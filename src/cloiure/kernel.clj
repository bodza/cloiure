(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(java-ns cloiure.lang.AFn

#_abstract
(class-ns AFn (§ implements IFn)
    (§ method Object call()
        (ß invoke())
    )

    (§ method void run()
        (ß invoke())
        nil
    )

    (§ method Object invoke()
        (ß throwArity(0))
    )

    (§ method Object invoke(Object arg1)
        (ß throwArity(1))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß throwArity(2))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß throwArity(3))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß throwArity(4))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß throwArity(5))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß throwArity(6))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß throwArity(7))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß throwArity(8))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß throwArity(9))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß throwArity(10))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß throwArity(11))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß throwArity(12))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß throwArity(13))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß throwArity(14))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß throwArity(15))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß throwArity(16))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß throwArity(17))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß throwArity(18))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß throwArity(19))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß throwArity(20))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
        (ß throwArity(21))
    )

    (§ method Object applyTo(ISeq arglist)
        (ß applyToHelper(this, Util.ret1(arglist, arglist = nil)))
    )

    (§ defn Object applyToHelper(IFn ifn, ISeq arglist)
        (§ switch (ß RT.boundedLength(arglist, 20))
            (§ case 0)
            (do
                (ß arglist = nil)
                (ß ifn.invoke())
            )
            (§ case 1)
            (do
                (ß ifn.invoke(Util.ret1(arglist.first(), arglist = nil)))
            )
            (§ case 2)
            (do
                (ß ifn.invoke(arglist.first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 3)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 4)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 5)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 6)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 7)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 8)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 9)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 10)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 11)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 12)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 13)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 14)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 15)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 16)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 17)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 18)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 19)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ case 20)
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil)))
            )
            (§ default )
            (do
                (ß ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        RT.seqToArray(Util.ret1(arglist.next(), arglist = nil))))
            )
        )
    )

    (§ method Object throwArity(int n)
        (let [#_"String" name (ß getClass().getSimpleName())]
            (throw (ß new ArityException(n, Compiler.demunge(name))))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    #_volatile
    (§ field MethodImplCache __methodImplCache)

    (§ method IPersistentMap meta()
        nil
    )

    (§ method IObj withMeta(IPersistentMap meta)
        (ß new RestFn()
            (§ reify
                #_protected
                (§ method Object doInvoke(Object args)
                    (ß AFunction.this.applyTo((ISeq) args))
                )

                (§ method IPersistentMap meta()
                    meta
                )

                (§ method IObj withMeta(IPersistentMap meta)
                    (ß AFunction.this.withMeta(meta))
                )

                (§ method int getRequiredArity()
                    0
                )
            )
        )
    )

    (§ method int compare(Object o1, Object o2)
        (let [#_"Object" o (ß invoke(o1, o2))]
            (when (ß o instanceof Boolean)
                (when (ß RT.booleanCast(o))
                    (§ return -1)
                )
                (§ return (ß RT.booleanCast(invoke(o2, o1)) ? 1 :or 0))
            )

            (let [#_"Number" n (ß (Number) o)]
                (ß n.intValue())
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Agent (§ extends ARef)
    (class-ns ActionQueue
        (§ field IPersistentStack q)
        (§ field Throwable error) ;; non-null indicates fail state
        (§ def ActionQueue EMPTY = new ActionQueue(PersistentQueue.EMPTY, nil))

        (§ constructor ActionQueue(IPersistentStack q, Throwable error)
            (ß this.q = q)
            (ß this.error = error)
            this
        )
    )

    (§ def Keyword CONTINUE = Keyword.intern(nil, "continue"))
    (§ def Keyword FAIL = Keyword.intern(nil, "fail"))

    #_volatile
    (§ field Object state)
    (§ field AtomicReference<ActionQueue> aq = new AtomicReference<ActionQueue>(ActionQueue.EMPTY))

    #_volatile
    (§ field Keyword errorMode = CONTINUE)
    #_volatile
    (§ field IFn errorHandler = nil)

    (§ def- AtomicLong sendThreadPoolCounter = new AtomicLong(0))

    (§ def- AtomicLong sendOffThreadPoolCounter = new AtomicLong(0))

    #_volatile
    (§ def ExecutorService pooledExecutor = Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter)))

    #_volatile
    (§ def ExecutorService soloExecutor = Executors.newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter)))

    (§ def ThreadLocal<IPersistentVector> nested = new ThreadLocal<IPersistentVector>())

    (§ defn- ThreadFactory createThreadFactory(String format, AtomicLong threadPoolCounter)
        (ß new ThreadFactory()
            (§ reify
                (§ method Thread newThread(Runnable runnable)
                    (let [#_"Thread" thread (ß new Thread(runnable))]
                        (ß thread.setName(String.format(format, threadPoolCounter.getAndIncrement())))
                        thread
                    )
                )
            )
        )
    )

    (§ defn void shutdown()
        (ß soloExecutor.shutdown())
        (ß pooledExecutor.shutdown())
        nil
    )

    (class-ns Action (§ implements Runnable)
        (§ field Agent agent)
        (§ field IFn fn)
        (§ field ISeq args)
        (§ field Executor exec)

        (§ constructor Action(Agent agent, IFn fn, ISeq args, Executor exec)
            (ß this.agent = agent)
            (ß this.args = args)
            (ß this.fn = fn)
            (ß this.exec = exec)
            this
        )

        (§ method void execute()
            (try
                (ß exec.execute(this))
                (catch Throwable error
                    (when (ß agent.errorHandler != nil)
                        (try
                            (ß agent.errorHandler.invoke(agent, error))
                            (catch Throwable e
                                ;; ignore errorHandler errors
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn void doRun(Action action)
            (try
                (ß nested.set(PersistentVector.EMPTY))

                (let [#_"Throwable" error nil]
                    (try
                        (let [#_"Object" oldval (ß action.agent.state)]
                            (let [#_"Object" newval (ß  action.fn.applyTo(RT.cons(action.agent.state, action.args)))]
                                (ß action.agent.setState(newval))
                                (ß action.agent.notifyWatches(oldval, newval))
                            )
                        )
                        (catch Throwable e
                            (ß error = e)
                        )
                    )

                    (if (ß error == nil)
                        (do
                            (ß releasePendingSends())
                        )
                        (do
                            (ß nested.set(nil)) ;; allow errorHandler to send
                            (when (ß action.agent.errorHandler != nil)
                                (try
                                    (ß action.agent.errorHandler.invoke(action.agent, error))
                                    (catch Throwable e
                                        ;; ignore errorHandler errors
                                    )
                                )
                            )
                            (when (ß action.agent.errorMode == CONTINUE)
                                (ß error = nil)
                            )
                        )
                    )

                    (let [#_"boolean" popped false]
                        (let [#_"ActionQueue" next nil]
                            (while (ß !popped)
                                (let [#_"ActionQueue" prior (ß action.agent.aq.get())]
                                    (ß next = new ActionQueue(prior.q.pop(), error))
                                    (ß popped = action.agent.aq.compareAndSet(prior, next))
                                )
                            )

                            (when (ß error == nil && next.q.count() > 0)
                                (ß ((Action) next.q.peek()).execute())
                            )
                        )
                    )
                )
                (finally
                    (ß nested.set(nil))
                )
            )
            nil
        )

        (§ method void run()
            (ß doRun(this))
            nil
        )
    )

    (§ constructor Agent(Object state)
        (§ this(state, nil))
        this
    )

    (§ constructor Agent(Object state, IPersistentMap meta)
        (§ super(meta))
        (ß setState(state))
        this
    )

    (§ method boolean setState(Object newState)
        (ß validate(newState))
        (let [#_"boolean" ret (ß (state != newState))]
            (ß state = newState)
            ret
        )
    )

    (§ method Object deref()
        state
    )

    (§ method Throwable getError()
        (ß aq.get().error)
    )

    (§ method void setErrorMode(Keyword k)
        (ß errorMode = k)
        nil
    )

    (§ method Keyword getErrorMode()
        errorMode
    )

    (§ method void setErrorHandler(IFn f)
        (ß errorHandler = f)
        nil
    )

    (§ method IFn getErrorHandler()
        errorHandler
    )

    (§ method Object restart(Object newState, boolean clearActions)
        (§ sync this
            (when (ß getError() == nil)
                (throw (ß Util.runtimeException("Agent does not need a restart")))
            )
            (ß validate(newState))
            (ß state = newState)

            (if clearActions
                (do
                    (ß aq.set(ActionQueue.EMPTY))
                )
                (do
                    (let [#_"boolean" restarted false]
                        (let [#_"ActionQueue" prior nil]
                            (while (ß !restarted)
                                (ß prior = aq.get())
                                (ß restarted = aq.compareAndSet(prior, new ActionQueue(prior.q, nil)))
                            )

                            (when (ß prior.q.count() > 0)
                                (ß ((Action) prior.q.peek()).execute())
                            )
                        )
                    )
                )
            )

            newState
        )
    )

    (§ method Object dispatch(IFn fn, ISeq args, Executor exec)
        (let [#_"Throwable" error (ß getError())]
            (when (ß error != nil)
                (throw (ß Util.runtimeException("Agent is failed, needs restart", error)))
            )
            (let [#_"Action" action (ß new Action(this, fn, args, exec))]
                (ß dispatchAction(action))

                this
            )
        )
    )

    (§ defn void dispatchAction(Action action)
        (let [#_"LockingTransaction" trans (ß LockingTransaction.getRunning())]
            (cond (ß trans != nil)
                (do
                    (ß trans.enqueue(action))
                )
                (ß nested.get() != nil)
                (do
                    (ß nested.set(nested.get().cons(action)))
                )
                :else
                (do
                    (ß action.agent.enqueue(action))
                )
            )
            nil
        )
    )

    (§ method void enqueue(Action action)
        (let [#_"boolean" queued false]
            (let [#_"ActionQueue" prior nil]
                (while (ß !queued)
                    (ß prior = aq.get())
                    (ß queued = aq.compareAndSet(prior, new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error)))
                )

                (when (ß prior.q.count() == 0 && prior.error == nil)
                    (ß action.execute())
                )
                nil
            )
        )
    )

    (§ method int getQueueCount()
        (ß aq.get().q.count())
    )

    (§ defn int releasePendingSends()
        (let [#_"IPersistentVector" sends (ß nested.get())]
            (when (ß sends == nil)
                (§ return 0)
            )
            (loop-when-recur [(ß int i = 0)] (ß i < sends.count()) [(ß i++)]
                (let [#_"Action" a (ß (Action) sends.valAt(i))]
                    (ß a.agent.enqueue(a))
                )
            )
            (ß nested.set(PersistentVector.EMPTY))
            (ß sends.count())
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    (§ method Object nth(int i)
        (cond (ß i == 0)
            (do
                (ß key())
            )
            (ß i == 1)
            (do
                (ß val())
            )
            :else
            (do
                (throw (ß new IndexOutOfBoundsException()))
            )
        )
    )

    (§ method- IPersistentVector asVector()
        (ß LazilyPersistentVector.createOwning(key(), val()))
    )

    (§ method IPersistentVector assocN(int i, Object val)
        (ß asVector().assocN(i, val))
    )

    (§ method int count()
        2
    )

    (§ method ISeq seq()
        (ß asVector().seq())
    )

    (§ method IPersistentVector cons(Object o)
        (ß asVector().cons(o))
    )

    (§ method IPersistentCollection empty()
        nil
    )

    (§ method IPersistentStack pop()
        (ß LazilyPersistentVector.createOwning(key()))
    )

    (§ method Object setValue(Object value)
        (throw (ß new UnsupportedOperationException()))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)

    (§ method String toString()
        (ß RT.printString(this))
    )

    (§ method IPersistentCollection cons(Object o)
        (cond (ß o instanceof Map.Entry)
            (do
                (let [(ß Map.Entry e = (Map.Entry) o)]
                    (§ return (ß assoc(e.getKey(), e.getValue())))
                )
            )
            (ß o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
                    (when (ß v.count() != 2)
                        (throw (ß new IllegalArgumentException("Vector arg to map conj must be a pair")))
                    )
                    (§ return (ß assoc(v.nth(0), v.nth(1))))
                )
            )
        )

        (let [#_"IPersistentMap" ret this]
            (loop-when-recur [(ß ISeq es = RT.seq(o))] (ß es != nil) [(ß es = es.next())]
                (let [(ß Map.Entry e = (Map.Entry) es.first())]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            ret
        )
    )

    (§ method boolean equals(Object obj)
        (ß mapEquals(this, obj))
    )

    (§ defn boolean mapEquals(IPersistentMap m1, Object obj)
        (when (ß m1 == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Map))
            (§ return false)
        )
        (let [#_"Map" m (ß (Map) obj)]
            (when (ß m.size() != m1.count())
                (§ return false)
            )

            (loop-when-recur [(ß ISeq s = m1.seq())] (ß s != nil) [(ß s = s.next())]
                (let [(ß Map.Entry e = (Map.Entry) s.first())]
                    (let [#_"boolean" found (ß m.containsKey(e.getKey()))]
                        (when (ß !found || !Util.equals(e.getValue(), m.get(e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    (§ method boolean equiv(Object obj)
        (when (ß !(obj instanceof Map))
            (§ return false)
        )
        (when (ß obj instanceof IPersistentMap && !(obj instanceof MapEquivalence))
            (§ return false)
        )

        (let [#_"Map" m (ß (Map) obj)]
            (when (ß m.size() != size())
                (§ return false)
            )

            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                (let [(ß Map.Entry e = (Map.Entry) s.first())]
                    (let [#_"boolean" found (ß m.containsKey(e.getKey()))]
                        (when (ß !found || !Util.equiv(e.getValue(), m.get(e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    (§ method int hashCode()
        (let [#_"int" cached (ß this._hash)]
            (when (ß cached == 0)
                (ß this._hash = cached = mapHash(this))
            )
            cached
        )
    )

    (§ defn int mapHash(IPersistentMap m)
        (let [#_"int" hash 0]
            (loop-when-recur [(ß ISeq s = m.seq())] (ß s != nil) [(ß s = s.next())]
                (let [(ß Map.Entry e = (Map.Entry) s.first())]
                    (ß hash += ((e.getKey() == nil) ? 0 :or e.getKey().hashCode()) :xor ((e.getValue() == nil) ? 0 :or e.getValue().hashCode()))
                )
            )
            hash
        )
    )

    (§ method int hasheq()
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (ß this._hasheq = cached = Murmur3.hashUnordered(this))
            )
            cached
        )
    )

    (§ defn int mapHasheq(IPersistentMap m)
        (ß Murmur3.hashUnordered(m))
    )

    (class-ns KeySeq (§ extends ASeq)
        (§ field ISeq seq)
        (§ field Iterable iterable)

        (§ defn KeySeq create(ISeq seq)
            (when (ß seq == nil)
                (§ return nil)
            )
            (ß new KeySeq(seq, nil))
        )

        (§ defn KeySeq createFromMap(IPersistentMap map)
            (when (ß map == nil)
                (§ return nil)
            )
            (let [#_"ISeq" seq (ß map.seq())]
                (when (ß seq == nil)
                    (§ return nil)
                )
                (ß new KeySeq(seq, map))
            )
        )

        (§ constructor- KeySeq(ISeq seq, Iterable iterable)
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ constructor- KeySeq(IPersistentMap meta, ISeq seq, Iterable iterable)
            (§ super(meta))
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ method Object first()
            (ß ((Map.Entry) seq.first()).getKey())
        )

        (§ method ISeq next()
            (ß create(seq.next()))
        )

        (§ method KeySeq withMeta(IPersistentMap meta)
            (ß new KeySeq(meta, seq, iterable))
        )

        (§ method Iterator iterator()
            (when (ß iterable == nil)
                (§ return (ß super.iterator()))
            )

            (when (ß iterable instanceof IMapIterable)
                (§ return (ß ((IMapIterable)iterable).keyIterator()))
            )

            (let [#_"Iterator" mapIter (ß iterable.iterator())]
                (ß new Iterator()
                    (§ reify
                        (§ method boolean hasNext()
                            (ß mapIter.hasNext())
                        )

                        (§ method Object next()
                            (ß ((Map.Entry)mapIter.next()).getKey())
                        )

                        (§ method void remove()
                            (throw (ß new UnsupportedOperationException()))
                        )
                    )
                )
            )
        )
    )

    (class-ns ValSeq (§ extends ASeq)
        (§ field ISeq seq)
        (§ field Iterable iterable)

        (§ defn ValSeq create(ISeq seq)
            (when (ß seq == nil)
                (§ return nil)
            )
            (ß new ValSeq(seq, nil))
        )

        (§ defn ValSeq createFromMap(IPersistentMap map)
            (when (ß map == nil)
                (§ return nil)
            )
            (let [#_"ISeq" seq (ß map.seq())]
                (when (ß seq == nil)
                    (§ return nil)
                )
                (ß new ValSeq(seq, map))
            )
        )

        (§ constructor- ValSeq(ISeq seq, Iterable iterable)
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ constructor- ValSeq(IPersistentMap meta, ISeq seq, Iterable iterable)
            (§ super(meta))
            (ß this.seq = seq)
            (ß this.iterable = iterable)
            this
        )

        (§ method Object first()
            (ß ((Map.Entry) seq.first()).getValue())
        )

        (§ method ISeq next()
            (ß create(seq.next()))
        )

        (§ method ValSeq withMeta(IPersistentMap meta)
            (ß new ValSeq(meta, seq, iterable))
        )

        (§ method Iterator iterator()
            (when (ß iterable == nil)
                (§ return (ß super.iterator()))
            )

            (when (ß iterable instanceof IMapIterable)
                (§ return (ß ((IMapIterable)iterable).valIterator()))
            )

            (let [#_"Iterator" mapIter (ß iterable.iterator())]
                (ß new Iterator()
                    (§ reify
                        (§ method boolean hasNext()
                            (ß mapIter.hasNext())
                        )

                        (§ method Object next()
                            (ß ((Map.Entry)mapIter.next()).getValue())
                        )

                        (§ method void remove()
                            (throw (ß new UnsupportedOperationException()))
                        )
                    )
                )
            )
        )
    )

    (§ def IFn MAKE_ENTRY = new AFn()
        (§ reify
            (§ method Object invoke(Object key, Object val)
                (ß MapEntry.create(key, val))
            )
        )
    )

    (§ def IFn MAKE_KEY = new AFn()
        (§ reify
            (§ method Object invoke(Object key, Object val)
                key
            )
        )
    )

    (§ def IFn MAKE_VAL = new AFn()
        (§ reify
            (§ method Object invoke(Object key, Object val)
                val
            )
        )
    )

    (§ method Object invoke(Object arg1)
        (ß valAt(arg1))
    )

    (§ method Object invoke(Object arg1, Object notFound)
        (ß valAt(arg1, notFound))
    )

    (§ method void clear()
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean containsValue(Object value)
        (ß values().contains(value))
    )

    (§ method Set entrySet()
        (ß new AbstractSet()
            (§ reify
                (§ method Iterator iterator()
                    (ß APersistentMap.this.iterator())
                )

                (§ method int size()
                    (ß count())
                )

                (§ method int hashCode()
                    (ß APersistentMap.this.hashCode())
                )

                (§ method boolean contains(Object o)
                    (when (ß o instanceof Entry)
                        (let [#_"Entry" e (ß (Entry) o)]
                            (let [#_"Entry" found (ß entryAt(e.getKey()))]
                                (when (ß found != nil && Util.equals(found.getValue(), e.getValue()))
                                    (§ return true)
                                )
                            )
                        )
                    )
                    false
                )
            )
        )
    )

    (§ method Object get(Object key)
        (ß valAt(key))
    )

    (§ method boolean isEmpty()
        (ß (count() == 0))
    )

    (§ method Set keySet()
        (ß new AbstractSet()
            (§ reify
                (§ method Iterator iterator()
                    (let [#_"Iterator" mi (ß APersistentMap.this.iterator())]
                        (ß new Iterator()
                            (§ reify
                                (§ method boolean hasNext()
                                    (ß mi.hasNext())
                                )

                                (§ method Object next()
                                    (let [#_"Entry" e (ß (Entry) mi.next())]
                                        (ß e.getKey())
                                    )
                                )

                                (§ method void remove()
                                    (throw (ß new UnsupportedOperationException()))
                                )
                            )
                        )
                    )
                )

                (§ method int size()
                    (ß count())
                )

                (§ method boolean contains(Object o)
                    (ß APersistentMap.this.containsKey(o))
                )
            )
        )
    )

    (§ method Object put(Object key, Object value)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method void putAll(Map t)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method Object remove(Object key)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method int size()
        (ß count())
    )

    (§ method Collection values()
        (ß new AbstractCollection()
            (§ reify
                (§ method Iterator iterator()
                    (let [#_"Iterator" mi (ß APersistentMap.this.iterator())]
                        (ß new Iterator()
                            (§ reify
                                (§ method boolean hasNext()
                                    (ß mi.hasNext())
                                )

                                (§ method Object next()
                                    (let [#_"Entry" e (ß (Entry) mi.next())]
                                        (ß e.getValue())
                                    )
                                )

                                (§ method void remove()
                                    (throw (ß new UnsupportedOperationException()))
                                )
                            )
                        )
                    )
                )

                (§ method int size()
                    (ß count())
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)
    (§ field IPersistentMap impl)

    #_protected
    (§ constructor APersistentSet(IPersistentMap impl)
        (ß this.impl = impl)
        this
    )

    (§ method String toString()
        (ß RT.printString(this))
    )

    (§ method boolean contains(Object key)
        (ß impl.containsKey(key))
    )

    (§ method Object get(Object key)
        (ß impl.valAt(key))
    )

    (§ method int count()
        (ß impl.count())
    )

    (§ method ISeq seq()
        (ß RT.keys(impl))
    )

    (§ method Object invoke(Object arg1)
        (ß get(arg1))
    )

    (§ method boolean equals(Object obj)
        (ß setEquals(this, obj))
    )

    (§ defn boolean setEquals(IPersistentSet s1, Object obj)
        (when (ß s1 == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Set))
            (§ return false)
        )
        (let [#_"Set" m (ß (Set) obj)]
            (when (ß m.size() != s1.count())
                (§ return false)
            )

            (doseq [#_"Object" aM m]
                (when (ß !s1.contains(aM))
                    (§ return false)
                )
            )

            true
        )
    )

    (§ method boolean equiv(Object obj)
        (when (ß !(obj instanceof Set))
            (§ return false)
        )

        (let [#_"Set" m (ß (Set) obj)]
            (when (ß m.size() != size())
                (§ return false)
            )

            (doseq [#_"Object" aM m]
                (when (ß !contains(aM))
                    (§ return false)
                )
            )

            true
        )
    )

    (§ method int hashCode()
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                    (let [#_"Object" e (ß s.first())]
                        (ß hash +=  Util.hash(e))
                    )
                )
                (ß this._hash = hash)
            )
            hash
        )
    )

    (§ method int hasheq()
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (ß this._hasheq = cached = Murmur3.hashUnordered(this))
            )
            cached
        )
    )

    (§ method Object[] toArray()
        (ß RT.seqToArray(seq()))
    )

    (§ method boolean add(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean remove(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean addAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method void clear()
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean retainAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean removeAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean containsAll(Collection c)
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (count() == 0))
    )

    (§ method Iterator iterator()
        (if (ß impl instanceof IMapIterable)
            (do
                (ß ((IMapIterable)impl).keyIterator())
            )
            (do
                (ß new Iterator()
                    (§ reify
                        (§ field- Iterator iter = impl.iterator())

                        (§ method boolean hasNext()
                            (ß iter.hasNext())
                        )

                        (§ method Object next()
                            (ß ((IMapEntry)iter.next()).key())
                        )

                        (§ method void remove()
                            (throw (ß new UnsupportedOperationException()))
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (§ field int _hash)
    (§ field int _hasheq)

    (§ method String toString()
        (ß RT.printString(this))
    )

    (§ method ISeq seq()
        (when (ß count() > 0)
            (§ return (ß new Seq(this, 0)))
        )
        nil
    )

    (§ method ISeq rseq()
        (when (ß count() > 0)
            (§ return (ß new RSeq(this, count() - 1)))
        )
        nil
    )

    (§ defn boolean doEquals(IPersistentVector v, Object obj)
        (cond (ß obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ov (ß (IPersistentVector) obj)]
                    (when (ß ov.count() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++)]
                        (when (ß !Util.equals(v.nth(i), ov.nth(i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß obj instanceof List)
            (do
                (let [#_"Collection" ma (ß (Collection) obj)]
                    (when (ß ma.size() != v.count() || ma.hashCode() != v.hashCode())
                        (§ return false)
                    )
                    (loop-when-recur [(ß Iterator i1 = ((List) v).iterator(), i2 = ma.iterator())] (ß i1.hasNext()) [(ß )]
                        (when (ß !Util.equals(i1.next(), i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ms (ß RT.seq(obj))]
                    (loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++, ms = ms.next())]
                        (when (ß ms == nil || !Util.equals(v.nth(i), ms.first()))
                            (§ return false)
                        )
                    )
                    (when (ß ms != nil)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    (§ defn boolean doEquiv(IPersistentVector v, Object obj)
        (cond (ß obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ov (ß (IPersistentVector) obj)]
                    (when (ß ov.count() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++)]
                        (when (ß !Util.equiv(v.nth(i), ov.nth(i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß obj instanceof List)
            (do
                (let [#_"Collection" ma (ß (Collection) obj)]
                    (when (ß ma.size() != v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(ß Iterator i1 = ((List) v).iterator(), i2 = ma.iterator())] (ß i1.hasNext()) [(ß )]
                        (when (ß !Util.equiv(i1.next(), i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ms (ß RT.seq(obj))]
                    (loop-when-recur [(ß int i = 0)] (ß i < v.count()) [(ß i++, ms = ms.next())]
                        (when (ß ms == nil || !Util.equiv(v.nth(i), ms.first()))
                            (§ return false)
                        )
                    )
                    (when (ß ms != nil)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    (§ method boolean equals(Object obj)
        (when (ß obj == this)
            (§ return true)
        )
        (ß doEquals(this, obj))
    )

    (§ method boolean equiv(Object obj)
        (when (ß obj == this)
            (§ return true)
        )
        (ß doEquiv(this, obj))
    )

    (§ method int hashCode()
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (ß hash = 1)
                (loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
                    (let [#_"Object" obj (ß nth(i))]
                        (ß hash = 31 * hash + ((obj == nil) ? 0 :or obj.hashCode()))
                    )
                )
                (ß this._hash = hash)
            )
            hash
        )
    )

    (§ method int hasheq()
        (let [#_"int" hash (ß this._hasheq)]
            (when (ß hash == 0)
                (§ let [#_"int" n]
                    (ß hash = 1)

                    (loop-when-recur [(ß n = 0)] (ß n < count()) [(ß ++n)]
                        (ß hash = 31 * hash + Util.hasheq(nth(n)))
                    )

                    (ß this._hasheq = hash = Murmur3.mixCollHash(hash, n))
                )
            )
            hash
        )
    )

    (§ method Object get(int index)
        (ß nth(index))
    )

    (§ method Object nth(int i, Object notFound)
        (when (ß i >= 0 && i < count())
            (§ return (ß nth(i)))
        )
        notFound
    )

    (§ method Object remove(int i)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method int indexOf(Object o)
        (loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
            (when (ß Util.equiv(nth(i), o))
                (§ return i)
            )
        )
        -1
    )

    (§ method int lastIndexOf(Object o)
        (loop-when-recur [(ß int i = count() - 1)] (ß i >= 0) [(ß i--)]
            (when (ß Util.equiv(nth(i), o))
                (§ return i)
            )
        )
        -1
    )

    (§ method ListIterator listIterator()
        (ß listIterator(0))
    )

    (§ method ListIterator listIterator(int index)
        (ß new ListIterator()
            (§ reify
                (let [#_"int" nexti index]
                    (§ method boolean hasNext()
                        (ß (nexti < count()))
                    )

                    (§ method Object next()
                        (if (ß nexti < count())
                            (do
                                (ß nth(nexti++))
                            )
                            (do
                                (throw (ß new NoSuchElementException()))
                            )
                        )
                    )

                    (§ method boolean hasPrevious()
                        (ß (nexti > 0))
                    )

                    (§ method Object previous()
                        (if (ß nexti > 0)
                            (do
                                (ß nth(--nexti))
                            )
                            (do
                                (throw (ß new NoSuchElementException()))
                            )
                        )
                    )

                    (§ method int nextIndex()
                        nexti
                    )

                    (§ method int previousIndex()
                        (ß nexti - 1)
                    )

                    (§ method void remove()
                        (throw (ß new UnsupportedOperationException()))
                    )

                    (§ method void set(Object o)
                        (throw (ß new UnsupportedOperationException()))
                    )

                    (§ method void add(Object o)
                        (throw (ß new UnsupportedOperationException()))
                    )
                )
            )
        )
    )

    (§ method Iterator rangedIterator(int start, int end)
        (ß new Iterator()
            (§ reify
                (let [#_"int" i start]
                    (§ method boolean hasNext()
                        (ß (i < end))
                    )

                    (§ method Object next()
                        (if (ß i < end)
                            (do
                                (ß nth(i++))
                            )
                            (do
                                (throw (ß new NoSuchElementException()))
                            )
                        )
                    )

                    (§ method void remove()
                        (throw (ß new UnsupportedOperationException()))
                    )
                )
            )
        )
    )

    (§ method List subList(int fromIndex, int toIndex)
        (ß (List) RT.subvec(this, fromIndex, toIndex))
    )

    (§ method Object set(int i, Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method void add(int i, Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean addAll(int i, Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method Object invoke(Object arg1)
        (when (ß Util.isInteger(arg1))
            (§ return (ß nth(((Number) arg1).intValue())))
        )
        (throw (ß new IllegalArgumentException("Key must be integer")))
    )

    (§ method Iterator iterator()
        ;; todo - something more efficient
        (ß new Iterator()
            (§ reify
                (let [#_"int" i 0]
                    (§ method boolean hasNext()
                        (ß (i < count()))
                    )

                    (§ method Object next()
                        (if (ß i < count())
                            (do
                                (ß nth(i++))
                            )
                            (do
                                (throw (ß new NoSuchElementException()))
                            )
                        )
                    )

                    (§ method void remove()
                        (throw (ß new UnsupportedOperationException()))
                    )
                )
            )
        )
    )

    (§ method Object peek()
        (when (ß count() > 0)
            (§ return (ß nth(count() - 1)))
        )
        nil
    )

    (§ method boolean containsKey(Object key)
        (when (ß !(Util.isInteger(key)))
            (§ return false)
        )
        (let [#_"int" i (ß ((Number) key).intValue())]
            (ß (i >= 0 && i < count()))
        )
    )

    (§ method IMapEntry entryAt(Object key)
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (when (ß i >= 0 && i < count())
                    (§ return (ß (IMapEntry) MapEntry.create(key, nth(i))))
                )
            )
        )
        nil
    )

    (§ method IPersistentVector assoc(Object key, Object val)
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (§ return (ß assocN(i, val)))
            )
        )
        (throw (ß new IllegalArgumentException("Key must be integer")))
    )

    (§ method Object valAt(Object key, Object notFound)
        (when (ß Util.isInteger(key))
            (let [#_"int" i (ß ((Number) key).intValue())]
                (when (ß i >= 0 && i < count())
                    (§ return (ß nth(i)))
                )
            )
        )
        notFound
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method Object[] toArray()
        (let [#_"Object[]" ret (ß new Object[count()])]
            (loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
                (ß ret[i] = nth(i))
            )
            ret
        )
    )

    (§ method boolean add(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean remove(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean addAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method void clear()
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean retainAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean removeAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean containsAll(Collection c)
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (count() == 0))
    )

    (§ method boolean contains(Object o)
        (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    (§ method int length()
        (ß count())
    )

    (§ method int compareTo(Object o)
        (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
            (cond (ß count() < v.count())
                (do
                    (§ return -1)
                )
                (ß count() > v.count())
                (do
                    (§ return 1)
                )
            )
            (loop-when-recur [(ß int i = 0)] (ß i < count()) [(ß i++)]
                (let [#_"int" c (ß Util.compare(nth(i), v.nth(i)))]
                    (when (ß c != 0)
                        (§ return c)
                    )
                )
            )
            0
        )
    )

    (class-ns Seq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        ;; todo - something more efficient
        (§ field IPersistentVector v)
        (§ field int i)

        (§ constructor Seq(IPersistentVector v, int i)
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        (§ constructor Seq(IPersistentMap meta, IPersistentVector v, int i)
            (§ super(meta))
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß v.nth(i))
        )

        (§ method ISeq next()
            (when (ß i + 1 < v.count())
                (§ return (ß new APersistentVector.Seq(v, i + 1)))
            )
            nil
        )

        (§ method int index()
            i
        )

        (§ method int count()
            (ß v.count() - i)
        )

        (§ method APersistentVector.Seq withMeta(IPersistentMap meta)
            (ß new APersistentVector.Seq(meta, v, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß v.nth(i))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < v.count()) [(ß x++)]
                    (ß ret = f.invoke(ret, v.nth(x)))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, v.nth(i)))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < v.count()) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, v.nth(x)))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )
    )

    (class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
        (§ field IPersistentVector v)
        (§ field int i)

        (§ constructor RSeq(IPersistentVector vector, int i)
            (ß this.v = vector)
            (ß this.i = i)
            this
        )

        (§ constructor RSeq(IPersistentMap meta, IPersistentVector v, int i)
            (§ super(meta))
            (ß this.v = v)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß v.nth(i))
        )

        (§ method ISeq next()
            (when (ß i > 0)
                (§ return (ß new APersistentVector.RSeq(v, i - 1)))
            )
            nil
        )

        (§ method int index()
            i
        )

        (§ method int count()
            (ß i + 1)
        )

        (§ method APersistentVector.RSeq withMeta(IPersistentMap meta)
            (ß new APersistentVector.RSeq(meta, v, i))
        )
    )

    (class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
        (§ field IPersistentVector v)
        (§ field int start)
        (§ field int end)
        (§ field IPersistentMap _meta)

        (§ constructor SubVector(IPersistentMap meta, IPersistentVector v, int start, int end)
            (ß this._meta = meta)

            (when (ß v instanceof APersistentVector.SubVector)
                (let [(ß APersistentVector.SubVector sv = (APersistentVector.SubVector) v)]
                    (ß start += sv.start)
                    (ß end += sv.start)
                    (ß v = sv.v)
                )
            )
            (ß this.v = v)
            (ß this.start = start)
            (ß this.end = end)
            this
        )

        (§ method Iterator iterator()
            (when (ß v instanceof APersistentVector)
                (§ return (ß ((APersistentVector)v).rangedIterator(start, end)))
            )
            (ß super.iterator())
        )

        (§ method Object nth(int i)
            (when (ß (start + i >= end) || (i < 0))
                (throw (ß new IndexOutOfBoundsException()))
            )
            (ß v.nth(start + i))
        )

        (§ method IPersistentVector assocN(int i, Object val)
            (cond (ß start + i > end)
                (do
                    (throw (ß new IndexOutOfBoundsException()))
                )
                (ß start + i == end)
                (do
                    (§ return (ß cons(val)))
                )
            )
            (ß new SubVector(_meta, v.assocN(start + i, val), start, end))
        )

        (§ method int count()
            (ß end - start)
        )

        (§ method IPersistentVector cons(Object o)
            (ß new SubVector(_meta, v.assocN(end, o), start, end + 1))
        )

        (§ method IPersistentCollection empty()
            (ß PersistentVector.EMPTY.withMeta(meta()))
        )

        (§ method IPersistentStack pop()
            (when (ß end - 1 == start)
                (§ return (ß PersistentVector.EMPTY))
            )
            (ß new SubVector(_meta, v, start, end - 1))
        )

        (§ method SubVector withMeta(IPersistentMap meta)
            (when (ß meta == _meta)
                (§ return this)
            )
            (ß new SubVector(meta, v, start, end))
        )

        (§ method IPersistentMap meta()
            (ß _meta)
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    #_protected
    #_volatile
    (§ field IFn validator = nil)
    #_volatile
    (§ field- IPersistentMap watches = PersistentHashMap.EMPTY)

    (§ constructor ARef()
        (§ super())
        this
    )

    (§ constructor ARef(IPersistentMap meta)
        (§ super(meta))
        this
    )

    (§ method void validate(IFn vf, Object val)
        (try
            (when (ß vf != nil && !RT.booleanCast(vf.invoke(val)))
                (throw (ß new IllegalStateException("Invalid reference state")))
            )
            (catch RuntimeException re
                (throw re)
            )
            (catch Exception e
                (throw (ß new IllegalStateException("Invalid reference state", e)))
            )
        )
        nil
    )

    (§ method void validate(Object val)
        (ß validate(validator, val))
        nil
    )

    (§ method void setValidator(IFn vf)
        (ß validate(vf, deref()))
        (ß validator = vf)
        nil
    )

    (§ method IFn getValidator()
        validator
    )

    (§ method IPersistentMap getWatches()
        watches
    )

    (§ method IRef addWatch(Object key, IFn callback)
        (§ sync this
            (ß watches = watches.assoc(key, callback))
            this
        )
    )

    (§ method IRef removeWatch(Object key)
        (§ sync this
            (ß watches = watches.without(key))
            this
        )
    )

    (§ method void notifyWatches(Object oldval, Object newval)
        (let [#_"IPersistentMap" ws watches]
            (when (ß ws.count() > 0)
                (loop-when-recur [(ß ISeq s = ws.seq())] (ß s != nil) [(ß s = s.next())]
                    (let [(ß Map.Entry e = (Map.Entry) s.first())]
                        (let [#_"IFn" fn (ß (IFn) e.getValue())]
                            (when (ß fn != nil)
                                (ß fn.invoke(e.getKey(), this, oldval, newval))
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (§ field- IPersistentMap _meta)

    (§ constructor AReference()
        (§ this(nil))
        this
    )

    (§ constructor AReference(IPersistentMap meta)
        (ß _meta = meta)
        this
    )

    (§ method IPersistentMap meta()
        (§ sync this
            (ß _meta)
        )
    )

    (§ method IPersistentMap alterMeta(IFn alter, ISeq args)
        (§ sync this
            (ß _meta = (IPersistentMap) alter.applyTo(new Cons(_meta, args)))
            (ß _meta)
        )
    )

    (§ method IPersistentMap resetMeta(IPersistentMap m)
        (§ sync this
            (ß _meta = m)
            m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (§ field int actual)

    (§ field String name)

    (§ constructor ArityException(int actual, String name)
        (§ this(actual, name, nil))
        this
    )

    (§ constructor ArityException(int actual, String name, Throwable cause)
        (§ super("Wrong number of args (" + actual + ") passed to: " + name, cause))
        (ß this.actual = actual)
        (ß this.name = name)
        this
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (§ field Object[] array)
    (§ field int off)
    (§ field int end)

    (§ constructor ArrayChunk(Object[] array)
        (§ this(array, 0, array.length))
        this
    )

    (§ constructor ArrayChunk(Object[] array, int off)
        (§ this(array, off, array.length))
        this
    )

    (§ constructor ArrayChunk(Object[] array, int off, int end)
        (ß this.array = array)
        (ß this.off = off)
        (ß this.end = end)
        this
    )

    (§ method Object nth(int i)
        (ß array[off + i])
    )

    (§ method Object nth(int i, Object notFound)
        (when (ß i >= 0 && i < count())
            (§ return (ß nth(i)))
        )
        notFound
    )

    (§ method int count()
        (ß end - off)
    )

    (§ method IChunk dropFirst()
        (when (ß off == end)
            (throw (ß new IllegalStateException("dropFirst of empty chunk")))
        )
        (ß new ArrayChunk(array, off + 1, end))
    )

    (§ method Object reduce(IFn f, Object start)
        (let [#_"Object" ret (ß f.invoke(start, array[off]))]
            (when (ß RT.isReduced(ret))
                (§ return ret)
            )
            (loop-when-recur [(ß int x = off + 1)] (ß x < end) [(ß x++)]
                (ß ret = f.invoke(ret, array[x]))
                (when (ß RT.isReduced(ret))
                    (§ return ret)
                )
            )
            ret
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(class-ns ArrayIter (§ implements Iterator)
    (§ field Object[] array)
    (§ field int i)

    (§ def Iterator EMPTY_ITERATOR = new Iterator()
        (§ reify
            (§ method boolean hasNext()
                false
            )

            (§ method Object next()
                (throw (ß new java.util.NoSuchElementException()))
            )

            (§ method void remove()
                (throw (ß new UnsupportedOperationException("remove() not supported")))
            )
        )
    )

    (§ defn Iterator create()
        (ß EMPTY_ITERATOR)
    )

    (§ defn Iterator create(Object... array)
        (when (ß array == nil || array.length == 0)
            (§ return (ß EMPTY_ITERATOR))
        )
        (ß new ArrayIter(array, 0))
    )

    (§ defn Iterator createFromObject(Object array)
        (when (ß array == nil || Array.getLength(array) == 0)
            (§ return (ß EMPTY_ITERATOR))
        )
        (let [#_"Class" aclass (ß array.getClass())]
            (when (ß aclass == int[].class)
                (§ return (ß new ArrayIter_int((int[]) array, 0)))
            )
            (when (ß aclass == float[].class)
                (§ return (ß new ArrayIter_float((float[]) array, 0)))
            )
            (when (ß aclass == double[].class)
                (§ return (ß new ArrayIter_double((double[]) array, 0)))
            )
            (when (ß aclass == long[].class)
                (§ return (ß new ArrayIter_long((long[]) array, 0)))
            )
            (when (ß aclass == byte[].class)
                (§ return (ß new ArrayIter_byte((byte[]) array, 0)))
            )
            (when (ß aclass == char[].class)
                (§ return (ß new ArrayIter_char((char[]) array, 0)))
            )
            (when (ß aclass == short[].class)
                (§ return (ß new ArrayIter_short((short[]) array, 0)))
            )
            (when (ß aclass == boolean[].class)
                (§ return (ß new ArrayIter_boolean((boolean[]) array, 0)))
            )
            (ß new ArrayIter(array, 0))
        )
    )

    (§ constructor ArrayIter(Object array, int i)
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    (§ method boolean hasNext()
        (ß (array != nil && i < array.length))
    )

    (§ method Object next()
        (when (ß array != nil && i < array.length)
            (§ return (ß array[i++]))
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    (§ method void remove()
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )

    (class-ns ArrayIter_int (§ implements Iterator<Long>)
        (§ field int[] array)
        (§ field int i)

        (§ constructor ArrayIter_int(int[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Long next()
            (when (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_float (§ implements Iterator<Double>)
        (§ field float[] array)
        (§ field int i)

        (§ constructor ArrayIter_float(float[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Double next()
            (when (ß array != nil && i < array.length)
                (§ return (ß Double.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_double (§ implements Iterator<Double>)
        (§ field double[] array)
        (§ field int i)

        (§ constructor ArrayIter_double(double[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Double next()
            (when (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_long (§ implements Iterator<Long>)
        (§ field long[] array)
        (§ field int i)

        (§ constructor ArrayIter_long(long[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Long next()
            (when (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_byte (§ implements Iterator<Byte>)
        (§ field byte[] array)
        (§ field int i)

        (§ constructor ArrayIter_byte(byte[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Byte next()
            (when (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_char (§ implements Iterator<Character>)
        (§ field char[] array)
        (§ field int i)

        (§ constructor ArrayIter_char(char[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Character next()
            (when (ß array != nil && i < array.length)
                (§ return (ß array[i++]))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_short (§ implements Iterator<Long>)
        (§ field short[] array)
        (§ field int i)

        (§ constructor ArrayIter_short(short[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Long next()
            (when (ß array != nil && i < array.length)
                (§ return (ß Long.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )

    (class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
        (§ field boolean[] array)
        (§ field int i)

        (§ constructor ArrayIter_boolean(boolean[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method boolean hasNext()
            (ß (array != nil && i < array.length))
        )

        (§ method Boolean next()
            (when (ß array != nil && i < array.length)
                (§ return (ß Boolean.valueOf(array[i++])))
            )
            (throw (ß new java.util.NoSuchElementException()))
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException("remove() not supported")))
        )
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ field Object[] array)
    (§ field int i)

    (§ defn ArraySeq create()
        nil
    )

    (§ defn ArraySeq create(Object... array)
        (when (ß array == nil || array.length == 0)
            (§ return nil)
        )
        (ß new ArraySeq(array, 0))
    )

    (§ defn ISeq createFromObject(Object array)
        (when (ß array == nil || Array.getLength(array) == 0)
            (§ return nil)
        )
        (let [#_"Class" aclass (ß array.getClass())]
            (when (ß aclass == int[].class)
                (§ return (ß new ArraySeq_int(nil, (int[]) array, 0)))
            )
            (when (ß aclass == float[].class)
                (§ return (ß new ArraySeq_float(nil, (float[]) array, 0)))
            )
            (when (ß aclass == double[].class)
                (§ return (ß new ArraySeq_double(nil, (double[]) array, 0)))
            )
            (when (ß aclass == long[].class)
                (§ return (ß new ArraySeq_long(nil, (long[]) array, 0)))
            )
            (when (ß aclass == byte[].class)
                (§ return (ß new ArraySeq_byte(nil, (byte[]) array, 0)))
            )
            (when (ß aclass == char[].class)
                (§ return (ß new ArraySeq_char(nil, (char[]) array, 0)))
            )
            (when (ß aclass == short[].class)
                (§ return (ß new ArraySeq_short(nil, (short[]) array, 0)))
            )
            (when (ß aclass == boolean[].class)
                (§ return (ß new ArraySeq_boolean(nil, (boolean[]) array, 0)))
            )
            (ß new ArraySeq(array, 0))
        )
    )

    (§ constructor ArraySeq(Object array, int i)
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    (§ constructor ArraySeq(IPersistentMap meta, Object array, int i)
        (§ super(meta))
        (ß this.i = i)
        (ß this.array = (Object[]) array)
        this
    )

    (§ method Object first()
        (when (ß array != nil)
            (§ return (ß array[i]))
        )
        nil
    )

    (§ method ISeq next()
        (when (ß array != nil && i + 1 < array.length)
            (§ return (ß new ArraySeq(array, i + 1)))
        )
        nil
    )

    (§ method int count()
        (when (ß array != nil)
            (§ return (ß array.length - i))
        )
        0
    )

    (§ method int index()
        i
    )

    (§ method ArraySeq withMeta(IPersistentMap meta)
        (ß new ArraySeq(meta, array, i))
    )

    (§ method Object reduce(IFn f)
        (when (ß array != nil)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                (§ return ret)
            )
        )
        nil
    )

    (§ method Object reduce(IFn f, Object start)
        (when (ß array != nil)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (§ return ret)
            )
        )
        nil
    )

    (§ method int indexOf(Object o)
        (when (ß array != nil)
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß Util.equals(o, array[j]))
                    (§ return (ß j - i))
                )
            )
        )
        -1
    )

    (§ method int lastIndexOf(Object o)
        (when (ß array != nil)
            (if (ß o == nil)
                (do
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß array[j] == nil)
                            (§ return (ß j - i))
                        )
                    )
                )
                (do
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß o.equals(array[j]))
                            (§ return (ß j - i))
                        )
                    )
                )
            )
        )
        -1
    )

    (class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field int[] array)
        (§ field int i)

        (§ constructor ArraySeq_int(IPersistentMap meta, int[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_int(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_int withMeta(IPersistentMap meta)
            (ß new ArraySeq_int(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        (§ method int indexOf(Object o)
            (when (ß o instanceof Number)
                (let [#_"int" k (ß ((Number) o).intValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß k == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        (§ method int lastIndexOf(Object o)
            (when (ß o instanceof Number)
                (let [#_"int" k (ß ((Number) o).intValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß k == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field float[] array)
        (§ field int i)

        (§ constructor ArraySeq_float(IPersistentMap meta, float[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß Numbers.num(array[i]))
        )

        (§ method ISeq next()
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_float(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_float withMeta(IPersistentMap meta)
            (ß new ArraySeq_float(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß Numbers.num(array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, Numbers.num(array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, Numbers.num(array[i])))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, Numbers.num(array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        (§ method int indexOf(Object o)
            (when (ß o instanceof Number)
                (let [#_"float" f (ß ((Number) o).floatValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß f == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (when (ß o instanceof Number)
                (let [#_"float" f (ß ((Number) o).floatValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß f == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field double[] array)
        (§ field int i)

        (§ constructor ArraySeq_double(IPersistentMap meta, double[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_double(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_double withMeta(IPersistentMap meta)
            (ß new ArraySeq_double(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        (§ method int indexOf(Object o)
            (when (ß o instanceof Number)
                (let [#_"double" d (ß ((Number) o).doubleValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß d == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        (§ method int lastIndexOf(Object o)
            (when (ß o instanceof Number)
                (let [#_"double" d (ß ((Number) o).doubleValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß d == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field long[] array)
        (§ field int i)

        (§ constructor ArraySeq_long(IPersistentMap meta, long[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß Numbers.num(array[i]))
        )

        (§ method ISeq next()
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_long(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_long withMeta(IPersistentMap meta)
            (ß new ArraySeq_long(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß Numbers.num(array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, Numbers.num(array[x])))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, Numbers.num(array[i])))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, Numbers.num(array[x])))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        (§ method int indexOf(Object o)
            (when (ß o instanceof Number)
                (let [#_"long" l (ß ((Number) o).longValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß l == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )

        (§ method int lastIndexOf(Object o)
            (when (ß o instanceof Number)
                (let [#_"long" l (ß ((Number) o).longValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß l == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )

            -1
        )
    )

    (class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field byte[] array)
        (§ field int i)

        (§ constructor ArraySeq_byte(IPersistentMap meta, byte[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_byte(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_byte withMeta(IPersistentMap meta)
            (ß new ArraySeq_byte(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        (§ method int indexOf(Object o)
            (when (ß o instanceof Byte)
                (let [#_"byte" b (ß ((Byte) o).byteValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (when (ß o instanceof Byte)
                (let [#_"byte" b (ß ((Byte) o).byteValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field char[] array)
        (§ field int i)

        (§ constructor ArraySeq_char(IPersistentMap meta, char[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_char(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_char withMeta(IPersistentMap meta)
            (ß new ArraySeq_char(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        (§ method int indexOf(Object o)
            (when (ß o instanceof Character)
                (let [#_"char" c (ß ((Character) o).charValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß c == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (when (ß o instanceof Character)
                (let [#_"char" c (ß ((Character) o).charValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß c == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field short[] array)
        (§ field int i)

        (§ constructor ArraySeq_short(IPersistentMap meta, short[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_short(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_short withMeta(IPersistentMap meta)
            (ß new ArraySeq_short(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        (§ method int indexOf(Object o)
            (when (ß o instanceof Short)
                (let [#_"short" s (ß ((Short) o).shortValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß s == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (when (ß o instanceof Short)
                (let [#_"short" s (ß ((Short) o).shortValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß s == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )

    (class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
        (§ field boolean[] array)
        (§ field int i)

        (§ constructor ArraySeq_boolean(IPersistentMap meta, boolean[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß array[i])
        )

        (§ method ISeq next()
            (when (ß i + 1 < array.length)
                (§ return (ß new ArraySeq_boolean(meta(), array, i + 1)))
            )
            nil
        )

        (§ method int count()
            (ß array.length - i)
        )

        (§ method int index()
            i
        )

        (§ method ArraySeq_boolean withMeta(IPersistentMap meta)
            (ß new ArraySeq_boolean(meta, array, i))
        )

        (§ method Object reduce(IFn f)
            (let [#_"Object" ret (ß array[i])]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (ß ret = f.invoke(ret, array[x]))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
                ret
            )
        )

        (§ method Object reduce(IFn f, Object start)
            (let [#_"Object" ret (ß f.invoke(start, array[i]))]
                (loop-when-recur [(ß int x = i + 1)] (ß x < array.length) [(ß x++)]
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß ret = f.invoke(ret, array[x]))
                )
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                ret
            )
        )

        (§ method int indexOf(Object o)
            (when (ß o instanceof Boolean)
                (let [#_"boolean" b (ß ((Boolean) o).booleanValue())]
                    (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j++)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )

        (§ method int lastIndexOf(Object o)
            (when (ß o instanceof Boolean)
                (let [#_"boolean" b (ß ((Boolean) o).booleanValue())]
                    (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                        (when (ß b == array[j])
                            (§ return (ß j - i))
                        )
                    )
                )
            )
            (when (ß o == nil)
                (§ return -1)
            )
            (loop-when-recur [(ß int j = array.length - 1)] (ß j >= i) [(ß j--)]
                (when (ß o.equals(array[j]))
                    (§ return (ß j - i))
                )
            )
            -1
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    #_transient
    (§ field int _hash)
    #_transient
    (§ field int _hasheq)

    (§ method String toString()
        (ß RT.printString(this))
    )

    (§ method IPersistentCollection empty()
        (ß PersistentList.EMPTY)
    )

    #_protected
    (§ constructor ASeq(IPersistentMap meta)
        (§ super(meta))
        this
    )

    #_protected
    (§ constructor ASeq()
        this
    )

    (§ method boolean equiv(Object obj)
        (when (ß !(obj instanceof Sequential || obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
                (when (ß ms == nil || !Util.equiv(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    (§ method boolean equals(Object obj)
        (when (ß this == obj)
            (§ return true)
        )
        (when (ß !(obj instanceof Sequential || obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
                (when (ß ms == nil || !Util.equals(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    (§ method int hashCode()
        (when (ß _hash == 0)
            (let [#_"int" hash 1]
                (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                    (ß hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode()))
                )
                (ß this._hash = hash)
            )
        )
        (ß _hash)
    )

    (§ method int hasheq()
        (when (ß _hasheq == 0)
            (ß _hasheq = Murmur3.hashOrdered(this))
        )
        (ß _hasheq)
    )

    (§ method int count()
        (let [#_"int" i 1]
            (loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next(), i++)]
                (when (ß s instanceof Counted)
                    (§ return (ß i + s.count()))
                )
            )
            i
        )
    )

    (§ method ISeq seq()
        this
    )

    (§ method ISeq cons(Object o)
        (ß new Cons(o, this))
    )

    (§ method ISeq more()
        (let [#_"ISeq" s (ß next())]
            (when (ß s == nil)
                (§ return (ß PersistentList.EMPTY))
            )
            s
        )
    )

    (§ method Object[] toArray()
        (ß RT.seqToArray(seq()))
    )

    (§ method boolean add(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean remove(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean addAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method void clear()
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean retainAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean removeAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean containsAll(Collection c)
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (seq() == nil))
    )

    (§ method boolean contains(Object o)
        (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    (§ method Iterator iterator()
        (ß new SeqIterator(this))
    )

    (§ method- List reify()
        (ß Collections.unmodifiableList(new ArrayList(this)))
    )

    (§ method List subList(int fromIndex, int toIndex)
        (ß reify().subList(fromIndex, toIndex))
    )

    (§ method Object set(int index, Object element)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method Object remove(int index)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method int indexOf(Object o)
        (let [#_"ISeq" s (ß seq())]
            (loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
                (when (ß Util.equiv(s.first(), o))
                    (§ return i)
                )
            )
            -1
        )
    )

    (§ method int lastIndexOf(Object o)
        (ß reify().lastIndexOf(o))
    )

    (§ method ListIterator listIterator()
        (ß reify().listIterator())
    )

    (§ method ListIterator listIterator(int index)
        (ß reify().listIterator(index))
    )

    (§ method Object get(int index)
        (ß RT.nth(this, index))
    )

    (§ method void add(int index, Object element)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean addAll(int index, Collection c)
        (throw (ß new UnsupportedOperationException()))
    )
)
)

(java-ns cloiure.lang.Associative

(§ interface Associative (§ extends IPersistentCollection, ILookup)
    (§ abstract boolean containsKey(Object key))
    (§ abstract IMapEntry entryAt(Object key))
    (§ abstract Associative assoc(Object key, Object val))
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (§ field AtomicReference state)

    (§ constructor Atom(Object state)
        (ß this.state = new AtomicReference(state))
        this
    )

    (§ constructor Atom(Object state, IPersistentMap meta)
        (§ super(meta))
        (ß this.state = new AtomicReference(state))
        this
    )

    (§ method Object deref()
        (ß state.get())
    )

    (§ method Object swap(IFn f)
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    (§ method Object swap(IFn f, Object arg)
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v, arg))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    (§ method Object swap(IFn f, Object arg1, Object arg2)
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.invoke(v, arg1, arg2))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    (§ method Object swap(IFn f, Object x, Object y, ISeq args)
        (while true
            (let [#_"Object" v (ß deref())]
                (let [#_"Object" newv (ß f.applyTo(RT.listStar(v, x, y, args)))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(v, newv))
                        (ß notifyWatches(v, newv))
                        (§ return newv)
                    )
                )
            )
        )
    )

    (§ method IPersistentVector swapVals(IFn f)
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    (§ method IPersistentVector swapVals(IFn f, Object arg)
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv, arg))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    (§ method IPersistentVector swapVals(IFn f, Object arg1, Object arg2)
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.invoke(oldv, arg1, arg2))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    (§ method IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args)
        (while true
            (let [#_"Object" oldv (ß deref())]
                (let [#_"Object" newv (ß f.applyTo(RT.listStar(oldv, x, y, args)))]
                    (ß validate(newv))
                    (when (ß state.compareAndSet(oldv, newv))
                        (ß notifyWatches(oldv, newv))
                        (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                    )
                )
            )
        )
    )

    (§ method boolean compareAndSet(Object oldv, Object newv)
        (ß validate(newv))
        (let [#_"boolean" ret (ß state.compareAndSet(oldv, newv))]
            (when ret
                (ß notifyWatches(oldv, newv))
            )
            ret
        )
    )

    (§ method Object reset(Object newval)
        (let [#_"Object" oldval (ß state.get())]
            (ß validate(newval))
            (ß state.set(newval))
            (ß notifyWatches(oldval, newval))
            newval
        )
    )

    (§ method IPersistentVector resetVals(Object newv)
        (ß validate(newv))
        (while true
            (let [#_"Object" oldv (ß deref())]
                (when (ß state.compareAndSet(oldv, newv))
                    (ß notifyWatches(oldv, newv))
                    (§ return (ß LazilyPersistentVector.createOwning(oldv, newv)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

(§ import cloiure.lang.PersistentHashMap.INode)

#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    (§ abstract void ensureEditable())
    (§ abstract ITransientMap doAssoc(Object key, Object val))
    (§ abstract ITransientMap doWithout(Object key))
    (§ abstract Object doValAt(Object key, Object notFound))
    (§ abstract int doCount())
    (§ abstract IPersistentMap doPersistent())

    (§ method ITransientMap conj(Object o)
        (ß ensureEditable())
        (cond (ß o instanceof Map.Entry)
            (do
                (let [(ß Map.Entry e = (Map.Entry) o)]
                    (§ return (ß assoc(e.getKey(), e.getValue())))
                )
            )
            (ß o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" v (ß (IPersistentVector) o)]
                    (when (ß v.count() != 2)
                        (throw (ß new IllegalArgumentException("Vector arg to map conj must be a pair")))
                    )
                    (§ return (ß assoc(v.nth(0), v.nth(1))))
                )
            )
        )

        (let [#_"ITransientMap" ret this]
            (loop-when-recur [(ß ISeq es = RT.seq(o))] (ß es != nil) [(ß es = es.next())]
                (let [(ß Map.Entry e = (Map.Entry) es.first())]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            ret
        )
    )

    (§ method Object invoke(Object arg1)
        (ß valAt(arg1))
    )

    (§ method Object invoke(Object arg1, Object notFound)
        (ß valAt(arg1, notFound))
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method ITransientMap assoc(Object key, Object val)
        (ß ensureEditable())
        (ß doAssoc(key, val))
    )

    (§ method ITransientMap without(Object key)
        (ß ensureEditable())
        (ß doWithout(key))
    )

    (§ method IPersistentMap persistent()
        (ß ensureEditable())
        (ß doPersistent())
    )

    (§ method Object valAt(Object key, Object notFound)
        (ß ensureEditable())
        (ß doValAt(key, notFound))
    )

    (§ def- Object NOT_FOUND = new Object())
    (§ method boolean containsKey(Object key)
        (ß (valAt(key, NOT_FOUND) != NOT_FOUND))
    )
    (§ method IMapEntry entryAt(Object key)
        (let [#_"Object" v (ß valAt(key, NOT_FOUND))]
            (when (ß v != NOT_FOUND)
                (§ return (ß MapEntry.create(key, v)))
            )
            nil
        )
    )

    (§ method int count()
        (ß ensureEditable())
        (ß doCount())
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    #_volatile
    (§ field ITransientMap impl)

    (§ constructor ATransientSet(ITransientMap impl)
        (ß this.impl = impl)
        this
    )

    (§ method int count()
        (ß impl.count())
    )

    (§ method ITransientSet conj(Object val)
        (let [#_"ITransientMap" m (ß impl.assoc(val, val))]
            (when (ß m != impl)
                (ß this.impl = m)
            )
            this
        )
    )

    (§ method boolean contains(Object key)
        (ß (this != impl.valAt(key, this)))
    )

    (§ method ITransientSet disjoin(Object key)
        (let [#_"ITransientMap" m (ß impl.without(key))]
            (when (ß m != impl)
                (ß this.impl = m)
            )
            this
        )
    )

    (§ method Object get(Object key)
        (ß impl.valAt(key))
    )

    (§ method Object invoke(Object key, Object notFound)
        (ß impl.valAt(key, notFound))
    )

    (§ method Object invoke(Object key)
        (ß impl.valAt(key))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ field long lpart)
    (§ field BigInteger bipart)

    (§ def BigInt ZERO = new BigInt(0, nil))
    (§ def BigInt ONE = new BigInt(1, nil))

    ;; must follow Long
    (§ method int hashCode()
        (when (ß bipart == nil)
            (§ return (ß (int) (this.lpart :xor (this.lpart >>> 32))))
        )
        (ß bipart.hashCode())
    )

    (§ method int hasheq()
        (when (ß bipart == nil)
            (§ return (ß Murmur3.hashLong(lpart)))
        )
        (ß bipart.hashCode())
    )

    (§ method boolean equals(Object obj)
        (when (ß this == obj)
            (§ return true)
        )
        (when (ß obj instanceof BigInt)
            (let [#_"BigInt" o (ß (BigInt) obj)]
                (when (ß bipart == nil)
                    (§ return (ß (o.bipart == nil && this.lpart == o.lpart)))
                )
                (§ return (ß (o.bipart != nil && this.bipart.equals(o.bipart))))
            )
        )
        false
    )

    (§ constructor- BigInt(long lpart, BigInteger bipart)
        (ß this.lpart = lpart)
        (ß this.bipart = bipart)
        this
    )

    (§ defn BigInt fromBigInteger(BigInteger val)
        (if (ß val.bitLength() < 64)
            (do
                (ß new BigInt(val.longValue(), nil))
            )
            (do
                (ß new BigInt(0, val))
            )
        )
    )

    (§ defn BigInt fromLong(long val)
        (ß new BigInt(val, nil))
    )

    (§ method BigInteger toBigInteger()
        (if (ß bipart == nil)
            (do
                (ß BigInteger.valueOf(lpart))
            )
            (do
                bipart
            )
        )
    )

    (§ method BigDecimal toBigDecimal()
        (if (ß bipart == nil)
            (do
                (ß BigDecimal.valueOf(lpart))
            )
            (do
                (ß new BigDecimal(bipart))
            )
        )
    )

    (§ method int intValue()
        (if (ß bipart == nil)
            (do
                (ß (int) lpart)
            )
            (do
                (ß bipart.intValue())
            )
        )
    )

    (§ method long longValue()
        (if (ß bipart == nil)
            (do
                lpart
            )
            (do
                (ß bipart.longValue())
            )
        )
    )

    (§ method float floatValue()
        (if (ß bipart == nil)
            (do
                lpart
            )
            (do
                (ß bipart.floatValue())
            )
        )
    )

    (§ method double doubleValue()
        (if (ß bipart == nil)
            (do
                lpart
            )
            (do
                (ß bipart.doubleValue())
            )
        )
    )

    (§ method byte byteValue()
        (if (ß bipart == nil)
            (do
                (ß (byte) lpart)
            )
            (do
                (ß bipart.byteValue())
            )
        )
    )

    (§ method short shortValue()
        (if (ß bipart == nil)
            (do
                (ß (short) lpart)
            )
            (do
                (ß bipart.shortValue())
            )
        )
    )

    (§ defn BigInt valueOf(long val)
        (ß new BigInt(val, nil))
    )

    (§ method String toString()
        (when (ß bipart == nil)
            (§ return (ß String.valueOf(lpart)))
        )
        (ß bipart.toString())
    )

    (§ method int bitLength()
        (ß toBigInteger().bitLength())
    )

    (§ method BigInt add(BigInt y)
        (when (ß (bipart == nil) && (y.bipart == nil))
            (let [#_"long" ret (ß lpart + y.lpart)]
                (when (ß (ret :xor lpart) >= 0 || (ret :xor y.lpart) >= 0)
                    (§ return (ß BigInt.valueOf(ret)))
                )
            )
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().add(y.toBigInteger())))
    )

    (§ method BigInt multiply(BigInt y)
        (when (ß (bipart == nil) && (y.bipart == nil))
            (let [#_"long" ret (ß lpart * y.lpart)]
                (when (ß y.lpart == 0 || (ret / y.lpart == lpart && lpart != Long.MIN_VALUE))
                    (§ return (ß BigInt.valueOf(ret)))
                )
            )
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().multiply(y.toBigInteger())))
    )

    (§ method BigInt quotient(BigInt y)
        (when (ß (bipart == nil) && (y.bipart == nil))
            (when (ß lpart == Long.MIN_VALUE && y.lpart == -1)
                (§ return (ß BigInt.fromBigInteger(this.toBigInteger().negate())))
            )
            (§ return (ß BigInt.valueOf(lpart / y.lpart)))
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().divide(y.toBigInteger())))
    )

    (§ method BigInt remainder(BigInt y)
        (when (ß (bipart == nil) && (y.bipart == nil))
            (§ return (ß BigInt.valueOf(lpart % y.lpart)))
        )
        (ß BigInt.fromBigInteger(this.toBigInteger().remainder(y.toBigInteger())))
    )

    (§ method boolean lt(BigInt y)
        (when (ß (bipart == nil) && (y.bipart == nil))
            (§ return (ß (lpart < y.lpart)))
        )
        (ß (this.toBigInteger().compareTo(y.toBigInteger()) < 0))
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (§ field T val)
    (§ field Binding rest)

    (§ constructor Binding(T val)
        (ß this.val = val)
        (ß this.rest = nil)
        this
    )

    (§ constructor Binding(T val, Binding rest)
        (ß this.val = val)
        (ß this.rest = rest)
        this
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (§ field Object val)

    (§ constructor Box(Object val)
        (ß this.val = val)
        this
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (§ field Object[] buffer)
    (§ field int end)

    (§ constructor ChunkBuffer(int capacity)
        (ß buffer = new Object[capacity])
        (ß end = 0)
        this
    )

    (§ method void add(Object o)
        (ß buffer[end++] = o)
        nil
    )

    (§ method IChunk chunk()
        (let [#_"ArrayChunk" ret (ß new ArrayChunk(buffer, 0, end))]
            (ß buffer = nil)
            ret
        )
    )

    (§ method int count()
        end
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (§ field IChunk chunk)
    (§ field ISeq _more)

    (§ constructor ChunkedCons(IPersistentMap meta, IChunk chunk, ISeq more)
        (§ super(meta))
        (ß this.chunk = chunk)
        (ß this._more = more)
        this
    )

    (§ constructor ChunkedCons(IChunk chunk, ISeq more)
        (§ this(nil, chunk, more))
        this
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (when (ß meta != _meta)
            (§ return (ß new ChunkedCons(meta, chunk, _more)))
        )
        this
    )

    (§ method Object first()
        (ß chunk.nth(0))
    )

    (§ method ISeq next()
        (when (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (ß chunkedNext())
    )

    (§ method ISeq more()
        (when (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (when (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )

    (§ method IChunk chunkedFirst()
        chunk
    )

    (§ method ISeq chunkedNext()
        (ß chunkedMore().seq())
    )

    (§ method ISeq chunkedMore()
        (when (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

(class-ns Compile
    (§ def- String PATH_PROP = "cloiure.compile.path")
    (§ def- String REFLECTION_WARNING_PROP = "cloiure.compile.warn-on-reflection")
    (§ def- String UNCHECKED_MATH_PROP = "cloiure.compile.unchecked-math")

    (§ def- Var compile_path = RT.var("cloiure.core", "*compile-path*"))
    (§ def- Var compile = RT.var("cloiure.core", "compile"))
    (§ def- Var warn_on_reflection = RT.var("cloiure.core", "*warn-on-reflection*"))
    (§ def- Var unchecked_math = RT.var("cloiure.core", "*unchecked-math*"))

    (§ defn void main(String[] args) (§ throws IOException, ClassNotFoundException)
        (let [#_"OutputStreamWriter" out (ß (OutputStreamWriter) RT.OUT.deref())]
            (let [#_"PrintWriter" err (ß RT.errPrintWriter())]
                (let [#_"String" path (ß System.getProperty(PATH_PROP))]
                    (let [#_"int" count (ß args.length)]
                        (when (ß path == nil)
                            (ß err.println("ERROR: Must set system property " + PATH_PROP + "\nto the location for compiled .class files." + "\nThis directory must also be on your CLASSPATH."))
                            (ß System.exit(1))
                        )

                        (let [#_"boolean" warnOnReflection (ß System.getProperty(REFLECTION_WARNING_PROP, "false").equals("true"))]
                            (let [#_"String" uncheckedMathProp (ß System.getProperty(UNCHECKED_MATH_PROP))]
                                (let [#_"Object" uncheckedMath (ß Boolean.FALSE)]
                                    (cond (ß "true".equals(uncheckedMathProp))
                                        (do
                                            (ß uncheckedMath = Boolean.TRUE)
                                        )
                                        (ß "warn-on-boxed".equals(uncheckedMathProp))
                                        (do
                                            (ß uncheckedMath = Keyword.intern("warn-on-boxed"))
                                        )
                                    )

                                    ;; force load to avoid transitive compilation during lazy load
                                    (ß RT.load("cloiure/core/specs/alpha"))

                                    (try
                                        (ß Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection, unchecked_math, uncheckedMath)))

                                        (doseq [#_"String" lib args]
                                            (ß out.write("Compiling " + lib + " to " + path + "\n"))
                                            (ß out.flush())
                                            (ß compile.invoke(Symbol.intern(lib)))
                                        )
                                        (finally
                                            (ß Var.popThreadBindings())
                                            (try
                                                (ß out.flush())
                                                (catch IOException e
                                                    (ß e.printStackTrace(err))
                                                )
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(class-ns Compiler (§ implements Opcodes)
    (§ def Symbol DEF = Symbol.intern("def"))
    (§ def Symbol LOOP = Symbol.intern("loop*"))
    (§ def Symbol RECUR = Symbol.intern("recur"))
    (§ def Symbol IF = Symbol.intern("if"))
    (§ def Symbol LET = Symbol.intern("let*"))
    (§ def Symbol LETFN = Symbol.intern("letfn*"))
    (§ def Symbol DO = Symbol.intern("do"))
    (§ def Symbol FN = Symbol.intern("fn*"))
    (§ def Symbol FNONCE = (Symbol) Symbol.intern("fn*").withMeta(RT.map(Keyword.intern(nil, "once"), RT.T)))
    (§ def Symbol QUOTE = Symbol.intern("quote"))
    (§ def Symbol THE_VAR = Symbol.intern("var"))
    (§ def Symbol DOT = Symbol.intern("."))
    (§ def Symbol ASSIGN = Symbol.intern("set!"))
    (§ def Symbol TRY = Symbol.intern("try"))
    (§ def Symbol CATCH = Symbol.intern("catch"))
    (§ def Symbol FINALLY = Symbol.intern("finally"))
    (§ def Symbol THROW = Symbol.intern("throw"))
    (§ def Symbol MONITOR_ENTER = Symbol.intern("monitor-enter"))
    (§ def Symbol MONITOR_EXIT = Symbol.intern("monitor-exit"))
    (§ def Symbol IMPORT = Symbol.intern("cloiure.core", "import*"))
    (§ def Symbol DEFTYPE = Symbol.intern("deftype*"))
    (§ def Symbol CASE = Symbol.intern("case*"))

    (§ def Symbol CLASS = Symbol.intern("Class"))
    (§ def Symbol NEW = Symbol.intern("new"))
    (§ def Symbol THIS = Symbol.intern("this"))
    (§ def Symbol REIFY = Symbol.intern("reify*"))
    (§ def Symbol LIST = Symbol.intern("cloiure.core", "list"))
    (§ def Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map"))
    (§ def Symbol VECTOR = Symbol.intern("cloiure.core", "vector"))
    (§ def Symbol IDENTITY = Symbol.intern("cloiure.core", "identity"))

    (§ def Symbol _AMP_ = Symbol.intern("&"))
    (§ def Symbol ISEQ = Symbol.intern("cloiure.lang.ISeq"))

    (§ def Keyword loadNs = Keyword.intern(nil, "load-ns"))
    (§ def Keyword inlineKey = Keyword.intern(nil, "inline"))
    (§ def Keyword inlineAritiesKey = Keyword.intern(nil, "inline-arities"))
    (§ def Keyword staticKey = Keyword.intern(nil, "static"))
    (§ def Keyword arglistsKey = Keyword.intern(nil, "arglists"))
    (§ def Symbol INVOKE_STATIC = Symbol.intern("invokeStatic"))

    (§ def Keyword volatileKey = Keyword.intern(nil, "volatile"))
    (§ def Keyword implementsKey = Keyword.intern(nil, "implements"))
    (§ def String COMPILE_STUB_PREFIX = "compile__stub")

    (§ def Keyword protocolKey = Keyword.intern(nil, "protocol"))
    (§ def Keyword onKey = Keyword.intern(nil, "on"))
    (§ def Keyword dynamicKey = Keyword.intern("dynamic"))
    (§ def Keyword redefKey = Keyword.intern(nil, "redef"))

    (§ def Symbol NS = Symbol.intern("ns"))
    (§ def Symbol IN_NS = Symbol.intern("in-ns"))

    (§ def IPersistentMap specials = PersistentHashMap.create(
  #_map DEF, new DefExpr.Parser(),
  #_map LOOP, new LetExpr.Parser(),
  #_map RECUR, new RecurExpr.Parser(),
  #_map IF, new IfExpr.Parser(),
  #_map CASE, new CaseExpr.Parser(),
  #_map LET, new LetExpr.Parser(),
  #_map LETFN, new LetFnExpr.Parser(),
  #_map DO, new BodyExpr.Parser(),
  #_map FN, nil,
  #_map QUOTE, new ConstantExpr.Parser(),
  #_map THE_VAR, new TheVarExpr.Parser(),
  #_map IMPORT, new ImportExpr.Parser(),
  #_map DOT, new HostExpr.Parser(),
  #_map ASSIGN, new AssignExpr.Parser(),
  #_map DEFTYPE, new NewInstanceExpr.DeftypeParser(),
  #_map REIFY, new NewInstanceExpr.ReifyParser(),
  #_map TRY, new TryExpr.Parser(),
  #_map THROW, new ThrowExpr.Parser(),
  #_map MONITOR_ENTER, new MonitorEnterExpr.Parser(),
  #_map MONITOR_EXIT, new MonitorExitExpr.Parser(),
  #_map CATCH, nil,
  #_map FINALLY, nil,
  #_map NEW, new NewExpr.Parser(),
  #_map _AMP_, nil
    ))

    (§ def- int MAX_POSITIONAL_ARITY = 20)
    (§ def- Type OBJECT_TYPE)
    (§ def- Type KEYWORD_TYPE = Type.getType(Keyword.class))
    (§ def- Type VAR_TYPE = Type.getType(Var.class))
    (§ def- Type SYMBOL_TYPE = Type.getType(Symbol.class))
    (§ def- Type IFN_TYPE = Type.getType(IFn.class))
    (§ def- Type AFUNCTION_TYPE = Type.getType(AFunction.class))
    (§ def- Type RT_TYPE = Type.getType(RT.class))
    (§ def- Type NUMBERS_TYPE = Type.getType(Numbers.class))

    (§ def Type CLASS_TYPE = Type.getType(Class.class))
    (§ def Type NS_TYPE = Type.getType(Namespace.class))
    (§ def Type UTIL_TYPE = Type.getType(Util.class))
    (§ def Type REFLECTOR_TYPE = Type.getType(Reflector.class))
    (§ def Type THROWABLE_TYPE = Type.getType(Throwable.class))
    (§ def Type BOOLEAN_OBJECT_TYPE = Type.getType(Boolean.class))
    (§ def Type IPERSISTENTMAP_TYPE = Type.getType(IPersistentMap.class))
    (§ def Type IOBJ_TYPE = Type.getType(IObj.class))
    (§ def Type TUPLE_TYPE = Type.getType(Tuple.class))

    (§ def Method[] createTupleMethods =
    (§ array
        (ß Method.getMethod("cloiure.lang.IPersistentVector create()")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)")),
        (ß Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)"))
    ))

    (§ def- Type[][] ARG_TYPES)
    (§ def- Type[] EXCEPTION_TYPES = (§))

    (§ static
        (ß OBJECT_TYPE = Type.getType(Object.class))
        (ß ARG_TYPES = new Type[MAX_POSITIONAL_ARITY + 2][])
        (loop-when-recur [(ß int i = 0)] (ß i <= MAX_POSITIONAL_ARITY) [(ß ++i)]
            (let [#_"Type[]" a (ß new Type[i])]
                (loop-when-recur [(ß int j = 0)] (ß j < i) [(ß j++)]
                    (ß a[j] = OBJECT_TYPE)
                )
                (ß ARG_TYPES[i] = a)
            )
        )
        (let [#_"Type[]" a (ß new Type[MAX_POSITIONAL_ARITY + 1])]
            (loop-when-recur [(ß int j = 0)] (ß j < MAX_POSITIONAL_ARITY) [(ß j++)]
                (ß a[j] = OBJECT_TYPE)
            )
            (ß a[MAX_POSITIONAL_ARITY] = Type.getType("[Ljava/lang/Object;"))
            (ß ARG_TYPES[MAX_POSITIONAL_ARITY + 1] = a)
        )
    )

    ;; symbol->localbinding
    (§ def Var LOCAL_ENV = Var.create(nil).setDynamic())

    ;; vector<localbinding>
    (§ def Var LOOP_LOCALS = Var.create().setDynamic())

    ;; Label
    (§ def Var LOOP_LABEL = Var.create().setDynamic())

    ;; vector<object>
    (§ def Var CONSTANTS = Var.create().setDynamic())

    ;; IdentityHashMap
    (§ def Var CONSTANT_IDS = Var.create().setDynamic())

    ;; vector<keyword>
    (§ def Var KEYWORD_CALLSITES = Var.create().setDynamic())

    ;; vector<var>
    (§ def Var PROTOCOL_CALLSITES = Var.create().setDynamic())

    ;; set<var>
    (§ def Var VAR_CALLSITES = Var.create().setDynamic())

    ;; keyword->constid
    (§ def Var KEYWORDS = Var.create().setDynamic())

    ;; var->constid
    (§ def Var VARS = Var.create().setDynamic())

    ;; FnFrame
    (§ def Var METHOD = Var.create(nil).setDynamic())

    ;; nil or not
    (§ def Var IN_CATCH_FINALLY = Var.create(nil).setDynamic())

    (§ def Var METHOD_RETURN_CONTEXT = Var.create(nil).setDynamic())

    (§ def Var NO_RECUR = Var.create(nil).setDynamic())

    ;; DynamicClassLoader
    (§ def Var LOADER = Var.create().setDynamic())

    ;; String
    (§ def Var SOURCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*source-path*"), "NO_SOURCE_FILE").setDynamic())

    ;; String
    (§ def Var SOURCE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynamic())

    ;; String
    (§ def Var COMPILE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-path*"), nil).setDynamic())
    ;; boolean
    (§ def Var COMPILE_FILES = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-files*"), Boolean.FALSE).setDynamic())

    (§ def Var INSTANCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("instance?")))

    (§ def Var ADD_ANNOTATIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("add-annotations")))

    (§ def Keyword disableLocalsClearingKey = Keyword.intern("disable-locals-clearing"))
    (§ def Keyword directLinkingKey = Keyword.intern("direct-linking"))
    (§ def Keyword elideMetaKey = Keyword.intern("elide-meta"))

    (§ def Var COMPILER_OPTIONS)

    (§ defn Object getCompilerOption(Keyword k)
        (ß RT.get(COMPILER_OPTIONS.deref(), k))
    )

    (§ static
        (let [#_"Object" compilerOptions nil]
            (doseq [#_"Map.Entry" e (ß System.getProperties().entrySet())]
                (let [#_"String" name (ß (String) e.getKey())]
                    (let [#_"String" v (ß (String) e.getValue())]
                        (when (ß name.startsWith("cloiure.compiler."))
                            (ß compilerOptions = RT.assoc(compilerOptions, RT.keyword(nil, name.substring(1 + name.lastIndexOf(\.))), RT.readString(v)))
                        )
                    )
                )
            )

            (ß COMPILER_OPTIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compiler-options*"), compilerOptions).setDynamic())
        )
    )

    (§ defn Object elideMeta(Object m)
        (let [#_"Collection<Object>" elides (ß (Collection<Object>) getCompilerOption(elideMetaKey))]
            (when (ß elides != nil)
                (doseq [#_"Object" k elides]
                    (ß m = RT.dissoc(m, k))
                )
            )
            m
        )
    )

    ;; Integer
    (§ def Var LINE = Var.create(0).setDynamic())
    (§ def Var COLUMN = Var.create(0).setDynamic())

    (§ defn int lineDeref()
        (ß ((Number)LINE.deref()).intValue())
    )

    (§ defn int columnDeref()
        (ß ((Number)COLUMN.deref()).intValue())
    )

    ;; Integer
    (§ def Var LINE_BEFORE = Var.create(0).setDynamic())
    (§ def Var COLUMN_BEFORE = Var.create(0).setDynamic())
    (§ def Var LINE_AFTER = Var.create(0).setDynamic())
    (§ def Var COLUMN_AFTER = Var.create(0).setDynamic())

    ;; Integer
    (§ def Var NEXT_LOCAL_NUM = Var.create(0).setDynamic())

    ;; Integer
    (§ def Var RET_LOCAL_NUM = Var.create().setDynamic())

    (§ def Var COMPILE_STUB_SYM = Var.create(nil).setDynamic())
    (§ def Var COMPILE_STUB_CLASS = Var.create(nil).setDynamic())

    ;; PathNode chain
    (§ def Var CLEAR_PATH = Var.create(nil).setDynamic())

    ;; tail of PathNode chain
    (§ def Var CLEAR_ROOT = Var.create(nil).setDynamic())

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def Var CLEAR_SITES = Var.create(nil).setDynamic())

    #_non-static
    (§ enum C
        (§ item STATEMENT), ;; value ignored
        (§ item EXPRESSION), ;; value required
        (§ item RETURN), ;; tail position relative to enclosing recur frame
        (§ item EVAL)
    )

    #_private
    #_non-static
    (class-ns Recur
    )

    (§ def Class RECUR_CLASS = Recur.class)

    #_non-static
    (§ interface Expr
        (§ abstract Object eval())
        (§ abstract void emit(C context, ObjExpr objx, GeneratorAdapter gen))
        (§ abstract boolean hasJavaClass())
        (§ abstract Class getJavaClass())
    )

    #_abstract
    (class-ns UntypedExpr (§ implements Expr)
        (§ method Class getJavaClass()
            (throw (ß new IllegalArgumentException("Has no Java class")))
        )

        (§ method boolean hasJavaClass()
            false
        )
    )

    #_non-static
    (§ interface IParser
        (§ abstract Expr parse(C context, Object form))
    )

    (§ defn boolean isSpecial(Object sym)
        (ß specials.containsKey(sym))
    )

    (§ defn boolean inTailCall(C context)
        (ß (context == C.RETURN) && (METHOD_RETURN_CONTEXT.deref() != nil) && (IN_CATCH_FINALLY.deref() == nil))
    )

    (§ defn Symbol resolveSymbol(Symbol sym)
        ;; already qualified or classname?
        (when (ß sym.name.indexOf(\.) > 0)
            (§ return sym)
        )
        (when (ß sym.ns != nil)
            (let [#_"Namespace" ns (ß namespaceFor(sym))]
                (when (ß ns == nil || ((ns.name.name == nil) ? (sym.ns == nil) :or ns.name.name.equals(sym.ns)))
                    (§ return sym)
                )
                (§ return (ß Symbol.intern(ns.name.name, sym.name)))
            )
        )
        (let [#_"Object" o (ß currentNS().getMapping(sym))]
            (cond (ß o == nil)
                (do
                    (§ return (ß Symbol.intern(currentNS().name.name, sym.name)))
                )
                (ß o instanceof Class)
                (do
                    (§ return (ß Symbol.intern(nil, ((Class) o).getName())))
                )
                (ß o instanceof Var)
                (do
                    (let [#_"Var" v (ß (Var) o)]
                        (§ return (ß Symbol.intern(v.ns.name.name, v.sym.name)))
                    )
                )
            )
            nil
        )
    )

    (class-ns DefExpr (§ implements Expr)
        (§ field Var var)
        (§ field Expr init)
        (§ field Expr meta)
        (§ field boolean initProvided)
        (§ field boolean isDynamic)
        (§ field boolean shadowsCoreMapping)
        (§ field String source)
        (§ field int line)
        (§ field int column)

        (§ def Method bindRootMethod = Method.getMethod("void bindRoot(Object)"))
        (§ def Method setTagMethod = Method.getMethod("void setTag(cloiure.lang.Symbol)"))
        (§ def Method setMetaMethod = Method.getMethod("void setMeta(cloiure.lang.IPersistentMap)"))
        (§ def Method setDynamicMethod = Method.getMethod("cloiure.lang.Var setDynamic(boolean)"))
        (§ def Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String, String)"))
        (§ def Method internVar = Method.getMethod("cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

        (§ constructor DefExpr(String source, int line, int column, Var var, Expr init, Expr meta, boolean initProvided, boolean isDynamic, boolean shadowsCoreMapping)
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.var = var)
            (ß this.init = init)
            (ß this.meta = meta)
            (ß this.isDynamic = isDynamic)
            (ß this.shadowsCoreMapping = shadowsCoreMapping)
            (ß this.initProvided = initProvided)
            this
        )

        (§ method- boolean includesExplicitMetadata(MapExpr expr)
            (loop-when-recur [(ß int i = 0)] (ß i < expr.keyvals.count()) [(ß i += 2)]
                (let [#_"Keyword" k (ß ((KeywordExpr) expr.keyvals.nth(i)).k)]
                    (when (ß (k != RT.FILE_KEY) && (k != RT.DECLARED_KEY) && (k != RT.LINE_KEY) && (k != RT.COLUMN_KEY))
                        (§ return true)
                    )
                )
            )
            false
        )

        (§ method Object eval()
            (try
                (when initProvided
                    (ß var.bindRoot(init.eval()))
                )
                (when (ß meta != nil)
                    (let [#_"IPersistentMap" metaMap (ß (IPersistentMap) meta.eval())]
                        (when (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                            (ß var.setMeta(metaMap))
                        )
                    )
                )
                (ß var.setDynamic(isDynamic))
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitVar(gen, var))

            (when shadowsCoreMapping
                (ß gen.dup())
                (ß gen.getField(VAR_TYPE, "ns", NS_TYPE))
                (ß gen.swap())
                (ß gen.dup())
                (ß gen.getField(VAR_TYPE, "sym", SYMBOL_TYPE))
                (ß gen.swap())
                (ß gen.invokeVirtual(NS_TYPE, internVar))
            )

            (when isDynamic
                (ß gen.push(isDynamic))
                (ß gen.invokeVirtual(VAR_TYPE, setDynamicMethod))
            )
            (when (ß meta != nil)
                (when (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                    (ß gen.dup())
                    (ß meta.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(IPERSISTENTMAP_TYPE))
                    (ß gen.invokeVirtual(VAR_TYPE, setMetaMethod))
                )
            )
            (when initProvided
                (ß gen.dup())
                (if (ß init instanceof FnExpr)
                    (do
                        (ß ((FnExpr)init).emitForDefn(objx, gen))
                    )
                    (do
                        (ß init.emit(C.EXPRESSION, objx, gen))
                    )
                )
                (ß gen.invokeVirtual(VAR_TYPE, bindRootMethod))
            )

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Var.class)
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
                (let [#_"String" docstring nil]
                    (when (ß RT.count(form) == 4 && (RT.third(form) instanceof String))
                        (ß docstring = (String) RT.third(form))
                        (ß form = RT.list(RT.first(form), RT.second(form), RT.fourth(form)))
                    )
                    (cond (ß RT.count(form) > 3)
                        (do
                            (throw (ß Util.runtimeException("Too many arguments to def")))
                        )
                        (ß RT.count(form) < 2)
                        (do
                            (throw (ß Util.runtimeException("Too few arguments to def")))
                        )
                        (ß !(RT.second(form) instanceof Symbol))
                        (do
                            (throw (ß Util.runtimeException("First argument to def must be a Symbol")))
                        )
                    )
                    (let [#_"Symbol" sym (ß (Symbol) RT.second(form))]
                        (let [#_"Var" v (ß lookupVar(sym, true))]
                            (when (ß v == nil)
                                (throw (ß Util.runtimeException("Can't refer to qualified var that doesn't exist")))
                            )
                            (let [#_"boolean" shadowsCoreMapping false]
                                (when (ß !v.ns.equals(currentNS()))
                                    (if (ß sym.ns == nil)
                                        (do
                                            (ß v = currentNS().intern(sym))
                                            (ß shadowsCoreMapping = true)
                                            (ß registerVar(v))
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Can't create defs outside of current ns")))
                                        )
                                    )
                                )
                                (let [#_"IPersistentMap" mm (ß sym.meta())]
                                    (let [#_"boolean" isDynamic (ß RT.booleanCast(RT.get(mm, dynamicKey)))]
                                        (when isDynamic
                                            (ß v.setDynamic())
                                        )
                                        (when (ß !isDynamic && sym.name.startsWith("*") && sym.name.endsWith("*") && sym.name.length() > 2)
                                            (ß RT.errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, " + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", sym, SOURCE_PATH.get(), LINE.get()))
                                        )
                                        (when (ß RT.booleanCast(RT.get(mm, arglistsKey)))
                                            (let [#_"IPersistentMap" vm (ß v.meta())]
                                                ;; drop quote
                                                (ß vm = (IPersistentMap) RT.assoc(vm, arglistsKey, RT.second(mm.valAt(arglistsKey))))
                                                (ß v.setMeta(vm))
                                            )
                                        )
                                        (let [#_"Object" source_path (ß SOURCE_PATH.get())]
                                            (ß source_path = (source_path == nil) ? "NO_SOURCE_FILE" :or source_path)
                                            (ß mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.COLUMN_KEY, COLUMN.get()).assoc(RT.FILE_KEY, source_path))
                                            (when (ß docstring != nil)
                                                (ß mm = (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring))
                                            )
                                            (ß mm = (IPersistentMap) elideMeta(mm))
                                            (let [#_"Expr" meta (ß (mm.count() == 0) ? nil :or analyze((context == C.EVAL) ? context :or C.EXPRESSION, mm))]
                                                (ß new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), v, analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.third(form), v.sym.name), meta, (RT.count(form) == 3), isDynamic, shadowsCoreMapping))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns AssignExpr (§ implements Expr)
        (§ field AssignableExpr target)
        (§ field Expr val)

        (§ constructor AssignExpr(AssignableExpr target, Expr val)
            (ß this.target = target)
            (ß this.val = val)
            this
        )

        (§ method Object eval()
            (ß target.evalAssign(val))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß target.emitAssign(context, objx, gen, val))
            nil
        )

        (§ method boolean hasJavaClass()
            (ß val.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß val.getJavaClass())
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß RT.length(form) != 3)
                        (throw (ß new IllegalArgumentException("Malformed assignment, expecting (set! target val)")))
                    )
                    (let [#_"Expr" target (ß analyze(C.EXPRESSION, RT.second(form)))]
                        (when (ß !(target instanceof AssignableExpr))
                            (throw (ß new IllegalArgumentException("Invalid assignment target")))
                        )
                        (ß new AssignExpr((AssignableExpr) target, analyze(C.EXPRESSION, RT.third(form))))
                    )
                )
            )
        )
    )

    (class-ns VarExpr (§ implements Expr, AssignableExpr)
        (§ field Var var)
        (§ field Object tag)
        (§ def Method getMethod = Method.getMethod("Object get()"))
        (§ def Method setMethod = Method.getMethod("Object set(Object)"))

        (§ field Class jc)

        (§ constructor VarExpr(Var var, Symbol tag)
            (ß this.var = var)
            (ß this.tag = (tag != nil) ? tag :or var.getTag())
            this
        )

        (§ method Object eval()
            (ß var.deref())
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitVarValue(gen, var))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (tag != nil))
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )

        (§ method Object evalAssign(Expr val)
            (ß var.set(val.eval()))
        )

        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (ß objx.emitVar(gen, var))
            (ß val.emit(C.EXPRESSION, objx, gen))
            (ß gen.invokeVirtual(VAR_TYPE, setMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (class-ns TheVarExpr (§ implements Expr)
        (§ field Var var)

        (§ constructor TheVarExpr(Var var)
            (ß this.var = var)
            this
        )

        (§ method Object eval()
            var
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitVar(gen, var))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Var.class)
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (let [#_"Symbol" sym (ß (Symbol) RT.second(form))]
                    (let [#_"Var" v (ß lookupVar(sym, false))]
                        (when (ß v != nil)
                            (§ return (ß new TheVarExpr(v)))
                        )
                        (throw (ß Util.runtimeException("Unable to resolve var: " + sym + " in this context")))
                    )
                )
            )
        )
    )

    (class-ns KeywordExpr (§ extends LiteralExpr)
        (§ field Keyword k)

        (§ constructor KeywordExpr(Keyword k)
            (ß this.k = k)
            this
        )

        (§ method Object val()
            k
        )

        (§ method Object eval()
            k
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitKeyword(gen, k))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Keyword.class)
        )
    )

    (class-ns ImportExpr (§ implements Expr)
        (§ field String c)

        (§ def Method forNameMethod = Method.getMethod("Class classForNameNonLoading(String)"))
        (§ def Method importClassMethod = Method.getMethod("Class importClass(Class)"))
        (§ def Method derefMethod = Method.getMethod("Object deref()"))

        (§ constructor ImportExpr(String c)
            (ß this.c = c)
            this
        )

        (§ method Object eval()
            (let [#_"Namespace" ns (ß (Namespace) RT.CURRENT_NS.deref())]
                (ß ns.importClass(RT.classForNameNonLoading(c)))
                nil
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.getStatic(RT_TYPE, "CURRENT_NS", VAR_TYPE))
            (ß gen.invokeVirtual(VAR_TYPE, derefMethod))
            (ß gen.checkCast(NS_TYPE))
            (ß gen.push(c))
            (ß gen.invokeStatic(RT_TYPE, forNameMethod))
            (ß gen.invokeVirtual(NS_TYPE, importClassMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            false
        )

        (§ method Class getJavaClass()
            (throw (ß new IllegalArgumentException("ImportExpr has no Java class")))
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (ß new ImportExpr((String) RT.second(form)))
            )
        )
    )

    #_abstract
    (class-ns LiteralExpr (§ implements Expr)
        (§ abstract Object val())

        (§ method Object eval()
            (ß val())
        )
    )

    (§ interface AssignableExpr
        (§ abstract Object evalAssign(Expr val))
        (§ abstract void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val))
    )

    (§ interface MaybePrimitiveExpr (§ extends Expr)
        (§ abstract boolean canEmitPrimitive())
        (§ abstract void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen))
    )

    #_abstract
    (class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ def Type BOOLEAN_TYPE = Type.getType(Boolean.class))
        (§ def Type CHAR_TYPE = Type.getType(Character.class))
        (§ def Type INTEGER_TYPE = Type.getType(Integer.class))
        (§ def Type LONG_TYPE = Type.getType(Long.class))
        (§ def Type FLOAT_TYPE = Type.getType(Float.class))
        (§ def Type DOUBLE_TYPE = Type.getType(Double.class))
        (§ def Type SHORT_TYPE = Type.getType(Short.class))
        (§ def Type BYTE_TYPE = Type.getType(Byte.class))
        (§ def Type NUMBER_TYPE = Type.getType(Number.class))

        (§ def Method charValueMethod = Method.getMethod("char charValue()"))
        (§ def Method booleanValueMethod = Method.getMethod("boolean booleanValue()"))

        (§ def Method charValueOfMethod = Method.getMethod("Character valueOf(char)"))
        (§ def Method intValueOfMethod = Method.getMethod("Integer valueOf(int)"))
        (§ def Method longValueOfMethod = Method.getMethod("Long valueOf(long)"))
        (§ def Method floatValueOfMethod = Method.getMethod("Float valueOf(float)"))
        (§ def Method doubleValueOfMethod = Method.getMethod("Double valueOf(double)"))
        (§ def Method shortValueOfMethod = Method.getMethod("Short valueOf(short)"))
        (§ def Method byteValueOfMethod = Method.getMethod("Byte valueOf(byte)"))

        (§ def Method intValueMethod = Method.getMethod("int intValue()"))
        (§ def Method longValueMethod = Method.getMethod("long longValue()"))
        (§ def Method floatValueMethod = Method.getMethod("float floatValue()"))
        (§ def Method doubleValueMethod = Method.getMethod("double doubleValue()"))
        (§ def Method byteValueMethod = Method.getMethod("byte byteValue()"))
        (§ def Method shortValueMethod = Method.getMethod("short shortValue()"))

        (§ def Method fromIntMethod = Method.getMethod("cloiure.lang.Num from(int)"))
        (§ def Method fromLongMethod = Method.getMethod("cloiure.lang.Num from(long)"))
        (§ def Method fromDoubleMethod = Method.getMethod("cloiure.lang.Num from(double)"))

        (§ defn void emitBoxReturn(ObjExpr objx, GeneratorAdapter gen, Class returnType)
            (when (ß returnType.isPrimitive())
                (cond (ß returnType == boolean.class)
                    (do
                        (let [#_"Label" falseLabel (ß gen.newLabel())]
                            (let [#_"Label" endLabel (ß gen.newLabel())]
                                (ß gen.ifZCmp(GeneratorAdapter.EQ, falseLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.goTo(endLabel))
                                (ß gen.mark(falseLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.mark(endLabel))
                            )
                        )
                    )
                    (ß returnType == void.class)
                    (do
                        (ß NIL_EXPR.emit(C.EXPRESSION, objx, gen))
                    )
                    (ß returnType == char.class)
                    (do
                        (ß gen.invokeStatic(CHAR_TYPE, charValueOfMethod))
                    )
                    :else
                    (do
                        (cond (ß returnType == int.class)
                            (do
                                (ß gen.invokeStatic(INTEGER_TYPE, intValueOfMethod))
                            )
                            (ß returnType == float.class)
                            (do
                                (ß gen.invokeStatic(FLOAT_TYPE, floatValueOfMethod))
                            )
                            (ß returnType == double.class)
                            (do
                                (ß gen.invokeStatic(DOUBLE_TYPE, doubleValueOfMethod))
                            )
                            (ß returnType == long.class)
                            (do
                                (ß gen.invokeStatic(NUMBERS_TYPE, Method.getMethod("Number num(long)")))
                            )
                            (ß returnType == byte.class)
                            (do
                                (ß gen.invokeStatic(BYTE_TYPE, byteValueOfMethod))
                            )
                            (ß returnType == short.class)
                            (do
                                (ß gen.invokeStatic(SHORT_TYPE, shortValueOfMethod))
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn void emitUnboxArg(ObjExpr objx, GeneratorAdapter gen, Class paramType)
            (if (ß paramType.isPrimitive())
                (do
                    (cond (ß paramType == boolean.class)
                        (do
                            (ß gen.checkCast(BOOLEAN_TYPE))
                            (ß gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod))
                        )
                        (ß paramType == char.class)
                        (do
                            (ß gen.checkCast(CHAR_TYPE))
                            (ß gen.invokeVirtual(CHAR_TYPE, charValueMethod))
                        )
                        :else
                        (do
                            (let [#_"Method" m nil]
                                (ß gen.checkCast(NUMBER_TYPE))
                                (if (ß RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                                    (do
                                        (cond (ß paramType == int.class)
                                            (do
                                                (ß m = Method.getMethod("int uncheckedIntCast(Object)"))
                                            )
                                            (ß paramType == float.class)
                                            (do
                                                (ß m = Method.getMethod("float uncheckedFloatCast(Object)"))
                                            )
                                            (ß paramType == double.class)
                                            (do
                                                (ß m = Method.getMethod("double uncheckedDoubleCast(Object)"))
                                            )
                                            (ß paramType == long.class)
                                            (do
                                                (ß m = Method.getMethod("long uncheckedLongCast(Object)"))
                                            )
                                            (ß paramType == byte.class)
                                            (do
                                                (ß m = Method.getMethod("byte uncheckedByteCast(Object)"))
                                            )
                                            (ß paramType == short.class)
                                            (do
                                                (ß m = Method.getMethod("short uncheckedShortCast(Object)"))
                                            )
                                        )
                                    )
                                    (do
                                        (cond (ß paramType == int.class)
                                            (do
                                                (ß m = Method.getMethod("int intCast(Object)"))
                                            )
                                            (ß paramType == float.class)
                                            (do
                                                (ß m = Method.getMethod("float floatCast(Object)"))
                                            )
                                            (ß paramType == double.class)
                                            (do
                                                (ß m = Method.getMethod("double doubleCast(Object)"))
                                            )
                                            (ß paramType == long.class)
                                            (do
                                                (ß m = Method.getMethod("long longCast(Object)"))
                                            )
                                            (ß paramType == byte.class)
                                            (do
                                                (ß m = Method.getMethod("byte byteCast(Object)"))
                                            )
                                            (ß paramType == short.class)
                                            (do
                                                (ß m = Method.getMethod("short shortCast(Object)"))
                                            )
                                        )
                                    )
                                )
                                (ß gen.invokeStatic(RT_TYPE, m))
                            )
                        )
                    )
                )
                (do
                    (ß gen.checkCast(Type.getType(paramType)))
                )
            )
            nil
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (. x fieldname-sym) or
                    ;; (. x 0-ary-method)
                    ;; (. x methodname-sym args+)
                    ;; (. x (methodname-sym args?))
                    (when (ß RT.length(form) < 3)
                        (throw (ß new IllegalArgumentException("Malformed member expression, expecting (. target member ...)")))
                    )
                    ;; determine static or instance
                    ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                    (let [#_"int" line (ß lineDeref())]
                        (let [#_"int" column (ß columnDeref())]
                            (let [#_"String" source (ß (String) SOURCE.deref())]
                                (let [#_"Class" c (ß maybeClass(RT.second(form), false))]
                                    ;; at this point c will be non-null if static
                                    (let [#_"Expr" instance nil]
                                        (when (ß c == nil)
                                            (ß instance = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))
                                        )

                                        (let [#_"boolean" maybeField (ß (RT.length(form) == 3) && (RT.third(form) instanceof Symbol))]
                                            (when (ß maybeField && !(((Symbol)RT.third(form)).name.charAt(0) == \-))
                                                (let [#_"Symbol" sym (ß (Symbol) RT.third(form))]
                                                    (cond (ß c != nil)
                                                        (do
                                                            (ß maybeField = Reflector.getMethods(c, 0, munge(sym.name), true).size() == 0)
                                                        )
                                                        (ß instance != nil && instance.hasJavaClass() && instance.getJavaClass() != nil)
                                                        (do
                                                            (ß maybeField = Reflector.getMethods(instance.getJavaClass(), 0, munge(sym.name), false).size() == 0)
                                                        )
                                                    )
                                                )
                                            )

                                            (if maybeField ;; field
                                                (do
                                                    (let [#_"Symbol" sym (ß (((Symbol)RT.third(form)).name.charAt(0) == \-) ? Symbol.intern(((Symbol)RT.third(form)).name.substring(1)) :or (Symbol) RT.third(form))]
                                                        (let [#_"Symbol" tag (ß tagOf(form))]
                                                            (if (ß c != nil)
                                                                (do
                                                                    (ß new StaticFieldExpr(line, column, c, munge(sym.name), tag))
                                                                )
                                                                (do
                                                                    (ß new InstanceFieldExpr(line, column, instance, munge(sym.name), tag, (((Symbol)RT.third(form)).name.charAt(0) == \-)))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (do
                                                    (let [#_"ISeq" call (ß (ISeq) ((RT.third(form) instanceof ISeq) ? RT.third(form) :or RT.next(RT.next(form))))]
                                                        (when (ß !(RT.first(call) instanceof Symbol))
                                                            (throw (ß new IllegalArgumentException("Malformed member expression")))
                                                        )
                                                        (let [#_"Symbol" sym (ß (Symbol) RT.first(call))]
                                                            (let [#_"Symbol" tag (ß tagOf(form))]
                                                                (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                                                    (let [#_"boolean" tailPosition (ß inTailCall(context))]
                                                                        (loop-when-recur [(ß ISeq s = RT.next(call))] (ß s != nil) [(ß s = s.next())]
                                                                            (ß args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first())))
                                                                        )
                                                                        (if (ß c != nil)
                                                                            (do
                                                                                (ß new StaticMethodExpr(source, line, column, tag, c, munge(sym.name), args, tailPosition))
                                                                            )
                                                                            (do
                                                                                (ß new InstanceMethodExpr(source, line, column, tag, instance, munge(sym.name), args, tailPosition))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn Class maybeClass(Object form, boolean stringOk)
            (when (ß form instanceof Class)
                (§ return (ß (Class) form))
            )
            (let [#_"Class" c nil]
                (cond (ß form instanceof Symbol)
                    (do
                        (let [#_"Symbol" sym (ß (Symbol) form)]
                            (when (ß sym.ns == nil) ;; if ns-qualified can't be classname
                                (when (ß Util.equals(sym, COMPILE_STUB_SYM.get()))
                                    (§ return (ß (Class) COMPILE_STUB_CLASS.get()))
                                )
                                (if (ß sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
                                    (do
                                        (ß c = RT.classForNameNonLoading(sym.name))
                                    )
                                    (do
                                        (let [#_"Object" o (ß currentNS().getMapping(sym))]
                                            (cond (ß o instanceof Class)
                                                (do
                                                    (ß c = (Class) o)
                                                )
                                                (ß LOCAL_ENV.deref() != nil && ((java.util.Map)LOCAL_ENV.deref()).containsKey(form))
                                                (do
                                                    (§ return nil)
                                                )
                                                :else
                                                (do
                                                    (try
                                                        (ß c = RT.classForNameNonLoading(sym.name))
                                                        (catch Exception e
                                                            ;; aargh
                                                            ;; leave c set to nil -> return nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (ß stringOk && form instanceof String)
                    (do
                        (ß c = RT.classForNameNonLoading((String) form))
                    )
                )
                c
            )
        )

        (§ defn Class maybeSpecialTag(Symbol sym)
            (let [#_"Class" c (ß primClass(sym))]
                (cond (ß c != nil)
                    (do
                        (§ return c)
                    )
                    (ß sym.name.equals("objects"))
                    (do
                        (ß c = Object[].class)
                    )
                    (ß sym.name.equals("ints"))
                    (do
                        (ß c = int[].class)
                    )
                    (ß sym.name.equals("longs"))
                    (do
                        (ß c = long[].class)
                    )
                    (ß sym.name.equals("floats"))
                    (do
                        (ß c = float[].class)
                    )
                    (ß sym.name.equals("doubles"))
                    (do
                        (ß c = double[].class)
                    )
                    (ß sym.name.equals("chars"))
                    (do
                        (ß c = char[].class)
                    )
                    (ß sym.name.equals("shorts"))
                    (do
                        (ß c = short[].class)
                    )
                    (ß sym.name.equals("bytes"))
                    (do
                        (ß c = byte[].class)
                    )
                    (ß sym.name.equals("booleans"))
                    (do
                        (ß c = boolean[].class)
                    )
                )
                c
            )
        )

        (§ defn Class tagToClass(Object tag)
            (let [#_"Class" c nil]
                (when (ß tag instanceof Symbol)
                    (let [#_"Symbol" sym (ß (Symbol) tag)]
                        (when (ß sym.ns == nil) ;; if ns-qualified can't be classname
                            (ß c = maybeSpecialTag(sym))
                        )
                    )
                )
                (when (ß c == nil)
                    (ß c = maybeClass(tag, true))
                )
                (when (ß c != nil)
                    (§ return c)
                )
                (throw (ß new IllegalArgumentException("Unable to resolve classname: " + tag)))
            )
        )
    )

    #_abstract
    (class-ns FieldExpr (§ extends HostExpr)
    )

    (class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        (§ field Expr target)
        (§ field Class targetClass)
        (§ field java.lang.reflect.Field field)
        (§ field String fieldName)
        (§ field int line)
        (§ field int column)
        (§ field Symbol tag)
        (§ field boolean requireField)

        (§ def Method invokeNoArgInstanceMember = Method.getMethod("Object invokeNoArgInstanceMember(Object,String,boolean)"))
        (§ def Method setInstanceFieldMethod = Method.getMethod("Object setInstanceField(Object,String,Object)"))

        (§ field Class jc)

        (§ constructor InstanceFieldExpr(int line, int column, Expr target, String fieldName, Symbol tag, boolean requireField)
            (ß this.target = target)
            (ß this.targetClass = target.hasJavaClass() ? target.getJavaClass() :or nil)
            (ß this.field = (targetClass != nil) ? Reflector.getField(targetClass, fieldName, false) :or nil)
            (ß this.fieldName = fieldName)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.requireField = requireField)

            (when (ß field == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (if (ß targetClass == nil)
                    (do
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName))
                    )
                    (do
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName, targetClass.getName()))
                    )
                )
            )
            this
        )

        (§ method Object eval()
            (ß Reflector.invokeNoArgInstanceMember(target.eval(), fieldName, requireField))
        )

        (§ method boolean canEmitPrimitive()
            (ß (targetClass != nil && field != nil && Util.isPrimitive(field.getType())))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
                )
                (do
                    (throw (ß new UnsupportedOperationException("Unboxed emit of unknown member")))
                )
            )
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß gen.getField(getType(targetClass), fieldName, Type.getType(field.getType())))
                    (ß HostExpr.emitBoxReturn(objx, gen, field.getType()))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.push(fieldName))
                    (ß gen.push(requireField))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstanceMember))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (field != nil || tag != nil))
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType())
            )
            jc
        )

        (§ method Object evalAssign(Expr val)
            (ß Reflector.setInstanceField(target.eval(), fieldName, val.eval()))
        )

        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (if (ß targetClass != nil && field != nil)
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(getType(targetClass)))
                    (ß val.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.dupX1())
                    (ß HostExpr.emitUnboxArg(objx, gen, field.getType()))
                    (ß gen.putField(getType(targetClass), fieldName, Type.getType(field.getType())))
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.push(fieldName))
                    (ß val.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, setInstanceFieldMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
        (§ field String fieldName)
        (§ field Class c)
        (§ field java.lang.reflect.Field field)
        (§ field Symbol tag)

        (§ field int line)
        (§ field int column)

        (§ field Class jc)

        (§ constructor StaticFieldExpr(int line, int column, Class c, String fieldName, Symbol tag)
            (ß this.fieldName = fieldName)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.c = c)
            (try
                (ß field = c.getField(fieldName))
                (catch NoSuchFieldException e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
            (ß this.tag = tag)
            this
        )

        (§ method Object eval()
            (ß Reflector.getStaticField(c, fieldName))
        )

        (§ method boolean canEmitPrimitive()
            (ß Util.isPrimitive(field.getType()))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.visitLineNumber(line, gen.mark()))

            (ß gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (ß HostExpr.emitBoxReturn(objx, gen, field.getType()))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType())
            )
            jc
        )

        (§ method Object evalAssign(Expr val)
            (ß Reflector.setStaticField(c, fieldName, val.eval()))
        )

        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (ß val.emit(C.EXPRESSION, objx, gen))
            (ß gen.visitLineNumber(line, gen.mark()))
            (ß gen.dup())
            (ß HostExpr.emitUnboxArg(objx, gen, field.getType()))
            (ß gen.putStatic(Type.getType(c), fieldName, Type.getType(field.getType())))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )
    )

    (§ defn Class maybePrimitiveType(Expr e)
        (when (ß e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive())
            (let [#_"Class" c (ß e.getJavaClass())]
                (when (ß Util.isPrimitive(c))
                    (§ return c)
                )
            )
        )
        nil
    )

    (§ defn Class maybeJavaClass(Collection<Expr> exprs)
        (let [#_"Class" match nil]
            (try
                (doseq [#_"Expr" e exprs]
                    (when (ß e instanceof ThrowExpr)
                        (§ continue )
                    )
                    (when (ß !e.hasJavaClass())
                        (§ return nil)
                    )
                    (let [#_"Class" c (ß e.getJavaClass())]
                        (cond (ß match == nil)
                            (do
                                (ß match = c)
                            )
                            (ß match != c)
                            (do
                                (§ return nil)
                            )
                        )
                    )
                )
                (catch Exception e
                    (§ return nil)
                )
            )
            match
        )
    )

    #_abstract
    (class-ns MethodExpr (§ extends HostExpr)
        (§ defn void emitArgsAsArray(IPersistentVector args, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.push(args.count()))
            (ß gen.newArray(OBJECT_TYPE))
            (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                (ß gen.dup())
                (ß gen.push(i))
                (ß ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen))
                (ß gen.arrayStore(OBJECT_TYPE))
            )
            nil
        )

        (§ defn void emitTypedArgs(ObjExpr objx, GeneratorAdapter gen, Class[] parameterTypes, IPersistentVector args)
            (loop-when-recur [(ß int i = 0)] (ß i < parameterTypes.length) [(ß i++)]
                (let [#_"Expr" e (ß (Expr) args.nth(i))]
                    (try
                        (let [#_"Class" primc (ß maybePrimitiveType(e))]
                            (cond (ß primc == parameterTypes[i])
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                    )
                                )
                                (ß primc == int.class && parameterTypes[i] == long.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(I2L))
                                    )
                                )
                                (ß primc == long.class && parameterTypes[i] == int.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (if (ß RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                                            (do
                                                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int uncheckedIntCast(long)")))
                                            )
                                            (do
                                                (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                            )
                                        )
                                    )
                                )
                                (ß primc == float.class && parameterTypes[i] == double.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(F2D))
                                    )
                                )
                                (ß primc == double.class && parameterTypes[i] == float.class)
                                (do
                                    (let [#_"MaybePrimitiveExpr" pe (ß (MaybePrimitiveExpr) e)]
                                        (ß pe.emitUnboxed(C.EXPRESSION, objx, gen))
                                        (ß gen.visitInsn(D2F))
                                    )
                                )
                                :else
                                (do
                                    (ß e.emit(C.EXPRESSION, objx, gen))
                                    (ß HostExpr.emitUnboxArg(objx, gen, parameterTypes[i]))
                                )
                            )
                        )
                        (catch Exception e1
                            (throw (ß Util.sneakyThrow(e1)))
                        )
                    )
                )
            )
            nil
        )
    )

    (class-ns InstanceMethodExpr (§ extends MethodExpr)
        (§ field Expr target)
        (§ field String methodName)
        (§ field IPersistentVector args)
        (§ field String source)
        (§ field int line)
        (§ field int column)
        (§ field Symbol tag)
        (§ field boolean tailPosition)
        (§ field java.lang.reflect.Method method)

        (§ field Class jc)

        (§ def Method invokeInstanceMethodMethod = Method.getMethod("Object invokeInstanceMethod(Object,String,Object[])"))

        (§ constructor InstanceMethodExpr(String source, int line, int column, Symbol tag, Expr target, String methodName, IPersistentVector args, boolean tailPosition)
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.args = args)
            (ß this.methodName = methodName)
            (ß this.target = target)
            (ß this.tag = tag)
            (ß this.tailPosition = tailPosition)
            (if (ß target.hasJavaClass() && target.getJavaClass() != nil)
                (do
                    (let [#_"List" methods (ß Reflector.getMethods(target.getJavaClass(), args.count(), methodName, false))]
                        (if (ß methods.isEmpty())
                            (do
                                (ß method = nil)
                                (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                    (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName()))
                                )
                            )
                            (do
                                (let [#_"int" methodidx 0]
                                    (when (ß methods.size() > 1)
                                        (let [#_"ArrayList<Class[]>" params (ß new ArrayList())]
                                            (let [#_"ArrayList<Class>" rets (ß new ArrayList())]
                                                (loop-when-recur [(ß int i = 0)] (ß i < methods.size()) [(ß i++)]
                                                    (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i))]
                                                        (ß params.add(m.getParameterTypes()))
                                                        (ß rets.add(m.getReturnType()))
                                                    )
                                                )
                                                (ß methodidx = getMatchingParams(methodName, params, args, rets))
                                            )
                                        )
                                    )
                                    (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil))]
                                        (when (ß m != nil && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                                            ;; public method of non-public class, try to find it in hierarchy
                                            (ß m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m))
                                        )
                                        (ß method = m)
                                        (when (ß method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                            (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName(), getTypeStringForArgs(args)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (ß method = nil)
                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", SOURCE_PATH.deref(), line, column, methodName))
                    )
                )
            )
            this
        )

        (§ method Object eval()
            (try
                (let [#_"Object" targetval (ß target.eval())]
                    (let [#_"Object[]" argvals (ß new Object[args.count()])]
                        (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                            (ß argvals[i] = ((Expr) args.nth(i)).eval())
                        )
                        (when (ß method != nil)
                            (let [#_"LinkedList" ms (ß new LinkedList())]
                                (ß ms.add(method))
                                (§ return (ß Reflector.invokeMatchingMethod(methodName, ms, targetval, argvals)))
                            )
                        )
                        (ß Reflector.invokeInstanceMethod(targetval, methodName, argvals))
                    )
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        (§ method boolean canEmitPrimitive()
            (ß (method != nil && Util.isPrimitive(method.getReturnType())))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (if (ß method != nil)
                (do
                    (let [#_"Type" type (ß Type.getType(method.getDeclaringClass()))]
                        (ß target.emit(C.EXPRESSION, objx, gen))
                        (ß gen.checkCast(type))
                        (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                        (ß gen.visitLineNumber(line, gen.mark()))
                        (when (ß tailPosition && !objx.canBeDirect)
                            (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                (ß method.emitClearThis(gen))
                            )
                        )
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (if (ß method.getDeclaringClass().isInterface())
                                (do
                                    (ß gen.invokeInterface(type, m))
                                )
                                (do
                                    (ß gen.invokeVirtual(type, m))
                                )
                            )
                        )
                    )
                )
                (do
                    (throw (ß new UnsupportedOperationException("Unboxed emit of unknown member")))
                )
            )
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (if (ß method != nil)
                (do
                    (let [#_"Type" type (ß Type.getType(method.getDeclaringClass()))]
                        (ß target.emit(C.EXPRESSION, objx, gen))
                        (ß gen.checkCast(type))
                        (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                        (ß gen.visitLineNumber(line, gen.mark()))
                        (when (ß context == C.RETURN)
                            (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                (ß method.emitClearLocals(gen))
                            )
                        )
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (if (ß method.getDeclaringClass().isInterface())
                                (do
                                    (ß gen.invokeInterface(type, m))
                                )
                                (do
                                    (ß gen.invokeVirtual(type, m))
                                )
                            )
                            (ß HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
                        )
                    )
                )
                (do
                    (ß target.emit(C.EXPRESSION, objx, gen))
                    (ß gen.push(methodName))
                    (ß emitArgsAsArray(args, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeInstanceMethodMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (method != nil || tag != nil))
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil))
            )
            jc
        )
    )

    (class-ns StaticMethodExpr (§ extends MethodExpr)
        (§ field Class c)
        (§ field String methodName)
        (§ field IPersistentVector args)
        (§ field String source)
        (§ field int line)
        (§ field int column)
        (§ field java.lang.reflect.Method method)
        (§ field Symbol tag)
        (§ field boolean tailPosition)

        (§ def Method forNameMethod = Method.getMethod("Class classForName(String)"))
        (§ def Method invokeStaticMethodMethod = Method.getMethod("Object invokeStaticMethod(Class,String,Object[])"))
        (§ def Keyword warnOnBoxedKeyword = Keyword.intern("warn-on-boxed"))

        (§ field Class jc)

        (§ constructor StaticMethodExpr(String source, int line, int column, Symbol tag, Class c, String methodName, IPersistentVector args, boolean tailPosition)
            (ß this.c = c)
            (ß this.methodName = methodName)
            (ß this.args = args)
            (ß this.source = source)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.tailPosition = tailPosition)

            (let [#_"List" methods (ß Reflector.getMethods(c, args.count(), methodName, true))]
                (when (ß methods.isEmpty())
                    (throw (ß new IllegalArgumentException("No matching method: " + methodName)))
                )

                (let [#_"int" methodidx 0]
                    (when (ß methods.size() > 1)
                        (let [#_"ArrayList<Class[]>" params (ß new ArrayList())]
                            (let [#_"ArrayList<Class>" rets (ß new ArrayList())]
                                (loop-when-recur [(ß int i = 0)] (ß i < methods.size()) [(ß i++)]
                                    (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i))]
                                        (ß params.add(m.getParameterTypes()))
                                        (ß rets.add(m.getReturnType()))
                                    )
                                )
                                (ß methodidx = getMatchingParams(methodName, params, args, rets))
                            )
                        )
                    )
                    (ß method = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil))
                    (when (ß method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, c.getName(), getTypeStringForArgs(args)))
                    )
                    (when (ß method != nil && warnOnBoxedKeyword.equals(RT.UNCHECKED_MATH.deref()) && isBoxedMath(method))
                        (ß RT.errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", SOURCE_PATH.deref(), line, column, method.toString()))
                    )
                    this
                )
            )
        )

        (§ defn boolean isBoxedMath(java.lang.reflect.Method m)
            (let [#_"Class" c (ß m.getDeclaringClass())]
                (when (ß c.equals(Numbers.class))
                    (let [#_"WarnBoxedMath" boxedMath (ß m.getAnnotation(WarnBoxedMath.class))]
                        (when (ß boxedMath != nil)
                            (§ return (ß boxedMath.value()))
                        )

                        (let [#_"Class[]" argTypes (ß m.getParameterTypes())]
                            (doseq [#_"Class" argType argTypes]
                                (when (ß argType.equals(Object.class) || argType.equals(Number.class))
                                    (§ return true)
                                )
                            )
                        )
                    )
                )
                false
            )
        )

        (§ method Object eval()
            (try
                (let [#_"Object[]" argvals (ß new Object[args.count()])]
                    (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                        (ß argvals[i] = ((Expr) args.nth(i)).eval())
                    )
                    (when (ß method != nil)
                        (let [#_"LinkedList" ms (ß new LinkedList())]
                            (ß ms.add(method))
                            (§ return (ß Reflector.invokeMatchingMethod(methodName, ms, nil, argvals)))
                        )
                    )
                    (ß Reflector.invokeStaticMethod(c, methodName, argvals))
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        (§ method boolean canEmitPrimitive()
            (ß (method != nil && Util.isPrimitive(method.getReturnType())))
        )

        (§ method boolean canEmitIntrinsicPredicate()
            (ß (method != nil && RT.get(Intrinsics.preds, method.toString()) != nil))
        )

        (§ method void emitIntrinsicPredicate(C context, ObjExpr objx, GeneratorAdapter gen, Label falseLabel)
            (ß gen.visitLineNumber(line, gen.mark()))
            (if (ß method != nil)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (let [#_"Object[]" predOps (ß (Object[]) RT.get(Intrinsics.preds, method.toString()))]
                        (loop-when-recur [(ß int i = 0)] (ß i < predOps.length - 1) [(ß i++)]
                            (ß gen.visitInsn((Integer)predOps[i]))
                        )
                        (ß gen.visitJumpInsn((Integer)predOps[predOps.length - 1], falseLabel))
                    )
                )
                (do
                    (throw (ß new UnsupportedOperationException("Unboxed emit of unknown member")))
                )
            )
            nil
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (if (ß method != nil)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (let [#_"Object" ops (ß RT.get(Intrinsics.ops, method.toString()))]
                        (if (ß ops != nil)
                            (do
                                (if (ß ops instanceof Object[])
                                    (do
                                        (doseq [#_"Object" op (ß (Object[])ops)]
                                            (ß gen.visitInsn((Integer) op))
                                        )
                                    )
                                    (do
                                        (ß gen.visitInsn((Integer) ops))
                                    )
                                )
                            )
                            (do
                                (let [#_"Type" type (ß Type.getType(c))]
                                    (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                                        (ß gen.invokeStatic(type, m))
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (throw (ß new UnsupportedOperationException("Unboxed emit of unknown member")))
                )
            )
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (if (ß method != nil)
                (do
                    (ß MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß tailPosition && !objx.canBeDirect)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearThis(gen))
                        )
                    )
                    (let [#_"Type" type (ß Type.getType(c))]
                        (let [#_"Method" m (ß new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method)))]
                            (ß gen.invokeStatic(type, m))
                            (let [#_"Class" retClass (ß method.getReturnType())]
                                (if (ß context == C.STATEMENT)
                                    (do
                                        (cond (ß retClass == long.class || retClass == double.class)
                                            (do
                                                (ß gen.pop2())
                                            )
                                            (ß retClass != void.class)
                                            (do
                                                (ß gen.pop())
                                            )
                                        )
                                    )
                                    (do
                                        (ß HostExpr.emitBoxReturn(objx, gen, method.getReturnType()))
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.push(c.getName()))
                    (ß gen.invokeStatic(RT_TYPE, forNameMethod))
                    (ß gen.push(methodName))
                    (ß emitArgsAsArray(args, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (when (ß context == C.RETURN)
                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                            (ß method.emitClearLocals(gen))
                        )
                    )
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodMethod))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (method != nil || tag != nil))
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil))
            )
            jc
        )
    )

    (class-ns UnresolvedVarExpr (§ implements Expr)
        (§ field Symbol symbol)

        (§ constructor UnresolvedVarExpr(Symbol symbol)
            (ß this.symbol = symbol)
            this
        )

        (§ method boolean hasJavaClass()
            false
        )

        (§ method Class getJavaClass()
            (throw (ß new IllegalArgumentException("UnresolvedVarExpr has no Java class")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            nil
        )

        (§ method Object eval()
            (throw (ß new IllegalArgumentException("UnresolvedVarExpr cannot be evalled")))
        )
    )

    (class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
        (§ field Number n)
        (§ field int id)

        (§ constructor NumberExpr(Number n)
            (ß this.n = n)
            (ß this.id = registerConstant(n))
            this
        )

        (§ method Object val()
            n
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (when (ß context != C.STATEMENT)
                (ß objx.emitConstant(gen, id))
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (cond (ß n instanceof Integer)
                (do
                    (ß long.class)
                )
                (ß n instanceof Double)
                (do
                    (ß double.class)
                )
                (ß n instanceof Long)
                (do
                    (ß long.class)
                )
                :else
                (do
                    (throw (ß new IllegalStateException("Unsupported Number type: " + n.getClass().getName())))
                )
            )
        )

        (§ method boolean canEmitPrimitive()
            true
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (cond (ß n instanceof Integer)
                (do
                    (ß gen.push(n.longValue()))
                )
                (ß n instanceof Double)
                (do
                    (ß gen.push(n.doubleValue()))
                )
                (ß n instanceof Long)
                (do
                    (ß gen.push(n.longValue()))
                )
            )
            nil
        )

        (§ defn Expr parse(Number form)
            (if (ß form instanceof Integer || form instanceof Double || form instanceof Long)
                (do
                    (ß new NumberExpr(form))
                )
                (do
                    (ß new ConstantExpr(form))
                )
            )
        )
    )

    (class-ns ConstantExpr (§ extends LiteralExpr)
        ;; stuff quoted vals in classloader at compile time, pull out at runtime
        ;; this won't work for static compilation...
        (§ field Object v)
        (§ field int id)

        (§ constructor ConstantExpr(Object v)
            (ß this.v = v)
            (ß this.id = registerConstant(v))
            this
        )

        (§ method Object val()
            v
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitConstant(gen, id))

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß Modifier.isPublic(v.getClass().getModifiers()))
        )

        (§ method Class getJavaClass()
            (cond (ß v instanceof APersistentMap)
                (do
                    (ß APersistentMap.class)
                )
                (ß v instanceof APersistentSet)
                (do
                    (ß APersistentSet.class)
                )
                (ß v instanceof APersistentVector)
                (do
                    (ß APersistentVector.class)
                )
                :else
                (do
                    (ß v.getClass())
                )
            )
        )

        (class-ns Parser (§ implements IParser)
            (§ def Keyword formKey = Keyword.intern("form"))

            (§ method Expr parse(C context, Object form)
                (let [#_"int" argCount (ß RT.count(form) - 1)]
                    (when (ß argCount != 1)
                        (let [#_"IPersistentMap" exData (ß new PersistentArrayMap(new Object[] (§ formKey, form )))]
                            (throw (ß new ExceptionInfo("Wrong number of args (" + argCount + ") passed to quote", exData)))
                        )
                    )
                    (let [#_"Object" v (ß RT.second(form))]
                        (cond (ß v == nil)
                            (do
                                (§ return (ß NIL_EXPR))
                            )
                            (ß v == Boolean.TRUE)
                            (do
                                (§ return (ß TRUE_EXPR))
                            )
                            (ß v == Boolean.FALSE)
                            (do
                                (§ return (ß FALSE_EXPR))
                            )
                        )
                        (cond (ß v instanceof Number)
                            (do
                                (ß NumberExpr.parse((Number)v))
                            )
                            (ß v instanceof String)
                            (do
                                (ß new StringExpr((String) v))
                            )
                            (ß v instanceof IPersistentCollection && ((IPersistentCollection) v).count() == 0)
                            (do
                                (ß new EmptyExpr(v))
                            )
                            :else
                            (do
                                (ß new ConstantExpr(v))
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns NilExpr (§ extends LiteralExpr)
        (§ method Object val()
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß gen.visitInsn(Opcodes.ACONST_NULL))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            nil
        )
    )

    (§ def NilExpr NIL_EXPR = new NilExpr())

    (class-ns BooleanExpr (§ extends LiteralExpr)
        (§ field boolean val)

        (§ constructor BooleanExpr(boolean val)
            (ß this.val = val)
            this
        )

        (§ method Object val()
            (ß val ? RT.T :or RT.F)
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (if val
                (do
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                )
                (do
                    (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Boolean.class)
        )
    )

    (§ def BooleanExpr TRUE_EXPR = new BooleanExpr(true))
    (§ def BooleanExpr FALSE_EXPR = new BooleanExpr(false))

    (class-ns StringExpr (§ extends LiteralExpr)
        (§ field String str)

        (§ constructor StringExpr(String str)
            (ß this.str = str)
            this
        )

        (§ method Object val()
            str
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (when (ß context != C.STATEMENT)
                (ß gen.push(str))
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß String.class)
        )
    )

    (class-ns MonitorEnterExpr (§ extends UntypedExpr)
        (§ field Expr target)

        (§ constructor MonitorEnterExpr(Expr target)
            (ß this.target = target)
            this
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval monitor-enter")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß target.emit(C.EXPRESSION, objx, gen))
            (ß gen.monitorEnter())
            (ß NIL_EXPR.emit(context, objx, gen))
            nil
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (ß new MonitorEnterExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (class-ns MonitorExitExpr (§ extends UntypedExpr)
        (§ field Expr target)

        (§ constructor MonitorExitExpr(Expr target)
            (ß this.target = target)
            this
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval monitor-exit")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß target.emit(C.EXPRESSION, objx, gen))
            (ß gen.monitorExit())
            (ß NIL_EXPR.emit(context, objx, gen))
            nil
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (ß new MonitorExitExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (class-ns TryExpr (§ implements Expr)
        (§ field Expr tryExpr)
        (§ field Expr finallyExpr)
        (§ field PersistentVector catchExprs)
        (§ field int retLocal)
        (§ field int finallyLocal)

        (class-ns CatchClause
            (§ field Class c)
            (§ field LocalBinding lb)
            (§ field Expr handler)
            (§ field Label label)
            (§ field Label endLabel)

            (§ constructor CatchClause(Class c, LocalBinding lb, Expr handler)
                (ß this.c = c)
                (ß this.lb = lb)
                (ß this.handler = handler)
                this
            )
        )

        (§ constructor TryExpr(Expr tryExpr, PersistentVector catchExprs, Expr finallyExpr, int retLocal, int finallyLocal)
            (ß this.tryExpr = tryExpr)
            (ß this.catchExprs = catchExprs)
            (ß this.finallyExpr = finallyExpr)
            (ß this.retLocal = retLocal)
            (ß this.finallyLocal = finallyLocal)
            this
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval try")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (let [#_"Label" startTry (ß gen.newLabel())]
                (let [#_"Label" endTry (ß gen.newLabel())]
                    (let [#_"Label" end (ß gen.newLabel())]
                        (let [#_"Label" ret (ß gen.newLabel())]
                            (let [#_"Label" finallyLabel (ß gen.newLabel())]
                                (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß clause.label = gen.newLabel())
                                        (ß clause.endLabel = gen.newLabel())
                                    )
                                )

                                (ß gen.mark(startTry))
                                (ß tryExpr.emit(context, objx, gen))
                                (when (ß context != C.STATEMENT)
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
                                )
                                (ß gen.mark(endTry))
                                (when (ß finallyExpr != nil)
                                    (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                )
                                (ß gen.goTo(ret))

                                (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.mark(clause.label))
                                        ;; exception should be on stack
                                        ;; put in clause local
                                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), clause.lb.idx))
                                        (ß clause.handler.emit(context, objx, gen))
                                        (when (ß context != C.STATEMENT)
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal))
                                        )
                                        (ß gen.mark(clause.endLabel))

                                        (when (ß finallyExpr != nil)
                                            (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                        )
                                        (ß gen.goTo(ret))
                                    )
                                )
                                (when (ß finallyExpr != nil)
                                    (ß gen.mark(finallyLabel))
                                    ;; exception should be on stack
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), finallyLocal))
                                    (ß finallyExpr.emit(C.STATEMENT, objx, gen))
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), finallyLocal))
                                    (ß gen.throwException())
                                )
                                (ß gen.mark(ret))
                                (when (ß context != C.STATEMENT)
                                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), retLocal))
                                )
                                (ß gen.mark(end))
                                (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.visitTryCatchBlock(startTry, endTry, clause.label, clause.c.getName().replace(\., \/)))
                                    )
                                )
                                (when (ß finallyExpr != nil)
                                    (ß gen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))
                                    (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                        (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                            (ß gen.visitTryCatchBlock(clause.label, clause.endLabel, finallyLabel, nil))
                                        )
                                    )
                                )
                                (loop-when-recur [(ß int i = 0)] (ß i < catchExprs.count()) [(ß i++)]
                                    (let [#_"CatchClause" clause (ß (CatchClause) catchExprs.nth(i))]
                                        (ß gen.visitLocalVariable(clause.lb.name, "Ljava/lang/Object;", nil, clause.label, clause.endLabel, clause.lb.idx))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )

        (§ method boolean hasJavaClass()
            (ß tryExpr.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß tryExpr.getJavaClass())
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß context != C.RETURN)
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )

                    ;; (try try-expr* catch-expr* finally-expr?)
                    ;; catch-expr: (catch class sym expr*)
                    ;; finally-expr: (finally expr*)

                    (let [#_"PersistentVector" body (ß PersistentVector.EMPTY)]
                        (let [#_"PersistentVector" catches (ß PersistentVector.EMPTY)]
                            (let [#_"Expr" bodyExpr nil]
                                (let [#_"Expr" finallyExpr nil]
                                    (let [#_"boolean" caught false]
                                        (let [#_"int" retLocal (ß getAndIncLocalNum())]
                                            (let [#_"int" finallyLocal (ß getAndIncLocalNum())]
                                                (loop-when-recur [(ß ISeq fs = form.next())] (ß fs != nil) [(ß fs = fs.next())]
                                                    (let [#_"Object" f (ß fs.first())]
                                                        (let [#_"Object" op (ß (f instanceof ISeq) ? ((ISeq) f).first() :or nil)]
                                                            (if (ß !Util.equals(op, CATCH) && !Util.equals(op, FINALLY))
                                                                (do
                                                                    (when caught
                                                                        (throw (ß Util.runtimeException("Only catch or finally clause can follow catch in try expression")))
                                                                    )
                                                                    (ß body = body.cons(f))
                                                                )
                                                                (do
                                                                    (when (ß bodyExpr == nil)
                                                                        (try
                                                                            (ß Var.pushThreadBindings(RT.map(NO_RECUR, true, METHOD_RETURN_CONTEXT, nil)))
                                                                            (ß bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body)))
                                                                            (finally
                                                                                (ß Var.popThreadBindings())
                                                                            )
                                                                        )
                                                                    )

                                                                    (cond (ß Util.equals(op, CATCH))
                                                                        (do
                                                                            (let [#_"Class" c (ß HostExpr.maybeClass(RT.second(f), false))]
                                                                                (when (ß c == nil)
                                                                                    (throw (ß new IllegalArgumentException("Unable to resolve classname: " + RT.second(f))))
                                                                                )
                                                                                (when (ß !(RT.third(f) instanceof Symbol))
                                                                                    (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + RT.third(f))))
                                                                                )
                                                                                (let [#_"Symbol" sym (ß (Symbol) RT.third(f))]
                                                                                    (when (ß sym.getNamespace() != nil)
                                                                                        (throw (ß Util.runtimeException("Can't bind qualified name:" + sym)))
                                                                                    )

                                                                                    (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(), IN_CATCH_FINALLY, RT.T))]
                                                                                        (try
                                                                                            (ß Var.pushThreadBindings(dynamicBindings))
                                                                                            (let [#_"LocalBinding" lb (ß registerLocal(sym, (Symbol) ((RT.second(f) instanceof Symbol) ? RT.second(f) :or nil), nil, false))]
                                                                                                (let [#_"Expr" handler (ß (new BodyExpr.Parser()).parse(C.EXPRESSION, RT.next(RT.next(RT.next(f)))))]
                                                                                                    (ß catches = catches.cons(new CatchClause(c, lb, handler)))
                                                                                                )
                                                                                            )
                                                                                            (finally
                                                                                                (ß Var.popThreadBindings())
                                                                                            )
                                                                                        )
                                                                                        (ß caught = true)
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        :else ;; finally
                                                                        (do
                                                                            (when (ß fs.next() != nil)
                                                                                (throw (ß Util.runtimeException("finally clause must be last in try expression")))
                                                                            )
                                                                            (try
                                                                                (ß Var.pushThreadBindings(RT.map(IN_CATCH_FINALLY, RT.T)))
                                                                                (ß finallyExpr = (new BodyExpr.Parser()).parse(C.STATEMENT, RT.next(f)))
                                                                                (finally
                                                                                    (ß Var.popThreadBindings())
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (when (ß bodyExpr == nil)
                                                    ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                                                    ;; return a body expr directly
                                                    (try
                                                        (ß Var.pushThreadBindings(RT.map(NO_RECUR, true)))
                                                        (ß bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body)))
                                                        (finally
                                                            (ß Var.popThreadBindings())
                                                        )
                                                    )
                                                    (§ return bodyExpr)
                                                )

                                                (ß new TryExpr(bodyExpr, catches, finallyExpr, retLocal, finallyLocal))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns ThrowExpr (§ extends UntypedExpr)
        (§ field Expr excExpr)

        (§ constructor ThrowExpr(Expr excExpr)
            (ß this.excExpr = excExpr)
            this
        )

        (§ method Object eval()
            (throw (ß Util.runtimeException("Can't eval throw")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß excExpr.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(THROWABLE_TYPE))
            (ß gen.throwException())
            nil
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object form)
                (cond (ß context == C.EVAL)
                    (do
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )
                    (ß RT.count(form) == 1)
                    (do
                        (throw (ß Util.runtimeException("Too few arguments to throw, throw expects a single Throwable instance")))
                    )
                    (ß RT.count(form) > 2)
                    (do
                        (throw (ß Util.runtimeException("Too many arguments to throw, throw expects a single Throwable instance")))
                    )
                )
                (ß new ThrowExpr(analyze(C.EXPRESSION, RT.second(form))))
            )
        )
    )

    (§ defn boolean subsumes(Class[] c1, Class[] c2)
        ;; presumes matching lengths
        (let [#_"Boolean" better false]
            (loop-when-recur [(ß int i = 0)] (ß i < c1.length) [(ß i++)]
                (when (ß c1[i] != c2[i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
                    (if (ß !c1[i].isPrimitive() && c2[i].isPrimitive() || c2[i].isAssignableFrom(c1[i]))
                        (do
                            (ß better = true)
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )
            better
        )
    )

    (§ defn String getTypeStringForArgs(IPersistentVector args)
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                (let [#_"Expr" arg (ß (Expr) args.nth(i))]
                    (when (ß i > 0)
                        (ß sb.append(", "))
                    )
                    (ß sb.append((arg.hasJavaClass() && arg.getJavaClass() != nil) ? arg.getJavaClass().getName() :or "unknown"))
                )
            )
            (ß sb.toString())
        )
    )

    (§ defn int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, IPersistentVector argexprs, List<Class> rets)
        ;; presumes matching lengths
        (let [#_"int" matchIdx -1]
            (let [#_"boolean" tied false]
                (let [#_"boolean" foundExact false]
                    (loop-when-recur [(ß int i = 0)] (ß i < paramlists.size()) [(ß i++)]
                        (let [#_"boolean" match true]
                            (let [#_"ISeq" aseq (ß argexprs.seq())]
                                (let [#_"int" exact 0]
                                    (loop-when-recur [(ß int p = 0)] (ß match && p < argexprs.count() && aseq != nil) [(ß ++p, aseq = aseq.next())]
                                        (let [#_"Expr" arg (ß (Expr) aseq.first())]
                                            (let [#_"Class" aclass (ß arg.hasJavaClass() ? arg.getJavaClass() :or Object.class)]
                                                (let [#_"Class" pclass (ß paramlists.get(i)[p])]
                                                    (if (ß arg.hasJavaClass() && aclass == pclass)
                                                        (do
                                                            (ß exact++)
                                                        )
                                                        (do
                                                            (ß match = Reflector.paramArgTypeMatch(pclass, aclass))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (cond (ß exact == argexprs.count())
                                        (do
                                            (when (ß !foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                                                (ß matchIdx = i)
                                            )
                                            (ß tied = false)
                                            (ß foundExact = true)
                                        )
                                        (ß match && !foundExact)
                                        (do
                                            (if (ß matchIdx == -1)
                                                (do
                                                    (ß matchIdx = i)
                                                )
                                                (do
                                                    (cond (ß subsumes(paramlists.get(i), paramlists.get(matchIdx)))
                                                        (do
                                                            (ß matchIdx = i)
                                                            (ß tied = false)
                                                        )
                                                        (ß Arrays.equals(paramlists.get(matchIdx), paramlists.get(i)))
                                                        (do
                                                            (when (ß rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                                                                (ß matchIdx = i)
                                                            )
                                                        )
                                                        (ß !(subsumes(paramlists.get(matchIdx), paramlists.get(i))))
                                                        (do
                                                            (ß tied = true)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when tied
                        (throw (ß new IllegalArgumentException("More than one matching method found: " + methodName)))
                    )

                    matchIdx
                )
            )
        )
    )

    (class-ns NewExpr (§ implements Expr)
        (§ field IPersistentVector args)
        (§ field Constructor ctor)
        (§ field Class c)

        (§ def Method invokeConstructorMethod = Method.getMethod("Object invokeConstructor(Class,Object[])"))
        (§ def Method forNameMethod = Method.getMethod("Class classForName(String)"))

        (§ constructor NewExpr(Class c, IPersistentVector args, int line, int column)
            (ß this.args = args)
            (ß this.c = c)
            (let [#_"Constructor[]" allctors (ß c.getConstructors())]
                (let [#_"ArrayList" ctors (ß new ArrayList())]
                    (let [#_"ArrayList<Class[]>" params (ß new ArrayList())]
                        (let [#_"ArrayList<Class>" rets (ß new ArrayList())]
                            (loop-when-recur [(ß int i = 0)] (ß i < allctors.length) [(ß i++)]
                                (let [#_"Constructor" ctor (ß allctors[i])]
                                    (when (ß ctor.getParameterTypes().length == args.count())
                                        (ß ctors.add(ctor))
                                        (ß params.add(ctor.getParameterTypes()))
                                        (ß rets.add(c))
                                    )
                                )
                            )
                            (when (ß ctors.isEmpty())
                                (throw (ß new IllegalArgumentException("No matching ctor found for " + c)))
                            )

                            (let [#_"int" ctoridx 0]
                                (when (ß ctors.size() > 1)
                                    (ß ctoridx = getMatchingParams(c.getName(), params, args, rets))
                                )

                                (ß this.ctor = (ctoridx >= 0) ? (Constructor) ctors.get(ctoridx) :or nil)
                                (when (ß ctor == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                    (ß RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", SOURCE_PATH.deref(), line, column, c.getName()))
                                )
                                this
                            )
                        )
                    )
                )
            )
        )

        (§ method Object eval()
            (let [#_"Object[]" argvals (ß new Object[args.count()])]
                (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß argvals[i] = ((Expr) args.nth(i)).eval())
                )
                (when (ß this.ctor != nil)
                    (try
                        (§ return (ß ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), argvals))))
                        (catch Exception e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (ß Reflector.invokeConstructor(c, argvals))
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (if (ß this.ctor != nil)
                (do
                    (let [#_"Type" type (ß getType(c))]
                        (ß gen.newInstance(type))
                        (ß gen.dup())
                        (ß MethodExpr.emitTypedArgs(objx, gen, ctor.getParameterTypes(), args))
                        (ß gen.invokeConstructor(type, new Method("<init>", Type.getConstructorDescriptor(ctor))))
                    )
                )
                (do
                    (ß gen.push(destubClassName(c.getName())))
                    (ß gen.invokeStatic(RT_TYPE, forNameMethod))
                    (ß MethodExpr.emitArgsAsArray(args, objx, gen))
                    (ß gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMethod))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            c
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"int" line (ß lineDeref())]
                    (let [#_"int" column (ß columnDeref())]
                        (let [#_"ISeq" form (ß (ISeq) frm)]
                            ;; (new Classname args...)
                            (when (ß form.count() < 2)
                                (throw (ß Util.runtimeException("wrong number of arguments, expecting: (new Classname args...)")))
                            )
                            (let [#_"Class" c (ß HostExpr.maybeClass(RT.second(form), false))]
                                (when (ß c == nil)
                                    (throw (ß new IllegalArgumentException("Unable to resolve classname: " + RT.second(form))))
                                )
                                (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                    (loop-when-recur [(ß ISeq s = RT.next(RT.next(form)))] (ß s != nil) [(ß s = s.next())]
                                        (ß args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first())))
                                    )
                                    (ß new NewExpr(c, args, line, column))
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns MetaExpr (§ implements Expr)
        (§ field Expr expr)
        (§ field Expr meta)

        (§ def Type IOBJ_TYPE = Type.getType(IObj.class))
        (§ def Method withMetaMethod = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

        (§ constructor MetaExpr(Expr expr, Expr meta)
            (ß this.expr = expr)
            (ß this.meta = meta)
            this
        )

        (§ method Object eval()
            (ß ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval()))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(IOBJ_TYPE))
            (ß meta.emit(C.EXPRESSION, objx, gen))
            (ß gen.checkCast(IPERSISTENTMAP_TYPE))
            (ß gen.invokeInterface(IOBJ_TYPE, withMetaMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß expr.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß expr.getJavaClass())
        )
    )

    (class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Expr testExpr)
        (§ field Expr thenExpr)
        (§ field Expr elseExpr)
        (§ field int line)
        (§ field int column)

        (§ constructor IfExpr(int line, int column, Expr testExpr, Expr thenExpr, Expr elseExpr)
            (ß this.testExpr = testExpr)
            (ß this.thenExpr = thenExpr)
            (ß this.elseExpr = elseExpr)
            (ß this.line = line)
            (ß this.column = column)
            this
        )

        (§ method Object eval()
            (let [#_"Object" t (ß testExpr.eval())]
                (when (ß t != nil && t != Boolean.FALSE)
                    (§ return (ß thenExpr.eval()))
                )
                (ß elseExpr.eval())
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, false))
            nil
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, true))
            nil
        )

        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (let [#_"Label" nullLabel (ß gen.newLabel())]
                (let [#_"Label" falseLabel (ß gen.newLabel())]
                    (let [#_"Label" endLabel (ß gen.newLabel())]
                        (ß gen.visitLineNumber(line, gen.mark()))

                        (cond (ß testExpr instanceof StaticMethodExpr && ((StaticMethodExpr)testExpr).canEmitIntrinsicPredicate())
                            (do
                                (ß ((StaticMethodExpr) testExpr).emitIntrinsicPredicate(C.EXPRESSION, objx, gen, falseLabel))
                            )
                            (ß maybePrimitiveType(testExpr) == boolean.class)
                            (do
                                (ß ((MaybePrimitiveExpr) testExpr).emitUnboxed(C.EXPRESSION, objx, gen))
                                (ß gen.ifZCmp(gen.EQ, falseLabel))
                            )
                            :else
                            (do
                                (ß testExpr.emit(C.EXPRESSION, objx, gen))
                                (ß gen.dup())
                                (ß gen.ifNull(nullLabel))
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                                (ß gen.visitJumpInsn(IF_ACMPEQ, falseLabel))
                            )
                        )
                        (if emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)thenExpr).emitUnboxed(context, objx, gen))
                            )
                            (do
                                (ß thenExpr.emit(context, objx, gen))
                            )
                        )
                        (ß gen.goTo(endLabel))
                        (ß gen.mark(nullLabel))
                        (ß gen.pop())
                        (ß gen.mark(falseLabel))
                        (if emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)elseExpr).emitUnboxed(context, objx, gen))
                            )
                            (do
                                (ß elseExpr.emit(context, objx, gen))
                            )
                        )
                        (ß gen.mark(endLabel))
                        nil
                    )
                )
            )
        )

        (§ method boolean hasJavaClass()
            (ß thenExpr.hasJavaClass()
                && elseExpr.hasJavaClass()
                && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                    || thenExpr.getJavaClass() == RECUR_CLASS
                    || elseExpr.getJavaClass() == RECUR_CLASS
                    || (thenExpr.getJavaClass() == nil && !elseExpr.getJavaClass().isPrimitive())
                    || (elseExpr.getJavaClass() == nil && !thenExpr.getJavaClass().isPrimitive())))
        )

        (§ method boolean canEmitPrimitive()
            (try
                (ß thenExpr instanceof MaybePrimitiveExpr
                    && elseExpr instanceof MaybePrimitiveExpr
                    && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                            || thenExpr.getJavaClass() == RECUR_CLASS
                            || elseExpr.getJavaClass() == RECUR_CLASS)
                    && ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
                    && ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive())
                (catch Exception e
                    false
                )
            )
        )

        (§ method Class getJavaClass()
            (let [#_"Class" thenClass (ß thenExpr.getJavaClass())]
                (when (ß thenClass != nil && thenClass != RECUR_CLASS)
                    (§ return thenClass)
                )
                (ß elseExpr.getJavaClass())
            )
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (if test then) or (if test then else)
                    (cond (ß form.count() > 4)
                        (do
                            (throw (ß Util.runtimeException("Too many arguments to if")))
                        )
                        (ß form.count() < 3)
                        (do
                            (throw (ß Util.runtimeException("Too few arguments to if")))
                        )
                    )
                    (let [#_"PathNode" branch (ß new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))]
                        (let [#_"Expr" testexpr (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form)))]
                            (let [(ß Expr thenexpr, elseexpr)]
                                (try
                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                    (ß thenexpr = analyze(context, RT.third(form)))
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                                (try
                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                    (ß elseexpr = analyze(context, RT.fourth(form)))
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                                (ß new IfExpr(lineDeref(), columnDeref(), testexpr, thenexpr, elseexpr))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ def IPersistentMap CHAR_MAP = PersistentHashMap.create(
      #_map \-, "_",
      #_map \:, "_COLON_",
      #_map \+, "_PLUS_",
      #_map \>, "_GT_",
      #_map \<, "_LT_",
      #_map \=, "_EQ_",
      #_map \~, "_TILDE_",
      #_map \!, "_BANG_",
      #_map \@, "_CIRCA_",
      #_map \#, "_SHARP_",
      #_map \', "_SINGLEQUOTE_",
      #_map \", "_DOUBLEQUOTE_", ;; oops! "
      #_map \%, "_PERCENT_",
      #_map \^, "_CARET_",
      #_map \&, "_AMPERSAND_",
      #_map \*, "_STAR_",
      #_map \|, "_BAR_",
      #_map \{, "_LBRACE_",
      #_map \}, "_RBRACE_",
      #_map \[, "_LBRACK_",
      #_map \], "_RBRACK_",
      #_map \/, "_SLASH_",
      #_map \\, "_BSLASH_",
      #_map \?, "_QMARK_"
    ))

    (§ def IPersistentMap DEMUNGE_MAP)
    (§ def Pattern DEMUNGE_PATTERN)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (let [#_"IPersistentMap" m (ß RT.map("$", \/))]
            (loop-when-recur [(ß ISeq s = RT.seq(CHAR_MAP))] (ß s != nil) [(ß s = s.next())]
                (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                    (let [#_"Character" origCh (ß (Character) e.key())]
                        (let [#_"String" escapeStr (ß (String) e.val())]
                            (ß m = m.assoc(escapeStr, origCh))
                        )
                    )
                )
            )
            (ß DEMUNGE_MAP = m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of
            ;; the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
            ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
            ;; as desired.  Sorting string keys of DEMUNGE_MAP from longest to
            ;; shortest ensures correct matching behavior, even if some strings are
            ;; prefixes of others.
            (let [#_"Object[]" mungeStrs (ß RT.toArray(RT.keys(m)))]
                (ß Arrays.sort(mungeStrs, new Comparator()
                    (§ reify
                        (§ method int compare(Object s1, Object s2)
                            (ß ((String) s2).length() - ((String) s1).length())
                        )
                    ))
                )
                (let [#_"StringBuilder" sb (ß new StringBuilder())]
                    (let [#_"boolean" first true]
                        (doseq [#_"Object" s mungeStrs]
                            (let [#_"String" escapeStr (ß (String) s)]
                                (when (ß !first)
                                    (ß sb.append("|"))
                                )
                                (ß first = false)
                                (ß sb.append("\\Q"))
                                (ß sb.append(escapeStr))
                                (ß sb.append("\\E"))
                            )
                        )
                        (ß DEMUNGE_PATTERN = Pattern.compile(sb.toString()))
                    )
                )
            )
        )
    )

    (§ defn String munge(String name)
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (doseq [#_"char" c (ß name.toCharArray())]
                (let [#_"String" sub (ß (String) CHAR_MAP.valAt(c))]
                    (if (ß sub != nil)
                        (do
                            (ß sb.append(sub))
                        )
                        (do
                            (ß sb.append(c))
                        )
                    )
                )
            )
            (ß sb.toString())
        )
    )

    (§ defn String demunge(String mungedName)
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (let [#_"Matcher" m (ß DEMUNGE_PATTERN.matcher(mungedName))]
                (let [#_"int" lastMatchEnd 0]
                    (while (ß m.find())
                        (let [#_"int" start (ß m.start())]
                            (let [#_"int" end (ß m.end())]
                                ;; Keep everything before the match
                                (ß sb.append(mungedName.substring(lastMatchEnd, start)))
                                (ß lastMatchEnd = end)
                                ;; Replace the match with DEMUNGE_MAP result
                                (let [#_"Character" origCh (ß (Character) DEMUNGE_MAP.valAt(m.group()))]
                                    (ß sb.append(origCh))
                                )
                            )
                        )
                    )
                    ;; Keep everything after the last match
                    (ß sb.append(mungedName.substring(lastMatchEnd)))
                    (ß sb.toString())
                )
            )
        )
    )

    (class-ns EmptyExpr (§ implements Expr)
        (§ field Object coll)

        (§ def Type HASHMAP_TYPE = Type.getType(PersistentArrayMap.class))
        (§ def Type HASHSET_TYPE = Type.getType(PersistentHashSet.class))
        (§ def Type VECTOR_TYPE = Type.getType(PersistentVector.class))
        (§ def Type IVECTOR_TYPE = Type.getType(IPersistentVector.class))
        (§ def Type TUPLE_TYPE = Type.getType(Tuple.class))
        (§ def Type LIST_TYPE = Type.getType(PersistentList.class))
        (§ def Type EMPTY_LIST_TYPE = Type.getType(PersistentList.EmptyList.class))

        (§ constructor EmptyExpr(Object coll)
            (ß this.coll = coll)
            this
        )

        (§ method Object eval()
            coll
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (cond (ß coll instanceof IPersistentList)
                (do
                    (ß gen.getStatic(LIST_TYPE, "EMPTY", EMPTY_LIST_TYPE))
                )
                (ß coll instanceof IPersistentVector)
                (do
                    (ß gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE))
                )
                (ß coll instanceof IPersistentMap)
                (do
                    (ß gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE))
                )
                (ß coll instanceof IPersistentSet)
                (do
                    (ß gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE))
                )
                :else
                (do
                    (throw (ß new UnsupportedOperationException("Unknown Collection type")))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (cond (ß coll instanceof IPersistentList)
                (do
                    (ß IPersistentList.class)
                )
                (ß coll instanceof IPersistentVector)
                (do
                    (ß IPersistentVector.class)
                )
                (ß coll instanceof IPersistentMap)
                (do
                    (ß IPersistentMap.class)
                )
                (ß coll instanceof IPersistentSet)
                (do
                    (ß IPersistentSet.class)
                )
                :else
                (do
                    (throw (ß new UnsupportedOperationException("Unknown Collection type")))
                )
            )
        )
    )

    (class-ns ListExpr (§ implements Expr)
        (§ field IPersistentVector args)

        (§ def Method arrayToListMethod = Method.getMethod("cloiure.lang.ISeq arrayToList(Object[])"))

        (§ constructor ListExpr(IPersistentVector args)
            (ß this.args = args)
            this
        )

        (§ method Object eval()
            (let [#_"IPersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval()))
                )
                (ß ret.seq())
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß MethodExpr.emitArgsAsArray(args, objx, gen))
            (ß gen.invokeStatic(RT_TYPE, arrayToListMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß IPersistentList.class)
        )
    )

    (class-ns MapExpr (§ implements Expr)
        (§ field IPersistentVector keyvals)

        (§ def Method mapMethod = Method.getMethod("cloiure.lang.IPersistentMap map(Object[])"))
        (§ def Method mapUniqueKeysMethod = Method.getMethod("cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

        (§ constructor MapExpr(IPersistentVector keyvals)
            (ß this.keyvals = keyvals)
            this
        )

        (§ method Object eval()
            (let [#_"Object[]" ret (ß new Object[keyvals.count()])]
                (loop-when-recur [(ß int i = 0)] (ß i < keyvals.count()) [(ß i++)]
                    (ß ret[i] = ((Expr) keyvals.nth(i)).eval())
                )
                (ß RT.map(ret))
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (let [#_"boolean" allKeysConstant true]
                (let [#_"boolean" allConstantKeysUnique true]
                    (let [#_"IPersistentSet" constantKeys (ß PersistentHashSet.EMPTY)]
                        (loop-when-recur [(ß int i = 0)] (ß i < keyvals.count()) [(ß i+=2)]
                            (let [#_"Expr" k (ß (Expr) keyvals.nth(i))]
                                (if (ß k instanceof LiteralExpr)
                                    (do
                                        (let [#_"Object" kval (ß k.eval())]
                                            (if (ß constantKeys.contains(kval))
                                                (do
                                                    (ß allConstantKeysUnique = false)
                                                )
                                                (do
                                                    (ß constantKeys = (IPersistentSet)constantKeys.cons(kval))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (ß allKeysConstant = false)
                                    )
                                )
                            )
                        )
                        (ß MethodExpr.emitArgsAsArray(keyvals, objx, gen))
                        (if (ß (allKeysConstant && allConstantKeysUnique) || (keyvals.count() <= 2))
                            (do
                                (ß gen.invokeStatic(RT_TYPE, mapUniqueKeysMethod))
                            )
                            (do
                                (ß gen.invokeStatic(RT_TYPE, mapMethod))
                            )
                        )
                        (when (ß context == C.STATEMENT)
                            (ß gen.pop())
                        )
                        nil
                    )
                )
            )
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß IPersistentMap.class)
        )

        (§ defn Expr parse(C context, IPersistentMap form)
            (let [#_"IPersistentVector" keyvals (ß PersistentVector.EMPTY)]
                (let [#_"boolean" keysConstant true]
                    (let [#_"boolean" valsConstant true]
                        (let [#_"boolean" allConstantKeysUnique true]
                            (let [#_"IPersistentSet" constantKeys (ß PersistentHashSet.EMPTY)]
                                (loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                                    (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                                        (let [#_"Expr" k (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.key()))]
                                            (let [#_"Expr" v (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.val()))]
                                                (ß keyvals = (IPersistentVector) keyvals.cons(k))
                                                (ß keyvals = (IPersistentVector) keyvals.cons(v))
                                                (if (ß k instanceof LiteralExpr)
                                                    (do
                                                        (let [#_"Object" kval (ß k.eval())]
                                                            (if (ß constantKeys.contains(kval))
                                                                (do
                                                                    (ß allConstantKeysUnique = false)
                                                                )
                                                                (do
                                                                    (ß constantKeys = (IPersistentSet)constantKeys.cons(kval))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (do
                                                        (ß keysConstant = false)
                                                    )
                                                )
                                                (when (ß !(v instanceof LiteralExpr))
                                                    (ß valsConstant = false)
                                                )
                                            )
                                        )
                                    )
                                )

                                (let [#_"Expr" ret (ß new MapExpr(keyvals))]
                                    (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                                        (do
                                            (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                                        )
                                        keysConstant
                                        (do
                                            ;; TBD: Add more detail to exception thrown below.
                                            (when (ß !allConstantKeysUnique)
                                                (throw (ß new IllegalArgumentException("Duplicate constant keys in map")))
                                            )
                                            (if valsConstant
                                                (do
                                                    (let [#_"IPersistentMap" m (ß PersistentArrayMap.EMPTY)]
                                                        (loop-when-recur [(ß int i = 0)] (ß i < keyvals.length()) [(ß i += 2)]
                                                            (ß m = m.assoc(((LiteralExpr)keyvals.nth(i)).val(), ((LiteralExpr)keyvals.nth(i + 1)).val()))
                                                        )
                                                        (ß new ConstantExpr(m))
                                                    )
                                                )
                                                (do
                                                    ret
                                                )
                                            )
                                        )
                                        :else
                                        (do
                                            ret
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns SetExpr (§ implements Expr)
        (§ field IPersistentVector keys)

        (§ def Method setMethod = Method.getMethod("cloiure.lang.IPersistentSet set(Object[])"))

        (§ constructor SetExpr(IPersistentVector keys)
            (ß this.keys = keys)
            this
        )

        (§ method Object eval()
            (let [#_"Object[]" ret (ß new Object[keys.count()])]
                (loop-when-recur [(ß int i = 0)] (ß i < keys.count()) [(ß i++)]
                    (ß ret[i] = ((Expr) keys.nth(i)).eval())
                )
                (ß RT.set(ret))
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß MethodExpr.emitArgsAsArray(keys, objx, gen))
            (ß gen.invokeStatic(RT_TYPE, setMethod))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß IPersistentSet.class)
        )

        (§ defn Expr parse(C context, IPersistentSet form)
            (let [#_"IPersistentVector" keys (ß PersistentVector.EMPTY)]
                (let [#_"boolean" constant true]
                    (loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"Object" e (ß s.first())]
                            (let [#_"Expr" expr (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, e))]
                                (ß keys = (IPersistentVector) keys.cons(expr))
                                (when (ß !(expr instanceof LiteralExpr))
                                    (ß constant = false)
                                )
                            )
                        )
                    )
                    (let [#_"Expr" ret (ß new SetExpr(keys))]
                        (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                            (do
                                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                            )
                            constant
                            (do
                                (let [#_"IPersistentSet" set (ß PersistentHashSet.EMPTY)]
                                    (loop-when-recur [(ß int i = 0)] (ß i < keys.count()) [(ß i++)]
                                        (let [#_"LiteralExpr" ve (ß (LiteralExpr)keys.nth(i))]
                                            (ß set = (IPersistentSet)set.cons(ve.val()))
                                        )
                                    )
                                    (ß new ConstantExpr(set))
                                )
                            )
                            :else
                            (do
                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns VectorExpr (§ implements Expr)
        (§ field IPersistentVector args)

        (§ def Method vectorMethod = Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])"))

        (§ constructor VectorExpr(IPersistentVector args)
            (ß this.args = args)
            this
        )

        (§ method Object eval()
            (let [#_"IPersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                    (ß ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval()))
                )
                ret
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (if (ß args.count() <= Tuple.MAX_SIZE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                        (ß ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen))
                    )
                    (ß gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
                )
                (do
                    (ß MethodExpr.emitArgsAsArray(args, objx, gen))
                    (ß gen.invokeStatic(RT_TYPE, vectorMethod))
                )
            )

            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß IPersistentVector.class)
        )

        (§ defn Expr parse(C context, IPersistentVector form)
            (let [#_"boolean" constant true]
                (let [#_"IPersistentVector" args (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(ß int i = 0)] (ß i < form.count()) [(ß i++)]
                        (let [#_"Expr" v (ß analyze((context == C.EVAL) ? context :or C.EXPRESSION, form.nth(i)))]
                            (ß args = (IPersistentVector) args.cons(v))
                            (when (ß !(v instanceof LiteralExpr))
                                (ß constant = false)
                            )
                        )
                    )
                    (let [#_"Expr" ret (ß new VectorExpr(args))]
                        (cond (ß form instanceof IObj && ((IObj) form).meta() != nil)
                            (do
                                (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                            )
                            constant
                            (do
                                (let [#_"IPersistentVector" rv (ß PersistentVector.EMPTY)]
                                    (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                                        (let [#_"LiteralExpr" ve (ß (LiteralExpr)args.nth(i))]
                                            (ß rv = rv.cons(ve.val()))
                                        )
                                    )
                                    (ß new ConstantExpr(rv))
                                )
                            )
                            :else
                            (do
                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns KeywordInvokeExpr (§ implements Expr)
        (§ field KeywordExpr kw)
        (§ field Object tag)
        (§ field Expr target)
        (§ field int line)
        (§ field int column)
        (§ field int siteIndex)
        (§ field String source)

        (§ def Type ILOOKUP_TYPE = Type.getType(ILookup.class))

        (§ field Class jc)

        (§ constructor KeywordInvokeExpr(String source, int line, int column, Symbol tag, KeywordExpr kw, Expr target)
            (ß this.source = source)
            (ß this.kw = kw)
            (ß this.target = target)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tag = tag)
            (ß this.siteIndex = registerKeywordCallsite(kw.k))
            this
        )

        (§ method Object eval()
            (try
                (ß kw.k.invoke(target.eval()))
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (let [#_"Label" endLabel (ß gen.newLabel())]
                (let [#_"Label" faultLabel (ß gen.newLabel())]
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.getStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE))
                    (ß gen.dup()) ;; thunk, thunk
                    (ß target.emit(C.EXPRESSION, objx, gen)) ;; thunk, thunk, target
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.dupX2()) ;; target, thunk, thunk, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; target, thunk, result
                    (ß gen.dupX2()) ;; result, target, thunk, result
                    (ß gen.visitJumpInsn(IF_ACMPEQ, faultLabel)) ;; result, target
                    (ß gen.pop()) ;; result
                    (ß gen.goTo(endLabel))

                    (ß gen.mark(faultLabel)) ;; result, target
                    (ß gen.swap()) ;; target, result
                    (ß gen.pop()) ;; target
                    (ß gen.dup()) ;; target, target
                    (ß gen.getStatic(objx.objtype, objx.siteNameStatic(siteIndex), ObjExpr.KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
                    (ß gen.swap()) ;; target, site, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_SITE_TYPE, Method.getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
                    (ß gen.dup()) ;; target, new-thunk, new-thunk
                    (ß gen.putStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
                    (ß gen.swap()) ;; new-thunk, target
                    (ß gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)"))) ;; result

                    (ß gen.mark(endLabel))
                    (when (ß context == C.STATEMENT)
                        (ß gen.pop())
                    )
                    nil
                )
            )
        )

        (§ method boolean hasJavaClass()
            (ß (tag != nil))
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )
    )

    (class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Expr expr)
        (§ field Class c)

        (§ constructor InstanceOfExpr(Class c, Expr expr)
            (ß this.expr = expr)
            (ß this.c = c)
            this
        )

        (§ method Object eval()
            (when (ß c.isInstance(expr.eval()))
                (§ return (ß RT.T))
            )
            (ß RT.F)
        )

        (§ method boolean canEmitPrimitive()
            true
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.instanceOf(getType(c)))
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß emitUnboxed(context, objx, gen))
            (ß HostExpr.emitBoxReturn(objx, gen, Boolean.TYPE))
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß Boolean.TYPE)
        )
    )

    (class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Type target)
        (§ field Class retClass)
        (§ field Class[] paramclasses)
        (§ field Type[] paramtypes)
        (§ field IPersistentVector args)
        (§ field boolean variadic)
        (§ field boolean tailPosition)
        (§ field Object tag)

        (§ field Class jc)

        (§ constructor StaticInvokeExpr(Type target, Class retClass, Class[] paramclasses, Type[] paramtypes, boolean variadic, IPersistentVector args, Object tag, boolean tailPosition)
            (ß this.target = target)
            (ß this.retClass = retClass)
            (ß this.paramclasses = paramclasses)
            (ß this.paramtypes = paramtypes)
            (ß this.args = args)
            (ß this.variadic = variadic)
            (ß this.tailPosition = tailPosition)
            (ß this.tag = tag)
            this
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval StaticInvokeExpr")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß emitUnboxed(context, objx, gen))
            (when (ß context != C.STATEMENT)
                (ß HostExpr.emitBoxReturn(objx, gen, retClass))
            )
            (when (ß context == C.STATEMENT)
                (if (ß retClass == long.class || retClass == double.class)
                    (do
                        (ß gen.pop2())
                    )
                    (do
                        (ß gen.pop())
                    )
                )
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, retClass))
            )
            jc
        )

        (§ method boolean canEmitPrimitive()
            (ß retClass.isPrimitive())
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (let [#_"Method" ms (ß new Method("invokeStatic", getReturnType(), paramtypes))]
                (if variadic
                    (do
                        (loop-when-recur [(ß int i = 0)] (ß i < paramclasses.length - 1) [(ß i++)]
                            (let [#_"Expr" e (ß (Expr) args.nth(i))]
                                (if (ß maybePrimitiveType(e) == paramclasses[i])
                                    (do
                                        (ß ((MaybePrimitiveExpr) e).emitUnboxed(C.EXPRESSION, objx, gen))
                                    )
                                    (do
                                        (ß e.emit(C.EXPRESSION, objx, gen))
                                        (ß HostExpr.emitUnboxArg(objx, gen, paramclasses[i]))
                                    )
                                )
                            )
                        )
                        (let [#_"IPersistentVector" restArgs (ß RT.subvec(args, paramclasses.length - 1, args.count()))]
                            (ß MethodExpr.emitArgsAsArray(restArgs, objx, gen))
                            (ß gen.invokeStatic(Type.getType(ArraySeq.class), Method.getMethod("cloiure.lang.ArraySeq create(Object[])")))
                        )
                    )
                    (do
                        (ß MethodExpr.emitTypedArgs(objx, gen, paramclasses, args))
                    )
                )

                (when (ß tailPosition && !objx.canBeDirect)
                    (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                        (ß method.emitClearThis(gen))
                    )
                )

                (ß gen.invokeStatic(target, ms))
                nil
            )
        )

        (§ method- Type getReturnType()
            (ß Type.getType(retClass))
        )

        (§ defn Expr parse(Var v, ISeq args, Object tag, boolean tailPosition)
            (when (ß !v.isBound() || v.get() == nil)
                (§ return nil)
            )
            (let [#_"Class" c (ß v.get().getClass())]
                (let [#_"String" cname (ß c.getName())]
                    (let [(ß java.lang.reflect.Method[] allmethods = c.getMethods())]
                        (let [#_"boolean" variadic false]
                            (let [#_"int" argcount (ß RT.count(args))]
                                (let [(ß java.lang.reflect.Method method = nil)]
                                    (doseq [#_"java.lang.reflect.Method" m allmethods]
                                        (when (ß Modifier.isStatic(m.getModifiers()) && m.getName().equals("invokeStatic"))
                                            (let [#_"Class[]" params (ß m.getParameterTypes())]
                                                (cond (ß argcount == params.length)
                                                    (do
                                                        (ß method = m)
                                                        (ß variadic = (argcount > 0 && params[params.length - 1] == ISeq.class))
                                                        (§ break )
                                                    )
                                                    (ß argcount > params.length && params.length > 0 && params[params.length - 1] == ISeq.class)
                                                    (do
                                                        (ß method = m)
                                                        (ß variadic = true)
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (when (ß method == nil)
                                        (§ return nil)
                                    )

                                    (let [#_"Class" retClass (ß method.getReturnType())]
                                        (let [#_"Class[]" paramClasses (ß method.getParameterTypes())]
                                            (let [#_"Type[]" paramTypes (ß new Type[paramClasses.length])]
                                                (loop-when-recur [(ß int i = 0)] (ß i < paramClasses.length) [(ß i++)]
                                                    (ß paramTypes[i] = Type.getType(paramClasses[i]))
                                                )

                                                (let [#_"Type" target (ß Type.getType(c))]
                                                    (let [#_"PersistentVector" argv (ß PersistentVector.EMPTY)]
                                                        (loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                                                            (ß argv = argv.cons(analyze(C.EXPRESSION, s.first())))
                                                        )

                                                        (ß new StaticInvokeExpr(target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns InvokeExpr (§ implements Expr)
        (§ field Expr fexpr)
        (§ field Object tag)
        (§ field IPersistentVector args)
        (§ field int line)
        (§ field int column)
        (§ field boolean tailPosition)
        (§ field String source)

        (§ field boolean isProtocol = false)
        (§ field boolean isDirect = false)
        (§ field int siteIndex = -1)
        (§ field Class protocolOn)
        (§ field java.lang.reflect.Method onMethod)

        (§ def Keyword onKey = Keyword.intern("on"))
        (§ def Keyword methodMapKey = Keyword.intern("method-map"))

        (§ field Class jc)

        (§ defn Object sigTag(int argcount, Var v)
            (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                (let [#_"Object" sigTag nil]
                    (loop-when-recur [(ß ISeq s = RT.seq(arglists))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"APersistentVector" sig (ß (APersistentVector) s.first())]
                            (let [#_"int" restOffset (ß sig.indexOf(_AMP_))]
                                (when (ß argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))
                                    (§ return (ß tagOf(sig)))
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )

        (§ constructor InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition)
            (ß this.source = source)
            (ß this.fexpr = fexpr)
            (ß this.args = args)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.tailPosition = tailPosition)

            (when (ß fexpr instanceof VarExpr)
                (let [#_"Var" fvar (ß ((VarExpr)fexpr).var)]
                    (let [#_"Var" pvar (ß  (Var)RT.get(fvar.meta(), protocolKey))]
                        (when (ß pvar != nil && PROTOCOL_CALLSITES.isBound())
                            (ß this.isProtocol = true)
                            (ß this.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var))
                            (let [#_"Object" pon (ß RT.get(pvar.get(), onKey))]
                                (ß this.protocolOn = HostExpr.maybeClass(pon, false))
                                (when (ß this.protocolOn != nil)
                                    (let [#_"IPersistentMap" mmap (ß (IPersistentMap) RT.get(pvar.get(), methodMapKey))]
                                        (let [#_"Keyword" mmapVal (ß (Keyword) mmap.valAt(Keyword.intern(fvar.sym)))]
                                            (when (ß mmapVal == nil)
                                                (throw (ß new IllegalArgumentException("No method of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym + " (The protocol method may have been defined before and removed.)")))
                                            )
                                            (let [#_"String" mname (ß munge(mmapVal.sym.toString()))]
                                                (let [#_"List" methods (ß Reflector.getMethods(protocolOn, args.count() - 1, mname, false))]
                                                    (when (ß methods.size() != 1)
                                                        (throw (ß new IllegalArgumentException("No single method: " + mname + " of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym)))
                                                    )
                                                    (ß this.onMethod = (java.lang.reflect.Method) methods.get(0))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (cond (ß tag != nil)
                (do
                    (ß this.tag = tag)
                )
                (ß fexpr instanceof VarExpr)
                (do
                    (let [#_"Var" v (ß ((VarExpr) fexpr).var)]
                        (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                            (let [#_"Object" sigTag (ß sigTag(args.count(), v))]
                                (ß this.tag = (sigTag == nil) ? ((VarExpr) fexpr).tag :or sigTag)
                            )
                        )
                    )
                )
                :else
                (do
                    (ß this.tag = nil)
                )
            )
            this
        )

        (§ method Object eval()
            (try
                (let [#_"IFn" fn (ß (IFn) fexpr.eval())]
                    (let [#_"PersistentVector" argvs (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                            (ß argvs = argvs.cons(((Expr) args.nth(i)).eval()))
                        )
                        (ß fn.applyTo(RT.seq(Util.ret1(argvs, argvs = nil))))
                    )
                )
                (catch Throwable e
                    (if (ß !(e instanceof CompilerException))
                        (do
                            (throw (ß new CompilerException(source, line, column, e)))
                        )
                        (do
                            (throw (ß (CompilerException) e))
                        )
                    )
                )
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (if isProtocol
                (do
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß emitProto(context, objx, gen))
                )
                (do
                    (ß fexpr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.visitLineNumber(line, gen.mark()))
                    (ß gen.checkCast(IFN_TYPE))
                    (ß emitArgsAndCall(0, context, objx, gen))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method void emitProto(C context, ObjExpr objx, GeneratorAdapter gen)
            (let [#_"Label" onLabel (ß gen.newLabel())]
                (let [#_"Label" callLabel (ß gen.newLabel())]
                    (let [#_"Label" endLabel (ß gen.newLabel())]
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (let [#_"Expr" e (ß (Expr) args.nth(0))]
                                (ß e.emit(C.EXPRESSION, objx, gen))
                                (ß gen.dup()) ;; target, target
                                (ß gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
                                (ß gen.getStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target, class, cached-class
                                (ß gen.visitJumpInsn(IF_ACMPEQ, callLabel)) ;; target
                                (when (ß protocolOn != nil)
                                    (ß gen.dup()) ;; target, target
                                    (ß gen.instanceOf(Type.getType(protocolOn)))
                                    (ß gen.ifZCmp(GeneratorAdapter.NE, onLabel))
                                )

                                (ß gen.dup()) ;; target, target
                                (ß gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)"))) ;; target, class
                                (ß gen.putStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target

                                (ß gen.mark(callLabel)) ;; target
                                (ß objx.emitVar(gen, v))
                                (ß gen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()"))) ;; target, proto-fn
                                (ß gen.swap())
                                (ß emitArgsAndCall(1, context, objx, gen))
                                (ß gen.goTo(endLabel))

                                (ß gen.mark(onLabel)) ;; target
                                (when (ß protocolOn != nil)
                                    (ß gen.checkCast(Type.getType(protocolOn)))
                                    (ß MethodExpr.emitTypedArgs(objx, gen, onMethod.getParameterTypes(), RT.subvec(args, 1, args.count())))
                                    (when (ß context == C.RETURN)
                                        (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                            (ß method.emitClearLocals(gen))
                                        )
                                    )
                                    (let [#_"Method" m (ß new Method(onMethod.getName(), Type.getReturnType(onMethod), Type.getArgumentTypes(onMethod)))]
                                        (ß gen.invokeInterface(Type.getType(protocolOn), m))
                                        (ß HostExpr.emitBoxReturn(objx, gen, onMethod.getReturnType()))
                                    )
                                )
                                (ß gen.mark(endLabel))
                                nil
                            )
                        )
                    )
                )
            )
        )

        (§ method void emitArgsAndCall(int firstArgToEmit, C context, ObjExpr objx, GeneratorAdapter gen)
            (loop-when-recur [(ß int i = firstArgToEmit)] (ß i < Math.min(MAX_POSITIONAL_ARITY, args.count())) [(ß i++)]
                (let [#_"Expr" e (ß (Expr) args.nth(i))]
                    (ß e.emit(C.EXPRESSION, objx, gen))
                )
            )
            (when (ß args.count() > MAX_POSITIONAL_ARITY)
                (let [#_"PersistentVector" restArgs (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(ß int i = MAX_POSITIONAL_ARITY)] (ß i < args.count()) [(ß i++)]
                        (ß restArgs = restArgs.cons(args.nth(i)))
                    )
                    (ß MethodExpr.emitArgsAsArray(restArgs, objx, gen))
                )
            )
            (ß gen.visitLineNumber(line, gen.mark()))

            (when (ß tailPosition && !objx.canBeDirect)
                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                    (ß method.emitClearThis(gen))
                )
            )

            (ß gen.invokeInterface(IFN_TYPE, new Method("invoke", OBJECT_TYPE, ARG_TYPES[Math.min(MAX_POSITIONAL_ARITY + 1, args.count())])))
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (tag != nil))
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = HostExpr.tagToClass(tag))
            )
            jc
        )

        (§ defn Expr parse(C context, ISeq form)
            (let [#_"boolean" tailPosition (ß inTailCall(context))]
                (when (ß context != C.EVAL)
                    (ß context = C.EXPRESSION)
                )
                (let [#_"Expr" fexpr (ß analyze(context, form.first()))]
                    (when (ß fexpr instanceof VarExpr && ((VarExpr)fexpr).var.equals(INSTANCE) && RT.count(form) == 3)
                        (let [#_"Expr" sexpr (ß analyze(C.EXPRESSION, RT.second(form)))]
                            (when (ß sexpr instanceof ConstantExpr)
                                (let [#_"Object" val (ß ((ConstantExpr) sexpr).val())]
                                    (when (ß val instanceof Class)
                                        (§ return (ß new InstanceOfExpr((Class) val, analyze(context, RT.third(form)))))
                                    )
                                )
                            )
                        )
                    )

                    (when (ß RT.booleanCast(getCompilerOption(directLinkingKey)) && fexpr instanceof VarExpr && context != C.EVAL)
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (when (ß !v.isDynamic() && !RT.booleanCast(RT.get(v.meta(), redefKey, false)))
                                (let [#_"Symbol" formtag (ß tagOf(form))]
                                    (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                                        (let [#_"int" arity (ß RT.count(form.next()))]
                                            (let [#_"Object" sigtag (ß sigTag(arity, v))]
                                                (let [#_"Object" vtag (ß RT.get(RT.meta(v), RT.TAG_KEY))]
                                                    (let [#_"Expr" ret (ß StaticInvokeExpr.parse(v, RT.next(form), (formtag != nil) ? formtag :or (sigtag != nil) ? sigtag :or vtag, tailPosition))]
                                                        (when (ß ret != nil)
                                                            (§ return ret)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (ß fexpr instanceof VarExpr && context != C.EVAL)
                        (let [#_"Var" v (ß ((VarExpr)fexpr).var)]
                            (let [#_"Object" arglists (ß RT.get(RT.meta(v), arglistsKey))]
                                (let [#_"int" arity (ß RT.count(form.next()))]
                                    (loop-when-recur [(ß ISeq s = RT.seq(arglists))] (ß s != nil) [(ß s = s.next())]
                                        (let [#_"IPersistentVector" args (ß (IPersistentVector) s.first())]
                                            (when (ß args.count() == arity)
                                                (let [#_"String" primc (ß FnMethod.primInterface(args))]
                                                    (when (ß primc != nil)
                                                        (§ return (ß analyze(context, ((IObj)RT.listStar(Symbol.intern(".invokePrim"), ((Symbol) form.first()).withMeta(RT.map(RT.TAG_KEY, Symbol.intern(primc))), form.next())).withMeta((IPersistentMap)RT.conj(RT.meta(v), RT.meta(form))))))
                                                    )
                                                    (§ break )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (ß fexpr instanceof KeywordExpr && RT.count(form) == 2 && KEYWORD_CALLSITES.isBound())
                        (let [#_"Expr" target (ß analyze(context, RT.second(form)))]
                            (§ return (ß new KeywordInvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), (KeywordExpr) fexpr, target)))
                        )
                    )
                    (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(ß ISeq s = RT.seq(form.next()))] (ß s != nil) [(ß s = s.next())]
                            (ß args = args.cons(analyze(context, s.first())))
                        )

                        (ß new InvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), fexpr, args, tailPosition))
                    )
                )
            )
        )
    )

    (class-ns SourceDebugExtensionAttribute (§ extends Attribute)
        (§ constructor SourceDebugExtensionAttribute()
            (§ super("SourceDebugExtension"))
            this
        )

        (§ method void writeSMAP(ClassWriter cw, String smap)
            (let [#_"ByteVector" bv (ß write(cw, nil, -1, -1, -1))]
                (ß bv.putUTF8(smap))
                nil
            )
        )
    )

    (class-ns FnExpr (§ extends ObjExpr)
        (§ def Type aFnType = Type.getType(AFunction.class))
        (§ def Type restFnType = Type.getType(RestFn.class))

        ;; if there is a variadic overload (there can only be one) it is stored here
        (§ field FnMethod variadicMethod = nil)
        (§ field IPersistentCollection methods)
        (§ field- boolean hasPrimSigs)
        (§ field- boolean hasMeta)
        (§ field- boolean hasEnclosingMethod)

        (§ field Class jc)

        (§ constructor FnExpr(Object tag)
            (§ super(tag))
            this
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method boolean supportsMeta()
            hasMeta
        )

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or AFunction.class)
            )
            jc
        )

        #_protected
        (§ method void emitMethods(ClassVisitor cv)
            ;; override of invoke/doInvoke for each method
            (loop-when-recur [(ß ISeq s = RT.seq(methods))] (ß s != nil) [(ß s = s.next())]
                (let [#_"ObjMethod" method (ß (ObjMethod) s.first())]
                    (ß method.emit(this, cv))
                )
            )

            (when (ß isVariadic())
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, Method.getMethod("int getRequiredArity()"), nil, nil, cv))]
                    (ß gen.visitCode())
                    (ß gen.push(variadicMethod.reqParms.count()))
                    (ß gen.returnValue())
                    (ß gen.endMethod())
                )
            )
            nil
        )

        (§ defn Expr parse(C context, ISeq form, String name)
            (let [#_"ISeq" origForm form]
                (let [#_"FnExpr" fn (ß new FnExpr(tagOf(form)))]
                    (let [#_"Keyword" retkey (ß Keyword.intern(nil, "rettag"))]
                        (let [#_"Object" rettag (ß RT.get(RT.meta(form), retkey))]
                            (ß fn.src = form)
                            (let [#_"ObjMethod" enclosingMethod (ß (ObjMethod) METHOD.deref())]
                                (ß fn.hasEnclosingMethod = enclosingMethod != nil)
                                (when (ß ((IMeta) form.first()).meta() != nil)
                                    (ß fn.onceOnly = RT.booleanCast(RT.get(RT.meta(form.first()), Keyword.intern(nil, "once"))))
                                )

                                (let [#_"String" basename (ß ((enclosingMethod != nil) ? enclosingMethod.objx.name :or munge(currentNS().name.name)) + "$")]
                                    (let [#_"Symbol" nm nil]
                                        (if (ß RT.second(form) instanceof Symbol)
                                            (do
                                                (ß nm = (Symbol) RT.second(form))
                                                (ß name = nm.name + "__" + RT.nextID())
                                            )
                                            (do
                                                (cond (ß name == nil)
                                                    (do
                                                        (ß name = "fn__" + RT.nextID())
                                                    )
                                                    (ß enclosingMethod != nil)
                                                    (do
                                                        (ß name += "__" + RT.nextID())
                                                    )
                                                )
                                            )
                                        )

                                        (let [#_"String" simpleName (ß munge(name).replace(".", "_DOT_"))]
                                            (ß fn.name = basename + simpleName)
                                            (ß fn.internalName = fn.name.replace(\., \/))
                                            (ß fn.objtype = Type.getObjectType(fn.internalName))
                                            (let [#_"ArrayList<String>" prims (ß new ArrayList())]
                                                (try
                                                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                        #_map CONSTANTS, PersistentVector.EMPTY,
                                                        #_map CONSTANT_IDS, new IdentityHashMap(),
                                                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                                                        #_map VARS, PersistentHashMap.EMPTY,
                                                        #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                                                        #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                                                        #_map VAR_CALLSITES, emptyVarCallSites(),
                                                        #_map NO_RECUR, nil
                                                    )))

                                                    ;; arglist might be preceded by symbol naming this fn
                                                    (when (ß nm != nil)
                                                        (ß fn.thisName = nm.name)
                                                        (ß form = RT.cons(FN, RT.next(RT.next(form))))
                                                    )

                                                    ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                                                    ;; turn former into latter
                                                    (when (ß RT.second(form) instanceof IPersistentVector)
                                                        (ß form = RT.list(FN, RT.next(form)))
                                                    )
                                                    (ß fn.line = lineDeref())
                                                    (ß fn.column = columnDeref())
                                                    (let [#_"FnMethod[]" methodArray (ß new FnMethod[MAX_POSITIONAL_ARITY + 1])]
                                                        (let [#_"FnMethod" variadicMethod nil]
                                                            (let [#_"boolean" usesThis false]
                                                                (loop-when-recur [(ß ISeq s = RT.next(form))] (ß s != nil) [(ß s = RT.next(s))]
                                                                    (let [#_"FnMethod" f (ß FnMethod.parse(fn, (ISeq) RT.first(s), rettag))]
                                                                        (when (ß f.usesThis)
                                                                            (ß usesThis = true)
                                                                        )
                                                                        (cond (ß f.isVariadic())
                                                                            (do
                                                                                (if (ß variadicMethod == nil)
                                                                                    (do
                                                                                        (ß variadicMethod = f)
                                                                                    )
                                                                                    (do
                                                                                        (throw (ß Util.runtimeException("Can't have more than 1 variadic overload")))
                                                                                    )
                                                                                )
                                                                            )
                                                                            (ß methodArray[f.reqParms.count()] == nil)
                                                                            (do
                                                                                (ß methodArray[f.reqParms.count()] = f)
                                                                            )
                                                                            :else
                                                                            (do
                                                                                (throw (ß Util.runtimeException("Can't have 2 overloads with same arity")))
                                                                            )
                                                                        )
                                                                        (when (ß f.prim != nil)
                                                                            (ß prims.add(f.prim))
                                                                        )
                                                                    )
                                                                )
                                                                (when (ß variadicMethod != nil)
                                                                    (loop-when-recur [(ß int i = variadicMethod.reqParms.count() + 1)] (ß i <= MAX_POSITIONAL_ARITY) [(ß i++)]
                                                                        (when (ß methodArray[i] != nil)
                                                                            (throw (ß Util.runtimeException("Can't have fixed arity function with more params than variadic function")))
                                                                        )
                                                                    )
                                                                )

                                                                (ß fn.canBeDirect = (!fn.hasEnclosingMethod && fn.closes.count() == 0 && !usesThis))

                                                                (let [#_"IPersistentCollection" methods nil]
                                                                    (loop-when-recur [(ß int i = 0)] (ß i < methodArray.length) [(ß i++)]
                                                                        (when (ß methodArray[i] != nil)
                                                                            (ß methods = RT.conj(methods, methodArray[i]))
                                                                        )
                                                                    )
                                                                    (when (ß variadicMethod != nil)
                                                                        (ß methods = RT.conj(methods, variadicMethod))
                                                                    )

                                                                    (when (ß fn.canBeDirect)
                                                                        (doseq [#_"FnMethod" fm (ß (Collection<FnMethod>)methods)]
                                                                            (when (ß fm.locals != nil)
                                                                                (doseq [#_"LocalBinding" lb (ß (Collection<LocalBinding>)RT.keys(fm.locals))]
                                                                                    (when (ß lb.isArg)
                                                                                        (ß lb.idx -= 1)
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )

                                                                    (ß fn.methods = methods)
                                                                    (ß fn.variadicMethod = variadicMethod)
                                                                    (ß fn.keywords = (IPersistentMap) KEYWORDS.deref())
                                                                    (ß fn.vars = (IPersistentMap) VARS.deref())
                                                                    (ß fn.constants = (PersistentVector) CONSTANTS.deref())
                                                                    (ß fn.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())
                                                                    (ß fn.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())
                                                                    (ß fn.varCallsites = (IPersistentSet) VAR_CALLSITES.deref())

                                                                    (ß fn.constantsID = RT.nextID())
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (finally
                                                        (ß Var.popThreadBindings())
                                                    )
                                                )
                                                (ß fn.hasPrimSigs = prims.size() > 0)
                                                (let [#_"IPersistentMap" fmeta (ß RT.meta(origForm))]
                                                    (when (ß fmeta != nil)
                                                        (ß fmeta = fmeta.without(RT.LINE_KEY).without(RT.COLUMN_KEY).without(RT.FILE_KEY).without(retkey))
                                                    )

                                                    (ß fn.hasMeta = RT.count(fmeta) > 0)

                                                    (try
                                                        (ß fn.compile(fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (prims.size() == 0) ? nil :or prims.toArray(new String[prims.size()]), fn.onceOnly))
                                                        (catch IOException e
                                                            (throw (ß Util.sneakyThrow(e)))
                                                        )
                                                    )
                                                    (ß fn.getCompiledClass())

                                                    (if (ß fn.supportsMeta())
                                                        (do
                                                            (ß new MetaExpr(fn, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, fmeta)))
                                                        )
                                                        (do
                                                            fn
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method ObjMethod variadicMethod()
            variadicMethod
        )

        (§ method boolean isVariadic()
            (ß (variadicMethod != nil))
        )

        (§ method IPersistentCollection methods()
            methods
        )

        (§ method void emitForDefn(ObjExpr objx, GeneratorAdapter gen)
            (ß emit(C.EXPRESSION, objx, gen))
            nil
        )
    )

    (class-ns ObjExpr (§ implements Expr)
        (§ def String CONST_PREFIX = "const__")

        (§ field String name)
        (§ field String internalName)
        (§ field String thisName)
        (§ field Type objtype)
        (§ field Object tag)
        ;; localbinding->itself
        (§ field IPersistentMap closes = PersistentHashMap.EMPTY)
        ;; localbndingexprs
        (§ field IPersistentVector closesExprs = PersistentVector.EMPTY)
        ;; symbols
        (§ field IPersistentSet volatiles = PersistentHashSet.EMPTY)

        ;; symbol->lb
        (§ field IPersistentMap fields = nil)

        ;; hinted fields
        (§ field IPersistentVector hintedFields = PersistentVector.EMPTY)

        ;; Keyword->KeywordExpr
        (§ field IPersistentMap keywords = PersistentHashMap.EMPTY)
        (§ field IPersistentMap vars = PersistentHashMap.EMPTY)
        (§ field Class compiledClass)
        (§ field int line)
        (§ field int column)
        (§ field PersistentVector constants)
        (§ field IPersistentSet usedConstants = PersistentHashSet.EMPTY)

        (§ field int constantsID)
        (§ field int altCtorDrops = 0)

        (§ field IPersistentVector keywordCallsites)
        (§ field IPersistentVector protocolCallsites)
        (§ field IPersistentSet varCallsites)
        (§ field boolean onceOnly = false)

        (§ field Object src)

        (§ field IPersistentMap opts = PersistentHashMap.EMPTY)

        (§ def Method voidctor = Method.getMethod("void <init>()"))
        #_protected
        (§ field IPersistentMap classMeta)
        #_protected
        (§ field boolean canBeDirect)

        (§ method String name()
            name
        )

        (§ method String internalName()
            internalName
        )

        (§ method String thisName()
            thisName
        )

        (§ method Type objtype()
            objtype
        )

        (§ method IPersistentMap closes()
            closes
        )

        (§ method IPersistentMap keywords()
            keywords
        )

        (§ method IPersistentMap vars()
            vars
        )

        (§ method Class compiledClass()
            compiledClass
        )

        (§ method int line()
            line
        )

        (§ method int column()
            column
        )

        (§ method PersistentVector constants()
            constants
        )

        (§ method int constantsID()
            constantsID
        )

        (§ def Method kwintern = Method.getMethod("cloiure.lang.Keyword intern(String, String)"))
        (§ def Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String)"))
        (§ def Method varintern = Method.getMethod("cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)"))

        (§ def Type DYNAMIC_CLASSLOADER_TYPE = Type.getType(DynamicClassLoader.class))
        (§ def Method getClassMethod = Method.getMethod("Class getClass()"))
        (§ def Method getClassLoaderMethod = Method.getMethod("ClassLoader getClassLoader()"))
        (§ def Method getConstantsMethod = Method.getMethod("Object[] getConstants(int)"))
        (§ def Method readStringMethod = Method.getMethod("Object readString(String)"))

        (§ def Type ILOOKUP_SITE_TYPE = Type.getType(ILookupSite.class))
        (§ def Type ILOOKUP_THUNK_TYPE = Type.getType(ILookupThunk.class))
        (§ def Type KEYWORD_LOOKUPSITE_TYPE = Type.getType(KeywordLookupSite.class))

        (§ field- DynamicClassLoader loader)
        (§ field- byte[] bytecode)

        (§ constructor ObjExpr(Object tag)
            (ß this.tag = tag)
            this
        )

        (§ defn String trimGenID(String name)
            (let [#_"int" i (ß name.lastIndexOf("__"))]
                (ß (i == -1) ? name :or name.substring(0, i))
            )
        )

        (§ method Type[] ctorTypes()
            (let [#_"IPersistentVector" tv (ß !supportsMeta() ? PersistentVector.EMPTY :or RT.vector(IPERSISTENTMAP_TYPE))]
                (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                        (if (ß lb.getPrimitiveType() != nil)
                            (do
                                (ß tv = tv.cons(Type.getType(lb.getPrimitiveType())))
                            )
                            (do
                                (ß tv = tv.cons(OBJECT_TYPE))
                            )
                        )
                    )
                )
                (let [#_"Type[]" ret (ß new Type[tv.count()])]
                    (loop-when-recur [(ß int i = 0)] (ß i < tv.count()) [(ß i++)]
                        (ß ret[i] = (Type) tv.nth(i))
                    )
                    ret
                )
            )
        )

        (§ method void compile(String superName, String[] interfaceNames, boolean oneTimeUse) (§ throws IOException)
            ;; create bytecode for a class
            ;; with name current_ns.defname[$letname]+
            ;; anonymous fns get names fn__id
            ;; derived from AFn/RestFn
            (let [#_"ClassWriter" cw (ß new ClassWriter(ClassWriter.COMPUTE_MAXS))]
                (let [#_"ClassVisitor" cv cw]
                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, internalName, nil, superName, interfaceNames))
                    (let [#_"String" source (ß (String) SOURCE.deref())]
                        (let [#_"int" lineBefore (ß (Integer) LINE_BEFORE.deref())]
                            (let [#_"int" lineAfter (ß (Integer) LINE_AFTER.deref() + 1)]
                                (let [#_"int" columnBefore (ß (Integer) COLUMN_BEFORE.deref())]
                                    (let [#_"int" columnAfter (ß (Integer) COLUMN_AFTER.deref() + 1)]
                                        (when (ß source != nil && SOURCE_PATH.deref() != nil)
                                            (let [#_"String" smap
                                                    (str "SMAP\n"
                                                        (ß (source.lastIndexOf(\.) > 0) ? source.substring(0, source.lastIndexOf(\.)) :or source) ;; :or simpleName
                                                        ".java\n"
                                                        "Cloiure\n"
                                                        "*S Cloiure\n"
                                                        "*F\n"
                                                        "+ 1 " source "\n"
                                                        (ß (String) SOURCE_PATH.deref()) "\n"
                                                        "*L\n"
                                                        (ß String.format("%d#1,%d:%d\n", lineBefore, lineAfter - lineBefore, lineBefore))
                                                        "*E"
                                                    )]
                                                (ß cv.visitSource(source, smap))
                                            )
                                        )
                                        (ß addAnnotation(cv, classMeta))

                                        (when (ß supportsMeta())
                                            (ß cv.visitField(ACC_FINAL, "__meta", IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
                                        )
                                        ;; instance fields for closed-overs
                                        (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                                            (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                (if (ß isDeftype())
                                                    (do
                                                        (let [#_"int" access (ß isVolatile(lb) ? ACC_VOLATILE :or isMutable(lb) ? 0 :or (ACC_PUBLIC + ACC_FINAL))]
                                                            (§ let [#_"FieldVisitor" fv]
                                                                (if (ß lb.getPrimitiveType() != nil)
                                                                    (do
                                                                        (ß fv = cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                                                    )
                                                                    (do
                                                                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                                                        (ß fv = cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                                                    )
                                                                )
                                                                (ß addAnnotation(fv, RT.meta(lb.sym)))
                                                            )
                                                        )
                                                    )
                                                    (do
                                                        ;; todo - only enable this non-private+writability for letfns where we need it
                                                        (if (ß lb.getPrimitiveType() != nil)
                                                            (do
                                                                (ß cv.visitField(0 + (isVolatile(lb) ? ACC_VOLATILE :or 0), lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                                            )
                                                            (do
                                                                (ß cv.visitField(0, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        ;; static fields for callsites and thunks
                                        (loop-when-recur [(ß int i = 0)] (ß i < protocolCallsites.count()) [(ß i++)]
                                            (ß cv.visitField(ACC_PRIVATE + ACC_STATIC, cachedClassName(i), CLASS_TYPE.getDescriptor(), nil, nil))
                                        )

                                        ;; ctor that takes closed-overs and inits base + fields
                                        (let [#_"Method" m (ß new Method("<init>", Type.VOID_TYPE, ctorTypes()))]
                                            (let [#_"GeneratorAdapter" ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))]
                                                (let [#_"Label" start (ß ctorgen.newLabel())]
                                                    (let [#_"Label" end (ß ctorgen.newLabel())]
                                                        (ß ctorgen.visitCode())
                                                        (ß ctorgen.visitLineNumber(line, ctorgen.mark()))
                                                        (ß ctorgen.visitLabel(start))
                                                        (ß ctorgen.loadThis())
                                                        (ß ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))

                                                        (when (ß supportsMeta())
                                                            (ß ctorgen.loadThis())
                                                            (ß ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE.getOpcode(Opcodes.ILOAD), 1))
                                                            (ß ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TYPE))
                                                        )

                                                        (let [#_"int" a (ß supportsMeta() ? 2 :or 1)]
                                                            (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next(), ++a)]
                                                                (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                                    (ß ctorgen.loadThis())
                                                                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                                        (if (ß primc != nil)
                                                                            (do
                                                                                (ß ctorgen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), a))
                                                                                (ß ctorgen.putField(objtype, lb.name, Type.getType(primc)))
                                                                                (when (ß primc == Long.TYPE || primc == Double.TYPE)
                                                                                    (ß ++a)
                                                                                )
                                                                            )
                                                                            (do
                                                                                (ß ctorgen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), a))
                                                                                (ß ctorgen.putField(objtype, lb.name, OBJECT_TYPE))
                                                                            )
                                                                        )
                                                                        (ß closesExprs = closesExprs.cons(new LocalBindingExpr(lb, nil)))
                                                                    )
                                                                )
                                                            )

                                                            (ß ctorgen.visitLabel(end))

                                                            (ß ctorgen.returnValue())

                                                            (ß ctorgen.endMethod())

                                                            (when (ß altCtorDrops > 0)
                                                                ;; ctor that takes closed-overs and inits base + fields
                                                                (let [#_"Type[]" ctorTypes (ß ctorTypes())]
                                                                    (let [#_"Type[]" altCtorTypes (ß new Type[ctorTypes.length-altCtorDrops])]
                                                                        (loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                                                                            (ß altCtorTypes[i] = ctorTypes[i])
                                                                        )
                                                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, altCtorTypes))]
                                                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.loadArgs())

                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())

                                                                            ;; alt ctor no __hash, __hasheq
                                                                            (ß altCtorTypes = new Type[ctorTypes.length-2])
                                                                            (loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                                                                                (ß altCtorTypes[i] = ctorTypes[i])
                                                                            )

                                                                            (ß alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                                                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.loadArgs())

                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())
                                                                        )
                                                                    )
                                                                )
                                                            )

                                                            (when (ß supportsMeta())
                                                                ;; ctor that takes closed-overs but not meta
                                                                (let [#_"Type[]" ctorTypes (ß ctorTypes())]
                                                                    (let [#_"Type[]" noMetaCtorTypes (ß new Type[ctorTypes.length-1])]
                                                                        (loop-when-recur [(ß int i = 1)] (ß i < ctorTypes.length) [(ß i++)]
                                                                            (ß noMetaCtorTypes[i - 1] = ctorTypes[i])
                                                                        )
                                                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, noMetaCtorTypes))]
                                                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                                                            (ß ctorgen.visitCode())
                                                                            (ß ctorgen.loadThis())
                                                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; nil meta
                                                                            (ß ctorgen.loadArgs())
                                                                            (ß ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                                                            (ß ctorgen.returnValue())
                                                                            (ß ctorgen.endMethod())

                                                                            ;; meta()
                                                                            (let [#_"Method" meth (ß Method.getMethod("cloiure.lang.IPersistentMap meta()"))]
                                                                                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))]
                                                                                    (ß gen.visitCode())
                                                                                    (ß gen.loadThis())
                                                                                    (ß gen.getField(objtype, "__meta", IPERSISTENTMAP_TYPE))

                                                                                    (ß gen.returnValue())
                                                                                    (ß gen.endMethod())

                                                                                    ;; withMeta()
                                                                                    (ß meth = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

                                                                                    (ß gen = new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv))
                                                                                    (ß gen.visitCode())
                                                                                    (ß gen.newInstance(objtype))
                                                                                    (ß gen.dup())
                                                                                    (ß gen.loadArg(0))

                                                                                    (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next(), ++a)]
                                                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                                                                                            (ß gen.loadThis())
                                                                                            (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                                                                (if (ß primc != nil)
                                                                                                    (do
                                                                                                        (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                                                                                                    )
                                                                                                    (do
                                                                                                        (ß gen.getField(objtype, lb.name, OBJECT_TYPE))
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )

                                                                                    (ß gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes)))
                                                                                    (ß gen.returnValue())
                                                                                    (ß gen.endMethod())
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )

                                                            (ß emitStatics(cv))
                                                            (ß emitMethods(cv))

                                                            ;; static fields for constants
                                                            (loop-when-recur [(ß int i = 0)] (ß i < constants.count()) [(ß i++)]
                                                                (when (ß usedConstants.contains(i))
                                                                    (ß cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, constantName(i), constantType(i).getDescriptor(), nil, nil))
                                                                )
                                                            )

                                                            ;; static fields for lookup sites
                                                            (loop-when-recur [(ß int i = 0)] (ß i < keywordCallsites.count()) [(ß i++)]
                                                                (ß cv.visitField(ACC_FINAL + ACC_STATIC, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                                                                (ß cv.visitField(ACC_STATIC, thunkNameStatic(i), ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
                                                            )

                                                            ;; static init for constants, keywords and vars
                                                            (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))]
                                                                (ß clinitgen.visitCode())
                                                                (ß clinitgen.visitLineNumber(line, clinitgen.mark()))

                                                                (when (ß constants.count() > 0)
                                                                    (ß emitConstants(clinitgen))
                                                                )

                                                                (when (ß keywordCallsites.count() > 0)
                                                                    (ß emitKeywordCallsites(clinitgen))
                                                                )

                                                                (when (ß isDeftype() && RT.booleanCast(RT.get(opts, loadNs)))
                                                                    (let [#_"String" nsname (ß ((Symbol)RT.second(src)).getNamespace())]
                                                                        (when (ß !nsname.equals("cloiure.core"))
                                                                            (ß clinitgen.push("cloiure.core"))
                                                                            (ß clinitgen.push("require"))
                                                                            (ß clinitgen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
                                                                            (ß clinitgen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()")))
                                                                            (ß clinitgen.checkCast(IFN_TYPE))
                                                                            (ß clinitgen.push(nsname))
                                                                            (ß clinitgen.invokeStatic(SYMBOL_TYPE, Method.getMethod("cloiure.lang.Symbol create(String)")))
                                                                            (ß clinitgen.invokeInterface(IFN_TYPE, Method.getMethod("Object invoke(Object)")))
                                                                            (ß clinitgen.pop())
                                                                        )
                                                                    )
                                                                )

                                                                (ß clinitgen.returnValue())

                                                                (ß clinitgen.endMethod())

                                                                ;; end of class
                                                                (ß cv.visitEnd())

                                                                (ß bytecode = cw.toByteArray())
                                                                (when (ß RT.booleanCast(COMPILE_FILES.deref()))
                                                                    (ß writeClassFile(internalName, bytecode))
                                                                )
                                                                nil
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method- void emitKeywordCallsites(GeneratorAdapter clinitgen)
            (loop-when-recur [(ß int i = 0)] (ß i < keywordCallsites.count()) [(ß i++)]
                (let [#_"Keyword" k (ß (Keyword) keywordCallsites.nth(i))]
                    (ß clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE))
                    (ß clinitgen.dup())
                    (ß emitValue(k, clinitgen))
                    (ß clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE, Method.getMethod("void <init>(cloiure.lang.Keyword)")))
                    (ß clinitgen.dup())
                    (ß clinitgen.putStatic(objtype, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE))
                    (ß clinitgen.putStatic(objtype, thunkNameStatic(i), ILOOKUP_THUNK_TYPE))
                )
            )
            nil
        )

        #_protected
        (§ method void emitStatics(ClassVisitor gen)
            nil
        )

        #_protected
        (§ method void emitMethods(ClassVisitor gen)
            nil
        )

        (§ method void emitListAsObjectArray(Object value, GeneratorAdapter gen)
            (ß gen.push(((List) value).size()))
            (ß gen.newArray(OBJECT_TYPE))
            (let [#_"int" i 0]
                (loop-when-recur [(ß Iterator it = ((List) value).iterator())] (ß it.hasNext()) [(ß i++)]
                    (ß gen.dup())
                    (ß gen.push(i))
                    (ß emitValue(it.next(), gen))
                    (ß gen.arrayStore(OBJECT_TYPE))
                )
                nil
            )
        )

        (§ method void emitValue(Object value, GeneratorAdapter gen)
            (let [#_"boolean" partial true]
                (cond (ß value == nil)
                    (do
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    )
                    (ß value instanceof String)
                    (do
                        (ß gen.push((String) value))
                    )
                    (ß value instanceof Boolean)
                    (do
                        (if (ß ((Boolean) value).booleanValue())
                            (do
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                            )
                            (do
                                (ß gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                            )
                        )
                    )
                    (ß value instanceof Integer)
                    (do
                        (ß gen.push(((Integer) value).intValue()))
                        (ß gen.invokeStatic(Type.getType(Integer.class), Method.getMethod("Integer valueOf(int)")))
                    )
                    (ß value instanceof Long)
                    (do
                        (ß gen.push(((Long) value).longValue()))
                        (ß gen.invokeStatic(Type.getType(Long.class), Method.getMethod("Long valueOf(long)")))
                    )
                    (ß value instanceof Double)
                    (do
                        (ß gen.push(((Double) value).doubleValue()))
                        (ß gen.invokeStatic(Type.getType(Double.class), Method.getMethod("Double valueOf(double)")))
                    )
                    (ß value instanceof Character)
                    (do
                        (ß gen.push(((Character) value).charValue()))
                        (ß gen.invokeStatic(Type.getType(Character.class), Method.getMethod("Character valueOf(char)")))
                    )
                    (ß value instanceof Class)
                    (do
                        (let [#_"Class" cc (ß (Class)value)]
                            (if (ß cc.isPrimitive())
                                (do
                                    (§ let [#_"Type" bt]
                                        (cond (ß cc == boolean.class)
                                            (do
                                                (ß bt = Type.getType(Boolean.class))
                                            )
                                            (ß cc == byte.class)
                                            (do
                                                (ß bt = Type.getType(Byte.class))
                                            )
                                            (ß cc == char.class)
                                            (do
                                                (ß bt = Type.getType(Character.class))
                                            )
                                            (ß cc == double.class)
                                            (do
                                                (ß bt = Type.getType(Double.class))
                                            )
                                            (ß cc == float.class)
                                            (do
                                                (ß bt = Type.getType(Float.class))
                                            )
                                            (ß cc == int.class)
                                            (do
                                                (ß bt = Type.getType(Integer.class))
                                            )
                                            (ß cc == long.class)
                                            (do
                                                (ß bt = Type.getType(Long.class))
                                            )
                                            (ß cc == short.class)
                                            (do
                                                (ß bt = Type.getType(Short.class))
                                            )
                                            :else
                                            (do
                                                (throw (ß Util.runtimeException("Can't embed unknown primitive in code: " + value)))
                                            )
                                        )
                                        (ß gen.getStatic(bt, "TYPE", Type.getType(Class.class)))
                                    )
                                )
                                (do
                                    (ß gen.push(destubClassName(cc.getName())))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
                                )
                            )
                        )
                    )
                    (ß value instanceof Symbol)
                    (do
                        (ß gen.push(((Symbol) value).ns))
                        (ß gen.push(((Symbol) value).name))
                        (ß gen.invokeStatic(Type.getType(Symbol.class), Method.getMethod("cloiure.lang.Symbol intern(String,String)")))
                    )
                    (ß value instanceof Keyword)
                    (do
                        (ß gen.push(((Keyword) value).sym.ns))
                        (ß gen.push(((Keyword) value).sym.name))
                        (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Keyword keyword(String,String)")))
                    )
                    (ß value instanceof Var)
                    (do
                        (let [#_"Var" var (ß (Var) value)]
                            (ß gen.push(var.ns.name.toString()))
                            (ß gen.push(var.sym.toString()))
                            (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)")))
                        )
                    )
                    (ß value instanceof IType)
                    (do
                        (let [#_"Method" ctor (ß new Method("<init>", Type.getConstructorDescriptor(value.getClass().getConstructors()[0])))]
                            (ß gen.newInstance(Type.getType(value.getClass())))
                            (ß gen.dup())
                            (let [#_"IPersistentVector" fields (ß (IPersistentVector) Reflector.invokeStaticMethod(value.getClass(), "getBasis", new Object[] (§)))]
                                (loop-when-recur [(ß ISeq s = RT.seq(fields))] (ß s != nil) [(ß s = s.next())]
                                    (let [#_"Symbol" field (ß (Symbol) s.first())]
                                        (let [#_"Class" k (ß tagClass(tagOf(field)))]
                                            (let [#_"Object" val (ß Reflector.getInstanceField(value, munge(field.name)))]
                                                (ß emitValue(val, gen))

                                                (when (ß k.isPrimitive())
                                                    (let [#_"Type" b (ß Type.getType(boxClass(k)))]
                                                        (let [#_"String" p (ß Type.getType(k).getDescriptor())]
                                                            (let [#_"String" n (ß k.getName())]
                                                                (ß gen.invokeVirtual(b, new Method(n+"Value", "()"+p)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (ß gen.invokeConstructor(Type.getType(value.getClass()), ctor))
                            )
                        )
                    )
                    (ß value instanceof IRecord)
                    (do
                        (let [#_"Method" createMethod (ß Method.getMethod(value.getClass().getName() + " create(cloiure.lang.IPersistentMap)"))]
                            (ß emitValue(PersistentArrayMap.create((java.util.Map) value), gen))
                            (ß gen.invokeStatic(getType(value.getClass()), createMethod))
                        )
                    )
                    (ß value instanceof IPersistentMap)
                    (do
                        (let [#_"List" entries (ß new ArrayList())]
                            (doseq [#_"Map.Entry" entry (ß (Set<Map.Entry>) ((Map) value).entrySet())]
                                (ß entries.add(entry.getKey()))
                                (ß entries.add(entry.getValue()))
                            )
                            (ß emitListAsObjectArray(entries, gen))
                            (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")))
                        )
                    )
                    (ß value instanceof IPersistentVector)
                    (do
                        (let [#_"IPersistentVector" args (ß (IPersistentVector) value)]
                            (if (ß args.count() <= Tuple.MAX_SIZE)
                                (do
                                    (loop-when-recur [(ß int i = 0)] (ß i < args.count()) [(ß i++)]
                                        (ß emitValue(args.nth(i), gen))
                                    )
                                    (ß gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
                                )
                                (do
                                    (ß emitListAsObjectArray(value, gen))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                                )
                            )
                        )
                    )
                    (ß value instanceof PersistentHashSet)
                    (do
                        (let [#_"ISeq" vs (ß RT.seq(value))]
                            (if (ß vs == nil)
                                (do
                                    (ß gen.getStatic(Type.getType(PersistentHashSet.class), "EMPTY", Type.getType(PersistentHashSet.class)))
                                )
                                (do
                                    (ß emitListAsObjectArray(vs, gen))
                                    (ß gen.invokeStatic(Type.getType(PersistentHashSet.class), Method.getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                                )
                            )
                        )
                    )
                    (ß value instanceof ISeq || value instanceof IPersistentList)
                    (do
                        (ß emitListAsObjectArray(value, gen))
                        (ß gen.invokeStatic(Type.getType(java.util.Arrays.class), Method.getMethod("java.util.List asList(Object[])")))
                        (ß gen.invokeStatic(Type.getType(PersistentList.class), Method.getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
                    )
                    (ß value instanceof Pattern)
                    (do
                        (ß emitValue(value.toString(), gen))
                        (ß gen.invokeStatic(Type.getType(Pattern.class), Method.getMethod("java.util.regex.Pattern compile(String)")))
                    )
                    :else
                    (do
                        (let [#_"String" cs nil]
                            (try
                                (ß cs = RT.printString(value))
                                (catch Exception e
                                    (throw (ß Util.runtimeException("Can't embed object in code, maybe print-dup not defined: " + value)))
                                )
                            )
                            (when (ß cs.length() == 0)
                                (throw (ß Util.runtimeException("Can't embed unreadable object in code: " + value)))
                            )

                            (when (ß cs.startsWith("#<"))
                                (throw (ß Util.runtimeException("Can't embed unreadable object in code: " + cs)))
                            )

                            (ß gen.push(cs))
                            (ß gen.invokeStatic(RT_TYPE, readStringMethod))
                            (ß partial = false)
                        )
                    )
                )

                (when partial
                    (when (ß value instanceof IObj && RT.count(((IObj) value).meta()) > 0)
                        (ß gen.checkCast(IOBJ_TYPE))
                        (let [#_"Object" m (ß ((IObj) value).meta())]
                            (ß emitValue(elideMeta(m), gen))
                            (ß gen.checkCast(IPERSISTENTMAP_TYPE))
                            (ß gen.invokeInterface(IOBJ_TYPE, Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                        )
                    )
                )
                nil
            )
        )

        (§ method void emitConstants(GeneratorAdapter clinitgen)
            (try
                (ß Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                (loop-when-recur [(ß int i = 0)] (ß i < constants.count()) [(ß i++)]
                    (when (ß usedConstants.contains(i))
                        (ß emitValue(constants.nth(i), clinitgen))
                        (ß clinitgen.checkCast(constantType(i)))
                        (ß clinitgen.putStatic(objtype, constantName(i), constantType(i)))
                    )
                )
                (finally
                    (ß Var.popThreadBindings())
                )
            )
            nil
        )

        (§ method boolean isMutable(LocalBinding lb)
            (ß isVolatile(lb) || RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("unsynchronized-mutable"))))
        )

        (§ method boolean isVolatile(LocalBinding lb)
            (ß RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("volatile-mutable"))))
        )

        (§ method boolean isDeftype()
            (ß (fields != nil))
        )

        (§ method boolean supportsMeta()
            (ß !isDeftype())
        )

        (§ method void emitClearCloses(GeneratorAdapter gen)
            nil
        )

        (§ method Class getCompiledClass()
            (§ sync this
                (when (ß compiledClass == nil)
                    (ß loader = (DynamicClassLoader) LOADER.deref())
                    (ß compiledClass = loader.defineClass(name, bytecode, src))
                )
                compiledClass
            )
        )

        (§ method Object eval()
            (when (ß isDeftype())
                (§ return nil)
            )
            (try
                (ß getCompiledClass().newInstance())
                (catch Exception e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )

        (§ method void emitLetFnInits(GeneratorAdapter gen, ObjExpr objx, IPersistentSet letFnLocals)
            ;; objx arg is enclosing objx, not this
            (ß gen.checkCast(objtype))

            (loop-when-recur [(ß ISeq s = RT.keys(closes))] (ß s != nil) [(ß s = s.next())]
                (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                    (when (ß letFnLocals.contains(lb))
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (ß gen.dup())
                            (if (ß primc != nil)
                                (do
                                    (ß objx.emitUnboxedLocal(gen, lb))
                                    (ß gen.putField(objtype, lb.name, Type.getType(primc)))
                                )
                                (do
                                    (ß objx.emitLocal(gen, lb, false))
                                    (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                                )
                            )
                        )
                    )
                )
            )
            (ß gen.pop())
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
            ;; objx arg is enclosing objx, not this
            (if (ß isDeftype())
                (do
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                )
                (do
                    (ß gen.newInstance(objtype))
                    (ß gen.dup())
                    (when (ß supportsMeta())
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    )
                    (loop-when-recur [(ß ISeq s = RT.seq(closesExprs))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"LocalBindingExpr" lbe (ß (LocalBindingExpr) s.first())]
                            (let [#_"LocalBinding" lb (ß lbe.b)]
                                (if (ß lb.getPrimitiveType() != nil)
                                    (do
                                        (ß objx.emitUnboxedLocal(gen, lb))
                                    )
                                    (do
                                        (ß objx.emitLocal(gen, lb, lbe.shouldClear))
                                    )
                                )
                            )
                        )
                    )
                    (ß gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes())))
                )
            )
            (when (ß context == C.STATEMENT)
                (ß gen.pop())
            )
            nil
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ field Class jc)

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = (compiledClass != nil) ? compiledClass :or (tag != nil) ? HostExpr.tagToClass(tag) :or IFn.class)
            )
            jc
        )

        (§ method void emitAssignLocal(GeneratorAdapter gen, LocalBinding lb, Expr val)
            (when (ß !isMutable(lb))
                (throw (ß new IllegalArgumentException("Cannot assign to non-mutable: " + lb.name)))
            )
            (let [#_"Class" primc (ß lb.getPrimitiveType())]
                (ß gen.loadThis())
                (if (ß primc != nil)
                    (do
                        (when (ß !(val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) val).canEmitPrimitive()))
                            (throw (ß new IllegalArgumentException("Must assign primitive to primitive mutable: " + lb.name)))
                        )
                        (let [#_"MaybePrimitiveExpr" me (ß (MaybePrimitiveExpr) val)]
                            (ß me.emitUnboxed(C.EXPRESSION, this, gen))
                            (ß gen.putField(objtype, lb.name, Type.getType(primc)))
                        )
                    )
                    (do
                        (ß val.emit(C.EXPRESSION, this, gen))
                        (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                    )
                )
                nil
            )
        )

        (§ method- void emitLocal(GeneratorAdapter gen, LocalBinding lb, boolean clear)
            (if (ß closes.containsKey(lb))
                (do
                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                        (ß gen.loadThis())
                        (if (ß primc != nil)
                            (do
                                (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                                (ß HostExpr.emitBoxReturn(this, gen, primc))
                            )
                            (do
                                (ß gen.getField(objtype, lb.name, OBJECT_TYPE))
                                (when (ß onceOnly && clear && lb.canBeCleared)
                                    (ß gen.loadThis())
                                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                    (ß gen.putField(objtype, lb.name, OBJECT_TYPE))
                                )
                            )
                        )
                    )
                )
                (do
                    (let [#_"int" argoff (ß canBeDirect ? 0 :or 1)]
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (if (ß lb.isArg)
                                (do
                                    (ß gen.loadArg(lb.idx-argoff))
                                    (cond (ß primc != nil)
                                        (do
                                            (ß HostExpr.emitBoxReturn(this, gen, primc))
                                        )
                                        (ß clear && lb.canBeCleared)
                                        (do
                                            (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                            (ß gen.storeArg(lb.idx - argoff))
                                        )
                                    )
                                )
                                (do
                                    (if (ß primc != nil)
                                        (do
                                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
                                            (ß HostExpr.emitBoxReturn(this, gen, primc))
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), lb.idx))
                                            (when (ß clear && lb.canBeCleared)
                                                (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                                (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ method- void emitUnboxedLocal(GeneratorAdapter gen, LocalBinding lb)
            (let [#_"int" argoff (ß canBeDirect ? 0 :or 1)]
                (let [#_"Class" primc (ß lb.getPrimitiveType())]
                    (cond (ß closes.containsKey(lb))
                        (do
                            (ß gen.loadThis())
                            (ß gen.getField(objtype, lb.name, Type.getType(primc)))
                        )
                        (ß lb.isArg)
                        (do
                            (ß gen.loadArg(lb.idx-argoff))
                        )
                        :else
                        (do
                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx))
                        )
                    )
                    nil
                )
            )
        )

        (§ method void emitVar(GeneratorAdapter gen, Var var)
            (let [#_"Integer" i (ß (Integer) vars.valAt(var))]
                (ß emitConstant(gen, i))
                nil
            )
        )

        (§ def Method varGetMethod = Method.getMethod("Object get()"))
        (§ def Method varGetRawMethod = Method.getMethod("Object getRawRoot()"))

        (§ method void emitVarValue(GeneratorAdapter gen, Var v)
            (let [#_"Integer" i (ß (Integer) vars.valAt(v))]
                (if (ß !v.isDynamic())
                    (do
                        (ß emitConstant(gen, i))
                        (ß gen.invokeVirtual(VAR_TYPE, varGetRawMethod))
                    )
                    (do
                        (ß emitConstant(gen, i))
                        (ß gen.invokeVirtual(VAR_TYPE, varGetMethod))
                    )
                )
                nil
            )
        )

        (§ method void emitKeyword(GeneratorAdapter gen, Keyword k)
            (let [#_"Integer" i (ß (Integer) keywords.valAt(k))]
                (ß emitConstant(gen, i))
                nil
            )
        )

        (§ method void emitConstant(GeneratorAdapter gen, int id)
            (ß usedConstants = (IPersistentSet) usedConstants.cons(id))
            (ß gen.getStatic(objtype, constantName(id), constantType(id)))
            nil
        )

        (§ method String constantName(int id)
            (ß CONST_PREFIX + id)
        )

        (§ method String siteName(int n)
            (ß "__site__" + n)
        )

        (§ method String siteNameStatic(int n)
            (ß siteName(n) + "__")
        )

        (§ method String thunkName(int n)
            (ß "__thunk__" + n)
        )

        (§ method String cachedClassName(int n)
            (ß "__cached_class__" + n)
        )

        (§ method String cachedVarName(int n)
            (ß "__cached_var__" + n)
        )

        (§ method String varCallsiteName(int n)
            (ß "__var__callsite__" + n)
        )

        (§ method String thunkNameStatic(int n)
            (ß thunkName(n) + "__")
        )

        (§ method Type constantType(int id)
            (let [#_"Object" o (ß constants.nth(id))]
                (let [#_"Class" c (ß cloiure.lang.Util.classOf(o))]
                    (when (ß c!= nil && Modifier.isPublic(c.getModifiers()))
                        ;; can't emit derived fn types due to visibility
                        (cond (ß LazySeq.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(ISeq.class)))
                            )
                            (ß c == Keyword.class)
                            (do
                                (§ return (ß Type.getType(Keyword.class)))
                            )
                            (ß RestFn.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(RestFn.class)))
                            )
                            (ß AFn.class.isAssignableFrom(c))
                            (do
                                (§ return (ß Type.getType(AFn.class)))
                            )
                            (ß c == Var.class)
                            (do
                                (§ return (ß Type.getType(Var.class)))
                            )
                            (ß c == String.class)
                            (do
                                (§ return (ß Type.getType(String.class)))
                            )
                        )
                    )
                    (ß OBJECT_TYPE)
                )
            )
        )
    )

    #_non-static
    (§ enum PATHTYPE
        (§ item PATH),
        (§ item BRANCH)
    )

    (class-ns PathNode
        (§ field PATHTYPE type)
        (§ field PathNode parent)

        (§ constructor PathNode(PATHTYPE type, PathNode parent)
            (ß this.type = type)
            (ß this.parent = parent)
            this
        )
    )

    (§ defn PathNode clearPathRoot()
        (ß (PathNode) CLEAR_ROOT.get())
    )

    #_non-static
    (§ enum PSTATE
        (§ item REQ),
        (§ item REST),
        (§ item DONE)
    )

    (class-ns FnMethod (§ extends ObjMethod)
        ;; localbinding->localbinding
        (§ field PersistentVector reqParms = PersistentVector.EMPTY)
        (§ field LocalBinding restParm = nil)
        (§ field Type[] argtypes)
        (§ field Class[] argclasses)
        (§ field Class retClass)
        (§ field String prim)

        (§ constructor FnMethod(ObjExpr objx, ObjMethod parent)
            (§ super(objx, parent))
            this
        )

        (§ defn char classChar(Object x)
            (let [#_"Class" c nil]
                (cond (ß x instanceof Class)
                    (do
                        (ß c = (Class) x)
                    )
                    (ß x instanceof Symbol)
                    (do
                        (ß c = primClass((Symbol) x))
                    )
                )
                (when (ß c == nil || !c.isPrimitive())
                    (§ return (ß \O))
                )
                (when (ß c == long.class)
                    (§ return (ß \L))
                )
                (when (ß c == double.class)
                    (§ return (ß \D))
                )
                (throw (ß new IllegalArgumentException("Only long and double primitives are supported")))
            )
        )

        (§ defn String primInterface(IPersistentVector arglist)
            (let [#_"StringBuilder" sb (ß new StringBuilder())]
                (loop-when-recur [(ß int i = 0)] (ß i < arglist.count()) [(ß i++)]
                    (ß sb.append(classChar(tagOf(arglist.nth(i)))))
                )
                (ß sb.append(classChar(tagOf(arglist))))
                (let [#_"String" ret (ß sb.toString())]
                    (let [#_"boolean" prim (ß ret.contains("L") || ret.contains("D"))]
                        (when (ß prim && arglist.count() > 4)
                            (throw (ß new IllegalArgumentException("fns taking primitives support only 4 or fewer args")))
                        )
                        (when prim
                            (§ return (ß "cloiure.lang.IFn$" + ret))
                        )
                        nil
                    )
                )
            )
        )

        (§ defn FnMethod parse(ObjExpr objx, ISeq form, Object rettag)
            ;; ([args] body...)
            (let [#_"IPersistentVector" parms (ß (IPersistentVector) RT.first(form))]
                (let [#_"ISeq" body (ß RT.next(form))]
                    (try
                        (let [#_"FnMethod" method (ß new FnMethod(objx, (ObjMethod) METHOD.deref()))]
                            (ß method.line = lineDeref())
                            (ß method.column = columnDeref())
                            ;; register as the current method and set up a new env frame
                            (let [#_"PathNode" pnode (ß  (PathNode) CLEAR_PATH.get())]
                                (when (ß pnode == nil)
                                    (ß pnode = new PathNode(PATHTYPE.PATH, nil))
                                )
                                (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                    #_map METHOD, method,
                                    #_map LOCAL_ENV, LOCAL_ENV.deref(),
                                    #_map LOOP_LOCALS, nil,
                                    #_map NEXT_LOCAL_NUM, 0,
                                    #_map CLEAR_PATH, pnode,
                                    #_map CLEAR_ROOT, pnode,
                                    #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                                    #_map METHOD_RETURN_CONTEXT, RT.T
                                )))

                                (ß method.prim = primInterface(parms))
                                (when (ß method.prim != nil)
                                    (ß method.prim = method.prim.replace(\., \/))
                                )

                                (when (ß rettag instanceof String)
                                    (ß rettag = Symbol.intern(nil, (String) rettag))
                                )
                                (when (ß !(rettag instanceof Symbol))
                                    (ß rettag = nil)
                                )
                                (when (ß rettag != nil)
                                    (let [#_"String" retstr (ß ((Symbol)rettag).getName())]
                                        (when (ß !(retstr.equals("long") || retstr.equals("double")))
                                            (ß rettag = nil)
                                        )
                                    )
                                )
                                (ß method.retClass = tagClass((tagOf(parms) != nil) ? tagOf(parms) :or rettag))
                                (if (ß method.retClass.isPrimitive())
                                    (do
                                        (when (ß !(method.retClass == double.class || method.retClass == long.class))
                                            (throw (ß new IllegalArgumentException("Only long and double primitives are supported")))
                                        )
                                    )
                                    (do
                                        (ß method.retClass = Object.class)
                                    )
                                )
                                ;; register 'this' as local 0
                                (if (ß objx.thisName != nil)
                                    (do
                                        (ß registerLocal(Symbol.intern(objx.thisName), nil, nil, false))
                                    )
                                    (do
                                        (ß getAndIncLocalNum())
                                    )
                                )
                                (let [#_"PSTATE" state (ß PSTATE.REQ)]
                                    (let [#_"PersistentVector" argLocals (ß PersistentVector.EMPTY)]
                                        (let [#_"ArrayList<Type>" argtypes (ß new ArrayList())]
                                            (let [#_"ArrayList<Class>" argclasses (ß new ArrayList())]
                                                (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                                                    (when (ß !(parms.nth(i) instanceof Symbol))
                                                        (throw (ß new IllegalArgumentException("fn params must be Symbols")))
                                                    )
                                                    (let [#_"Symbol" p (ß (Symbol) parms.nth(i))]
                                                        (when (ß p.getNamespace() != nil)
                                                            (throw (ß Util.runtimeException("Can't use qualified name as parameter: " + p)))
                                                        )
                                                        (if (ß p.equals(_AMP_))
                                                            (do
                                                                (if (ß state == PSTATE.REQ)
                                                                    (do
                                                                        (ß state = PSTATE.REST)
                                                                    )
                                                                    (do
                                                                        (throw (ß Util.runtimeException("Invalid parameter list")))
                                                                    )
                                                                )
                                                            )
                                                            (do
                                                                (let [#_"Class" pc (ß primClass(tagClass(tagOf(p))))]
                                                                    (when (ß pc.isPrimitive() && !(pc == double.class || pc == long.class))
                                                                        (throw (ß new IllegalArgumentException("Only long and double primitives are supported: " + p)))
                                                                    )

                                                                    (when (ß state == PSTATE.REST && tagOf(p) != nil)
                                                                        (throw (ß Util.runtimeException("& arg cannot have type hint")))
                                                                    )
                                                                    (when (ß state == PSTATE.REST && method.prim != nil)
                                                                        (throw (ß Util.runtimeException("fns taking primitives cannot be variadic")))
                                                                    )

                                                                    (when (ß state == PSTATE.REST)
                                                                        (ß pc = ISeq.class)
                                                                    )
                                                                    (ß argtypes.add(Type.getType(pc)))
                                                                    (ß argclasses.add(pc))
                                                                    (let [#_"LocalBinding" lb (ß pc.isPrimitive() ? registerLocal(p, nil, new MethodParamExpr(pc), true) :or registerLocal(p, (state == PSTATE.REST) ? ISEQ :or tagOf(p), nil, true))]
                                                                        (ß argLocals = argLocals.cons(lb))
                                                                        (§ switch state
                                                                            (§ case REQ)
                                                                            (do
                                                                                (ß method.reqParms = method.reqParms.cons(lb))
                                                                                (§ break )
                                                                            )
                                                                            (§ case REST)
                                                                            (do
                                                                                (ß method.restParm = lb)
                                                                                (ß state = PSTATE.DONE)
                                                                                (§ break )
                                                                            )
                                                                            (§ default )
                                                                            (do
                                                                                (throw (ß Util.runtimeException("Unexpected parameter")))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (when (ß method.reqParms.count() > MAX_POSITIONAL_ARITY)
                                                    (throw (ß Util.runtimeException("Can't specify more than " + MAX_POSITIONAL_ARITY + " params")))
                                                )
                                                (ß LOOP_LOCALS.set(argLocals))
                                                (ß method.argLocals = argLocals)
                                                (ß method.argtypes = argtypes.toArray(new Type[argtypes.size()]))
                                                (ß method.argclasses = argclasses.toArray(new Class[argtypes.size()]))
                                                (when (ß method.prim != nil)
                                                    (loop-when-recur [(ß int i = 0)] (ß i < method.argclasses.length) [(ß i++)]
                                                        (when (ß method.argclasses[i] == long.class || method.argclasses[i] == double.class)
                                                            (ß getAndIncLocalNum())
                                                        )
                                                    )
                                                )
                                                (ß method.body = (new BodyExpr.Parser()).parse(C.RETURN, body))
                                                method
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (finally
                            (ß Var.popThreadBindings())
                        )
                    )
                )
            )
        )

        (§ method void emit(ObjExpr fn, ClassVisitor cv)
            (cond (ß fn.canBeDirect)
                (do
                    (ß doEmitStatic(fn, cv))
                )
                (ß prim != nil)
                (do
                    (ß doEmitPrim(fn, cv))
                )
                :else
                (do
                    (ß doEmit(fn, cv))
                )
            )
            nil
        )

        (§ method void doEmitStatic(ObjExpr fn, ClassVisitor cv)
            (let [#_"Type" returnType (ß Type.getType(retClass))]
                (let [#_"Method" ms (ß new Method("invokeStatic", returnType, argtypes))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, ms, nil, EXCEPTION_TYPES, cv))]
                        (ß gen.visitCode())
                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                                (ß emitBody(objx, gen, retClass, body))

                                (let [#_"Label" end (ß gen.mark())]
                                    (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argtypes[lb.idx].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())

                            ;; generate the regular invoke, calling the static method
                            (let [#_"Method" m (ß new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))]
                                ;; todo don't hardwire EXCEPTION_TYPES
                                (ß gen = new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))
                                (ß gen.visitCode())
                                (loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                                    (ß gen.loadArg(i))
                                    (ß HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
                                    (when (ß !argclasses[i].isPrimitive())
                                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                        (ß gen.storeArg(i))
                                    )
                                )
                                (let [#_"Label" callLabel (ß gen.mark())]
                                    (ß gen.visitLineNumber(line, callLabel))
                                    (ß gen.invokeStatic(objx.objtype, ms))
                                    (ß gen.box(returnType))

                                    (ß gen.returnValue())
                                    (ß gen.endMethod())

                                    ;; generate primInvoke if prim
                                    (when (ß prim != nil)
                                        (when (ß retClass == double.class || retClass == long.class)
                                            (ß returnType = getReturnType())
                                        )
                                        (let [#_"else" returnType (ß OBJECT_TYPE)]
                                            (let [#_"Method" pm (ß new Method("invokePrim", returnType, argtypes))]
                                                ;; todo don't hardwire EXCEPTION_TYPES
                                                (ß gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL, pm, nil, EXCEPTION_TYPES, cv))
                                                (ß gen.visitCode())
                                                (loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                                                    (ß gen.loadArg(i))
                                                    (when (ß !argclasses[i].isPrimitive())
                                                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                                                        (ß gen.storeArg(i))
                                                    )
                                                )
                                                (ß gen.invokeStatic(objx.objtype, ms))

                                                (ß gen.returnValue())
                                                (ß gen.endMethod())
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method void doEmitPrim(ObjExpr fn, ClassVisitor cv)
            (§ let [#_"Type" returnType]
                (if (ß retClass == double.class || retClass == long.class)
                    (do
                        (ß returnType = getReturnType())
                    )
                    (do
                        (ß returnType = OBJECT_TYPE)
                    )
                )
                (let [#_"Method" ms (ß new Method("invokePrim", returnType, argtypes))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL, ms, nil, EXCEPTION_TYPES, cv))]
                        (ß gen.visitCode())

                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))
                                (ß emitBody(objx, gen, retClass, body))

                                (let [#_"Label" end (ß gen.mark())]
                                    (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                    (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argtypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())

                            ;; generate the regular invoke, calling the prim method
                            (let [#_"Method" m (ß new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))]
                                ;; todo don't hardwire EXCEPTION_TYPES
                                (ß gen = new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))
                                (ß gen.visitCode())
                                (ß gen.loadThis())
                                (loop-when-recur [(ß int i = 0)] (ß i < argtypes.length) [(ß i++)]
                                    (ß gen.loadArg(i))
                                    (ß HostExpr.emitUnboxArg(fn, gen, argclasses[i]))
                                )
                                (ß gen.invokeInterface(Type.getType("L"+prim+";"), ms))
                                (ß gen.box(getReturnType()))

                                (ß gen.returnValue())
                                (ß gen.endMethod())
                                nil
                            )
                        )
                    )
                )
            )
        )

        (§ method void doEmit(ObjExpr fn, ClassVisitor cv)
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))]
                    (ß gen.visitCode())

                    (let [#_"Label" loopLabel (ß gen.mark())]
                        (ß gen.visitLineNumber(line, loopLabel))
                        (try
                            (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                            (ß body.emit(C.RETURN, fn, gen))
                            (let [#_"Label" end (ß gen.mark())]
                                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                    (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                        (ß gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )

                        (ß gen.returnValue())
                        (ß gen.endMethod())
                        nil
                    )
                )
            )
        )

        (§ method PersistentVector reqParms()
            reqParms
        )

        (§ method LocalBinding restParm()
            restParm
        )

        (§ method boolean isVariadic()
            (ß (restParm != nil))
        )

        (§ method int numParams()
            (ß reqParms.count() + (isVariadic() ? 1 :or 0))
        )

        (§ method String getMethodName()
            (ß isVariadic() ? "doInvoke" :or "invoke")
        )

        (§ method Type getReturnType()
            (when (ß prim != nil) ;; objx.isStatic
                (§ return (ß Type.getType(retClass)))
            )
            (ß OBJECT_TYPE)
        )

        (§ method Type[] getArgTypes()
            (when (ß isVariadic() && reqParms.count() == MAX_POSITIONAL_ARITY)
                (let [#_"Type[]" ret (ß new Type[MAX_POSITIONAL_ARITY + 1])]
                    (loop-when-recur [(ß int i = 0)] (ß i < MAX_POSITIONAL_ARITY + 1) [(ß i++)]
                        (ß ret[i] = OBJECT_TYPE)
                    )
                    (§ return ret)
                )
            )
            (ß ARG_TYPES[numParams()])
        )

        (§ method void emitClearLocals(GeneratorAdapter gen)
            nil
        )
    )

    #_abstract
    (class-ns ObjMethod
        ;; when closures are defined inside other closures,
        ;; the closed over locals need to be propagated to the enclosing objx
        (§ field ObjMethod parent)
        ;; localbinding->localbinding
        (§ field IPersistentMap locals = nil)
        ;; num->localbinding
        (§ field IPersistentMap indexlocals = nil)
        (§ field Expr body = nil)
        (§ field ObjExpr objx)
        (§ field PersistentVector argLocals)
        (§ field int maxLocal = 0)
        (§ field int line)
        (§ field int column)
        (§ field boolean usesThis = false)
        (§ field PersistentHashSet localsUsedInCatchFinally = PersistentHashSet.EMPTY)
        #_protected
        (§ field IPersistentMap methodMeta)

        (§ method IPersistentMap locals()
            locals
        )

        (§ method Expr body()
            body
        )

        (§ method ObjExpr objx()
            objx
        )

        (§ method PersistentVector argLocals()
            argLocals
        )

        (§ method int maxLocal()
            maxLocal
        )

        (§ method int line()
            line
        )

        (§ method int column()
            column
        )

        (§ constructor ObjMethod(ObjExpr objx, ObjMethod parent)
            (ß this.parent = parent)
            (ß this.objx = objx)
            this
        )

        (§ defn void emitBody(ObjExpr objx, GeneratorAdapter gen, Class retClass, Expr body)
            (let [#_"MaybePrimitiveExpr" be (ß (MaybePrimitiveExpr) body)]
                (if (ß Util.isPrimitive(retClass) && be.canEmitPrimitive())
                    (do
                        (let [#_"Class" bc (ß maybePrimitiveType(be))]
                            (cond (ß bc == retClass)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                )
                                (ß retClass == long.class && bc == int.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(I2L))
                                )
                                (ß retClass == double.class && bc == float.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(F2D))
                                )
                                (ß retClass == int.class && bc == long.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                )
                                (ß retClass == float.class && bc == double.class)
                                (do
                                    (ß be.emitUnboxed(C.RETURN, objx, gen))
                                    (ß gen.visitInsn(D2F))
                                )
                                :else
                                (do
                                    (throw (ß new IllegalArgumentException("Mismatched primitive return, expected: " + retClass + ", had: " + be.getJavaClass())))
                                )
                            )
                        )
                    )
                    (do
                        (ß body.emit(C.RETURN, objx, gen))
                        (if (ß retClass == void.class)
                            (do
                                (ß gen.pop())
                            )
                            (do
                                (ß gen.unbox(Type.getType(retClass)))
                            )
                        )
                    )
                )
                nil
            )
        )

        (§ abstract int numParams())
        (§ abstract String getMethodName())
        (§ abstract Type getReturnType())
        (§ abstract Type[] getArgTypes())

        (§ method void emit(ObjExpr fn, ClassVisitor cv)
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, EXCEPTION_TYPES, cv))]
                    (ß gen.visitCode())

                    (let [#_"Label" loopLabel (ß gen.mark())]
                        (ß gen.visitLineNumber(line, loopLabel))
                        (try
                            (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                            (ß body.emit(C.RETURN, fn, gen))
                            (let [#_"Label" end (ß gen.mark())]
                                (ß gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0))
                                (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                    (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                        (ß gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )

                        (ß gen.returnValue())
                        (ß gen.endMethod())
                        nil
                    )
                )
            )
        )

        (§ method void emitClearLocals(GeneratorAdapter gen)
            nil
        )

        (§ method void emitClearLocalsOld(GeneratorAdapter gen)
            (loop-when-recur [(ß int i = 0)] (ß i < argLocals.count()) [(ß i++)]
                (let [#_"LocalBinding" lb (ß (LocalBinding) argLocals.nth(i))]
                    (when (ß !localsUsedInCatchFinally.contains(lb.idx) && lb.getPrimitiveType() == nil)
                        (ß gen.visitInsn(Opcodes.ACONST_NULL))
                        (ß gen.storeArg(lb.idx - 1))
                    )
                )
            )
            (loop-when-recur [(ß int i = numParams() + 1)] (ß i < maxLocal + 1) [(ß i++)]
                (when (ß !localsUsedInCatchFinally.contains(i))
                    (let [#_"LocalBinding" b (ß (LocalBinding) RT.get(indexlocals, i))]
                        (when (ß b == nil || maybePrimitiveType(b.init) == nil)
                            (ß gen.visitInsn(Opcodes.ACONST_NULL))
                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i))
                        )
                    )
                )
            )
            nil
        )

        (§ method void emitClearThis(GeneratorAdapter gen)
            (ß gen.visitInsn(Opcodes.ACONST_NULL))
            (ß gen.visitVarInsn(Opcodes.ASTORE, 0))
            nil
        )
    )

    (class-ns LocalBinding
        (§ field Symbol sym)
        (§ field Symbol tag)
        (§ field Expr init)
        (§ field int idx)
        (§ field String name)
        (§ field boolean isArg)
        (§ field PathNode clearPathRoot)
        (§ field boolean canBeCleared = !RT.booleanCast(getCompilerOption(disableLocalsClearingKey)))
        (§ field boolean recurMistmatch = false)
        (§ field boolean used = false)

        (§ constructor LocalBinding(int num, Symbol sym, Symbol tag, Expr init, boolean isArg, PathNode clearPathRoot)
            (when (ß maybePrimitiveType(init) != nil && tag != nil)
                (throw (ß new UnsupportedOperationException("Can't type hint a local with a primitive initializer")))
            )
            (ß this.idx = num)
            (ß this.sym = sym)
            (ß this.tag = tag)
            (ß this.init = init)
            (ß this.isArg = isArg)
            (ß this.clearPathRoot = clearPathRoot)
            (ß name = munge(sym.name))
            this
        )

        (§ field Boolean hjc)

        (§ method boolean hasJavaClass()
            (when (ß hjc == nil)
                (if (ß init != nil && init.hasJavaClass() && Util.isPrimitive(init.getJavaClass()) && !(init instanceof MaybePrimitiveExpr))
                    (do
                        (ß hjc =  false)
                    )
                    (do
                        (ß hjc = (tag != nil || (init != nil && init.hasJavaClass())))
                    )
                )
            )
            hjc
        )

        (§ field Class jc)

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (ß jc = (tag != nil) ? HostExpr.tagToClass(tag) :or init.getJavaClass())
            )
            jc
        )

        (§ method Class getPrimitiveType()
            (ß maybePrimitiveType(init))
        )
    )

    (class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
        (§ field LocalBinding b)
        (§ field Symbol tag)

        (§ field PathNode clearPath)
        (§ field PathNode clearRoot)
        (§ field boolean shouldClear = false)

        (§ constructor LocalBindingExpr(LocalBinding b, Symbol tag)
            (when (ß b.getPrimitiveType() != nil && tag != nil)
                (throw (ß new UnsupportedOperationException("Can't type hint a primitive local")))
            )
            (ß this.b = b)
            (ß this.tag = tag)

            (ß this.clearPath = (PathNode)CLEAR_PATH.get())
            (ß this.clearRoot = (PathNode)CLEAR_ROOT.get())
            (let [#_"IPersistentCollection" sites (ß (IPersistentCollection) RT.get(CLEAR_SITES.get(), b))]
                (ß b.used = true)

                (when (ß b.idx > 0)
                    (when (ß sites != nil)
                        (loop-when-recur [(ß ISeq s = sites.seq())] (ß s != nil) [(ß s = s.next())]
                            (let [#_"LocalBindingExpr" o (ß (LocalBindingExpr) s.first())]
                                (let [#_"PathNode" common (ß commonPath(clearPath, o.clearPath))]
                                    (when (ß common != nil && common.type == PATHTYPE.PATH)
                                        (ß o.shouldClear = false)
                                    )
                                )
                            )
                        )
                    )

                    (when (ß clearRoot == b.clearPathRoot)
                        (ß this.shouldClear = true)
                        (ß sites = RT.conj(sites, this))
                        (ß CLEAR_SITES.set(RT.assoc(CLEAR_SITES.get(), b, sites)))
                    )
                )
                this
            )
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval locals")))
        )

        (§ method boolean canEmitPrimitive()
            (ß (b.getPrimitiveType() != nil))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß objx.emitUnboxedLocal(gen, b))
            nil
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (when (ß context != C.STATEMENT)
                (ß objx.emitLocal(gen, b, shouldClear))
            )
            nil
        )

        (§ method Object evalAssign(Expr val)
            (throw (ß new UnsupportedOperationException("Can't eval locals")))
        )

        (§ method void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
            (ß objx.emitAssignLocal(gen, b, val))
            (when (ß context != C.STATEMENT)
                (ß objx.emitLocal(gen, b, false))
            )
            nil
        )

        (§ method boolean hasJavaClass()
            (ß (tag != nil || b.hasJavaClass()))
        )

        (§ field Class jc)

        (§ method Class getJavaClass()
            (when (ß jc == nil)
                (if (ß tag != nil)
                    (do
                        (ß jc = HostExpr.tagToClass(tag))
                    )
                    (do
                        (ß jc = b.getJavaClass())
                    )
                )
            )
            jc
        )
    )

    (class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field PersistentVector exprs)

        (§ method PersistentVector exprs()
            exprs
        )

        (§ constructor BodyExpr(PersistentVector exprs)
            (ß this.exprs = exprs)
            this
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frms)
                (let [#_"ISeq" forms (ß (ISeq) frms)]
                    (when (ß Util.equals(RT.first(forms), DO))
                        (ß forms = RT.next(forms))
                    )
                    (let [#_"PersistentVector" exprs (ß PersistentVector.EMPTY)]
                        (loop-when-recur [(ß )] (ß forms != nil) [(ß forms = forms.next())]
                            (let [#_"Expr" e (ß (context != C.EVAL && (context == C.STATEMENT || forms.next() != nil)) ? analyze(C.STATEMENT, forms.first()) :or analyze(context, forms.first()))]
                                (ß exprs = exprs.cons(e))
                            )
                        )
                        (when (ß exprs.count() == 0)
                            (ß exprs = exprs.cons(NIL_EXPR))
                        )
                        (ß new BodyExpr(exprs))
                    )
                )
            )
        )

        (§ method Object eval()
            (let [#_"Object" ret nil]
                (doseq [#_"Object" o exprs]
                    (let [#_"Expr" e (ß (Expr) o)]
                        (ß ret = e.eval())
                    )
                )
                ret
            )
        )

        (§ method boolean canEmitPrimitive()
            (ß (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive()))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (loop-when-recur [(ß int i = 0)] (ß i < exprs.count() - 1) [(ß i++)]
                (let [#_"Expr" e (ß (Expr) exprs.nth(i))]
                    (ß e.emit(C.STATEMENT, objx, gen))
                )
            )
            (let [#_"MaybePrimitiveExpr" last (ß (MaybePrimitiveExpr) exprs.nth(exprs.count() - 1))]
                (ß last.emitUnboxed(context, objx, gen))
                nil
            )
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (loop-when-recur [(ß int i = 0)] (ß i < exprs.count() - 1) [(ß i++)]
                (let [#_"Expr" e (ß (Expr) exprs.nth(i))]
                    (ß e.emit(C.STATEMENT, objx, gen))
                )
            )
            (let [#_"Expr" last (ß (Expr) exprs.nth(exprs.count() - 1))]
                (ß last.emit(context, objx, gen))
                nil
            )
        )

        (§ method boolean hasJavaClass()
            (ß lastExpr().hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß lastExpr().getJavaClass())
        )

        (§ method- Expr lastExpr()
            (ß (Expr) exprs.nth(exprs.count() - 1))
        )
    )

    (class-ns BindingInit
        (§ field LocalBinding binding)
        (§ field Expr init)

        (§ method LocalBinding binding()
            binding
        )

        (§ method Expr init()
            init
        )

        (§ constructor BindingInit(LocalBinding binding, Expr init)
            (ß this.binding = binding)
            (ß this.init = init)
            this
        )
    )

    (class-ns LetFnExpr (§ implements Expr)
        (§ field PersistentVector bindingInits)
        (§ field Expr body)

        (§ constructor LetFnExpr(PersistentVector bindingInits, Expr body)
            (ß this.bindingInits = bindingInits)
            (ß this.body = body)
            this
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (letfns* [var (fn [args] body) ...] body...)
                    (when (ß !(RT.second(form) instanceof IPersistentVector))
                        (throw (ß new IllegalArgumentException("Bad binding form, expected vector")))
                    )

                    (let [#_"IPersistentVector" bindings (ß (IPersistentVector) RT.second(form))]
                        (when (ß (bindings.count() % 2) != 0)
                            (throw (ß new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")))
                        )

                        (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                            (when (ß context == C.EVAL)
                                (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                            )

                            (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))]
                                (try
                                    (ß Var.pushThreadBindings(dynamicBindings))

                                    ;; pre-seed env (like Lisp labels)
                                    (let [#_"PersistentVector" lbs (ß PersistentVector.EMPTY)]
                                        (loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                                            (when (ß !(bindings.nth(i) instanceof Symbol))
                                                (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))))
                                            )
                                            (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                (when (ß sym.getNamespace() != nil)
                                                    (throw (ß Util.runtimeException("Can't let qualified name: " + sym)))
                                                )
                                                (let [#_"LocalBinding" lb (ß registerLocal(sym, tagOf(sym), nil, false))]
                                                    (ß lb.canBeCleared = false)
                                                    (ß lbs = lbs.cons(lb))
                                                )
                                            )
                                        )
                                        (let [#_"PersistentVector" bindingInits (ß PersistentVector.EMPTY)]
                                            (loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                                                (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                    (let [#_"Expr" init (ß analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))]
                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.nth(i / 2))]
                                                            (ß lb.init = init)
                                                            (let [#_"BindingInit" bi (ß new BindingInit(lb, init))]
                                                                (ß bindingInits = bindingInits.cons(bi))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (ß new LetFnExpr(bindingInits, (new BodyExpr.Parser()).parse(context, body)))
                                        )
                                    )
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval letfns")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                    (ß gen.visitInsn(Opcodes.ACONST_NULL))
                    (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                )
            )

            (let [#_"IPersistentSet" lbset (ß PersistentHashSet.EMPTY)]
                (loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (ß lbset = (IPersistentSet) lbset.cons(bi.binding))
                        (ß bi.init.emit(C.EXPRESSION, objx, gen))
                        (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                    )
                )

                (loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (let [#_"ObjExpr" fe (ß (ObjExpr) bi.init)]
                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), bi.binding.idx))
                            (ß fe.emitLetFnInits(gen, objx, lbset))
                        )
                    )
                )

                (let [#_"Label" loopLabel (ß gen.mark())]
                    (ß body.emit(context, objx, gen))

                    (let [#_"Label" end (ß gen.mark())]
                        (loop-when-recur [(ß ISeq bis = bindingInits.seq())] (ß bis != nil) [(ß bis = bis.next())]
                            (let [#_"BindingInit" bi (ß (BindingInit) bis.first())]
                                (let [#_"String" lname (ß bi.binding.name)]
                                    (when (ß lname.endsWith("__auto__"))
                                        (ß lname += RT.nextID())
                                    )
                                    (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                                        (if (ß primc != nil)
                                            (do
                                                (ß gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, loopLabel, end, bi.binding.idx))
                                            )
                                            (do
                                                (ß gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, loopLabel, end, bi.binding.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        nil
                    )
                )
            )
        )

        (§ method boolean hasJavaClass()
            (ß body.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß body.getJavaClass())
        )
    )

    (class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field PersistentVector bindingInits)
        (§ field Expr body)
        (§ field boolean isLoop)

        (§ constructor LetExpr(PersistentVector bindingInits, Expr body, boolean isLoop)
            (ß this.bindingInits = bindingInits)
            (ß this.body = body)
            (ß this.isLoop = isLoop)
            this
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    ;; (let [var val var2 val2 ...] body...)
                    (let [#_"boolean" isLoop (ß RT.first(form).equals(LOOP))]
                        (when (ß !(RT.second(form) instanceof IPersistentVector))
                            (throw (ß new IllegalArgumentException("Bad binding form, expected vector")))
                        )

                        (let [#_"IPersistentVector" bindings (ß (IPersistentVector) RT.second(form))]
                            (when (ß (bindings.count() % 2) != 0)
                                (throw (ß new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")))
                            )

                            (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                                (when (ß context == C.EVAL || (context == C.EXPRESSION && isLoop))
                                    (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                                )

                                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                                    (let [#_"IPersistentMap" backupMethodLocals (ß method.locals)]
                                        (let [#_"IPersistentMap" backupMethodIndexLocals (ß method.indexlocals)]
                                            (let [#_"IPersistentVector" recurMismatches (ß PersistentVector.EMPTY)]
                                                (loop-when-recur [(ß int i = 0)] (ß i < bindings.count() / 2) [(ß i++)]
                                                    (ß recurMismatches = recurMismatches.cons(RT.F))
                                                )

                                                ;; may repeat once for each binding with a mismatch, return breaks
                                                (while true
                                                    (let [#_"IPersistentMap" dynamicBindings (ß RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))]
                                                        (ß method.locals = backupMethodLocals)
                                                        (ß method.indexlocals = backupMethodIndexLocals)

                                                        (let [#_"PathNode" looproot (ß new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))]
                                                            (let [#_"PathNode" clearroot (ß new PathNode(PATHTYPE.PATH, looproot))]
                                                                (let [#_"PathNode" clearpath (ß new PathNode(PATHTYPE.PATH, looproot))]
                                                                    (when isLoop
                                                                        (ß dynamicBindings = dynamicBindings.assoc(LOOP_LOCALS, nil))
                                                                    )

                                                                    (try
                                                                        (ß Var.pushThreadBindings(dynamicBindings))

                                                                        (let [#_"PersistentVector" bindingInits (ß PersistentVector.EMPTY)]
                                                                            (let [#_"PersistentVector" loopLocals (ß PersistentVector.EMPTY)]
                                                                                (loop-when-recur [(ß int i = 0)] (ß i < bindings.count()) [(ß i += 2)]
                                                                                    (when (ß !(bindings.nth(i) instanceof Symbol))
                                                                                        (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))))
                                                                                    )
                                                                                    (let [#_"Symbol" sym (ß (Symbol) bindings.nth(i))]
                                                                                        (when (ß sym.getNamespace() != nil)
                                                                                            (throw (ß Util.runtimeException("Can't let qualified name: " + sym)))
                                                                                        )
                                                                                        (let [#_"Expr" init (ß analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name))]
                                                                                            (when isLoop
                                                                                                (cond (ß recurMismatches != nil && RT.booleanCast(recurMismatches.nth(i / 2)))
                                                                                                    (do
                                                                                                        (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "box", RT.vector(init), false))
                                                                                                        (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                                                                                            (ß RT.errPrintWriter().println("Auto-boxing loop arg: " + sym))
                                                                                                        )
                                                                                                    )
                                                                                                    (ß maybePrimitiveType(init) == int.class)
                                                                                                    (do
                                                                                                        (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "longCast", RT.vector(init), false))
                                                                                                    )
                                                                                                    (ß maybePrimitiveType(init) == float.class)
                                                                                                    (do
                                                                                                        (ß init = new StaticMethodExpr("", 0, 0, nil, RT.class, "doubleCast", RT.vector(init), false))
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                            ;; sequential enhancement of env (like Lisp let*)
                                                                                            (try
                                                                                                (when isLoop
                                                                                                    (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath, CLEAR_ROOT, clearroot, NO_RECUR, nil)))
                                                                                                )
                                                                                                (let [#_"LocalBinding" lb (ß registerLocal(sym, tagOf(sym), init, false))]
                                                                                                    (let [#_"BindingInit" bi (ß new BindingInit(lb, init))]
                                                                                                        (ß bindingInits = bindingInits.cons(bi))
                                                                                                        (when isLoop
                                                                                                            (ß loopLocals = loopLocals.cons(lb))
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                                (finally
                                                                                                    (when isLoop
                                                                                                        (ß Var.popThreadBindings())
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                                (when isLoop
                                                                                    (ß LOOP_LOCALS.set(loopLocals))
                                                                                )
                                                                                (§ let [#_"Expr" bodyExpr]
                                                                                    (let [#_"boolean" moreMismatches false]
                                                                                        (try
                                                                                            (when isLoop
                                                                                                (let [#_"Object" methodReturnContext (ß (context == C.RETURN) ? METHOD_RETURN_CONTEXT.deref() :or nil)]
                                                                                                    (ß Var.pushThreadBindings(RT.map(
                                                                                                        #_map CLEAR_PATH, clearpath,
                                                                                                        #_map CLEAR_ROOT, clearroot,
                                                                                                        #_map NO_RECUR, nil,
                                                                                                        #_map METHOD_RETURN_CONTEXT, methodReturnContext
                                                                                                    )))
                                                                                                )
                                                                                            )
                                                                                            (ß bodyExpr = (new BodyExpr.Parser()).parse(isLoop ? C.RETURN :or context, body))
                                                                                            (finally
                                                                                                (when isLoop
                                                                                                    (ß Var.popThreadBindings())
                                                                                                    (loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                                                                                                        (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                                                                                                            (when (ß lb.recurMistmatch)
                                                                                                                (ß recurMismatches = (IPersistentVector)recurMismatches.assoc(i, RT.T))
                                                                                                                (ß moreMismatches = true)
                                                                                                            )
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                        (when (ß !moreMismatches)
                                                                                            (§ return (ß new LetExpr(bindingInits, bodyExpr, isLoop)))
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (finally
                                                                            (ß Var.popThreadBindings())
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval let/loop")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, false))
            nil
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, true))
            nil
        )

        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (let [(ß HashMap<BindingInit, Label> bindingLabels = new HashMap())]
                (loop-when-recur [(ß int i = 0)] (ß i < bindingInits.count()) [(ß i++)]
                    (let [#_"BindingInit" bi (ß (BindingInit) bindingInits.nth(i))]
                        (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                            (if (ß primc != nil)
                                (do
                                    (ß ((MaybePrimitiveExpr) bi.init).emitUnboxed(C.EXPRESSION, objx, gen))
                                    (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), bi.binding.idx))
                                )
                                (do
                                    (ß bi.init.emit(C.EXPRESSION, objx, gen))
                                    (if (ß !bi.binding.used && bi.binding.canBeCleared)
                                        (do
                                            (ß gen.pop())
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx))
                                        )
                                    )
                                )
                            )
                            (ß bindingLabels.put(bi, gen.mark()))
                        )
                    )
                )
                (let [#_"Label" loopLabel (ß gen.mark())]
                    (if isLoop
                        (do
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel)))
                                (if emitUnboxed
                                    (do
                                        (ß ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen))
                                    )
                                    (do
                                        (ß body.emit(context, objx, gen))
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )
                        )
                        (do
                            (if emitUnboxed
                                (do
                                    (ß ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen))
                                )
                                (do
                                    (ß body.emit(context, objx, gen))
                                )
                            )
                        )
                    )
                    (let [#_"Label" end (ß gen.mark())]
                        (loop-when-recur [(ß ISeq bis = bindingInits.seq())] (ß bis != nil) [(ß bis = bis.next())]
                            (let [#_"BindingInit" bi (ß (BindingInit) bis.first())]
                                (let [#_"String" lname (ß bi.binding.name)]
                                    (when (ß lname.endsWith("__auto__"))
                                        (ß lname += RT.nextID())
                                    )
                                    (let [#_"Class" primc (ß maybePrimitiveType(bi.init))]
                                        (if (ß primc != nil)
                                            (do
                                                (ß gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, bindingLabels.get(bi), end, bi.binding.idx))
                                            )
                                            (do
                                                (ß gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, bindingLabels.get(bi), end, bi.binding.idx))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        nil
                    )
                )
            )
        )

        (§ method boolean hasJavaClass()
            (ß body.hasJavaClass())
        )

        (§ method Class getJavaClass()
            (ß body.getJavaClass())
        )

        (§ method boolean canEmitPrimitive()
            (ß (body instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)body).canEmitPrimitive()))
        )
    )

    (class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field IPersistentVector args)
        (§ field IPersistentVector loopLocals)

        (§ field int line)
        (§ field int column)
        (§ field String source)

        (§ constructor RecurExpr(IPersistentVector loopLocals, IPersistentVector args, int line, int column, String source)
            (ß this.loopLocals = loopLocals)
            (ß this.args = args)
            (ß this.line = line)
            (ß this.column = column)
            (ß this.source = source)
            this
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval recur")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (let [#_"Label" loopLabel (ß (Label) LOOP_LABEL.deref())]
                (when (ß loopLabel == nil)
                    (throw (ß new IllegalStateException()))
                )
                (loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                        (let [#_"Expr" arg (ß (Expr) args.nth(i))]
                            (if (ß lb.getPrimitiveType() != nil)
                                (do
                                    (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                        (let [#_"Class" pc (ß maybePrimitiveType(arg))]
                                            (cond (ß pc == primc)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                )
                                                (ß primc == long.class && pc == int.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(I2L))
                                                )
                                                (ß primc == double.class && pc == float.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(F2D))
                                                )
                                                (ß primc == int.class && pc == long.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)")))
                                                )
                                                (ß primc == float.class && pc == double.class)
                                                (do
                                                    (ß ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen))
                                                    (ß gen.visitInsn(D2F))
                                                )
                                                :else
                                                (do
                                                    (throw (ß new IllegalArgumentException("recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + (arg.hasJavaClass() ? arg.getJavaClass().getName() :or "Object") + ", needed: " + primc.getName())))
                                                )
                                            )
                                        )
                                    )
                                )
                                (do
                                    (ß arg.emit(C.EXPRESSION, objx, gen))
                                )
                            )
                        )
                    )
                )

                (loop-when-recur [(ß int i = loopLocals.count() - 1)] (ß i >= 0) [(ß i--)]
                    (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                        (let [#_"Class" primc (ß lb.getPrimitiveType())]
                            (if (ß lb.isArg)
                                (do
                                    (ß gen.storeArg(lb.idx - (objx.canBeDirect ? 0 :or 1)))
                                )
                                (do
                                    (if (ß primc != nil)
                                        (do
                                            (ß gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), lb.idx))
                                        )
                                        (do
                                            (ß gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (ß gen.goTo(loopLabel))
                nil
            )
        )

        (§ method boolean hasJavaClass()
            true
        )

        (§ method Class getJavaClass()
            (ß RECUR_CLASS)
        )

        (class-ns Parser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"int" line (ß lineDeref())]
                    (let [#_"int" column (ß columnDeref())]
                        (let [#_"String" source (ß (String) SOURCE.deref())]
                            (let [#_"ISeq" form (ß (ISeq) frm)]
                                (let [#_"IPersistentVector" loopLocals (ß (IPersistentVector) LOOP_LOCALS.deref())]
                                    (when (ß context != C.RETURN || loopLocals == nil)
                                        (throw (ß new UnsupportedOperationException("Can only recur from tail position")))
                                    )
                                    (when (ß NO_RECUR.deref() != nil)
                                        (throw (ß new UnsupportedOperationException("Cannot recur across try")))
                                    )
                                    (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                                        (loop-when-recur [(ß ISeq s = RT.seq(form.next()))] (ß s != nil) [(ß s = s.next())]
                                            (ß args = args.cons(analyze(C.EXPRESSION, s.first())))
                                        )
                                        (when (ß args.count() != loopLocals.count())
                                            (throw (ß new IllegalArgumentException(String.format("Mismatched argument count to recur, expected: %d args, got: %d", loopLocals.count(), args.count()))))
                                        )
                                        (loop-when-recur [(ß int i = 0)] (ß i < loopLocals.count()) [(ß i++)]
                                            (let [#_"LocalBinding" lb (ß (LocalBinding) loopLocals.nth(i))]
                                                (let [#_"Class" primc (ß lb.getPrimitiveType())]
                                                    (when (ß primc != nil)
                                                        (let [#_"boolean" mismatch false]
                                                            (let [#_"Class" pc (ß maybePrimitiveType((Expr) args.nth(i)))]
                                                                (cond (ß primc == long.class)
                                                                    (do
                                                                        (when (ß !(pc == long.class || pc == int.class || pc == short.class || pc == char.class || pc == byte.class))
                                                                            (ß mismatch = true)
                                                                        )
                                                                    )
                                                                    (ß primc == double.class)
                                                                    (do
                                                                        (when (ß !(pc == double.class || pc == float.class))
                                                                            (ß mismatch = true)
                                                                        )
                                                                    )
                                                                )
                                                                (when mismatch
                                                                    (ß lb.recurMistmatch = true)
                                                                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                                                        (ß RT.errPrintWriter().println(source + ":" + line + " recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + ((pc != nil) ? pc.getName() :or "Object") + ", needed: " + primc.getName()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (ß new RecurExpr(loopLocals, args, line, column, source))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method boolean canEmitPrimitive()
            true
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß emit(context, objx, gen))
            nil
        )
    )

    (§ defn- LocalBinding registerLocal(Symbol sym, Symbol tag, Expr init, boolean isArg)
        (let [#_"int" num (ß getAndIncLocalNum())]
            (let [#_"LocalBinding" b (ß new LocalBinding(num, sym, tag, init, isArg, clearPathRoot()))]
                (let [#_"IPersistentMap" localsMap (ß (IPersistentMap) LOCAL_ENV.deref())]
                    (ß LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b)))
                    (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                        (ß method.locals = (IPersistentMap) RT.assoc(method.locals, b, b))
                        (ß method.indexlocals = (IPersistentMap) RT.assoc(method.indexlocals, num, b))
                        b
                    )
                )
            )
        )
    )

    (§ defn- int getAndIncLocalNum()
        (let [#_"int" num (ß ((Number) NEXT_LOCAL_NUM.deref()).intValue())]
            (let [#_"ObjMethod" m (ß (ObjMethod) METHOD.deref())]
                (when (ß num > m.maxLocal)
                    (ß m.maxLocal = num)
                )
                (ß NEXT_LOCAL_NUM.set(num + 1))
                num
            )
        )
    )

    (§ defn Expr analyze(C context, Object form)
        (ß analyze(context, form, nil))
    )

    (§ defn- Expr analyze(C context, Object form, String name)
        ;; todo symbol macro expansion?
        (try
            (when (ß form instanceof LazySeq)
                (let [#_"Object" mform form]
                    (ß form = RT.seq(form))
                    (when (ß form == nil)
                        (ß form = PersistentList.EMPTY)
                    )
                    (ß form = ((IObj)form).withMeta(RT.meta(mform)))
                )
            )
            (cond (ß form == nil)
                (do
                    (§ return (ß NIL_EXPR))
                )
                (ß form == Boolean.TRUE)
                (do
                    (§ return (ß TRUE_EXPR))
                )
                (ß form == Boolean.FALSE)
                (do
                    (§ return (ß FALSE_EXPR))
                )
            )
            (let [#_"Class" fclass (ß form.getClass())]
                (cond (ß fclass == Symbol.class)
                    (do
                        (§ return (ß analyzeSymbol((Symbol) form)))
                    )
                    (ß fclass == Keyword.class)
                    (do
                        (§ return (ß registerKeyword((Keyword) form)))
                    )
                    (ß form instanceof Number)
                    (do
                        (§ return (ß NumberExpr.parse((Number) form)))
                    )
                    (ß fclass == String.class)
                    (do
                        (§ return (ß new StringExpr(((String) form).intern())))
                    )
                    (ß form instanceof IPersistentCollection && !(form instanceof IRecord) && !(form instanceof IType) && ((IPersistentCollection) form).count() == 0)
                    (do
                        (let [#_"Expr" ret (ß new EmptyExpr(form))]
                            (when (ß RT.meta(form) != nil)
                                (ß ret = new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta())))
                            )
                            (§ return ret)
                        )
                    )
                    (ß form instanceof ISeq)
                    (do
                        (§ return (ß analyzeSeq(context, (ISeq) form, name)))
                    )
                    (ß form instanceof IPersistentVector)
                    (do
                        (§ return (ß VectorExpr.parse(context, (IPersistentVector) form)))
                    )
                    (ß form instanceof IRecord)
                    (do
                        (§ return (ß new ConstantExpr(form)))
                    )
                    (ß form instanceof IType)
                    (do
                        (§ return (ß new ConstantExpr(form)))
                    )
                    (ß form instanceof IPersistentMap)
                    (do
                        (§ return (ß MapExpr.parse(context, (IPersistentMap) form)))
                    )
                    (ß form instanceof IPersistentSet)
                    (do
                        (§ return (ß SetExpr.parse(context, (IPersistentSet) form)))
                    )
                )

                (ß new ConstantExpr(form))
            )
            (catch Throwable e
                (if (ß !(e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                    )
                    (do
                        (throw (ß (CompilerException) e))
                    )
                )
            )
        )
    )

    (class-ns CompilerException (§ extends RuntimeException)
        (§ field String source)

        (§ field int line)

        (§ constructor CompilerException(String source, int line, int column, Throwable cause)
            (§ super(errorMsg(source, line, column, cause.toString()), cause))
            (ß this.source = source)
            (ß this.line = line)
            this
        )

        (§ method String toString()
            (ß getMessage())
        )
    )

    (§ defn Var isMacro(Object op)
        ;; no local macros for now
        (when (ß op instanceof Symbol && referenceLocal((Symbol) op) != nil)
            (§ return nil)
        )
        (when (ß op instanceof Symbol || op instanceof Var)
            (let [#_"Var" v (ß (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false, false))]
                (when (ß v != nil && v.isMacro())
                    (when (ß v.ns != currentNS() && !v.isPublic())
                        (throw (ß new IllegalStateException("var: " + v + " is not public")))
                    )
                    (§ return v)
                )
            )
        )
        nil
    )

    (§ defn IFn isInline(Object op, int arity)
        ;; no local inlines for now
        (when (ß op instanceof Symbol && referenceLocal((Symbol) op) != nil)
            (§ return nil)
        )
        (when (ß op instanceof Symbol || op instanceof Var)
            (let [#_"Var" v (ß (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false))]
                (when (ß v != nil)
                    (when (ß v.ns != currentNS() && !v.isPublic())
                        (throw (ß new IllegalStateException("var: " + v + " is not public")))
                    )
                    (let [#_"IFn" ret (ß (IFn) RT.get(v.meta(), inlineKey))]
                        (when (ß ret != nil)
                            (let [#_"IFn" arityPred (ß (IFn) RT.get(v.meta(), inlineAritiesKey))]
                                (when (ß arityPred == nil || RT.booleanCast(arityPred.invoke(arity)))
                                    (§ return ret)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn boolean namesStaticMember(Symbol sym)
        (ß (sym.ns != nil && namespaceFor(sym) == nil))
    )

    (§ defn Object preserveTag(ISeq src, Object dst)
        (let [#_"Symbol" tag (ß tagOf(src))]
            (when (ß tag != nil && dst instanceof IObj)
                (let [#_"IPersistentMap" meta (ß RT.meta(dst))]
                    (§ return (ß ((IObj) dst).withMeta((IPersistentMap) RT.assoc(meta, RT.TAG_KEY, tag))))
                )
            )
            dst
        )
    )

    #_volatile
    (§ def- Var MACRO_CHECK = nil)
    #_volatile
    (§ def- boolean MACRO_CHECK_LOADING = false)
    (§ def- Object MACRO_CHECK_LOCK = new Object())

    (§ defn- Var ensureMacroCheck() (§ throws ClassNotFoundException, IOException)
        (when (ß MACRO_CHECK == nil)
            (§ sync (ß MACRO_CHECK_LOCK)
                (when (ß MACRO_CHECK == nil)
                    (ß MACRO_CHECK_LOADING = true)
                    (ß RT.load("cloiure/spec/alpha"))
                    (ß RT.load("cloiure/core/specs/alpha"))
                    (ß MACRO_CHECK = Var.find(Symbol.intern("cloiure.spec.alpha", "macroexpand-check")))
                    (ß MACRO_CHECK_LOADING = false)
                )
            )
        )
        (ß MACRO_CHECK)
    )

    (§ defn void checkSpecs(Var v, ISeq form)
        (when (ß RT.CHECK_SPECS && !MACRO_CHECK_LOADING)
            (try
                (ß ensureMacroCheck().applyTo(RT.cons(v, RT.list(form.next()))))
                (catch Exception e
                    (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                )
            )
        )
        nil
    )

    (§ defn Object macroexpand1(Object x)
        (when (ß x instanceof ISeq)
            (let [#_"ISeq" form (ß (ISeq) x)]
                (let [#_"Object" op (ß RT.first(form))]
                    (when (ß isSpecial(op))
                        (§ return x)
                    )
                    ;; macro expansion
                    (let [#_"Var" v (ß isMacro(op))]
                        (if (ß v != nil)
                            (do
                                (ß checkSpecs(v, form))

                                (try
                                    (let [#_"ISeq" args (ß RT.cons(form, RT.cons(Compiler.LOCAL_ENV.get(), form.next())))]
                                        (§ return (ß v.applyTo(args)))
                                    )
                                    (catch ArityException e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ß new ArityException(e.actual - 2, e.name)))
                                    )
                                )
                            )
                            (do
                                (when (ß op instanceof Symbol)
                                    (let [#_"Symbol" sym (ß (Symbol) op)]
                                        (let [#_"String" sname (ß sym.name)]
                                            ;; (.substring s 2 5) => (. s substring 2 5)
                                            (cond (ß sym.name.charAt(0) == \.)
                                                (do
                                                    (when (ß RT.length(form) < 2)
                                                        (throw (ß new IllegalArgumentException("Malformed member expression, expecting (.member target ...)")))
                                                    )
                                                    (let [#_"Symbol" meth (ß Symbol.intern(sname.substring(1)))]
                                                        (let [#_"Object" target (ß RT.second(form))]
                                                            (when (ß HostExpr.maybeClass(target, false) != nil)
                                                                (ß target = ((IObj)RT.list(IDENTITY, target)).withMeta(RT.map(RT.TAG_KEY, CLASS)))
                                                            )
                                                            (§ return (ß preserveTag(form, RT.listStar(DOT, target, meth, form.next().next()))))
                                                        )
                                                    )
                                                )
                                                (ß namesStaticMember(sym))
                                                (do
                                                    (let [#_"Symbol" target (ß Symbol.intern(sym.ns))]
                                                        (let [#_"Class" c (ß HostExpr.maybeClass(target, false))]
                                                            (when (ß c != nil)
                                                                (let [#_"Symbol" meth (ß Symbol.intern(sym.name))]
                                                                    (§ return (ß preserveTag(form, RT.listStar(DOT, target, meth, form.next()))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                :else
                                                (do
                                                    ;; (s.substring 2 5) => (. s substring 2 5)
                                                    ;; also (package.class.name ...) (. package.class name ...)
                                                    (let [#_"int" idx (ß sname.lastIndexOf(\.))]
                                                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                                                        (when (ß idx == sname.length() - 1)
                                                            (§ return (ß RT.listStar(NEW, Symbol.intern(sname.substring(0, idx)), form.next())))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        x
    )

    (§ defn Object macroexpand(Object form)
        (let [#_"Object" exf (ß macroexpand1(form))]
            (when (ß exf != form)
                (§ return (ß macroexpand(exf)))
            )
            form
        )
    )

    (§ defn- Expr analyzeSeq(C context, ISeq form, String name)
        (let [#_"Object" line (ß lineDeref())]
            (let [#_"Object" column (ß columnDeref())]
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                    (ß line = RT.meta(form).valAt(RT.LINE_KEY))
                )
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                    (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
                )
                (ß Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
                (try
                    (let [#_"Object" me (ß macroexpand1(form))]
                        (when (ß me != form)
                            (§ return (ß analyze(context, me, name)))
                        )

                        (let [#_"Object" op (ß RT.first(form))]
                            (when (ß op == nil)
                                (throw (ß new IllegalArgumentException("Can't call nil, form: " + form)))
                            )
                            (let [#_"IFn" inline (ß isInline(op, RT.count(RT.next(form))))]
                                (when (ß inline != nil)
                                    (§ return (ß analyze(context, preserveTag(form, inline.applyTo(RT.next(form))))))
                                )
                                (§ let [#_"IParser" p]
                                    (cond (ß op.equals(FN))
                                        (do
                                            (ß FnExpr.parse(context, form, name))
                                        )
                                        (ß (p = (IParser) specials.valAt(op)) != nil)
                                        (do
                                            (ß p.parse(context, form))
                                        )
                                        :else
                                        (do
                                            (ß InvokeExpr.parse(context, form))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (catch Throwable e
                        (if (ß !(e instanceof CompilerException))
                            (do
                                (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)))
                            )
                            (do
                                (throw (ß (CompilerException) e))
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn String errorMsg(String source, int line, int column, String s)
        (ß String.format("%s, compiling:(%s:%d:%d)", s, source, line, column))
    )

    (§ defn Object eval(Object form)
        (ß eval(form, true))
    )

    (§ defn Object eval(Object form, boolean freshLoader)
        (let [#_"boolean" createdLoader false]
            (when true ;; !LOADER.isBound()
                (ß Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLoader())))
                (ß createdLoader = true)
            )
            (try
                (let [#_"Object" line (ß lineDeref())]
                    (let [#_"Object" column (ß columnDeref())]
                        (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                            (ß line = RT.meta(form).valAt(RT.LINE_KEY))
                        )
                        (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                            (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
                        )
                        (ß Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column)))
                        (try
                            (ß form = macroexpand(form))
                            (cond (ß form instanceof ISeq && Util.equals(RT.first(form), DO))
                                (do
                                    (let [#_"ISeq" s (ß RT.next(form))]
                                        (loop-when-recur [(ß )] (ß RT.next(s) != nil) [(ß s = RT.next(s))]
                                            (ß eval(RT.first(s), false))
                                        )
                                        (ß eval(RT.first(s), false))
                                    )
                                )
                                (ß (form instanceof IType) || (form instanceof IPersistentCollection && !(RT.first(form) instanceof Symbol && ((Symbol) RT.first(form)).name.startsWith("def"))))
                                (do
                                    (let [#_"ObjExpr" fexpr (ß (ObjExpr) analyze(C.EXPRESSION, RT.list(FN, PersistentVector.EMPTY, form), "eval" + RT.nextID()))]
                                        (let [#_"IFn" fn (ß (IFn) fexpr.eval())]
                                            (ß fn.invoke())
                                        )
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Expr" expr (ß analyze(C.EVAL, form))]
                                        (ß expr.eval())
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                    )
                )
                (finally
                    (when createdLoader
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn- int registerConstant(Object o)
        (when (ß !CONSTANTS.isBound())
            (§ return -1)
        )
        (let [#_"PersistentVector" v (ß (PersistentVector) CONSTANTS.deref())]
            (let [(ß IdentityHashMap<Object, Integer> ids = (IdentityHashMap<Object, Integer>) CONSTANT_IDS.deref())]
                (let [#_"Integer" i (ß ids.get(o))]
                    (when (ß i != nil)
                        (§ return i)
                    )
                    (ß CONSTANTS.set(RT.conj(v, o)))
                    (ß ids.put(o, v.count()))
                    (ß v.count())
                )
            )
        )
    )

    (§ defn- KeywordExpr registerKeyword(Keyword keyword)
        (when (ß !KEYWORDS.isBound())
            (§ return (ß new KeywordExpr(keyword)))
        )

        (let [#_"IPersistentMap" keywordsMap (ß (IPersistentMap) KEYWORDS.deref())]
            (let [#_"Object" id (ß RT.get(keywordsMap, keyword))]
                (when (ß id == nil)
                    (ß KEYWORDS.set(RT.assoc(keywordsMap, keyword, registerConstant(keyword))))
                )
                (ß new KeywordExpr(keyword))
            )
        )
    )

    (§ defn- int registerKeywordCallsite(Keyword keyword)
        (when (ß !KEYWORD_CALLSITES.isBound())
            (throw (ß new IllegalAccessError("KEYWORD_CALLSITES is not bound")))
        )

        (let [#_"IPersistentVector" keywordCallsites (ß (IPersistentVector) KEYWORD_CALLSITES.deref())]
            (ß keywordCallsites = keywordCallsites.cons(keyword))
            (ß KEYWORD_CALLSITES.set(keywordCallsites))
            (ß keywordCallsites.count() - 1)
        )
    )

    (§ defn- int registerProtocolCallsite(Var v)
        (when (ß !PROTOCOL_CALLSITES.isBound())
            (throw (ß new IllegalAccessError("PROTOCOL_CALLSITES is not bound")))
        )

        (let [#_"IPersistentVector" protocolCallsites (ß (IPersistentVector) PROTOCOL_CALLSITES.deref())]
            (ß protocolCallsites = protocolCallsites.cons(v))
            (ß PROTOCOL_CALLSITES.set(protocolCallsites))
            (ß protocolCallsites.count() - 1)
        )
    )

    (§ defn- void registerVarCallsite(Var v)
        (when (ß !VAR_CALLSITES.isBound())
            (throw (ß new IllegalAccessError("VAR_CALLSITES is not bound")))
        )

        (let [#_"IPersistentCollection" varCallsites (ß (IPersistentCollection) VAR_CALLSITES.deref())]
            (ß varCallsites = varCallsites.cons(v))
            (ß VAR_CALLSITES.set(varCallsites))
            nil
        )
    )

    (§ defn ISeq fwdPath(PathNode p1)
        (let [#_"ISeq" ret nil]
            (loop-when-recur [(ß )] (ß p1 != nil) [(ß p1 = p1.parent)]
                (ß ret = RT.cons(p1, ret))
            )
            ret
        )
    )

    (§ defn PathNode commonPath(PathNode n1, PathNode n2)
        (let [#_"ISeq" xp (ß fwdPath(n1))]
            (let [#_"ISeq" yp (ß fwdPath(n2))]
                (when (ß RT.first(xp) != RT.first(yp))
                    (§ return nil)
                )
                (while (ß RT.second(xp) != nil && RT.second(xp) == RT.second(yp))
                    (ß xp = xp.next())
                    (ß yp = yp.next())
                )
                (ß (PathNode) RT.first(xp))
            )
        )
    )

    (§ defn void addAnnotation(Object visitor, IPersistentMap meta)
        (when (ß meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(visitor, meta))
        )
        nil
    )

    (§ defn void addParameterAnnotation(Object visitor, IPersistentMap meta, int i)
        (when (ß meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(visitor, meta, i))
        )
        nil
    )

    (§ defn- Expr analyzeSymbol(Symbol sym)
        (let [#_"Symbol" tag (ß tagOf(sym))]
            (cond (ß sym.ns == nil) ;; ns-qualified syms are always Vars
                (do
                    (let [#_"LocalBinding" b (ß referenceLocal(sym))]
                        (when (ß b != nil)
                            (§ return (ß new LocalBindingExpr(b, tag)))
                        )
                    )
                )
                (ß namespaceFor(sym) == nil)
                (do
                    (let [#_"Symbol" nsSym (ß Symbol.intern(sym.ns))]
                        (let [#_"Class" c (ß HostExpr.maybeClass(nsSym, false))]
                            (when (ß c != nil)
                                (when (ß Reflector.getField(c, sym.name, true) != nil)
                                    (§ return (ß new StaticFieldExpr(lineDeref(), columnDeref(), c, sym.name, tag)))
                                )
                                (throw (ß Util.runtimeException("Unable to find static field: " + sym.name + " in " + c)))
                            )
                        )
                    )
                )
            )
            (let [#_"Object" o (ß resolve(sym))]
                (cond (ß o instanceof Var)
                    (do
                        (let [#_"Var" v (ß (Var) o)]
                            (when (ß isMacro(v) != nil)
                                (throw (ß Util.runtimeException("Can't take value of a macro: " + v)))
                            )
                            (when (ß RT.booleanCast(RT.get(v.meta(), RT.CONST_KEY)))
                                (§ return (ß analyze(C.EXPRESSION, RT.list(QUOTE, v.get()))))
                            )
                            (ß registerVar(v))
                            (§ return (ß new VarExpr(v, tag)))
                        )
                    )
                    (ß o instanceof Class)
                    (do
                        (§ return (ß new ConstantExpr(o)))
                    )
                    (ß o instanceof Symbol)
                    (do
                        (§ return (ß new UnresolvedVarExpr((Symbol) o)))
                    )
                )

                (throw (ß Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")))
            )
        )
    )

    (§ defn String destubClassName(String className)
        ;; skip over prefix + '.' or '/'
        (when (ß className.startsWith(COMPILE_STUB_PREFIX))
            (§ return (ß className.substring(COMPILE_STUB_PREFIX.length() + 1)))
        )
        className
    )

    (§ defn Type getType(Class c)
        (let [#_"String" descriptor (ß Type.getType(c).getDescriptor())]
            (when (ß descriptor.startsWith("L"))
                (ß descriptor = "L" + destubClassName(descriptor.substring(1)))
            )
            (ß Type.getType(descriptor))
        )
    )

    (§ defn Object resolve(Symbol sym, boolean allowPrivate)
        (ß resolveIn(currentNS(), sym, allowPrivate))
    )

    (§ defn Object resolve(Symbol sym)
        (ß resolveIn(currentNS(), sym, false))
    )

    (§ defn Namespace namespaceFor(Symbol sym)
        (ß namespaceFor(currentNS(), sym))
    )

    (§ defn Namespace namespaceFor(Namespace inns, Symbol sym)
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (let [#_"Symbol" nsSym (ß Symbol.intern(sym.ns))]
            (let [#_"Namespace" ns (ß inns.lookupAlias(nsSym))]
                (when (ß ns == nil)
                    ;; ...otherwise check the Namespaces map.
                    (ß ns = Namespace.find(nsSym))
                )
                ns
            )
        )
    )

    (§ defn Object resolveIn(Namespace n, Symbol sym, boolean allowPrivate)
        ;; note - ns-qualified vars must already exist
        (cond (ß sym.ns != nil)
            (do
                (let [#_"Namespace" ns (ß namespaceFor(n, sym))]
                    (when (ß ns == nil)
                        (throw (ß Util.runtimeException("No such namespace: " + sym.ns)))
                    )

                    (let [#_"Var" v (ß ns.findInternedVar(Symbol.intern(sym.name)))]
                        (cond (ß v == nil)
                            (do
                                (throw (ß Util.runtimeException("No such var: " + sym)))
                            )
                            (ß v.ns != currentNS() && !v.isPublic() && !allowPrivate)
                            (do
                                (throw (ß new IllegalStateException("var: " + sym + " is not public")))
                            )
                        )
                        v
                    )
                )
            )
            (ß sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
            (do
                (ß RT.classForName(sym.name))
            )
            (ß sym.equals(NS))
            (do
                (ß RT.NS_VAR)
            )
            (ß sym.equals(IN_NS))
            (do
                (ß RT.IN_NS_VAR)
            )
            :else
            (do
                (when (ß Util.equals(sym, COMPILE_STUB_SYM.get()))
                    (§ return (ß COMPILE_STUB_CLASS.get()))
                )
                (let [#_"Object" o (ß n.getMapping(sym))]
                    (when (ß o == nil)
                        (if (ß RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref()))
                            (do
                                (§ return sym)
                            )
                            (do
                                (throw (ß Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")))
                            )
                        )
                    )
                    o
                )
            )
        )
    )

    (§ defn Object maybeResolveIn(Namespace n, Symbol sym)
        ;; note - ns-qualified vars must already exist
        (cond (ß sym.ns != nil)
            (do
                (let [#_"Namespace" ns (ß namespaceFor(n, sym))]
                    (when (ß ns == nil)
                        (§ return nil)
                    )
                    (let [#_"Var" v (ß ns.findInternedVar(Symbol.intern(sym.name)))]
                        (when (ß v == nil)
                            (§ return nil)
                        )
                        v
                    )
                )
            )
            (ß sym.name.indexOf(\.) > 0 && !sym.name.endsWith(".") || sym.name.charAt(0) == \[)
            (do
                (ß RT.classForName(sym.name))
            )
            (ß sym.equals(NS))
            (do
                (ß RT.NS_VAR)
            )
            (ß sym.equals(IN_NS))
            (do
                (ß RT.IN_NS_VAR)
            )
            :else
            (do
                (let [#_"Object" o (ß n.getMapping(sym))]
                    o
                )
            )
        )
    )

    (§ defn Var lookupVar(Symbol sym, boolean internNew, boolean registerMacro)
        (let [#_"Var" var nil]
            ;; note - ns-qualified vars in other namespaces must already exist
            (cond (ß sym.ns != nil)
                (do
                    (let [#_"Namespace" ns (ß namespaceFor(sym))]
                        (when (ß ns == nil)
                            (§ return nil)
                        )
                        (let [#_"Symbol" name (ß Symbol.intern(sym.name))]
                            (if (ß internNew && ns == currentNS())
                                (do
                                    (ß var = currentNS().intern(name))
                                )
                                (do
                                    (ß var = ns.findInternedVar(name))
                                )
                            )
                        )
                    )
                )
                (ß sym.equals(NS))
                (do
                    (ß var = RT.NS_VAR)
                )
                (ß sym.equals(IN_NS))
                (do
                    (ß var = RT.IN_NS_VAR)
                )
                :else
                (do
                    ;; is it mapped?
                    (let [#_"Object" o (ß currentNS().getMapping(sym))]
                        (cond (ß o == nil)
                            (do
                                ;; introduce a new var in the current ns
                                (when internNew
                                    (ß var = currentNS().intern(Symbol.intern(sym.name)))
                                )
                            )
                            (ß o instanceof Var)
                            (do
                                (ß var = (Var) o)
                            )
                            :else
                            (do
                                (throw (ß Util.runtimeException("Expecting var, but " + sym + " is mapped to " + o)))
                            )
                        )
                    )
                )
            )
            (when (ß var != nil && (!var.isMacro() || registerMacro))
                (ß registerVar(var))
            )
            var
        )
    )

    (§ defn Var lookupVar(Symbol sym, boolean internNew)
        (ß lookupVar(sym, internNew, true))
    )

    (§ defn- void registerVar(Var var)
        (when (ß !VARS.isBound())
            (§ return nil)
        )
        (let [#_"IPersistentMap" varsMap (ß (IPersistentMap) VARS.deref())]
            (let [#_"Object" id (ß RT.get(varsMap, var))]
                (when (ß id == nil)
                    (ß VARS.set(RT.assoc(varsMap, var, registerConstant(var))))
                )
                nil
            )
        )
    )

    (§ defn Namespace currentNS()
        (ß (Namespace) RT.CURRENT_NS.deref())
    )

    (§ defn void closeOver(LocalBinding b, ObjMethod method)
        (when (ß b != nil && method != nil)
            (let [#_"LocalBinding" lb (ß (LocalBinding) RT.get(method.locals, b))]
                (if (ß lb == nil)
                    (do
                        (ß method.objx.closes = (IPersistentMap) RT.assoc(method.objx.closes, b, b))
                        (ß closeOver(b, method.parent))
                    )
                    (do
                        (when (ß lb.idx == 0)
                            (ß method.usesThis = true)
                        )
                        (when (ß IN_CATCH_FINALLY.deref() != nil)
                            (ß method.localsUsedInCatchFinally = (PersistentHashSet) method.localsUsedInCatchFinally.cons(b.idx))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn LocalBinding referenceLocal(Symbol sym)
        (when (ß !LOCAL_ENV.isBound())
            (§ return nil)
        )
        (let [#_"LocalBinding" b (ß (LocalBinding) RT.get(LOCAL_ENV.deref(), sym))]
            (when (ß b != nil)
                (let [#_"ObjMethod" method (ß (ObjMethod) METHOD.deref())]
                    (when (ß b.idx == 0)
                        (ß method.usesThis = true)
                    )
                    (ß closeOver(b, method))
                )
            )
            b
        )
    )

    (§ defn- Symbol tagOf(Object o)
        (let [#_"Object" tag (ß RT.get(RT.meta(o), RT.TAG_KEY))]
            (cond (ß tag instanceof Symbol)
                (do
                    (§ return (ß (Symbol) tag))
                )
                (ß tag instanceof String)
                (do
                    (§ return (ß Symbol.intern(nil, (String) tag)))
                )
            )
            nil
        )
    )

    (§ defn Object loadFile(String file) (§ throws IOException)
        (let [#_"FileInputStream" f (ß new FileInputStream(file))]
            (try
                (ß load(new InputStreamReader(f, RT.UTF8), new File(file).getAbsolutePath(), (new File(file)).getName()))
                (finally
                    (ß f.close())
                )
            )
        )
    )

    (§ defn Object load(Reader rdr)
        (ß load(rdr, nil, "NO_SOURCE_FILE"))
    )

    (§ defn void consumeWhitespaces(LineNumberingPushbackReader pushbackReader)
        (let [#_"int" ch (ß LispReader.read1(pushbackReader))]
            (while (ß LispReader.isWhitespace(ch))
                (ß ch = LispReader.read1(pushbackReader))
            )
            (ß LispReader.unread(pushbackReader, ch))
            nil
        )
    )

    (§ def- Object OPTS_COND_ALLOWED = RT.mapUniqueKeys(LispReader.OPT_READ_COND, LispReader.COND_ALLOW))

    (§ defn- Object readerOpts(String sourceName)
        (if (ß sourceName != nil && sourceName.endsWith(".clic"))
            (do
                (ß OPTS_COND_ALLOWED)
            )
            (do
                nil
            )
        )
    )

    (§ defn Object load(Reader rdr, String sourcePath, String sourceName)
        (let [(ß Object EOF = new Object())]
            (let [#_"Object" ret nil]
                (let [#_"LineNumberingPushbackReader" pushbackReader (ß (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))]
                    (ß consumeWhitespaces(pushbackReader))
                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                        #_map LOADER, RT.makeClassLoader(),
                        #_map SOURCE_PATH, sourcePath,
                        #_map SOURCE, sourceName,
                        #_map METHOD, nil,
                        #_map LOCAL_ENV, nil,
                        #_map LOOP_LOCALS, nil,
                        #_map NEXT_LOCAL_NUM, 0,
                        #_map RT.READEVAL, RT.T,
                        #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                        #_map LINE_BEFORE, pushbackReader.getLineNumber(),
                        #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                        #_map LINE_AFTER, pushbackReader.getLineNumber(),
                        #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
                        #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                        #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                        #_map RT.DATA_READERS, RT.DATA_READERS.deref()
                    )))

                    (let [#_"Object" readerOpts (ß readerOpts(sourceName))]
                        (try
                            (loop-when-recur [(ß Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))] (ß r != EOF) [(ß r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))]
                                (ß consumeWhitespaces(pushbackReader))
                                (ß LINE_AFTER.set(pushbackReader.getLineNumber()))
                                (ß COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                                (ß ret = eval(r, false))
                                (ß LINE_BEFORE.set(pushbackReader.getLineNumber()))
                                (ß COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
                            )
                            (catch (ß LispReader.ReaderException) e
                                (throw (ß new CompilerException(sourcePath, e.line, e.column, e.getCause())))
                            )
                            (catch Throwable e
                                (if (ß !(e instanceof CompilerException))
                                    (do
                                        (throw (ß new CompilerException(sourcePath, (Integer) LINE_BEFORE.deref(), (Integer) COLUMN_BEFORE.deref(), e)))
                                    )
                                    (do
                                        (throw (ß (CompilerException) e))
                                    )
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                        ret
                    )
                )
            )
        )
    )

    (§ defn void writeClassFile(String internalName, byte[] bytecode) (§ throws IOException)
        (let [#_"String" genPath (ß (String) COMPILE_PATH.deref())]
            (when (ß genPath == nil)
                (throw (ß Util.runtimeException("*compile-path* not set")))
            )
            (let [#_"String[]" dirs (ß internalName.split("/"))]
                (let [#_"String" p genPath]
                    (loop-when-recur [(ß int i = 0)] (ß i < dirs.length - 1) [(ß i++)]
                        (ß p += File.separator + dirs[i])
                        (ß (new File(p)).mkdir())
                    )
                    (let [#_"String" path (ß genPath + File.separator + internalName + ".class")]
                        (let [#_"File" cf (ß new File(path))]
                            (ß cf.createNewFile())
                            (let [#_"FileOutputStream" cfs (ß new FileOutputStream(cf))]
                                (try
                                    (ß cfs.write(bytecode))
                                    (ß cfs.flush())
                                    (finally
                                        (ß cfs.close())
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn void pushNS()
        (ß Var.pushThreadBindings(PersistentHashMap.create(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil)))
        nil
    )

    (§ defn void pushNSandLoader(ClassLoader loader)
        (ß Var.pushThreadBindings(RT.map(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil, RT.FN_LOADER_VAR, loader, RT.READEVAL, RT.T)))
        nil
    )

    (§ defn ILookupThunk getLookupThunk(Object target, Keyword k)
        nil
    )

    (§ defn void compile1(GeneratorAdapter gen, ObjExpr objx, Object form)
        (let [#_"Object" line (ß lineDeref())]
            (let [#_"Object" column (ß columnDeref())]
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
                    (ß line = RT.meta(form).valAt(RT.LINE_KEY))
                )
                (when (ß RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
                    (ß column = RT.meta(form).valAt(RT.COLUMN_KEY))
                )
                (ß Var.pushThreadBindings(RT.map(
                    #_map LINE, line, COLUMN, column,
                    #_map LOADER, RT.makeClassLoader()
                )))
                (try
                    (ß form = macroexpand(form))
                    (if (ß form instanceof ISeq && Util.equals(RT.first(form), DO))
                        (do
                            (loop-when-recur [(ß ISeq s = RT.next(form))] (ß s != nil) [(ß s = RT.next(s))]
                                (ß compile1(gen, objx, RT.first(s)))
                            )
                        )
                        (do
                            (let [#_"Expr" expr (ß analyze(C.EVAL, form))]
                                (ß objx.keywords = (IPersistentMap) KEYWORDS.deref())
                                (ß objx.vars = (IPersistentMap) VARS.deref())
                                (ß objx.constants = (PersistentVector) CONSTANTS.deref())
                                (ß expr.emit(C.EXPRESSION, objx, gen))
                                (ß expr.eval())
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
                nil
            )
        )
    )

    (§ defn Object compile(Reader rdr, String sourcePath, String sourceName) (§ throws IOException)
        (when (ß COMPILE_PATH.deref() == nil)
            (throw (ß Util.runtimeException("*compile-path* not set")))
        )

        (let [(ß Object EOF = new Object())]
            (let [#_"Object" ret nil]
                (let [#_"LineNumberingPushbackReader" pushbackReader (ß (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr))]
                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                        #_map SOURCE_PATH, sourcePath,
                        #_map SOURCE, sourceName,
                        #_map METHOD, nil,
                        #_map LOCAL_ENV, nil,
                        #_map LOOP_LOCALS, nil,
                        #_map NEXT_LOCAL_NUM, 0,
                        #_map RT.READEVAL, RT.T,
                        #_map RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                        #_map LINE_BEFORE, pushbackReader.getLineNumber(),
                        #_map COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                        #_map LINE_AFTER, pushbackReader.getLineNumber(),
                        #_map COLUMN_AFTER, pushbackReader.getColumnNumber(),
                        #_map CONSTANTS, PersistentVector.EMPTY,
                        #_map CONSTANT_IDS, new IdentityHashMap(),
                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                        #_map VARS, PersistentHashMap.EMPTY,
                        #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                        #_map RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                        #_map RT.DATA_READERS, RT.DATA_READERS.deref()
                    )))

                    (try
                        ;; generate loader class
                        (let [#_"ObjExpr" objx (ß new ObjExpr(nil))]
                            (ß objx.internalName = sourcePath.replace(File.separator, "/").substring(0, sourcePath.lastIndexOf(\.)) + RT.LOADER_SUFFIX)

                            (ß objx.objtype = Type.getObjectType(objx.internalName))
                            (let [#_"ClassWriter" cw (ß new ClassWriter(ClassWriter.COMPUTE_MAXS))]
                                (let [#_"ClassVisitor" cv cw]
                                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, objx.internalName, nil, "java/lang/Object", nil))

                                    ;; static load method
                                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void load ()"), nil, nil, cv))]
                                        (ß gen.visitCode())

                                        (let [#_"Object" readerOpts (ß readerOpts(sourceName))]
                                            (loop-when-recur [(ß Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))] (ß r != EOF) [(ß r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))]
                                                (ß LINE_AFTER.set(pushbackReader.getLineNumber()))
                                                (ß COLUMN_AFTER.set(pushbackReader.getColumnNumber()))
                                                (ß compile1(gen, objx, r))
                                                (ß LINE_BEFORE.set(pushbackReader.getLineNumber()))
                                                (ß COLUMN_BEFORE.set(pushbackReader.getColumnNumber()))
                                            )
                                            ;; end of load
                                            (ß gen.returnValue())
                                            (ß gen.endMethod())

                                            ;; static fields for constants
                                            (loop-when-recur [(ß int i = 0)] (ß i < objx.constants.count()) [(ß i++)]
                                                (when (ß objx.usedConstants.contains(i))
                                                    (ß cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, objx.constantName(i), objx.constantType(i).getDescriptor(), nil, nil))
                                                )
                                            )

                                            (let [(ß int INITS_PER = 100)]
                                                (let [#_"int" numInits (ß  objx.constants.count() / INITS_PER)]
                                                    (when (ß objx.constants.count() % INITS_PER != 0)
                                                        (ß ++numInits)
                                                    )

                                                    (loop-when-recur [(ß int n = 0)] (ß n < numInits) [(ß n++)]
                                                        (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void __init" + n + "()"), nil, nil, cv))]
                                                            (ß clinitgen.visitCode())
                                                            (try
                                                                (ß Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T)))

                                                                (loop-when-recur [(ß int i = n * INITS_PER)] (ß i < objx.constants.count() && i < (n + 1) * INITS_PER) [(ß i++)]
                                                                    (when (ß objx.usedConstants.contains(i))
                                                                        (ß objx.emitValue(objx.constants.nth(i), clinitgen))
                                                                        (ß clinitgen.checkCast(objx.constantType(i)))
                                                                        (ß clinitgen.putStatic(objx.objtype, objx.constantName(i), objx.constantType(i)))
                                                                    )
                                                                )
                                                                (finally
                                                                    (ß Var.popThreadBindings())
                                                                )
                                                            )
                                                            (ß clinitgen.returnValue())
                                                            (ß clinitgen.endMethod())
                                                        )
                                                    )

                                                    ;; static init for constants, keywords and vars
                                                    (let [#_"GeneratorAdapter" clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv))]
                                                        (ß clinitgen.visitCode())
                                                        (let [#_"Label" startTry (ß clinitgen.newLabel())]
                                                            (let [#_"Label" endTry (ß clinitgen.newLabel())]
                                                                (let [#_"Label" end (ß clinitgen.newLabel())]
                                                                    (let [#_"Label" finallyLabel (ß clinitgen.newLabel())]
                                                                        (loop-when-recur [(ß int n = 0)] (ß n < numInits) [(ß n++)]
                                                                            (ß clinitgen.invokeStatic(objx.objtype, Method.getMethod("void __init" + n + "()")))
                                                                        )

                                                                        (ß clinitgen.push(objx.internalName.replace(\/, \.)))
                                                                        (ß clinitgen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)")))
                                                                        (ß clinitgen.invokeVirtual(CLASS_TYPE, Method.getMethod("ClassLoader getClassLoader()")))
                                                                        (ß clinitgen.invokeStatic(Type.getType(Compiler.class), Method.getMethod("void pushNSandLoader(ClassLoader)")))
                                                                        (ß clinitgen.mark(startTry))
                                                                        (ß clinitgen.invokeStatic(objx.objtype, Method.getMethod("void load()")))
                                                                        (ß clinitgen.mark(endTry))
                                                                        (ß clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
                                                                        (ß clinitgen.goTo(end))

                                                                        (ß clinitgen.mark(finallyLabel))
                                                                        ;; exception should be on stack
                                                                        (ß clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()")))
                                                                        (ß clinitgen.throwException())
                                                                        (ß clinitgen.mark(end))
                                                                        (ß clinitgen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil))

                                                                        ;; end of static init
                                                                        (ß clinitgen.returnValue())
                                                                        (ß clinitgen.endMethod())

                                                                        ;; end of class
                                                                        (ß cv.visitEnd())

                                                                        (ß writeClassFile(objx.internalName, cw.toByteArray()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (catch (ß LispReader.ReaderException) e
                            (throw (ß new CompilerException(sourcePath, e.line, e.column, e.getCause())))
                        )
                        (finally
                            (ß Var.popThreadBindings())
                        )
                    )
                    ret
                )
            )
        )
    )

    (class-ns NewInstanceExpr (§ extends ObjExpr)
        (§ field IPersistentCollection methods)

        (§ field Map<IPersistentVector, java.lang.reflect.Method> mmap)
        (§ field Map<IPersistentVector, Set<Class>> covariants)

        (§ constructor NewInstanceExpr(Object tag)
            (§ super(tag))
            this
        )

        (class-ns DeftypeParser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                (let [#_"ISeq" rform (ß (ISeq) frm)]
                    ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
                    (ß rform = RT.next(rform))
                    (let [#_"String" tagname (ß ((Symbol) rform.first()).getName())]
                        (ß rform = rform.next())
                        (let [#_"Symbol" classname (ß (Symbol) rform.first())]
                            (ß rform = rform.next())
                            (let [#_"IPersistentVector" fields (ß (IPersistentVector) rform.first())]
                                (ß rform = rform.next())
                                (let [#_"IPersistentMap" opts (ß PersistentHashMap.EMPTY)]
                                    (while (ß rform != nil && rform.first() instanceof Keyword)
                                        (ß opts = opts.assoc(rform.first(), RT.second(rform)))
                                        (ß rform = rform.next().next())
                                    )

                                    (let [#_"ObjExpr" ret (ß build((IPersistentVector)RT.get(opts, implementsKey, PersistentVector.EMPTY), fields, nil, tagname, classname, (Symbol) RT.get(opts, RT.TAG_KEY), rform, frm, opts))]
                                        ret
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (class-ns ReifyParser (§ implements IParser)
            (§ method Expr parse(C context, Object frm)
                ;; (reify this-name? [interfaces] (method-name [args] body)*)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (let [#_"ObjMethod" enclosingMethod (ß (ObjMethod) METHOD.deref())]
                        (let [#_"String" basename (ß (enclosingMethod != nil) ? (trimGenID(enclosingMethod.objx.name) + "$") :or (munge(currentNS().name.name) + "$"))]
                            (let [#_"String" simpleName (ß "reify__" + RT.nextID())]
                                (let [#_"String" classname (ß basename + simpleName)]
                                    (let [#_"ISeq" rform (ß RT.next(form))]
                                        (let [#_"IPersistentVector" interfaces (ß ((IPersistentVector) RT.first(rform)).cons(Symbol.intern("cloiure.lang.IObj")))]
                                            (ß rform = RT.next(rform))

                                            (let [#_"ObjExpr" ret (ß build(interfaces, nil, nil, classname, Symbol.intern(classname), nil, rform, frm, nil))]
                                                (if (ß frm instanceof IObj && ((IObj) frm).meta() != nil)
                                                    (do
                                                        (ß new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) frm).meta())))
                                                    )
                                                    (do
                                                        ret
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn ObjExpr build(IPersistentVector interfaceSyms, IPersistentVector fieldSyms, Symbol thisSym, String tagName, Symbol className, Symbol typeTag, ISeq methodForms, Object frm, IPersistentMap opts)
            (let [#_"NewInstanceExpr" ret (ß new NewInstanceExpr(nil))]
                (ß ret.src = frm)
                (ß ret.name = className.toString())
                (ß ret.classMeta = RT.meta(className))
                (ß ret.internalName = ret.name.replace(\., \/))
                (ß ret.objtype = Type.getObjectType(ret.internalName))
                (ß ret.opts = opts)

                (when (ß thisSym != nil)
                    (ß ret.thisName = thisSym.name)
                )

                (when (ß fieldSyms != nil)
                    (let [#_"IPersistentMap" fmap (ß PersistentHashMap.EMPTY)]
                        (let [#_"Object[]" closesvec (ß new Object[2 * fieldSyms.count()])]
                            (loop-when-recur [(ß int i = 0)] (ß i < fieldSyms.count()) [(ß i++)]
                                (let [#_"Symbol" sym (ß (Symbol) fieldSyms.nth(i))]
                                    (let [#_"LocalBinding" lb (ß new LocalBinding(-1, sym, nil, new MethodParamExpr(tagClass(tagOf(sym))), false, nil))]
                                        (ß fmap = fmap.assoc(sym, lb))
                                        (ß closesvec[i * 2] = lb)
                                        (ß closesvec[i * 2 + 1] = lb)
                                    )
                                )
                            )

                            ;; todo - inject __meta et al into closes - when?
                            ;; use array map to preserve ctor order
                            (ß ret.closes = new PersistentArrayMap(closesvec))
                            (ß ret.fields = fmap)
                            (loop-when-recur [(ß int i = fieldSyms.count() - 1)] (ß i >= 0 && (((Symbol)fieldSyms.nth(i)).name.equals("__meta") || ((Symbol)fieldSyms.nth(i)).name.equals("__extmap") || ((Symbol)fieldSyms.nth(i)).name.equals("__hash") || ((Symbol)fieldSyms.nth(i)).name.equals("__hasheq"))) [(ß --i)]
                                (ß ret.altCtorDrops++)
                            )
                        )
                    )
                )

                (let [#_"PersistentVector" interfaces (ß PersistentVector.EMPTY)]
                    (loop-when-recur [(ß ISeq s = RT.seq(interfaceSyms))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"Class" c (ß (Class) resolve((Symbol) s.first()))]
                            (when (ß !c.isInterface())
                                (throw (ß new IllegalArgumentException("only interfaces are supported, had: " + c.getName())))
                            )
                            (ß interfaces = interfaces.cons(c))
                        )
                    )
                    (let [#_"Class" superClass (ß Object.class)]
                        (let [#_"Map[]" mc (ß gatherMethods(superClass, RT.seq(interfaces)))]
                            (let [#_"Map" overrideables (ß mc[0])]
                                (let [#_"Map" covariants (ß mc[1])]
                                    (ß ret.mmap = overrideables)
                                    (ß ret.covariants = covariants)

                                    (let [#_"String[]" inames (ß interfaceNames(interfaces))]
                                        (let [#_"Class" stub (ß compileStub(slashname(superClass), ret, inames, frm))]
                                            (let [#_"Symbol" thistag (ß Symbol.intern(nil, stub.getName()))]
                                                (try
                                                    (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                        #_map CONSTANTS, PersistentVector.EMPTY,
                                                        #_map CONSTANT_IDS, new IdentityHashMap(),
                                                        #_map KEYWORDS, PersistentHashMap.EMPTY,
                                                        #_map VARS, PersistentHashMap.EMPTY,
                                                        #_map KEYWORD_CALLSITES, PersistentVector.EMPTY,
                                                        #_map PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                                                        #_map VAR_CALLSITES, emptyVarCallSites(),
                                                        #_map NO_RECUR, nil
                                                    )))
                                                    (when (ß ret.isDeftype())
                                                        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                            #_map METHOD, nil,
                                                            #_map LOCAL_ENV, ret.fields,
                                                            #_map COMPILE_STUB_SYM, Symbol.intern(nil, tagName),
                                                            #_map COMPILE_STUB_CLASS, stub
                                                        )))

                                                        (ß ret.hintedFields = RT.subvec(fieldSyms, 0, fieldSyms.count() - ret.altCtorDrops))
                                                    )

                                                    ;; now (methodname [args] body)*
                                                    (ß ret.line = lineDeref())
                                                    (ß ret.column = columnDeref())
                                                    (let [#_"IPersistentCollection" methods nil]
                                                        (loop-when-recur [(ß ISeq s = methodForms)] (ß s != nil) [(ß s = RT.next(s))]
                                                            (let [#_"NewInstanceMethod" m (ß NewInstanceMethod.parse(ret, (ISeq) RT.first(s), thistag, overrideables))]
                                                                (ß methods = RT.conj(methods, m))
                                                            )
                                                        )

                                                        (ß ret.methods = methods)
                                                        (ß ret.keywords = (IPersistentMap) KEYWORDS.deref())
                                                        (ß ret.vars = (IPersistentMap) VARS.deref())
                                                        (ß ret.constants = (PersistentVector) CONSTANTS.deref())
                                                        (ß ret.constantsID = RT.nextID())
                                                        (ß ret.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref())
                                                        (ß ret.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref())
                                                        (ß ret.varCallsites = (IPersistentSet) VAR_CALLSITES.deref())
                                                    )
                                                    (finally
                                                        (when (ß ret.isDeftype())
                                                            (ß Var.popThreadBindings())
                                                        )
                                                        (ß Var.popThreadBindings())
                                                    )
                                                )

                                                (try
                                                    (ß ret.compile(slashname(superClass), inames, false))
                                                    (catch IOException e
                                                        (throw (ß Util.sneakyThrow(e)))
                                                    )
                                                )
                                                (ß ret.getCompiledClass())
                                                ret
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        ;;;
         ; Current host interop uses reflection, which requires pre-existing classes
         ; Work around this by:
         ; Generate a stub class that has the same interfaces and fields as the class we are generating.
         ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
         ; Unmunge the name (using a magic prefix) on any code gen for classes
         ;;
        (§ defn Class compileStub(String superName, NewInstanceExpr ret, String[] interfaceNames, Object frm)
            (let [#_"ClassWriter" cw (ß new ClassWriter(ClassWriter.COMPUTE_MAXS))]
                (let [#_"ClassVisitor" cv cw]
                    (ß cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, COMPILE_STUB_PREFIX + "/" + ret.internalName, nil, superName, interfaceNames))

                    ;; instance fields for closed-overs
                    (loop-when-recur [(ß ISeq s = RT.keys(ret.closes))] (ß s != nil) [(ß s = s.next())]
                        (let [#_"LocalBinding" lb (ß (LocalBinding) s.first())]
                            (let [#_"int" access (ß ACC_PUBLIC + (ret.isVolatile(lb) ? ACC_VOLATILE :or ret.isMutable(lb) ? 0 :or ACC_FINAL))]
                                (if (ß lb.getPrimitiveType() != nil)
                                    (do
                                        (ß cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                    )
                                    (do
                                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                        (ß cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                    )
                                )
                            )
                        )
                    )

                    ;; ctor that takes closed-overs and does nothing
                    (let [#_"Method" m (ß new Method("<init>", Type.VOID_TYPE, ret.ctorTypes()))]
                        (let [#_"GeneratorAdapter" ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv))]
                            (ß ctorgen.visitCode())
                            (ß ctorgen.loadThis())
                            (ß ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor))
                            (ß ctorgen.returnValue())
                            (ß ctorgen.endMethod())

                            (when (ß ret.altCtorDrops > 0)
                                (let [#_"Type[]" ctorTypes (ß ret.ctorTypes())]
                                    (let [#_"Type[]" altCtorTypes (ß new Type[ctorTypes.length-ret.altCtorDrops])]
                                        (loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                                            (ß altCtorTypes[i] = ctorTypes[i])
                                        )
                                        (let [#_"Method" alt (ß new Method("<init>", Type.VOID_TYPE, altCtorTypes))]
                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                            (ß ctorgen.visitCode())
                                            (ß ctorgen.loadThis())
                                            (ß ctorgen.loadArgs())

                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __meta
                                            (ß ctorgen.visitInsn(Opcodes.ACONST_NULL)) ;; __extmap
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                            (ß ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                            (ß ctorgen.returnValue())
                                            (ß ctorgen.endMethod())

                                            ;; alt ctor no __hash, __hasheq
                                            (ß altCtorTypes = new Type[ctorTypes.length-2])
                                            (loop-when-recur [(ß int i = 0)] (ß i < altCtorTypes.length) [(ß i++)]
                                                (ß altCtorTypes[i] = ctorTypes[i])
                                            )

                                            (ß alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes))
                                            (ß ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv))
                                            (ß ctorgen.visitCode())
                                            (ß ctorgen.loadThis())
                                            (ß ctorgen.loadArgs())

                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hash
                                            (ß ctorgen.visitInsn(Opcodes.ICONST_0)) ;; __hasheq

                                            (ß ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes)))

                                            (ß ctorgen.returnValue())
                                            (ß ctorgen.endMethod())
                                        )
                                    )
                                )
                            )
                            ;; end of class
                            (ß cv.visitEnd())

                            (let [#_"byte[]" bytecode (ß cw.toByteArray())]
                                (let [#_"DynamicClassLoader" loader (ß (DynamicClassLoader) LOADER.deref())]
                                    (ß loader.defineClass(COMPILE_STUB_PREFIX + "." + ret.name, bytecode, frm))
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn String[] interfaceNames(IPersistentVector interfaces)
            (let [#_"int" icnt (ß interfaces.count())]
                (let [#_"String[]" inames (ß (icnt > 0) ? new String[icnt] :or nil)]
                    (loop-when-recur [(ß int i = 0)] (ß i < icnt) [(ß i++)]
                        (ß inames[i] = slashname((Class) interfaces.nth(i)))
                    )
                    inames
                )
            )
        )

        (§ defn String slashname(Class c)
            (ß c.getName().replace(\., \/))
        )

        #_protected
        (§ method void emitStatics(ClassVisitor cv)
            (when (ß this.isDeftype())
                ;; getBasis()
                (let [#_"Method" meth (ß Method.getMethod("cloiure.lang.IPersistentVector getBasis()"))]
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, meth, nil, nil, cv))]
                        (ß emitValue(hintedFields, gen))
                        (ß gen.returnValue())
                        (ß gen.endMethod())

                        (when (ß this.isDeftype() && this.fields.count() > this.hintedFields.count())
                            ;; create(IPersistentMap)
                            (let [#_"String" className (ß name.replace(\., \/))]
                                (let [#_"int" i 1]
                                    (let [#_"int" fieldCount (ß hintedFields.count())]
                                        (let [#_"MethodVisitor" mv (ß cv.visitMethod(ACC_PUBLIC + ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + className + ";", nil, nil))]
                                            (ß mv.visitCode())

                                            (loop-when-recur [(ß ISeq s = RT.seq(hintedFields))] (ß s != nil) [(ß s = s.next(), i++)]
                                                (let [#_"String" bName (ß ((Symbol)s.first()).name)]
                                                    (let [#_"Class" k (ß tagClass(tagOf(s.first())))]
                                                        (ß mv.visitVarInsn(ALOAD, 0))
                                                        (ß mv.visitLdcInsn(bName))
                                                        (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                        (ß mv.visitInsn(ACONST_NULL))
                                                        (ß mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"))
                                                        (when (ß k.isPrimitive())
                                                            (ß mv.visitTypeInsn(CHECKCAST, Type.getType(boxClass(k)).getInternalName()))
                                                        )
                                                        (ß mv.visitVarInsn(ASTORE, i))
                                                        (ß mv.visitVarInsn(ALOAD, 0))
                                                        (ß mv.visitLdcInsn(bName))
                                                        (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                        (ß mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;"))
                                                        (ß mv.visitVarInsn(ASTORE, 0))
                                                    )
                                                )
                                            )

                                            (ß mv.visitTypeInsn(Opcodes.NEW, className))
                                            (ß mv.visitInsn(DUP))

                                            (let [#_"Method" ctor (ß new Method("<init>", Type.VOID_TYPE, ctorTypes()))]
                                                (when (ß hintedFields.count() > 0)
                                                    (loop-when-recur [(ß i = 1)] (ß i <= fieldCount) [(ß i++)]
                                                        (ß mv.visitVarInsn(ALOAD, i))
                                                        (let [#_"Class" k (ß tagClass(tagOf(hintedFields.nth(i - 1))))]
                                                            (when (ß k.isPrimitive())
                                                                (let [#_"String" b (ß Type.getType(boxClass(k)).getInternalName())]
                                                                    (let [#_"String" p (ß Type.getType(k).getDescriptor())]
                                                                        (let [#_"String" n (ß k.getName())]
                                                                            (ß mv.visitMethodInsn(INVOKEVIRTUAL, b, n+"Value", "()" + p))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )

                                                (ß mv.visitInsn(ACONST_NULL)) ;; __meta
                                                (ß mv.visitVarInsn(ALOAD, 0)) ;; __extmap
                                                (ß mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;"))
                                                (ß mv.visitInsn(ICONST_0)) ;; __hash
                                                (ß mv.visitInsn(ICONST_0)) ;; __hasheq
                                                (ß mv.visitMethodInsn(INVOKESPECIAL, className, "<init>", ctor.getDescriptor()))
                                                (ß mv.visitInsn(ARETURN))
                                                (ß mv.visitMaxs(4 + fieldCount, 1 + fieldCount))
                                                (ß mv.visitEnd())
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        #_protected
        (§ method void emitMethods(ClassVisitor cv)
            (loop-when-recur [(ß ISeq s = RT.seq(methods))] (ß s != nil) [(ß s = s.next())]
                (let [#_"ObjMethod" method (ß (ObjMethod) s.first())]
                    (ß method.emit(this, cv))
                )
            )
            ;; emit bridge methods
            (doseq [#_"Map.Entry<IPersistentVector, Set<Class>>" (ß e covariants.entrySet())]
                (let [(ß java.lang.reflect.Method m = mmap.get(e.getKey()))]
                    (let [#_"Class[]" params (ß m.getParameterTypes())]
                        (let [#_"Type[]" argTypes (ß new Type[params.length])]
                            (loop-when-recur [(ß int i = 0)] (ß i < params.length) [(ß i++)]
                                (ß argTypes[i] = Type.getType(params[i]))
                            )

                            (let [#_"Method" target (ß new Method(m.getName(), Type.getType(m.getReturnType()), argTypes))]
                                (doseq [#_"Class" retType (ß e.getValue())]
                                    (let [#_"Method" meth (ß new Method(m.getName(), Type.getType(retType), argTypes))]
                                        ;; todo don't hardwire EXCEPTION_TYPES
                                        (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE, meth, nil, EXCEPTION_TYPES, cv))]
                                            (ß gen.visitCode())
                                            (ß gen.loadThis())
                                            (ß gen.loadArgs())
                                            (ß gen.invokeInterface(Type.getType(m.getDeclaringClass()), target))
                                            (ß gen.returnValue())
                                            (ß gen.endMethod())
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ defn IPersistentVector msig(java.lang.reflect.Method m)
            (ß RT.vector(m.getName(), RT.seq(m.getParameterTypes()), m.getReturnType()))
        )

        (§ defn void considerMethod(java.lang.reflect.Method m, Map mm)
            (let [#_"IPersistentVector" mk (ß msig(m))]
                (let [#_"int" mods (ß m.getModifiers())]
                    (when (ß !(mm.containsKey(mk) || !(Modifier.isPublic(mods) || Modifier.isProtected(mods)) || Modifier.isStatic(mods) || Modifier.isFinal(mods)))
                        (ß mm.put(mk, m))
                    )
                    nil
                )
            )
        )

        (§ defn void gatherMethods(Class c, Map mm)
            (loop-when-recur [(ß )] (ß c != nil) [(ß c = c.getSuperclass())]
                (doseq [#_"java.lang.reflect.Method" m (ß c.getDeclaredMethods())]
                    (ß considerMethod(m, mm))
                )
                (doseq [#_"java.lang.reflect.Method" m (ß c.getMethods())]
                    (ß considerMethod(m, mm))
                )
            )
            nil
        )

        (§ defn Map[] gatherMethods(Class sc, ISeq interfaces)
            (let [#_"Map" allm (ß new HashMap())]
                (ß gatherMethods(sc, allm))
                (loop-when-recur [(ß )] (ß interfaces != nil) [(ß interfaces = interfaces.next())]
                    (ß gatherMethods((Class) interfaces.first(), allm))
                )

                (let [(ß Map<IPersistentVector, java.lang.reflect.Method> mm = new HashMap<IPersistentVector, java.lang.reflect.Method>())]
                    (let [(ß Map<IPersistentVector, Set<Class>> covariants = new HashMap<IPersistentVector, Set<Class>>())]
                        (doseq [#_"Object" o (ß allm.entrySet())]
                            (let [(ß Map.Entry e = (Map.Entry) o)]
                                (let [#_"IPersistentVector" mk (ß (IPersistentVector) e.getKey())]
                                    (ß mk = (IPersistentVector) mk.pop())
                                    (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())]
                                        (if (ß mm.containsKey(mk)) ;; covariant return
                                            (do
                                                (let [#_"Set<Class>" cvs (ß covariants.get(mk))]
                                                    (when (ß cvs == nil)
                                                        (ß cvs = new HashSet<Class>())
                                                        (ß covariants.put(mk, cvs))
                                                    )
                                                    (let [(ß java.lang.reflect.Method om = mm.get(mk))]
                                                        (if (ß om.getReturnType().isAssignableFrom(m.getReturnType()))
                                                            (do
                                                                (ß cvs.add(om.getReturnType()))
                                                                (ß mm.put(mk, m))
                                                            )
                                                            (do
                                                                (ß cvs.add(m.getReturnType()))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (do
                                                (ß mm.put(mk, m))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß new Map[] (§ mm, covariants ))
                    )
                )
            )
        )
    )

    (class-ns NewInstanceMethod (§ extends ObjMethod)
        (§ field String name)
        (§ field Type[] argTypes)
        (§ field Type retType)
        (§ field Class retClass)
        (§ field Class[] exclasses)

        (§ def Symbol dummyThis = Symbol.intern(nil, "dummy_this_dlskjsdfower"))
        (§ field- IPersistentVector parms)

        (§ constructor NewInstanceMethod(ObjExpr objx, ObjMethod parent)
            (§ super(objx, parent))
            this
        )

        (§ method int numParams()
            (ß argLocals.count())
        )

        (§ method String getMethodName()
            name
        )

        (§ method Type getReturnType()
            retType
        )

        (§ method Type[] getArgTypes()
            argTypes
        )

        (§ defn IPersistentVector msig(String name, Class[] paramTypes)
            (ß RT.vector(name, RT.seq(paramTypes)))
        )

        (§ defn NewInstanceMethod parse(ObjExpr objx, ISeq form, Symbol thistag, Map overrideables)
            ;; (methodname [this-name args*] body...)
            ;; this-name might be nil
            (let [#_"NewInstanceMethod" method (ß new NewInstanceMethod(objx, (ObjMethod) METHOD.deref()))]
                (let [#_"Symbol" dotname (ß (Symbol)RT.first(form))]
                    (let [#_"Symbol" name (ß (Symbol) Symbol.intern(nil, munge(dotname.name)).withMeta(RT.meta(dotname)))]
                        (let [#_"IPersistentVector" parms (ß (IPersistentVector) RT.second(form))]
                            (when (ß parms.count() == 0)
                                (throw (ß new IllegalArgumentException("Must supply at least one argument for 'this' in: " + dotname)))
                            )
                            (let [#_"Symbol" thisName (ß (Symbol) parms.nth(0))]
                                (ß parms = RT.subvec(parms, 1, parms.count()))
                                (let [#_"ISeq" body (ß RT.next(RT.next(form)))]
                                    (try
                                        (ß method.line = lineDeref())
                                        (ß method.column = columnDeref())
                                        ;; register as the current method and set up a new env frame
                                        (let [#_"PathNode" pnode (ß  new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get()))]
                                            (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                                #_map METHOD, method,
                                                #_map LOCAL_ENV, LOCAL_ENV.deref(),
                                                #_map LOOP_LOCALS, nil,
                                                #_map NEXT_LOCAL_NUM, 0,
                                                #_map CLEAR_PATH, pnode,
                                                #_map CLEAR_ROOT, pnode,
                                                #_map CLEAR_SITES, PersistentHashMap.EMPTY,
                                                #_map METHOD_RETURN_CONTEXT, RT.T
                                            )))

                                            ;; register 'this' as local 0
                                            (if (ß thisName != nil)
                                                (do
                                                    (ß registerLocal((thisName == nil) ? dummyThis:thisName, thistag, nil, false))
                                                )
                                                (do
                                                    (ß getAndIncLocalNum())
                                                )
                                            )

                                            (let [#_"PersistentVector" argLocals (ß PersistentVector.EMPTY)]
                                                (ß method.retClass = tagClass(tagOf(name)))
                                                (ß method.argTypes = new Type[parms.count()])
                                                (let [#_"boolean" hinted (ß tagOf(name) != nil)]
                                                    (let [#_"Class[]" pclasses (ß new Class[parms.count()])]
                                                        (let [#_"Symbol[]" psyms (ß new Symbol[parms.count()])]
                                                            (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                                                                (when (ß !(parms.nth(i) instanceof Symbol))
                                                                    (throw (ß new IllegalArgumentException("params must be Symbols")))
                                                                )
                                                                (let [#_"Symbol" p (ß (Symbol) parms.nth(i))]
                                                                    (let [#_"Object" tag (ß tagOf(p))]
                                                                        (when (ß tag != nil)
                                                                            (ß hinted = true)
                                                                        )
                                                                        (when (ß p.getNamespace() != nil)
                                                                            (ß p = Symbol.intern(p.name))
                                                                        )
                                                                        (let [#_"Class" pclass (ß tagClass(tag))]
                                                                            (ß pclasses[i] = pclass)
                                                                            (ß psyms[i] = p)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (let [#_"Map" matches (ß findMethodsWithNameAndArity(name.name, parms.count(), overrideables))]
                                                                (let [#_"Object" mk (ß msig(name.name, pclasses))]
                                                                    (let [(ß java.lang.reflect.Method m = nil)]
                                                                        (if (ß matches.size() > 0)
                                                                            (do
                                                                                ;; multiple methods
                                                                                (cond (ß matches.size() > 1)
                                                                                    (do
                                                                                        ;; must be hinted and match one method
                                                                                        (when (ß !hinted)
                                                                                            (throw (ß new IllegalArgumentException("Must hint overloaded method: " + name.name)))
                                                                                        )
                                                                                        (ß m = (java.lang.reflect.Method) matches.get(mk))
                                                                                        (when (ß m == nil)
                                                                                            (throw (ß new IllegalArgumentException("Can't find matching overloaded method: " + name.name)))
                                                                                        )
                                                                                        (when (ß m.getReturnType() != method.retClass)
                                                                                            (throw (ß new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName())))
                                                                                        )
                                                                                    )
                                                                                    :else ;; one match
                                                                                    (do
                                                                                        ;; if hinted, validate match
                                                                                        (cond hinted
                                                                                            (do
                                                                                                (ß m = (java.lang.reflect.Method) matches.get(mk))
                                                                                                (when (ß m == nil)
                                                                                                    (throw (ß new IllegalArgumentException("Can't find matching method: " + name.name + ", leave off hints for auto match.")))
                                                                                                )
                                                                                                (when (ß m.getReturnType() != method.retClass)
                                                                                                    (throw (ß new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName())))
                                                                                                )
                                                                                            )
                                                                                            :else ;; adopt found method sig
                                                                                            (do
                                                                                                (ß m = (java.lang.reflect.Method) matches.values().iterator().next())
                                                                                                (ß method.retClass = m.getReturnType())
                                                                                                (ß pclasses = m.getParameterTypes())
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                            (do
                                                                                (throw (ß new IllegalArgumentException("Can't define method not in interfaces: " + name.name)))
                                                                            )
                                                                        )

                                                                        ;; validate unque name+arity among additional methods

                                                                        (ß method.retType = Type.getType(method.retClass))
                                                                        (ß method.exclasses = m.getExceptionTypes())

                                                                        (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                                                                            (let [#_"LocalBinding" lb (ß registerLocal(psyms[i], nil, new MethodParamExpr(pclasses[i]), true))]
                                                                                (ß argLocals = argLocals.assocN(i, lb))
                                                                                (ß method.argTypes[i] = Type.getType(pclasses[i]))
                                                                            )
                                                                        )
                                                                        (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                                                                            (when (ß pclasses[i] == long.class || pclasses[i] == double.class)
                                                                                (ß getAndIncLocalNum())
                                                                            )
                                                                        )
                                                                        (ß LOOP_LOCALS.set(argLocals))
                                                                        (ß method.name = name.name)
                                                                        (ß method.methodMeta = RT.meta(name))
                                                                        (ß method.parms = parms)
                                                                        (ß method.argLocals = argLocals)
                                                                        (ß method.body = (new BodyExpr.Parser()).parse(C.RETURN, body))
                                                                        method
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (finally
                                            (ß Var.popThreadBindings())
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn- Map findMethodsWithNameAndArity(String name, int arity, Map mm)
            (let [#_"Map" ret (ß new HashMap())]
                (doseq [#_"Object" o (ß mm.entrySet())]
                    (let [(ß Map.Entry e = (Map.Entry) o)]
                        (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())]
                            (when (ß name.equals(m.getName()) && m.getParameterTypes().length == arity)
                                (ß ret.put(e.getKey(), e.getValue()))
                            )
                        )
                    )
                )
                ret
            )
        )

        (§ defn- Map findMethodsWithName(String name, Map mm)
            (let [#_"Map" ret (ß new HashMap())]
                (doseq [#_"Object" o (ß mm.entrySet())]
                    (let [(ß Map.Entry e = (Map.Entry) o)]
                        (let [(ß java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue())]
                            (when (ß name.equals(m.getName()))
                                (ß ret.put(e.getKey(), e.getValue()))
                            )
                        )
                    )
                )
                ret
            )
        )

        (§ method void emit(ObjExpr obj, ClassVisitor cv)
            (let [#_"Method" m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
                (let [#_"Type[]" extypes nil]
                    (when (ß exclasses.length > 0)
                        (ß extypes = new Type[exclasses.length])
                        (loop-when-recur [(ß int i = 0)] (ß i < exclasses.length) [(ß i++)]
                            (ß extypes[i] = Type.getType(exclasses[i]))
                        )
                    )
                    (let [#_"GeneratorAdapter" gen (ß new GeneratorAdapter(ACC_PUBLIC, m, nil, extypes, cv))]
                        (ß addAnnotation(gen, methodMeta))
                        (loop-when-recur [(ß int i = 0)] (ß i < parms.count()) [(ß i++)]
                            (let [#_"IPersistentMap" meta (ß RT.meta(parms.nth(i)))]
                                (ß addParameterAnnotation(gen, meta, i))
                            )
                        )
                        (ß gen.visitCode())

                        (let [#_"Label" loopLabel (ß gen.mark())]
                            (ß gen.visitLineNumber(line, loopLabel))
                            (try
                                (ß Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this)))

                                (ß emitBody(objx, gen, retClass, body))
                                (let [#_"Label" end (ß gen.mark())]
                                    (ß gen.visitLocalVariable("this", obj.objtype.getDescriptor(), nil, loopLabel, end, 0))
                                    (loop-when-recur [(ß ISeq lbs = argLocals.seq())] (ß lbs != nil) [(ß lbs = lbs.next())]
                                        (let [#_"LocalBinding" lb (ß (LocalBinding) lbs.first())]
                                            (ß gen.visitLocalVariable(lb.name, argTypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx))
                                        )
                                    )
                                )
                                (finally
                                    (ß Var.popThreadBindings())
                                )
                            )

                            (ß gen.returnValue())
                            (ß gen.endMethod())
                            nil
                        )
                    )
                )
            )
        )
    )

    (§ defn boolean inty(Class c)
        (ß (c == int.class || c == short.class || c == byte.class || c == char.class))
    )

    (§ defn Class retType(Class tc, Class ret)
        (when (ß tc == nil)
            (§ return ret)
        )
        (when (ß ret == nil)
            (§ return tc)
        )
        (when (ß ret.isPrimitive() && tc.isPrimitive())
            (when (ß (inty(ret) && inty(tc)) || (ret == tc))
                (§ return tc)
            )
            (throw (ß new UnsupportedOperationException("Cannot coerce " + ret + " to " + tc + ", use a cast instead")))
        )
        tc
    )

    (§ defn Class primClass(Symbol sym)
        (when (ß sym == nil)
            (§ return nil)
        )
        (let [#_"Class" c nil]
            (cond (ß sym.name.equals("int"))
                (do
                    (ß c = int.class)
                )
                (ß sym.name.equals("long"))
                (do
                    (ß c = long.class)
                )
                (ß sym.name.equals("float"))
                (do
                    (ß c = float.class)
                )
                (ß sym.name.equals("double"))
                (do
                    (ß c = double.class)
                )
                (ß sym.name.equals("char"))
                (do
                    (ß c = char.class)
                )
                (ß sym.name.equals("short"))
                (do
                    (ß c = short.class)
                )
                (ß sym.name.equals("byte"))
                (do
                    (ß c = byte.class)
                )
                (ß sym.name.equals("boolean"))
                (do
                    (ß c = boolean.class)
                )
                (ß sym.name.equals("void"))
                (do
                    (ß c = void.class)
                )
            )
            c
        )
    )

    (§ defn Class tagClass(Object tag)
        (when (ß tag == nil)
            (§ return (ß Object.class))
        )
        (let [#_"Class" c nil]
            (when (ß tag instanceof Symbol)
                (ß c = primClass((Symbol) tag))
            )
            (when (ß c == nil)
                (ß c = HostExpr.tagToClass(tag))
            )
            c
        )
    )

    (§ defn Class primClass(Class c)
        (ß c.isPrimitive() ? c :or Object.class)
    )

    (§ defn Class boxClass(Class p)
        (when (ß !p.isPrimitive())
            (§ return p)
        )

        (let [#_"Class" c nil]
            (cond (ß p == Integer.TYPE)
                (do
                    (ß c = Integer.class)
                )
                (ß p == Long.TYPE)
                (do
                    (ß c = Long.class)
                )
                (ß p == Float.TYPE)
                (do
                    (ß c = Float.class)
                )
                (ß p == Double.TYPE)
                (do
                    (ß c = Double.class)
                )
                (ß p == Character.TYPE)
                (do
                    (ß c = Character.class)
                )
                (ß p == Short.TYPE)
                (do
                    (ß c = Short.class)
                )
                (ß p == Byte.TYPE)
                (do
                    (ß c = Byte.class)
                )
                (ß p == Boolean.TYPE)
                (do
                    (ß c = Boolean.class)
                )
            )

            c
        )
    )

    (class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field Class c)

        (§ constructor MethodParamExpr(Class c)
            (ß this.c = c)
            this
        )

        (§ method Object eval()
            (throw (ß Util.runtimeException("Can't eval")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (throw (ß Util.runtimeException("Can't emit")))
        )

        (§ method boolean hasJavaClass()
            (ß (c != nil))
        )

        (§ method Class getJavaClass()
            c
        )

        (§ method boolean canEmitPrimitive()
            (ß Util.isPrimitive(c))
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (throw (ß Util.runtimeException("Can't emit")))
        )
    )

    (class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
        (§ field LocalBindingExpr expr)
        (§ field int shift, mask, low, high)
        (§ field Expr defaultExpr)
        (§ field SortedMap<Integer, Expr> tests)
        (§ field HashMap<Integer, Expr> thens)
        (§ field Keyword switchType)
        (§ field Keyword testType)
        (§ field Set<Integer> skipCheck)
        (§ field Class returnType)
        (§ field int line)
        (§ field int column)

        (§ def Type NUMBER_TYPE = Type.getType(Number.class))
        (§ def Method intValueMethod = Method.getMethod("int intValue()"))

        (§ def Method hashMethod = Method.getMethod("int hash(Object)"))
        (§ def Method hashCodeMethod = Method.getMethod("int hashCode()"))
        (§ def Method equivMethod = Method.getMethod("boolean equiv(Object, Object)"))
        (§ def Keyword compactKey = Keyword.intern(nil, "compact"))
        (§ def Keyword sparseKey = Keyword.intern(nil, "sparse"))
        (§ def Keyword hashIdentityKey = Keyword.intern(nil, "hash-identity"))
        (§ def Keyword hashEquivKey = Keyword.intern(nil, "hash-equiv"))
        (§ def Keyword intKey = Keyword.intern(nil, "int"))

        ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
        (§ constructor CaseExpr(int line, int column, LocalBindingExpr expr, int shift, int mask, int low, int high, Expr defaultExpr, SortedMap<Integer, Expr> tests, HashMap<Integer, Expr> thens, Keyword switchType, Keyword testType, Set<Integer> skipCheck)
            (ß this.expr = expr)
            (ß this.shift = shift)
            (ß this.mask = mask)
            (ß this.low = low)
            (ß this.high = high)
            (ß this.defaultExpr = defaultExpr)
            (ß this.tests = tests)
            (ß this.thens = thens)
            (ß this.line = line)
            (ß this.column = column)
            (when (ß switchType != compactKey && switchType != sparseKey)
                (throw (ß new IllegalArgumentException("Unexpected switch type: "+switchType)))
            )
            (ß this.switchType = switchType)
            (when (ß testType != intKey && testType != hashEquivKey && testType != hashIdentityKey)
                (throw (ß new IllegalArgumentException("Unexpected test type: "+switchType)))
            )
            (ß this.testType = testType)
            (ß this.skipCheck = skipCheck)
            (let [#_"Collection<Expr>" returns (ß new ArrayList(thens.values()))]
                (ß returns.add(defaultExpr))
                (ß this.returnType = maybeJavaClass(returns))
                (when (ß RT.count(skipCheck) > 0 && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (ß RT.errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", SOURCE_PATH.deref(), line, column))
                )
                this
            )
        )

        (§ method boolean hasJavaClass()
            (ß (returnType != nil))
        )

        (§ method boolean canEmitPrimitive()
            (ß Util.isPrimitive(returnType))
        )

        (§ method Class getJavaClass()
            returnType
        )

        (§ method Object eval()
            (throw (ß new UnsupportedOperationException("Can't eval case")))
        )

        (§ method void emit(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, false))
            nil
        )

        (§ method void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
            (ß doEmit(context, objx, gen, true))
            nil
        )

        (§ method void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
            (let [#_"Label" defaultLabel (ß gen.newLabel())]
                (let [#_"Label" endLabel (ß gen.newLabel())]
                    (let [(ß SortedMap<Integer, Label> labels = new TreeMap())]
                        (doseq [#_"Integer" i (ß tests.keySet())]
                            (ß labels.put(i, gen.newLabel()))
                        )

                        (ß gen.visitLineNumber(line, gen.mark()))

                        (let [#_"Class" primExprClass (ß maybePrimitiveType(expr))]
                            (let [#_"Type" primExprType (ß (primExprClass == nil) ? nil :or Type.getType(primExprClass))]
                                (if (ß testType == intKey)
                                    (do
                                        (ß emitExprForInts(objx, gen, primExprType, defaultLabel))
                                    )
                                    (do
                                        (ß emitExprForHashes(objx, gen))
                                    )
                                )

                                (if (ß switchType == sparseKey)
                                    (do
                                        (let [#_"Label[]" la (ß new Label[labels.size()])]
                                            (ß la = labels.values().toArray(la))
                                            (let [#_"int[]" ints (ß Numbers.int_array(tests.keySet()))]
                                                (ß gen.visitLookupSwitchInsn(defaultLabel, ints, la))
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Label[]" la (ß new Label[(high - low) + 1])]
                                            (loop-when-recur [(ß int i = low)] (ß i <= high) [(ß i++)]
                                                (ß la[i - low] = labels.containsKey(i) ? labels.get(i) :or defaultLabel)
                                            )
                                            (ß gen.visitTableSwitchInsn(low, high, defaultLabel, la))
                                        )
                                    )
                                )

                                (doseq [#_"Integer" i (ß labels.keySet())]
                                    (ß gen.mark(labels.get(i)))
                                    (cond (ß testType == intKey)
                                        (do
                                            (ß emitThenForInts(objx, gen, primExprType, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                                        )
                                        (ß RT.contains(skipCheck, i) == RT.T)
                                        (do
                                            (ß emitExpr(objx, gen, thens.get(i), emitUnboxed))
                                        )
                                        :else
                                        (do
                                            (ß emitThenForHashes(objx, gen, tests.get(i), thens.get(i), defaultLabel, emitUnboxed))
                                        )
                                    )
                                    (ß gen.goTo(endLabel))
                                )

                                (ß gen.mark(defaultLabel))
                                (ß emitExpr(objx, gen, defaultExpr, emitUnboxed))
                                (ß gen.mark(endLabel))
                                (when (ß context == C.STATEMENT)
                                    (ß gen.pop())
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )

        (§ method- boolean isShiftMasked()
            (ß (mask != 0))
        )

        (§ method- void emitShiftMask(GeneratorAdapter gen)
            (when (ß isShiftMasked())
                (ß gen.push(shift))
                (ß gen.visitInsn(ISHR))
                (ß gen.push(mask))
                (ß gen.visitInsn(IAND))
            )
            nil
        )

        (§ method- void emitExprForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Label defaultLabel)
            (cond (ß exprType == nil)
                (do
                    (when (ß RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                        (ß RT.errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", SOURCE_PATH.deref(), line, column))
                    )
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.instanceOf(NUMBER_TYPE))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß gen.checkCast(NUMBER_TYPE))
                    (ß gen.invokeVirtual(NUMBER_TYPE, intValueMethod))
                    (ß emitShiftMask(gen))
                )
                (ß exprType == Type.LONG_TYPE || exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
                (do
                    (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß gen.cast(exprType, Type.INT_TYPE))
                    (ß emitShiftMask(gen))
                )
                :else
                (do
                    (ß gen.goTo(defaultLabel))
                )
            )
            nil
        )

        (§ method- void emitThenForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
            (cond (ß exprType == nil)
                (do
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                    (ß test.emit(C.EXPRESSION, objx, gen))
                    (ß gen.invokeStatic(UTIL_TYPE, equivMethod))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                (ß exprType == Type.LONG_TYPE)
                (do
                    (ß ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                    (ß gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                (ß exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
                (do
                    (when (ß isShiftMasked())
                        (ß ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß expr.emitUnboxed(C.EXPRESSION, objx, gen))
                        (ß gen.cast(exprType, Type.LONG_TYPE))
                        (ß gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel))
                    )
                    ;; else direct match
                    (ß emitExpr(objx, gen, then, emitUnboxed))
                )
                :else
                (do
                    (ß gen.goTo(defaultLabel))
                )
            )
            nil
        )

        (§ method- void emitExprForHashes(ObjExpr objx, GeneratorAdapter gen)
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß gen.invokeStatic(UTIL_TYPE, hashMethod))
            (ß emitShiftMask(gen))
            nil
        )

        (§ method- void emitThenForHashes(ObjExpr objx, GeneratorAdapter gen, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
            (ß expr.emit(C.EXPRESSION, objx, gen))
            (ß test.emit(C.EXPRESSION, objx, gen))
            (if (ß testType == hashIdentityKey)
                (do
                    (ß gen.visitJumpInsn(IF_ACMPNE, defaultLabel))
                )
                (do
                    (ß gen.invokeStatic(UTIL_TYPE, equivMethod))
                    (ß gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel))
                )
            )
            (ß emitExpr(objx, gen, then, emitUnboxed))
            nil
        )

        (§ defn- void emitExpr(ObjExpr objx, GeneratorAdapter gen, Expr expr, boolean emitUnboxed)
            (if (ß emitUnboxed && expr instanceof MaybePrimitiveExpr)
                (do
                    (ß ((MaybePrimitiveExpr)expr).emitUnboxed(C.EXPRESSION, objx, gen))
                )
                (do
                    (ß expr.emit(C.EXPRESSION, objx, gen))
                )
            )
            nil
        )

        (class-ns Parser (§ implements IParser)
            ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
            ;; prepared by case macro and presumed correct
            ;; case macro binds actual expr in let so expr is always a local,
            ;; no need to worry about multiple evaluation
            (§ method Expr parse(C context, Object frm)
                (let [#_"ISeq" form (ß (ISeq) frm)]
                    (when (ß context == C.EVAL)
                        (§ return (ß analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                    )
                    (let [#_"IPersistentVector" args (ß LazilyPersistentVector.create(form.next()))]
                        (let [#_"Object" exprForm (ß args.nth(0))]
                            (let [#_"int" shift (ß ((Number)args.nth(1)).intValue())]
                                (let [#_"int" mask (ß ((Number)args.nth(2)).intValue())]
                                    (let [#_"Object" defaultForm (ß args.nth(3))]
                                        (let [#_"Map" caseMap (ß (Map)args.nth(4))]
                                            (let [#_"Keyword" switchType (ß ((Keyword)args.nth(5)))]
                                                (let [#_"Keyword" testType (ß ((Keyword)args.nth(6)))]
                                                    (let [#_"Set" skipCheck (ß (RT.count(args) < 8) ? nil :or (Set)args.nth(7))]
                                                        (let [#_"ISeq" keys (ß RT.keys(caseMap))]
                                                            (let [#_"int" low (ß ((Number)RT.first(keys)).intValue())]
                                                                (let [#_"int" high (ß ((Number)RT.nth(keys, RT.count(keys) - 1)).intValue())]
                                                                    (let [#_"LocalBindingExpr" testexpr (ß (LocalBindingExpr) analyze(C.EXPRESSION, exprForm))]
                                                                        (ß testexpr.shouldClear = false)

                                                                        (let [(ß SortedMap<Integer, Expr> tests = new TreeMap())]
                                                                            (let [(ß HashMap<Integer, Expr> thens = new HashMap())]
                                                                                (let [#_"PathNode" branch (ß new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get()))]
                                                                                    (doseq [#_"Object" o (ß caseMap.entrySet())]
                                                                                        (let [(ß Map.Entry e = (Map.Entry) o)]
                                                                                            (let [#_"Integer" minhash (ß ((Number)e.getKey()).intValue())]
                                                                                                (let [#_"Object" pair (ß e.getValue())] ;; [test-val then-expr]
                                                                                                    (let [#_"Expr" testExpr (ß (testType == intKey) ? NumberExpr.parse(((Number)RT.first(pair)).intValue()) :or new ConstantExpr(RT.first(pair)))]
                                                                                                        (ß tests.put(minhash, testExpr))

                                                                                                        (§ let [#_"Expr" thenExpr]
                                                                                                            (try
                                                                                                                (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                                                                                                (ß thenExpr = analyze(context, RT.second(pair)))
                                                                                                                (finally
                                                                                                                    (ß Var.popThreadBindings())
                                                                                                                )
                                                                                                            )
                                                                                                            (ß thens.put(minhash, thenExpr))
                                                                                                        )
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )

                                                                                    (§ let [#_"Expr" defaultExpr]
                                                                                        (try
                                                                                            (ß Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch))))
                                                                                            (ß defaultExpr = analyze(context, args.nth(3)))
                                                                                            (finally
                                                                                                (ß Var.popThreadBindings())
                                                                                            )
                                                                                        )

                                                                                        (let [#_"int" line (ß ((Number)LINE.deref()).intValue())]
                                                                                            (let [#_"int" column (ß ((Number)COLUMN.deref()).intValue())]
                                                                                                (ß new CaseExpr(line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck))
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn IPersistentCollection emptyVarCallSites()
        (ß PersistentHashSet.EMPTY)
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (§ field- Object _first)
    (§ field- ISeq _more)

    (§ constructor Cons(Object first, ISeq _more)
        (ß this._first = first)
        (ß this._more = _more)
        this
    )

    (§ constructor Cons(IPersistentMap meta, Object _first, ISeq _more)
        (§ super(meta))
        (ß this._first = _first)
        (ß this._more = _more)
        this
    )

    (§ method Object first()
        (ß _first)
    )

    (§ method ISeq next()
        (ß more().seq())
    )

    (§ method ISeq more()
        (when (ß _more == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _more)
    )

    (§ method int count()
        (ß 1 + RT.count(_more))
    )

    (§ method Cons withMeta(IPersistentMap meta)
        (ß new Cons(meta, _first, _more))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(§ interface Counted
    (§ abstract int count())
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (§ field- ISeq all) ;; never nil
    (§ field- ISeq prev)
    #_volatile
    (§ field- ISeq _current) ;; lazily realized
    #_volatile
    (§ field- ISeq _next) ;; cached

    (§ constructor- Cycle(ISeq all, ISeq prev, ISeq current)
        (ß this.all = all)
        (ß this.prev = prev)
        (ß this._current = current)
        this
    )

    (§ constructor- Cycle(IPersistentMap meta, ISeq all, ISeq prev, ISeq current, ISeq next)
        (§ super(meta))
        (ß this.all = all)
        (ß this.prev = prev)
        (ß this._current = current)
        (ß this._next = next)
        this
    )

    (§ defn ISeq create(ISeq vals)
        (when (ß vals == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new Cycle(vals, nil, vals))
    )

    ;; realization for use of current
    (§ method- ISeq current()
        (when (ß _current == nil)
            (let [#_"ISeq" current (ß prev.next())]
                (ß _current = (current == nil) ? all :or current)
            )
        )
        (ß _current)
    )

    (§ method boolean isRealized()
        (ß (_current != nil))
    )

    (§ method Object first()
        (ß current().first())
    )

    (§ method ISeq next()
        (when (ß _next == nil)
            (ß _next = new Cycle(all, current(), nil))
        )
        (ß _next)
    )

    (§ method Cycle withMeta(IPersistentMap meta)
        (ß new Cycle(meta, all, prev, _current, _next))
    )

    (§ method Object reduce(IFn f)
        (let [#_"ISeq" s (ß current())]
            (let [#_"Object" ret (ß s.first())]
                (while true
                    (ß s = s.next())
                    (when (ß s == nil)
                        (ß s = all)
                    )
                    (ß ret = f.invoke(ret, s.first()))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                )
            )
        )
    )

    (§ method Object reduce(IFn f, Object start)
        (let [#_"Object" ret start]
            (let [#_"ISeq" s (ß current())]
                (while true
                    (ß ret = f.invoke(ret, s.first()))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß s = s.next())
                    (when (ß s == nil)
                        (ß s = all)
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    #_volatile
    (§ field Object val)
    #_volatile
    (§ field Throwable exception)
    #_volatile
    (§ field IFn fn)

    (§ constructor Delay(IFn fn)
        (ß this.fn = fn)
        (ß this.val = nil)
        (ß this.exception = nil)
        this
    )

    (§ defn Object force(Object x)
        (ß (x instanceof Delay) ? ((Delay) x).deref() :or x)
    )

    (§ method Object deref()
        (when (ß fn != nil)
            (§ sync this
                ;; double check
                (when (ß fn != nil)
                    (try
                        (ß val = fn.invoke())
                        (catch Throwable t
                            (ß exception = t)
                        )
                    )
                    (ß fn = nil)
                )
            )
        )
        (when (ß exception != nil)
            (throw (ß Util.sneakyThrow(exception)))
        )
        val
    )

    (§ method boolean isRealized()
        (§ sync this
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (§ field HashMap<Integer, Object[]> constantVals = new HashMap<Integer, Object[]>())
    (§ def ConcurrentHashMap<String, Reference<Class>>classCache = new ConcurrentHashMap<String, Reference<Class> >())

    (§ def URL[] EMPTY_URLS = new URL[] (§))

    (§ def ReferenceQueue rq = new ReferenceQueue())

    (§ constructor DynamicClassLoader()
        ;; pseudo test in lieu of hasContextClassLoader()
        (§ super(EMPTY_URLS, (Thread.currentThread().getContextClassLoader() == nil || Thread.currentThread().getContextClassLoader() == ClassLoader.getSystemClassLoader()) ? Compiler.class.getClassLoader() :or Thread.currentThread().getContextClassLoader()))
        this
    )

    (§ constructor DynamicClassLoader(ClassLoader parent)
        (§ super(EMPTY_URLS, parent))
        this
    )

    (§ method Class defineClass(String name, byte[] bytes, Object srcForm)
        (ß Util.clearCache(rq, classCache))
        (let [#_"Class" c (ß defineClass(name, bytes, 0, bytes.length))]
            (ß classCache.put(name, new SoftReference(c, rq)))
            c
        )
    )

    (§ defn Class<?> findInMemoryClass(String name)
        (let [#_"Reference<Class>" cr (ß classCache.get(name))]
            (when (ß cr != nil)
                (let [#_"Class" c (ß cr.get())]
                    (if (ß c != nil)
                        (do
                            (§ return c)
                        )
                        (do
                            (ß classCache.remove(name, cr))
                        )
                    )
                )
            )
            nil
        )
    )

    #_protected
    (§ method Class<?>findClass(String name) (§ throws ClassNotFoundException)
        (let [#_"Class" c (ß findInMemoryClass(name))]
            (if (ß c != nil)
                (do
                    c
                )
                (do
                    (ß super.findClass(name))
                )
            )
        )
    )

    #_protected
    (§ method Class<?> loadClass(String name, boolean resolve) (§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" c (ß findLoadedClass(name))]
                (when (ß c == nil)
                    (ß c = findInMemoryClass(name))
                    (when (ß c == nil)
                        (ß c = super.loadClass(name, false))
                    )
                )
                (when resolve
                    (ß resolveClass(c))
                )
                c
            )
        )
    )

    (§ method void registerConstants(int id, Object[] val)
        (ß constantVals.put(id, val))
        nil
    )

    (§ method Object[] getConstants(int id)
        (ß constantVals.get(id))
    )

    (§ method void addURL(URL url)
        (ß super.addURL(url))
        nil
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns EdnReader
    (§ def IFn[] macros = new IFn[256])
    (§ def IFn[] dispatchMacros = new IFn[256])
    (§ def Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (§ def Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (§ def Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)"))
    (§ def Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    (§ def IFn taggedReader = new TaggedReader())

    (§ static
        (ß macros[\"] = new StringReader()) ;; oops! "
        (ß macros[\;] = new CommentReader())
        (ß macros[\^] = new MetaReader())
        (ß macros[\(] = new ListReader())
        (ß macros[\)] = new UnmatchedDelimiterReader())
        (ß macros[\[] = new VectorReader())
        (ß macros[\]] = new UnmatchedDelimiterReader())
        (ß macros[\{] = new MapReader())
        (ß macros[\}] = new UnmatchedDelimiterReader())
        (ß macros[\\] = new CharacterReader())
        (ß macros[\#] = new DispatchReader())

        (ß dispatchMacros[\#] = new SymbolicValueReader())
        (ß dispatchMacros[\^] = new MetaReader())
        (ß dispatchMacros[\{] = new SetReader())
        (ß dispatchMacros[\<] = new UnreadableReader())
        (ß dispatchMacros[\_] = new DiscardReader())
        (ß dispatchMacros[\:] = new NamespaceMapReader())
    )

    (§ defn boolean nonConstituent(int ch)
        (ß (ch == \@ || ch == \` || ch == \~))
    )

    (§ defn Object readString(String s, IPersistentMap opts)
        (let [#_"PushbackReader" r (ß new PushbackReader(new java.io.StringReader(s)))]
            (ß read(r, opts))
        )
    )

    (§ defn boolean isWhitespace(int ch)
        (ß (Character.isWhitespace(ch) || ch == \,))
    )

    (§ defn void unread(PushbackReader r, int ch)
        (when (ß ch != -1)
            (try
                (ß r.unread(ch))
                (catch IOException e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )
        nil
    )

    (class-ns ReaderException (§ extends RuntimeException)
        (§ field int line)
        (§ field int column)

        (§ constructor ReaderException(int line, int column, Throwable cause)
            (§ super(cause))
            (ß this.line = line)
            (ß this.column = column)
            this
        )
    )

    (§ defn int read1(Reader r)
        (try
            (ß r.read())
            (catch IOException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ def Keyword EOF = Keyword.intern(nil, "eof"))

    (§ defn Object read(PushbackReader r, IPersistentMap opts)
        (ß read(r, !opts.containsKey(EOF), opts.valAt(EOF), false, opts))
    )

    (§ defn Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
        (try
            (while true
                (let [#_"int" ch (ß read1(r))]
                    (while (ß isWhitespace(ch))
                        (ß ch = read1(r))
                    )

                    (when (ß ch == -1)
                        (when eofIsError
                            (throw (ß Util.runtimeException("EOF while reading")))
                        )
                        (§ return eofValue)
                    )

                    (when (ß Character.isDigit(ch))
                        (let [#_"Object" n (ß readNumber(r, (char) ch))]
                            (when (ß RT.suppressRead())
                                (§ return nil)
                            )
                            (§ return n)
                        )
                    )

                    (let [#_"IFn" macroFn (ß getMacro(ch))]
                        (when (ß macroFn != nil)
                            (let [#_"Object" ret (ß macroFn.invoke(r, (char) ch, opts))]
                                (when (ß RT.suppressRead())
                                    (§ return nil)
                                )
                                ;; no op macros return the reader
                                (when (ß ret == r)
                                    (§ continue )
                                )
                                (§ return ret)
                            )
                        )

                        (when (ß ch == \+ || ch == \-)
                            (let [#_"int" ch2 (ß read1(r))]
                                (when (ß Character.isDigit(ch2))
                                    (ß unread(r, ch2))
                                    (let [#_"Object" n (ß readNumber(r, (char) ch))]
                                        (when (ß RT.suppressRead())
                                            (§ return nil)
                                        )
                                        (§ return n)
                                    )
                                )
                                (ß unread(r, ch2))
                            )
                        )

                        (let [#_"String" token (ß readToken(r, (char) ch, true))]
                            (when (ß RT.suppressRead())
                                (§ return nil)
                            )
                            (§ return (ß interpretToken(token)))
                        )
                    )
                )
            )
            (catch Exception e
                (when (ß isRecursive || !(r instanceof LineNumberingPushbackReader))
                    (throw (ß Util.sneakyThrow(e)))
                )
                (let [#_"LineNumberingPushbackReader" rdr (ß (LineNumberingPushbackReader) r)]
                    (throw (ß new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)))
                )
            )
        )
    )

    (§ defn- String readToken(PushbackReader r, char initch, boolean leadConstituent)
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (when (ß leadConstituent && nonConstituent(initch))
                (throw (ß Util.runtimeException("Invalid leading character: " + (char)initch)))
            )

            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (cond (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (do
                            (ß unread(r, ch))
                            (§ return (ß sb.toString()))
                        )
                        (ß nonConstituent(ch))
                        (do
                            (throw (ß Util.runtimeException("Invalid constituent character: " + (char)ch)))
                        )
                    )
                    (ß sb.append((char) ch))
                )
            )
        )
    )

    (§ defn- Object readNumber(PushbackReader r, char initch)
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                        (ß unread(r, ch))
                        (§ break )
                    )
                    (ß sb.append((char) ch))
                )
            )

            (let [#_"String" s (ß sb.toString())]
                (let [#_"Object" n (ß matchNumber(s))]
                    (when (ß n == nil)
                        (throw (ß new NumberFormatException("Invalid number: " + s)))
                    )
                    n
                )
            )
        )
    )

    (§ defn- int readUnicodeChar(String token, int offset, int length, int base)
        (when (ß token.length() != offset + length)
            (throw (ß new IllegalArgumentException("Invalid unicode character: \\" + token)))
        )
        (let [#_"int" uc 0]
            (loop-when-recur [(ß int i = offset)] (ß i < offset + length) [(ß ++i)]
                (let [#_"int" d (ß Character.digit(token.charAt(i), base))]
                    (when (ß d == -1)
                        (throw (ß new IllegalArgumentException("Invalid digit: " + token.charAt(i))))
                    )
                    (ß uc = uc * base + d)
                )
            )
            (ß (char) uc)
        )
    )

    (§ defn- int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
        (let [#_"int" uc (ß Character.digit(initch, base))]
            (when (ß uc == -1)
                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) initch)))
            )
            (let [#_"int" i 1]
                (loop-when-recur [(ß )] (ß i < length) [(ß ++i)]
                    (let [#_"int" ch (ß read1(r))]
                        (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                            (ß unread(r, ch))
                            (§ break )
                        )
                        (let [#_"int" d (ß Character.digit(ch, base))]
                            (when (ß d == -1)
                                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ch)))
                            )
                            (ß uc = uc * base + d)
                        )
                    )
                )
                (when (ß i != length && exact)
                    (throw (ß new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)))
                )
                uc
            )
        )
    )

    (§ defn- Object interpretToken(String s)
        (cond (ß s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß s.equals("true"))
            (do
                (§ return (ß RT.T))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß RT.F))
            )
        )

        (let [#_"Object" ret nil]
            (ß ret = matchSymbol(s))
            (when (ß ret != nil)
                (§ return ret)
            )

            (throw (ß Util.runtimeException("Invalid token: " + s)))
        )
    )

    (§ defn- Object matchSymbol(String s)
        (let [#_"Matcher" m (ß symbolPat.matcher(s))]
            (when (ß m.matches())
                (let [#_"int" gc (ß m.groupCount())]
                    (let [#_"String" ns (ß m.group(1))]
                        (let [#_"String" name (ß m.group(2))]
                            (when (ß ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß s.startsWith("::"))
                                (§ return nil)
                            )
                            (let [#_"boolean" isKeyword (ß s.charAt(0) == \:)]
                                (let [#_"Symbol" sym (ß Symbol.intern(s.substring(isKeyword ? 1 :or 0)))]
                                    (when isKeyword
                                        (§ return (ß Keyword.intern(sym)))
                                    )
                                    (§ return sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (§ defn- Object matchNumber(String s)
        (let [#_"Matcher" m (ß intPat.matcher(s))]
            (when (ß m.matches())
                (when (ß m.group(2) != nil)
                    (when (ß m.group(8) != nil)
                        (§ return (ß BigInt.ZERO))
                    )
                    (§ return (ß Numbers.num(0)))
                )
                (let [#_"boolean" negate (ß m.group(1).equals("-"))]
                    (§ let [#_"String" n]
                        (let [#_"int" radix 10]
                            (cond (ß (n = m.group(3)) != nil)
                                (do
                                    (ß radix = 10)
                                )
                                (ß (n = m.group(4)) != nil)
                                (do
                                    (ß radix = 16)
                                )
                                (ß (n = m.group(5)) != nil)
                                (do
                                    (ß radix = 8)
                                )
                                (ß (n = m.group(7)) != nil)
                                (do
                                    (ß radix = Integer.parseInt(m.group(6)))
                                )
                            )
                            (when (ß n == nil)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" bn (ß new BigInteger(n, radix))]
                                (when negate
                                    (ß bn = bn.negate())
                                )
                                (when (ß m.group(8) != nil)
                                    (§ return (ß BigInt.fromBigInteger(bn)))
                                )
                                (§ return (ß (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
                            )
                        )
                    )
                )
            )
            (ß m = floatPat.matcher(s))
            (when (ß m.matches())
                (when (ß m.group(4) != nil)
                    (§ return (ß new BigDecimal(m.group(1))))
                )
                (§ return (ß Double.parseDouble(s)))
            )
            (ß m = ratioPat.matcher(s))
            (when (ß m.matches())
                (let [#_"String" numerator (ß m.group(1))]
                    (when (ß numerator.startsWith("+"))
                        (ß numerator = numerator.substring(1))
                    )

                    (§ return (ß Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
                )
            )
            nil
        )
    )

    (§ defn- IFn getMacro(int ch)
        (when (ß ch < macros.length)
            (§ return (ß macros[ch]))
        )
        nil
    )

    (§ defn- boolean isMacro(int ch)
        (ß (ch < macros.length && macros[ch] != nil))
    )

    (§ defn- boolean isTerminatingMacro(int ch)
        (ß (ch != \# && ch != \' && isMacro(ch)))
    )

    (class-ns StringReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object doublequote, Object opts)
            (let [#_"StringBuilder" sb (ß new StringBuilder())]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading string")))
                        )
                        (when (ß ch == \\) ;; escape
                            (ß ch = read1(r))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading string")))
                            )
                            (§ switch ch
                                (§ case \t)
                                (do
                                    (ß ch = \tab)
                                    (§ break )
                                )
                                (§ case \r)
                                (do
                                    (ß ch = \return)
                                    (§ break )
                                )
                                (§ case \n)
                                (do
                                    (ß ch = \newline)
                                    (§ break )
                                )
                                (§ case \\)
                                (do
                                    (§ break )
                                )
                                (§ case \") ;; oops! "
                                (do
                                    (§ break )
                                )
                                (§ case \b)
                                (do
                                    (ß ch = \backspace)
                                    (§ break )
                                )
                                (§ case \f)
                                (do
                                    (ß ch = \formfeed)
                                    (§ break )
                                )
                                (§ case \u)
                                (do
                                    (ß ch = read1(r))
                                    (when (ß Character.digit(ch, 16) == -1)
                                        (throw (ß Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)))
                                    )
                                    (ß ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (if (ß Character.isDigit(ch))
                                        (do
                                            (ß ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false))
                                            (when (ß ch > 0377)
                                                (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                            )
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Unsupported escape character: \\" + (char) ch)))
                                        )
                                    )
                                    (§ break )
                                )
                            )
                        )
                        (ß sb.append((char) ch))
                    )
                    (ß sb.toString())
                )
            )
        )
    )

    (class-ns CommentReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object semicolon, Object opts)
            (let [#_"Reader" r (ß (Reader) reader)]
                (§ let [#_"int" ch]
                    (§ loop
                        (ß ch = read1(r))
                        (§ recur-if (ch != -1 && ch != \newline && ch != \return))
                    )
                    r
                )
            )
        )
    )

    (class-ns DiscardReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object underscore, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß read(r, true, nil, true, opts))
                r
            )
        )
    )

    (class-ns NamespaceMapReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object colon, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                ;; Read ns symbol
                (let [#_"Object" sym (ß read(r, true, nil, false, opts))]
                    (when (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                        (throw (ß new RuntimeException("Namespaced map must specify a valid namespace: " + sym)))
                    )
                    (let [#_"String" ns (ß ((Symbol)sym).getName())]
                        ;; Read map
                        (let [#_"int" nextChar (ß read1(r))]
                            (while (ß isWhitespace(nextChar))
                                (ß nextChar = read1(r))
                            )
                            (when (ß \{ != nextChar)
                                (throw (ß new RuntimeException("Namespaced map must specify a map")))
                            )
                            (let [#_"List" kvs (ß readDelimitedList(\}, r, true, opts))]
                                (when (ß (kvs.size() & 1) == 1)
                                    (throw (ß Util.runtimeException("Namespaced map literal must contain an even number of forms")))
                                )

                                ;; Construct output map
                                (let [#_"Object[]" a (ß new Object[kvs.size()])]
                                    (let [#_"Iterator" iter (ß kvs.iterator())]
                                        (loop-when-recur [(ß int i = 0)] (ß iter.hasNext()) [(ß i += 2)]
                                            (let [#_"Object" key (ß iter.next())]
                                                (let [#_"Object" val (ß iter.next())]
                                                    (cond (ß key instanceof Keyword)
                                                        (do
                                                            (let [#_"Keyword" kw (ß (Keyword) key)]
                                                                (cond (ß kw.getNamespace() == nil)
                                                                    (do
                                                                        (ß key = Keyword.intern(ns, kw.getName()))
                                                                    )
                                                                    (ß kw.getNamespace().equals("_"))
                                                                    (do
                                                                        (ß key = Keyword.intern(nil, kw.getName()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (ß key instanceof Symbol)
                                                        (do
                                                            (let [#_"Symbol" s (ß (Symbol) key)]
                                                                (cond (ß s.getNamespace() == nil)
                                                                    (do
                                                                        (ß key = Symbol.intern(ns, s.getName()))
                                                                    )
                                                                    (ß s.getNamespace().equals("_"))
                                                                    (do
                                                                        (ß key = Symbol.intern(nil, s.getName()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (ß a[i] = key)
                                                    (ß a[i + 1] = val)
                                                )
                                            )
                                        )
                                        (ß RT.map(a))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns DispatchReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object hash, Object opts)
            (let [#_"int" ch (ß read1((Reader) reader))]
                (when (ß ch == -1)
                    (throw (ß Util.runtimeException("EOF while reading character")))
                )
                (let [#_"IFn" fn (ß dispatchMacros[ch])]
                    (when (ß fn == nil)
                        ;; try tagged reader
                        (when (ß Character.isLetter(ch))
                            (ß unread((PushbackReader) reader, ch))
                            (§ return (ß taggedReader.invoke(reader, ch, opts)))
                        )

                        (throw (ß Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))))
                    )
                    (ß fn.invoke(reader, ch, opts))
                )
            )
        )
    )

    (class-ns MetaReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object caret, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                            (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
                        )
                        (let [#_"Object" meta (ß read(r, true, nil, true, opts))]
                            (cond (ß meta instanceof Symbol || meta instanceof String)
                                (do
                                    (ß meta = RT.map(RT.TAG_KEY, meta))
                                )
                                (ß meta instanceof Keyword)
                                (do
                                    (ß meta = RT.map(meta, RT.T))
                                )
                                (ß !(meta instanceof IPersistentMap))
                                (do
                                    (throw (ß new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")))
                                )
                            )

                            (let [#_"Object" o (ß read(r, true, nil, true, opts))]
                                (if (ß o instanceof IMeta)
                                    (do
                                        (when (ß line != -1 && o instanceof ISeq)
                                            (ß meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column))
                                        )
                                        (when (ß o instanceof IReference)
                                            (ß ((IReference)o).resetMeta((IPersistentMap) meta))
                                            (§ return o)
                                        )
                                        (let [#_"Object" ometa (ß RT.meta(o))]
                                            (loop-when-recur [(ß ISeq s = RT.seq(meta))] (ß s != nil) [(ß s = s.next())]
                                                (let [#_"IMapEntry" kv (ß (IMapEntry) s.first())]
                                                    (ß ometa = RT.assoc(ometa, kv.getKey(), kv.getValue()))
                                                )
                                            )
                                            (ß ((IObj) o).withMeta((IPersistentMap) ometa))
                                        )
                                    )
                                    (do
                                        (throw (ß new IllegalArgumentException("Metadata can only be applied to IMetas")))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns CharacterReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object backslash, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (let [#_"String" token (ß readToken(r, (char) ch, false))]
                        (cond (ß token.length() == 1)
                            (do
                                (§ return (ß Character.valueOf(token.charAt(0))))
                            )
                            (ß token.equals("newline"))
                            (do
                                (§ return (ß \newline))
                            )
                            (ß token.equals("space"))
                            (do
                                (§ return (ß \space))
                            )
                            (ß token.equals("tab"))
                            (do
                                (§ return (ß \tab))
                            )
                            (ß token.equals("backspace"))
                            (do
                                (§ return (ß \backspace))
                            )
                            (ß token.equals("formfeed"))
                            (do
                                (§ return (ß \formfeed))
                            )
                            (ß token.equals("return"))
                            (do
                                (§ return (ß \return))
                            )
                            (ß token.startsWith("u"))
                            (do
                                (let [#_"char" c (ß (char) readUnicodeChar(token, 1, 4, 16))]
                                    (when (ß c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                                        (throw (ß Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))))
                                    )
                                    (§ return c)
                                )
                            )
                            (ß token.startsWith("o"))
                            (do
                                (let [#_"int" len (ß token.length() - 1)]
                                    (when (ß len > 3)
                                        (throw (ß Util.runtimeException("Invalid octal escape sequence length: " + len)))
                                    )
                                    (let [#_"int" uc (ß readUnicodeChar(token, 1, len, 8))]
                                        (when (ß uc > 0377)
                                            (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                        )
                                        (§ return (ß (char) uc))
                                    )
                                )
                            )
                        )
                        (throw (ß Util.runtimeException("Unsupported character: \\" + token)))
                    )
                )
            )
        )
    )

    (class-ns ListReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                            (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
                        )
                        (let [#_"List" list (ß readDelimitedList(\), r, true, opts))]
                            (when (ß list.isEmpty())
                                (§ return (ß PersistentList.EMPTY))
                            )
                            (let [#_"IObj" s (ß (IObj) PersistentList.create(list))]
                                s
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns VectorReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß LazilyPersistentVector.create(readDelimitedList(\], r, true, opts)))
            )
        )
    )

    (class-ns MapReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object[]" a (ß readDelimitedList(\}, r, true, opts).toArray())]
                    (when (ß (a.length & 1) == 1)
                        (throw (ß Util.runtimeException("Map literal must contain an even number of forms")))
                    )
                    (ß RT.map(a))
                )
            )
        )
    )

    (class-ns SetReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftbracket, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts)))
            )
        )
    )

    (class-ns UnmatchedDelimiterReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object rightdelim, Object opts)
            (throw (ß Util.runtimeException("Unmatched delimiter: " + rightdelim)))
        )
    )

    (class-ns UnreadableReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftangle, Object opts)
            (throw (ß Util.runtimeException("Unreadable form")))
        )
    )

    (class-ns SymbolicValueReader (§ extends AFn)
        (§ def IPersistentMap specials = PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        ))

        (§ method Object invoke(Object reader, Object quote, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts))]
                    (when (ß !(o instanceof Symbol))
                        (throw (ß Util.runtimeException("Invalid token: ##" + o)))
                    )
                    (when (ß !(specials.containsKey(o)))
                        (throw (ß Util.runtimeException("Unknown symbolic value: ##" + o)))
                    )

                    (ß specials.valAt(o))
                )
            )
        )
    )

    (§ defn List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts)
        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
            (let [#_"ArrayList" a (ß new ArrayList())]
                (while true
                    (let [#_"int" ch (ß read1(r))]
                        (while (ß isWhitespace(ch))
                            (ß ch = read1(r))
                        )

                        (when (ß ch == -1)
                            (if (ß firstline < 0)
                                (do
                                    (throw (ß Util.runtimeException("EOF while reading")))
                                )
                                (do
                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                )
                            )
                        )

                        (when (ß ch == delim)
                            (§ break )
                        )

                        (let [#_"IFn" macroFn (ß getMacro(ch))]
                            (if (ß macroFn != nil)
                                (do
                                    (let [#_"Object" mret (ß macroFn.invoke(r, (char) ch, opts))]
                                        ;; no op macros return the reader
                                        (when (ß mret != r)
                                            (ß a.add(mret))
                                        )
                                    )
                                )
                                (do
                                    (ß unread(r, ch))

                                    (let [#_"Object" o (ß read(r, true, nil, isRecursive, opts))]
                                        (when (ß o != r)
                                            (ß a.add(o))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                a
            )
        )
    )

    (class-ns TaggedReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object firstChar, Object opts)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" name (ß read(r, true, nil, false, opts))]
                    (when (ß !(name instanceof Symbol))
                        (throw (ß new RuntimeException("Reader tag must be a symbol")))
                    )
                    (let [#_"Symbol" sym (ß (Symbol)name)]
                        (ß readTagged(r, sym, (IPersistentMap) opts))
                    )
                )
            )
        )

        (§ def Keyword READERS = Keyword.intern(nil, "readers"))
        (§ def Keyword DEFAULT = Keyword.intern(nil, "default"))

        (§ method- Object readTagged(PushbackReader reader, Symbol tag, IPersistentMap opts)
            (let [#_"Object" o (ß read(reader, true, nil, true, opts))]
                (let [#_"ILookup" readers (ß (ILookup)RT.get(opts, READERS))]
                    (let [#_"IFn" dataReader (ß (IFn)RT.get(readers, tag))]
                        (when (ß dataReader == nil)
                            (ß dataReader = (IFn)RT.get(RT.DEFAULT_DATA_READERS.deref(), tag))
                        )
                        (if (ß dataReader == nil)
                            (do
                                (let [#_"IFn" defaultReader (ß (IFn)RT.get(opts, DEFAULT))]
                                    (if (ß defaultReader != nil)
                                        (do
                                            (ß defaultReader.invoke(tag, o))
                                        )
                                        (do
                                            (throw (ß new RuntimeException("No reader function for tag " + tag.toString())))
                                        )
                                    )
                                )
                            )
                            (do
                                (ß dataReader.invoke(o))
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

(class-ns EnumerationSeq (§ extends ASeq)
    (§ field Enumeration iter)
    (§ field State state)

    (class-ns State
        #_volatile
        (§ field Object val)
        #_volatile
        (§ field Object _rest)
    )

    (§ defn EnumerationSeq create(Enumeration iter)
        (when (ß iter.hasMoreElements())
            (§ return (ß new EnumerationSeq(iter)))
        )
        nil
    )

    (§ constructor EnumerationSeq(Enumeration iter)
        (ß this.iter = iter)
        (ß state = new State())
        (ß this.state.val = state)
        (ß this.state._rest = state)
        this
    )

    (§ constructor EnumerationSeq(IPersistentMap meta, Enumeration iter, State state)
        (§ super(meta))
        (ß this.iter = iter)
        (ß this.state = state)
        this
    )

    (§ method Object first()
        (when (ß state.val == state)
            (§ sync state
                (when (ß state.val == state)
                    (ß state.val = iter.nextElement())
                )
            )
        )
        (ß state.val)
    )

    (§ method ISeq next()
        (when (ß state._rest == state)
            (§ sync state
                (when (ß state._rest == state)
                    (ß first())
                    (ß state._rest = create(iter))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    (§ method EnumerationSeq withMeta(IPersistentMap meta)
        (ß new EnumerationSeq(meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (§ field IPersistentMap data)

    (§ constructor ExceptionInfo(String s, IPersistentMap data)
        (§ this(s, data, nil))
        this
    )

    (§ constructor ExceptionInfo(String s, IPersistentMap data, Throwable throwable)
        ;; nil cause is equivalent to not passing a cause
        (§ super(s, throwable))
        (if (ß data != nil)
            (do
                (ß this.data = data)
            )
            (do
                (throw (ß new IllegalArgumentException("Additional data must be non-nil.")))
            )
        )
        this
    )

    (§ method IPersistentMap getData()
        data
    )

    (§ method String toString()
        (ß "cloiure.lang.ExceptionInfo: " + getMessage() + " " + data.toString())
    )
)
)

(java-ns cloiure.lang.Fn

(§ interface Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (§ field Var v)
    (§ field ClassLoader loader)
    (§ field String fnClassName)
    (§ field IFn fn)

    (§ constructor FnLoaderThunk(Var v, String fnClassName)
        (ß this.v = v)
        (ß this.loader = (ClassLoader) RT.FN_LOADER_VAR.get())
        (ß this.fnClassName = fnClassName)
        (ß fn = nil)
        this
    )

    (§ method Object invoke(Object arg1)
        (ß load())
        (ß fn.invoke(arg1))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß load())
        (ß fn.invoke(arg1, arg2))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß load())
        (ß fn.invoke(arg1, arg2, arg3))
    )

    #_protected
    (§ method Object doInvoke(Object args)
        (ß load())
        (ß fn.applyTo((ISeq) args))
    )

    (§ method- void load()
        (when (ß fn == nil)
            (try
                (ß fn = (IFn) Class.forName(fnClassName, true, loader).newInstance())
                (catch Exception e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
            (ß v.root = fn)
        )
        nil
    )

    (§ method int getRequiredArity()
        0
    )

    (§ method IObj withMeta(IPersistentMap meta)
        this
    )

    (§ method IPersistentMap meta()
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(§ interface IAtom
    (§ abstract Object swap(IFn f))
    (§ abstract Object swap(IFn f, Object arg))
    (§ abstract Object swap(IFn f, Object arg1, Object arg2))
    (§ abstract Object swap(IFn f, Object x, Object y, ISeq args))
    (§ abstract boolean compareAndSet(Object oldv, Object newv))
    (§ abstract Object reset(Object newval))
)
)

(java-ns cloiure.lang.IAtom2

(§ interface IAtom2 (§ extends IAtom)
    (§ abstract IPersistentVector swapVals(IFn f))
    (§ abstract IPersistentVector swapVals(IFn f, Object arg))
    (§ abstract IPersistentVector swapVals(IFn f, Object arg1, Object arg2))
    (§ abstract IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args))
    (§ abstract IPersistentVector resetVals(Object newv))
)
)

(java-ns cloiure.lang.IBlockingDeref

(§ interface IBlockingDeref
    (§ abstract Object deref(long ms, Object timeoutValue))
)
)

(java-ns cloiure.lang.IChunk

(§ interface IChunk (§ extends Indexed)
    (§ abstract IChunk dropFirst())
    (§ abstract Object reduce(IFn f, Object start))
)
)

(java-ns cloiure.lang.IChunkedSeq

(§ interface IChunkedSeq (§ extends ISeq, Sequential)
    (§ abstract IChunk chunkedFirst())
    (§ abstract ISeq chunkedNext())
    (§ abstract ISeq chunkedMore())
)
)

(java-ns cloiure.lang.IDeref

(§ interface IDeref
    (§ abstract Object deref())
)
)

(java-ns cloiure.lang.IEditableCollection

(§ interface IEditableCollection
    (§ abstract ITransientCollection asTransient())
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(§ interface IExceptionInfo
    (§ abstract IPersistentMap getData())
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(§ interface IFn (§ extends Callable, Runnable)
    (§ abstract Object invoke())
    (§ abstract Object invoke(Object arg1))
    (§ abstract Object invoke(Object arg1, Object arg2))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7))
    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20))

    (§ abstract Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args))

    (§ abstract Object applyTo(ISeq arglist))

    (§ interface L
        (§ abstract long invokePrim())
    )

    (§ interface D
        (§ abstract double invokePrim())
    )

    (§ interface OL
        (§ abstract long invokePrim(Object arg0))
    )

    (§ interface OD
        (§ abstract double invokePrim(Object arg0))
    )

    (§ interface LO
        (§ abstract Object invokePrim(long arg0))
    )

    (§ interface LL
        (§ abstract long invokePrim(long arg0))
    )

    (§ interface LD
        (§ abstract double invokePrim(long arg0))
    )

    (§ interface DO
        (§ abstract Object invokePrim(double arg0))
    )

    (§ interface DL
        (§ abstract long invokePrim(double arg0))
    )

    (§ interface DD
        (§ abstract double invokePrim(double arg0))
    )

    (§ interface OOL
        (§ abstract long invokePrim(Object arg0, Object arg1))
    )

    (§ interface OOD
        (§ abstract double invokePrim(Object arg0, Object arg1))
    )

    (§ interface OLO
        (§ abstract Object invokePrim(Object arg0, long arg1))
    )

    (§ interface OLL
        (§ abstract long invokePrim(Object arg0, long arg1))
    )

    (§ interface OLD
        (§ abstract double invokePrim(Object arg0, long arg1))
    )

    (§ interface ODO
        (§ abstract Object invokePrim(Object arg0, double arg1))
    )

    (§ interface ODL
        (§ abstract long invokePrim(Object arg0, double arg1))
    )

    (§ interface ODD
        (§ abstract double invokePrim(Object arg0, double arg1))
    )

    (§ interface LOO
        (§ abstract Object invokePrim(long arg0, Object arg1))
    )

    (§ interface LOL
        (§ abstract long invokePrim(long arg0, Object arg1))
    )

    (§ interface LOD
        (§ abstract double invokePrim(long arg0, Object arg1))
    )

    (§ interface LLO
        (§ abstract Object invokePrim(long arg0, long arg1))
    )

    (§ interface LLL
        (§ abstract long invokePrim(long arg0, long arg1))
    )

    (§ interface LLD
        (§ abstract double invokePrim(long arg0, long arg1))
    )

    (§ interface LDO
        (§ abstract Object invokePrim(long arg0, double arg1))
    )

    (§ interface LDL
        (§ abstract long invokePrim(long arg0, double arg1))
    )

    (§ interface LDD
        (§ abstract double invokePrim(long arg0, double arg1))
    )

    (§ interface DOO
        (§ abstract Object invokePrim(double arg0, Object arg1))
    )

    (§ interface DOL
        (§ abstract long invokePrim(double arg0, Object arg1))
    )

    (§ interface DOD
        (§ abstract double invokePrim(double arg0, Object arg1))
    )

    (§ interface DLO
        (§ abstract Object invokePrim(double arg0, long arg1))
    )

    (§ interface DLL
        (§ abstract long invokePrim(double arg0, long arg1))
    )

    (§ interface DLD
        (§ abstract double invokePrim(double arg0, long arg1))
    )

    (§ interface DDO
        (§ abstract Object invokePrim(double arg0, double arg1))
    )

    (§ interface DDL
        (§ abstract long invokePrim(double arg0, double arg1))
    )

    (§ interface DDD
        (§ abstract double invokePrim(double arg0, double arg1))
    )

    (§ interface OOOL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2))
    )

    (§ interface OOOD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2))
    )

    (§ interface OOLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OOLL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OOLD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2))
    )

    (§ interface OODO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OODL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OODD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2))
    )

    (§ interface OLOO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLOL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLOD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2))
    )

    (§ interface OLLO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLLL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLLD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2))
    )

    (§ interface OLDO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface OLDL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface OLDD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2))
    )

    (§ interface ODOO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODOL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODOD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2))
    )

    (§ interface ODLO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODLL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODLD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2))
    )

    (§ interface ODDO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface ODDL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface ODDD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2))
    )

    (§ interface LOOO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOOL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOOD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2))
    )

    (§ interface LOLO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LOLL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LOLD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2))
    )

    (§ interface LODO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LODL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LODD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2))
    )

    (§ interface LLOO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLOL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLOD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2))
    )

    (§ interface LLLO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLLL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLLD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2))
    )

    (§ interface LLDO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LLDL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LLDD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2))
    )

    (§ interface LDOO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDOL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDOD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2))
    )

    (§ interface LDLO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDLL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDLD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2))
    )

    (§ interface LDDO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface LDDL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface LDDD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2))
    )

    (§ interface DOOO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOOL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOOD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2))
    )

    (§ interface DOLO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DOLL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DOLD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2))
    )

    (§ interface DODO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DODL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DODD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2))
    )

    (§ interface DLOO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLOL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLOD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2))
    )

    (§ interface DLLO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLLL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLLD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2))
    )

    (§ interface DLDO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DLDL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DLDD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2))
    )

    (§ interface DDOO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDOL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDOD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2))
    )

    (§ interface DDLO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDLL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDLD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2))
    )

    (§ interface DDDO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface DDDL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface DDDD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2))
    )

    (§ interface OOOOL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface OOOOD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface OOOLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOOLL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOOLD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface OOODO
        (§ abstract Object invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOODL
        (§ abstract long invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOODD
        (§ abstract double invokePrim(Object arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface OOLOO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLOL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLOD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface OOLLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLLL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLLD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface OOLDO
        (§ abstract Object invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OOLDL
        (§ abstract long invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OOLDD
        (§ abstract double invokePrim(Object arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface OODOO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODOL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODOD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface OODLO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODLL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODLD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface OODDO
        (§ abstract Object invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OODDL
        (§ abstract long invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OODDD
        (§ abstract double invokePrim(Object arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface OLOOO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOOL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOOD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface OLOLO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLOLL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLOLD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface OLODO
        (§ abstract Object invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLODL
        (§ abstract long invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLODD
        (§ abstract double invokePrim(Object arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface OLLOO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLOL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLOD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface OLLLO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLLL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLLD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, long arg3))
    )

    (§ interface OLLDO
        (§ abstract Object invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLLDL
        (§ abstract long invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLLDD
        (§ abstract double invokePrim(Object arg0, long arg1, long arg2, double arg3))
    )

    (§ interface OLDOO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDOL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDOD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface OLDLO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDLL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDLD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, long arg3))
    )

    (§ interface OLDDO
        (§ abstract Object invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface OLDDL
        (§ abstract long invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface OLDDD
        (§ abstract double invokePrim(Object arg0, long arg1, double arg2, double arg3))
    )

    (§ interface ODOOO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOOL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOOD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface ODOLO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODOLL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODOLD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface ODODO
        (§ abstract Object invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODODL
        (§ abstract long invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODODD
        (§ abstract double invokePrim(Object arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface ODLOO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLOL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLOD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface ODLLO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLLL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLLD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, long arg3))
    )

    (§ interface ODLDO
        (§ abstract Object invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODLDL
        (§ abstract long invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODLDD
        (§ abstract double invokePrim(Object arg0, double arg1, long arg2, double arg3))
    )

    (§ interface ODDOO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDOL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDOD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface ODDLO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDLL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDLD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, long arg3))
    )

    (§ interface ODDDO
        (§ abstract Object invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface ODDDL
        (§ abstract long invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface ODDDD
        (§ abstract double invokePrim(Object arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LOOOO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOOL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOOD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface LOOLO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOOLL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOOLD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface LOODO
        (§ abstract Object invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOODL
        (§ abstract long invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOODD
        (§ abstract double invokePrim(long arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface LOLOO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLOL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLOD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface LOLLO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLLL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLLD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface LOLDO
        (§ abstract Object invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LOLDL
        (§ abstract long invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LOLDD
        (§ abstract double invokePrim(long arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface LODOO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODOL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODOD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface LODLO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODLL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODLD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface LODDO
        (§ abstract Object invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LODDL
        (§ abstract long invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LODDD
        (§ abstract double invokePrim(long arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface LLOOO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOOL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOOD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface LLOLO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLOLL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLOLD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface LLODO
        (§ abstract Object invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLODL
        (§ abstract long invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLODD
        (§ abstract double invokePrim(long arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface LLLOO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLOL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLOD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface LLLLO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLLL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLLD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, long arg3))
    )

    (§ interface LLLDO
        (§ abstract Object invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLLDL
        (§ abstract long invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLLDD
        (§ abstract double invokePrim(long arg0, long arg1, long arg2, double arg3))
    )

    (§ interface LLDOO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDOL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDOD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface LLDLO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDLL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDLD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, long arg3))
    )

    (§ interface LLDDO
        (§ abstract Object invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LLDDL
        (§ abstract long invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LLDDD
        (§ abstract double invokePrim(long arg0, long arg1, double arg2, double arg3))
    )

    (§ interface LDOOO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOOL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOOD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface LDOLO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDOLL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDOLD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface LDODO
        (§ abstract Object invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDODL
        (§ abstract long invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDODD
        (§ abstract double invokePrim(long arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface LDLOO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLOL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLOD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface LDLLO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLLL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLLD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, long arg3))
    )

    (§ interface LDLDO
        (§ abstract Object invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDLDL
        (§ abstract long invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDLDD
        (§ abstract double invokePrim(long arg0, double arg1, long arg2, double arg3))
    )

    (§ interface LDDOO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDOL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDOD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface LDDLO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDLL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDLD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, long arg3))
    )

    (§ interface LDDDO
        (§ abstract Object invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LDDDL
        (§ abstract long invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface LDDDD
        (§ abstract double invokePrim(long arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DOOOO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOOL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOOD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, Object arg3))
    )

    (§ interface DOOLO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOOLL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOOLD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, long arg3))
    )

    (§ interface DOODO
        (§ abstract Object invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOODL
        (§ abstract long invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOODD
        (§ abstract double invokePrim(double arg0, Object arg1, Object arg2, double arg3))
    )

    (§ interface DOLOO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLOL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLOD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, Object arg3))
    )

    (§ interface DOLLO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLLL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLLD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, long arg3))
    )

    (§ interface DOLDO
        (§ abstract Object invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DOLDL
        (§ abstract long invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DOLDD
        (§ abstract double invokePrim(double arg0, Object arg1, long arg2, double arg3))
    )

    (§ interface DODOO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODOL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODOD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, Object arg3))
    )

    (§ interface DODLO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODLL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODLD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, long arg3))
    )

    (§ interface DODDO
        (§ abstract Object invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DODDL
        (§ abstract long invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DODDD
        (§ abstract double invokePrim(double arg0, Object arg1, double arg2, double arg3))
    )

    (§ interface DLOOO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOOL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOOD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, Object arg3))
    )

    (§ interface DLOLO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLOLL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLOLD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, long arg3))
    )

    (§ interface DLODO
        (§ abstract Object invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLODL
        (§ abstract long invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLODD
        (§ abstract double invokePrim(double arg0, long arg1, Object arg2, double arg3))
    )

    (§ interface DLLOO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLOL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLOD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, Object arg3))
    )

    (§ interface DLLLO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLLL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLLD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, long arg3))
    )

    (§ interface DLLDO
        (§ abstract Object invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLLDL
        (§ abstract long invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLLDD
        (§ abstract double invokePrim(double arg0, long arg1, long arg2, double arg3))
    )

    (§ interface DLDOO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDOL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDOD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, Object arg3))
    )

    (§ interface DLDLO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDLL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDLD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, long arg3))
    )

    (§ interface DLDDO
        (§ abstract Object invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DLDDL
        (§ abstract long invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DLDDD
        (§ abstract double invokePrim(double arg0, long arg1, double arg2, double arg3))
    )

    (§ interface DDOOO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOOL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOOD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, Object arg3))
    )

    (§ interface DDOLO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDOLL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDOLD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, long arg3))
    )

    (§ interface DDODO
        (§ abstract Object invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDODL
        (§ abstract long invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDODD
        (§ abstract double invokePrim(double arg0, double arg1, Object arg2, double arg3))
    )

    (§ interface DDLOO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLOL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLOD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, Object arg3))
    )

    (§ interface DDLLO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLLL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLLD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, long arg3))
    )

    (§ interface DDLDO
        (§ abstract Object invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDLDL
        (§ abstract long invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDLDD
        (§ abstract double invokePrim(double arg0, double arg1, long arg2, double arg3))
    )

    (§ interface DDDOO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDOL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDOD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, Object arg3))
    )

    (§ interface DDDLO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDLL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDLD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, long arg3))
    )

    (§ interface DDDDO
        (§ abstract Object invokePrim(double arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DDDDL
        (§ abstract long invokePrim(double arg0, double arg1, double arg2, double arg3))
    )

    (§ interface DDDDD
        (§ abstract double invokePrim(double arg0, double arg1, double arg2, double arg3))
    )
)
)

(java-ns cloiure.lang.IHashEq

(§ interface IHashEq
    (§ abstract int hasheq())
)
)

(java-ns cloiure.lang.IKeywordLookup

(§ interface IKeywordLookup
    (§ abstract ILookupThunk getLookupThunk(Keyword k))
)
)

(java-ns cloiure.lang.IKVReduce

(§ interface IKVReduce
    (§ abstract Object kvreduce(IFn f, Object init))
)
)

(java-ns cloiure.lang.ILookup

(§ interface ILookup
    (§ abstract Object valAt(Object key))
    (§ abstract Object valAt(Object key, Object notFound))
)
)

(java-ns cloiure.lang.ILookupSite

(§ interface ILookupSite
    (§ abstract ILookupThunk fault(Object target))
)
)

(java-ns cloiure.lang.ILookupThunk

(§ interface ILookupThunk
    (§ abstract Object get(Object target))
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(§ interface IMapEntry (§ extends Map).Entry
    (§ abstract Object key())
    (§ abstract Object val())
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(§ interface IMapIterable
    (§ abstract Iterator keyIterator())
    (§ abstract Iterator valIterator())
)
)

(java-ns cloiure.lang.IMeta

(§ interface IMeta
    (§ abstract IPersistentMap meta())
)
)

(java-ns cloiure.lang.Indexed

(§ interface Indexed (§ extends Counted)
    (§ abstract Object nth(int i))
    (§ abstract Object nth(int i, Object notFound))
)
)

(java-ns cloiure.lang.IndexedSeq

(§ interface IndexedSeq (§ extends ISeq, Sequential, Counted)
    (§ abstract int index())
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

(class-ns Intrinsics (§ implements Opcodes)
    (§ defn- Object[] oa(Object... arr)
        arr
    )

    (§ def IPersistentMap ops = RT.map(
      #_map "public static double cloiure.lang.Numbers.add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.and(long,long)", LAND,
      #_map "public static long cloiure.lang.Numbers.or(long,long)", LOR,
      #_map "public static long cloiure.lang.Numbers.xor(long,long)", LXOR,
      #_map "public static double cloiure.lang.Numbers.multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.divide(double,double)", DDIV,
      #_map "public static long cloiure.lang.Numbers.remainder(long,long)", LREM,
      #_map "public static long cloiure.lang.Numbers.shiftLeft(long,long)", oa(L2I, LSHL),
      #_map "public static long cloiure.lang.Numbers.shiftRight(long,long)", oa(L2I, LSHR),
      #_map "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)", oa(L2I, LUSHR),
      #_map "public static double cloiure.lang.Numbers.minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.minus(double,double)", DSUB,
      #_map "public static double cloiure.lang.Numbers.inc(double)", oa(DCONST_1, DADD),
      #_map "public static double cloiure.lang.Numbers.dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.quotient(long,long)", LDIV,
      #_map "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)", ISHL,
      #_map "public static int cloiure.lang.Numbers.shiftRightInt(int,int)", ISHR,
      #_map "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)", IUSHR,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)", IADD,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)", ISUB,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_negate(int)", INEG,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_inc(int)", oa(ICONST_1, IADD),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_dec(int)", oa(ICONST_1, ISUB),
      #_map "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)", IMUL,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)", IDIV,
      #_map "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)", IREM,
      #_map "public static long cloiure.lang.Numbers.unchecked_add(long,long)", LADD,
      #_map "public static double cloiure.lang.Numbers.unchecked_add(double,double)", DADD,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long)", LNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double)", DNEG,
      #_map "public static double cloiure.lang.Numbers.unchecked_minus(double,double)", DSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_minus(long,long)", LSUB,
      #_map "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)", LMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)", DMUL,
      #_map "public static double cloiure.lang.Numbers.unchecked_inc(double)", oa(DCONST_1, DADD),
      #_map "public static long cloiure.lang.Numbers.unchecked_inc(long)", oa(LCONST_1, LADD),
      #_map "public static double cloiure.lang.Numbers.unchecked_dec(double)", oa(DCONST_1, DSUB),
      #_map "public static long cloiure.lang.Numbers.unchecked_dec(long)", oa(LCONST_1, LSUB),

      #_map "public static short cloiure.lang.RT.aget(short[],int)", SALOAD,
      #_map "public static float cloiure.lang.RT.aget(float[],int)", FALOAD,
      #_map "public static double cloiure.lang.RT.aget(double[],int)", DALOAD,
      #_map "public static int cloiure.lang.RT.aget(int[],int)", IALOAD,
      #_map "public static long cloiure.lang.RT.aget(long[],int)", LALOAD,
      #_map "public static char cloiure.lang.RT.aget(char[],int)", CALOAD,
      #_map "public static byte cloiure.lang.RT.aget(byte[],int)", BALOAD,
      #_map "public static boolean cloiure.lang.RT.aget(boolean[],int)", BALOAD,
      #_map "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)", AALOAD,
      #_map "public static int cloiure.lang.RT.alength(int[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(long[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(char[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(java.lang.Object[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(byte[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(float[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(short[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(boolean[])", ARRAYLENGTH,
      #_map "public static int cloiure.lang.RT.alength(double[])", ARRAYLENGTH,

      #_map "public static double cloiure.lang.RT.doubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.doubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.doubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.doubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.doubleCast(byte)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(double)", NOP,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(float)", F2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(long)", L2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(int)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(short)", I2D,
      #_map "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)", I2D,
      #_map "public static long cloiure.lang.RT.longCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.longCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.longCast(int)", I2L,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(long)", L2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(double)", D2I,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(byte)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(short)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(char)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(int)", NOP,
      #_map "public static int cloiure.lang.RT.uncheckedIntCast(float)", F2I,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(short)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(float)", F2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(double)", D2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(byte)", I2L,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(long)", NOP,
      #_map "public static long cloiure.lang.RT.uncheckedLongCast(int)", I2L
    ))

    ;; map to instructions terminated with comparator for branch to false
    (§ def IPersistentMap preds = RT.map(
      #_map "public static boolean cloiure.lang.Numbers.lt(double,double)", oa(DCMPG, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.lt(long,long)", oa(LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(double,double)", oa(DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.lte(double,double)", oa(DCMPG, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.lte(long,long)", oa(LCMP, IFGT),
      #_map "public static boolean cloiure.lang.Numbers.gt(long,long)", oa(LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gt(double,double)", oa(DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.gte(long,long)", oa(LCMP, IFLT),
      #_map "public static boolean cloiure.lang.Numbers.gte(double,double)", oa(DCMPL, IFLT),
      #_map "public static boolean cloiure.lang.Util.equiv(long,long)", oa(LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Util.equiv(boolean,boolean)", oa(IF_ICMPNE),
      #_map "public static boolean cloiure.lang.Util.equiv(double,double)", oa(DCMPL, IFNE),

      #_map "public static boolean cloiure.lang.Numbers.isZero(double)", oa(DCONST_0, DCMPL, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isZero(long)", oa(LCONST_0, LCMP, IFNE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(long)", oa(LCONST_0, LCMP, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isPos(double)", oa(DCONST_0, DCMPL, IFLE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(long)", oa(LCONST_0, LCMP, IFGE),
      #_map "public static boolean cloiure.lang.Numbers.isNeg(double)", oa(DCONST_0, DCMPG, IFGE)
    ))
)
)

(java-ns cloiure.lang.IObj

(§ interface IObj (§ extends IMeta)
    (§ abstract IObj withMeta(IPersistentMap meta))
)
)

(java-ns cloiure.lang.IPending

(§ interface IPending
    (§ abstract boolean isRealized())
)
)

(java-ns cloiure.lang.IPersistentCollection

(§ interface IPersistentCollection (§ extends Seqable)
    (§ abstract int count())
    (§ abstract IPersistentCollection cons(Object o))
    (§ abstract IPersistentCollection empty())
    (§ abstract boolean equiv(Object o))
)
)

(java-ns cloiure.lang.IPersistentList

(§ interface IPersistentList (§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(§ interface IPersistentMap (§ extends Iterable, Associative, Counted)
    (§ abstract IPersistentMap assoc(Object key, Object val))
    (§ abstract IPersistentMap assocEx(Object key, Object val))
    (§ abstract IPersistentMap without(Object key))
)
)

(java-ns cloiure.lang.IPersistentSet

(§ interface IPersistentSet (§ extends IPersistentCollection, Counted)
    (§ abstract IPersistentSet disjoin(Object key))
    (§ abstract boolean contains(Object key))
    (§ abstract Object get(Object key))
)
)

(java-ns cloiure.lang.IPersistentStack

(§ interface IPersistentStack (§ extends IPersistentCollection)
    (§ abstract Object peek())
    (§ abstract IPersistentStack pop())
)
)

(java-ns cloiure.lang.IPersistentVector

(§ interface IPersistentVector (§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    (§ abstract int length())
    (§ abstract IPersistentVector assocN(int i, Object val))
    (§ abstract IPersistentVector cons(Object o))
)
)

(java-ns cloiure.lang.IProxy

(§ interface IProxy
    (§ abstract void __initCloiureFnMappings(IPersistentMap m))
    (§ abstract void __updateCloiureFnMappings(IPersistentMap m))
    (§ abstract IPersistentMap __getCloiureFnMappings())
)
)

(java-ns cloiure.lang.IRecord

(§ interface IRecord
)
)

(java-ns cloiure.lang.IReduce

(§ interface IReduce (§ extends IReduceInit)
    (§ abstract Object reduce(IFn f))
)
)

(java-ns cloiure.lang.IReduceInit

(§ interface IReduceInit
    (§ abstract Object reduce(IFn f, Object start))
)
)

(java-ns cloiure.lang.IRef

(§ interface IRef (§ extends IDeref)
    (§ abstract void setValidator(IFn vf))
    (§ abstract IFn getValidator())
    (§ abstract IPersistentMap getWatches())
    (§ abstract IRef addWatch(Object key, IFn callback))
    (§ abstract IRef removeWatch(Object key))
)
)

(java-ns cloiure.lang.IReference

(§ interface IReference (§ extends IMeta)
    (§ abstract IPersistentMap alterMeta(IFn alter, ISeq args))
    (§ abstract IPersistentMap resetMeta(IPersistentMap m))
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(§ interface ISeq (§ extends IPersistentCollection)
    (§ abstract Object first())
    (§ abstract ISeq next())
    (§ abstract ISeq more())
    (§ abstract ISeq cons(Object o))
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (§ def- Object UNREALIZED_SEED = new Object())
    (§ field- IFn f) ;; never nil
    (§ field- Object prevSeed)
    #_volatile
    (§ field- Object _seed) ;; lazily realized
    #_volatile
    (§ field- ISeq _next) ;; cached

    (§ constructor- Iterate(IFn f, Object prevSeed, Object seed)
        (ß this.f = f)
        (ß this.prevSeed = prevSeed)
        (ß this._seed = seed)
        this
    )

    (§ constructor- Iterate(IPersistentMap meta, IFn f, Object prevSeed, Object seed, ISeq next)
        (§ super(meta))
        (ß this.f = f)
        (ß this.prevSeed = prevSeed)
        (ß this._seed = seed)
        (ß this._next = next)
        this
    )

    (§ defn ISeq create(IFn f, Object seed)
        (ß new Iterate(f, nil, seed))
    )

    (§ method boolean isRealized()
        (ß (_seed != UNREALIZED_SEED))
    )

    (§ method Object first()
        (when (ß _seed == UNREALIZED_SEED)
            (ß _seed = f.invoke(prevSeed))
        )
        (ß _seed)
    )

    (§ method ISeq next()
        (when (ß _next == nil)
            (ß _next = new Iterate(f, first(), UNREALIZED_SEED))
        )
        (ß _next)
    )

    (§ method Iterate withMeta(IPersistentMap meta)
        (ß new Iterate(meta, f, prevSeed, _seed, _next))
    )

    (§ method Object reduce(IFn rf)
        (let [#_"Object" first (ß first())]
            (let [#_"Object" ret first]
                (let [#_"Object" v (ß f.invoke(first))]
                    (while true
                        (ß ret = rf.invoke(ret, v))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                        (ß v = f.invoke(v))
                    )
                )
            )
        )
    )

    (§ method Object reduce(IFn rf, Object start)
        (let [#_"Object" ret start]
            (let [#_"Object" v (ß first())]
                (while true
                    (ß ret = rf.invoke(ret, v))
                    (when (ß RT.isReduced(ret))
                        (§ return (ß ((IDeref)ret).deref()))
                    )
                    (ß v = f.invoke(v))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeq (§ extends ASeq)
    (§ field Iterator iter)
    (§ field State state)

    (class-ns State
        #_volatile
        (§ field Object val)
        #_volatile
        (§ field Object _rest)
    )

    (§ defn IteratorSeq create(Iterator iter)
        (when (ß iter.hasNext())
            (§ return (ß new IteratorSeq(iter)))
        )
        nil
    )

    (§ constructor IteratorSeq(Iterator iter)
        (ß this.iter = iter)
        (ß state = new State())
        (ß this.state.val = state)
        (ß this.state._rest = state)
        this
    )

    (§ constructor IteratorSeq(IPersistentMap meta, Iterator iter, State state)
        (§ super(meta))
        (ß this.iter = iter)
        (ß this.state = state)
        this
    )

    (§ method Object first()
        (when (ß state.val == state)
            (§ sync state
                (when (ß state.val == state)
                    (ß state.val = iter.next())
                )
            )
        )
        (ß state.val)
    )

    (§ method ISeq next()
        (when (ß state._rest == state)
            (§ sync state
                (when (ß state._rest == state)
                    (ß first())
                    (ß state._rest = create(iter))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    (§ method IteratorSeq withMeta(IPersistentMap meta)
        (ß new IteratorSeq(meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(§ interface ITransientAssociative (§ extends ITransientCollection, ILookup)
    (§ abstract ITransientAssociative assoc(Object key, Object val))
)
)

(java-ns cloiure.lang.ITransientAssociative2

(§ interface ITransientAssociative2 (§ extends ITransientAssociative)
    (§ abstract boolean containsKey(Object key))
    (§ abstract IMapEntry entryAt(Object key))
)
)

(java-ns cloiure.lang.ITransientCollection

(§ interface ITransientCollection
    (§ abstract ITransientCollection conj(Object val))
    (§ abstract IPersistentCollection persistent())
)
)

(java-ns cloiure.lang.ITransientMap

(§ interface ITransientMap (§ extends ITransientAssociative, Counted)
    (§ abstract ITransientMap assoc(Object key, Object val))
    (§ abstract ITransientMap without(Object key))
    (§ abstract IPersistentMap persistent())
)
)

(java-ns cloiure.lang.ITransientSet

(§ interface ITransientSet (§ extends ITransientCollection, Counted)
    (§ abstract ITransientSet disjoin(Object key))
    (§ abstract boolean contains(Object key))
    (§ abstract Object get(Object key))
)
)

(java-ns cloiure.lang.ITransientVector

(§ interface ITransientVector (§ extends ITransientAssociative, Indexed)
    (§ abstract ITransientVector assocN(int i, Object val))
    (§ abstract ITransientVector pop())
)
)

(java-ns cloiure.lang.IType

(§ interface IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (§ def- ConcurrentHashMap<Symbol, Reference<Keyword>> table = new ConcurrentHashMap())

    (§ def ReferenceQueue rq = new ReferenceQueue())

    (§ field Symbol sym)
    (§ field int hasheq)
    #_transient
    (§ field String _str)

    (§ defn Keyword intern(Symbol sym)
        (let [#_"Keyword" k nil]
            (let [#_"Reference<Keyword>" existingRef (ß table.get(sym))]
                (when (ß existingRef == nil)
                    (ß Util.clearCache(rq, table))
                    (when (ß sym.meta() != nil)
                        (ß sym = (Symbol) sym.withMeta(nil))
                    )
                    (ß k = new Keyword(sym))
                    (ß existingRef = table.putIfAbsent(sym, new WeakReference<Keyword>(k, rq)))
                )
                (when (ß existingRef == nil)
                    (§ return k)
                )
                (let [#_"Keyword" existingk (ß existingRef.get())]
                    (when (ß existingk != nil)
                        (§ return existingk)
                    )
                    ;; entry died in the interim, do over
                    (ß table.remove(sym, existingRef))
                    (ß intern(sym))
                )
            )
        )
    )

    (§ defn Keyword intern(String ns, String name)
        (ß intern(Symbol.intern(ns, name)))
    )

    (§ defn Keyword intern(String nsname)
        (ß intern(Symbol.intern(nsname)))
    )

    (§ constructor- Keyword(Symbol sym)
        (ß this.sym = sym)
        (ß hasheq = sym.hasheq() + 0x9e3779b9)
        this
    )

    (§ defn Keyword find(Symbol sym)
        (let [#_"Reference<Keyword>" ref (ß table.get(sym))]
            (if (ß ref != nil)
                (do
                    (ß ref.get())
                )
                (do
                    nil
                )
            )
        )
    )

    (§ defn Keyword find(String ns, String name)
        (ß find(Symbol.intern(ns, name)))
    )

    (§ defn Keyword find(String nsname)
        (ß find(Symbol.intern(nsname)))
    )

    (§ method int hashCode()
        (ß sym.hashCode() + 0x9e3779b9)
    )

    (§ method int hasheq()
        hasheq
    )

    (§ method String toString()
        (when (ß _str == nil)
            (ß _str = (":" + sym))
        )
        (ß _str)
    )

    (§ method Object throwArity()
        (throw (ß new IllegalArgumentException("Wrong number of args passed to keyword: " + toString())))
    )

    (§ method Object call()
        (ß throwArity())
    )

    (§ method void run()
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method Object invoke()
        (ß throwArity())
    )

    (§ method int compareTo(Object o)
        (ß sym.compareTo(((Keyword) o).sym))
    )

    (§ method String getNamespace()
        (ß sym.getNamespace())
    )

    (§ method String getName()
        (ß sym.getName())
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    (§ method Object invoke(Object obj)
        (when (ß obj instanceof ILookup)
            (§ return (ß ((ILookup)obj).valAt(this)))
        )
        (ß RT.get(obj, this))
    )

    (§ method Object invoke(Object obj, Object notFound)
        (when (ß obj instanceof ILookup)
            (§ return (ß ((ILookup)obj).valAt(this, notFound)))
        )
        (ß RT.get(obj, this, notFound))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß throwArity())
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
        (ß throwArity())
    )

    (§ method Object applyTo(ISeq arglist)
        (ß AFn.applyToHelper(this, arglist))
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (§ field Keyword k)

    (§ constructor KeywordLookupSite(Keyword k)
        (ß this.k = k)
        this
    )

    (§ method ILookupThunk fault(Object target)
        (cond (ß target instanceof IKeywordLookup)
            (do
                (§ return (ß install(target)))
            )
            (ß target instanceof ILookup)
            (do
                (§ return (ß ilookupThunk(target.getClass())))
            )
        )
        this
    )

    (§ method Object get(Object target)
        (when (ß target instanceof IKeywordLookup || target instanceof ILookup)
            (§ return this)
        )
        (ß RT.get(target, k))
    )

    (§ method- ILookupThunk ilookupThunk(Class c)
        (ß new ILookupThunk()
            (§ reify
                (§ method Object get(Object target)
                    (when (ß target != nil && target.getClass() == c)
                        (§ return (ß ((ILookup) target).valAt(k)))
                    )
                    this
                )
            )
        )
    )

    (§ method- ILookupThunk install(Object target)
        (let [#_"ILookupThunk" t (ß ((IKeywordLookup)target).getLookupThunk(k))]
            (when (ß t != nil)
                (§ return t)
            )
            (ß ilookupThunk(target.getClass()))
        )
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

(class-ns LazilyPersistentVector
    (§ defn IPersistentVector createOwning(Object... items)
        (when (ß items.length <= 32)
            (§ return (ß new PersistentVector(items.length, 5, PersistentVector.EMPTY_NODE, items)))
        )
        (ß PersistentVector.create(items))
    )

    (§ defn int fcount(Object c)
        (when (ß c instanceof Counted)
            (§ return (ß ((Counted) c).count()))
        )
        (ß ((Collection)c).size())
    )

    (§ defn IPersistentVector create(Object obj)
        (cond (ß obj instanceof IReduceInit)
            (do
                (ß PersistentVector.create((IReduceInit) obj))
            )
            (ß obj instanceof ISeq)
            (do
                (ß PersistentVector.create(RT.seq(obj)))
            )
            (ß obj instanceof Iterable)
            (do
                (ß PersistentVector.create((Iterable)obj))
            )
            :else
            (do
                (ß createOwning(RT.toArray(obj)))
            )
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (§ field- IFn fn)
    (§ field- Object sv)
    (§ field- ISeq s)

    (§ constructor LazySeq(IFn fn)
        (ß this.fn = fn)
        this
    )

    (§ constructor- LazySeq(IPersistentMap meta, ISeq s)
        (§ super(meta))
        (ß this.fn = nil)
        (ß this.s = s)
        this
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (ß new LazySeq(meta, seq()))
    )

    (§ method Object sval()
        (§ sync this
            (when (ß fn != nil)
                (ß sv = fn.invoke())
                (ß fn = nil)
            )
            (when (ß sv != nil)
                (§ return sv)
            )
            s
        )
    )

    (§ method ISeq seq()
        (§ sync this
            (ß sval())
            (when (ß sv != nil)
                (let [#_"Object" ls sv]
                    (ß sv = nil)
                    (while (ß ls instanceof LazySeq)
                        (ß ls = ((LazySeq)ls).sval())
                    )
                    (ß s = RT.seq(ls))
                )
            )
            s
        )
    )

    (§ method int count()
        (let [#_"int" c 0]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                (ß ++c)
            )
            c
        )
    )

    (§ method Object first()
        (ß seq())
        (when (ß s == nil)
            (§ return nil)
        )
        (ß s.first())
    )

    (§ method ISeq next()
        (ß seq())
        (when (ß s == nil)
            (§ return nil)
        )
        (ß s.next())
    )

    (§ method ISeq more()
        (ß seq())
        (when (ß s == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß s.more())
    )

    (§ method ISeq cons(Object o)
        (ß RT.cons(o, seq()))
    )

    (§ method IPersistentCollection empty()
        (ß PersistentList.EMPTY)
    )

    (§ method boolean equiv(Object o)
        (let [#_"ISeq" s (ß seq())]
            (if (ß s != nil)
                (do
                    (ß s.equiv(o))
                )
                (do
                    (ß (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)
                )
            )
        )
    )

    (§ method int hashCode()
        (let [#_"ISeq" s (ß seq())]
            (when (ß s == nil)
                (§ return 1)
            )
            (ß Util.hash(s))
        )
    )

    (§ method int hasheq()
        (ß Murmur3.hashOrdered(this))
    )

    (§ method boolean equals(Object o)
        (let [#_"ISeq" s (ß seq())]
            (if (ß s != nil)
                (do
                    (ß s.equals(o))
                )
                (do
                    (ß (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)
                )
            )
        )
    )

    (§ method Object[] toArray()
        (ß RT.seqToArray(seq()))
    )

    (§ method boolean add(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean remove(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean addAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method void clear()
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean retainAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean removeAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean containsAll(Collection c)
        (doseq [#_"Object" o c]
            (when (ß !contains(o))
                (§ return false)
            )
        )
        true
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (seq() == nil))
    )

    (§ method boolean contains(Object o)
        (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    (§ method Iterator iterator()
        (ß new SeqIterator(this))
    )

    (§ method- List reify()
        (ß new ArrayList(this))
    )

    (§ method List subList(int fromIndex, int toIndex)
        (ß reify().subList(fromIndex, toIndex))
    )

    (§ method Object set(int index, Object element)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method Object remove(int index)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method int indexOf(Object o)
        (let [#_"ISeq" s (ß seq())]
            (loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
                (when (ß Util.equiv(s.first(), o))
                    (§ return i)
                )
            )
            -1
        )
    )

    (§ method int lastIndexOf(Object o)
        (ß reify().lastIndexOf(o))
    )

    (§ method ListIterator listIterator()
        (ß reify().listIterator())
    )

    (§ method ListIterator listIterator(int index)
        (ß reify().listIterator(index))
    )

    (§ method Object get(int index)
        (ß RT.nth(this, index))
    )

    (§ method void add(int index, Object element)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean addAll(int index, Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean isRealized()
        (§ sync this
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.

    (§ def- int newline = (int) \newline)

    (§ field- boolean _atLineStart = true)
    (§ field- boolean _prev)
    (§ field- int _columnNumber = 1)

    (§ constructor LineNumberingPushbackReader(Reader r)
        (§ super(new LineNumberReader(r)))
        this
    )

    (§ constructor LineNumberingPushbackReader(Reader r, int size)
        (§ super(new LineNumberReader(r, size)))
        this
    )

    (§ method int getLineNumber()
        (ß ((LineNumberReader) in).getLineNumber() + 1)
    )

    (§ method void setLineNumber(int line)
        (ß ((LineNumberReader) in).setLineNumber(line - 1))
        nil
    )

    (§ method int getColumnNumber()
        (ß _columnNumber)
    )

    (§ method int read() (§ throws IOException)
        (let [#_"int" c (ß super.read())]
            (ß _prev = _atLineStart)
            (if (ß (c == newline) || (c == -1))
                (do
                    (ß _atLineStart = true)
                    (ß _columnNumber = 1)
                )
                (do
                    (ß _atLineStart = false)
                    (ß _columnNumber++)
                )
            )
            c
        )
    )

    (§ method void unread(int c) (§ throws IOException)
        (ß super.unread(c))
        (ß _atLineStart = _prev)
        (ß _columnNumber--)
        nil
    )

    (§ method String readLine() (§ throws IOException)
        (let [#_"int" c (ß read())]
            (§ let [#_"String" line]
                (§ switch c
                    (§ case -1)
                    (do
                        (ß line = nil)
                        (§ break )
                    )
                    (§ case newline)
                    (do
                        (ß line = "")
                        (§ break )
                    )
                    (§ default )
                    (do
                        (let [#_"String" first (ß String.valueOf((char) c))]
                            (let [#_"String" rest (ß ((LineNumberReader)in).readLine())]
                                (ß line = (rest == nil) ? first :or first + rest)
                                (ß _prev = false)
                                (ß _atLineStart = true)
                                (ß _columnNumber = 1)
                                (§ break )
                            )
                        )
                    )
                )
                line
            )
        )
    )

    (§ method boolean atLineStart()
        (ß _atLineStart)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns LispReader
    (§ def Symbol QUOTE = Symbol.intern("quote"))
    (§ def Symbol THE_VAR = Symbol.intern("var"))

    (§ def Symbol UNQUOTE = Symbol.intern("cloiure.core", "unquote"))
    (§ def Symbol UNQUOTE_SPLICING = Symbol.intern("cloiure.core", "unquote-splicing"))
    (§ def Symbol CONCAT = Symbol.intern("cloiure.core", "concat"))
    (§ def Symbol SEQ = Symbol.intern("cloiure.core", "seq"))
    (§ def Symbol LIST = Symbol.intern("cloiure.core", "list"))
    (§ def Symbol APPLY = Symbol.intern("cloiure.core", "apply"))
    (§ def Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map"))
    (§ def Symbol HASHSET = Symbol.intern("cloiure.core", "hash-set"))
    (§ def Symbol VECTOR = Symbol.intern("cloiure.core", "vector"))
    (§ def Symbol WITH_META = Symbol.intern("cloiure.core", "with-meta"))
    (§ def Symbol META = Symbol.intern("cloiure.core", "meta"))
    (§ def Symbol DEREF = Symbol.intern("cloiure.core", "deref"))
    (§ def Symbol READ_COND = Symbol.intern("cloiure.core", "read-cond"))
    (§ def Symbol READ_COND_SPLICING = Symbol.intern("cloiure.core", "read-cond-splicing"))
    (§ def Keyword UNKNOWN = Keyword.intern(nil, "unknown"))

    (§ def IFn[] macros = new IFn[256])
    (§ def IFn[] dispatchMacros = new IFn[256])

    (§ def Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (§ def Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (§ def Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)"))
    (§ def Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    (§ def Var GENSYM_ENV = Var.create(nil).setDynamic())
    ;; sorted-map num->gensymbol
    (§ def Var ARG_ENV = Var.create(nil).setDynamic())
    (§ def IFn ctorReader = new CtorReader())

    ;; Dynamic var set to true in a read-cond context
    (§ def Var READ_COND_ENV = Var.create(nil).setDynamic())

    (§ static
        (ß macros[\"] = new StringReader()) ;; oops! "
        (ß macros[\;] = new CommentReader())
        (ß macros[\'] = new WrappingReader(QUOTE))
        (ß macros[\@] = new WrappingReader(DEREF))
        (ß macros[\^] = new MetaReader())
        (ß macros[\`] = new SyntaxQuoteReader())
        (ß macros[\~] = new UnquoteReader())
        (ß macros[\(] = new ListReader())
        (ß macros[\)] = new UnmatchedDelimiterReader())
        (ß macros[\[] = new VectorReader())
        (ß macros[\]] = new UnmatchedDelimiterReader())
        (ß macros[\{] = new MapReader())
        (ß macros[\}] = new UnmatchedDelimiterReader())
        (ß macros[\\] = new CharacterReader())
        (ß macros[\%] = new ArgReader())
        (ß macros[\#] = new DispatchReader())

        (ß dispatchMacros[\^] = new MetaReader())
        (ß dispatchMacros[\#] = new SymbolicValueReader())
        (ß dispatchMacros[\'] = new VarReader())
        (ß dispatchMacros[\"] = new RegexReader()) ;; oops! "
        (ß dispatchMacros[\(] = new FnReader())
        (ß dispatchMacros[\{] = new SetReader())
        (ß dispatchMacros[\=] = new EvalReader())
        (ß dispatchMacros[\!] = new CommentReader())
        (ß dispatchMacros[\<] = new UnreadableReader())
        (ß dispatchMacros[\_] = new DiscardReader())
        (ß dispatchMacros[\?] = new ConditionalReader())
        (ß dispatchMacros[\:] = new NamespaceMapReader())
    )

    (§ interface Resolver
        (§ abstract Symbol currentNS())
        (§ abstract Symbol resolveClass(Symbol sym))
        (§ abstract Symbol resolveAlias(Symbol sym))
        (§ abstract Symbol resolveVar(Symbol sym))
    )

    (§ defn boolean isWhitespace(int ch)
        (ß (Character.isWhitespace(ch) || ch == \,))
    )

    (§ defn void unread(PushbackReader r, int ch)
        (when (ß ch != -1)
            (try
                (ß r.unread(ch))
                (catch IOException e
                    (throw (ß Util.sneakyThrow(e)))
                )
            )
        )
        nil
    )

    (class-ns ReaderException (§ extends RuntimeException)
        (§ field int line)
        (§ field int column)

        (§ constructor ReaderException(int line, int column, Throwable cause)
            (§ super(cause))
            (ß this.line = line)
            (ß this.column = column)
            this
        )
    )

    (§ defn int read1(Reader r)
        (try
            (ß r.read())
            (catch IOException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    ;; Reader opts
    (§ def Keyword OPT_EOF = Keyword.intern(nil, "eof"))
    (§ def Keyword OPT_FEATURES = Keyword.intern(nil, "features"))
    (§ def Keyword OPT_READ_COND = Keyword.intern(nil, "read-cond"))

    ;; EOF special value to throw on eof
    (§ def Keyword EOFTHROW = Keyword.intern(nil, "eofthrow"))

    ;; Platform features - always installed
    (§ def- Keyword PLATFORM_KEY = Keyword.intern(nil, "cli"))
    (§ def- Object PLATFORM_FEATURES = PersistentHashSet.create(PLATFORM_KEY))

    ;; Reader conditional options - use with :read-cond
    (§ def Keyword COND_ALLOW = Keyword.intern(nil, "allow"))
    (§ def Keyword COND_PRESERVE = Keyword.intern(nil, "preserve"))

    (§ defn Object read(PushbackReader r, Object opts)
        (let [#_"boolean" eofIsError true]
            (let [#_"Object" eofValue nil]
                (when (ß opts != nil && opts instanceof IPersistentMap)
                    (let [#_"Object" eof (ß ((IPersistentMap)opts).valAt(OPT_EOF, EOFTHROW))]
                        (when (ß !EOFTHROW.equals(eof))
                            (ß eofIsError = false)
                            (ß eofValue = eof)
                        )
                    )
                )
                (ß read(r, eofIsError, eofValue, false, opts))
            )
        )
    )

    (§ defn Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive)
        (ß read(r, eofIsError, eofValue, isRecursive, PersistentHashMap.EMPTY))
    )

    (§ defn Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (ß read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, nil, (Resolver) RT.READER_RESOLVER.deref()))
    )

    (§ defn- Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts, Object pendingForms)
        (ß read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, ensurePending(pendingForms), (Resolver) RT.READER_RESOLVER.deref()))
    )

    (§ defn- Object ensurePending(Object pendingForms)
        (if (ß pendingForms == nil)
            (do
                (ß new LinkedList())
            )
            (do
                pendingForms
            )
        )
    )

    (§ defn- Object installPlatformFeature(Object opts)
        (if (ß opts == nil)
            (do
                (ß RT.mapUniqueKeys(LispReader.OPT_FEATURES, PLATFORM_FEATURES))
            )
            (do
                (let [#_"IPersistentMap" mopts (ß (IPersistentMap) opts)]
                    (let [#_"Object" features (ß mopts.valAt(OPT_FEATURES))]
                        (if (ß features == nil)
                            (do
                                (ß mopts.assoc(LispReader.OPT_FEATURES, PLATFORM_FEATURES))
                            )
                            (do
                                (ß mopts.assoc(LispReader.OPT_FEATURES, RT.conj((IPersistentSet) features, PLATFORM_KEY)))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- Object read(PushbackReader r, boolean eofIsError, Object eofValue, Character returnOn, Object returnOnValue, boolean isRecursive, Object opts, Object pendingForms, Resolver resolver)
        (when (ß RT.READEVAL.deref() == UNKNOWN)
            (throw (ß Util.runtimeException("Reading disallowed - *read-eval* bound to :unknown")))
        )

        (ß opts = installPlatformFeature(opts))

        (try
            (while true
                (when (ß pendingForms instanceof List && !((List)pendingForms).isEmpty())
                    (§ return (ß ((List)pendingForms).remove(0)))
                )

                (let [#_"int" ch (ß read1(r))]
                    (while (ß isWhitespace(ch))
                        (ß ch = read1(r))
                    )

                    (when (ß ch == -1)
                        (when eofIsError
                            (throw (ß Util.runtimeException("EOF while reading")))
                        )
                        (§ return eofValue)
                    )

                    (when (ß returnOn != nil && (returnOn.charValue() == ch))
                        (§ return returnOnValue)
                    )

                    (when (ß Character.isDigit(ch))
                        (let [#_"Object" n (ß readNumber(r, (char) ch))]
                            (§ return n)
                        )
                    )

                    (let [#_"IFn" macroFn (ß getMacro(ch))]
                        (when (ß macroFn != nil)
                            (let [#_"Object" ret (ß macroFn.invoke(r, (char) ch, opts, pendingForms))]
                                ;; no op macros return the reader
                                (when (ß ret == r)
                                    (§ continue )
                                )
                                (§ return ret)
                            )
                        )

                        (when (ß ch == \+ || ch == \-)
                            (let [#_"int" ch2 (ß read1(r))]
                                (when (ß Character.isDigit(ch2))
                                    (ß unread(r, ch2))
                                    (let [#_"Object" n (ß readNumber(r, (char) ch))]
                                        (§ return n)
                                    )
                                )
                                (ß unread(r, ch2))
                            )
                        )

                        (let [#_"String" token (ß readToken(r, (char) ch))]
                            (§ return (ß interpretToken(token, resolver)))
                        )
                    )
                )
            )
            (catch Exception e
                (when (ß isRecursive || !(r instanceof LineNumberingPushbackReader))
                    (throw (ß Util.sneakyThrow(e)))
                )
                (let [#_"LineNumberingPushbackReader" rdr (ß (LineNumberingPushbackReader) r)]
                    (throw (ß new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)))
                )
            )
        )
    )

    (§ defn- String readToken(PushbackReader r, char initch)
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (ß unread(r, ch))
                        (§ return (ß sb.toString()))
                    )
                    (ß sb.append((char) ch))
                )
            )
        )
    )

    (§ defn- Object readNumber(PushbackReader r, char initch)
        (let [#_"StringBuilder" sb (ß new StringBuilder())]
            (ß sb.append(initch))

            (while true
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                        (ß unread(r, ch))
                        (§ break )
                    )
                    (ß sb.append((char) ch))
                )
            )

            (let [#_"String" s (ß sb.toString())]
                (let [#_"Object" n (ß matchNumber(s))]
                    (when (ß n == nil)
                        (throw (ß new NumberFormatException("Invalid number: " + s)))
                    )
                    n
                )
            )
        )
    )

    (§ defn- int readUnicodeChar(String token, int offset, int length, int base)
        (when (ß token.length() != offset + length)
            (throw (ß new IllegalArgumentException("Invalid unicode character: \\" + token)))
        )
        (let [#_"int" uc 0]
            (loop-when-recur [(ß int i = offset)] (ß i < offset + length) [(ß ++i)]
                (let [#_"int" d (ß Character.digit(token.charAt(i), base))]
                    (when (ß d == -1)
                        (throw (ß new IllegalArgumentException("Invalid digit: " + token.charAt(i))))
                    )
                    (ß uc = uc * base + d)
                )
            )
            (ß (char) uc)
        )
    )

    (§ defn- int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
        (let [#_"int" uc (ß Character.digit(initch, base))]
            (when (ß uc == -1)
                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) initch)))
            )
            (let [#_"int" i 1]
                (loop-when-recur [(ß )] (ß i < length) [(ß ++i)]
                    (let [#_"int" ch (ß read1(r))]
                        (when (ß ch == -1 || isWhitespace(ch) || isMacro(ch))
                            (ß unread(r, ch))
                            (§ break )
                        )
                        (let [#_"int" d (ß Character.digit(ch, base))]
                            (when (ß d == -1)
                                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ch)))
                            )
                            (ß uc = uc * base + d)
                        )
                    )
                )
                (when (ß i != length && exact)
                    (throw (ß new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)))
                )
                uc
            )
        )
    )

    (§ defn- Object interpretToken(String s, Resolver resolver)
        (cond (ß s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß s.equals("true"))
            (do
                (§ return (ß RT.T))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß RT.F))
            )
        )
        (let [#_"Object" ret nil]
            (ß ret = matchSymbol(s, resolver))
            (when (ß ret != nil)
                (§ return ret)
            )

            (throw (ß Util.runtimeException("Invalid token: " + s)))
        )
    )

    (§ defn- Object matchSymbol(String s, Resolver resolver)
        (let [#_"Matcher" m (ß symbolPat.matcher(s))]
            (when (ß m.matches())
                (let [#_"int" gc (ß m.groupCount())]
                    (let [#_"String" ns (ß m.group(1))]
                        (let [#_"String" name (ß m.group(2))]
                            (when (ß ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß s.startsWith("::"))
                                (let [#_"Symbol" ks (ß Symbol.intern(s.substring(2)))]
                                    (if (ß resolver != nil)
                                        (do
                                            (§ let [#_"Symbol" nsym]
                                                (if (ß ks.ns != nil)
                                                    (do
                                                        (ß nsym = resolver.resolveAlias(Symbol.intern(ks.ns)))
                                                    )
                                                    (do
                                                        (ß nsym = resolver.currentNS())
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (ß nsym != nil)
                                                    (do
                                                        (§ return (ß Keyword.intern(nsym.name, ks.name)))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (§ let [#_"Namespace" kns]
                                                (if (ß ks.ns != nil)
                                                    (do
                                                        (ß kns = Compiler.currentNS().lookupAlias(Symbol.intern(ks.ns)))
                                                    )
                                                    (do
                                                        (ß kns = Compiler.currentNS())
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (ß kns != nil)
                                                    (do
                                                        (§ return (ß Keyword.intern(kns.name.name, ks.name)))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (let [#_"boolean" isKeyword (ß (s.charAt(0) == \:))]
                                (let [#_"Symbol" sym (ß Symbol.intern(s.substring(isKeyword ? 1 :or 0)))]
                                    (when isKeyword
                                        (§ return (ß Keyword.intern(sym)))
                                    )
                                    (§ return sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (§ defn- Object matchNumber(String s)
        (let [#_"Matcher" m (ß intPat.matcher(s))]
            (when (ß m.matches())
                (when (ß m.group(2) != nil)
                    (when (ß m.group(8) != nil)
                        (§ return (ß BigInt.ZERO))
                    )
                    (§ return (ß Numbers.num(0)))
                )
                (let [#_"boolean" negate (ß m.group(1).equals("-"))]
                    (§ let [#_"String" n]
                        (let [#_"int" radix 10]
                            (cond (ß (n = m.group(3)) != nil)
                                (do
                                    (ß radix = 10)
                                )
                                (ß (n = m.group(4)) != nil)
                                (do
                                    (ß radix = 16)
                                )
                                (ß (n = m.group(5)) != nil)
                                (do
                                    (ß radix = 8)
                                )
                                (ß (n = m.group(7)) != nil)
                                (do
                                    (ß radix = Integer.parseInt(m.group(6)))
                                )
                            )
                            (when (ß n == nil)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" bn (ß new BigInteger(n, radix))]
                                (when negate
                                    (ß bn = bn.negate())
                                )
                                (when (ß m.group(8) != nil)
                                    (§ return (ß BigInt.fromBigInteger(bn)))
                                )
                                (§ return (ß (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
                            )
                        )
                    )
                )
            )
            (ß m = floatPat.matcher(s))
            (when (ß m.matches())
                (when (ß m.group(4) != nil)
                    (§ return (ß new BigDecimal(m.group(1))))
                )
                (§ return (ß Double.parseDouble(s)))
            )
            (ß m = ratioPat.matcher(s))
            (when (ß m.matches())
                (let [#_"String" numerator (ß m.group(1))]
                    (when (ß numerator.startsWith("+"))
                        (ß numerator = numerator.substring(1))
                    )
                    (§ return (ß Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
                )
            )
            nil
        )
    )

    (§ defn- IFn getMacro(int ch)
        (when (ß ch < macros.length)
            (§ return (ß macros[ch]))
        )
        nil
    )

    (§ defn- boolean isMacro(int ch)
        (ß (ch < macros.length && macros[ch] != nil))
    )

    (§ defn- boolean isTerminatingMacro(int ch)
        (ß (ch != \# && ch != \' && ch != \% && isMacro(ch)))
    )

    (class-ns RegexReader (§ extends AFn)
        (§ def StringReader stringrdr = new StringReader())

        (§ method Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
            (let [#_"StringBuilder" sb (ß new StringBuilder())]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading regex")))
                        )
                        (ß sb.append((char) ch))
                        (when (ß ch == \\) ;; escape
                            (ß ch = read1(r))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading regex")))
                            )
                            (ß sb.append((char) ch))
                        )
                    )
                    (ß Pattern.compile(sb.toString()))
                )
            )
        )
    )

    (class-ns StringReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
            (let [#_"StringBuilder" sb (ß new StringBuilder())]
                (let [#_"Reader" r (ß (Reader) reader)]
                    (loop-when-recur [(ß int ch = read1(r))] (ß ch != \") [(ß ch = read1(r))] ;; oops! "
                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading string")))
                        )
                        (when (ß ch == \\) ;; escape
                            (ß ch = read1(r))
                            (when (ß ch == -1)
                                (throw (ß Util.runtimeException("EOF while reading string")))
                            )
                            (§ switch ch
                                (§ case \t)
                                (do
                                    (ß ch = \tab)
                                    (§ break )
                                )
                                (§ case \r)
                                (do
                                    (ß ch = \return)
                                    (§ break )
                                )
                                (§ case \n)
                                (do
                                    (ß ch = \newline)
                                    (§ break )
                                )
                                (§ case \\)
                                (do
                                    (§ break )
                                )
                                (§ case \") ;; oops! "
                                (do
                                    (§ break )
                                )
                                (§ case \b)
                                (do
                                    (ß ch = \backspace)
                                    (§ break )
                                )
                                (§ case \f)
                                (do
                                    (ß ch = \formfeed)
                                    (§ break )
                                )
                                (§ case \u)
                                (do
                                    (ß ch = read1(r))
                                    (when (ß Character.digit(ch, 16) == -1)
                                        (throw (ß Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)))
                                    )
                                    (ß ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (if (ß Character.isDigit(ch))
                                        (do
                                            (ß ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false))
                                            (when (ß ch > 0377)
                                                (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                            )
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("Unsupported escape character: \\" + (char) ch)))
                                        )
                                    )
                                    (§ break )
                                )
                            )
                        )
                        (ß sb.append((char) ch))
                    )
                    (ß sb.toString())
                )
            )
        )
    )

    (class-ns CommentReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object semicolon, Object opts, Object pendingForms)
            (let [#_"Reader" r (ß (Reader) reader)]
                (§ let [#_"int" ch]
                    (§ loop
                        (ß ch = read1(r))
                        (§ recur-if (ch != -1 && ch != \newline && ch != \return))
                    )
                    r
                )
            )
        )
    )

    (class-ns DiscardReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object underscore, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))
                r
            )
        )
    )

    ;; :a.b{:c 1} => {:a.b/c 1}
    ;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
    ;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
    (class-ns NamespaceMapReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object colon, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"boolean" auto false]
                    (let [#_"int" autoChar (ß read1(r))]
                        (if (ß autoChar == \:)
                            (do
                                (ß auto = true)
                            )
                            (do
                                (ß unread(r, autoChar))
                            )
                        )

                        (let [#_"Object" sym nil]
                            (let [#_"int" nextChar (ß read1(r))]
                                (cond (ß isWhitespace(nextChar)) ;; the #:: { } case or an error
                                    (do
                                        (if auto
                                            (do
                                                (while (ß isWhitespace(nextChar))
                                                    (ß nextChar = read1(r))
                                                )
                                                (when (ß nextChar != \{)
                                                    (ß unread(r, nextChar))
                                                    (throw (ß Util.runtimeException("Namespaced map must specify a namespace")))
                                                )
                                            )
                                            (do
                                                (ß unread(r, nextChar))
                                                (throw (ß Util.runtimeException("Namespaced map must specify a namespace")))
                                            )
                                        )
                                    )
                                    (ß nextChar != \{) ;; #:foo { } or #::foo { }
                                    (do
                                        (ß unread(r, nextChar))
                                        (ß sym = read(r, true, nil, false, opts, pendingForms))
                                        (ß nextChar = read1(r))
                                        (while (ß isWhitespace(nextChar))
                                            (ß nextChar = read1(r))
                                        )
                                    )
                                )
                                (when (ß nextChar != \{)
                                    (throw (ß Util.runtimeException("Namespaced map must specify a map")))
                                )

                                ;; Resolve autoresolved ns
                                (§ let [#_"String" ns]
                                    (cond auto
                                        (do
                                            (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                                                (cond (ß sym == nil)
                                                    (do
                                                        (if (ß resolver != nil)
                                                            (do
                                                                (ß ns = resolver.currentNS().name)
                                                            )
                                                            (do
                                                                (ß ns = Compiler.currentNS().getName().getName())
                                                            )
                                                        )
                                                    )
                                                    (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                                                    (do
                                                        (throw (ß Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)))
                                                    )
                                                    :else
                                                    (do
                                                        (§ let [#_"Symbol" resolvedNS]
                                                            (if (ß resolver != nil)
                                                                (do
                                                                    (ß resolvedNS = resolver.resolveAlias((Symbol) sym))
                                                                )
                                                                (do
                                                                    (let [#_"Namespace" rns (ß Compiler.currentNS().lookupAlias((Symbol)sym))]
                                                                        (ß resolvedNS = (rns != nil) ? rns.getName() :or nil)
                                                                    )
                                                                )
                                                            )

                                                            (if (ß resolvedNS == nil)
                                                                (do
                                                                    (throw (ß Util.runtimeException("Unknown auto-resolved namespace alias: " + sym)))
                                                                )
                                                                (do
                                                                    (ß ns = resolvedNS.getName())
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (ß !(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                                        (do
                                            (throw (ß Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)))
                                        )
                                        :else
                                        (do
                                            (ß ns = ((Symbol)sym).getName())
                                        )
                                    )

                                    ;; Read map
                                    (let [#_"List" kvs (ß readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)))]
                                        (when (ß (kvs.size() & 1) == 1)
                                            (throw (ß Util.runtimeException("Namespaced map literal must contain an even number of forms")))
                                        )

                                        ;; Construct output map
                                        (let [#_"Object[]" a (ß new Object[kvs.size()])]
                                            (let [#_"Iterator" iter (ß kvs.iterator())]
                                                (loop-when-recur [(ß int i = 0)] (ß iter.hasNext()) [(ß i += 2)]
                                                    (let [#_"Object" key (ß iter.next())]
                                                        (let [#_"Object" val (ß iter.next())]
                                                            (cond (ß key instanceof Keyword)
                                                                (do
                                                                    (let [#_"Keyword" kw (ß (Keyword) key)]
                                                                        (cond (ß kw.getNamespace() == nil)
                                                                            (do
                                                                                (ß key = Keyword.intern(ns, kw.getName()))
                                                                            )
                                                                            (ß kw.getNamespace().equals("_"))
                                                                            (do
                                                                                (ß key = Keyword.intern(nil, kw.getName()))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                (ß key instanceof Symbol)
                                                                (do
                                                                    (let [#_"Symbol" s (ß (Symbol) key)]
                                                                        (cond (ß s.getNamespace() == nil)
                                                                            (do
                                                                                (ß key = Symbol.intern(ns, s.getName()))
                                                                            )
                                                                            (ß s.getNamespace().equals("_"))
                                                                            (do
                                                                                (ß key = Symbol.intern(nil, s.getName()))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (ß a[i] = key)
                                                            (ß a[i + 1] = val)
                                                        )
                                                    )
                                                )
                                                (ß RT.map(a))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns SymbolicValueReader (§ extends AFn)
        (§ def IPersistentMap  specials = PersistentHashMap.create(
      #_map Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
      #_map Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
      #_map Symbol.intern("NaN"), Double.NaN
        ))

        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (when (ß !(o instanceof Symbol))
                        (throw (ß Util.runtimeException("Invalid token: ##" + o)))
                    )
                    (when (ß !(specials.containsKey(o)))
                        (throw (ß Util.runtimeException("Unknown symbolic value: ##" + o)))
                    )

                    (ß specials.valAt(o))
                )
            )
        )
    )

    (class-ns WrappingReader (§ extends AFn)
        (§ field Symbol sym)

        (§ constructor WrappingReader(Symbol sym)
            (ß this.sym = sym)
            this
        )

        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(sym, o))
                )
            )
        )
    )

    (class-ns DeprecatedWrappingReader (§ extends AFn)
        (§ field Symbol sym)
        (§ field String macro)

        (§ constructor DeprecatedWrappingReader(Symbol sym, String macro)
            (ß this.sym = sym)
            (ß this.macro = macro)
            this
        )

        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (ß System.out.println("WARNING: reader macro " + macro + " is deprecated; use " + sym.getName() + " instead"))
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(sym, o))
                )
            )
        )
    )

    (class-ns VarReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (ß RT.list(THE_VAR, o))
                )
            )
        )
    )

    (class-ns DispatchReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object hash, Object opts, Object pendingForms)
            (let [#_"int" ch (ß read1((Reader) reader))]
                (when (ß ch == -1)
                    (throw (ß Util.runtimeException("EOF while reading character")))
                )
                (let [#_"IFn" fn (ß dispatchMacros[ch])]
                    ;; Try the ctor reader first
                    (when (ß fn == nil)
                        (ß unread((PushbackReader) reader, ch))
                        (ß pendingForms = ensurePending(pendingForms))
                        (let [#_"Object" result (ß ctorReader.invoke(reader, ch, opts, pendingForms))]
                            (if (ß result != nil)
                                (do
                                    (§ return result)
                                )
                                (do
                                    (throw (ß Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))))
                                )
                            )
                        )
                    )
                    (ß fn.invoke(reader, ch, opts, pendingForms))
                )
            )
        )
    )

    (§ defn Symbol garg(int n)
        (ß Symbol.intern(nil, ((n == -1) ? "rest" :or ("p" + n)) + "__" + RT.nextID() + "#"))
    )

    (class-ns FnReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object lparen, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (when (ß ARG_ENV.deref() != nil)
                    (throw (ß new IllegalStateException("Nested #()s are not allowed")))
                )
                (try
                    (ß Var.pushThreadBindings(RT.map(ARG_ENV, PersistentTreeMap.EMPTY)))
                    (ß unread(r, \())
                    (let [#_"Object" form (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (let [#_"PersistentVector" args (ß PersistentVector.EMPTY)]
                            (let [#_"PersistentTreeMap" argsyms (ß (PersistentTreeMap) ARG_ENV.deref())]
                                (let [#_"ISeq" rargs (ß argsyms.rseq())]
                                    (when (ß rargs != nil)
                                        (let [#_"int" higharg (ß (Integer) ((Map.Entry) rargs.first()).getKey())]
                                            (when (ß higharg > 0)
                                                (loop-when-recur [(ß int i = 1)] (ß i <= higharg) [(ß ++i)]
                                                    (let [#_"Object" sym (ß argsyms.valAt(i))]
                                                        (when (ß sym == nil)
                                                            (ß sym = garg(i))
                                                        )
                                                        (ß args = args.cons(sym))
                                                    )
                                                )
                                            )
                                            (let [#_"Object" restsym (ß argsyms.valAt(-1))]
                                                (when (ß restsym != nil)
                                                    (ß args = args.cons(Compiler._AMP_))
                                                    (ß args = args.cons(restsym))
                                                )
                                            )
                                        )
                                    )
                                    (ß RT.list(Compiler.FN, args, form))
                                )
                            )
                        )
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn Symbol registerArg(int n)
        (let [#_"PersistentTreeMap" argsyms (ß (PersistentTreeMap) ARG_ENV.deref())]
            (when (ß argsyms == nil)
                (throw (ß new IllegalStateException("arg literal not in #()")))
            )
            (let [#_"Symbol" ret (ß (Symbol) argsyms.valAt(n))]
                (when (ß ret == nil)
                    (ß ret = garg(n))
                    (ß ARG_ENV.set(argsyms.assoc(n, ret)))
                )
                ret
            )
        )
    )

    (class-ns ArgReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object pct, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (when (ß ARG_ENV.deref() == nil)
                    (§ return (ß interpretToken(readToken(r, \%), nil)))
                )
                (let [#_"int" ch (ß read1(r))]
                    (ß unread(r, ch))
                    ;; % alone is first arg
                    (when (ß ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
                        (§ return (ß registerArg(1)))
                    )
                    (let [#_"Object" n (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (when (ß n.equals(Compiler._AMP_))
                            (§ return (ß registerArg(-1)))
                        )
                        (when (ß !(n instanceof Number))
                            (throw (ß new IllegalStateException("arg literal must be %, %& or %integer")))
                        )
                        (ß registerArg(((Number) n).intValue()))
                    )
                )
            )
        )
    )

    (class-ns MetaReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object caret, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                            (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
                        )
                        (ß pendingForms = ensurePending(pendingForms))
                        (let [#_"Object" meta (ß read(r, true, nil, true, opts, pendingForms))]
                            (cond (ß meta instanceof Symbol || meta instanceof String)
                                (do
                                    (ß meta = RT.map(RT.TAG_KEY, meta))
                                )
                                (ß meta instanceof Keyword)
                                (do
                                    (ß meta = RT.map(meta, RT.T))
                                )
                                (ß !(meta instanceof IPersistentMap))
                                (do
                                    (throw (ß new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")))
                                )
                            )

                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (if (ß o instanceof IMeta)
                                    (do
                                        (when (ß line != -1 && o instanceof ISeq)
                                            (ß meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column))
                                        )
                                        (when (ß o instanceof IReference)
                                            (ß ((IReference)o).resetMeta((IPersistentMap) meta))
                                            (§ return o)
                                        )
                                        (let [#_"Object" ometa (ß RT.meta(o))]
                                            (loop-when-recur [(ß ISeq s = RT.seq(meta))] (ß s != nil) [(ß s = s.next())]
                                                (let [#_"IMapEntry" kv (ß (IMapEntry) s.first())]
                                                    (ß ometa = RT.assoc(ometa, kv.getKey(), kv.getValue()))
                                                )
                                            )
                                            (ß ((IObj) o).withMeta((IPersistentMap) ometa))
                                        )
                                    )
                                    (do
                                        (throw (ß new IllegalArgumentException("Metadata can only be applied to IMetas")))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns SyntaxQuoteReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object backquote, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (try
                    (ß Var.pushThreadBindings(RT.map(GENSYM_ENV, PersistentHashMap.EMPTY)))

                    (let [#_"Object" form (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                        (ß syntaxQuote(form))
                    )
                    (finally
                        (ß Var.popThreadBindings())
                    )
                )
            )
        )

        (§ defn Object syntaxQuote(Object form)
            (§ let [#_"Object" ret]
                (cond (ß Compiler.isSpecial(form))
                    (do
                        (ß ret = RT.list(Compiler.QUOTE, form))
                    )
                    (ß form instanceof Symbol)
                    (do
                        (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                            (let [#_"Symbol" sym (ß (Symbol) form)]
                                (cond (ß sym.ns == nil && sym.name.endsWith("#"))
                                    (do
                                        (let [#_"IPersistentMap" gmap (ß (IPersistentMap) GENSYM_ENV.deref())]
                                            (when (ß gmap == nil)
                                                (throw (ß new IllegalStateException("Gensym literal not in syntax-quote")))
                                            )
                                            (let [#_"Symbol" gs (ß (Symbol) gmap.valAt(sym))]
                                                (when (ß gs == nil)
                                                    (ß GENSYM_ENV.set(gmap.assoc(sym, gs = Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1) + "__" + RT.nextID() + "__auto__"))))
                                                )
                                                (ß sym = gs)
                                            )
                                        )
                                    )
                                    (ß sym.ns == nil && sym.name.endsWith("."))
                                    (do
                                        (let [#_"Symbol" csym (ß Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1)))]
                                            (if (ß resolver != nil)
                                                (do
                                                    (let [#_"Symbol" rc (ß resolver.resolveClass(csym))]
                                                        (when (ß rc != nil)
                                                            (ß csym = rc)
                                                        )
                                                    )
                                                )
                                                (do
                                                    (ß csym = Compiler.resolveSymbol(csym))
                                                )
                                            )
                                            (ß sym = Symbol.intern(nil, csym.name.concat(".")))
                                        )
                                    )
                                    (ß sym.ns == nil && sym.name.startsWith("."))
                                    (do
                                        ;; Simply quote method names.
                                    )
                                    (ß resolver != nil)
                                    (do
                                        (let [#_"Symbol" nsym nil]
                                            (when (ß sym.ns != nil)
                                                (let [#_"Symbol" alias (ß Symbol.intern(nil, sym.ns))]
                                                    (ß nsym = resolver.resolveClass(alias))
                                                    (when (ß nsym == nil)
                                                        (ß nsym = resolver.resolveAlias(alias))
                                                    )
                                                )
                                            )
                                            (cond (ß nsym != nil)
                                                (do
                                                    ;; Classname/foo -> package.qualified.Classname/foo
                                                    (ß sym = Symbol.intern(nsym.name, sym.name))
                                                )
                                                (ß sym.ns == nil)
                                                (do
                                                    (let [#_"Symbol" rsym (ß resolver.resolveClass(sym))]
                                                        (when (ß rsym == nil)
                                                            (ß rsym = resolver.resolveVar(sym))
                                                        )
                                                        (if (ß rsym != nil)
                                                            (do
                                                                (ß sym = rsym)
                                                            )
                                                            (do
                                                                (ß sym = Symbol.intern(resolver.currentNS().name, sym.name))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            ;; leave alone if qualified
                                        )
                                    )
                                    :else
                                    (do
                                        (let [#_"Object" maybeClass nil]
                                            (when (ß sym.ns != nil)
                                                (ß maybeClass = Compiler.currentNS().getMapping(Symbol.intern(nil, sym.ns)))
                                            )
                                            (if (ß maybeClass instanceof Class)
                                                (do
                                                    ;; Classname/foo -> package.qualified.Classname/foo
                                                    (ß sym = Symbol.intern(((Class)maybeClass).getName(), sym.name))
                                                )
                                                (do
                                                    (ß sym = Compiler.resolveSymbol(sym))
                                                )
                                            )
                                        )
                                    )
                                )
                                (ß ret = RT.list(Compiler.QUOTE, sym))
                            )
                        )
                    )
                    (ß isUnquote(form))
                    (do
                        (§ return (ß RT.second(form)))
                    )
                    (ß isUnquoteSplicing(form))
                    (do
                        (throw (ß new IllegalStateException("splice not in list")))
                    )
                    (ß form instanceof IPersistentCollection)
                    (do
                        (cond (ß form instanceof IRecord)
                            (do
                                (ß ret = form)
                            )
                            (ß form instanceof IPersistentMap)
                            (do
                                (let [#_"IPersistentVector" keyvals (ß flattenMap(form))]
                                    (ß ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq())))))
                                )
                            )
                            (ß form instanceof IPersistentVector)
                            (do
                                (ß ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq())))))
                            )
                            (ß form instanceof IPersistentSet)
                            (do
                                (ß ret = RT.list(APPLY, HASHSET, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentSet) form).seq())))))
                            )
                            (ß form instanceof ISeq || form instanceof IPersistentList)
                            (do
                                (let [#_"ISeq" seq (ß RT.seq(form))]
                                    (if (ß seq == nil)
                                        (do
                                            (ß ret = RT.cons(LIST, nil))
                                        )
                                        (do
                                            (ß ret = RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq))))
                                        )
                                    )
                                )
                            )
                            :else
                            (do
                                (throw (ß new UnsupportedOperationException("Unknown Collection type")))
                            )
                        )
                    )
                    (ß form instanceof Keyword || form instanceof Number || form instanceof Character || form instanceof String)
                    (do
                        (ß ret = form)
                    )
                    :else
                    (do
                        (ß ret = RT.list(Compiler.QUOTE, form))
                    )
                )

                (when (ß form instanceof IObj && RT.meta(form) != nil)
                    ;; filter line and column numbers
                    (let [#_"IPersistentMap" newMeta (ß ((IObj) form).meta().without(RT.LINE_KEY).without(RT.COLUMN_KEY))]
                        (when (ß newMeta.count() > 0)
                            (§ return (ß RT.list(WITH_META, ret, syntaxQuote(((IObj) form).meta()))))
                        )
                    )
                )
                ret
            )
        )

        (§ defn- ISeq sqExpandList(ISeq seq)
            (let [#_"PersistentVector" ret (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß )] (ß seq != nil) [(ß seq = seq.next())]
                    (let [#_"Object" item (ß seq.first())]
                        (cond (ß isUnquote(item))
                            (do
                                (ß ret = ret.cons(RT.list(LIST, RT.second(item))))
                            )
                            (ß isUnquoteSplicing(item))
                            (do
                                (ß ret = ret.cons(RT.second(item)))
                            )
                            :else
                            (do
                                (ß ret = ret.cons(RT.list(LIST, syntaxQuote(item))))
                            )
                        )
                    )
                )
                (ß ret.seq())
            )
        )

        (§ defn- IPersistentVector flattenMap(Object form)
            (let [#_"IPersistentVector" keyvals (ß PersistentVector.EMPTY)]
                (loop-when-recur [(ß ISeq s = RT.seq(form))] (ß s != nil) [(ß s = s.next())]
                    (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                        (ß keyvals = (IPersistentVector) keyvals.cons(e.key()))
                        (ß keyvals = (IPersistentVector) keyvals.cons(e.val()))
                    )
                )
                keyvals
            )
        )
    )

    (§ defn boolean isUnquoteSplicing(Object form)
        (ß form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE_SPLICING))
    )

    (§ defn boolean isUnquote(Object form)
        (ß form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE))
    )

    (class-ns UnquoteReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object comma, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (ß pendingForms = ensurePending(pendingForms))
                    (if (ß ch == \@)
                        (do
                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (ß RT.list(UNQUOTE_SPLICING, o))
                            )
                        )
                        (do
                            (ß unread(r, ch))
                            (let [#_"Object" o (ß read(r, true, nil, true, opts, pendingForms))]
                                (ß RT.list(UNQUOTE, o))
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns CharacterReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object backslash, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )
                    (let [#_"String" token (ß readToken(r, (char) ch))]
                        (cond (ß token.length() == 1)
                            (do
                                (§ return (ß Character.valueOf(token.charAt(0))))
                            )
                            (ß token.equals("newline"))
                            (do
                                (§ return (ß \newline))
                            )
                            (ß token.equals("space"))
                            (do
                                (§ return (ß \space))
                            )
                            (ß token.equals("tab"))
                            (do
                                (§ return (ß \tab))
                            )
                            (ß token.equals("backspace"))
                            (do
                                (§ return (ß \backspace))
                            )
                            (ß token.equals("formfeed"))
                            (do
                                (§ return (ß \formfeed))
                            )
                            (ß token.equals("return"))
                            (do
                                (§ return (ß \return))
                            )
                            (ß token.startsWith("u"))
                            (do
                                (let [#_"char" c (ß (char) readUnicodeChar(token, 1, 4, 16))]
                                    (when (ß c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                                        (throw (ß Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))))
                                    )
                                    (§ return c)
                                )
                            )
                            (ß token.startsWith("o"))
                            (do
                                (let [#_"int" len (ß token.length() - 1)]
                                    (when (ß len > 3)
                                        (throw (ß Util.runtimeException("Invalid octal escape sequence length: " + len)))
                                    )
                                    (let [#_"int" uc (ß readUnicodeChar(token, 1, len, 8))]
                                        (when (ß uc > 0377)
                                            (throw (ß Util.runtimeException("Octal escape sequence must be in range [0, 377].")))
                                        )
                                        (§ return (ß (char) uc))
                                    )
                                )
                            )
                        )
                        (throw (ß Util.runtimeException("Unsupported character: \\" + token)))
                    )
                )
            )
        )
    )

    (class-ns ListReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" line -1]
                    (let [#_"int" column -1]
                        (when (ß r instanceof LineNumberingPushbackReader)
                            (ß line = ((LineNumberingPushbackReader) r).getLineNumber())
                            (ß column = ((LineNumberingPushbackReader) r).getColumnNumber()-1)
                        )
                        (let [#_"List" list (ß readDelimitedList(\), r, true, opts, ensurePending(pendingForms)))]
                            (when (ß list.isEmpty())
                                (§ return (ß PersistentList.EMPTY))
                            )
                            (let [#_"IObj" s (ß (IObj) PersistentList.create(list))]
                                (if (ß line != -1)
                                    (do
                                        (ß s.withMeta(RT.map(RT.LINE_KEY, line, RT.COLUMN_KEY, column)))
                                    )
                                    (do
                                        s
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (class-ns EvalReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object eq, Object opts, Object pendingForms)
            (when (ß !RT.booleanCast(RT.READEVAL.deref()))
                (throw (ß Util.runtimeException("EvalReader not allowed when *read-eval* is false.")))
            )

            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object" o (ß read(r, true, nil, true, opts, ensurePending(pendingForms)))]
                    (cond (ß o instanceof Symbol)
                        (do
                            (ß RT.classForName(o.toString()))
                        )
                        (ß o instanceof IPersistentList)
                        (do
                            (let [#_"Symbol" fs (ß (Symbol) RT.first(o))]
                                (when (ß fs.equals(THE_VAR))
                                    (let [#_"Symbol" vs (ß (Symbol) RT.second(o))]
                                        (§ return (ß RT.var(vs.ns, vs.name)))
                                    )
                                )
                                (when (ß fs.name.endsWith("."))
                                    (let [#_"Object[]" args (ß RT.toArray(RT.next(o)))]
                                        (§ return (ß Reflector.invokeConstructor(RT.classForName(fs.name.substring(0, fs.name.length() - 1)), args)))
                                    )
                                )
                                (when (ß Compiler.namesStaticMember(fs))
                                    (let [#_"Object[]" args (ß RT.toArray(RT.next(o)))]
                                        (§ return (ß Reflector.invokeStaticMethod(fs.ns, fs.name, args)))
                                    )
                                )
                                (let [#_"Object" v (ß Compiler.maybeResolveIn(Compiler.currentNS(), fs))]
                                    (when (ß v instanceof Var)
                                        (§ return (ß ((IFn) v).applyTo(RT.next(o))))
                                    )
                                    (throw (ß Util.runtimeException("Can't resolve " + fs)))
                                )
                            )
                        )
                        :else
                        (do
                            (throw (ß new IllegalArgumentException("Unsupported #= form")))
                        )
                    )
                )
            )
        )
    )

    (class-ns VectorReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß LazilyPersistentVector.create(readDelimitedList(\], r, true, opts, ensurePending(pendingForms))))
            )
        )
    )

    (class-ns MapReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"Object[]" a (ß readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)).toArray())]
                    (when (ß (a.length & 1) == 1)
                        (throw (ß Util.runtimeException("Map literal must contain an even number of forms")))
                    )
                    (ß RT.map(a))
                )
            )
        )
    )

    (class-ns SetReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftbracket, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts, ensurePending(pendingForms))))
            )
        )
    )

    (class-ns UnmatchedDelimiterReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object rightdelim, Object opts, Object pendingForms)
            (throw (ß Util.runtimeException("Unmatched delimiter: " + rightdelim)))
        )
    )

    (class-ns UnreadableReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object leftangle, Object opts, Object pendingForms)
            (throw (ß Util.runtimeException("Unreadable form")))
        )
    )

    ;; Sentinel values for reading lists
    (§ def- Object READ_EOF = new Object())
    (§ def- Object READ_FINISHED = new Object())

    (§ defn List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts, Object pendingForms)
        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
            (let [#_"ArrayList" a (ß new ArrayList())]
                (let [#_"Resolver" resolver (ß (Resolver) RT.READER_RESOLVER.deref())]
                    (while true
                        (let [#_"Object" form (ß read(r, false, READ_EOF, delim, READ_FINISHED, isRecursive, opts, pendingForms, resolver))]
                            (cond (ß form == READ_EOF)
                                (do
                                    (if (ß firstline < 0)
                                        (do
                                            (throw (ß Util.runtimeException("EOF while reading")))
                                        )
                                        (do
                                            (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                        )
                                    )
                                )
                                (ß form == READ_FINISHED)
                                (do
                                    (§ return a)
                                )
                            )

                            (ß a.add(form))
                        )
                    )
                )
            )
        )
    )

    (class-ns CtorReader (§ extends AFn)
        (§ method Object invoke(Object reader, Object firstChar, Object opts, Object pendingForms)
            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (ß pendingForms = ensurePending(pendingForms))
                (let [#_"Object" name (ß read(r, true, nil, false, opts, pendingForms))]
                    (when (ß !(name instanceof Symbol))
                        (throw (ß new RuntimeException("Reader tag must be a symbol")))
                    )
                    (let [#_"Symbol" sym (ß (Symbol)name)]
                        (let [#_"Object" form (ß read(r, true, nil, true, opts, pendingForms))]
                            (if (ß isPreserveReadCond(opts) || RT.suppressRead())
                                (do
                                    (ß TaggedLiteral.create(sym, form))
                                )
                                (do
                                    (ß sym.getName().contains(".") ? readRecord(form, sym, opts, pendingForms) :or readTagged(form, sym, opts, pendingForms))
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method- Object readTagged(Object o, Symbol tag, Object opts, Object pendingForms)
            (let [#_"ILookup" data_readers (ß (ILookup)RT.DATA_READERS.deref())]
                (let [#_"IFn" data_reader (ß (IFn)RT.get(data_readers, tag))]
                    (when (ß data_reader == nil)
                        (ß data_readers = (ILookup)RT.DEFAULT_DATA_READERS.deref())
                        (ß data_reader = (IFn)RT.get(data_readers, tag))
                        (when (ß data_reader == nil)
                            (let [#_"IFn" default_reader (ß (IFn)RT.DEFAULT_DATA_READER_FN.deref())]
                                (if (ß default_reader != nil)
                                    (do
                                        (§ return (ß default_reader.invoke(tag, o)))
                                    )
                                    (do
                                        (throw (ß new RuntimeException("No reader function for tag " + tag.toString())))
                                    )
                                )
                            )
                        )
                    )

                    (ß data_reader.invoke(o))
                )
            )
        )

        (§ method- Object readRecord(Object form, Symbol recordName, Object opts, Object pendingForms)
            (let [#_"boolean" readeval (ß RT.booleanCast(RT.READEVAL.deref()))]
                (when (ß !readeval)
                    (throw (ß Util.runtimeException("Record construction syntax can only be used when *read-eval* == true")))
                )

                (let [#_"Class" recordClass (ß RT.classForNameNonLoading(recordName.toString()))]
                    (let [#_"boolean" shortForm true]
                        (cond (ß form instanceof IPersistentMap)
                            (do
                                (ß shortForm = false)
                            )
                            (ß form instanceof IPersistentVector)
                            (do
                                (ß shortForm = true)
                            )
                            :else
                            (do
                                (throw (ß Util.runtimeException("Unreadable constructor form starting with \"#" + recordName + "\"")))
                            )
                        )

                        (let [#_"Object" ret nil]
                            (let [#_"Constructor[]" allctors (ß ((Class)recordClass).getConstructors())]
                                (if shortForm
                                    (do
                                        (let [#_"IPersistentVector" recordEntries (ß (IPersistentVector)form)]
                                            (let [#_"boolean" ctorFound false]
                                                (doseq [#_"Constructor" ctor allctors]
                                                    (when (ß ctor.getParameterTypes().length == recordEntries.count())
                                                        (ß ctorFound = true)
                                                    )
                                                )

                                                (when (ß !ctorFound)
                                                    (throw (ß Util.runtimeException("Unexpected number of constructor arguments to " + recordClass.toString() + ": got " + recordEntries.count())))
                                                )

                                                (ß ret = Reflector.invokeConstructor(recordClass, RT.toArray(recordEntries)))
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"IPersistentMap" vals (ß (IPersistentMap)form)]
                                            (loop-when-recur [(ß ISeq s = RT.keys(vals))] (ß s != nil) [(ß s = s.next())]
                                                (when (ß !(s.first() instanceof Keyword))
                                                    (throw (ß Util.runtimeException("Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " + s.first().toString())))
                                                )
                                            )
                                            (ß ret = Reflector.invokeStaticMethod(recordClass, "create", new Object[] (§ vals )))
                                        )
                                    )
                                )

                                ret
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn boolean isPreserveReadCond(Object opts)
        (if (ß RT.booleanCast(READ_COND_ENV.deref()) && opts instanceof IPersistentMap)
            (do
                (let [#_"Object" readCond (ß ((IPersistentMap) opts).valAt(OPT_READ_COND))]
                    (ß COND_PRESERVE.equals(readCond))
                )
            )
            (do
                false
            )
        )
    )

    (class-ns ConditionalReader (§ extends AFn)
        (§ def- Object READ_STARTED = new Object())
        (§ def Keyword DEFAULT_FEATURE = Keyword.intern(nil, "default"))
        (§ def IPersistentSet RESERVED_FEATURES = RT.set(Keyword.intern(nil, "else"), Keyword.intern(nil, "none")))

        (§ defn boolean hasFeature(Object feature, Object opts)
            (when (ß !(feature instanceof Keyword))
                (throw (ß Util.runtimeException("Feature should be a keyword: " + feature)))
            )

            (when (ß DEFAULT_FEATURE.equals(feature))
                (§ return true)
            )

            (let [#_"IPersistentSet" custom (ß (IPersistentSet) ((IPersistentMap)opts).valAt(OPT_FEATURES))]
                (ß (custom != nil && custom.contains(feature)))
            )
        )

        (§ defn Object readCondDelimited(PushbackReader r, boolean splicing, Object opts, Object pendingForms)
            (let [#_"Object" result (ß READ_STARTED)]
                (§ let [#_"Object" form] ;; The most recently ready form
                    (let [#_"boolean" toplevel (ß (pendingForms == nil))]
                        (ß pendingForms = ensurePending(pendingForms))

                        (let [#_"int" firstline (ß (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1)]
                            (while true
                                (when (ß result == READ_STARTED)
                                    ;; Read the next feature
                                    (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, nil))

                                    (cond (ß form == READ_EOF)
                                        (do
                                            (if (ß firstline < 0)
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading")))
                                                )
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                )
                                            )
                                        )
                                        (ß form == READ_FINISHED)
                                        (do
                                            (§ break ) ;; read-cond form is done
                                        )
                                    )

                                    (when (ß RESERVED_FEATURES.contains(form))
                                        (throw (ß Util.runtimeException("Feature name " + form + " is reserved.")))
                                    )

                                    (when (ß hasFeature(form, opts))
                                        ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                                        (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref()))

                                        (cond (ß form == READ_EOF)
                                            (do
                                                (if (ß firstline < 0)
                                                    (do
                                                        (throw (ß Util.runtimeException("EOF while reading")))
                                                    )
                                                    (do
                                                        (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                    )
                                                )
                                            )
                                            (ß form == READ_FINISHED)
                                            (do
                                                (if (ß firstline < 0)
                                                    (do
                                                        (throw (ß Util.runtimeException("read-cond requires an even number of forms.")))
                                                    )
                                                    (do
                                                        (throw (ß Util.runtimeException("read-cond starting on line " + firstline + " requires an even number of forms")))
                                                    )
                                                )
                                            )
                                            :else
                                            (do
                                                (ß result = form)
                                            )
                                        )
                                    )
                                )

                                ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                                (try
                                    (ß Var.pushThreadBindings(RT.map(RT.SUPPRESS_READ, RT.T)))
                                    (ß form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref()))

                                    (cond (ß form == READ_EOF)
                                        (do
                                            (if (ß firstline < 0)
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading")))
                                                )
                                                (do
                                                    (throw (ß Util.runtimeException("EOF while reading, starting at line " + firstline)))
                                                )
                                            )
                                        )
                                        (ß form == READ_FINISHED)
                                        (do
                                            (§ break )
                                        )
                                    )
                                    (finally
                                        (ß Var.popThreadBindings())
                                    )
                                )
                            )

                            (when (ß result == READ_STARTED) ;; no features matched
                                (§ return r)
                            )

                            (if splicing
                                (do
                                    (when (ß !(result instanceof List))
                                        (throw (ß Util.runtimeException("Spliced form list in read-cond-splicing must implement java.util.List")))
                                    )

                                    (when toplevel
                                        (throw (ß Util.runtimeException("Reader conditional splicing not allowed at the top level.")))
                                    )

                                    (ß ((List)pendingForms).addAll(0, (List)result))

                                    r
                                )
                                (do
                                    result
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ defn- void checkConditionalAllowed(Object opts)
            (let [#_"IPersistentMap" mopts (ß (IPersistentMap)opts)]
                (when (ß !(opts != nil && (COND_ALLOW.equals(mopts.valAt(OPT_READ_COND)) || COND_PRESERVE.equals(mopts.valAt(OPT_READ_COND)))))
                    (throw (ß Util.runtimeException("Conditional read not allowed")))
                )
                nil
            )
        )

        (§ method Object invoke(Object reader, Object mode, Object opts, Object pendingForms)
            (ß checkConditionalAllowed(opts))

            (let [#_"PushbackReader" r (ß (PushbackReader) reader)]
                (let [#_"int" ch (ß read1(r))]
                    (when (ß ch == -1)
                        (throw (ß Util.runtimeException("EOF while reading character")))
                    )

                    (let [#_"boolean" splicing false]
                        (when (ß ch == \@)
                            (ß splicing = true)
                            (ß ch = read1(r))
                        )

                        (while (ß isWhitespace(ch))
                            (ß ch = read1(r))
                        )

                        (when (ß ch == -1)
                            (throw (ß Util.runtimeException("EOF while reading character")))
                        )

                        (when (ß ch != \()
                            (throw (ß Util.runtimeException("read-cond body must be a list")))
                        )

                        (try
                            (ß Var.pushThreadBindings(RT.map(READ_COND_ENV, RT.T)))

                            (if (ß isPreserveReadCond(opts))
                                (do
                                    (let [#_"IFn" listReader (ß getMacro(ch))] ;; should always be a list
                                        (let [#_"Object" form (ß listReader.invoke(r, ch, opts, ensurePending(pendingForms)))]
                                            (ß ReaderConditional.create(form, splicing))
                                        )
                                    )
                                )
                                (do
                                    (ß readCondDelimited(r, splicing, opts, pendingForms))
                                )
                            )
                            (finally
                                (ß Var.popThreadBindings())
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(§ anno @SuppressWarnings((§ "SynchronizeOnNonFinalField" )))
(class-ns LockingTransaction
    (§ def int RETRY_LIMIT = 10000)
    (§ def int LOCK_WAIT_MSECS = 100)
    (§ def long BARGE_WAIT_NANOS = 10 * 1000000)

    (§ def int RUNNING = 0)
    (§ def int COMMITTING = 1)
    (§ def int RETRY = 2)
    (§ def int KILLED = 3)
    (§ def int COMMITTED = 4)

    (§ def ThreadLocal<LockingTransaction> transaction = new ThreadLocal<LockingTransaction>())

    (class-ns RetryEx (§ extends Error)
    )

    (class-ns AbortException (§ extends Exception)
    )

    (class-ns Info
        (§ field AtomicInteger status)
        (§ field long startPoint)
        (§ field CountDownLatch latch)

        (§ constructor Info(int status, long startPoint)
            (ß this.status = new AtomicInteger(status))
            (ß this.startPoint = startPoint)
            (ß this.latch = new CountDownLatch(1))
            this
        )

        (§ method boolean running()
            (let [#_"int" s (ß status.get())]
                (ß (s == RUNNING || s == COMMITTING))
            )
        )
    )

    (class-ns CFn
        (§ field IFn fn)
        (§ field ISeq args)

        (§ constructor CFn(IFn fn, ISeq args)
            (ß this.fn = fn)
            (ß this.args = args)
            this
        )
    )

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (§ def- AtomicLong lastPoint = new AtomicLong())

    (§ method void getReadPoint()
        (ß readPoint = lastPoint.incrementAndGet())
        nil
    )

    (§ method long getCommitPoint()
        (ß lastPoint.incrementAndGet())
    )

    (§ method void stop(int status)
        (when (ß info != nil)
            (§ sync info
                (ß info.status.set(status))
                (ß info.latch.countDown())
            )
            (ß info = nil)
            (ß vals.clear())
            (ß sets.clear())
            (ß commutes.clear())
        )
        nil
    )

    (§ field Info info)
    (§ field long readPoint)
    (§ field long startPoint)
    (§ field long startTime)

    (§ field RetryEx retryex = new RetryEx())
    (§ field ArrayList<Agent.Action> actions = new ArrayList<Agent.Action>())
    (§ field HashMap<Ref, Object> vals = new HashMap<Ref, Object>())
    (§ field HashSet<Ref> sets = new HashSet<Ref>())
    (§ field TreeMap<Ref, ArrayList<CFn>> commutes = new TreeMap<Ref, ArrayList<CFn>>())

    (§ field HashSet<Ref> ensures = new HashSet<Ref>()) ;; all hold readLock

    (§ method void tryWriteLock(Ref ref)
        (try
            (when (ß !ref.lock.writeLock().tryLock(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
                (throw retryex)
            )
            (catch InterruptedException e
                (throw retryex)
            )
        )
        nil
    )

    ;; returns the most recent val
    (§ method Object lock(Ref ref)
        ;; can't upgrade readLock, so release it
        (ß releaseIfEnsured(ref))

        (let [#_"boolean" unlocked true]
            (try
                (ß tryWriteLock(ref))
                (ß unlocked = false)

                (when (ß ref.tvals != nil && ref.tvals.point > readPoint)
                    (throw retryex)
                )
                (let [#_"Info" refinfo (ß ref.tinfo)]
                    ;; write lock conflict
                    (when (ß refinfo != nil && refinfo != info && refinfo.running())
                        (when (ß !barge(refinfo))
                            (ß ref.lock.writeLock().unlock())
                            (ß unlocked = true)
                            (§ return (ß blockAndBail(refinfo)))
                        )
                    )
                    (ß ref.tinfo = info)
                    (ß (ref.tvals == nil) ? nil :or ref.tvals.val)
                )
                (finally
                    (when (ß !unlocked)
                        (ß ref.lock.writeLock().unlock())
                    )
                )
            )
        )
    )

    (§ method- Object blockAndBail(Info refinfo)
        ;; stop prior to blocking
        (ß stop(RETRY))
        (try
            (ß refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
            (catch InterruptedException e
                ;; ignore
            )
        )
        (throw retryex)
    )

    (§ method- void releaseIfEnsured(Ref ref)
        (when (ß ensures.contains(ref))
            (ß ensures.remove(ref))
            (ß ref.lock.readLock().unlock())
        )
        nil
    )

    (§ method void abort() (§ throws AbortException)
        (ß stop(KILLED))
        (throw (ß new AbortException()))
    )

    (§ method- boolean bargeTimeElapsed()
        (ß (System.nanoTime() - startTime > BARGE_WAIT_NANOS))
    )

    (§ method- boolean barge(Info refinfo)
        (let [#_"boolean" barged false]
            ;; if this transaction is older, try to abort the other
            (when (ß bargeTimeElapsed() && startPoint < refinfo.startPoint)
                (ß barged = refinfo.status.compareAndSet(RUNNING, KILLED))
                (when barged
                    (ß refinfo.latch.countDown())
                )
            )
            barged
        )
    )

    (§ defn LockingTransaction getEx()
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (when (ß t == nil || t.info == nil)
                (throw (ß new IllegalStateException("No transaction running")))
            )
            t
        )
    )

    (§ defn boolean isRunning()
        (ß (getRunning() != nil))
    )

    (§ defn LockingTransaction getRunning()
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (when (ß t == nil || t.info == nil)
                (§ return nil)
            )
            t
        )
    )

    (§ defn Object runInTransaction(Callable fn) (§ throws Exception)
        (let [#_"LockingTransaction" t (ß transaction.get())]
            (§ let [#_"Object" ret]
                (if (ß t == nil)
                    (do
                        (ß transaction.set(t = new LockingTransaction()))
                        (try
                            (ß ret = t.run(fn))
                            (finally
                                (ß transaction.remove())
                            )
                        )
                    )
                    (do
                        (if (ß t.info != nil)
                            (do
                                (ß ret = fn.call())
                            )
                            (do
                                (ß ret = t.run(fn))
                            )
                        )
                    )
                )

                ret
            )
        )
    )

    (class-ns Notify
        (§ field Ref ref)
        (§ field Object oldval)
        (§ field Object newval)

        (§ constructor Notify(Ref ref, Object oldval, Object newval)
            (ß this.ref = ref)
            (ß this.oldval = oldval)
            (ß this.newval = newval)
            this
        )
    )

    (§ method Object run(Callable fn) (§ throws Exception)
        (let [#_"boolean" done false]
            (let [#_"Object" ret nil]
                (let [#_"ArrayList<Ref>" locked (ß new ArrayList<Ref>())]
                    (let [#_"ArrayList<Notify>" notify (ß new ArrayList<Notify>())]
                        (loop-when-recur [(ß int i = 0)] (ß !done && i < RETRY_LIMIT) [(ß i++)]
                            (try
                                (ß getReadPoint())
                                (when (ß i == 0)
                                    (ß startPoint = readPoint)
                                    (ß startTime = System.nanoTime())
                                )
                                (ß info = new Info(RUNNING, startPoint))
                                (ß ret = fn.call())
                                ;; make sure no one has killed us before this point, and can't from now on
                                (when (ß info.status.compareAndSet(RUNNING, COMMITTING))
                                    (doseq [#_"Map.Entry<Ref, ArrayList<CFn>>" (ß e commutes.entrySet())]
                                        (let [#_"Ref" ref (ß e.getKey())]
                                            (when (ß sets.contains(ref))
                                                (§ continue )
                                            )

                                            (let [#_"boolean" wasEnsured (ß ensures.contains(ref))]
                                                ;; can't upgrade readLock, so release it
                                                (ß releaseIfEnsured(ref))
                                                (ß tryWriteLock(ref))
                                                (ß locked.add(ref))
                                                (when (ß wasEnsured && ref.tvals != nil && ref.tvals.point > readPoint)
                                                    (throw retryex)
                                                )

                                                (let [#_"Info" refinfo (ß ref.tinfo)]
                                                    (when (ß refinfo != nil && refinfo != info && refinfo.running())
                                                        (when (ß !barge(refinfo))
                                                            (throw retryex)
                                                        )
                                                    )
                                                    (let [#_"Object" val (ß (ref.tvals == nil) ? nil :or ref.tvals.val)]
                                                        (ß vals.put(ref, val))
                                                        (doseq [#_"CFn" f (ß e.getValue())]
                                                            (ß vals.put(ref, f.fn.applyTo(RT.cons(vals.get(ref), f.args))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (doseq [#_"Ref" ref sets]
                                        (ß tryWriteLock(ref))
                                        (ß locked.add(ref))
                                    )

                                    ;; validate and enqueue notifications
                                    (doseq [#_"Map.Entry<Ref, Object>" (ß e vals.entrySet())]
                                        (let [#_"Ref" ref (ß e.getKey())]
                                            (ß ref.validate(ref.getValidator(), e.getValue()))
                                        )
                                    )

                                    ;; at this point, all values calced, all refs to be written locked
                                    ;; no more client code to be called
                                    (let [#_"long" commitPoint (ß getCommitPoint())]
                                        (doseq [#_"Map.Entry<Ref, Object>" (ß e vals.entrySet())]
                                            (let [#_"Ref" ref (ß e.getKey())]
                                                (let [#_"Object" oldval (ß (ref.tvals == nil) ? nil :or ref.tvals.val)]
                                                    (let [#_"Object" newval (ß e.getValue())]
                                                        (let [#_"int" hcount (ß ref.histCount())]
                                                            (cond (ß ref.tvals == nil)
                                                                (do
                                                                    (ß ref.tvals = new Ref.TVal(newval, commitPoint))
                                                                )
                                                                (ß (ref.faults.get() > 0 && hcount < ref.maxHistory) || hcount < ref.minHistory)
                                                                (do
                                                                    (ß ref.tvals = new Ref.TVal(newval, commitPoint, ref.tvals))
                                                                    (ß ref.faults.set(0))
                                                                )
                                                                :else
                                                                (do
                                                                    (ß ref.tvals = ref.tvals.next)
                                                                    (ß ref.tvals.val = newval)
                                                                    (ß ref.tvals.point = commitPoint)
                                                                )
                                                            )
                                                            (when (ß ref.getWatches().count() > 0)
                                                                (ß notify.add(new Notify(ref, oldval, newval)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        (ß done = true)
                                        (ß info.status.set(COMMITTED))
                                    )
                                )
                                (catch RetryEx retry
                                    ;; eat this so we retry rather than fall out
                                )
                                (finally
                                    (loop-when-recur [(ß int k = locked.size() - 1)] (ß k >= 0) [(ß --k)]
                                        (ß locked.get(k).lock.writeLock().unlock())
                                    )
                                    (ß locked.clear())
                                    (doseq [#_"Ref" r ensures]
                                        (ß r.lock.readLock().unlock())
                                    )
                                    (ß ensures.clear())
                                    (ß stop(done ? COMMITTED :or RETRY))
                                    (try
                                        (when done ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" n notify]
                                                (ß n.ref.notifyWatches(n.oldval, n.newval))
                                            )
                                            (doseq [#_"Agent.Action" action actions]
                                                (ß Agent.dispatchAction(action))
                                            )
                                        )
                                        (finally
                                            (ß notify.clear())
                                            (ß actions.clear())
                                        )
                                    )
                                )
                            )
                        )
                        (when (ß !done)
                            (throw (ß Util.runtimeException("Transaction failed after reaching retry limit")))
                        )
                        ret
                    )
                )
            )
        )
    )

    (§ method void enqueue(Agent.Action action)
        (ß actions.add(action))
        nil
    )

    (§ method Object doGet(Ref ref)
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß vals.containsKey(ref))
            (§ return (ß vals.get(ref)))
        )
        (try
            (ß ref.lock.readLock().lock())
            (when (ß ref.tvals == nil)
                (throw (ß new IllegalStateException(ref.toString() + " is unbound.")))
            )
            (let [(ß Ref.TVal ver = ref.tvals)]
                (§ loop
                    (when (ß ver.point <= readPoint)
                        (§ return (ß ver.val))
                    )
                    (§ recur-if ((ver = ver.prior) != ref.tvals))
                )
            )
            (finally
                (ß ref.lock.readLock().unlock())
            )
        )
        ;; no version of val precedes the read point
        (ß ref.faults.incrementAndGet())
        (throw retryex)
    )

    (§ method Object doSet(Ref ref, Object val)
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß commutes.containsKey(ref))
            (throw (ß new IllegalStateException("Can't set after commute")))
        )
        (when (ß !sets.contains(ref))
            (ß sets.add(ref))
            (ß lock(ref))
        )
        (ß vals.put(ref, val))
        val
    )

    (§ method void doEnsure(Ref ref)
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß ensures.contains(ref))
            (§ return nil)
        )
        (ß ref.lock.readLock().lock())

        ;; someone completed a write after our snapshot
        (when (ß ref.tvals != nil && ref.tvals.point > readPoint)
            (ß ref.lock.readLock().unlock())
            (throw retryex)
        )

        (let [#_"Info" refinfo (ß ref.tinfo)]
            ;; writer exists
            (if (ß refinfo != nil && refinfo.running())
                (do
                    (ß ref.lock.readLock().unlock())

                    (when (ß refinfo != info) ;; not us, ensure is doomed
                        (ß blockAndBail(refinfo))
                    )
                )
                (do
                    (ß ensures.add(ref))
                )
            )
            nil
        )
    )

    (§ method Object doCommute(Ref ref, IFn fn, ISeq args)
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß !vals.containsKey(ref))
            (let [#_"Object" val nil]
                (try
                    (ß ref.lock.readLock().lock())
                    (ß val = (ref.tvals == nil) ? nil :or ref.tvals.val)
                    (finally
                        (ß ref.lock.readLock().unlock())
                    )
                )
                (ß vals.put(ref, val))
            )
        )
        (let [#_"ArrayList<CFn>" fns (ß commutes.get(ref))]
            (when (ß fns == nil)
                (ß commutes.put(ref, fns = new ArrayList<CFn>()))
            )
            (ß fns.add(new CFn(fn, args)))
            (let [#_"Object" ret (ß fn.applyTo(RT.cons(vals.get(ref), args)))]
                (ß vals.put(ref, ret))
                ret
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (§ def- int CHUNK_SIZE = 32)

    ;; Invariants guarantee this is never an empty or infinite seq
    (§ field long start)
    (§ field long end)
    (§ field long step)
    (§ field BoundsCheck boundsCheck)

    #_volatile
    (§ field- LongChunk _chunk) ;; lazy
    #_volatile
    (§ field- ISeq _chunkNext) ;; lazy
    #_volatile
    (§ field- ISeq _next) ;; cached

    #_private
    (§ interface BoundsCheck
        (§ abstract boolean exceededBounds(long val))
    )

    (§ defn- BoundsCheck positiveStep(long end)
        (ß new BoundsCheck()
            (§ reify
                (§ method boolean exceededBounds(long val)
                    (ß (val >= end))
                )
            )
        )
    )

    (§ defn- BoundsCheck negativeStep(long end)
        (ß new BoundsCheck()
            (§ reify
                (§ method boolean exceededBounds(long val)
                    (ß (val <= end))
                )
            )
        )
    )

    (§ constructor- LongRange(long start, long end, long step, BoundsCheck boundsCheck)
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        this
    )

    (§ constructor- LongRange(long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ constructor- LongRange(IPersistentMap meta, long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
        (§ super(meta))
        (ß this.start = start)
        (ß this.end = end)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ defn ISeq create(long end)
        (when (ß end > 0)
            (§ return (ß new LongRange(0, end, 1, positiveStep(end))))
        )
        (ß PersistentList.EMPTY)
    )

    (§ defn ISeq create(long start, long end)
        (when (ß start >= end)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new LongRange(start, end, 1, positiveStep(end)))
    )

    (§ defn ISeq create(long start, long end, long step)
        (cond (ß step > 0)
            (do
                (when (ß end <= start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß new LongRange(start, end, step, positiveStep(end)))
            )
            (ß step < 0)
            (do
                (when (ß end >= start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß new LongRange(start, end, step, negativeStep(end)))
            )
            :else
            (do
                (when (ß end == start)
                    (§ return (ß PersistentList.EMPTY))
                )
                (ß Repeat.create(start))
            )
        )
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (when (ß meta == _meta)
            (§ return this)
        )
        (ß new LongRange(meta, start, end, step, boundsCheck, _chunk, _chunkNext))
    )

    (§ method Object first()
        start
    )

    (§ method void forceChunk()
        (when (ß _chunk != nil)
            (§ return nil)
        )

        (§ let [#_"long" count]
            (try
                (ß count = rangeCount(start, end, step))
                (catch ArithmeticException e
                    ;; size of total range is > Long.MAX_VALUE so must step to count
                    ;; this only happens in pathological range cases like:
                    ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                    (ß count = steppingCount(start, end, step))
                )
            )

            (cond (ß count > CHUNK_SIZE) ;; not last chunk
                (do
                    (let [#_"long" nextStart (ß start + (step * CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (ß _chunkNext = new LongRange(nextStart, end, step, boundsCheck))
                        (ß _chunk = new LongChunk(start, step, CHUNK_SIZE))
                    )
                )
                :else ;; last chunk
                (do
                    (ß _chunk = new LongChunk(start, step, (int) count)) ;; count must be <= CHUNK_SIZE
                )
            )
            nil
        )
    )

    (§ method ISeq next()
        (when (ß _next != nil)
            (§ return (ß _next))
        )

        (ß forceChunk())
        (when (ß _chunk.count() > 1)
            (let [#_"LongChunk" smallerChunk (ß _chunk.dropFirst())]
                (ß _next = new LongRange(smallerChunk.first(), end, step, boundsCheck, smallerChunk, _chunkNext))
                (§ return (ß _next))
            )
        )
        (ß chunkedNext())
    )

    (§ method IChunk chunkedFirst()
        (ß forceChunk())
        (ß _chunk)
    )

    (§ method ISeq chunkedNext()
        (ß chunkedMore().seq())
    )

    (§ method ISeq chunkedMore()
        (ß forceChunk())
        (when (ß _chunkNext == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _chunkNext)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    (§ method long steppingCount(long start, long end, long step)
        (let [#_"long" count 1]
            (let [#_"long" s start]
                (while (ß count <= CHUNK_SIZE)
                    (try
                        (ß s = Numbers.add(s, step))
                        (if (ß boundsCheck.exceededBounds(s))
                            (do
                                (§ break )
                            )
                            (do
                                (ß count++)
                            )
                        )
                        (catch ArithmeticException e
                            (§ break )
                        )
                    )
                )
                count
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    (§ method long rangeCount(long start, long end, long step)
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (ß Numbers.add(Numbers.add(Numbers.minus(end, start), step), (this.step > 0) ? -1 :or 1) / step)
    )

    (§ method int count()
        (try
            (let [#_"long" c (ß rangeCount(start, end, step))]
                (if (ß c > Integer.MAX_VALUE)
                    (do
                        (ß Numbers.throwIntOverflow())
                    )
                    (do
                        (ß (int) c)
                    )
                )
            )
            (catch ArithmeticException e
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"Iterator" iter (ß this.iterator())]
                    (let [#_"long" count 0]
                        (while (ß iter.hasNext())
                            (ß iter.next())
                            (ß count++)
                        )

                        (if (ß count > Integer.MAX_VALUE)
                            (do
                                (ß Numbers.throwIntOverflow())
                            )
                            (do
                                (ß (int)count)
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method Object reduce(IFn f)
        (let [#_"Object" acc start]
            (let [#_"long" i (ß start + step)]
                (while (ß !boundsCheck.exceededBounds(i))
                    (ß acc = f.invoke(acc, i))
                    (when (ß acc instanceof Reduced)
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (ß i += step)
                )
                acc
            )
        )
    )

    (§ method Object reduce(IFn f, Object val)
        (let [#_"Object" acc val]
            (let [#_"long" i start]
                (§ loop
                    (ß acc = f.invoke(acc, i))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (ß i += step)
                    (§ recur-if (!boundsCheck.exceededBounds(i)))
                )
                acc
            )
        )
    )

    (§ method Iterator iterator()
        (ß new LongRangeIterator())
    )

    #_non-static
    (class-ns LongRangeIterator (§ implements Iterator)
        (§ field- long next)
        (§ field- boolean hasNext)

        (§ constructor LongRangeIterator()
            (ß this.next = start)
            (ß this.hasNext = true)
            this
        )

        (§ method boolean hasNext()
            hasNext
        )

        (§ method Object next()
            (if hasNext
                (do
                    (let [#_"long" ret next]
                        (try
                            (ß next = Numbers.add(next, step))
                            (ß hasNext = !boundsCheck.exceededBounds(next))
                            (catch ArithmeticException e
                                (ß hasNext = false)
                            )
                        )
                        ret
                    )
                )
                (do
                    (throw (ß new NoSuchElementException()))
                )
            )
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException()))
        )
    )

    #_private
    (class-ns LongChunk (§ implements IChunk)
        (§ field long start)
        (§ field long step)
        (§ field int count)

        (§ constructor LongChunk(long start, long step, int count)
            (ß this.start = start)
            (ß this.step = step)
            (ß this.count = count)
            this
        )

        (§ method long first()
            start
        )

        (§ method Object nth(int i)
            (ß start + (i * step))
        )

        (§ method Object nth(int i, Object notFound)
            (when (ß i >= 0 && i < count)
                (§ return (ß start + (i * step)))
            )
            notFound
        )

        (§ method int count()
            count
        )

        (§ method LongChunk dropFirst()
            (when (ß count <= 1)
                (throw (ß new IllegalStateException("dropFirst of empty chunk")))
            )
            (ß new LongChunk(start + step, step, count - 1))
        )

        (§ method Object reduce(IFn f, Object init)
            (let [#_"long" x start]
                (let [#_"Object" ret init]
                    (loop-when-recur [(ß int i = 0)] (ß i < count) [(ß i++)]
                        (ß ret = f.invoke(ret, x))
                        (when (ß RT.isReduced(ret))
                            (§ return ret)
                        )
                        (ß x += step)
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (§ field Object _key)
    (§ field Object _val)

    (§ defn MapEntry create(Object key, Object val)
        (ß new MapEntry(key, val))
    )

    (§ constructor MapEntry(Object key, Object val)
        (ß this._key = key)
        (ß this._val = val)
        this
    )

    (§ method Object key()
        (ß _key)
    )

    (§ method Object val()
        (ß _val)
    )

    (§ method Object getKey()
        (ß key())
    )

    (§ method Object getValue()
        (ß val())
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(§ interface MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns MethodImplCache
    (class-ns Entry
        (§ field Class c)
        (§ field IFn fn)

        (§ constructor Entry(Class c, IFn fn)
            (ß this.c = c)
            (ß this.fn = fn)
            this
        )
    )

    (§ field IPersistentMap protocol)
    (§ field Keyword methodk)
    (§ field int shift)
    (§ field int mask)
    (§ field Object[] table) ;; [class, entry. class, entry ...]
    (§ field Map map)

    (§ field Entry mre = nil)

    (§ constructor MethodImplCache(IPersistentMap protocol, Keyword methodk)
        (§ this(protocol, methodk, 0, 0, RT.EMPTY_ARRAY))
        this
    )

    (§ constructor MethodImplCache(IPersistentMap protocol, Keyword methodk, int shift, int mask, Object[] table)
        (ß this.protocol = protocol)
        (ß this.methodk = methodk)
        (ß this.shift = shift)
        (ß this.mask = mask)
        (ß this.table = table)
        (ß this.map = nil)
        this
    )

    (§ constructor MethodImplCache(IPersistentMap protocol, Keyword methodk, Map map)
        (ß this.protocol = protocol)
        (ß this.methodk = methodk)
        (ß this.shift = 0)
        (ß this.mask = 0)
        (ß this.table = nil)
        (ß this.map = map)
        this
    )

    (§ method IFn fnFor(Class c)
        (let [#_"Entry" last mre]
            (when (ß last != nil && last.c == c)
                (§ return (ß last.fn))
            )
            (ß findFnFor(c))
        )
    )

    (§ method IFn findFnFor(Class c)
        (if (ß map != nil)
            (do
                (let [#_"Entry" e (ß (Entry) map.get(c))]
                    (ß mre = e)
                    (ß (e != nil) ? e.fn :or nil)
                )
            )
            (do
                (let [#_"int" idx (ß ((Util.hash(c) >> shift) & mask) << 1)]
                    (when (ß idx < table.length && table[idx] == c)
                        (let [#_"Entry" e (ß ((Entry) table[idx + 1]))]
                            (ß mre = e)
                            (§ return (ß (e != nil) ? e.fn :or nil))
                        )
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ field IFn dispatchFn)
    (§ field Object defaultDispatchVal)
    (§ field IRef hierarchy)
    (§ field String name)
    (§ field ReentrantReadWriteLock rw)

    #_volatile
    (§ field IPersistentMap methodTable)
    #_volatile
    (§ field IPersistentMap preferTable)
    #_volatile
    (§ field IPersistentMap methodCache)
    #_volatile
    (§ field Object cachedHierarchy)

    (§ def Var assoc = RT.var("cloiure.core", "assoc"))
    (§ def Var dissoc = RT.var("cloiure.core", "dissoc"))
    (§ def Var isa = RT.var("cloiure.core", "isa?"))
    (§ def Var parents = RT.var("cloiure.core", "parents"))

    (§ constructor MultiFn(String name, IFn dispatchFn, Object defaultDispatchVal, IRef hierarchy)
        (ß this.rw = new ReentrantReadWriteLock())
        (ß this.name = name)
        (ß this.dispatchFn = dispatchFn)
        (ß this.defaultDispatchVal = defaultDispatchVal)
        (ß this.methodTable = PersistentHashMap.EMPTY)
        (ß this.methodCache = getMethodTable())
        (ß this.preferTable = PersistentHashMap.EMPTY)
        (ß this.hierarchy = hierarchy)
        (ß cachedHierarchy = nil)
        this
    )

    (§ method MultiFn reset()
        (ß rw.writeLock().lock())
        (try
            (ß methodTable = methodCache = preferTable = PersistentHashMap.EMPTY)
            (ß cachedHierarchy = nil)
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    (§ method MultiFn addMethod(Object dispatchVal, IFn method)
        (ß rw.writeLock().lock())
        (try
            (ß methodTable = getMethodTable().assoc(dispatchVal, method))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    (§ method MultiFn removeMethod(Object dispatchVal)
        (ß rw.writeLock().lock())
        (try
            (ß methodTable = getMethodTable().without(dispatchVal))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    (§ method MultiFn preferMethod(Object dispatchValX, Object dispatchValY)
        (ß rw.writeLock().lock())
        (try
            (when (ß prefers(dispatchValY, dispatchValX))
                (throw (ß new IllegalStateException(String.format("Preference conflict in multimethod '%s': %s is already preferred to %s", name, dispatchValY, dispatchValX))))
            )
            (ß preferTable = getPreferTable().assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(getPreferTable(), dispatchValX, PersistentHashSet.EMPTY), dispatchValY)))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    (§ method- boolean prefers(Object x, Object y)
        (let [#_"IPersistentSet" xprefs (ß (IPersistentSet) getPreferTable().valAt(x))]
            (when (ß xprefs != nil && xprefs.contains(y))
                (§ return true)
            )
            (loop-when-recur [(ß ISeq ps = RT.seq(parents.invoke(y)))] (ß ps != nil) [(ß ps = ps.next())]
                (when (ß prefers(x, ps.first()))
                    (§ return true)
                )
            )
            (loop-when-recur [(ß ISeq ps = RT.seq(parents.invoke(x)))] (ß ps != nil) [(ß ps = ps.next())]
                (when (ß prefers(ps.first(), y))
                    (§ return true)
                )
            )
            false
        )
    )

    (§ method- boolean isA(Object x, Object y)
        (ß RT.booleanCast(isa.invoke(hierarchy.deref(), x, y)))
    )

    (§ method- boolean dominates(Object x, Object y)
        (ß prefers(x, y) || isA(x, y))
    )

    (§ method- IPersistentMap resetCache()
        (ß rw.writeLock().lock())
        (try
            (ß methodCache = getMethodTable())
            (ß cachedHierarchy = hierarchy.deref())
            methodCache
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    (§ method IFn getMethod(Object dispatchVal)
        (when (ß cachedHierarchy != hierarchy.deref())
            (ß resetCache())
        )
        (let [#_"IFn" targetFn (ß (IFn) methodCache.valAt(dispatchVal))]
            (when (ß targetFn != nil)
                (§ return targetFn)
            )
            (ß findAndCacheBestMethod(dispatchVal))
        )
    )

    (§ method- IFn getFn(Object dispatchVal)
        (let [#_"IFn" targetFn (ß getMethod(dispatchVal))]
            (when (ß targetFn == nil)
                (throw (ß new IllegalArgumentException(String.format("No method in multimethod '%s' for dispatch value: %s", name, dispatchVal))))
            )
            targetFn
        )
    )

    (§ method- IFn findAndCacheBestMethod(Object dispatchVal)
        (ß rw.readLock().lock())
        (§ let [#_"Object" bestValue]
            (let [#_"IPersistentMap" mt methodTable]
                (let [#_"IPersistentMap" pt preferTable]
                    (let [#_"Object" ch cachedHierarchy]
                        (try
                            (let [(ß Map.Entry bestEntry = nil)]
                                (doseq [#_"Object" o (ß getMethodTable())]
                                    (let [(ß Map.Entry e = (Map.Entry) o)]
                                        (when (ß isA(dispatchVal, e.getKey()))
                                            (when (ß bestEntry == nil || dominates(e.getKey(), bestEntry.getKey()))
                                                (ß bestEntry = e)
                                            )
                                            (when (ß !dominates(bestEntry.getKey(), e.getKey()))
                                                (throw (ß new IllegalArgumentException(String.format("Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", name, dispatchVal, e.getKey(), bestEntry.getKey()))))
                                            )
                                        )
                                    )
                                )
                                (if (ß bestEntry == nil)
                                    (do
                                        (ß bestValue = methodTable.valAt(defaultDispatchVal))
                                        (when (ß bestValue == nil)
                                            (§ return nil)
                                        )
                                    )
                                    (do
                                        (ß bestValue = bestEntry.getValue())
                                    )
                                )
                            )
                            (finally
                                (ß rw.readLock().unlock())
                            )
                        )

                        ;; ensure basis has stayed stable throughout, else redo
                        (ß rw.writeLock().lock())
                        (try
                            (if (ß mt == methodTable && pt == preferTable && ch == cachedHierarchy && cachedHierarchy == hierarchy.deref())
                                (do
                                    ;; place in cache
                                    (ß methodCache = methodCache.assoc(dispatchVal, bestValue))
                                    (ß (IFn) bestValue)
                                )
                                (do
                                    (ß resetCache())
                                    (ß findAndCacheBestMethod(dispatchVal))
                                )
                            )
                            (finally
                                (ß rw.writeLock().unlock())
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method Object invoke()
        (ß getFn(dispatchFn.invoke()).invoke())
    )

    (§ method Object invoke(Object arg1)
        (ß getFn(dispatchFn.invoke(arg1)).invoke(Util.ret1(arg1, arg1 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß getFn(dispatchFn.invoke(arg1, arg2)).
            invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3)).
            invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args)
        (ß getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20, args)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil),
                    args))
    )

    (§ method IPersistentMap getMethodTable()
        methodTable
    )

    (§ method IPersistentMap getPreferTable()
        preferTable
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
(class-ns Murmur3
    (§ def- int seed = 0)
    (§ def- int C1 = 0xcc9e2d51)
    (§ def- int C2 = 0x1b873593)

    (§ defn int hashInt(int input)
        (when (ß input == 0)
            (§ return 0)
        )
        (let [#_"int" k1 (ß mixK1(input))]
            (let [#_"int" h1 (ß mixH1(seed, k1))]
                (ß fmix(h1, 4))
            )
        )
    )

    (§ defn int hashLong(long input)
        (when (ß input == 0)
            (§ return 0)
        )
        (let [#_"int" low (ß (int) input)]
            (let [#_"int" high (ß (int) (input >>> 32))]
                (let [#_"int" k1 (ß mixK1(low))]
                    (let [#_"int" h1 (ß mixH1(seed, k1))]
                        (ß k1 = mixK1(high))
                        (ß h1 = mixH1(h1, k1))

                        (ß fmix(h1, 8))
                    )
                )
            )
        )
    )

    (§ defn int hashUnencodedChars(CharSequence input)
        (let [#_"int" h1 seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [(ß int i = 1)] (ß i < input.length()) [(ß i += 2)]
                (let [#_"int" k1 (ß input.charAt(i - 1) | (input.charAt(i) << 16))]
                    (ß k1 = mixK1(k1))
                    (ß h1 = mixH1(h1, k1))
                )
            )

            ;; deal with any remaining characters
            (when (ß (input.length() & 1) == 1)
                (let [#_"int" k1 (ß input.charAt(input.length() - 1))]
                    (ß k1 = mixK1(k1))
                    (ß h1 ^= k1)
                )
            )

            (ß fmix(h1, 2 * input.length()))
        )
    )

    (§ defn int mixCollHash(int hash, int count)
        (let [#_"int" h1 seed]
            (let [#_"int" k1 (ß mixK1(hash))]
                (ß h1 = mixH1(h1, k1))
                (ß fmix(h1, count))
            )
        )
    )

    (§ defn int hashOrdered(Iterable xs)
        (let [#_"int" n 0]
            (let [#_"int" hash 1]
                (doseq [#_"Object" x xs]
                    (ß hash = 31 * hash + Util.hasheq(x))
                    (ß ++n)
                )

                (ß mixCollHash(hash, n))
            )
        )
    )

    (§ defn int hashUnordered(Iterable xs)
        (let [#_"int" hash 0]
            (let [#_"int" n 0]
                (doseq [#_"Object" x xs]
                    (ß hash += Util.hasheq(x))
                    (ß ++n)
                )

                (ß mixCollHash(hash, n))
            )
        )
    )

    (§ defn- int mixK1(int k1)
        (ß k1 *= C1)
        (ß k1 = Integer.rotateLeft(k1, 15))
        (ß k1 *= C2)
        k1
    )

    (§ defn- int mixH1(int h1, int k1)
        (ß h1 ^= k1)
        (ß h1 = Integer.rotateLeft(h1, 13))
        (ß h1 = h1 * 5 + 0xe6546b64)
        h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (§ defn- int fmix(int h1, int length)
        (ß h1 ^= length)
        (ß h1 ^= h1 >>> 16)
        (ß h1 *= 0x85ebca6b)
        (ß h1 ^= h1 >>> 13)
        (ß h1 *= 0xc2b2ae35)
        (ß h1 ^= h1 >>> 16)
        h1
    )
)
)

(java-ns cloiure.lang.Named

(§ interface Named
    (§ abstract String getNamespace())
    (§ abstract String getName())
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (§ field Symbol name)

    #_transient
    (§ field AtomicReference<IPersistentMap> mappings = new AtomicReference<IPersistentMap>())
    #_transient
    (§ field AtomicReference<IPersistentMap> aliases = new AtomicReference<IPersistentMap>())

    (§ def ConcurrentHashMap<Symbol, Namespace> namespaces = new ConcurrentHashMap<Symbol, Namespace>())

    (§ method String toString()
        (ß name.toString())
    )

    (§ constructor Namespace(Symbol name)
        (§ super(name.meta()))
        (ß this.name = name)
        (ß mappings.set(RT.DEFAULT_IMPORTS))
        (ß aliases.set(RT.map()))
        this
    )

    (§ defn ISeq all()
        (ß RT.seq(namespaces.values()))
    )

    (§ method Symbol getName()
        name
    )

    (§ method IPersistentMap getMappings()
        (ß mappings.get())
    )

    (§ method Var intern(Symbol sym)
        (when (ß sym.ns != nil)
            (throw (ß new IllegalArgumentException("Can't intern namespace-qualified symbol")))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (§ let [#_"Object" o]
                (let [#_"Var" v nil]
                    (while (ß (o = map.valAt(sym)) == nil)
                        (when (ß v == nil)
                            (ß v = new Var(this, sym))
                        )
                        (let [#_"IPersistentMap" newMap (ß map.assoc(sym, v))]
                            (ß mappings.compareAndSet(map, newMap))
                            (ß map = getMappings())
                        )
                    )
                    (when (ß o instanceof Var && ((Var) o).ns == this)
                        (§ return (ß (Var) o))
                    )

                    (when (ß v == nil)
                        (ß v = new Var(this, sym))
                    )

                    (ß warnOrFailOnReplace(sym, o, v))

                    (while (ß !mappings.compareAndSet(map, map.assoc(sym, v)))
                        (ß map = getMappings())
                    )

                    v
                )
            )
        )
    )

    (§ method- void warnOrFailOnReplace(Symbol sym, Object o, Object v)
        (when (ß o instanceof Var)
            (let [#_"Namespace" ns (ß ((Var)o).ns)]
                (when (ß ns == this || (v instanceof Var && ((Var)v).ns  == RT.CLOIURE_NS))
                    (§ return nil)
                )
                (when (ß ns != RT.CLOIURE_NS)
                    (throw (ß new IllegalStateException(sym + " already refers to: " + o + " in namespace: " + name)))
                )
            )
        )
        (ß RT.errPrintWriter().println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name + ", being replaced by: " + v))
        nil
    )

    (§ method Object reference(Symbol sym, Object val)
        (when (ß sym.ns != nil)
            (throw (ß new IllegalArgumentException("Can't intern namespace-qualified symbol")))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (§ let [#_"Object" o]
                (while (ß (o = map.valAt(sym)) == nil)
                    (let [#_"IPersistentMap" newMap (ß map.assoc(sym, val))]
                        (ß mappings.compareAndSet(map, newMap))
                        (ß map = getMappings())
                    )
                )
                (when (ß o == val)
                    (§ return o)
                )

                (ß warnOrFailOnReplace(sym, o, val))

                (while (ß !mappings.compareAndSet(map, map.assoc(sym, val)))
                    (ß map = getMappings())
                )

                val
            )
        )
    )

    (§ defn boolean areDifferentInstancesOfSameClassName(Class cls1, Class cls2)
        (ß (cls1 != cls2) && (cls1.getName().equals(cls2.getName())))
    )

    (§ method Class referenceClass(Symbol sym, Class val)
        (when (ß sym.ns != nil)
            (throw (ß new IllegalArgumentException("Can't intern namespace-qualified symbol")))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (let [#_"Class" c (ß (Class) map.valAt(sym))]
                (while (ß (c == nil) || (areDifferentInstancesOfSameClassName(c, val)))
                    (let [#_"IPersistentMap" newMap (ß map.assoc(sym, val))]
                        (ß mappings.compareAndSet(map, newMap))
                        (ß map = getMappings())
                        (ß c = (Class) map.valAt(sym))
                    )
                )
                (when (ß c == val)
                    (§ return c)
                )

                (throw (ß new IllegalStateException(sym + " already refers to: " + c + " in namespace: " + name)))
            )
        )
    )

    (§ method void unmap(Symbol sym)
        (when (ß sym.ns != nil)
            (throw (ß new IllegalArgumentException("Can't unintern namespace-qualified symbol")))
        )
        (let [#_"IPersistentMap" map (ß getMappings())]
            (while (ß map.containsKey(sym))
                (let [#_"IPersistentMap" newMap (ß map.without(sym))]
                    (ß mappings.compareAndSet(map, newMap))
                    (ß map = getMappings())
                )
            )
            nil
        )
    )

    (§ method Class importClass(Symbol sym, Class c)
        (ß referenceClass(sym, c))
    )

    (§ method Class importClass(Class c)
        (let [#_"String" n (ß c.getName())]
            (ß importClass(Symbol.intern(n.substring(n.lastIndexOf(\.) + 1)), c))
        )
    )

    (§ method Var refer(Symbol sym, Var var)
        (ß (Var) reference(sym, var))
    )

    (§ defn Namespace findOrCreate(Symbol name)
        (let [#_"Namespace" ns (ß namespaces.get(name))]
            (when (ß ns != nil)
                (§ return ns)
            )
            (let [#_"Namespace" newns (ß new Namespace(name))]
                (ß ns = namespaces.putIfAbsent(name, newns))
                (ß (ns == nil) ? newns :or ns)
            )
        )
    )

    (§ defn Namespace remove(Symbol name)
        (when (ß name.equals(RT.CLOIURE_NS.name))
            (throw (ß new IllegalArgumentException("Cannot remove cloiure namespace")))
        )
        (ß namespaces.remove(name))
    )

    (§ defn Namespace find(Symbol name)
        (ß namespaces.get(name))
    )

    (§ method Object getMapping(Symbol name)
        (ß mappings.get().valAt(name))
    )

    (§ method Var findInternedVar(Symbol symbol)
        (let [#_"Object" o (ß mappings.get().valAt(symbol))]
            (when (ß o != nil && o instanceof Var && ((Var) o).ns == this)
                (§ return (ß (Var) o))
            )
            nil
        )
    )

    (§ method IPersistentMap getAliases()
        (ß aliases.get())
    )

    (§ method Namespace lookupAlias(Symbol alias)
        (let [#_"IPersistentMap" map (ß getAliases())]
            (ß (Namespace) map.valAt(alias))
        )
    )

    (§ method void addAlias(Symbol alias, Namespace ns)
        (when (ß alias == nil || ns == nil)
            (throw (ß new NullPointerException("Expecting Symbol + Namespace")))
        )
        (let [#_"IPersistentMap" map (ß getAliases())]
            (while (ß !map.containsKey(alias))
                (let [#_"IPersistentMap" newMap (ß map.assoc(alias, ns))]
                    (ß aliases.compareAndSet(map, newMap))
                    (ß map = getAliases())
                )
            )
            ;; you can rebind an alias, but only to the initially-aliased namespace.
            (when (ß !map.valAt(alias).equals(ns))
                (throw (ß new IllegalStateException("Alias " + alias + " already exists in namespace " + name + ", aliasing " + map.valAt(alias))))
            )
            nil
        )
    )

    (§ method void removeAlias(Symbol alias)
        (let [#_"IPersistentMap" map (ß getAliases())]
            (while (ß map.containsKey(alias))
                (let [#_"IPersistentMap" newMap (ß map.without(alias))]
                    (ß aliases.compareAndSet(map, newMap))
                    (ß map = getAliases())
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Numbers
    (§ interface Ops
        (§ abstract Ops combine(Ops y))
        (§ abstract Ops opsWith(LongOps x))
        (§ abstract Ops opsWith(DoubleOps x))
        (§ abstract Ops opsWith(RatioOps x))
        (§ abstract Ops opsWith(BigIntOps x))
        (§ abstract Ops opsWith(BigDecimalOps x))
        (§ abstract boolean isZero(Number x))
        (§ abstract boolean isPos(Number x))
        (§ abstract boolean isNeg(Number x))
        (§ abstract Number add(Number x, Number y))
        (§ abstract Number addP(Number x, Number y))
        (§ abstract Number multiply(Number x, Number y))
        (§ abstract Number multiplyP(Number x, Number y))
        (§ abstract Number divide(Number x, Number y))
        (§ abstract Number quotient(Number x, Number y))
        (§ abstract Number remainder(Number x, Number y))
        (§ abstract boolean equiv(Number x, Number y))
        (§ abstract boolean lt(Number x, Number y))
        (§ abstract boolean lte(Number x, Number y))
        (§ abstract boolean gte(Number x, Number y))
        (§ abstract Number negate(Number x))
        (§ abstract Number negateP(Number x))
        (§ abstract Number inc(Number x))
        (§ abstract Number incP(Number x))
        (§ abstract Number dec(Number x))
        (§ abstract Number decP(Number x))
    )

    #_abstract
    (class-ns OpsP (§ implements Ops)
        (§ method Number addP(Number x, Number y)
            (ß add(x, y))
        )

        (§ method Number multiplyP(Number x, Number y)
            (ß multiply(x, y))
        )

        (§ method Number negateP(Number x)
            (ß negate(x))
        )

        (§ method Number incP(Number x)
            (ß inc(x))
        )

        (§ method Number decP(Number x)
            (ß dec(x))
        )
    )

    (§ defn boolean isZero(Object x)
        (ß ops(x).isZero((Number)x))
    )

    (§ defn boolean isPos(Object x)
        (ß ops(x).isPos((Number)x))
    )

    (§ defn boolean isNeg(Object x)
        (ß ops(x).isNeg((Number)x))
    )

    (§ defn Number minus(Object x)
        (ß ops(x).negate((Number)x))
    )

    (§ defn Number minusP(Object x)
        (ß ops(x).negateP((Number)x))
    )

    (§ defn Number inc(Object x)
        (ß ops(x).inc((Number)x))
    )

    (§ defn Number incP(Object x)
        (ß ops(x).incP((Number)x))
    )

    (§ defn Number dec(Object x)
        (ß ops(x).dec((Number)x))
    )

    (§ defn Number decP(Object x)
        (ß ops(x).decP((Number)x))
    )

    (§ defn Number add(Object x, Object y)
        (ß ops(x).combine(ops(y)).add((Number)x, (Number)y))
    )

    (§ defn Number addP(Object x, Object y)
        (ß ops(x).combine(ops(y)).addP((Number)x, (Number)y))
    )

    (§ defn Number minus(Object x, Object y)
        (let [#_"Ops" yops (ß ops(y))]
            (ß ops(x).combine(yops).add((Number)x, yops.negate((Number)y)))
        )
    )

    (§ defn Number minusP(Object x, Object y)
        (let [#_"Ops" yops (ß ops(y))]
            (let [#_"Number" negativeY (ß yops.negateP((Number) y))]
                (let [#_"Ops" negativeYOps (ß ops(negativeY))]
                    (ß ops(x).combine(negativeYOps).addP((Number)x, negativeY))
                )
            )
        )
    )

    (§ defn Number multiply(Object x, Object y)
        (ß ops(x).combine(ops(y)).multiply((Number)x, (Number)y))
    )

    (§ defn Number multiplyP(Object x, Object y)
        (ß ops(x).combine(ops(y)).multiplyP((Number)x, (Number)y))
    )

    (§ defn Number divide(Object x, Object y)
        (cond (ß isNaN(x))
            (do
                (§ return (ß (Number)x))
            )
            (ß isNaN(y))
            (do
                (§ return (ß (Number)y))
            )
        )
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number)y))
                (throw (ß new ArithmeticException("Divide by zero")))
            )
            (ß ops(x).combine(yops).divide((Number)x, (Number)y))
        )
    )

    (§ defn Number quotient(Object x, Object y)
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number) y))
                (throw (ß new ArithmeticException("Divide by zero")))
            )
            (ß ops(x).combine(yops).quotient((Number)x, (Number)y))
        )
    )

    (§ defn Number remainder(Object x, Object y)
        (let [#_"Ops" yops (ß ops(y))]
            (when (ß yops.isZero((Number) y))
                (throw (ß new ArithmeticException("Divide by zero")))
            )
            (ß ops(x).combine(yops).remainder((Number)x, (Number)y))
        )
    )

    (§ defn double quotient(double n, double d)
        (when (ß d == 0)
            (throw (ß new ArithmeticException("Divide by zero")))
        )

        (let [#_"double" q (ß n / d)]
            (cond (ß q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
                (do
                    (ß (double)(long) q)
                )
                :else ;; bigint quotient
                (do
                    (ß new BigDecimal(q).toBigInteger().doubleValue())
                )
            )
        )
    )

    (§ defn double remainder(double n, double d)
        (when (ß d == 0)
            (throw (ß new ArithmeticException("Divide by zero")))
        )

        (let [#_"double" q (ß n / d)]
            (cond (ß q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
                (do
                    (ß (n - ((long) q) * d))
                )
                :else ;; bigint quotient
                (do
                    (let [#_"Number" bq (ß new BigDecimal(q).toBigInteger())]
                        (ß (n - bq.doubleValue() * d))
                    )
                )
            )
        )
    )

    (§ defn boolean equiv(Object x, Object y)
        (ß equiv((Number) x, (Number) y))
    )

    (§ defn boolean equiv(Number x, Number y)
        (ß ops(x).combine(ops(y)).equiv(x, y))
    )

    (§ defn boolean equal(Number x, Number y)
        (ß (category(x) == category(y) && ops(x).combine(ops(y)).equiv(x, y)))
    )

    (§ defn boolean lt(Object x, Object y)
        (ß ops(x).combine(ops(y)).lt((Number)x, (Number)y))
    )

    (§ defn boolean lte(Object x, Object y)
        (ß ops(x).combine(ops(y)).lte((Number)x, (Number)y))
    )

    (§ defn boolean gt(Object x, Object y)
        (ß ops(x).combine(ops(y)).lt((Number)y, (Number)x))
    )

    (§ defn boolean gte(Object x, Object y)
        (ß ops(x).combine(ops(y)).gte((Number)x, (Number)y))
    )

    (§ defn int compare(Number x, Number y)
        (let [#_"Ops" ops (ß ops(x).combine(ops(y)))]
            (cond (ß ops.lt(x, y))
                (do
                    (§ return -1)
                )
                (ß ops.lt(y, x))
                (do
                    (§ return 1)
                )
            )
            0
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn BigInt toBigInt(Object x)
        (when (ß x instanceof BigInt)
            (§ return (ß (BigInt) x))
        )
        (if (ß x instanceof BigInteger)
            (do
                (ß BigInt.fromBigInteger((BigInteger) x))
            )
            (do
                (ß BigInt.fromLong(((Number) x).longValue()))
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn BigInteger toBigInteger(Object x)
        (cond (ß x instanceof BigInteger)
            (do
                (ß (BigInteger) x)
            )
            (ß x instanceof BigInt)
            (do
                (ß ((BigInt) x).toBigInteger())
            )
            :else
            (do
                (ß BigInteger.valueOf(((Number) x).longValue()))
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn BigDecimal toBigDecimal(Object x)
        (cond (ß x instanceof BigDecimal)
            (do
                (ß (BigDecimal) x)
            )
            (ß x instanceof BigInt)
            (do
                (let [#_"BigInt" bi (ß (BigInt) x)]
                    (if (ß bi.bipart == nil)
                        (do
                            (ß BigDecimal.valueOf(bi.lpart))
                        )
                        (do
                            (ß new BigDecimal(bi.bipart))
                        )
                    )
                )
            )
            (ß x instanceof BigInteger)
            (do
                (ß new BigDecimal((BigInteger) x))
            )
            (ß x instanceof Double)
            (do
                (ß new BigDecimal(((Number) x).doubleValue()))
            )
            (ß x instanceof Float)
            (do
                (ß new BigDecimal(((Number) x).doubleValue()))
            )
            (ß x instanceof Ratio)
            (do
                (let [#_"Ratio" r (ß (Ratio)x)]
                    (ß (BigDecimal)divide(new BigDecimal(r.numerator), r.denominator))
                )
            )
            :else
            (do
                (ß BigDecimal.valueOf(((Number) x).longValue()))
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn Ratio toRatio(Object x)
        (cond (ß x instanceof Ratio)
            (do
                (§ return (ß (Ratio) x))
            )
            (ß x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (let [#_"BigInteger" bv (ß bx.unscaledValue())]
                        (let [#_"int" scale (ß bx.scale())]
                            (if (ß scale < 0)
                                (do
                                    (§ return (ß new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)), BigInteger.ONE)))
                                )
                                (do
                                    (§ return (ß new Ratio(bv, BigInteger.TEN.pow(scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        (ß new Ratio(toBigInteger(x), BigInteger.ONE))
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn Number rationalize(Number x)
        (cond (ß x instanceof Float || x instanceof Double)
            (do
                (§ return (ß rationalize(BigDecimal.valueOf(x.doubleValue()))))
            )
            (ß x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (let [#_"BigInteger" bv (ß bx.unscaledValue())]
                        (let [#_"int" scale (ß bx.scale())]
                            (if (ß scale < 0)
                                (do
                                    (§ return (ß BigInt.fromBigInteger(bv.multiply(BigInteger.TEN.pow(-scale)))))
                                )
                                (do
                                    (§ return (ß divide(bv, BigInteger.TEN.pow(scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        x
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn Number reduceBigInt(BigInt val)
        (if (ß val.bipart == nil)
            (do
                (ß num(val.lpart))
            )
            (do
                (ß val.bipart)
            )
        )
    )

    (§ defn Number divide(BigInteger n, BigInteger d)
        (when (ß d.equals(BigInteger.ZERO))
            (throw (ß new ArithmeticException("Divide by zero")))
        )
        (let [#_"BigInteger" gcd (ß n.gcd(d))]
            (when (ß gcd.equals(BigInteger.ZERO))
                (§ return (ß BigInt.ZERO))
            )
            (ß n = n.divide(gcd))
            (ß d = d.divide(gcd))
            (cond (ß d.equals(BigInteger.ONE))
                (do
                    (§ return (ß BigInt.fromBigInteger(n)))
                )
                (ß d.equals(BigInteger.ONE.negate()))
                (do
                    (§ return (ß BigInt.fromBigInteger(n.negate())))
                )
            )
            (ß new Ratio(((d.signum() < 0) ? n.negate() :or n), ((d.signum() < 0) ? d.negate() :or d)))
        )
    )

    (§ defn int shiftLeftInt(int x, int n)
        (ß x << n)
    )

    (§ defn long shiftLeft(Object x, Object y)
        (ß shiftLeft(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn long shiftLeft(Object x, long y)
        (ß shiftLeft(bitOpsCast(x), y))
    )
    (§ defn long shiftLeft(long x, Object y)
        (ß shiftLeft(x, bitOpsCast(y)))
    )
    (§ defn long shiftLeft(long x, long n)
        (ß x << n)
    )

    (§ defn int shiftRightInt(int x, int n)
        (ß x >> n)
    )

    (§ defn long shiftRight(Object x, Object y)
        (ß shiftRight(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn long shiftRight(Object x, long y)
        (ß shiftRight(bitOpsCast(x), y))
    )
    (§ defn long shiftRight(long x, Object y)
        (ß shiftRight(x, bitOpsCast(y)))
    )
    (§ defn long shiftRight(long x, long n)
        (ß x >> n)
    )

    (§ defn int unsignedShiftRightInt(int x, int n)
        (ß x >>> n)
    )

    (§ defn long unsignedShiftRight(Object x, Object y)
        (ß unsignedShiftRight(bitOpsCast(x), bitOpsCast(y)))
    )
    (§ defn long unsignedShiftRight(Object x, long y)
        (ß unsignedShiftRight(bitOpsCast(x), y))
    )
    (§ defn long unsignedShiftRight(long x, Object y)
        (ß unsignedShiftRight(x, bitOpsCast(y)))
    )
    (§ defn long unsignedShiftRight(long x, long n)
        (ß x >>> n)
    )

    (class-ns LongOps (§ implements Ops)
        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            (ß DOUBLE_OPS)
        )

        (§ method Ops opsWith(RatioOps x)
            (ß RATIO_OPS)
        )

        (§ method Ops opsWith(BigIntOps x)
            (ß BIGINT_OPS)
        )

        (§ method Ops opsWith(BigDecimalOps x)
            (ß BIGDECIMAL_OPS)
        )

        (§ method boolean isZero(Number x)
            (ß (x.longValue() == 0))
        )

        (§ method boolean isPos(Number x)
            (ß (x.longValue() > 0))
        )

        (§ method boolean isNeg(Number x)
            (ß (x.longValue() < 0))
        )

        (§ method Number add(Number x, Number y)
            (ß num(Numbers.add(x.longValue(), y.longValue())))
        )

        (§ method Number addP(Number x, Number y)
            (let [#_"long" lx (ß x.longValue(), ly = y.longValue())]
                (let [#_"long" ret (ß lx + ly)]
                    (when (ß (ret :xor lx) < 0 && (ret :xor ly) < 0)
                        (§ return (ß BIGINT_OPS.add(x, y)))
                    )
                    (ß num(ret))
                )
            )
        )

        (§ method Number multiply(Number x, Number y)
            (ß num(Numbers.multiply(x.longValue(), y.longValue())))
        )

        (§ method Number multiplyP(Number x, Number y)
            (let [#_"long" lx (ß x.longValue(), ly = y.longValue())]
                (when (ß lx == Long.MIN_VALUE && ly < 0)
                    (§ return (ß BIGINT_OPS.multiply(x, y)))
                )
                (let [#_"long" ret (ß lx * ly)]
                    (when (ß ly != 0 && ret / ly != lx)
                        (§ return (ß BIGINT_OPS.multiply(x, y)))
                    )
                    (ß num(ret))
                )
            )
        )

        (§ defn long gcd(long u, long v)
            (while (ß v != 0)
                (let [#_"long" r (ß u % v)]
                    (ß u = v)
                    (ß v = r)
                )
            )
            u
        )

        (§ method Number divide(Number x, Number y)
            (let [#_"long" n (ß x.longValue())]
                (let [#_"long" val (ß y.longValue())]
                    (let [#_"long" gcd (ß gcd(n, val))]
                        (when (ß gcd == 0)
                            (§ return (ß num(0)))
                        )

                        (ß n = n / gcd)
                        (let [#_"long" d (ß val / gcd)]
                            (when (ß d == 1)
                                (§ return (ß num(n)))
                            )
                            (when (ß d < 0)
                                (ß n = -n)
                                (ß d = -d)
                            )
                            (ß new Ratio(BigInteger.valueOf(n), BigInteger.valueOf(d)))
                        )
                    )
                )
            )
        )

        (§ method Number quotient(Number x, Number y)
            (ß num(x.longValue() / y.longValue()))
        )

        (§ method Number remainder(Number x, Number y)
            (ß num(x.longValue() % y.longValue()))
        )

        (§ method boolean equiv(Number x, Number y)
            (ß (x.longValue() == y.longValue()))
        )

        (§ method boolean lt(Number x, Number y)
            (ß (x.longValue() < y.longValue()))
        )

        (§ method boolean lte(Number x, Number y)
            (ß (x.longValue() <= y.longValue()))
        )

        (§ method boolean gte(Number x, Number y)
            (ß (x.longValue() >= y.longValue()))
        )

        (§ method Number negate(Number x)
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.minus(val)))
            )
        )

        (§ method Number negateP(Number x)
            (let [#_"long" val (ß x.longValue())]
                (when (ß val > Long.MIN_VALUE)
                    (§ return (ß num(-val)))
                )
                (ß BigInt.fromBigInteger(BigInteger.valueOf(val).negate()))
            )
        )

        (§ method Number inc(Number x)
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.inc(val)))
            )
        )

        (§ method Number incP(Number x)
            (let [#_"long" val (ß x.longValue())]
                (when (ß val < Long.MAX_VALUE)
                    (§ return (ß num(val + 1)))
                )
                (ß BIGINT_OPS.inc(x))
            )
        )

        (§ method Number dec(Number x)
            (let [#_"long" val (ß x.longValue())]
                (ß num(Numbers.dec(val)))
            )
        )

        (§ method Number decP(Number x)
            (let [#_"long" val (ß x.longValue())]
                (when (ß val > Long.MIN_VALUE)
                    (§ return (ß num(val - 1)))
                )
                (ß BIGINT_OPS.dec(x))
            )
        )
    )

    (class-ns DoubleOps (§ extends OpsP)
        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            this
        )

        (§ method Ops opsWith(RatioOps x)
            this
        )

        (§ method Ops opsWith(BigIntOps x)
            this
        )

        (§ method Ops opsWith(BigDecimalOps x)
            this
        )

        (§ method boolean isZero(Number x)
            (ß (x.doubleValue() == 0))
        )

        (§ method boolean isPos(Number x)
            (ß (x.doubleValue() > 0))
        )

        (§ method boolean isNeg(Number x)
            (ß (x.doubleValue() < 0))
        )

        (§ method Number add(Number x, Number y)
            (ß Double.valueOf(x.doubleValue() + y.doubleValue()))
        )

        (§ method Number multiply(Number x, Number y)
            (ß Double.valueOf(x.doubleValue() * y.doubleValue()))
        )

        (§ method Number divide(Number x, Number y)
            (ß Double.valueOf(x.doubleValue() / y.doubleValue()))
        )

        (§ method Number quotient(Number x, Number y)
            (ß Numbers.quotient(x.doubleValue(), y.doubleValue()))
        )

        (§ method Number remainder(Number x, Number y)
            (ß Numbers.remainder(x.doubleValue(), y.doubleValue()))
        )

        (§ method boolean equiv(Number x, Number y)
            (ß (x.doubleValue() == y.doubleValue()))
        )

        (§ method boolean lt(Number x, Number y)
            (ß (x.doubleValue() < y.doubleValue()))
        )

        (§ method boolean lte(Number x, Number y)
            (ß (x.doubleValue() <= y.doubleValue()))
        )

        (§ method boolean gte(Number x, Number y)
            (ß (x.doubleValue() >= y.doubleValue()))
        )

        (§ method Number negate(Number x)
            (ß Double.valueOf(-x.doubleValue()))
        )

        (§ method Number inc(Number x)
            (ß Double.valueOf(x.doubleValue() + 1))
        )

        (§ method Number dec(Number x)
            (ß Double.valueOf(x.doubleValue() - 1))
        )
    )

    (class-ns RatioOps (§ extends OpsP)
        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            (ß DOUBLE_OPS)
        )

        (§ method Ops opsWith(RatioOps x)
            this
        )

        (§ method Ops opsWith(BigIntOps x)
            this
        )

        (§ method Ops opsWith(BigDecimalOps x)
            (ß BIGDECIMAL_OPS)
        )

        (§ method boolean isZero(Number x)
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() == 0))
            )
        )

        (§ method boolean isPos(Number x)
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() > 0))
            )
        )

        (§ method boolean isNeg(Number x)
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß (r.numerator.signum() < 0))
            )
        )

        (§ defn Number normalizeRet(Number ret, Number x, Number y)
            ret
        )

        (§ method Number add(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß divide(ry.numerator.multiply(rx.denominator).add(rx.numerator.multiply(ry.denominator)), ry.denominator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        (§ method Number multiply(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß Numbers.divide(ry.numerator.multiply(rx.numerator), ry.denominator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        (§ method Number divide(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"Number" ret (ß Numbers.divide(ry.denominator.multiply(rx.numerator), ry.numerator.multiply(rx.denominator)))]
                        (ß normalizeRet(ret, x, y))
                    )
                )
            )
        )

        (§ method Number quotient(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"BigInteger" q (ß rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))]
                        (ß normalizeRet(BigInt.fromBigInteger(q), x, y))
                    )
                )
            )
        )

        (§ method Number remainder(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (let [#_"BigInteger" q (ß rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator)))]
                        (let [#_"Number" ret (ß Numbers.minus(x, Numbers.multiply(q, y)))]
                            (ß normalizeRet(ret, x, y))
                        )
                    )
                )
            )
        )

        (§ method boolean equiv(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß (rx.numerator.equals(ry.numerator) && rx.denominator.equals(ry.denominator)))
                )
            )
        )

        (§ method boolean lt(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.lt(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        (§ method boolean lte(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.lte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        (§ method boolean gte(Number x, Number y)
            (let [#_"Ratio" rx (ß toRatio(x))]
                (let [#_"Ratio" ry (ß toRatio(y))]
                    (ß Numbers.gte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator)))
                )
            )
        )

        (§ method Number negate(Number x)
            (let [#_"Ratio" r (ß (Ratio) x)]
                (ß new Ratio(r.numerator.negate(), r.denominator))
            )
        )

        (§ method Number inc(Number x)
            (ß Numbers.add(x, 1))
        )

        (§ method Number dec(Number x)
            (ß Numbers.add(x, -1))
        )
    )

    (class-ns BigIntOps (§ extends OpsP)
        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            (ß DOUBLE_OPS)
        )

        (§ method Ops opsWith(RatioOps x)
            (ß RATIO_OPS)
        )

        (§ method Ops opsWith(BigIntOps x)
            this
        )

        (§ method Ops opsWith(BigDecimalOps x)
            (ß BIGDECIMAL_OPS)
        )

        (§ method boolean isZero(Number x)
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart == 0)))
                )
                (ß (bx.bipart.signum() == 0))
            )
        )

        (§ method boolean isPos(Number x)
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart > 0)))
                )
                (ß (bx.bipart.signum() > 0))
            )
        )

        (§ method boolean isNeg(Number x)
            (let [#_"BigInt" bx (ß toBigInt(x))]
                (when (ß bx.bipart == nil)
                    (§ return (ß (bx.lpart < 0)))
                )
                (ß (bx.bipart.signum() < 0))
            )
        )

        (§ method Number add(Number x, Number y)
            (ß toBigInt(x).add(toBigInt(y)))
        )

        (§ method Number multiply(Number x, Number y)
            (ß toBigInt(x).multiply(toBigInt(y)))
        )

        (§ method Number divide(Number x, Number y)
            (ß Numbers.divide(toBigInteger(x), toBigInteger(y)))
        )

        (§ method Number quotient(Number x, Number y)
            (ß toBigInt(x).quotient(toBigInt(y)))
        )

        (§ method Number remainder(Number x, Number y)
            (ß toBigInt(x).remainder(toBigInt(y)))
        )

        (§ method boolean equiv(Number x, Number y)
            (ß toBigInt(x).equals(toBigInt(y)))
        )

        (§ method boolean lt(Number x, Number y)
            (ß toBigInt(x).lt(toBigInt(y)))
        )

        (§ method boolean lte(Number x, Number y)
            (ß (toBigInteger(x).compareTo(toBigInteger(y)) <= 0))
        )

        (§ method boolean gte(Number x, Number y)
            (ß (toBigInteger(x).compareTo(toBigInteger(y)) >= 0))
        )

        (§ method Number negate(Number x)
            (ß BigInt.fromBigInteger(toBigInteger(x).negate()))
        )

        (§ method Number inc(Number x)
            (let [#_"BigInteger" bx (ß toBigInteger(x))]
                (ß BigInt.fromBigInteger(bx.add(BigInteger.ONE)))
            )
        )

        (§ method Number dec(Number x)
            (let [#_"BigInteger" bx (ß toBigInteger(x))]
                (ß BigInt.fromBigInteger(bx.subtract(BigInteger.ONE)))
            )
        )
    )

    (class-ns BigDecimalOps (§ extends OpsP)
        (§ def Var MATH_CONTEXT = RT.MATH_CONTEXT)

        (§ method Ops combine(Ops y)
            (ß y.opsWith(this))
        )

        (§ method Ops opsWith(LongOps x)
            this
        )

        (§ method Ops opsWith(DoubleOps x)
            (ß DOUBLE_OPS)
        )

        (§ method Ops opsWith(RatioOps x)
            this
        )

        (§ method Ops opsWith(BigIntOps x)
            this
        )

        (§ method Ops opsWith(BigDecimalOps x)
            this
        )

        (§ method boolean isZero(Number x)
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() == 0))
            )
        )

        (§ method boolean isPos(Number x)
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() > 0))
            )
        )

        (§ method boolean isNeg(Number x)
            (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                (ß (bx.signum() < 0))
            )
        )

        (§ method Number add(Number x, Number y)
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).add(toBigDecimal(y)) :or toBigDecimal(x).add(toBigDecimal(y), mc))
            )
        )

        (§ method Number multiply(Number x, Number y)
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).multiply(toBigDecimal(y)) :or toBigDecimal(x).multiply(toBigDecimal(y), mc))
            )
        )

        (§ method Number divide(Number x, Number y)
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).divide(toBigDecimal(y)) :or toBigDecimal(x).divide(toBigDecimal(y), mc))
            )
        )

        (§ method Number quotient(Number x, Number y)
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).divideToIntegralValue(toBigDecimal(y)) :or toBigDecimal(x).divideToIntegralValue(toBigDecimal(y), mc))
            )
        )

        (§ method Number remainder(Number x, Number y)
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? toBigDecimal(x).remainder(toBigDecimal(y)) :or toBigDecimal(x).remainder(toBigDecimal(y), mc))
            )
        )

        (§ method boolean equiv(Number x, Number y)
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) == 0))
        )

        (§ method boolean lt(Number x, Number y)
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) < 0))
        )

        (§ method boolean lte(Number x, Number y)
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) <= 0))
        )

        (§ method boolean gte(Number x, Number y)
            (ß (toBigDecimal(x).compareTo(toBigDecimal(y)) >= 0))
        )

        (§ method Number negate(Number x)
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (ß (mc == nil) ? ((BigDecimal) x).negate() :or ((BigDecimal) x).negate(mc))
            )
        )

        (§ method Number inc(Number x)
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (ß (mc == nil) ? bx.add(BigDecimal.ONE) :or bx.add(BigDecimal.ONE, mc))
                )
            )
        )

        (§ method Number dec(Number x)
            (let [#_"MathContext" mc (ß (MathContext) MATH_CONTEXT.deref())]
                (let [#_"BigDecimal" bx (ß (BigDecimal) x)]
                    (ß (mc == nil) ? bx.subtract(BigDecimal.ONE) :or bx.subtract(BigDecimal.ONE, mc))
                )
            )
        )
    )

    (§ def LongOps LONG_OPS = new LongOps())
    (§ def DoubleOps DOUBLE_OPS = new DoubleOps())
    (§ def RatioOps RATIO_OPS = new RatioOps())
    (§ def BigIntOps BIGINT_OPS = new BigIntOps())
    (§ def BigDecimalOps BIGDECIMAL_OPS = new BigDecimalOps())

    (§ enum Category
        (§ item INTEGER),
        (§ item FLOATING),
        (§ item DECIMAL),
        (§ item RATIO)
    )

    (§ defn Ops ops(Object x)
        (let [#_"Class" xc (ß x.getClass())]
            (cond (ß xc == Long.class)
                (do
                    (ß LONG_OPS)
                )
                (ß xc == Double.class)
                (do
                    (ß DOUBLE_OPS)
                )
                (ß xc == Integer.class)
                (do
                    (ß LONG_OPS)
                )
                (ß xc == Float.class)
                (do
                    (ß DOUBLE_OPS)
                )
                (ß xc == BigInt.class)
                (do
                    (ß BIGINT_OPS)
                )
                (ß xc == BigInteger.class)
                (do
                    (ß BIGINT_OPS)
                )
                (ß xc == Ratio.class)
                (do
                    (ß RATIO_OPS)
                )
                (ß xc == BigDecimal.class)
                (do
                    (ß BIGDECIMAL_OPS)
                )
                :else
                (do
                    (ß LONG_OPS)
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int hasheqFrom(Number x, Class xc)
        (when (ß xc == Integer.class || xc == Short.class || xc == Byte.class || (xc == BigInteger.class && lte(x, Long.MAX_VALUE) && gte(x, Long.MIN_VALUE)))
            (let [#_"long" lpart (ß x.longValue())]
                (§ return (ß Murmur3.hashLong(lpart)))
            )
        )
        (when (ß xc == BigDecimal.class)
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode.  Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (if (ß isZero(x))
                (do
                    (§ return (ß BigDecimal.ZERO.hashCode()))
                )
                (do
                    (§ return (ß ((BigDecimal) x).stripTrailingZeros().hashCode()))
                )
            )
        )
        (when (ß xc == Float.class && x.equals((§ float -0.0)))
            (§ return 0) ;; match 0.0f
        )
        (ß x.hashCode())
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int hasheq(Number x)
        (let [#_"Class" xc (ß x.getClass())]
            (when (ß xc == Long.class)
                (let [#_"long" lpart (ß x.longValue())]
                    (§ return (ß Murmur3.hashLong(lpart)))
                )
            )
            (when (ß xc == Double.class)
                (when (ß x.equals(-0.0))
                    (§ return 0) ;; match 0.0
                )
                (§ return (ß x.hashCode()))
            )
            (ß hasheqFrom(x, xc))
        )
    )

    (§ defn Category category(Object x)
        (let [#_"Class" xc (ß x.getClass())]
            (cond (ß xc == Integer.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Double.class)
                (do
                    (ß Category.FLOATING)
                )
                (ß xc == Long.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Float.class)
                (do
                    (ß Category.FLOATING)
                )
                (ß xc == BigInt.class)
                (do
                    (ß Category.INTEGER)
                )
                (ß xc == Ratio.class)
                (do
                    (ß Category.RATIO)
                )
                (ß xc == BigDecimal.class)
                (do
                    (ß Category.DECIMAL)
                )
                :else
                (do
                    (ß Category.INTEGER)
                )
            )
        )
    )

    (§ defn long bitOpsCast(Object x)
        (let [#_"Class" xc (ß x.getClass())]
            (when (ß xc == Long.class || xc == Integer.class || xc == Short.class || xc == Byte.class)
                (§ return (ß RT.longCast(x)))
            )
            ;; no bignums, no decimals
            (throw (ß new IllegalArgumentException("bit operation not supported for: " + xc)))
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn float[] float_array(int size, Object init)
        (let [#_"float[]" ret (ß new float[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"float" f (ß ((Number) init).floatValue())]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).floatValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn float[] float_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new float[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"float[]" ret (ß new float[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).floatValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn double[] double_array(int size, Object init)
        (let [#_"double[]" ret (ß new double[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"double" f (ß ((Number) init).doubleValue())]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).doubleValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn double[] double_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new double[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"double[]" ret (ß new double[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).doubleValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int[] int_array(int size, Object init)
        (let [#_"int[]" ret (ß new int[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"int" f (ß ((Number) init).intValue())]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).intValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int[] int_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new int[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"int[]" ret (ß new int[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).intValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn long[] long_array(int size, Object init)
        (let [#_"long[]" ret (ß new long[size])]
            (if (ß init instanceof Number)
                (do
                    (let [#_"long" f (ß ((Number) init).longValue())]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).longValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn long[] long_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new long[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"long[]" ret (ß new long[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).longValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn short[] short_array(int size, Object init)
        (let [#_"short[]" ret (ß new short[size])]
            (if (ß init instanceof Short)
                (do
                    (let [#_"short" s (ß (Short) init)]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = s)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).shortValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn short[] short_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new short[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"short[]" ret (ß new short[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).shortValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn char[] char_array(int size, Object init)
        (let [#_"char[]" ret (ß new char[size])]
            (if (ß init instanceof Character)
                (do
                    (let [#_"char" c (ß (Character) init)]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = c)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = (Character) s.first())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn char[] char_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new char[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"char[]" ret (ß new char[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = (Character) s.first())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn byte[] byte_array(int size, Object init)
        (let [#_"byte[]" ret (ß new byte[size])]
            (if (ß init instanceof Byte)
                (do
                    (let [#_"byte" b (ß (Byte) init)]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = ((Number) s.first()).byteValue())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn byte[] byte_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new byte[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"byte[]" ret (ß new byte[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = ((Number) s.first()).byteValue())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn boolean[] boolean_array(int size, Object init)
        (let [#_"boolean[]" ret (ß new boolean[size])]
            (if (ß init instanceof Boolean)
                (do
                    (let [#_"boolean" b (ß (Boolean) init)]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++)]
                            (ß ret[i] = b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" s (ß RT.seq(init))]
                        (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                            (ß ret[i] = (Boolean)s.first())
                        )
                    )
                )
            )
            ret
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn boolean[] boolean_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new boolean[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"boolean[]" ret (ß new boolean[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = (Boolean)s.first())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn boolean[] booleans(Object array)
        (ß (boolean[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn byte[] bytes(Object array)
        (ß (byte[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn char[] chars(Object array)
        (ß (char[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn short[] shorts(Object array)
        (ß (short[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn float[] floats(Object array)
        (ß (float[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn double[] doubles(Object array)
        (ß (double[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn int[] ints(Object array)
        (ß (int[]) array)
    )

    (§ anno @WarnBoxedMath(false))
    (§ defn long[] longs(Object array)
        (ß (long[]) array)
    )

    (§ defn Number num(Object x)
        (ß (Number) x)
    )

    (§ defn Number num(float x)
        (ß Float.valueOf(x))
    )

    (§ defn Number num(double x)
        (ß Double.valueOf(x))
    )

    (§ defn double add(double x, double y)
        (ß x + y)
    )

    (§ defn double addP(double x, double y)
        (ß x + y)
    )

    (§ defn double minus(double x, double y)
        (ß x - y)
    )

    (§ defn double minusP(double x, double y)
        (ß x - y)
    )

    (§ defn double minus(double x)
        (ß -x)
    )

    (§ defn double minusP(double x)
        (ß -x)
    )

    (§ defn double inc(double x)
        (ß x + 1)
    )

    (§ defn double incP(double x)
        (ß x + 1)
    )

    (§ defn double dec(double x)
        (ß x - 1)
    )

    (§ defn double decP(double x)
        (ß x - 1)
    )

    (§ defn double multiply(double x, double y)
        (ß x * y)
    )

    (§ defn double multiplyP(double x, double y)
        (ß x * y)
    )

    (§ defn double divide(double x, double y)
        (ß x / y)
    )

    (§ defn boolean equiv(double x, double y)
        (ß (x == y))
    )

    (§ defn boolean lt(double x, double y)
        (ß (x < y))
    )

    (§ defn boolean lte(double x, double y)
        (ß (x <= y))
    )

    (§ defn boolean gt(double x, double y)
        (ß (x > y))
    )

    (§ defn boolean gte(double x, double y)
        (ß (x >= y))
    )

    (§ defn boolean isPos(double x)
        (ß (x > 0))
    )

    (§ defn boolean isNeg(double x)
        (ß (x < 0))
    )

    (§ defn boolean isZero(double x)
        (ß (x == 0))
    )

    (§ defn int throwIntOverflow()
        (throw (ß new ArithmeticException("integer overflow")))
    )

    (§ defn int unchecked_int_add(int x, int y)
        (ß x + y)
    )

    (§ defn int unchecked_int_subtract(int x, int y)
        (ß x - y)
    )

    (§ defn int unchecked_int_negate(int x)
        (ß -x)
    )

    (§ defn int unchecked_int_inc(int x)
        (ß x + 1)
    )

    (§ defn int unchecked_int_dec(int x)
        (ß x - 1)
    )

    (§ defn int unchecked_int_multiply(int x, int y)
        (ß x * y)
    )

    (§ defn long not(Object x)
        (ß not(bitOpsCast(x)))
    )

    (§ defn long not(long x)
        (ß ~x)
    )

    (§ defn long and(Object x, Object y)
        (ß and(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long and(Object x, long y)
        (ß and(bitOpsCast(x), y))
    )

    (§ defn long and(long x, Object y)
        (ß and(x, bitOpsCast(y)))
    )

    (§ defn long and(long x, long y)
        (ß x & y)
    )

    (§ defn long or(Object x, Object y)
        (ß or(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long or(Object x, long y)
        (ß or(bitOpsCast(x), y))
    )

    (§ defn long or(long x, Object y)
        (ß or(x, bitOpsCast(y)))
    )

    (§ defn long or(long x, long y)
        (ß x | y)
    )

    (§ defn long xor(Object x, Object y)
        (ß xor(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long xor(Object x, long y)
        (ß xor(bitOpsCast(x), y))
    )

    (§ defn long xor(long x, Object y)
        (ß xor(x, bitOpsCast(y)))
    )

    (§ defn long xor(long x, long y)
        (ß x :xor y)
    )

    (§ defn long andNot(Object x, Object y)
        (ß andNot(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long andNot(Object x, long y)
        (ß andNot(bitOpsCast(x), y))
    )

    (§ defn long andNot(long x, Object y)
        (ß andNot(x, bitOpsCast(y)))
    )

    (§ defn long andNot(long x, long y)
        (ß x & ~y)
    )

    (§ defn long clearBit(Object x, Object y)
        (ß clearBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long clearBit(Object x, long y)
        (ß clearBit(bitOpsCast(x), y))
    )

    (§ defn long clearBit(long x, Object y)
        (ß clearBit(x, bitOpsCast(y)))
    )

    (§ defn long clearBit(long x, long n)
        (ß x & ~(1 << n))
    )

    (§ defn long setBit(Object x, Object y)
        (ß setBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long setBit(Object x, long y)
        (ß setBit(bitOpsCast(x), y))
    )

    (§ defn long setBit(long x, Object y)
        (ß setBit(x, bitOpsCast(y)))
    )

    (§ defn long setBit(long x, long n)
        (ß x | (1 << n))
    )

    (§ defn long flipBit(Object x, Object y)
        (ß flipBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn long flipBit(Object x, long y)
        (ß flipBit(bitOpsCast(x), y))
    )

    (§ defn long flipBit(long x, Object y)
        (ß flipBit(x, bitOpsCast(y)))
    )

    (§ defn long flipBit(long x, long n)
        (ß x :xor (1 << n))
    )

    (§ defn boolean testBit(Object x, Object y)
        (ß testBit(bitOpsCast(x), bitOpsCast(y)))
    )

    (§ defn boolean testBit(Object x, long y)
        (ß testBit(bitOpsCast(x), y))
    )

    (§ defn boolean testBit(long x, Object y)
        (ß testBit(x, bitOpsCast(y)))
    )

    (§ defn boolean testBit(long x, long n)
        (ß ((x & (1 << n)) != 0))
    )

    (§ defn int unchecked_int_divide(int x, int y)
        (ß x / y)
    )

    (§ defn int unchecked_int_remainder(int x, int y)
        (ß x % y)
    )

    (§ defn Number num(long x)
        (ß Long.valueOf(x))
    )

    (§ defn long unchecked_add(long x, long y)
        (ß x + y)
    )

    (§ defn long unchecked_minus(long x, long y)
        (ß x - y)
    )

    (§ defn long unchecked_multiply(long x, long y)
        (ß x * y)
    )

    (§ defn long unchecked_minus(long x)
        (ß -x)
    )

    (§ defn long unchecked_inc(long x)
        (ß x + 1)
    )

    (§ defn long unchecked_dec(long x)
        (ß x - 1)
    )

    (§ defn Number unchecked_add(Object x, Object y)
        (ß add(x, y))
    )

    (§ defn Number unchecked_minus(Object x, Object y)
        (ß minus(x, y))
    )

    (§ defn Number unchecked_multiply(Object x, Object y)
        (ß multiply(x, y))
    )

    (§ defn Number unchecked_minus(Object x)
        (ß minus(x))
    )

    (§ defn Number unchecked_inc(Object x)
        (ß inc(x))
    )

    (§ defn Number unchecked_dec(Object x)
        (ß dec(x))
    )

    (§ defn double unchecked_add(double x, double y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(double x, double y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(double x, double y)
        (ß multiply(x, y))
    )

    (§ defn double unchecked_minus(double x)
        (ß minus(x))
    )

    (§ defn double unchecked_inc(double x)
        (ß inc(x))
    )

    (§ defn double unchecked_dec(double x)
        (ß dec(x))
    )

    (§ defn double unchecked_add(double x, Object y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(double x, Object y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(double x, Object y)
        (ß multiply(x, y))
    )

    (§ defn double unchecked_add(Object x, double y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(Object x, double y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(Object x, double y)
        (ß multiply(x, y))
    )

    (§ defn double unchecked_add(double x, long y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(double x, long y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(double x, long y)
        (ß multiply(x, y))
    )

    (§ defn double unchecked_add(long x, double y)
        (ß add(x, y))
    )

    (§ defn double unchecked_minus(long x, double y)
        (ß minus(x, y))
    )

    (§ defn double unchecked_multiply(long x, double y)
        (ß multiply(x, y))
    )

    (§ defn Number unchecked_add(long x, Object y)
        (ß add(x, y))
    )

    (§ defn Number unchecked_minus(long x, Object y)
        (ß minus(x, y))
    )

    (§ defn Number unchecked_multiply(long x, Object y)
        (ß multiply(x, y))
    )

    (§ defn Number unchecked_add(Object x, long y)
        (ß add(x, y))
    )

    (§ defn Number unchecked_minus(Object x, long y)
        (ß minus(x, y))
    )

    (§ defn Number unchecked_multiply(Object x, long y)
        (ß multiply(x, y))
    )

    (§ defn Number quotient(double x, Object y)
        (ß quotient((Object)x, y))
    )

    (§ defn Number quotient(Object x, double y)
        (ß quotient(x, (Object)y))
    )

    (§ defn Number quotient(long x, Object y)
        (ß quotient((Object)x, y))
    )

    (§ defn Number quotient(Object x, long y)
        (ß quotient(x, (Object)y))
    )

    (§ defn double quotient(double x, long y)
        (ß quotient(x, (double)y))
    )

    (§ defn double quotient(long x, double y)
        (ß quotient((double)x, y))
    )

    (§ defn Number remainder(double x, Object y)
        (ß remainder((Object)x, y))
    )

    (§ defn Number remainder(Object x, double y)
        (ß remainder(x, (Object)y))
    )

    (§ defn Number remainder(long x, Object y)
        (ß remainder((Object)x, y))
    )

    (§ defn Number remainder(Object x, long y)
        (ß remainder(x, (Object)y))
    )

    (§ defn double remainder(double x, long y)
        (ß remainder(x, (double)y))
    )

    (§ defn double remainder(long x, double y)
        (ß remainder((double)x, y))
    )

    (§ defn long add(long x, long y)
        (let [#_"long" ret (ß x + y)]
            (when (ß (ret :xor x) < 0 && (ret :xor y) < 0)
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn Number addP(long x, long y)
        (let [#_"long" ret (ß x + y)]
            (when (ß (ret :xor x) < 0 && (ret :xor y) < 0)
                (§ return (ß addP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn long minus(long x, long y)
        (let [#_"long" ret (ß x - y)]
            (when (ß ((ret :xor x) < 0 && (ret :xor ~y) < 0))
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn Number minusP(long x, long y)
        (let [#_"long" ret (ß x - y)]
            (when (ß ((ret :xor x) < 0 && (ret :xor ~y) < 0))
                (§ return (ß minusP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn long minus(long x)
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß -x)
    )

    (§ defn Number minusP(long x)
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß BigInt.fromBigInteger(BigInteger.valueOf(x).negate())))
        )
        (ß num(-x))
    )

    (§ defn long inc(long x)
        (when (ß x == Long.MAX_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß x + 1)
    )

    (§ defn Number incP(long x)
        (when (ß x == Long.MAX_VALUE)
            (§ return (ß BIGINT_OPS.inc(x)))
        )
        (ß num(x + 1))
    )

    (§ defn long dec(long x)
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß x - 1)
    )

    (§ defn Number decP(long x)
        (when (ß x == Long.MIN_VALUE)
            (§ return (ß BIGINT_OPS.dec(x)))
        )
        (ß num(x - 1))
    )

    (§ defn long multiply(long x, long y)
        (when (ß x == Long.MIN_VALUE && y < 0)
            (§ return (ß throwIntOverflow()))
        )
        (let [#_"long" ret (ß x * y)]
            (when (ß y != 0 && ret / y != x)
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn Number multiplyP(long x, long y)
        (when (ß x == Long.MIN_VALUE && y < 0)
            (§ return (ß multiplyP((Number)x, (Number)y)))
        )
        (let [#_"long" ret (ß x * y)]
            (when (ß y != 0 && ret / y != x)
                (§ return (ß multiplyP((Number)x, (Number)y)))
            )
            (ß num(ret))
        )
    )

    (§ defn long quotient(long x, long y)
        (ß x / y)
    )

    (§ defn long remainder(long x, long y)
        (ß x % y)
    )

    (§ defn boolean equiv(long x, long y)
        (ß (x == y))
    )

    (§ defn boolean lt(long x, long y)
        (ß (x < y))
    )

    (§ defn boolean lte(long x, long y)
        (ß (x <= y))
    )

    (§ defn boolean gt(long x, long y)
        (ß (x > y))
    )

    (§ defn boolean gte(long x, long y)
        (ß (x >= y))
    )

    (§ defn boolean isPos(long x)
        (ß (x > 0))
    )

    (§ defn boolean isNeg(long x)
        (ß (x < 0))
    )

    (§ defn boolean isZero(long x)
        (ß (x == 0))
    )

    ;; overload resolution

    (§ defn Number add(long x, Object y)
        (ß add((Object)x, y))
    )

    (§ defn Number add(Object x, long y)
        (ß add(x, (Object)y))
    )

    (§ defn Number addP(long x, Object y)
        (ß addP((Object)x, y))
    )

    (§ defn Number addP(Object x, long y)
        (ß addP(x, (Object)y))
    )

    (§ defn double add(double x, Object y)
        (ß add(x, ((Number)y).doubleValue()))
    )

    (§ defn double add(Object x, double y)
        (ß add(((Number)x).doubleValue(), y))
    )

    (§ defn double add(double x, long y)
        (ß x + y)
    )

    (§ defn double add(long x, double y)
        (ß x + y)
    )

    (§ defn double addP(double x, Object y)
        (ß addP(x, ((Number)y).doubleValue()))
    )

    (§ defn double addP(Object x, double y)
        (ß addP(((Number)x).doubleValue(), y))
    )

    (§ defn double addP(double x, long y)
        (ß x + y)
    )

    (§ defn double addP(long x, double y)
        (ß x + y)
    )

    (§ defn Number minus(long x, Object y)
        (ß minus((Object)x, y))
    )

    (§ defn Number minus(Object x, long y)
        (ß minus(x, (Object)y))
    )

    (§ defn Number minusP(long x, Object y)
        (ß minusP((Object)x, y))
    )

    (§ defn Number minusP(Object x, long y)
        (ß minusP(x, (Object)y))
    )

    (§ defn double minus(double x, Object y)
        (ß minus(x, ((Number)y).doubleValue()))
    )

    (§ defn double minus(Object x, double y)
        (ß minus(((Number)x).doubleValue(), y))
    )

    (§ defn double minus(double x, long y)
        (ß x - y)
    )

    (§ defn double minus(long x, double y)
        (ß x - y)
    )

    (§ defn double minusP(double x, Object y)
        (ß minus(x, ((Number)y).doubleValue()))
    )

    (§ defn double minusP(Object x, double y)
        (ß minus(((Number)x).doubleValue(), y))
    )

    (§ defn double minusP(double x, long y)
        (ß x - y)
    )

    (§ defn double minusP(long x, double y)
        (ß x - y)
    )

    (§ defn Number multiply(long x, Object y)
        (ß multiply((Object)x, y))
    )

    (§ defn Number multiply(Object x, long y)
        (ß multiply(x, (Object)y))
    )

    (§ defn Number multiplyP(long x, Object y)
        (ß multiplyP((Object)x, y))
    )

    (§ defn Number multiplyP(Object x, long y)
        (ß multiplyP(x, (Object)y))
    )

    (§ defn double multiply(double x, Object y)
        (ß multiply(x, ((Number)y).doubleValue()))
    )

    (§ defn double multiply(Object x, double y)
        (ß multiply(((Number)x).doubleValue(), y))
    )

    (§ defn double multiply(double x, long y)
        (ß x * y)
    )

    (§ defn double multiply(long x, double y)
        (ß x * y)
    )

    (§ defn double multiplyP(double x, Object y)
        (ß multiplyP(x, ((Number)y).doubleValue()))
    )

    (§ defn double multiplyP(Object x, double y)
        (ß multiplyP(((Number)x).doubleValue(), y))
    )

    (§ defn double multiplyP(double x, long y)
        (ß x * y)
    )

    (§ defn double multiplyP(long x, double y)
        (ß x * y)
    )

    (§ defn Number divide(long x, Object y)
        (ß divide((Object)x, y))
    )

    (§ defn Number divide(Object x, long y)
        (ß divide(x, (Object)y))
    )

    (§ defn double divide(double x, Object y)
        (ß x / ((Number)y).doubleValue())
    )

    (§ defn double divide(Object x, double y)
        (ß ((Number)x).doubleValue() / y)
    )

    (§ defn double divide(double x, long y)
        (ß x / y)
    )

    (§ defn double divide(long x, double y)
        (ß x / y)
    )

    (§ defn Number divide(long x, long y)
        (ß divide((Number)x, (Number)y))
    )

    (§ defn boolean lt(long x, Object y)
        (ß lt((Object)x, y))
    )

    (§ defn boolean lt(Object x, long y)
        (ß lt(x, (Object)y))
    )

    (§ defn boolean lt(double x, Object y)
        (ß (x < ((Number)y).doubleValue()))
    )

    (§ defn boolean lt(Object x, double y)
        (ß (((Number)x).doubleValue() < y))
    )

    (§ defn boolean lt(double x, long y)
        (ß (x < y))
    )

    (§ defn boolean lt(long x, double y)
        (ß (x < y))
    )

    (§ defn boolean lte(long x, Object y)
        (ß lte((Object)x, y))
    )

    (§ defn boolean lte(Object x, long y)
        (ß lte(x, (Object)y))
    )

    (§ defn boolean lte(double x, Object y)
        (ß (x <= ((Number)y).doubleValue()))
    )

    (§ defn boolean lte(Object x, double y)
        (ß (((Number)x).doubleValue() <= y))
    )

    (§ defn boolean lte(double x, long y)
        (ß (x <= y))
    )

    (§ defn boolean lte(long x, double y)
        (ß (x <= y))
    )

    (§ defn boolean gt(long x, Object y)
        (ß gt((Object)x, y))
    )

    (§ defn boolean gt(Object x, long y)
        (ß gt(x, (Object)y))
    )

    (§ defn boolean gt(double x, Object y)
        (ß (x > ((Number)y).doubleValue()))
    )

    (§ defn boolean gt(Object x, double y)
        (ß (((Number)x).doubleValue() > y))
    )

    (§ defn boolean gt(double x, long y)
        (ß (x > y))
    )

    (§ defn boolean gt(long x, double y)
        (ß (x > y))
    )

    (§ defn boolean gte(long x, Object y)
        (ß gte((Object)x, y))
    )

    (§ defn boolean gte(Object x, long y)
        (ß gte(x, (Object)y))
    )

    (§ defn boolean gte(double x, Object y)
        (ß (x >= ((Number)y).doubleValue()))
    )

    (§ defn boolean gte(Object x, double y)
        (ß (((Number)x).doubleValue() >= y))
    )

    (§ defn boolean gte(double x, long y)
        (ß (x >= y))
    )

    (§ defn boolean gte(long x, double y)
        (ß (x >= y))
    )

    (§ defn boolean equiv(long x, Object y)
        (ß equiv((Object)x, y))
    )

    (§ defn boolean equiv(Object x, long y)
        (ß equiv(x, (Object)y))
    )

    (§ defn boolean equiv(double x, Object y)
        (ß (x == ((Number)y).doubleValue()))
    )

    (§ defn boolean equiv(Object x, double y)
        (ß (((Number)x).doubleValue() == y))
    )

    (§ defn boolean equiv(double x, long y)
        (ß (x == y))
    )

    (§ defn boolean equiv(long x, double y)
        (ß (x == y))
    )

    (§ defn boolean isNaN(Object x)
        (ß (x instanceof Double) && ((Double)x).isNaN() || (x instanceof Float) && ((Float)x).isNaN())
    )

    (§ defn double max(double x, double y)
        (ß Math.max(x, y))
    )

    (§ defn Object max(double x, long y)
        (when (ß Double.isNaN(x))
            (§ return x)
        )
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object max(double x, Object y)
        (cond (ß Double.isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß x > ((Number)y).doubleValue())
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object max(long x, double y)
        (when (ß Double.isNaN(y))
            (§ return y)
        )
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn long max(long x, long y)
        (if (ß x > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object max(long x, Object y)
        (when (ß isNaN(y))
            (§ return y)
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object max(Object x, long y)
        (when (ß isNaN(x))
            (§ return x)
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object max(Object x, double y)
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß Double.isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß ((Number)x).doubleValue() > y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object max(Object x, Object y)
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß gt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn double min(double x, double y)
        (ß Math.min(x, y))
    )

    (§ defn Object min(double x, long y)
        (when (ß Double.isNaN(x))
            (§ return x)
        )
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object min(double x, Object y)
        (cond (ß Double.isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß x < ((Number)y).doubleValue())
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object min(long x, double y)
        (when (ß Double.isNaN(y))
            (§ return y)
        )
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn long min(long x, long y)
        (if (ß x < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object min(long x, Object y)
        (when (ß isNaN(y))
            (§ return y)
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object min(Object x, long y)
        (when (ß isNaN(x))
            (§ return x)
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object min(Object x, double y)
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß Double.isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß ((Number)x).doubleValue() < y)
            (do
                x
            )
            (do
                y
            )
        )
    )

    (§ defn Object min(Object x, Object y)
        (cond (ß isNaN(x))
            (do
                (§ return x)
            )
            (ß isNaN(y))
            (do
                (§ return y)
            )
        )
        (if (ß lt(x, y))
            (do
                x
            )
            (do
                y
            )
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (§ field IPersistentMap _meta)

    (§ constructor Obj(IPersistentMap meta)
        (ß this._meta = meta)
        this
    )

    (§ constructor Obj()
        (ß _meta = nil)
        this
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (§ abstract Obj withMeta(IPersistentMap meta))
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ field Object[] array)
    (§ def int HASHTABLE_THRESHOLD = 16)

    (§ def PersistentArrayMap EMPTY = new PersistentArrayMap())
    (§ field- IPersistentMap _meta)

    (§ defn IPersistentMap create(Map other)
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(ß Map.Entry e = (Entry) o)]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            (ß ret.persistent())
        )
    )

    #_protected
    (§ constructor PersistentArrayMap()
        (ß this.array = new Object[] (§))
        (ß this._meta = nil)
        this
    )

    (§ method PersistentArrayMap withMeta(IPersistentMap meta)
        (ß new PersistentArrayMap(meta, array))
    )

    (§ method PersistentArrayMap create(Object... init)
        (ß new PersistentArrayMap(meta(), init))
    )

    (§ method IPersistentMap createHT(Object[] init)
        (ß PersistentHashMap.create(meta(), init))
    )

    (§ defn PersistentArrayMap createWithCheck(Object[] init)
        (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
            (loop-when-recur [(ß int j = i + 2)] (ß j < init.length) [(ß j += 2)]
                (when (ß equalKey(init[i], init[j]))
                    (throw (ß new IllegalArgumentException("Duplicate key: " + init[i])))
                )
            )
        )
        (ß new PersistentArrayMap(init))
    )

    (§ defn PersistentArrayMap createAsIfByAssoc(Object[] init)
        (when (ß (init.length & 1) == 1)
            (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", init[init.length - 1]))))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (let [#_"int" n 0]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                (let [#_"boolean" duplicateKey false]
                    (loop-when-recur [(ß int j = 0)] (ß j < i) [(ß j += 2)]
                        (when (ß equalKey(init[i], init[j]))
                            (ß duplicateKey = true)
                            (§ break )
                        )
                    )
                    (when (ß !duplicateKey)
                        (ß n += 2)
                    )
                )
            )
            (when (ß n < init.length)
                ;; Create a new shorter array with unique keys, and
                ;; the last value associated with each key.  To behave
                ;; like assoc, the first occurrence of each key must
                ;; be used, since its metadata may be different than
                ;; later equal keys.
                (let [#_"Object[]" nodups (ß new Object[n])]
                    (let [#_"int" m 0]
                        (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                            (let [#_"boolean" duplicateKey false]
                                (loop-when-recur [(ß int j = 0)] (ß j < m) [(ß j += 2)]
                                    (when (ß equalKey(init[i], nodups[j]))
                                        (ß duplicateKey = true)
                                        (§ break )
                                    )
                                )
                                (when (ß !duplicateKey)
                                    (§ let [#_"int" j]
                                        (loop-when-recur [(ß j = init.length - 2)] (ß j >= i) [(ß j -= 2)]
                                            (when (ß equalKey(init[i], init[j]))
                                                (§ break )
                                            )
                                        )
                                        (ß nodups[m] = init[i])
                                        (ß nodups[m + 1] = init[j + 1])
                                        (ß m += 2)
                                    )
                                )
                            )
                        )
                        (when (ß m != n)
                            (throw (ß new IllegalArgumentException("Internal error: m=" + m)))
                        )
                        (ß init = nodups)
                    )
                )
            )
            (ß new PersistentArrayMap(init))
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ constructor PersistentArrayMap(Object[] init)
        (ß this.array = init)
        (ß this._meta = nil)
        this
    )

    (§ constructor PersistentArrayMap(IPersistentMap meta, Object[] init)
        (ß this._meta = meta)
        (ß this.array = init)
        this
    )

    (§ method int count()
        (ß array.length / 2)
    )

    (§ method boolean containsKey(Object key)
        (ß (indexOf(key) >= 0))
    )

    (§ method IMapEntry entryAt(Object key)
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0)
                (§ return (ß (IMapEntry) MapEntry.create(array[i], array[i + 1])))
            )
            nil
        )
    )

    (§ method IPersistentMap assocEx(Object key, Object val)
        (let [#_"int" i (ß indexOf(key))]
            (§ let [#_"Object[]" newArray]
                (cond (ß i >= 0)
                    (do
                        (throw (ß Util.runtimeException("Key already present")))
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß array.length > HASHTABLE_THRESHOLD)
                            (§ return (ß createHT(array).assocEx(key, val)))
                        )
                        (ß newArray = new Object[array.length + 2])
                        (when (ß array.length > 0)
                            (ß System.arraycopy(array, 0, newArray, 2, array.length))
                        )
                        (ß newArray[0] = key)
                        (ß newArray[1] = val)
                    )
                )
                (ß create(newArray))
            )
        )
    )

    (§ method IPersistentMap assoc(Object key, Object val)
        (let [#_"int" i (ß indexOf(key))]
            (§ let [#_"Object[]" newArray]
                (cond (ß i >= 0) ;; already have key, same-sized replacement
                    (do
                        (when (ß array[i + 1] == val) ;; no change, no op
                            (§ return this)
                        )
                        (ß newArray = array.clone())
                        (ß newArray[i + 1] = val)
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß array.length > HASHTABLE_THRESHOLD)
                            (§ return (ß createHT(array).assoc(key, val)))
                        )
                        (ß newArray = new Object[array.length + 2])
                        (when (ß array.length > 0)
                            (ß System.arraycopy(array, 0, newArray, 0, array.length))
                        )
                        (ß newArray[newArray.length - 2] = key)
                        (ß newArray[newArray.length - 1] = val)
                    )
                )
                (ß create(newArray))
            )
        )
    )

    (§ method IPersistentMap without(Object key)
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0) ;; have key, will remove
                (let [#_"int" newlen (ß array.length - 2)]
                    (when (ß newlen == 0)
                        (§ return (ß empty()))
                    )
                    (let [#_"Object[]" newArray (ß new Object[newlen])]
                        (ß System.arraycopy(array, 0, newArray, 0, i))
                        (ß System.arraycopy(array, i + 2, newArray, i, newlen - i))
                        (§ return (ß create(newArray)))
                    )
                )
            )
            ;; don't have key, no op
            this
        )
    )

    (§ method IPersistentMap empty()
        (ß (IPersistentMap) EMPTY.withMeta(meta()))
    )

    (§ method Object valAt(Object key, Object notFound)
        (let [#_"int" i (ß indexOf(key))]
            (when (ß i >= 0)
                (§ return (ß array[i + 1]))
            )
            notFound
        )
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method int capacity()
        (ß count())
    )

    (§ method- int indexOfObject(Object key)
        (let [(ß Util.EquivPred ep = Util.equivPred(key))]
            (loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
                (when (ß ep.equiv(key, array[i]))
                    (§ return i)
                )
            )
            -1
        )
    )

    (§ method- int indexOf(Object key)
        (if (ß key instanceof Keyword)
            (do
                (loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
                    (when (ß key == array[i])
                        (§ return i)
                    )
                )
                -1
            )
            (do
                (ß indexOfObject(key))
            )
        )
    )

    (§ defn boolean equalKey(Object k1, Object k2)
        (when (ß k1 instanceof Keyword)
            (§ return (ß (k1 == k2)))
        )
        (ß Util.equiv(k1, k2))
    )

    (§ method Iterator iterator()
        (ß new Iter(array, APersistentMap.MAKE_ENTRY))
    )

    (§ method Iterator keyIterator()
        (ß new Iter(array, APersistentMap.MAKE_KEY))
    )

    (§ method Iterator valIterator()
        (ß new Iter(array, APersistentMap.MAKE_VAL))
    )

    (§ method ISeq seq()
        (when (ß array.length > 0)
            (§ return (ß new Seq(array, 0)))
        )
        nil
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (class-ns Seq (§ extends ASeq) (§ implements Counted)
        (§ field Object[] array)
        (§ field int i)

        (§ constructor Seq(Object[] array, int i)
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ constructor Seq(IPersistentMap meta, Object[] array, int i)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            this
        )

        (§ method Object first()
            (ß MapEntry.create(array[i], array[i + 1]))
        )

        (§ method ISeq next()
            (when (ß i + 2 < array.length)
                (§ return (ß new Seq(array, i + 2)))
            )
            nil
        )

        (§ method int count()
            (ß (array.length - i) / 2)
        )

        (§ method Obj withMeta(IPersistentMap meta)
            (ß new Seq(meta, array, i))
        )
    )

    (class-ns Iter (§ implements Iterator)
        (§ field IFn f)
        (§ field Object[] array)
        (§ field int i)

        ;; for iterator
        (§ constructor Iter(Object[] array, IFn f)
            (§ this(array, -2, f))
            this
        )

        ;; for entryAt
        (§ constructor Iter(Object[] array, int i, IFn f)
            (ß this.array = array)
            (ß this.i = i)
            (ß this.f = f)
            this
        )

        (§ method boolean hasNext()
            (ß (i < array.length - 2))
        )

        (§ method Object next()
            (try
                (ß i += 2)
                (ß f.invoke(array[i], array[i + 1]))
                (catch IndexOutOfBoundsException e
                    (throw (ß new NoSuchElementException()))
                )
            )
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException()))
        )
    )

    (§ method Object kvreduce(IFn f, Object init)
        (loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
            (ß init = f.invoke(init, array[i], array[i + 1]))
            (when (ß RT.isReduced(init))
                (§ return (ß ((IDeref)init).deref()))
            )
        )
        init
    )

    (§ method ITransientMap asTransient()
        (ß new TransientArrayMap(array))
    )

    (class-ns TransientArrayMap (§ extends ATransientMap)
        #_volatile
        (§ field int len)
        (§ field Object[] array)
        #_volatile
        (§ field Thread owner)

        (§ constructor TransientArrayMap(Object[] array)
            (ß this.owner = Thread.currentThread())
            (ß this.array = new Object[Math.max(HASHTABLE_THRESHOLD, array.length)])
            (ß System.arraycopy(array, 0, this.array, 0, array.length))
            (ß this.len = array.length)
            this
        )

        (§ method- int indexOf(Object key)
            (loop-when-recur [(ß int i = 0)] (ß i < len) [(ß i += 2)]
                (when (ß equalKey(array[i], key))
                    (§ return i)
                )
            )
            -1
        )

        (§ method ITransientMap doAssoc(Object key, Object val)
            (let [#_"int" i (ß indexOf(key))]
                (cond (ß i >= 0) ;; already have key,
                    (do
                        (when (ß array[i + 1] != val) ;; no change, no op
                            (ß array[i + 1] = val)
                        )
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß len >= array.length)
                            (§ return (ß PersistentHashMap.create(array).asTransient().assoc(key, val)))
                        )
                        (ß array[len++] = key)
                        (ß array[len++] = val)
                    )
                )
                this
            )
        )

        (§ method ITransientMap doWithout(Object key)
            (let [#_"int" i (ß indexOf(key))]
                (when (ß i >= 0) ;; have key, will remove
                    (when (ß len >= 2)
                        (ß array[i] = array[len - 2])
                        (ß array[i + 1] = array[len - 1])
                    )
                    (ß len -= 2)
                )
                this
            )
        )

        (§ method Object doValAt(Object key, Object notFound)
            (let [#_"int" i (ß indexOf(key))]
                (when (ß i >= 0)
                    (§ return (ß array[i + 1]))
                )
                notFound
            )
        )

        (§ method int doCount()
            (ß len / 2)
        )

        (§ method IPersistentMap doPersistent()
            (ß ensureEditable())
            (ß owner = nil)
            (let [#_"Object[]" a (ß new Object[len])]
                (ß System.arraycopy(array, 0, a, 0, len))
                (ß new PersistentArrayMap(a))
            )
        )

        (§ method void ensureEditable()
            (when (ß owner == nil)
                (throw (ß new IllegalAccessError("Transient used after persistent! call")))
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ field int count)
    (§ field INode root)
    (§ field boolean hasNull)
    (§ field Object nullValue)
    (§ field IPersistentMap _meta)

    (§ def PersistentHashMap EMPTY = new PersistentHashMap(0, nil, false, nil))
    (§ def- Object NOT_FOUND = new Object())

    (§ defn IPersistentMap create(Map other)
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(ß Map.Entry e = (Entry) o)]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            (ß ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn PersistentHashMap create(Object... init)
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                (ß ret = ret.assoc(init[i], init[i + 1]))
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn PersistentHashMap createWithCheck(Object... init)
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i += 2)]
                (ß ret = ret.assoc(init[i], init[i + 1]))
                (when (ß ret.count() != i / 2 + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + init[i])))
                )
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn PersistentHashMap create(ISeq items)
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (ß ret = ret.assoc(items.first(), RT.second(items)))
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    (§ defn PersistentHashMap createWithCheck(ISeq items)
        (let [#_"ITransientMap" ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß items != nil) [(ß items = items.next().next(), ++i)]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (ß ret = ret.assoc(items.first(), RT.second(items)))
                (when (ß ret.count() != i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + items.first())))
                )
            )
            (ß (PersistentHashMap) ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn PersistentHashMap create(IPersistentMap meta, Object... init)
        (ß create(init).withMeta(meta))
    )

    (§ constructor PersistentHashMap(int count, INode root, boolean hasNull, Object nullValue)
        (ß this.count = count)
        (ß this.root = root)
        (ß this.hasNull = hasNull)
        (ß this.nullValue = nullValue)
        (ß this._meta = nil)
        this
    )

    (§ constructor PersistentHashMap(IPersistentMap meta, int count, INode root, boolean hasNull, Object nullValue)
        (ß this._meta = meta)
        (ß this.count = count)
        (ß this.root = root)
        (ß this.hasNull = hasNull)
        (ß this.nullValue = nullValue)
        this
    )

    (§ defn int hash(Object k)
        (ß Util.hasheq(k))
    )

    (§ method boolean containsKey(Object key)
        (when (ß key == nil)
            (§ return hasNull)
        )
        (ß (root != nil) ? (root.find(0, hash(key), key, NOT_FOUND) != NOT_FOUND) :or false)
    )

    (§ method IMapEntry entryAt(Object key)
        (when (ß key == nil)
            (§ return (ß hasNull ? (IMapEntry) MapEntry.create(nil, nullValue) :or nil))
        )
        (ß (root != nil) ? root.find(0, hash(key), key) :or nil)
    )

    (§ method IPersistentMap assoc(Object key, Object val)
        (when (ß key == nil)
            (when (ß hasNull && val == nullValue)
                (§ return this)
            )
            (§ return (ß new PersistentHashMap(meta(), hasNull ? count :or count + 1, root, true, val)))
        )
        (let [#_"Box" addedLeaf (ß new Box(nil))]
            (let [#_"INode" newroot (ß ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(0, hash(key), key, val, addedLeaf))]
                (when (ß newroot == root)
                    (§ return this)
                )
                (ß new PersistentHashMap(meta(), (addedLeaf.val == nil) ? count :or count + 1, newroot, hasNull, nullValue))
            )
        )
    )

    (§ method Object valAt(Object key, Object notFound)
        (when (ß key == nil)
            (§ return (ß hasNull ? nullValue :or notFound))
        )
        (ß (root != nil) ? root.find(0, hash(key), key, notFound) :or notFound)
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method IPersistentMap assocEx(Object key, Object val)
        (when (ß containsKey(key))
            (throw (ß Util.runtimeException("Key already present")))
        )
        (ß assoc(key, val))
    )

    (§ method IPersistentMap without(Object key)
        (when (ß key == nil)
            (§ return (ß hasNull ? new PersistentHashMap(meta(), count - 1, root, false, nil) :or this))
        )
        (when (ß root == nil)
            (§ return this)
        )
        (let [#_"INode" newroot (ß root.without(0, hash(key), key))]
            (when (ß newroot == root)
                (§ return this)
            )
            (ß new PersistentHashMap(meta(), count - 1, newroot, hasNull, nullValue))
        )
    )

    (§ def Iterator EMPTY_ITER = new Iterator()
        (§ reify
            (§ method boolean hasNext()
                false
            )

            (§ method Object next()
                (throw (ß new NoSuchElementException()))
            )

            (§ method void remove()
                (throw (ß new UnsupportedOperationException()))
            )
        )
    )

    (§ method- Iterator iterator(IFn f)
        (let [#_"Iterator" rootIter (ß (root == nil) ? EMPTY_ITER :or root.iterator(f))]
            (if hasNull
                (do
                    (ß new Iterator()
                        (§ reify
                            (§ field- boolean seen = false)

                            (§ method boolean hasNext()
                                (if (ß !seen)
                                    (do
                                        true
                                    )
                                    (do
                                        (ß rootIter.hasNext())
                                    )
                                )
                            )

                            (§ method Object next()
                                (if (ß !seen)
                                    (do
                                        (ß seen = true)
                                        (ß f.invoke(nil, nullValue))
                                    )
                                    (do
                                        (ß rootIter.next())
                                    )
                                )
                            )

                            (§ method void remove()
                                (throw (ß new UnsupportedOperationException()))
                            )
                        )
                    )
                )
                (do
                    rootIter
                )
            )
        )
    )

    (§ method Iterator iterator()
        (ß iterator(APersistentMap.MAKE_ENTRY))
    )

    (§ method Iterator keyIterator()
        (ß iterator(APersistentMap.MAKE_KEY))
    )

    (§ method Iterator valIterator()
        (ß iterator(APersistentMap.MAKE_VAL))
    )

    (§ method Object kvreduce(IFn f, Object init)
        (ß init = hasNull ? f.invoke(init, nil, nullValue) :or init)
        (when (ß RT.isReduced(init))
            (§ return (ß ((IDeref)init).deref()))
        )
        (when (ß root != nil)
            (ß init = root.kvreduce(f, init))
            (if (ß RT.isReduced(init))
                (do
                    (§ return (ß ((IDeref)init).deref()))
                )
                (do
                    (§ return init)
                )
            )
        )
        init
    )

    (§ method Object fold(long n, IFn combinef, IFn reducef, IFn fjinvoke, IFn fjtask, IFn fjfork, IFn fjjoin)
        ;; we are ignoring n for now
        (let [#_"Callable" top
                (ß new Callable()
                    (§ reify
                        (§ method Object call() (§ throws Exception)
                            (let [#_"Object" ret (ß combinef.invoke())]
                                (when (ß root != nil)
                                    (ß ret = combinef.invoke(ret, root.fold(combinef, reducef, fjtask, fjfork, fjjoin)))
                                )
                                (ß hasNull ? combinef.invoke(ret, reducef.invoke(combinef.invoke(), nil, nullValue)) :or ret)
                            )
                        )
                    )
                )]
            (ß fjinvoke.invoke(top))
        )
    )

    (§ method int count()
        count
    )

    (§ method ISeq seq()
        (let [#_"ISeq" s (ß (root != nil) ? root.nodeSeq() :or nil)]
            (ß hasNull ? new Cons(MapEntry.create(nil, nullValue), s) :or s)
        )
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ defn int mask(int hash, int shift)
        (ß (hash >>> shift) & 0x01f)
    )

    (§ method PersistentHashMap withMeta(IPersistentMap meta)
        (ß new PersistentHashMap(meta, count, root, hasNull, nullValue))
    )

    (§ method TransientHashMap asTransient()
        (ß new TransientHashMap(this))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (class-ns TransientHashMap (§ extends ATransientMap)
        (§ field AtomicReference<Thread> edit)
        #_volatile
        (§ field INode root)
        #_volatile
        (§ field int count)
        #_volatile
        (§ field boolean hasNull)
        #_volatile
        (§ field Object nullValue)
        (§ field Box leafFlag = new Box(nil))

        (§ constructor TransientHashMap(PersistentHashMap m)
            (§ this(new AtomicReference<Thread>(Thread.currentThread()), m.root, m.count, m.hasNull, m.nullValue))
            this
        )

        (§ constructor TransientHashMap(AtomicReference<Thread> edit, INode root, int count, boolean hasNull, Object nullValue)
            (ß this.edit = edit)
            (ß this.root = root)
            (ß this.count = count)
            (ß this.hasNull = hasNull)
            (ß this.nullValue = nullValue)
            this
        )

        (§ method ITransientMap doAssoc(Object key, Object val)
            (when (ß key == nil)
                (when (ß this.nullValue != val)
                    (ß this.nullValue = val)
                )
                (when (ß !hasNull)
                    (ß this.count++)
                    (ß this.hasNull = true)
                )
                (§ return this)
            )
            (ß leafFlag.val = nil)
            (let [#_"INode" n (ß ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(edit, 0, hash(key), key, val, leafFlag))]
                (when (ß n != this.root)
                    (ß this.root = n)
                )
                (when (ß leafFlag.val != nil)
                    (ß this.count++)
                )
                this
            )
        )

        (§ method ITransientMap doWithout(Object key)
            (when (ß key == nil)
                (when (ß !hasNull)
                    (§ return this)
                )
                (ß hasNull = false)
                (ß nullValue = nil)
                (ß this.count--)
                (§ return this)
            )
            (when (ß root == nil)
                (§ return this)
            )
            (ß leafFlag.val = nil)
            (let [#_"INode" n (ß root.without(edit, 0, hash(key), key, leafFlag))]
                (when (ß n != root)
                    (ß this.root = n)
                )
                (when (ß leafFlag.val != nil)
                    (ß this.count--)
                )
                this
            )
        )

        (§ method IPersistentMap doPersistent()
            (ß edit.set(nil))
            (ß new PersistentHashMap(count, root, hasNull, nullValue))
        )

        (§ method Object doValAt(Object key, Object notFound)
            (when (ß key == nil)
                (if hasNull
                    (do
                        (§ return nullValue)
                    )
                    (do
                        (§ return notFound)
                    )
                )
            )
            (when (ß root == nil)
                (§ return notFound)
            )
            (ß root.find(0, hash(key), key, notFound))
        )

        (§ method int doCount()
            count
        )

        (§ method void ensureEditable()
            (when (ß edit.get() == nil)
                (throw (ß new IllegalAccessError("Transient used after persistent! call")))
            )
            nil
        )
    )

    (§ interface INode
        (§ abstract INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf))
        (§ abstract INode without(int shift, int hash, Object key))
        (§ abstract IMapEntry find(int shift, int hash, Object key))
        (§ abstract Object find(int shift, int hash, Object key, Object notFound))
        (§ abstract ISeq nodeSeq())
        (§ abstract INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf))
        (§ abstract INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf))
        (§ abstract Object kvreduce(IFn f, Object init))
        (§ abstract Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin))
        ;; returns the result of (f [k v]) for each iterated element
        (§ abstract Iterator iterator(IFn f))
    )

    (class-ns ArrayNode (§ implements INode)
        (§ field int count)
        (§ field INode[] array)
        (§ field AtomicReference<Thread> edit)

        (§ constructor ArrayNode(AtomicReference<Thread> edit, int count, INode[] array)
            (ß this.array = array)
            (ß this.edit = edit)
            (ß this.count = count)
            this
        )

        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return (ß new ArrayNode(nil, count + 1, cloneAndSet(array, idx, BitmapIndexedNode.EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)))))
                    )
                    (let [#_"INode" n (ß node.assoc(shift + 5, hash, key, val, addedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (ß new ArrayNode(nil, count, cloneAndSet(array, idx, n)))
                    )
                )
            )
        )

        (§ method INode without(int shift, int hash, Object key)
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return this)
                    )
                    (let [#_"INode" n (ß node.without(shift + 5, hash, key))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (if (ß n == nil)
                            (do
                                (when (ß count <= 8) ;; shrink
                                    (§ return (ß pack(nil, idx)))
                                )
                                (ß new ArrayNode(nil, count - 1, cloneAndSet(array, idx, n)))
                            )
                            (do
                                (ß new ArrayNode(nil, count, cloneAndSet(array, idx, n)))
                            )
                        )
                    )
                )
            )
        )

        (§ method IMapEntry find(int shift, int hash, Object key)
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return nil)
                    )
                    (ß node.find(shift + 5, hash, key))
                )
            )
        )

        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return notFound)
                    )
                    (ß node.find(shift + 5, hash, key, notFound))
                )
            )
        )

        (§ method ISeq nodeSeq()
            (ß Seq.create(array))
        )

        (§ method Iterator iterator(IFn f)
            (ß new Iter(array, f))
        )

        (§ method Object kvreduce(IFn f, Object init)
            (doseq [#_"INode" node array]
                (when (ß node != nil)
                    (ß init = node.kvreduce(f, init))
                    (when (ß RT.isReduced(init))
                        (§ return init)
                    )
                )
            )
            init
        )

        (§ method Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (let [#_"List<Callable>" tasks (ß new ArrayList())]
                (doseq [#_"INode" node array]
                    (when (ß node != nil)
                        (ß tasks.add(new Callable()
                            (§ reify
                                (§ method Object call() (§ throws Exception)
                                    (ß node.fold(combinef, reducef, fjtask, fjfork, fjjoin))
                                )
                            ))
                        )
                    )
                )

                (ß foldTasks(tasks, combinef, fjtask, fjfork, fjjoin))
            )
        )

        (§ defn Object foldTasks(List<Callable> tasks, IFn combinef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (when (ß tasks.isEmpty())
                (§ return (ß combinef.invoke()))
            )

            (when (ß tasks.size() == 1)
                (let [#_"Object" ret nil]
                    (try
                        (§ return (ß tasks.get(0).call()))
                        (catch Exception e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
            )

            (let [#_"List<Callable>" t1 (ß tasks.subList(0, tasks.size() / 2))]
                (let [#_"List<Callable>" t2 (ß tasks.subList(tasks.size() / 2, tasks.size()))]
                    (let [#_"Object" forked
                            (ß fjfork.invoke(fjtask.invoke(new Callable()
                                (§ reify
                                    (§ method Object call() (§ throws Exception)
                                        (ß foldTasks(t2, combinef, fjtask, fjfork, fjjoin))
                                    )
                                )))
                            )]
                        (ß combinef.invoke(foldTasks(t1, combinef, fjtask, fjfork, fjjoin), fjjoin.invoke(forked)))
                    )
                )
            )
        )

        (§ method- ArrayNode ensureEditable(AtomicReference<Thread> edit)
            (when (ß this.edit == edit)
                (§ return this)
            )
            (ß new ArrayNode(edit, count, this.array.clone()))
        )

        (§ method- ArrayNode editAndSet(AtomicReference<Thread> edit, int i, INode n)
            (let [#_"ArrayNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = n)
                editable
            )
        )

        (§ method- INode pack(AtomicReference<Thread> edit, int idx)
            (let [#_"Object[]" newArray (ß new Object[2 * (count - 1)])]
                (let [#_"int" j 1]
                    (let [#_"int" bitmap 0]
                        (loop-when-recur [(ß int i = 0)] (ß i < idx) [(ß i++)]
                            (when (ß array[i] != nil)
                                (ß newArray[j] = array[i])
                                (ß bitmap |= 1 << i)
                                (ß j += 2)
                            )
                        )
                        (loop-when-recur [(ß int i = idx + 1)] (ß i < array.length) [(ß i++)]
                            (when (ß array[i] != nil)
                                (ß newArray[j] = array[i])
                                (ß bitmap |= 1 << i)
                                (ß j += 2)
                            )
                        )
                        (ß new BitmapIndexedNode(edit, bitmap, newArray))
                    )
                )
            )
        )

        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (let [#_"ArrayNode" editable (ß editAndSet(edit, idx, BitmapIndexedNode.EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf)))]
                            (ß editable.count++)
                            (§ return editable)
                        )
                    )
                    (let [#_"INode" n (ß node.assoc(edit, shift + 5, hash, key, val, addedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (ß editAndSet(edit, idx, n))
                    )
                )
            )
        )

        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (let [#_"int" idx (ß mask(hash, shift))]
                (let [#_"INode" node (ß array[idx])]
                    (when (ß node == nil)
                        (§ return this)
                    )
                    (let [#_"INode" n (ß node.without(edit, shift + 5, hash, key, removedLeaf))]
                        (when (ß n == node)
                            (§ return this)
                        )
                        (when (ß n == nil)
                            (when (ß count <= 8) ;; shrink
                                (§ return (ß pack(edit, idx)))
                            )
                            (let [#_"ArrayNode" editable (ß editAndSet(edit, idx, n))]
                                (ß editable.count--)
                                (§ return editable)
                            )
                        )
                        (ß editAndSet(edit, idx, n))
                    )
                )
            )
        )

        (class-ns Seq (§ extends ASeq)
            (§ field INode[] nodes)
            (§ field int i)
            (§ field ISeq s)

            (§ defn ISeq create(INode[] nodes)
                (ß create(nil, nodes, 0, nil))
            )

            (§ defn- ISeq create(IPersistentMap meta, INode[] nodes, int i, ISeq s)
                (when (ß s != nil)
                    (§ return (ß new Seq(meta, nodes, i, s)))
                )
                (loop-when-recur [(ß int j = i)] (ß j < nodes.length) [(ß j++)]
                    (when (ß nodes[j] != nil)
                        (let [#_"ISeq" ns (ß nodes[j].nodeSeq())]
                            (when (ß ns != nil)
                                (§ return (ß new Seq(meta, nodes, j + 1, ns)))
                            )
                        )
                    )
                )
                nil
            )

            (§ constructor- Seq(IPersistentMap meta, INode[] nodes, int i, ISeq s)
                (§ super(meta))
                (ß this.nodes = nodes)
                (ß this.i = i)
                (ß this.s = s)
                this
            )

            (§ method Obj withMeta(IPersistentMap meta)
                (ß new Seq(meta, nodes, i, s))
            )

            (§ method Object first()
                (ß s.first())
            )

            (§ method ISeq next()
                (ß create(nil, nodes, i, s.next()))
            )
        )

        (class-ns Iter (§ implements Iterator)
            (§ field- INode[] array)
            (§ field- IFn f)
            (§ field- int i = 0)
            (§ field- Iterator nestedIter)

            (§ constructor- Iter(INode[] array, IFn f)
                (ß this.array = array)
                (ß this.f = f)
                this
            )

            (§ method boolean hasNext()
                (while true
                    (when (ß nestedIter != nil)
                        (if (ß nestedIter.hasNext())
                            (do
                                (§ return true)
                            )
                            (do
                                (ß nestedIter = nil)
                            )
                        )
                    )

                    (if (ß i < array.length)
                        (do
                            (let [#_"INode" node (ß array[i++])]
                                (when (ß node != nil)
                                    (ß nestedIter = node.iterator(f))
                                )
                            )
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )

            (§ method Object next()
                (if (ß hasNext())
                    (do
                        (ß nestedIter.next())
                    )
                    (do
                        (throw (ß new NoSuchElementException()))
                    )
                )
            )

            (§ method void remove()
                (throw (ß new UnsupportedOperationException()))
            )
        )
    )

    (class-ns BitmapIndexedNode (§ implements INode)
        (§ def BitmapIndexedNode EMPTY = new BitmapIndexedNode(nil, 0, new Object[0]))

        (§ field int bitmap)
        (§ field Object[] array)
        (§ field AtomicReference<Thread> edit)

        (§ method int index(int bit)
            (ß Integer.bitCount(bitmap & (bit - 1)))
        )

        (§ constructor BitmapIndexedNode(AtomicReference<Thread> edit, int bitmap, Object[] array)
            (ß this.bitmap = bitmap)
            (ß this.array = array)
            (ß this.edit = edit)
            this
        )

        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (let [#_"int" idx (ß index(bit))]
                    (if (ß (bitmap & bit) != 0)
                        (do
                            (let [#_"Object" keyOrNull (ß array[2 * idx])]
                                (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                                    (when (ß keyOrNull == nil)
                                        (let [#_"INode" n (ß ((INode) valOrNode).assoc(shift + 5, hash, key, val, addedLeaf))]
                                            (when (ß n == valOrNode)
                                                (§ return this)
                                            )
                                            (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                                        )
                                    )
                                    (when (ß Util.equiv(key, keyOrNull))
                                        (when (ß val == valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, val))))
                                    )
                                    (ß addedLeaf.val = addedLeaf)
                                    (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx, nil, 2 * idx + 1, createNode(shift + 5, keyOrNull, valOrNode, hash, key, val))))
                                )
                            )
                        )
                        (do
                            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                                (if (ß n >= 16)
                                    (do
                                        (let [#_"INode[]" nodes (ß new INode[32])]
                                            (let [#_"int" jdx (ß mask(hash, shift))]
                                                (ß nodes[jdx] = EMPTY.assoc(shift + 5, hash, key, val, addedLeaf))
                                                (let [#_"int" j 0]
                                                    (loop-when-recur [(ß int i = 0)] (ß i < 32) [(ß i++)]
                                                        (when (ß ((bitmap >>> i) & 1) != 0)
                                                            (if (ß array[j] == nil)
                                                                (do
                                                                    (ß nodes[i] = (INode) array[j + 1])
                                                                )
                                                                (do
                                                                    (ß nodes[i] = EMPTY.assoc(shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf))
                                                                )
                                                            )
                                                            (ß j += 2)
                                                        )
                                                    )
                                                    (ß new ArrayNode(nil, n + 1, nodes))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Object[]" newArray (ß new Object[2 * (n + 1)])]
                                            (ß System.arraycopy(array, 0, newArray, 0, 2 * idx))
                                            (ß newArray[2 * idx] = key)
                                            (ß addedLeaf.val = addedLeaf)
                                            (ß newArray[2 * idx + 1] = val)
                                            (ß System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                                            (ß new BitmapIndexedNode(nil, bitmap | bit, newArray))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method INode without(int shift, int hash, Object key)
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return this)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (ß keyOrNull == nil)
                                (let [#_"INode" n (ß ((INode) valOrNode).without(shift + 5, hash, key))]
                                    (when (ß n == valOrNode)
                                        (§ return this)
                                    )
                                    (when (ß n != nil)
                                        (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                                    )
                                    (when (ß bitmap == bit)
                                        (§ return nil)
                                    )
                                    (§ return (ß new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
                                )
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                ;; TODO: collapse
                                (§ return (ß new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
                            )
                            this
                        )
                    )
                )
            )
        )

        (§ method IMapEntry find(int shift, int hash, Object key)
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return nil)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (ß keyOrNull == nil)
                                (§ return (ß ((INode) valOrNode).find(shift + 5, hash, key)))
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (§ return (ß (IMapEntry) MapEntry.create(keyOrNull, valOrNode)))
                            )
                            nil
                        )
                    )
                )
            )
        )

        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return notFound)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (ß keyOrNull == nil)
                                (§ return (ß ((INode) valOrNode).find(shift + 5, hash, key, notFound)))
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (§ return valOrNode)
                            )
                            notFound
                        )
                    )
                )
            )
        )

        (§ method ISeq nodeSeq()
            (ß NodeSeq.create(array))
        )

        (§ method Iterator iterator(IFn f)
            (ß new NodeIter(array, f))
        )

        (§ method Object kvreduce(IFn f, Object init)
            (ß NodeSeq.kvreduce(array, f, init))
        )

        (§ method Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (ß NodeSeq.kvreduce(array, reducef, combinef.invoke()))
        )

        (§ method- BitmapIndexedNode ensureEditable(AtomicReference<Thread> edit)
            (when (ß this.edit == edit)
                (§ return this)
            )
            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                (let [#_"Object[]" newArray (ß new Object[(n >= 0) ? 2 * (n + 1) :or 4])] ;; make room for next assoc
                    (ß System.arraycopy(array, 0, newArray, 0, 2 * n))
                    (ß new BitmapIndexedNode(edit, bitmap, newArray))
                )
            )
        )

        (§ method- BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = a)
                editable
            )
        )

        (§ method- BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = a)
                (ß editable.array[j] = b)
                editable
            )
        )

        (§ method- BitmapIndexedNode editAndRemovePair(AtomicReference<Thread> edit, int bit, int i)
            (when (ß bitmap == bit)
                (§ return nil)
            )
            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                (ß editable.bitmap ^= bit)
                (ß System.arraycopy(editable.array, 2 * (i + 1), editable.array, 2 * i, editable.array.length - 2 * (i + 1)))
                (ß editable.array[editable.array.length - 2] = nil)
                (ß editable.array[editable.array.length - 1] = nil)
                editable
            )
        )

        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (let [#_"int" idx (ß index(bit))]
                    (if (ß (bitmap & bit) != 0)
                        (do
                            (let [#_"Object" keyOrNull (ß array[2 * idx])]
                                (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                                    (when (ß keyOrNull == nil)
                                        (let [#_"INode" n (ß ((INode) valOrNode).assoc(edit, shift + 5, hash, key, val, addedLeaf))]
                                            (when (ß n == valOrNode)
                                                (§ return this)
                                            )
                                            (§ return (ß editAndSet(edit, 2 * idx + 1, n)))
                                        )
                                    )
                                    (when (ß Util.equiv(key, keyOrNull))
                                        (when (ß val == valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß editAndSet(edit, 2 * idx + 1, val)))
                                    )
                                    (ß addedLeaf.val = addedLeaf)
                                    (ß editAndSet(edit, 2 * idx, nil, 2 * idx + 1, createNode(edit, shift + 5, keyOrNull, valOrNode, hash, key, val)))
                                )
                            )
                        )
                        (do
                            (let [#_"int" n (ß Integer.bitCount(bitmap))]
                                (when (ß n * 2 < array.length)
                                    (ß addedLeaf.val = addedLeaf)
                                    (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                                        (ß System.arraycopy(editable.array, 2 * idx, editable.array, 2 * (idx + 1), 2 * (n - idx)))
                                        (ß editable.array[2 * idx] = key)
                                        (ß editable.array[2 * idx + 1] = val)
                                        (ß editable.bitmap |= bit)
                                        (§ return editable)
                                    )
                                )
                                (if (ß n >= 16)
                                    (do
                                        (let [#_"INode[]" nodes (ß new INode[32])]
                                            (let [#_"int" jdx (ß mask(hash, shift))]
                                                (ß nodes[jdx] = EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf))
                                                (let [#_"int" j 0]
                                                    (loop-when-recur [(ß int i = 0)] (ß i < 32) [(ß i++)]
                                                        (when (ß ((bitmap >>> i) & 1) != 0)
                                                            (if (ß array[j] == nil)
                                                                (do
                                                                    (ß nodes[i] = (INode) array[j + 1])
                                                                )
                                                                (do
                                                                    (ß nodes[i] = EMPTY.assoc(edit, shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf))
                                                                )
                                                            )
                                                            (ß j += 2)
                                                        )
                                                    )
                                                    (ß new ArrayNode(edit, n + 1, nodes))
                                                )
                                            )
                                        )
                                    )
                                    (do
                                        (let [#_"Object[]" newArray (ß new Object[2 * (n + 4)])]
                                            (ß System.arraycopy(array, 0, newArray, 0, 2 * idx))
                                            (ß newArray[2 * idx] = key)
                                            (ß addedLeaf.val = addedLeaf)
                                            (ß newArray[2 * idx + 1] = val)
                                            (ß System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx)))
                                            (let [#_"BitmapIndexedNode" editable (ß ensureEditable(edit))]
                                                (ß editable.array = newArray)
                                                (ß editable.bitmap |= bit)
                                                editable
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (let [#_"int" bit (ß bitpos(hash, shift))]
                (when (ß (bitmap & bit) == 0)
                    (§ return this)
                )
                (let [#_"int" idx (ß index(bit))]
                    (let [#_"Object" keyOrNull (ß array[2 * idx])]
                        (let [#_"Object" valOrNode (ß array[2 * idx + 1])]
                            (when (ß keyOrNull == nil)
                                (let [#_"INode" n (ß ((INode) valOrNode).without(edit, shift + 5, hash, key, removedLeaf))]
                                    (when (ß n == valOrNode)
                                        (§ return this)
                                    )
                                    (when (ß n != nil)
                                        (§ return (ß editAndSet(edit, 2 * idx + 1, n)))
                                    )
                                    (when (ß bitmap == bit)
                                        (§ return nil)
                                    )
                                    (§ return (ß editAndRemovePair(edit, bit, idx)))
                                )
                            )
                            (when (ß Util.equiv(key, keyOrNull))
                                (ß removedLeaf.val = removedLeaf)
                                ;; TODO: collapse
                                (§ return (ß editAndRemovePair(edit, bit, idx)))
                            )
                            this
                        )
                    )
                )
            )
        )
    )

    (class-ns HashCollisionNode (§ implements INode)
        (§ field int hash)
        (§ field int count)
        (§ field Object[] array)
        (§ field AtomicReference<Thread> edit)

        (§ constructor HashCollisionNode(AtomicReference<Thread> edit, int hash, int count, Object... array)
            (ß this.edit = edit)
            (ß this.hash = hash)
            (ß this.count = count)
            (ß this.array = array)
            this
        )

        (§ method INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
            (when (ß hash == this.hash)
                (let [#_"int" idx (ß findIndex(key))]
                    (when (ß idx != -1)
                        (when (ß array[idx + 1] == val)
                            (§ return this)
                        )
                        (§ return (ß new HashCollisionNode(nil, hash, count, cloneAndSet(array, idx + 1, val))))
                    )
                    (let [#_"Object[]" newArray (ß new Object[2 * (count + 1)])]
                        (ß System.arraycopy(array, 0, newArray, 0, 2 * count))
                        (ß newArray[2 * count] = key)
                        (ß newArray[2 * count + 1] = val)
                        (ß addedLeaf.val = addedLeaf)
                        (§ return (ß new HashCollisionNode(edit, hash, count + 1, newArray)))
                    )
                )
            )
            ;; nest it in a bitmap node
            (ß new BitmapIndexedNode(nil, bitpos(this.hash, shift), new Object[] (§ nil, this )).assoc(shift, hash, key, val, addedLeaf))
        )

        (§ method INode without(int shift, int hash, Object key)
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx == -1)
                    (§ return this)
                )
                (when (ß count == 1)
                    (§ return nil)
                )
                (ß new HashCollisionNode(nil, hash, count - 1, removePair(array, idx / 2)))
            )
        )

        (§ method IMapEntry find(int shift, int hash, Object key)
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx < 0)
                    (§ return nil)
                )
                (when (ß Util.equiv(key, array[idx]))
                    (§ return (ß (IMapEntry) MapEntry.create(array[idx], array[idx + 1])))
                )
                nil
            )
        )

        (§ method Object find(int shift, int hash, Object key, Object notFound)
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx < 0)
                    (§ return notFound)
                )
                (when (ß Util.equiv(key, array[idx]))
                    (§ return (ß array[idx + 1]))
                )
                notFound
            )
        )

        (§ method ISeq nodeSeq()
            (ß NodeSeq.create(array))
        )

        (§ method Iterator iterator(IFn f)
            (ß new NodeIter(array, f))
        )

        (§ method Object kvreduce(IFn f, Object init)
            (ß NodeSeq.kvreduce(array, f, init))
        )

        (§ method Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
            (ß NodeSeq.kvreduce(array, reducef, combinef.invoke()))
        )

        (§ method int findIndex(Object key)
            (loop-when-recur [(ß int i = 0)] (ß i < 2 * count) [(ß i += 2)]
                (when (ß Util.equiv(key, array[i]))
                    (§ return i)
                )
            )
            -1
        )

        (§ method- HashCollisionNode ensureEditable(AtomicReference<Thread> edit)
            (when (ß this.edit == edit)
                (§ return this)
            )
            (let [#_"Object[]" newArray (ß new Object[2 * (count + 1)])] ;; make room for next assoc
                (ß System.arraycopy(array, 0, newArray, 0, 2 * count))
                (ß new HashCollisionNode(edit, hash, count, newArray))
            )
        )

        (§ method- HashCollisionNode ensureEditable(AtomicReference<Thread> edit, int count, Object[] array)
            (when (ß this.edit == edit)
                (ß this.array = array)
                (ß this.count = count)
                (§ return this)
            )
            (ß new HashCollisionNode(edit, hash, count, array))
        )

        (§ method- HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
            (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = a)
                editable
            )
        )

        (§ method- HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
            (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                (ß editable.array[i] = a)
                (ß editable.array[j] = b)
                editable
            )
        )

        (§ method INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
            (when (ß hash == this.hash)
                (let [#_"int" idx (ß findIndex(key))]
                    (when (ß idx != -1)
                        (when (ß array[idx + 1] == val)
                            (§ return this)
                        )
                        (§ return (ß editAndSet(edit, idx + 1, val)))
                    )
                    (when (ß array.length > 2 * count)
                        (ß addedLeaf.val = addedLeaf)
                        (let [#_"HashCollisionNode" editable (ß editAndSet(edit, 2 * count, key, 2 * count + 1, val))]
                            (ß editable.count++)
                            (§ return editable)
                        )
                    )
                    (let [#_"Object[]" newArray (ß new Object[array.length + 2])]
                        (ß System.arraycopy(array, 0, newArray, 0, array.length))
                        (ß newArray[array.length] = key)
                        (ß newArray[array.length + 1] = val)
                        (ß addedLeaf.val = addedLeaf)
                        (§ return (ß ensureEditable(edit, count + 1, newArray)))
                    )
                )
            )
            ;; nest it in a bitmap node
            (ß new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] (§ nil, this, nil, nil )).assoc(edit, shift, hash, key, val, addedLeaf))
        )

        (§ method INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
            (let [#_"int" idx (ß findIndex(key))]
                (when (ß idx == -1)
                    (§ return this)
                )
                (ß removedLeaf.val = removedLeaf)
                (when (ß count == 1)
                    (§ return nil)
                )
                (let [#_"HashCollisionNode" editable (ß ensureEditable(edit))]
                    (ß editable.array[idx] = editable.array[2 * count - 2])
                    (ß editable.array[idx + 1] = editable.array[2 * count - 1])
                    (ß editable.array[2 * count - 2] = editable.array[2 * count - 1] = nil)
                    (ß editable.count--)
                    editable
                )
            )
        )
    )

    (§ defn- INode[] cloneAndSet(INode[] array, int i, INode a)
        (let [#_"INode[]" clone (ß array.clone())]
            (ß clone[i] = a)
            clone
        )
    )

    (§ defn- Object[] cloneAndSet(Object[] array, int i, Object a)
        (let [#_"Object[]" clone (ß array.clone())]
            (ß clone[i] = a)
            clone
        )
    )

    (§ defn- Object[] cloneAndSet(Object[] array, int i, Object a, int j, Object b)
        (let [#_"Object[]" clone (ß array.clone())]
            (ß clone[i] = a)
            (ß clone[j] = b)
            clone
        )
    )

    (§ defn- Object[] removePair(Object[] array, int i)
        (let [#_"Object[]" newArray (ß new Object[array.length - 2])]
            (ß System.arraycopy(array, 0, newArray, 0, 2 * i))
            (ß System.arraycopy(array, 2 * (i + 1), newArray, 2 * i, newArray.length - 2 * i))
            newArray
        )
    )

    (§ defn- INode createNode(int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
        (let [#_"int" key1hash (ß hash(key1))]
            (when (ß key1hash == key2hash)
                (§ return (ß new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
            )
            (let [#_"Box" addedLeaf (ß new Box(nil))]
                (let [#_"AtomicReference<Thread>" edit (ß new AtomicReference<Thread>())]
                    (ß BitmapIndexedNode.EMPTY.assoc(edit, shift, key1hash, key1, val1, addedLeaf).assoc(edit, shift, key2hash, key2, val2, addedLeaf))
                )
            )
        )
    )

    (§ defn- INode createNode(AtomicReference<Thread> edit, int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
        (let [#_"int" key1hash (ß hash(key1))]
            (when (ß key1hash == key2hash)
                (§ return (ß new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
            )
            (let [#_"Box" addedLeaf (ß new Box(nil))]
                (ß BitmapIndexedNode.EMPTY.assoc(edit, shift, key1hash, key1, val1, addedLeaf).assoc(edit, shift, key2hash, key2, val2, addedLeaf))
            )
        )
    )

    (§ defn- int bitpos(int hash, int shift)
        (ß 1 << mask(hash, shift))
    )

    (class-ns NodeIter (§ implements Iterator)
        (§ def- Object NULL = new Object())
        (§ field Object[] array)
        (§ field IFn f)
        (§ field- int i = 0)
        (§ field- Object nextEntry = NULL)
        (§ field- Iterator nextIter)

        (§ constructor NodeIter(Object[] array, IFn f)
            (ß this.array = array)
            (ß this.f = f)
            this
        )

        (§ method- boolean advance()
            (while (ß i < array.length)
                (let [#_"Object" key (ß array[i])]
                    (let [#_"Object" nodeOrVal (ß array[i + 1])]
                        (ß i += 2)
                        (cond (ß key != nil)
                            (do
                                (ß nextEntry = f.invoke(key, nodeOrVal))
                                (§ return true)
                            )
                            (ß nodeOrVal != nil)
                            (do
                                (let [#_"Iterator" iter (ß ((INode) nodeOrVal).iterator(f))]
                                    (when (ß iter != nil && iter.hasNext())
                                        (ß nextIter = iter)
                                        (§ return true)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            false
        )

        (§ method boolean hasNext()
            (when (ß nextEntry != NULL || nextIter != nil)
                (§ return true)
            )
            (ß advance())
        )

        (§ method Object next()
            (let [#_"Object" ret nextEntry]
                (cond (ß ret != NULL)
                    (do
                        (ß nextEntry = NULL)
                        (§ return ret)
                    )
                    (ß nextIter != nil)
                    (do
                        (ß ret = nextIter.next())
                        (when (ß !nextIter.hasNext())
                            (ß nextIter = nil)
                        )
                        (§ return ret)
                    )
                    (ß advance())
                    (do
                        (§ return (ß next()))
                    )
                )
                (throw (ß new NoSuchElementException()))
            )
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException()))
        )
    )

    (class-ns NodeSeq (§ extends ASeq)
        (§ field Object[] array)
        (§ field int i)
        (§ field ISeq s)

        (§ constructor NodeSeq(Object[] array, int i)
            (§ this(nil, array, i, nil))
            this
        )

        (§ defn ISeq create(Object[] array)
            (ß create(array, 0, nil))
        )

        (§ defn Object kvreduce(Object[] array, IFn f, Object init)
            (loop-when-recur [(ß int i = 0)] (ß i < array.length) [(ß i += 2)]
                (if (ß array[i] != nil)
                    (do
                        (ß init = f.invoke(init, array[i], array[i + 1]))
                    )
                    (do
                        (let [#_"INode" node (ß (INode) array[i + 1])]
                            (when (ß node != nil)
                                (ß init = node.kvreduce(f, init))
                            )
                        )
                    )
                )
                (when (ß RT.isReduced(init))
                    (§ return init)
                )
            )
            init
        )

        (§ defn- ISeq create(Object[] array, int i, ISeq s)
            (when (ß s != nil)
                (§ return (ß new NodeSeq(nil, array, i, s)))
            )
            (loop-when-recur [(ß int j = i)] (ß j < array.length) [(ß j+=2)]
                (when (ß array[j] != nil)
                    (§ return (ß new NodeSeq(nil, array, j, nil)))
                )
                (let [#_"INode" node (ß (INode) array[j + 1])]
                    (when (ß node != nil)
                        (let [#_"ISeq" nodeSeq (ß node.nodeSeq())]
                            (when (ß nodeSeq != nil)
                                (§ return (ß new NodeSeq(nil, array, j + 2, nodeSeq)))
                            )
                        )
                    )
                )
            )
            nil
        )

        (§ constructor NodeSeq(IPersistentMap meta, Object[] array, int i, ISeq s)
            (§ super(meta))
            (ß this.array = array)
            (ß this.i = i)
            (ß this.s = s)
            this
        )

        (§ method Obj withMeta(IPersistentMap meta)
            (ß new NodeSeq(meta, array, i, s))
        )

        (§ method Object first()
            (when (ß s != nil)
                (§ return (ß s.first()))
            )
            (ß MapEntry.create(array[i], array[i + 1]))
        )

        (§ method ISeq next()
            (when (ß s != nil)
                (§ return (ß create(array, i, s.next())))
            )
            (ß create(array, i + 2, nil))
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def PersistentHashSet EMPTY = new PersistentHashSet(nil, PersistentHashMap.EMPTY))

    (§ field IPersistentMap _meta)

    (§ defn PersistentHashSet create(Object... init)
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i++)]
                (ß ret = (ITransientSet)ret.conj(init[i]))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn PersistentHashSet create(List init)
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (doseq [#_"Object" key init]
                (ß ret = (ITransientSet) ret.conj(key))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn PersistentHashSet create(ISeq items)
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                (ß ret = (ITransientSet) ret.conj(items.first()))
            )
            (ß (PersistentHashSet)ret.persistent())
        )
    )

    (§ defn PersistentHashSet createWithCheck(Object... init)
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß i < init.length) [(ß i++)]
                (ß ret = (ITransientSet) ret.conj(init[i]))
                (when (ß ret.count() != i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + init[i])))
                )
            )
            (ß (PersistentHashSet) ret.persistent())
        )
    )

    (§ defn PersistentHashSet createWithCheck(List init)
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (let [#_"int" i 0]
                (doseq [#_"Object" key init]
                    (ß ret = (ITransientSet) ret.conj(key))
                    (when (ß ret.count() != i + 1)
                        (throw (ß new IllegalArgumentException("Duplicate key: " + key)))
                    )
                    (ß ++i)
                )
                (ß (PersistentHashSet) ret.persistent())
            )
        )
    )

    (§ defn PersistentHashSet createWithCheck(ISeq items)
        (let [#_"ITransientSet" ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß int i = 0)] (ß items != nil) [(ß items = items.next(), ++i)]
                (ß ret = (ITransientSet) ret.conj(items.first()))
                (when (ß ret.count() != i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + items.first())))
                )
            )
            (ß (PersistentHashSet) ret.persistent())
        )
    )

    (§ constructor PersistentHashSet(IPersistentMap meta, IPersistentMap impl)
        (§ super(impl))
        (ß this._meta = meta)
        this
    )

    (§ method IPersistentSet disjoin(Object key)
        (when (ß contains(key))
            (§ return (ß new PersistentHashSet(meta(), impl.without(key))))
        )
        this
    )

    (§ method IPersistentSet cons(Object o)
        (when (ß contains(o))
            (§ return this)
        )
        (ß new PersistentHashSet(meta(), impl.assoc(o, o)))
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ method PersistentHashSet withMeta(IPersistentMap meta)
        (ß new PersistentHashSet(meta, impl))
    )

    (§ method ITransientCollection asTransient()
        (ß new TransientHashSet(((PersistentHashMap) impl).asTransient()))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (class-ns TransientHashSet (§ extends ATransientSet)
        (§ constructor TransientHashSet(ITransientMap impl)
            (§ super(impl))
            this
        )

        (§ method IPersistentCollection persistent()
            (ß new PersistentHashSet(nil, impl.persistent()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ field- Object _first)
    (§ field- IPersistentList _rest)
    (§ field- int _count)

    (class-ns Primordial (§ extends RestFn)
        (§ method int getRequiredArity()
            0
        )

        #_protected
        (§ method Object doInvoke(Object args)
            (when (ß args instanceof ArraySeq)
                (let [#_"Object[]" argsarray (ß ((ArraySeq) args).array)]
                    (let [#_"IPersistentList" ret (ß EMPTY)]
                        (loop-when-recur [(ß int i = argsarray.length - 1)] (ß i >= ((ArraySeq)args).i) [(ß --i)]
                            (ß ret = (IPersistentList) ret.cons(argsarray[i]))
                        )
                        (§ return ret)
                    )
                )
            )
            (let [#_"LinkedList" list (ß new LinkedList())]
                (loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                    (ß list.add(s.first()))
                )
                (ß create(list))
            )
        )

        (§ defn Object invokeStatic(ISeq args)
            (when (ß args instanceof ArraySeq)
                (let [#_"Object[]" argsarray (ß ((ArraySeq) args).array)]
                    (let [#_"IPersistentList" ret (ß EMPTY)]
                        (loop-when-recur [(ß int i = argsarray.length - 1)] (ß i >= 0) [(ß --i)]
                            (ß ret = (IPersistentList) ret.cons(argsarray[i]))
                        )
                        (§ return ret)
                    )
                )
            )
            (let [#_"LinkedList" list (ß new LinkedList())]
                (loop-when-recur [(ß ISeq s = RT.seq(args))] (ß s != nil) [(ß s = s.next())]
                    (ß list.add(s.first()))
                )
                (ß create(list))
            )
        )

        (§ method IObj withMeta(IPersistentMap meta)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method IPersistentMap meta()
            nil
        )
    )

    (§ def IFn creator = new Primordial())

    (§ def EmptyList EMPTY = new EmptyList(nil))

    (§ constructor PersistentList(Object first)
        (ß this._first = first)
        (ß this._rest = nil)

        (ß this._count = 1)
        this
    )

    (§ constructor PersistentList(IPersistentMap meta, Object _first, IPersistentList _rest, int _count)
        (§ super(meta))
        (ß this._first = _first)
        (ß this._rest = _rest)
        (ß this._count = _count)
        this
    )

    (§ defn IPersistentList create(List init)
        (let [#_"IPersistentList" ret (ß EMPTY)]
            (loop-when-recur [(ß ListIterator i = init.listIterator(init.size()))] (ß i.hasPrevious()) [(ß )]
                (ß ret = (IPersistentList) ret.cons(i.previous()))
            )
            ret
        )
    )

    (§ method Object first()
        (ß _first)
    )

    (§ method ISeq next()
        (when (ß _count == 1)
            (§ return nil)
        )
        (ß (ISeq) _rest)
    )

    (§ method Object peek()
        (ß first())
    )

    (§ method IPersistentList pop()
        (when (ß _rest == nil)
            (§ return (ß EMPTY.withMeta(_meta)))
        )
        (ß _rest)
    )

    (§ method int count()
        (ß _count)
    )

    (§ method PersistentList cons(Object o)
        (ß new PersistentList(meta(), o, this, _count + 1))
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ method PersistentList withMeta(IPersistentMap meta)
        (when (ß meta != _meta)
            (§ return (ß new PersistentList(meta, _first, _rest, _count)))
        )
        this
    )

    (§ method Object reduce(IFn f)
        (let [#_"Object" ret (ß first())]
            (loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next())]
                (ß ret = f.invoke(ret, s.first()))
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
            )
            ret
        )
    )

    (§ method Object reduce(IFn f, Object start)
        (let [#_"Object" ret (ß f.invoke(start, first()))]
            (loop-when-recur [(ß ISeq s = next())] (ß s != nil) [(ß s = s.next())]
                (when (ß RT.isReduced(ret))
                    (§ return (ß ((IDeref)ret).deref()))
                )
                (ß ret = f.invoke(ret, s.first()))
            )
            (when (ß RT.isReduced(ret))
                (§ return (ß ((IDeref)ret).deref()))
            )
            ret
        )
    )

    (class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
        (§ def int hasheq = Murmur3.hashOrdered(Collections.EMPTY_LIST))

        (§ method int hashCode()
            1
        )

        (§ method int hasheq()
            hasheq
        )

        (§ method String toString()
            (ß "()")
        )

        (§ method boolean equals(Object o)
            (ß ((o instanceof Sequential || o instanceof List) && RT.seq(o) == nil))
        )

        (§ method boolean equiv(Object o)
            (ß equals(o))
        )

        (§ constructor EmptyList(IPersistentMap meta)
            (§ super(meta))
            this
        )

        (§ method Object first()
            nil
        )

        (§ method ISeq next()
            nil
        )

        (§ method ISeq more()
            this
        )

        (§ method PersistentList cons(Object o)
            (ß new PersistentList(meta(), o, nil, 1))
        )

        (§ method IPersistentCollection empty()
            this
        )

        (§ method EmptyList withMeta(IPersistentMap meta)
            (when (ß meta != meta())
                (§ return (ß new EmptyList(meta)))
            )
            this
        )

        (§ method Object peek()
            nil
        )

        (§ method IPersistentList pop()
            (throw (ß new IllegalStateException("Can't pop empty list")))
        )

        (§ method int count()
            0
        )

        (§ method ISeq seq()
            nil
        )

        (§ method int size()
            0
        )

        (§ method boolean isEmpty()
            true
        )

        (§ method boolean contains(Object o)
            false
        )

        (§ method Iterator iterator()
            (ß new Iterator()
                (§ reify
                    (§ method boolean hasNext()
                        false
                    )

                    (§ method Object next()
                        (throw (ß new NoSuchElementException()))
                    )

                    (§ method void remove()
                        (throw (ß new UnsupportedOperationException()))
                    )
                )
            )
        )

        (§ method Object[] toArray()
            (ß RT.EMPTY_ARRAY)
        )

        (§ method boolean add(Object o)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method boolean remove(Object o)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method boolean addAll(Collection collection)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method void clear()
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method boolean retainAll(Collection collection)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method boolean removeAll(Collection collection)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method boolean containsAll(Collection collection)
            (ß collection.isEmpty())
        )

        (§ method Object[] toArray(Object[] objects)
            (when (ß objects.length > 0)
                (ß objects[0] = nil)
            )
            objects
        )

        (§ method- List reify()
            (ß Collections.unmodifiableList(new ArrayList(this)))
        )

        (§ method List subList(int fromIndex, int toIndex)
            (ß reify().subList(fromIndex, toIndex))
        )

        (§ method Object set(int index, Object element)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method Object remove(int index)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method int indexOf(Object o)
            (let [#_"ISeq" s (ß seq())]
                (loop-when-recur [(ß int i = 0)] (ß s != nil) [(ß s = s.next(), i++)]
                    (when (ß Util.equiv(s.first(), o))
                        (§ return i)
                    )
                )
                -1
            )
        )

        (§ method int lastIndexOf(Object o)
            (ß reify().lastIndexOf(o))
        )

        (§ method ListIterator listIterator()
            (ß reify().listIterator())
        )

        (§ method ListIterator listIterator(int index)
            (ß reify().listIterator(index))
        )

        (§ method Object get(int index)
            (ß RT.nth(this, index))
        )

        (§ method void add(int index, Object element)
            (throw (ß new UnsupportedOperationException()))
        )

        (§ method boolean addAll(int index, Collection c)
            (throw (ß new UnsupportedOperationException()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def PersistentQueue EMPTY = new PersistentQueue(nil, 0, nil, nil))

    (§ field int cnt)
    (§ field ISeq f)
    (§ field PersistentVector r)
    (§ field int _hash)
    (§ field int _hasheq)

    (§ constructor PersistentQueue(IPersistentMap meta, int cnt, ISeq f, PersistentVector r)
        (§ super(meta))
        (ß this.cnt = cnt)
        (ß this.f = f)
        (ß this.r = r)
        this
    )

    (§ method boolean equiv(Object obj)
        (when (ß !(obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
                (when (ß ms == nil || !Util.equiv(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    (§ method boolean equals(Object obj)
        (when (ß !(obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ms (ß RT.seq(obj))]
            (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next(), ms = ms.next())]
                (when (ß ms == nil || !Util.equals(s.first(), ms.first()))
                    (§ return false)
                )
            )
            (ß (ms == nil))
        )
    )

    (§ method int hashCode()
        (let [#_"int" hash (ß this._hash)]
            (when (ß hash == 0)
                (ß hash = 1)
                (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
                    (ß hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode()))
                )
                (ß this._hash = hash)
            )
            hash
        )
    )

    (§ method int hasheq()
        (let [#_"int" cached (ß this._hasheq)]
            (when (ß cached == 0)
                (ß this._hasheq = cached = Murmur3.hashOrdered(this))
            )
            cached
        )
    )

    (§ method Object peek()
        (ß RT.first(f))
    )

    (§ method PersistentQueue pop()
        (when (ß f == nil) ;; hmmm... pop of empty queue -> empty queue?
            (§ return this)
        )
        (let [#_"ISeq" f1 (ß f.next())]
            (let [#_"PersistentVector" r1 r]
                (when (ß f1 == nil)
                    (ß f1 = RT.seq(r))
                    (ß r1 = nil)
                )
                (ß new PersistentQueue(meta(), cnt - 1, f1, r1))
            )
        )
    )

    (§ method int count()
        cnt
    )

    (§ method ISeq seq()
        (when (ß f == nil)
            (§ return nil)
        )
        (ß new Seq(f, RT.seq(r)))
    )

    (§ method PersistentQueue cons(Object o)
        (if (ß f == nil) ;; empty
            (do
                (ß new PersistentQueue(meta(), cnt + 1, RT.list(o), nil))
            )
            (do
                (ß new PersistentQueue(meta(), cnt + 1, f, ((r != nil) ? r :or PersistentVector.EMPTY).cons(o)))
            )
        )
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ method PersistentQueue withMeta(IPersistentMap meta)
        (ß new PersistentQueue(meta, cnt, f, r))
    )

    (class-ns Seq (§ extends ASeq)
        (§ field ISeq f)
        (§ field ISeq rseq)

        (§ constructor Seq(ISeq f, ISeq rseq)
            (ß this.f = f)
            (ß this.rseq = rseq)
            this
        )

        (§ constructor Seq(IPersistentMap meta, ISeq f, ISeq rseq)
            (§ super(meta))
            (ß this.f = f)
            (ß this.rseq = rseq)
            this
        )

        (§ method Object first()
            (ß f.first())
        )

        (§ method ISeq next()
            (let [#_"ISeq" f1 (ß f.next())]
                (let [#_"ISeq" r1 rseq]
                    (when (ß f1 == nil)
                        (when (ß rseq == nil)
                            (§ return nil)
                        )
                        (ß f1 = rseq)
                        (ß r1 = nil)
                    )
                    (ß new Seq(f1, r1))
                )
            )
        )

        (§ method int count()
            (ß RT.count(f) + RT.count(rseq))
        )

        (§ method Seq withMeta(IPersistentMap meta)
            (ß new Seq(meta, f, rseq))
        )
    )

    (§ method Object[] toArray()
        (ß RT.seqToArray(seq()))
    )

    (§ method boolean add(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean remove(Object o)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean addAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method void clear()
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean retainAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean removeAll(Collection c)
        (throw (ß new UnsupportedOperationException()))
    )

    (§ method boolean containsAll(Collection c)
        (doseq [#_"Object" o c]
            (when (ß contains(o))
                (§ return true)
            )
        )
        false
    )

    (§ method Object[] toArray(Object[] a)
        (ß RT.seqToPassedArray(seq(), a))
    )

    (§ method int size()
        (ß count())
    )

    (§ method boolean isEmpty()
        (ß (count() == 0))
    )

    (§ method boolean contains(Object o)
        (loop-when-recur [(ß ISeq s = seq())] (ß s != nil) [(ß s = s.next())]
            (when (ß Util.equiv(s.first(), o))
                (§ return true)
            )
        )
        false
    )

    (§ method Iterator iterator()
        (ß new Iterator()
            (§ reify
                (§ field- ISeq fseq = f)
                (§ field- Iterator riter = (r != nil) ? r.iterator() :or nil)

                (§ method boolean hasNext()
                    (ß ((fseq != nil && fseq.seq() != nil) || (riter != nil && riter.hasNext())))
                )

                (§ method Object next()
                    (cond (ß fseq != nil)
                        (do
                            (let [#_"Object" ret (ß fseq.first())]
                                (ß fseq = fseq.next())
                                ret
                            )
                        )
                        (ß riter != nil && riter.hasNext())
                        (do
                            (ß riter.next())
                        )
                        :else
                        (do
                            (throw (ß new NoSuchElementException()))
                        )
                    )
                )

                (§ method void remove()
                    (throw (ß new UnsupportedOperationException()))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ field Comparator comp)
    (§ field Node tree)
    (§ field int _count)
    (§ field IPersistentMap _meta)

    (§ def PersistentTreeMap EMPTY = new PersistentTreeMap())

    (§ defn IPersistentMap create(Map other)
        (let [#_"IPersistentMap" ret (ß EMPTY)]
            (doseq [#_"Object" o (ß other.entrySet())]
                (let [(ß Map.Entry e = (Entry) o)]
                    (ß ret = ret.assoc(e.getKey(), e.getValue()))
                )
            )
            ret
        )
    )

    (§ constructor PersistentTreeMap()
        (§ this(RT.DEFAULT_COMPARATOR))
        this
    )

    (§ method PersistentTreeMap withMeta(IPersistentMap meta)
        (ß new PersistentTreeMap(meta, comp, tree, _count))
    )

    (§ constructor- PersistentTreeMap(Comparator comp)
        (§ this(nil, comp))
        this
    )

    (§ constructor PersistentTreeMap(IPersistentMap meta, Comparator comp)
        (ß this.comp = comp)
        (ß this._meta = meta)
        (ß tree = nil)
        (ß _count = 0)
        this
    )

    (§ constructor PersistentTreeMap(IPersistentMap meta, Comparator comp, Node tree, int _count)
        (ß this._meta = meta)
        (ß this.comp = comp)
        (ß this.tree = tree)
        (ß this._count = _count)
        this
    )

    (§ defn PersistentTreeMap create(ISeq items)
        (let [#_"IPersistentMap" ret (ß EMPTY)]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (ß ret = ret.assoc(items.first(), RT.second(items)))
            )
            (ß (PersistentTreeMap) ret)
        )
    )

    (§ defn PersistentTreeMap create(Comparator comp, ISeq items)
        (let [#_"IPersistentMap" ret (ß new PersistentTreeMap(comp))]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next().next())]
                (when (ß items.next() == nil)
                    (throw (ß new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))))
                )
                (ß ret = ret.assoc(items.first(), RT.second(items)))
            )
            (ß (PersistentTreeMap) ret)
        )
    )

    (§ method boolean containsKey(Object key)
        (ß (entryAt(key) != nil))
    )

    (§ method boolean equals(Object obj)
        (try
            (ß super.equals(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    (§ method boolean equiv(Object obj)
        (try
            (ß super.equiv(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    (§ method PersistentTreeMap assocEx(Object key, Object val)
        (let [#_"Box" found (ß new Box(nil))]
            (let [#_"Node" t (ß add(tree, key, val, found))]
                (when (ß t == nil) ;; nil == already contains key
                    (throw (ß Util.runtimeException("Key already present")))
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count + 1, meta()))
            )
        )
    )

    (§ method PersistentTreeMap assoc(Object key, Object val)
        (let [#_"Box" found (ß new Box(nil))]
            (let [#_"Node" t (ß add(tree, key, val, found))]
                (when (ß t == nil) ;; nil == already contains key
                    (let [#_"Node" foundNode (ß (Node) found.val)]
                        (when (ß foundNode.val() == val) ;; note only get same collection on identity of val, not equals()
                            (§ return this)
                        )
                        (§ return (ß new PersistentTreeMap(comp, replace(tree, key, val), _count, meta())))
                    )
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count + 1, meta()))
            )
        )
    )

    (§ method PersistentTreeMap without(Object key)
        (let [#_"Box" found (ß new Box(nil))]
            (let [#_"Node" t (ß remove(tree, key, found))]
                (when (ß t == nil)
                    (when (ß found.val == nil) ;; nil == doesn't contain key
                        (§ return this)
                    )
                    ;; empty
                    (§ return (ß new PersistentTreeMap(meta(), comp)))
                )
                (ß new PersistentTreeMap(comp, t.blacken(), _count - 1, meta()))
            )
        )
    )

    (§ method ISeq seq()
        (when (ß _count > 0)
            (§ return (ß Seq.create(tree, true, _count)))
        )
        nil
    )

    (§ method IPersistentCollection empty()
        (ß new PersistentTreeMap(meta(), comp))
    )

    (§ method ISeq rseq()
        (when (ß _count > 0)
            (§ return (ß Seq.create(tree, false, _count)))
        )
        nil
    )

    (§ method Comparator comparator()
        comp
    )

    (§ method Object entryKey(Object entry)
        (ß ((IMapEntry) entry).key())
    )

    (§ method ISeq seq(boolean ascending)
        (when (ß _count > 0)
            (§ return (ß Seq.create(tree, ascending, _count)))
        )
        nil
    )

    (§ method ISeq seqFrom(Object key, boolean ascending)
        (when (ß _count > 0)
            (let [#_"ISeq" stack nil]
                (let [#_"Node" t tree]
                    (while (ß t != nil)
                        (let [#_"int" c (ß doCompare(key, t.key))]
                            (cond (ß c == 0)
                                (do
                                    (ß stack = RT.cons(t, stack))
                                    (§ return (ß new Seq(stack, ascending)))
                                )
                                ascending
                                (do
                                    (if (ß c < 0)
                                        (do
                                            (ß stack = RT.cons(t, stack))
                                            (ß t = t.left())
                                        )
                                        (do
                                            (ß t = t.right())
                                        )
                                    )
                                )
                                :else
                                (do
                                    (if (ß c > 0)
                                        (do
                                            (ß stack = RT.cons(t, stack))
                                            (ß t = t.right())
                                        )
                                        (do
                                            (ß t = t.left())
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when (ß stack != nil)
                        (§ return (ß new Seq(stack, ascending)))
                    )
                )
            )
        )
        nil
    )

    (§ method NodeIterator iterator()
        (ß new NodeIterator(tree, true))
    )

    (§ method Object kvreduce(IFn f, Object init)
        (when (ß tree != nil)
            (ß init = tree.kvreduce(f, init))
        )
        (when (ß RT.isReduced(init))
            (ß init = ((IDeref)init).deref())
        )
        init
    )

    (§ method NodeIterator reverseIterator()
        (ß new NodeIterator(tree, false))
    )

    (§ method Iterator keys()
        (ß keys(iterator()))
    )

    (§ method Iterator vals()
        (ß vals(iterator()))
    )

    (§ method Iterator keys(NodeIterator it)
        (ß new KeyIterator(it))
    )

    (§ method Iterator vals(NodeIterator it)
        (ß new ValIterator(it))
    )

    (§ method Object minKey()
        (let [#_"Node" t (ß min())]
            (ß (t != nil) ? t.key :or nil)
        )
    )

    (§ method Node min()
        (let [#_"Node" t tree]
            (when (ß t != nil)
                (while (ß t.left() != nil)
                    (ß t = t.left())
                )
            )
            t
        )
    )

    (§ method Object maxKey()
        (let [#_"Node" t (ß max())]
            (ß (t != nil) ? t.key :or nil)
        )
    )

    (§ method Node max()
        (let [#_"Node" t tree]
            (when (ß t != nil)
                (while (ß t.right() != nil)
                    (ß t = t.right())
                )
            )
            t
        )
    )

    (§ method int depth()
        (ß depth(tree))
    )

    (§ method int depth(Node t)
        (when (ß t == nil)
            (§ return 0)
        )
        (ß 1 + Math.max(depth(t.left()), depth(t.right())))
    )

    (§ method Object valAt(Object key, Object notFound)
        (let [#_"Node" n (ß entryAt(key))]
            (ß (n != nil) ? n.val() :or notFound)
        )
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method int capacity()
        (ß _count)
    )

    (§ method int count()
        (ß _count)
    )

    (§ method Node entryAt(Object key)
        (let [#_"Node" t tree]
            (while (ß t != nil)
                (let [#_"int" c (ß doCompare(key, t.key))]
                    (cond (ß c == 0)
                        (do
                            (§ return t)
                        )
                        (ß c < 0)
                        (do
                            (ß t = t.left())
                        )
                        :else
                        (do
                            (ß t = t.right())
                        )
                    )
                )
            )
            t
        )
    )

    (§ method int doCompare(Object k1, Object k2)
        (ß comp.compare(k1, k2))
    )

    (§ method Node add(Node t, Object key, Object val, Box found)
        (when (ß t == nil)
            (when (ß val == nil)
                (§ return (ß new Red(key)))
            )
            (§ return (ß new RedVal(key, val)))
        )
        (let [#_"int" c (ß doCompare(key, t.key))]
            (when (ß c == 0)
                (ß found.val = t)
                (§ return nil)
            )
            (let [#_"Node" ins (ß (c < 0) ? add(t.left(), key, val, found) :or add(t.right(), key, val, found))]
                (when (ß ins == nil) ;; found below
                    (§ return nil)
                )
                (when (ß c < 0)
                    (§ return (ß t.addLeft(ins)))
                )
                (ß t.addRight(ins))
            )
        )
    )

    (§ method Node remove(Node t, Object key, Box found)
        (when (ß t == nil)
            (§ return nil) ;; not found indicator
        )
        (let [#_"int" c (ß doCompare(key, t.key))]
            (when (ß c == 0)
                (ß found.val = t)
                (§ return (ß append(t.left(), t.right())))
            )
            (let [#_"Node" del (ß (c < 0) ? remove(t.left(), key, found) :or remove(t.right(), key, found))]
                (when (ß del == nil && found.val == nil) ;; not found below
                    (§ return nil)
                )
                (when (ß c < 0)
                    (if (ß t.left() instanceof Black)
                        (do
                            (§ return (ß balanceLeftDel(t.key, t.val(), del, t.right())))
                        )
                        (do
                            (§ return (ß red(t.key, t.val(), del, t.right())))
                        )
                    )
                )
                (when (ß t.right() instanceof Black)
                    (§ return (ß balanceRightDel(t.key, t.val(), t.left(), del)))
                )
                (ß red(t.key, t.val(), t.left(), del))
            )
        )
    )

    (§ defn Node append(Node left, Node right)
        (cond (ß left == nil)
            (do
                right
            )
            (ß right == nil)
            (do
                left
            )
            (ß left instanceof Red)
            (do
                (if (ß right instanceof Red)
                    (do
                        (let [#_"Node" app (ß append(left.right(), right.left()))]
                            (if (ß app instanceof Red)
                                (do
                                    (ß red(app.key, app.val(), red(left.key, left.val(), left.left(), app.left()), red(right.key, right.val(), app.right(), right.right())))
                                )
                                (do
                                    (ß red(left.key, left.val(), left.left(), red(right.key, right.val(), app, right.right())))
                                )
                            )
                        )
                    )
                    (do
                        (ß red(left.key, left.val(), left.left(), append(left.right(), right)))
                    )
                )
            )
            (ß right instanceof Red)
            (do
                (ß red(right.key, right.val(), append(left, right.left()), right.right()))
            )
            :else ;; black/black
            (do
                (let [#_"Node" app (ß append(left.right(), right.left()))]
                    (if (ß app instanceof Red)
                        (do
                            (ß red(app.key, app.val(), black(left.key, left.val(), left.left(), app.left()), black(right.key, right.val(), app.right(), right.right())))
                        )
                        (do
                            (ß balanceLeftDel(left.key, left.val(), left.left(), black(right.key, right.val(), app, right.right())))
                        )
                    )
                )
            )
        )
    )

    (§ defn Node balanceLeftDel(Object key, Object val, Node del, Node right)
        (cond (ß del instanceof Red)
            (do
                (ß red(key, val, del.blacken(), right))
            )
            (ß right instanceof Black)
            (do
                (ß rightBalance(key, val, del, right.redden()))
            )
            (ß right instanceof Red && right.left() instanceof Black)
            (do
                (ß red(right.left().key, right.left().val(), black(key, val, del, right.left().left()), rightBalance(right.key, right.val(), right.left().right(), right.right().redden())))
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("Invariant violation")))
            )
        )
    )

    (§ defn Node balanceRightDel(Object key, Object val, Node left, Node del)
        (cond (ß del instanceof Red)
            (do
                (ß red(key, val, left, del.blacken()))
            )
            (ß left instanceof Black)
            (do
                (ß leftBalance(key, val, left.redden(), del))
            )
            (ß left instanceof Red && left.right() instanceof Black)
            (do
                (ß red(left.right().key, left.right().val(), leftBalance(left.key, left.val(), left.left().redden(), left.right().left()), black(key, val, left.right().right(), del)))
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("Invariant violation")))
            )
        )
    )

    (§ defn Node leftBalance(Object key, Object val, Node ins, Node right)
        (cond (ß ins instanceof Red && ins.left() instanceof Red)
            (do
                (ß red(ins.key, ins.val(), ins.left().blacken(), black(key, val, ins.right(), right)))
            )
            (ß ins instanceof Red && ins.right() instanceof Red)
            (do
                (ß red(ins.right().key, ins.right().val(), black(ins.key, ins.val(), ins.left(), ins.right().left()), black(key, val, ins.right().right(), right)))
            )
            :else
            (do
                (ß black(key, val, ins, right))
            )
        )
    )

    (§ defn Node rightBalance(Object key, Object val, Node left, Node ins)
        (cond (ß ins instanceof Red && ins.right() instanceof Red)
            (do
                (ß red(ins.key, ins.val(), black(key, val, left, ins.left()), ins.right().blacken()))
            )
            (ß ins instanceof Red && ins.left() instanceof Red)
            (do
                (ß red(ins.left().key, ins.left().val(), black(key, val, left, ins.left().left()), black(ins.key, ins.val(), ins.left().right(), ins.right())))
            )
            :else
            (do
                (ß black(key, val, left, ins))
            )
        )
    )

    (§ method Node replace(Node t, Object key, Object val)
        (let [#_"int" c (ß doCompare(key, t.key))]
            (ß t.replace(t.key, (c == 0) ? val :or t.val(), (c < 0) ? replace(t.left(), key, val) :or t.left(), (c > 0) ? replace(t.right(), key, val) :or t.right()))
        )
    )

    (§ constructor PersistentTreeMap(Comparator comp, Node tree, int count, IPersistentMap meta)
        (ß this._meta = meta)
        (ß this.comp = comp)
        (ß this.tree = tree)
        (ß this._count = count)
        this
    )

    (§ defn Red red(Object key, Object val, Node left, Node right)
        (when (ß left == nil && right == nil)
            (when (ß val == nil)
                (§ return (ß new Red(key)))
            )
            (§ return (ß new RedVal(key, val)))
        )
        (when (ß val == nil)
            (§ return (ß new RedBranch(key, left, right)))
        )
        (ß new RedBranchVal(key, val, left, right))
    )

    (§ defn Black black(Object key, Object val, Node left, Node right)
        (when (ß left == nil && right == nil)
            (when (ß val == nil)
                (§ return (ß new Black(key)))
            )
            (§ return (ß new BlackVal(key, val)))
        )
        (when (ß val == nil)
            (§ return (ß new BlackBranch(key, left, right)))
        )
        (ß new BlackBranchVal(key, val, left, right))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    #_abstract
    (class-ns Node (§ extends AMapEntry)
        (§ field Object key)

        (§ constructor Node(Object key)
            (ß this.key = key)
            this
        )

        (§ method Object key()
            key
        )

        (§ method Object val()
            nil
        )

        (§ method Object getKey()
            (ß key())
        )

        (§ method Object getValue()
            (ß val())
        )

        (§ method Node left()
            nil
        )

        (§ method Node right()
            nil
        )

        (§ abstract Node addLeft(Node ins))
        (§ abstract Node addRight(Node ins))
        (§ abstract Node removeLeft(Node del))
        (§ abstract Node removeRight(Node del))
        (§ abstract Node blacken())
        (§ abstract Node redden())

        (§ method Node balanceLeft(Node parent)
            (ß black(parent.key, parent.val(), this, parent.right()))
        )

        (§ method Node balanceRight(Node parent)
            (ß black(parent.key, parent.val(), parent.left(), this))
        )

        (§ abstract Node replace(Object key, Object val, Node left, Node right))

        (§ method Object kvreduce(IFn f, Object init)
            (when (ß left() != nil)
                (ß init = left().kvreduce(f, init))
                (when (ß RT.isReduced(init))
                    (§ return init)
                )
            )
            (ß init = f.invoke(init, key(), val()))
            (when (ß RT.isReduced(init))
                (§ return init)
            )

            (when (ß right() != nil)
                (ß init = right().kvreduce(f, init))
            )
            init
        )
    )

    (class-ns Black (§ extends Node)
        (§ constructor Black(Object key)
            (§ super(key))
            this
        )

        (§ method Node addLeft(Node ins)
            (ß ins.balanceLeft(this))
        )

        (§ method Node addRight(Node ins)
            (ß ins.balanceRight(this))
        )

        (§ method Node removeLeft(Node del)
            (ß balanceLeftDel(key, val(), del, right()))
        )

        (§ method Node removeRight(Node del)
            (ß balanceRightDel(key, val(), left(), del))
        )

        (§ method Node blacken()
            this
        )

        (§ method Node redden()
            (ß new Red(key))
        )

        (§ method Node replace(Object key, Object val, Node left, Node right)
            (ß black(key, val, left, right))
        )
    )

    (class-ns BlackVal (§ extends Black)
        (§ field Object val)

        (§ constructor BlackVal(Object key, Object val)
            (§ super(key))
            (ß this.val = val)
            this
        )

        (§ method Object val()
            val
        )

        (§ method Node redden()
            (ß new RedVal(key, val))
        )
    )

    (class-ns BlackBranch (§ extends Black)
        (§ field Node left)

        (§ field Node right)

        (§ constructor BlackBranch(Object key, Node left, Node right)
            (§ super(key))
            (ß this.left = left)
            (ß this.right = right)
            this
        )

        (§ method Node left()
            left
        )

        (§ method Node right()
            right
        )

        (§ method Node redden()
            (ß new RedBranch(key, left, right))
        )
    )

    (class-ns BlackBranchVal (§ extends BlackBranch)
        (§ field Object val)

        (§ constructor BlackBranchVal(Object key, Object val, Node left, Node right)
            (§ super(key, left, right))
            (ß this.val = val)
            this
        )

        (§ method Object val()
            val
        )

        (§ method Node redden()
            (ß new RedBranchVal(key, val, left, right))
        )
    )

    (class-ns Red (§ extends Node)
        (§ constructor Red(Object key)
            (§ super(key))
            this
        )

        (§ method Node addLeft(Node ins)
            (ß red(key, val(), ins, right()))
        )

        (§ method Node addRight(Node ins)
            (ß red(key, val(), left(), ins))
        )

        (§ method Node removeLeft(Node del)
            (ß red(key, val(), del, right()))
        )

        (§ method Node removeRight(Node del)
            (ß red(key, val(), left(), del))
        )

        (§ method Node blacken()
            (ß new Black(key))
        )

        (§ method Node redden()
            (throw (ß new UnsupportedOperationException("Invariant violation")))
        )

        (§ method Node replace(Object key, Object val, Node left, Node right)
            (ß red(key, val, left, right))
        )
    )

    (class-ns RedVal (§ extends Red)
        (§ field Object val)

        (§ constructor RedVal(Object key, Object val)
            (§ super(key))
            (ß this.val = val)
            this
        )

        (§ method Object val()
            val
        )

        (§ method Node blacken()
            (ß new BlackVal(key, val))
        )
    )

    (class-ns RedBranch (§ extends Red)
        (§ field Node left)

        (§ field Node right)

        (§ constructor RedBranch(Object key, Node left, Node right)
            (§ super(key))
            (ß this.left = left)
            (ß this.right = right)
            this
        )

        (§ method Node left()
            left
        )

        (§ method Node right()
            right
        )

        (§ method Node balanceLeft(Node parent)
            (cond (ß left instanceof Red)
                (do
                    (ß red(key, val(), left.blacken(), black(parent.key, parent.val(), right, parent.right())))
                )
                (ß right instanceof Red)
                (do
                    (ß red(right.key, right.val(), black(key, val(), left, right.left()), black(parent.key, parent.val(), right.right(), parent.right())))
                )
                :else
                (do
                    (ß super.balanceLeft(parent))
                )
            )
        )

        (§ method Node balanceRight(Node parent)
            (cond (ß right instanceof Red)
                (do
                    (ß red(key, val(), black(parent.key, parent.val(), parent.left(), left), right.blacken()))
                )
                (ß left instanceof Red)
                (do
                    (ß red(left.key, left.val(), black(parent.key, parent.val(), parent.left(), left.left()), black(key, val(), left.right(), right)))
                )
                :else
                (do
                    (ß super.balanceRight(parent))
                )
            )
        )

        (§ method Node blacken()
            (ß new BlackBranch(key, left, right))
        )
    )

    (class-ns RedBranchVal (§ extends RedBranch)
        (§ field Object val)

        (§ constructor RedBranchVal(Object key, Object val, Node left, Node right)
            (§ super(key, left, right))
            (ß this.val = val)
            this
        )

        (§ method Object val()
            val
        )

        (§ method Node blacken()
            (ß new BlackBranchVal(key, val, left, right))
        )
    )

    (class-ns Seq (§ extends ASeq)
        (§ field ISeq stack)
        (§ field boolean asc)
        (§ field int cnt)

        (§ constructor Seq(ISeq stack, boolean asc)
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = -1)
            this
        )

        (§ constructor Seq(ISeq stack, boolean asc, int cnt)
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = cnt)
            this
        )

        (§ constructor Seq(IPersistentMap meta, ISeq stack, boolean asc, int cnt)
            (§ super(meta))
            (ß this.stack = stack)
            (ß this.asc = asc)
            (ß this.cnt = cnt)
            this
        )

        (§ defn Seq create(Node t, boolean asc, int cnt)
            (ß new Seq(push(t, nil, asc), asc, cnt))
        )

        (§ defn ISeq push(Node t, ISeq stack, boolean asc)
            (while (ß t != nil)
                (ß stack = RT.cons(t, stack))
                (ß t = asc ? t.left() :or t.right())
            )
            stack
        )

        (§ method Object first()
            (ß stack.first())
        )

        (§ method ISeq next()
            (let [#_"Node" t (ß (Node) stack.first())]
                (let [#_"ISeq" nextstack (ß push(asc ? t.right() :or t.left(), stack.next(), asc))]
                    (when (ß nextstack != nil)
                        (§ return (ß new Seq(nextstack, asc, cnt - 1)))
                    )
                    nil
                )
            )
        )

        (§ method int count()
            (when (ß cnt < 0)
                (§ return (ß super.count()))
            )
            cnt
        )

        (§ method Obj withMeta(IPersistentMap meta)
            (ß new Seq(meta, stack, asc, cnt))
        )
    )

    (class-ns NodeIterator (§ implements Iterator)
        (§ field Stack stack = new Stack())
        (§ field boolean asc)

        (§ constructor NodeIterator(Node t, boolean asc)
            (ß this.asc = asc)
            (ß push(t))
            this
        )

        (§ method void push(Node t)
            (while (ß t != nil)
                (ß stack.push(t))
                (ß t = asc ? t.left() :or t.right())
            )
            nil
        )

        (§ method boolean hasNext()
            (ß !stack.isEmpty())
        )

        (§ method Object next()
            (try
                (let [#_"Node" t (ß (Node) stack.pop())]
                    (ß push(asc ? t.right() :or t.left()))
                    t
                )
                (catch EmptyStackException e
                    (throw (ß new NoSuchElementException()))
                )
            )
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException()))
        )
    )

    (class-ns KeyIterator (§ implements Iterator)
        (§ field NodeIterator it)

        (§ constructor KeyIterator(NodeIterator it)
            (ß this.it = it)
            this
        )

        (§ method boolean hasNext()
            (ß it.hasNext())
        )

        (§ method Object next()
            (ß ((Node) it.next()).key)
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException()))
        )
    )

    (class-ns ValIterator (§ implements Iterator)
        (§ field NodeIterator it)

        (§ constructor ValIterator(NodeIterator it)
            (ß this.it = it)
            this
        )

        (§ method boolean hasNext()
            (ß it.hasNext())
        )

        (§ method Object next()
            (ß ((Node) it.next()).val())
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def PersistentTreeSet EMPTY = new PersistentTreeSet(nil, PersistentTreeMap.EMPTY))

    (§ field IPersistentMap _meta)

    (§ defn PersistentTreeSet create(ISeq items)
        (let [#_"PersistentTreeSet" ret (ß EMPTY)]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                (ß ret = (PersistentTreeSet) ret.cons(items.first()))
            )
            ret
        )
    )

    (§ defn PersistentTreeSet create(Comparator comp, ISeq items)
        (let [#_"PersistentTreeSet" ret (ß new PersistentTreeSet(nil, new PersistentTreeMap(nil, comp)))]
            (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                (ß ret = (PersistentTreeSet) ret.cons(items.first()))
            )
            ret
        )
    )

    (§ constructor PersistentTreeSet(IPersistentMap meta, IPersistentMap impl)
        (§ super(impl))
        (ß this._meta = meta)
        this
    )

    (§ method boolean equals(Object obj)
        (try
            (ß super.equals(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    (§ method boolean equiv(Object obj)
        (try
            (ß super.equiv(obj))
            (catch ClassCastException e
                false
            )
        )
    )

    (§ method IPersistentSet disjoin(Object key)
        (when (ß contains(key))
            (§ return (ß new PersistentTreeSet(meta(), impl.without(key))))
        )
        this
    )

    (§ method IPersistentSet cons(Object o)
        (when (ß contains(o))
            (§ return this)
        )
        (ß new PersistentTreeSet(meta(), impl.assoc(o, o)))
    )

    (§ method IPersistentCollection empty()
        (ß new PersistentTreeSet(meta(), (PersistentTreeMap)impl.empty()))
    )

    (§ method ISeq rseq()
        (ß APersistentMap.KeySeq.create(((Reversible) impl).rseq()))
    )

    (§ method PersistentTreeSet withMeta(IPersistentMap meta)
        (ß new PersistentTreeSet(meta, impl))
    )

    (§ method Comparator comparator()
        (ß ((Sorted)impl).comparator())
    )

    (§ method Object entryKey(Object entry)
        entry
    )

    (§ method ISeq seq(boolean ascending)
        (let [#_"PersistentTreeMap" m (ß (PersistentTreeMap) impl)]
            (ß RT.keys(m.seq(ascending)))
        )
    )

    (§ method ISeq seqFrom(Object key, boolean ascending)
        (let [#_"PersistentTreeMap" m (ß (PersistentTreeMap) impl)]
            (ß RT.keys(m.seqFrom(key, ascending)))
        )
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (class-ns Node
        #_transient
        (§ field AtomicReference<Thread> edit)
        (§ field Object[] array)

        (§ constructor Node(AtomicReference<Thread> edit, Object[] array)
            (ß this.edit = edit)
            (ß this.array = array)
            this
        )

        (§ constructor Node(AtomicReference<Thread> edit)
            (ß this.edit = edit)
            (ß this.array = new Object[32])
            this
        )
    )

    (§ def AtomicReference<Thread> NOEDIT = new AtomicReference<Thread>(nil))
    (§ def Node EMPTY_NODE = new Node(NOEDIT, new Object[32]))

    (§ field int cnt)
    (§ field int shift)
    (§ field Node root)
    (§ field Object[] tail)
    (§ field IPersistentMap _meta)

    (§ def PersistentVector EMPTY = new PersistentVector(0, 5, EMPTY_NODE, new Object[] (§)))

    (§ def- IFn TRANSIENT_VECTOR_CONJ = new AFn()
        (§ reify
            (§ method Object invoke(Object coll, Object val)
                (ß ((ITransientVector)coll).conj(val))
            )
            (§ method Object invoke(Object coll)
                coll
            )
        )
    )

    (§ defn PersistentVector adopt(Object [] items)
        (ß new PersistentVector(items.length, 5, EMPTY_NODE, items))
    )

    (§ defn PersistentVector create(IReduceInit items)
        (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
            (ß items.reduce(TRANSIENT_VECTOR_CONJ, ret))
            (ß ret.persistent())
        )
    )

    (§ defn PersistentVector create(ISeq items)
        (let [#_"Object[]" arr (ß new Object[32])]
            (let [#_"int" i 0]
                (loop-when-recur [(ß )] (ß items != nil && i < 32) [(ß items = items.next())]
                    (ß arr[i++] = items.first())
                )

                (cond (ß items != nil) ;; >32, construct with array directly
                    (do
                        (let [#_"PersistentVector" start (ß new PersistentVector(32, 5, EMPTY_NODE, arr))]
                            (let [#_"TransientVector" ret (ß start.asTransient())]
                                (loop-when-recur [(ß )] (ß items != nil) [(ß items = items.next())]
                                    (ß ret = ret.conj(items.first()))
                                )
                                (ß ret.persistent())
                            )
                        )
                    )
                    (ß i == 32) ;; exactly 32, skip copy
                    (do
                        (ß new PersistentVector(32, 5, EMPTY_NODE, arr))
                    )
                    :else ;; <32, copy to minimum array and construct
                    (do
                        (let [#_"Object[]" arr2 (ß new Object[i])]
                            (ß System.arraycopy(arr, 0, arr2, 0, i))
                            (ß new PersistentVector(i, 5, EMPTY_NODE, arr2))
                        )
                    )
                )
            )
        )
    )

    (§ defn PersistentVector create(List list)
        (let [#_"int" size (ß list.size())]
            (when (ß size <= 32)
                (§ return (ß new PersistentVector(size, 5, PersistentVector.EMPTY_NODE, list.toArray())))
            )

            (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
                (loop-when-recur [(ß int i = 0)] (ß i < size) [(ß i++)]
                    (ß ret = ret.conj(list.get(i)))
                )
                (ß ret.persistent())
            )
        )
    )

    (§ defn PersistentVector create(Iterable items)
        ;; optimize common case
        (when (ß items instanceof ArrayList)
            (§ return (ß create((ArrayList)items)))
        )

        (let [#_"Iterator" iter (ß items.iterator())]
            (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
                (while (ß iter.hasNext())
                    (ß ret = ret.conj(iter.next()))
                )
                (ß ret.persistent())
            )
        )
    )

    (§ defn PersistentVector create(Object... items)
        (let [#_"TransientVector" ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" item items]
                (ß ret = ret.conj(item))
            )
            (ß ret.persistent())
        )
    )

    (§ constructor PersistentVector(int cnt, int shift, Node root, Object[] tail)
        (ß this._meta = nil)
        (ß this.cnt = cnt)
        (ß this.shift = shift)
        (ß this.root = root)
        (ß this.tail = tail)
        this
    )

    (§ constructor PersistentVector(IPersistentMap meta, int cnt, int shift, Node root, Object[] tail)
        (ß this._meta = meta)
        (ß this.cnt = cnt)
        (ß this.shift = shift)
        (ß this.root = root)
        (ß this.tail = tail)
        this
    )

    (§ method TransientVector asTransient()
        (ß new TransientVector(this))
    )

    (§ method int tailoff()
        (when (ß cnt < 32)
            (§ return 0)
        )
        (ß ((cnt - 1) >>> 5) << 5)
    )

    (§ method Object[] arrayFor(int i)
        (when (ß i >= 0 && i < cnt)
            (when (ß i >= tailoff())
                (§ return tail)
            )
            (let [#_"Node" node root]
                (loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                    (ß node = (Node) node.array[(i >>> level) & 0x01f])
                )
                (§ return (ß node.array))
            )
        )
        (throw (ß new IndexOutOfBoundsException()))
    )

    (§ method Object nth(int i)
        (let [#_"Object[]" node (ß arrayFor(i))]
            (ß node[i & 0x01f])
        )
    )

    (§ method Object nth(int i, Object notFound)
        (when (ß i >= 0 && i < cnt)
            (§ return (ß nth(i)))
        )
        notFound
    )

    (§ method PersistentVector assocN(int i, Object val)
        (when (ß i >= 0 && i < cnt)
            (when (ß i >= tailoff())
                (let [#_"Object[]" newTail (ß new Object[tail.length])]
                    (ß System.arraycopy(tail, 0, newTail, 0, tail.length))
                    (ß newTail[i & 0x01f] = val)

                    (§ return (ß new PersistentVector(meta(), cnt, shift, root, newTail)))
                )
            )

            (§ return (ß new PersistentVector(meta(), cnt, shift, doAssoc(shift, root, i, val), tail)))
        )
        (when (ß i == cnt)
            (§ return (ß cons(val)))
        )
        (throw (ß new IndexOutOfBoundsException()))
    )

    (§ defn- Node doAssoc(int level, Node node, int i, Object val)
        (let [#_"Node" ret (ß new Node(node.edit, node.array.clone()))]
            (if (ß level == 0)
                (do
                    (ß ret.array[i & 0x01f] = val)
                )
                (do
                    (let [#_"int" subidx (ß (i >>> level) & 0x01f)]
                        (ß ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val))
                    )
                )
            )
            ret
        )
    )

    (§ method int count()
        cnt
    )

    (§ method PersistentVector withMeta(IPersistentMap meta)
        (ß new PersistentVector(meta, cnt, shift, root, tail))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )

    (§ method PersistentVector cons(Object val)
        ;; room in tail?
        (when (ß cnt - tailoff() < 32)
            (let [#_"Object[]" newTail (ß new Object[tail.length + 1])]
                (ß System.arraycopy(tail, 0, newTail, 0, tail.length))
                (ß newTail[tail.length] = val)
                (§ return (ß new PersistentVector(meta(), cnt + 1, shift, root, newTail)))
            )
        )
        ;; full tail, push into tree
        (§ let [#_"Node" newroot]
            (let [#_"Node" tailnode (ß new Node(root.edit, tail))]
                (let [#_"int" newshift shift]
                    ;; overflow root?
                    (if (ß (cnt >>> 5) > (1 << shift))
                        (do
                            (ß newroot = new Node(root.edit))
                            (ß newroot.array[0] = root)
                            (ß newroot.array[1] = newPath(root.edit, shift, tailnode))
                            (ß newshift += 5)
                        )
                        (do
                            (ß newroot = pushTail(shift, root, tailnode))
                        )
                    )
                    (ß new PersistentVector(meta(), cnt + 1, newshift, newroot, new Object[] (§ val )))
                )
            )
        )
    )

    (§ method- Node pushTail(int level, Node parent, Node tailnode)
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" subidx (ß ((cnt - 1) >>> level) & 0x01f)]
            (let [#_"Node" ret (ß new Node(parent.edit, parent.array.clone()))]
                (§ let [#_"Node" nodeToInsert]
                    (if (ß level == 5)
                        (do
                            (ß nodeToInsert = tailnode)
                        )
                        (do
                            (let [#_"Node" child (ß (Node) parent.array[subidx])]
                                (ß nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode))
                            )
                        )
                    )
                    (ß ret.array[subidx] = nodeToInsert)
                    ret
                )
            )
        )
    )

    (§ defn- Node newPath(AtomicReference<Thread> edit, int level, Node node)
        (when (ß level == 0)
            (§ return node)
        )
        (let [#_"Node" ret (ß new Node(edit))]
            (ß ret.array[0] = newPath(edit, level - 5, node))
            ret
        )
    )

    (§ method IChunkedSeq chunkedSeq()
        (when (ß count() == 0)
            (§ return nil)
        )
        (ß new ChunkedSeq(this, 0, 0))
    )

    (§ method ISeq seq()
        (ß chunkedSeq())
    )

    (§ anno @Override)
    (§ method Iterator rangedIterator(int start, int end)
        (ß new Iterator()
            (§ reify
                (let [#_"int" i start]
                    (let [#_"int" base (ß i - (i%32))]
                        (let [#_"Object[]" array (ß (start < count()) ? arrayFor(i) :or nil)]
                            (§ method boolean hasNext()
                                (ß (i < end))
                            )

                            (§ method Object next()
                                (if (ß i < end)
                                    (do
                                        (when (ß i - base == 32)
                                            (ß array = arrayFor(i))
                                            (ß base += 32)
                                        )
                                        (ß array[i++ & 0x01f])
                                    )
                                    (do
                                        (throw (ß new NoSuchElementException()))
                                    )
                                )
                            )

                            (§ method void remove()
                                (throw (ß new UnsupportedOperationException()))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ method Iterator iterator()
        (ß rangedIterator(0, count()))
    )

    (§ method Object reduce(IFn f)
        (§ let [#_"Object" init]
            (if (ß cnt > 0)
                (do
                    (ß init = arrayFor(0)[0])
                )
                (do
                    (§ return (ß f.invoke()))
                )
            )
            (let [#_"int" step 0]
                (loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
                    (let [#_"Object[]" array (ß arrayFor(i))]
                        (loop-when-recur [(ß int j = (i == 0) ? 1 :or 0)] (ß j < array.length) [(ß ++j)]
                            (ß init = f.invoke(init, array[j]))
                            (when (ß RT.isReduced(init))
                                (§ return (ß ((IDeref)init).deref()))
                            )
                        )
                        (ß step = array.length)
                    )
                )
                init
            )
        )
    )

    (§ method Object reduce(IFn f, Object init)
        (let [#_"int" step 0]
            (loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
                (let [#_"Object[]" array (ß arrayFor(i))]
                    (loop-when-recur [(ß int j = 0)] (ß j < array.length) [(ß ++j)]
                        (ß init = f.invoke(init, array[j]))
                        (when (ß RT.isReduced(init))
                            (§ return (ß ((IDeref)init).deref()))
                        )
                    )
                    (ß step = array.length)
                )
            )
            init
        )
    )

    (§ method Object kvreduce(IFn f, Object init)
        (let [#_"int" step 0]
            (loop-when-recur [(ß int i = 0)] (ß i < cnt) [(ß i += step)]
                (let [#_"Object[]" array (ß arrayFor(i))]
                    (loop-when-recur [(ß int j = 0)] (ß j < array.length) [(ß ++j)]
                        (ß init = f.invoke(init, j + i, array[j]))
                        (when (ß RT.isReduced(init))
                            (§ return (ß ((IDeref)init).deref()))
                        )
                    )
                    (ß step = array.length)
                )
            )
            init
        )
    )

    (class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
        (§ field PersistentVector vec)
        (§ field Object[] node)
        (§ field int i)
        (§ field int offset)

        (§ constructor ChunkedSeq(PersistentVector vec, int i, int offset)
            (ß this.vec = vec)
            (ß this.i = i)
            (ß this.offset = offset)
            (ß this.node = vec.arrayFor(i))
            this
        )

        (§ constructor ChunkedSeq(IPersistentMap meta, PersistentVector vec, Object[] node, int i, int offset)
            (§ super(meta))
            (ß this.vec = vec)
            (ß this.node = node)
            (ß this.i = i)
            (ß this.offset = offset)
            this
        )

        (§ constructor ChunkedSeq(PersistentVector vec, Object[] node, int i, int offset)
            (ß this.vec = vec)
            (ß this.node = node)
            (ß this.i = i)
            (ß this.offset = offset)
            this
        )

        (§ method IChunk chunkedFirst()
            (ß new ArrayChunk(node, offset))
        )

        (§ method ISeq chunkedNext()
            (when (ß i + node.length < vec.cnt)
                (§ return (ß new ChunkedSeq(vec, i + node.length, 0)))
            )
            nil
        )

        (§ method ISeq chunkedMore()
            (let [#_"ISeq" s (ß chunkedNext())]
                (when (ß s == nil)
                    (§ return (ß PersistentList.EMPTY))
                )
                s
            )
        )

        (§ method Obj withMeta(IPersistentMap meta)
            (when (ß meta == this._meta)
                (§ return this)
            )
            (ß new ChunkedSeq(meta, vec, node, i, offset))
        )

        (§ method Object first()
            (ß node[offset])
        )

        (§ method ISeq next()
            (when (ß offset + 1 < node.length)
                (§ return (ß new ChunkedSeq(vec, node, i, offset + 1)))
            )
            (ß chunkedNext())
        )

        (§ method int count()
            (ß vec.cnt - (i + offset))
        )
    )

    (§ method IPersistentCollection empty()
        (ß EMPTY.withMeta(meta()))
    )

    (§ method PersistentVector pop()
        (when (ß cnt == 0)
            (throw (ß new IllegalStateException("Can't pop empty vector")))
        )
        (when (ß cnt == 1)
            (§ return (ß EMPTY.withMeta(meta())))
        )
        (when (ß cnt - tailoff() > 1)
            (let [#_"Object[]" newTail (ß new Object[tail.length - 1])]
                (ß System.arraycopy(tail, 0, newTail, 0, newTail.length))
                (§ return (ß new PersistentVector(meta(), cnt - 1, shift, root, newTail)))
            )
        )
        (let [#_"Object[]" newtail (ß arrayFor(cnt - 2))]
            (let [#_"Node" newroot (ß popTail(shift, root))]
                (let [#_"int" newshift shift]
                    (when (ß newroot == nil)
                        (ß newroot = EMPTY_NODE)
                    )
                    (when (ß shift > 5 && newroot.array[1] == nil)
                        (ß newroot = (Node) newroot.array[0])
                        (ß newshift -= 5)
                    )
                    (ß new PersistentVector(meta(), cnt - 1, newshift, newroot, newtail))
                )
            )
        )
    )

    (§ method- Node popTail(int level, Node node)
        (let [#_"int" subidx (ß ((cnt - 2) >>> level) & 0x01f)]
            (cond (ß level > 5)
                (do
                    (let [#_"Node" newchild (ß popTail(level - 5, (Node) node.array[subidx]))]
                        (if (ß newchild == nil && subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"Node" ret (ß new Node(root.edit, node.array.clone()))]
                                    (ß ret.array[subidx] = newchild)
                                    ret
                                )
                            )
                        )
                    )
                )
                (ß subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"Node" ret (ß new Node(root.edit, node.array.clone()))]
                        (ß ret.array[subidx] = nil)
                        ret
                    )
                )
            )
        )
    )

    (class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
        #_volatile
        (§ field int cnt)
        #_volatile
        (§ field int shift)
        #_volatile
        (§ field Node root)
        #_volatile
        (§ field Object[] tail)

        (§ constructor TransientVector(int cnt, int shift, Node root, Object[] tail)
            (ß this.cnt = cnt)
            (ß this.shift = shift)
            (ß this.root = root)
            (ß this.tail = tail)
            this
        )

        (§ constructor TransientVector(PersistentVector v)
            (§ this(v.cnt, v.shift, editableRoot(v.root), editableTail(v.tail)))
            this
        )

        (§ method int count()
            (ß ensureEditable())
            cnt
        )

        (§ method Node ensureEditable(Node node)
            (when (ß node.edit == root.edit)
                (§ return node)
            )
            (ß new Node(root.edit, node.array.clone()))
        )

        (§ method void ensureEditable()
            (when (ß root.edit.get() == nil)
                (throw (ß new IllegalAccessError("Transient used after persistent! call")))
            )
            nil
        )

        (§ defn Node editableRoot(Node node)
            (ß new Node(new AtomicReference<Thread>(Thread.currentThread()), node.array.clone()))
        )

        (§ method PersistentVector persistent()
            (ß ensureEditable())
            (ß root.edit.set(nil))
            (let [#_"Object[]" trimmedTail (ß new Object[cnt - tailoff()])]
                (ß System.arraycopy(tail, 0, trimmedTail, 0, trimmedTail.length))
                (ß new PersistentVector(cnt, shift, root, trimmedTail))
            )
        )

        (§ defn Object[] editableTail(Object[] tl)
            (let [#_"Object[]" ret (ß new Object[32])]
                (ß System.arraycopy(tl, 0, ret, 0, tl.length))
                ret
            )
        )

        (§ method TransientVector conj(Object val)
            (ß ensureEditable())
            (let [#_"int" i cnt]
                ;; room in tail?
                (when (ß i - tailoff() < 32)
                    (ß tail[i & 0x01f] = val)
                    (ß ++cnt)
                    (§ return this)
                )
                ;; full tail, push into tree
                (§ let [#_"Node" newroot]
                    (let [#_"Node" tailnode (ß new Node(root.edit, tail))]
                        (ß tail = new Object[32])
                        (ß tail[0] = val)
                        (let [#_"int" newshift shift]
                            ;; overflow root?
                            (if (ß (cnt >>> 5) > (1 << shift))
                                (do
                                    (ß newroot = new Node(root.edit))
                                    (ß newroot.array[0] = root)
                                    (ß newroot.array[1] = newPath(root.edit, shift, tailnode))
                                    (ß newshift += 5)
                                )
                                (do
                                    (ß newroot = pushTail(shift, root, tailnode))
                                )
                            )
                            (ß root = newroot)
                            (ß shift = newshift)
                            (ß ++cnt)
                            this
                        )
                    )
                )
            )
        )

        (§ method- Node pushTail(int level, Node parent, Node tailnode)
            ;; if parent is leaf, insert node,
            ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
            ;; else alloc new path
            ;; return nodeToInsert placed in parent
            (ß parent = ensureEditable(parent))
            (let [#_"int" subidx (ß ((cnt - 1) >>> level) & 0x01f)]
                (let [#_"Node" ret parent]
                    (§ let [#_"Node" nodeToInsert]
                        (if (ß level == 5)
                            (do
                                (ß nodeToInsert = tailnode)
                            )
                            (do
                                (let [#_"Node" child (ß (Node) parent.array[subidx])]
                                    (ß nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode))
                                )
                            )
                        )
                        (ß ret.array[subidx] = nodeToInsert)
                        ret
                    )
                )
            )
        )

        (§ method- int tailoff()
            (when (ß cnt < 32)
                (§ return 0)
            )
            (ß ((cnt - 1) >>> 5) << 5)
        )

        (§ method- Object[] arrayFor(int i)
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (§ return tail)
                )
                (let [#_"Node" node root]
                    (loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                        (ß node = (Node) node.array[(i >>> level) & 0x01f])
                    )
                    (§ return (ß node.array))
                )
            )
            (throw (ß new IndexOutOfBoundsException()))
        )

        (§ method- Object[] editableArrayFor(int i)
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (§ return tail)
                )
                (let [#_"Node" node root]
                    (loop-when-recur [(ß int level = shift)] (ß level > 0) [(ß level -= 5)]
                        (ß node = ensureEditable((Node) node.array[(i >>> level) & 0x01f]))
                    )
                    (§ return (ß node.array))
                )
            )
            (throw (ß new IndexOutOfBoundsException()))
        )

        (§ method Object valAt(Object key)
            ;; note - relies on ensureEditable in 2-arg valAt
            (ß valAt(key, nil))
        )

        (§ method Object valAt(Object key, Object notFound)
            (ß ensureEditable())
            (when (ß Util.isInteger(key))
                (let [#_"int" i (ß ((Number) key).intValue())]
                    (when (ß i >= 0 && i < cnt)
                        (§ return (ß nth(i)))
                    )
                )
            )
            notFound
        )

        (§ def- Object NOT_FOUND = new Object())

        (§ method boolean containsKey(Object key)
            (ß (valAt(key, NOT_FOUND) != NOT_FOUND))
        )

        (§ method IMapEntry entryAt(Object key)
            (let [#_"Object" v (ß valAt(key, NOT_FOUND))]
                (when (ß v != NOT_FOUND)
                    (§ return (ß MapEntry.create(key, v)))
                )
                nil
            )
        )

        (§ method Object invoke(Object arg1)
            ;; note - relies on ensureEditable in nth
            (when (ß Util.isInteger(arg1))
                (§ return (ß nth(((Number) arg1).intValue())))
            )
            (throw (ß new IllegalArgumentException("Key must be integer")))
        )

        (§ method Object nth(int i)
            (ß ensureEditable())
            (let [#_"Object[]" node (ß arrayFor(i))]
                (ß node[i & 0x01f])
            )
        )

        (§ method Object nth(int i, Object notFound)
            (when (ß i >= 0 && i < count())
                (§ return (ß nth(i)))
            )
            notFound
        )

        (§ method TransientVector assocN(int i, Object val)
            (ß ensureEditable())
            (when (ß i >= 0 && i < cnt)
                (when (ß i >= tailoff())
                    (ß tail[i & 0x01f] = val)
                    (§ return this)
                )

                (ß root = doAssoc(shift, root, i, val))
                (§ return this)
            )
            (when (ß i == cnt)
                (§ return (ß conj(val)))
            )
            (throw (ß new IndexOutOfBoundsException()))
        )

        (§ method TransientVector assoc(Object key, Object val)
            ;; note - relies on ensureEditable in assocN
            (when (ß Util.isInteger(key))
                (let [#_"int" i (ß ((Number) key).intValue())]
                    (§ return (ß assocN(i, val)))
                )
            )
            (throw (ß new IllegalArgumentException("Key must be integer")))
        )

        (§ method- Node doAssoc(int level, Node node, int i, Object val)
            (ß node = ensureEditable(node))
            (let [#_"Node" ret node]
                (if (ß level == 0)
                    (do
                        (ß ret.array[i & 0x01f] = val)
                    )
                    (do
                        (let [#_"int" subidx (ß (i >>> level) & 0x01f)]
                            (ß ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val))
                        )
                    )
                )
                ret
            )
        )

        (§ method TransientVector pop()
            (ß ensureEditable())
            (when (ß cnt == 0)
                (throw (ß new IllegalStateException("Can't pop empty vector")))
            )
            (when (ß cnt == 1)
                (ß cnt = 0)
                (§ return this)
            )
            (let [#_"int" i (ß cnt - 1)]
                ;; pop in tail?
                (when (ß (i & 0x01f) > 0)
                    (ß --cnt)
                    (§ return this)
                )

                (let [#_"Object[]" newtail (ß editableArrayFor(cnt - 2))]
                    (let [#_"Node" newroot (ß popTail(shift, root))]
                        (let [#_"int" newshift shift]
                            (when (ß newroot == nil)
                                (ß newroot = new Node(root.edit))
                            )
                            (when (ß shift > 5 && newroot.array[1] == nil)
                                (ß newroot = ensureEditable((Node) newroot.array[0]))
                                (ß newshift -= 5)
                            )
                            (ß root = newroot)
                            (ß shift = newshift)
                            (ß --cnt)
                            (ß tail = newtail)
                            this
                        )
                    )
                )
            )
        )

        (§ method- Node popTail(int level, Node node)
            (ß node = ensureEditable(node))
            (let [#_"int" subidx (ß ((cnt - 2) >>> level) & 0x01f)]
                (cond (ß level > 5)
                    (do
                        (let [#_"Node" newchild (ß popTail(level - 5, (Node) node.array[subidx]))]
                            (if (ß newchild == nil && subidx == 0)
                                (do
                                    nil
                                )
                                (do
                                    (let [#_"Node" ret node]
                                        (ß ret.array[subidx] = newchild)
                                        ret
                                    )
                                )
                            )
                        )
                    )
                    (ß subidx == 0)
                    (do
                        nil
                    )
                    :else
                    (do
                        (let [#_"Node" ret node]
                            (ß ret.array[subidx] = nil)
                            ret
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    ;; method-name-string->fn
    (§ field IPersistentMap fns)

    (§ constructor ProxyHandler(IPersistentMap fns)
        (ß this.fns = fns)
        this
    )

    (§ method Object invoke(Object proxy, Method method, Object[] args) (§ throws Throwable)
        (let [#_"Class" rt (ß method.getReturnType())]
            (let [#_"IFn" fn (ß (IFn) fns.valAt(method.getName()))]
                (when (ß fn == nil)
                    (cond (ß rt == Void.TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß method.getName().equals("equals"))
                        (do
                            (§ return (ß (proxy == args[0])))
                        )
                        (ß method.getName().equals("hashCode"))
                        (do
                            (§ return (ß System.identityHashCode(proxy)))
                        )
                        (ß method.getName().equals("toString"))
                        (do
                            (§ return (ß "Proxy: " + System.identityHashCode(proxy)))
                        )
                    )
                    (throw (ß new UnsupportedOperationException()))
                )
                (let [#_"Object" ret (ß fn.applyTo(ArraySeq.create(args)))]
                    (cond (ß rt == Void.TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß rt.isPrimitive())
                        (do
                            (cond (ß rt == Character.TYPE)
                                (do
                                    (§ return ret)
                                )
                                (ß rt == Integer.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).intValue()))
                                )
                                (ß rt == Long.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).longValue()))
                                )
                                (ß rt == Float.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).floatValue()))
                                )
                                (ß rt == Double.TYPE)
                                (do
                                    (§ return (ß ((Number) ret).doubleValue()))
                                )
                                (ß rt == Boolean.TYPE && !(ret instanceof Boolean))
                                (do
                                    (§ return (ß (ret == nil) ? Boolean.FALSE :or Boolean.TRUE))
                                )
                                (ß rt == Byte.TYPE)
                                (do
                                    (§ return (ß (byte) ((Number) ret).intValue()))
                                )
                                (ß rt == Short.TYPE)
                                (do
                                    (§ return (ß (short) ((Number) ret).intValue()))
                                )
                            )
                        )
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (§ def- int CHUNK_SIZE = 32)

    ;; Invariants guarantee this is never an "empty" seq
    (§ field Object end)
    (§ field Object start)
    (§ field Object step)
    (§ field BoundsCheck boundsCheck)

    #_volatile
    (§ field- IChunk _chunk) ;; lazy
    #_volatile
    (§ field- ISeq _chunkNext) ;; lazy
    #_volatile
    (§ field- ISeq _next) ;; cached

    #_private
    (§ interface BoundsCheck
        (§ abstract boolean exceededBounds(Object val))
    )

    (§ defn- BoundsCheck positiveStep(Object end)
        (ß new BoundsCheck()
            (§ reify
                (§ method boolean exceededBounds(Object val)
                    (ß Numbers.gte(val, end))
                )
            )
        )
    )

    (§ defn- BoundsCheck negativeStep(Object end)
        (ß new BoundsCheck()
            (§ reify
                (§ method boolean exceededBounds(Object val)
                    (ß Numbers.lte(val, end))
                )
            )
        )
    )

    (§ constructor- Range(Object start, Object end, Object step, BoundsCheck boundsCheck)
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        this
    )

    (§ constructor- Range(Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ constructor- Range(IPersistentMap meta, Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
        (§ super(meta))
        (ß this.end = end)
        (ß this.start = start)
        (ß this.step = step)
        (ß this.boundsCheck = boundsCheck)
        (ß this._chunk = chunk)
        (ß this._chunkNext = chunkNext)
        this
    )

    (§ defn ISeq create(Object end)
        (when (ß Numbers.isPos(end))
            (§ return (ß new Range(0, end, 1, positiveStep(end))))
        )
        (ß PersistentList.EMPTY)
    )

    (§ defn ISeq create(Object start, Object end)
        (ß create(start, end, 1))
    )

    (§ defn ISeq create(Object start, Object end, Object step)
        (when (ß (Numbers.isPos(step) && Numbers.gt(start, end)) || (Numbers.isNeg(step) && Numbers.gt(end, start)) || Numbers.equiv(start, end))
            (§ return (ß PersistentList.EMPTY))
        )
        (when (ß Numbers.isZero(step))
            (§ return (ß Repeat.create(start)))
        )
        (ß new Range(start, end, step, Numbers.isPos(step) ? positiveStep(end) :or negativeStep(end)))
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (when (ß meta == _meta)
            (§ return this)
        )
        (ß new Range(meta, end, start, step, boundsCheck, _chunk, _chunkNext))
    )

    (§ method Object first()
        start
    )

    (§ method void forceChunk()
        (when (ß _chunk != nil)
            (§ return nil)
        )

        (let [#_"Object[]" arr (ß new Object[CHUNK_SIZE])]
            (let [#_"int" n 0]
                (let [#_"Object" val start]
                    (while (ß n < CHUNK_SIZE)
                        (ß arr[n++] = val)
                        (ß val = Numbers.addP(val, step))
                        (when (ß boundsCheck.exceededBounds(val))
                            ;; partial last chunk
                            (ß _chunk = new ArrayChunk(arr, 0, n))
                            (§ return nil)
                        )
                    )

                    ;; full last chunk
                    (when (ß boundsCheck.exceededBounds(val))
                        (ß _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE))
                        (§ return nil)
                    )

                    ;; full intermediate chunk
                    (ß _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE))
                    (ß _chunkNext = new Range(val, end, step, boundsCheck))
                    nil
                )
            )
        )
    )

    (§ method ISeq next()
        (when (ß _next != nil)
            (§ return (ß _next))
        )

        (ß forceChunk())
        (when (ß _chunk.count() > 1)
            (let [#_"IChunk" smallerChunk (ß _chunk.dropFirst())]
                (ß _next = new Range(smallerChunk.nth(0), end, step, boundsCheck, smallerChunk, _chunkNext))
                (§ return (ß _next))
            )
        )
        (ß chunkedNext())
    )

    (§ method IChunk chunkedFirst()
        (ß forceChunk())
        (ß _chunk)
    )

    (§ method ISeq chunkedNext()
        (ß chunkedMore().seq())
    )

    (§ method ISeq chunkedMore()
        (ß forceChunk())
        (when (ß _chunkNext == nil)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß _chunkNext)
    )

    (§ method Object reduce(IFn f)
        (let [#_"Object" acc start]
            (let [#_"Number" i (ß Numbers.addP(start, step))]
                (while (ß !boundsCheck.exceededBounds(i))
                    (ß acc = f.invoke(acc, i))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (ß i = Numbers.addP(i, step))
                )
                acc
            )
        )
    )

    (§ method Object reduce(IFn f, Object val)
        (let [#_"Object" acc val]
            (let [#_"Object" i start]
                (while (ß !boundsCheck.exceededBounds(i))
                    (ß acc = f.invoke(acc, i))
                    (when (ß RT.isReduced(acc))
                        (§ return (ß ((Reduced)acc).deref()))
                    )
                    (ß i = Numbers.addP(i, step))
                )
                acc
            )
        )
    )

    (§ method Iterator iterator()
        (ß new RangeIterator())
    )

    #_private
    #_non-static
    (class-ns RangeIterator (§ implements Iterator)
        (§ field- Object next)

        (§ constructor RangeIterator()
            (ß this.next = start)
            this
        )

        (§ method boolean hasNext()
            (ß (!boundsCheck.exceededBounds(next)))
        )

        (§ method Object next()
            (if (ß hasNext())
                (do
                    (let [#_"Object" ret next]
                        (ß next = Numbers.addP(next, step))
                        ret
                    )
                )
                (do
                    (throw (ß new NoSuchElementException()))
                )
            )
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException()))
        )
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (§ field BigInteger numerator)
    (§ field BigInteger denominator)

    (§ constructor Ratio(BigInteger numerator, BigInteger denominator)
        (ß this.numerator = numerator)
        (ß this.denominator = denominator)
        this
    )

    (§ method boolean equals(Object arg0)
        (ß (arg0 != nil && arg0 instanceof Ratio && ((Ratio) arg0).numerator.equals(numerator) && ((Ratio) arg0).denominator.equals(denominator)))
    )

    (§ method int hashCode()
        (ß numerator.hashCode() :xor denominator.hashCode())
    )

    (§ method String toString()
        (ß numerator.toString() + "/" + denominator.toString())
    )

    (§ method int intValue()
        (ß (int) doubleValue())
    )

    (§ method long longValue()
        (ß bigIntegerValue().longValue())
    )

    (§ method float floatValue()
        (ß (float)doubleValue())
    )

    (§ method double doubleValue()
        (ß decimalValue(MathContext.DECIMAL64).doubleValue())
    )

    (§ method BigDecimal decimalValue()
        (ß decimalValue(MathContext.UNLIMITED))
    )

    (§ method BigDecimal decimalValue(MathContext mc)
        (let [#_"BigDecimal" numerator (ß new BigDecimal(this.numerator))]
            (let [#_"BigDecimal" denominator (ß new BigDecimal(this.denominator))]
                (ß numerator.divide(denominator, mc))
            )
        )
    )

    (§ method BigInteger bigIntegerValue()
        (ß numerator.divide(denominator))
    )

    (§ method int compareTo(Object o)
        (let [#_"Number" other (ß (Number)o)]
            (ß Numbers.compare(this, other))
        )
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(class-ns ReaderConditional (§ implements ILookup)
    (§ def Keyword FORM_KW = Keyword.intern("form"))
    (§ def Keyword SPLICING_KW = Keyword.intern("splicing?"))

    (§ field Object form)
    (§ field Boolean splicing)

    (§ defn ReaderConditional create(Object form, boolean splicing)
        (ß new ReaderConditional(form, splicing))
    )

    (§ constructor- ReaderConditional(Object form, boolean splicing)
        (ß this.form = form)
        (ß this.splicing = splicing)
        this
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method Object valAt(Object key, Object notFound)
        (cond (ß FORM_KW.equals(key))
            (do
                (ß this.form)
            )
            (ß SPLICING_KW.equals(key))
            (do
                (ß this.splicing)
            )
            :else
            (do
                notFound
            )
        )
    )

    (§ anno @Override)
    (§ method boolean equals(Object o)
        (when (ß this == o)
            (§ return true)
        )
        (when (ß o == nil || getClass() != o.getClass())
            (§ return false)
        )

        (let [#_"ReaderConditional" that (ß (ReaderConditional) o)]
            (when (ß (form != nil) ? !form.equals(that.form) :or that.form != nil)
                (§ return false)
            )
            (when (ß (splicing != nil) ? !splicing.equals(that.splicing) :or that.splicing != nil)
                (§ return false)
            )
            true
        )
    )

    (§ anno @Override)
    (§ method int hashCode()
        (let [#_"int" result (ß Util.hash(form))]
            (ß result = 31 * result + Util.hash(splicing))
            result
        )
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (§ field int i = 0)
    (§ field int basecnt)
    (§ field ILookup rec)
    (§ field IPersistentVector basefields)
    (§ field Iterator extmap)

    (§ constructor RecordIterator(ILookup rec, IPersistentVector basefields, Iterator extmap)
        (ß this.rec = rec)
        (ß this.basefields = basefields)
        (ß this.basecnt = basefields.count())
        (ß this.extmap = extmap)
        this
    )

    (§ method boolean hasNext()
        (if (ß i < basecnt)
            (do
                true
            )
            (do
                (ß extmap.hasNext())
            )
        )
    )

    (§ method Object next()
        (if (ß i < basecnt)
            (do
                (let [#_"Object" k (ß basefields.nth(i))]
                    (ß i++)
                    (ß MapEntry.create(k, rec.valAt(k)))
                )
            )
            (do
                (ß extmap.next())
            )
        )
    )

    (§ method void remove()
        (throw (ß new UnsupportedOperationException()))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (§ field Object val)

    (§ constructor Reduced(Object val)
        (ß this.val = val)
        this
    )

    (§ method Object deref()
        val
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (§ method int compareTo(Ref ref)
        (cond (ß this.id == ref.id)
            (do
                0
            )
            (ß this.id < ref.id)
            (do
                -1
            )
            :else
            (do
                1
            )
        )
    )

    (§ method int getMinHistory()
        minHistory
    )

    (§ method Ref setMinHistory(int minHistory)
        (ß this.minHistory = minHistory)
        this
    )

    (§ method int getMaxHistory()
        maxHistory
    )

    (§ method Ref setMaxHistory(int maxHistory)
        (ß this.maxHistory = maxHistory)
        this
    )

    (class-ns TVal
        (§ field Object val)
        (§ field long point)
        (§ field TVal prior)
        (§ field TVal next)

        (§ constructor TVal(Object val, long point, TVal prior)
            (ß this.val = val)
            (ß this.point = point)
            (ß this.prior = prior)
            (ß this.next = prior.next)
            (ß this.prior.next = this)
            (ß this.next.prior = this)
            this
        )

        (§ constructor TVal(Object val, long point)
            (ß this.val = val)
            (ß this.point = point)
            (ß this.next = this)
            (ß this.prior = this)
            this
        )
    )

    (§ field TVal tvals)
    (§ field AtomicInteger faults)
    (§ field ReentrantReadWriteLock lock)
    (§ field LockingTransaction.Info tinfo)
    (§ field long id)

    #_volatile
    (§ field int minHistory = 0)
    #_volatile
    (§ field int maxHistory = 10)

    (§ def AtomicLong ids = new AtomicLong())

    (§ constructor Ref(Object initVal)
        (§ this(initVal, nil))
        this
    )

    (§ constructor Ref(Object initVal, IPersistentMap meta)
        (§ super(meta))
        (ß this.id = ids.getAndIncrement())
        (ß this.faults = new AtomicInteger())
        (ß this.lock = new ReentrantReadWriteLock())
        (ß tvals = new TVal(initVal, 0))
        this
    )

    ;; the latest val

    ;; ok out of transaction
    (§ method Object currentVal()
        (try
            (ß lock.readLock().lock())
            (when (ß tvals != nil)
                (§ return (ß tvals.val))
            )
            (throw (ß new IllegalStateException(this.toString() + " is unbound.")))
            (finally
                (ß lock.readLock().unlock())
            )
        )
    )

    (§ method Object deref()
        (let [#_"LockingTransaction" t (ß LockingTransaction.getRunning())]
            (when (ß t == nil)
                (§ return (ß currentVal()))
            )
            (ß t.doGet(this))
        )
    )

    (§ method Object set(Object val)
        (ß LockingTransaction.getEx().doSet(this, val))
    )

    (§ method Object commute(IFn fn, ISeq args)
        (ß LockingTransaction.getEx().doCommute(this, fn, args))
    )

    (§ method Object alter(IFn fn, ISeq args)
        (let [#_"LockingTransaction" t (ß LockingTransaction.getEx())]
            (ß t.doSet(this, fn.applyTo(RT.cons(t.doGet(this), args))))
        )
    )

    (§ method void touch()
        (ß LockingTransaction.getEx().doEnsure(this))
        nil
    )

    (§ method boolean isBound()
        (try
            (ß lock.readLock().lock())
            (ß (tvals != nil))
            (finally
                (ß lock.readLock().unlock())
            )
        )
    )

    (§ method void trimHistory()
        (try
            (ß lock.writeLock().lock())
            (when (ß tvals != nil)
                (ß tvals.next = tvals)
                (ß tvals.prior = tvals)
            )
            (finally
                (ß lock.writeLock().unlock())
            )
        )
        nil
    )

    (§ method int getHistoryCount()
        (try
            (ß lock.writeLock().lock())
            (ß histCount())
            (finally
                (ß lock.writeLock().unlock())
            )
        )
    )

    (§ method int histCount()
        (if (ß tvals == nil)
            (do
                0
            )
            (do
                (let [#_"int" count 0]
                    (loop-when-recur [(ß TVal tv = tvals.next)] (ß tv != tvals) [(ß tv = tv.next)]
                        (ß count++)
                    )
                    count
                )
            )
        )
    )

    (§ method IFn fn()
        (ß (IFn) deref())
    )

    (§ method Object call()
        (ß invoke())
    )

    (§ method void run()
        (ß invoke())
        nil
    )

    (§ method Object invoke()
        (ß fn().invoke())
    )

    (§ method Object invoke(Object arg1)
        (ß fn().invoke(arg1))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß fn().invoke(arg1, arg2))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß fn().invoke(arg1, arg2, arg3))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß fn().invoke(arg1, arg2, arg3, arg4))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
        (ß fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args))
    )

    (§ method Object applyTo(ISeq arglist)
        (ß AFn.applyToHelper(this, arglist))
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

(class-ns Reflector
    (§ defn Object invokeInstanceMethod(Object target, String methodName, Object[] args)
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"List" methods (ß getMethods(c, args.length, methodName, false))]
                (ß invokeMatchingMethod(methodName, methods, target, args))
            )
        )
    )

    (§ defn- Throwable getCauseOrElse(Exception e)
        (when (ß e.getCause() != nil)
            (§ return (ß e.getCause()))
        )
        e
    )

    (§ defn- RuntimeException throwCauseOrElseException(Exception e)
        (when (ß e.getCause() != nil)
            (throw (ß Util.sneakyThrow(e.getCause())))
        )
        (throw (ß Util.sneakyThrow(e)))
    )

    (§ defn- String noMethodReport(String methodName, Object target)
        (ß "No matching method found: " + methodName + ((target == nil) ? "" :or " for " + target.getClass()))
    )

    (§ defn Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
        (let [#_"Method" m nil]
            (let [#_"Object[]" boxedArgs nil]
                (cond (ß methods.isEmpty())
                    (do
                        (throw (ß new IllegalArgumentException(noMethodReport(methodName, target))))
                    )
                    (ß methods.size() == 1)
                    (do
                        (ß m = (Method) methods.get(0))
                        (ß boxedArgs = boxArgs(m.getParameterTypes(), args))
                    )
                    :else ;; overloaded w/same arity
                    (do
                        (let [#_"Method" foundm nil]
                            (loop-when-recur [(ß Iterator i = methods.iterator())] (ß i.hasNext()) [(ß )]
                                (ß m = (Method) i.next())

                                (let [#_"Class[]" params (ß m.getParameterTypes())]
                                    (when (ß isCongruent(params, args))
                                        (when (ß foundm == nil || Compiler.subsumes(params, foundm.getParameterTypes()))
                                            (ß foundm = m)
                                            (ß boxedArgs = boxArgs(params, args))
                                        )
                                    )
                                )
                            )
                            (ß m = foundm)
                        )
                    )
                )
                (when (ß m == nil)
                    (throw (ß new IllegalArgumentException(noMethodReport(methodName, target))))
                )

                (when (ß !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                    ;; public method of non-public class, try to find it in hierarchy
                    (let [#_"Method" oldm m]
                        (ß m = getAsMethodOfPublicBase(target.getClass(), m))
                        (when (ß m == nil)
                            (throw (ß new IllegalArgumentException("Can't call public method of non-public class: " + oldm.toString())))
                        )
                    )
                )
                (try
                    (ß prepRet(m.getReturnType(), m.invoke(target, boxedArgs)))
                    (catch Exception e
                        (throw (ß Util.sneakyThrow(getCauseOrElse(e))))
                    )
                )
            )
        )
    )

    (§ defn Method getAsMethodOfPublicBase(Class c, Method m)
        (doseq [#_"Class" iface (ß c.getInterfaces())]
            (doseq [#_"Method" im (ß iface.getMethods())]
                (when (ß isMatch(im, m))
                    (§ return im)
                )
            )
        )
        (let [#_"Class" sc (ß c.getSuperclass())]
            (when (ß sc == nil)
                (§ return nil)
            )
            (doseq [#_"Method" scm (ß sc.getMethods())]
                (when (ß isMatch(scm, m))
                    (§ return scm)
                )
            )
            (ß getAsMethodOfPublicBase(sc, m))
        )
    )

    (§ defn boolean isMatch(Method lhs, Method rhs)
        (when (ß !lhs.getName().equals(rhs.getName()) || !Modifier.isPublic(lhs.getDeclaringClass().getModifiers()))
            (§ return false)
        )

        (let [#_"Class[]" types1 (ß lhs.getParameterTypes())]
            (let [#_"Class[]" types2 (ß rhs.getParameterTypes())]
                (when (ß types1.length != types2.length)
                    (§ return false)
                )

                (let [#_"boolean" match true]
                    (loop-when-recur [(ß int i = 0)] (ß i < types1.length) [(ß ++i)]
                        (when (ß !types1[i].isAssignableFrom(types2[i]))
                            (ß match = false)
                            (§ break )
                        )
                    )
                    match
                )
            )
        )
    )

    (§ defn Object invokeConstructor(Class c, Object[] args)
        (try
            (let [#_"Constructor[]" allctors (ß c.getConstructors())]
                (let [#_"ArrayList" ctors (ß new ArrayList())]
                    (loop-when-recur [(ß int i = 0)] (ß i < allctors.length) [(ß i++)]
                        (let [#_"Constructor" ctor (ß allctors[i])]
                            (when (ß ctor.getParameterTypes().length == args.length)
                                (ß ctors.add(ctor))
                            )
                        )
                    )
                    (cond (ß ctors.isEmpty())
                        (do
                            (throw (ß new IllegalArgumentException("No matching ctor found for " + c)))
                        )
                        (ß ctors.size() == 1)
                        (do
                            (let [#_"Constructor" ctor (ß (Constructor) ctors.get(0))]
                                (ß ctor.newInstance(boxArgs(ctor.getParameterTypes(), args)))
                            )
                        )
                        :else ;; overloaded w/same arity
                        (do
                            (loop-when-recur [(ß Iterator iterator = ctors.iterator())] (ß iterator.hasNext()) [(ß )]
                                (let [#_"Constructor" ctor (ß (Constructor) iterator.next())]
                                    (let [#_"Class[]" params (ß ctor.getParameterTypes())]
                                        (when (ß isCongruent(params, args))
                                            (let [#_"Object[]" boxedArgs (ß boxArgs(params, args))]
                                                (§ return (ß ctor.newInstance(boxedArgs)))
                                            )
                                        )
                                    )
                                )
                            )
                            (throw (ß new IllegalArgumentException("No matching ctor found for " + c)))
                        )
                    )
                )
            )
            (catch Exception e
                (throw (ß Util.sneakyThrow(getCauseOrElse(e))))
            )
        )
    )

    (§ defn Object invokeStaticMethodVariadic(String className, String methodName, Object... args)
        (ß invokeStaticMethod(className, methodName, args))
    )

    (§ defn Object invokeStaticMethod(String className, String methodName, Object[] args)
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß invokeStaticMethod(c, methodName, args))
        )
    )

    (§ defn Object invokeStaticMethod(Class c, String methodName, Object[] args)
        (when (ß methodName.equals("new"))
            (§ return (ß invokeConstructor(c, args)))
        )
        (let [#_"List" methods (ß getMethods(c, args.length, methodName, true))]
            (ß invokeMatchingMethod(methodName, methods, nil, args))
        )
    )

    (§ defn Object getStaticField(String className, String fieldName)
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß getStaticField(c, fieldName))
        )
    )

    (§ defn Object getStaticField(Class c, String fieldName)
        (let [#_"Field" f (ß getField(c, fieldName, true))]
            (when (ß f != nil)
                (try
                    (§ return (ß prepRet(f.getType(), f.get(nil))))
                    (catch IllegalAccessException e
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
            )
            (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + c)))
        )
    )

    (§ defn Object setStaticField(String className, String fieldName, Object val)
        (let [#_"Class" c (ß RT.classForName(className))]
            (ß setStaticField(c, fieldName, val))
        )
    )

    (§ defn Object setStaticField(Class c, String fieldName, Object val)
        (let [#_"Field" f (ß getField(c, fieldName, true))]
            (when (ß f != nil)
                (try
                    (ß f.set(nil, boxArg(f.getType(), val)))
                    (catch IllegalAccessException e
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
                (§ return val)
            )
            (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + c)))
        )
    )

    (§ defn Object getInstanceField(Object target, String fieldName)
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, fieldName, false))]
                (when (ß f != nil)
                    (try
                        (§ return (ß prepRet(f.getType(), f.get(target))))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())))
            )
        )
    )

    (§ defn Object setInstanceField(Object target, String fieldName, Object val)
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, fieldName, false))]
                (when (ß f != nil)
                    (try
                        (ß f.set(target, boxArg(f.getType(), val)))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                    (§ return val)
                )
                (throw (ß new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())))
            )
        )
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    (§ defn Object invokeNoArgInstanceMember(Object target, String name)
        (ß invokeNoArgInstanceMember(target, name, false))
    )

    (§ defn Object invokeNoArgInstanceMember(Object target, String name, boolean requireField)
        (let [#_"Class" c (ß target.getClass())]
            (if requireField
                (do
                    (let [#_"Field" f (ß getField(c, name, false))]
                        (if (ß f != nil)
                            (do
                                (ß getInstanceField(target, name))
                            )
                            (do
                                (throw (ß new IllegalArgumentException("No matching field found: " + name + " for " + target.getClass())))
                            )
                        )
                    )
                )
                (do
                    (let [#_"List" meths (ß getMethods(c, 0, name, false))]
                        (if (ß meths.size() > 0)
                            (do
                                (ß invokeMatchingMethod(name, meths, target, RT.EMPTY_ARRAY))
                            )
                            (do
                                (ß getInstanceField(target, name))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn Object invokeInstanceMember(Object target, String name)
        ;; check for field first
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, name, false))]
                (when (ß f != nil) ;; field get
                    (try
                        (§ return (ß prepRet(f.getType(), f.get(target))))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                )
                (ß invokeInstanceMethod(target, name, RT.EMPTY_ARRAY))
            )
        )
    )

    (§ defn Object invokeInstanceMember(String name, Object target, Object arg1)
        ;; check for field first
        (let [#_"Class" c (ß target.getClass())]
            (let [#_"Field" f (ß getField(c, name, false))]
                (when (ß f != nil) ;; field set
                    (try
                        (ß f.set(target, boxArg(f.getType(), arg1)))
                        (catch IllegalAccessException e
                            (throw (ß Util.sneakyThrow(e)))
                        )
                    )
                    (§ return arg1)
                )
                (ß invokeInstanceMethod(target, name, new Object[] (§ arg1 )))
            )
        )
    )

    (§ defn Object invokeInstanceMember(String name, Object target, Object... args)
        (ß invokeInstanceMethod(target, name, args))
    )

    (§ defn Field getField(Class c, String name, boolean getStatics)
        (let [#_"Field[]" allfields (ß c.getFields())]
            (loop-when-recur [(ß int i = 0)] (ß i < allfields.length) [(ß i++)]
                (when (ß name.equals(allfields[i].getName()) && Modifier.isStatic(allfields[i].getModifiers()) == getStatics)
                    (§ return (ß allfields[i]))
                )
            )
            nil
        )
    )

    (§ defn List getMethods(Class c, int arity, String name, boolean getStatics)
        (let [#_"Method[]" allmethods (ß c.getMethods())]
            (let [#_"ArrayList" methods (ß new ArrayList())]
                (let [#_"ArrayList" bridgeMethods (ß new ArrayList())]
                    (loop-when-recur [(ß int i = 0)] (ß i < allmethods.length) [(ß i++)]
                        (let [#_"Method" method (ß allmethods[i])]
                            (when (ß name.equals(method.getName()) && Modifier.isStatic(method.getModifiers()) == getStatics && method.getParameterTypes().length == arity)
                                (try
                                    (if (ß method.isBridge() && c.getMethod(method.getName(), method.getParameterTypes()).equals(method))
                                        (do
                                            (ß bridgeMethods.add(method))
                                        )
                                        (do
                                            (ß methods.add(method))
                                        )
                                    )
                                    (catch NoSuchMethodException e
                                    )
                                )
                            )
                        )
                    )

                    (when (ß methods.isEmpty())
                        (ß methods.addAll(bridgeMethods))
                    )
                    (when (ß !getStatics && c.isInterface())
                        (ß allmethods = Object.class.getMethods())
                        (loop-when-recur [(ß int i = 0)] (ß i < allmethods.length) [(ß i++)]
                            (when (ß name.equals(allmethods[i].getName()) && Modifier.isStatic(allmethods[i].getModifiers()) == getStatics && allmethods[i].getParameterTypes().length == arity)
                                (ß methods.add(allmethods[i]))
                            )
                        )
                    )
                    methods
                )
            )
        )
    )

    (§ defn Object boxArg(Class paramType, Object arg)
        (cond (ß !paramType.isPrimitive())
            (do
                (§ return (ß paramType.cast(arg)))
            )
            (ß paramType == boolean.class)
            (do
                (§ return (ß Boolean.class.cast(arg)))
            )
            (ß paramType == char.class)
            (do
                (§ return (ß Character.class.cast(arg)))
            )
            (ß arg instanceof Number)
            (do
                (let [#_"Number" n (ß (Number) arg)]
                    (cond (ß paramType == int.class)
                        (do
                            (§ return (ß n.intValue()))
                        )
                        (ß paramType == float.class)
                        (do
                            (§ return (ß n.floatValue()))
                        )
                        (ß paramType == double.class)
                        (do
                            (§ return (ß n.doubleValue()))
                        )
                        (ß paramType == long.class)
                        (do
                            (§ return (ß n.longValue()))
                        )
                        (ß paramType == short.class)
                        (do
                            (§ return (ß n.shortValue()))
                        )
                        (ß paramType == byte.class)
                        (do
                            (§ return (ß n.byteValue()))
                        )
                    )
                )
            )
        )
        (throw (ß new IllegalArgumentException("Unexpected param type, expected: " + paramType + ", given: " + arg.getClass().getName())))
    )

    (§ defn Object[] boxArgs(Class[] params, Object[] args)
        (when (ß params.length == 0)
            (§ return nil)
        )
        (let [#_"Object[]" ret (ß new Object[params.length])]
            (loop-when-recur [(ß int i = 0)] (ß i < params.length) [(ß i++)]
                (let [#_"Object" arg (ß args[i])]
                    (let [#_"Class" paramType (ß params[i])]
                        (ß ret[i] = boxArg(paramType, arg))
                    )
                )
            )
            ret
        )
    )

    (§ defn boolean paramArgTypeMatch(Class paramType, Class argType)
        (when (ß argType == nil)
            (§ return (ß !paramType.isPrimitive()))
        )
        (when (ß paramType == argType || paramType.isAssignableFrom(argType))
            (§ return true)
        )
        (cond (ß paramType == int.class)
            (do
                (§ return (ß argType == Integer.class
                    || argType == long.class
                    || argType == Long.class
                    || argType == short.class
                    || argType == byte.class))
            )
            (ß paramType == float.class)
            (do
                (§ return (ß argType == Float.class
                    || argType == double.class))
            )
            (ß paramType == double.class)
            (do
                (§ return (ß argType == Double.class
                    || argType == float.class))
            )
            (ß paramType == long.class)
            (do
                (§ return (ß argType == Long.class
                    || argType == int.class
                    || argType == short.class
                    || argType == byte.class))
            )
            (ß paramType == char.class)
            (do
                (§ return (ß argType == Character.class))
            )
            (ß paramType == short.class)
            (do
                (§ return (ß argType == Short.class))
            )
            (ß paramType == byte.class)
            (do
                (§ return (ß argType == Byte.class))
            )
            (ß paramType == boolean.class)
            (do
                (§ return (ß argType == Boolean.class))
            )
        )
        false
    )

    (§ defn boolean isCongruent(Class[] params, Object[] args)
        (let [#_"boolean" ret false]
            (when (ß args == nil)
                (§ return (ß (params.length == 0)))
            )
            (when (ß params.length == args.length)
                (ß ret = true)
                (loop-when-recur [(ß int i = 0)] (ß ret && i < params.length) [(ß i++)]
                    (let [#_"Object" arg (ß args[i])]
                        (let [#_"Class" argType (ß (arg == nil) ? nil :or arg.getClass())]
                            (let [#_"Class" paramType (ß params[i])]
                                (ß ret = paramArgTypeMatch(paramType, argType))
                            )
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn Object prepRet(Class c, Object x)
        (when (ß !(c.isPrimitive() || c == Boolean.class))
            (§ return x)
        )
        (when (ß x instanceof Boolean)
            (§ return (ß ((Boolean) x) ? Boolean.TRUE :or Boolean.FALSE))
        )
        x
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (§ def- long INFINITE = -1)

    (§ field- long count) ;; always INFINITE or >0
    (§ field- Object val)
    #_volatile
    (§ field- ISeq _next) ;; cached

    (§ constructor- Repeat(long count, Object val)
        (ß this.count = count)
        (ß this.val = val)
        this
    )

    (§ constructor- Repeat(IPersistentMap meta, long count, Object val)
        (§ super(meta))
        (ß this.count = count)
        (ß this.val = val)
        this
    )

    (§ defn Repeat create(Object val)
        (ß new Repeat(INFINITE, val))
    )

    (§ defn ISeq create(long count, Object val)
        (when (ß count <= 0)
            (§ return (ß PersistentList.EMPTY))
        )
        (ß new Repeat(count, val))
    )

    (§ method Object first()
        val
    )

    (§ method ISeq next()
        (when (ß _next == nil)
            (cond (ß count > 1)
                (do
                    (ß _next = new Repeat(count - 1, val))
                )
                (ß count == INFINITE)
                (do
                    (ß _next = this)
                )
            )
        )
        (ß _next)
    )

    (§ method Repeat withMeta(IPersistentMap meta)
        (ß new Repeat(meta, count, val))
    )

    (§ method Object reduce(IFn f)
        (let [#_"Object" ret val]
            (if (ß count == INFINITE)
                (do
                    (while true
                        (ß ret = f.invoke(ret, val))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [(ß long i = 1)] (ß i < count) [(ß i++)]
                        (ß ret = f.invoke(ret, val))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                    ret
                )
            )
        )
    )

    (§ method Object reduce(IFn f, Object start)
        (let [#_"Object" ret start]
            (if (ß count == INFINITE)
                (do
                    (while true
                        (ß ret = f.invoke(ret, val))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [(ß long i = 0)] (ß i < count) [(ß i++)]
                        (ß ret = f.invoke(ret, val))
                        (when (ß RT.isReduced(ret))
                            (§ return (ß ((IDeref)ret).deref()))
                        )
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_abstract
(class-ns RestFn (§ extends AFunction)
    (§ abstract int getRequiredArity())

    #_protected
    (§ method Object doInvoke(Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
            Object args)
        nil
    )

    #_protected
    (§ method Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
            Object arg20, Object args)
        nil
    )

    (§ method Object applyTo(ISeq args)
        (when (ß RT.boundedLength(args, getRequiredArity()) <= getRequiredArity())
            (§ return (ß AFn.applyToHelper(this, Util.ret1(args, args = nil))))
        )
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (§ return (ß doInvoke(Util.ret1(args, args = nil))))
            )
            (§ case 1)
            (do
                (§ return (ß doInvoke(args.first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 2)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 3)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 4)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 5)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 6)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 7)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 8)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 9)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 10)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 11)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 12)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 13)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 14)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 15)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 16)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 17)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 18)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 19)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
            (§ case 20)
            (do
                (§ return (ß doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            )
        )
        (ß throwArity(-1))
    )

    (§ method Object invoke()
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(nil))
            )
            (§ default )
            (do
                (ß throwArity(0))
            )
        )
    )

    (§ method Object invoke(Object arg1)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(Util.ret1(arg1, arg1 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(1))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(2))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    ArraySeq.create(
                        Util.ret1(arg3, arg3 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(3))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    ArraySeq.create(
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    ArraySeq.create(
                        Util.ret1(arg4, arg4 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(4))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(5))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(6))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(7))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(8))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(9))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    ArraySeq.create(
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(10))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(11))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(12))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(13))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(14))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(15))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(16))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(17))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(18))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ArraySeq.create(
                            Util.ret1(arg19, arg19 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(19))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq.create(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil),
                        Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ArraySeq.create(
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                        ArraySeq.create(
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil), nil))
            )
            (§ default )
            (do
                (ß throwArity(20))
            )
        )
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args)
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ontoArrayPrepend(args,
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil),
                        Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                        ontoArrayPrepend(args,
                            Util.ret1(arg20, arg20 = nil))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil),
                        ArraySeq.create(args)))
            )
            (§ default )
            (do
                (ß throwArity(21))
            )
        )
    )

    #_protected
    (§ defn ISeq ontoArrayPrepend(Object[] array, Object... args)
        (let [#_"ISeq" ret (ß ArraySeq.create(array))]
            (loop-when-recur [(ß int i = args.length - 1)] (ß i >= 0) [(ß --i)]
                (ß ret = RT.cons(args[i], ret))
            )
            ret
        )
    )

    #_protected
    (§ defn ISeq findKey(Object key, ISeq args)
        (while (ß args != nil)
            (when (ß key == args.first())
                (§ return (ß args.next()))
            )
            (ß args = RT.next(args))
            (ß args = RT.next(args))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Reversible

(§ interface Reversible
    (§ abstract ISeq rseq())
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

(class-ns RT
    (§ def Boolean T = Boolean.TRUE)
    (§ def Boolean F = Boolean.FALSE)
    (§ def String LOADER_SUFFIX = "__init")

    ;; simple-symbol->class
    (§ def IPersistentMap DEFAULT_IMPORTS = map(
      #_map Symbol.intern("Boolean"), Boolean.class,
      #_map Symbol.intern("Byte"), Byte.class,
      #_map Symbol.intern("Character"), Character.class,
      #_map Symbol.intern("Class"), Class.class,
      #_map Symbol.intern("ClassLoader"), ClassLoader.class,
      #_map Symbol.intern("Compiler"), Compiler.class,
      #_map Symbol.intern("Double"), Double.class,
      #_map Symbol.intern("Enum"), Enum.class,
      #_map Symbol.intern("Float"), Float.class,
      #_map Symbol.intern("InheritableThreadLocal"), InheritableThreadLocal.class,
      #_map Symbol.intern("Integer"), Integer.class,
      #_map Symbol.intern("Long"), Long.class,
      #_map Symbol.intern("Math"), Math.class,
      #_map Symbol.intern("Number"), Number.class,
      #_map Symbol.intern("Object"), Object.class,
      #_map Symbol.intern("Package"), Package.class,
      #_map Symbol.intern("Process"), Process.class,
      #_map Symbol.intern("ProcessBuilder"), ProcessBuilder.class,
      #_map Symbol.intern("Runtime"), Runtime.class,
      #_map Symbol.intern("RuntimePermission"), RuntimePermission.class,
      #_map Symbol.intern("SecurityManager"), SecurityManager.class,
      #_map Symbol.intern("Short"), Short.class,
      #_map Symbol.intern("StackTraceElement"), StackTraceElement.class,
      #_map Symbol.intern("StrictMath"), StrictMath.class,
      #_map Symbol.intern("String"), String.class,
      #_map Symbol.intern("StringBuffer"), StringBuffer.class,
      #_map Symbol.intern("StringBuilder"), StringBuilder.class,
      #_map Symbol.intern("System"), System.class,
      #_map Symbol.intern("Thread"), Thread.class,
      #_map Symbol.intern("ThreadGroup"), ThreadGroup.class,
      #_map Symbol.intern("ThreadLocal"), ThreadLocal.class,
      #_map Symbol.intern("Throwable"), Throwable.class,
      #_map Symbol.intern("Void"), Void.class,
      #_map Symbol.intern("Appendable"), Appendable.class,
      #_map Symbol.intern("CharSequence"), CharSequence.class,
      #_map Symbol.intern("Cloneable"), Cloneable.class,
      #_map Symbol.intern("Comparable"), Comparable.class,
      #_map Symbol.intern("Iterable"), Iterable.class,
      #_map Symbol.intern("Readable"), Readable.class,
      #_map Symbol.intern("Runnable"), Runnable.class,
      #_map Symbol.intern("Callable"), Callable.class,
      #_map Symbol.intern("BigInteger"), BigInteger.class,
      #_map Symbol.intern("BigDecimal"), BigDecimal.class,
      #_map Symbol.intern("ArithmeticException"), ArithmeticException.class,
      #_map Symbol.intern("ArrayIndexOutOfBoundsException"), ArrayIndexOutOfBoundsException.class,
      #_map Symbol.intern("ArrayStoreException"), ArrayStoreException.class,
      #_map Symbol.intern("ClassCastException"), ClassCastException.class,
      #_map Symbol.intern("ClassNotFoundException"), ClassNotFoundException.class,
      #_map Symbol.intern("CloneNotSupportedException"), CloneNotSupportedException.class,
      #_map Symbol.intern("EnumConstantNotPresentException"), EnumConstantNotPresentException.class,
      #_map Symbol.intern("Exception"), Exception.class,
      #_map Symbol.intern("IllegalAccessException"), IllegalAccessException.class,
      #_map Symbol.intern("IllegalArgumentException"), IllegalArgumentException.class,
      #_map Symbol.intern("IllegalMonitorStateException"), IllegalMonitorStateException.class,
      #_map Symbol.intern("IllegalStateException"), IllegalStateException.class,
      #_map Symbol.intern("IllegalThreadStateException"), IllegalThreadStateException.class,
      #_map Symbol.intern("IndexOutOfBoundsException"), IndexOutOfBoundsException.class,
      #_map Symbol.intern("InstantiationException"), InstantiationException.class,
      #_map Symbol.intern("InterruptedException"), InterruptedException.class,
      #_map Symbol.intern("NegativeArraySizeException"), NegativeArraySizeException.class,
      #_map Symbol.intern("NoSuchFieldException"), NoSuchFieldException.class,
      #_map Symbol.intern("NoSuchMethodException"), NoSuchMethodException.class,
      #_map Symbol.intern("NullPointerException"), NullPointerException.class,
      #_map Symbol.intern("NumberFormatException"), NumberFormatException.class,
      #_map Symbol.intern("RuntimeException"), RuntimeException.class,
      #_map Symbol.intern("SecurityException"), SecurityException.class,
      #_map Symbol.intern("StringIndexOutOfBoundsException"), StringIndexOutOfBoundsException.class,
      #_map Symbol.intern("TypeNotPresentException"), TypeNotPresentException.class,
      #_map Symbol.intern("UnsupportedOperationException"), UnsupportedOperationException.class,
      #_map Symbol.intern("AbstractMethodError"), AbstractMethodError.class,
      #_map Symbol.intern("AssertionError"), AssertionError.class,
      #_map Symbol.intern("ClassCircularityError"), ClassCircularityError.class,
      #_map Symbol.intern("ClassFormatError"), ClassFormatError.class,
      #_map Symbol.intern("Error"), Error.class,
      #_map Symbol.intern("ExceptionInInitializerError"), ExceptionInInitializerError.class,
      #_map Symbol.intern("IllegalAccessError"), IllegalAccessError.class,
      #_map Symbol.intern("IncompatibleClassChangeError"), IncompatibleClassChangeError.class,
      #_map Symbol.intern("InstantiationError"), InstantiationError.class,
      #_map Symbol.intern("InternalError"), InternalError.class,
      #_map Symbol.intern("LinkageError"), LinkageError.class,
      #_map Symbol.intern("NoClassDefFoundError"), NoClassDefFoundError.class,
      #_map Symbol.intern("NoSuchFieldError"), NoSuchFieldError.class,
      #_map Symbol.intern("NoSuchMethodError"), NoSuchMethodError.class,
      #_map Symbol.intern("OutOfMemoryError"), OutOfMemoryError.class,
      #_map Symbol.intern("StackOverflowError"), StackOverflowError.class,
      #_map Symbol.intern("ThreadDeath"), ThreadDeath.class,
      #_map Symbol.intern("UnknownError"), UnknownError.class,
      #_map Symbol.intern("UnsatisfiedLinkError"), UnsatisfiedLinkError.class,
      #_map Symbol.intern("UnsupportedClassVersionError"), UnsupportedClassVersionError.class,
      #_map Symbol.intern("VerifyError"), VerifyError.class,
      #_map Symbol.intern("VirtualMachineError"), VirtualMachineError.class,
      #_map Symbol.intern("Thread$UncaughtExceptionHandler"), Thread.UncaughtExceptionHandler.class,
      #_map Symbol.intern("Thread$State"), Thread.State.class,
      #_map Symbol.intern("Deprecated"), Deprecated.class,
      #_map Symbol.intern("Override"), Override.class,
      #_map Symbol.intern("SuppressWarnings"), SuppressWarnings.class
    ))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (§ def Charset UTF8 = Charset.forName("UTF-8"))

    (§ defn Object readTrueFalseUnknown(String s)
        (cond (ß s.equals("true"))
            (do
                (§ return (ß Boolean.TRUE))
            )
            (ß s.equals("false"))
            (do
                (§ return (ß Boolean.FALSE))
            )
        )
        (ß Keyword.intern(nil, "unknown"))
    )

    (§ def Namespace CLOIURE_NS = Namespace.findOrCreate(Symbol.intern("cloiure.core")))
    (§ def Var OUT = Var.intern(CLOIURE_NS, Symbol.intern("*out*"), new OutputStreamWriter(System.out)).setDynamic())
    (§ def Var IN = Var.intern(CLOIURE_NS, Symbol.intern("*in*"), new LineNumberingPushbackReader(new InputStreamReader(System.in))).setDynamic())
    (§ def Var ERR = Var.intern(CLOIURE_NS, Symbol.intern("*err*"), new PrintWriter(new OutputStreamWriter(System.err), true)).setDynamic())
    (§ def Keyword TAG_KEY = Keyword.intern(nil, "tag"))
    (§ def Keyword CONST_KEY = Keyword.intern(nil, "const"))
    (§ def Var AGENT = Var.intern(CLOIURE_NS, Symbol.intern("*agent*"), nil).setDynamic())
    (§ def Object readeval = readTrueFalseUnknown(System.getProperty("cloiure.read.eval", "true")))
    (§ def Var READEVAL = Var.intern(CLOIURE_NS, Symbol.intern("*read-eval*"),  readeval).setDynamic())
    (§ def Var DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic())
    (§ def Var DEFAULT_DATA_READER_FN = Var.intern(CLOIURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic())
    (§ def Var DEFAULT_DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("default-data-readers"), RT.map()))
    (§ def Var SUPPRESS_READ = Var.intern(CLOIURE_NS, Symbol.intern("*suppress-read*"), nil).setDynamic())
    (§ def Var ASSERT = Var.intern(CLOIURE_NS, Symbol.intern("*assert*"), T).setDynamic())
    (§ def Var MATH_CONTEXT = Var.intern(CLOIURE_NS, Symbol.intern("*math-context*"), nil).setDynamic())
    (§ def Keyword LINE_KEY = Keyword.intern(nil, "line"))
    (§ def Keyword COLUMN_KEY = Keyword.intern(nil, "column"))
    (§ def Keyword FILE_KEY = Keyword.intern(nil, "file"))
    (§ def Keyword DECLARED_KEY = Keyword.intern(nil, "declared"))
    (§ def Keyword DOC_KEY = Keyword.intern(nil, "doc"))
    (§ def Var USE_CONTEXT_CLASSLOADER = Var.intern(CLOIURE_NS, Symbol.intern("*use-context-classloader*"), T).setDynamic())
    ;; boolean
    (§ def Var UNCHECKED_MATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*unchecked-math*"), Boolean.FALSE).setDynamic())

    (§ def Symbol LOAD_FILE = Symbol.intern("load-file"))
    (§ def Symbol IN_NAMESPACE = Symbol.intern("in-ns"))
    (§ def Symbol NAMESPACE = Symbol.intern("ns"))
    (§ def Symbol IDENTICAL = Symbol.intern("identical?"))
    (§ def Var CMD_LINE_ARGS = Var.intern(CLOIURE_NS, Symbol.intern("*command-line-args*"), nil).setDynamic())
    ;; symbol
    (§ def Var CURRENT_NS = Var.intern(CLOIURE_NS, Symbol.intern("*ns*"), CLOIURE_NS).setDynamic())

    (§ def Var FLUSH_ON_NEWLINE = Var.intern(CLOIURE_NS, Symbol.intern("*flush-on-newline*"), T).setDynamic())
    (§ def Var PRINT_META = Var.intern(CLOIURE_NS, Symbol.intern("*print-meta*"), F).setDynamic())
    (§ def Var PRINT_READABLY = Var.intern(CLOIURE_NS, Symbol.intern("*print-readably*"), T).setDynamic())
    (§ def Var PRINT_DUP = Var.intern(CLOIURE_NS, Symbol.intern("*print-dup*"), F).setDynamic())
    (§ def Var WARN_ON_REFLECTION = Var.intern(CLOIURE_NS, Symbol.intern("*warn-on-reflection*"), F).setDynamic())
    (§ def Var ALLOW_UNRESOLVED_VARS = Var.intern(CLOIURE_NS, Symbol.intern("*allow-unresolved-vars*"), F).setDynamic())
    (§ def Var READER_RESOLVER = Var.intern(CLOIURE_NS, Symbol.intern("*reader-resolver*"), nil).setDynamic())

    (§ def Var IN_NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("in-ns"), F))
    (§ def Var NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("ns"), F))
    (§ def Var FN_LOADER_VAR = Var.intern(CLOIURE_NS, Symbol.intern("*fn-loader*"), nil).setDynamic())
    (§ def Var PRINT_INITIALIZED = Var.intern(CLOIURE_NS, Symbol.intern("print-initialized")))
    (§ def Var PR_ON = Var.intern(CLOIURE_NS, Symbol.intern("pr-on")))

    (§ def IFn inNamespace = new AFn()
        (§ reify
            (§ method Object invoke(Object arg1)
                (let [#_"Symbol" nsname (ß (Symbol) arg1)]
                    (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsname))]
                        (ß CURRENT_NS.set(ns))
                        ns
                    )
                )
            )
        )
    )

    (§ def IFn bootNamespace = new AFn()
        (§ reify
            (§ method Object invoke(Object __form, Object __env, Object arg1)
                (let [#_"Symbol" nsname (ß (Symbol) arg1)]
                    (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsname))]
                        (ß CURRENT_NS.set(ns))
                        ns
                    )
                )
            )
        )
    )

    (§ defn List<String> processCommandLine(String[] args)
        (let [#_"List<String>" arglist (ß Arrays.asList(args))]
            (let [#_"int" split (ß arglist.indexOf("--"))]
                (when (ß split >= 0)
                    (ß CMD_LINE_ARGS.bindRoot(RT.seq(arglist.subList(split + 1, args.length))))
                    (§ return (ß arglist.subList(0, split)))
                )
                arglist
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (§ defn PrintWriter errPrintWriter()
        (let [#_"Writer" w (ß (Writer) ERR.deref())]
            (if (ß w instanceof PrintWriter)
                (do
                    (ß (PrintWriter) w)
                )
                (do
                    (ß new PrintWriter(w))
                )
            )
        )
    )

    (§ def Object[] EMPTY_ARRAY = new Object[] (§))
    (§ def Comparator DEFAULT_COMPARATOR = new DefaultComparator())

    #_private
    (class-ns DefaultComparator (§ implements Comparator)
        (§ method int compare(Object o1, Object o2)
            (ß Util.compare(o1, o2))
        )
    )

    (§ def AtomicInteger id = new AtomicInteger(1))

    (§ defn void addURL(Object url) (§ throws MalformedURLException)
        (let [#_"URL" u (ß (url instanceof String) ? (new URL((String) url)) :or (URL) url)]
            (let [#_"ClassLoader" ccl (ß Thread.currentThread().getContextClassLoader())]
                (if (ß ccl instanceof DynamicClassLoader)
                    (do
                        (ß ((DynamicClassLoader)ccl).addURL(u))
                    )
                    (do
                        (throw (ß new IllegalAccessError("Context classloader is not a DynamicClassLoader")))
                    )
                )
                nil
            )
        )
    )

    (§ def boolean checkSpecAsserts = Boolean.getBoolean("cloiure.spec.check-asserts"))
    (§ def boolean instrumentMacros = ! Boolean.getBoolean("cloiure.spec.skip-macros"))
    #_volatile
    (§ def boolean CHECK_SPECS = false)

    (§ static
        (let [#_"Keyword" arglistskw (ß Keyword.intern(nil, "arglists"))]
            (let [#_"Symbol" namesym (ß Symbol.intern("name"))]
                (ß OUT.setTag(Symbol.intern("java.io.Writer")))
                (ß CURRENT_NS.setTag(Symbol.intern("cloiure.lang.Namespace")))
                (ß AGENT.setMeta(map(DOC_KEY, "The agent currently running an action on this thread, else nil")))
                (ß AGENT.setTag(Symbol.intern("cloiure.lang.Agent")))
                (ß MATH_CONTEXT.setTag(Symbol.intern("java.math.MathContext")))
                (let [#_"Var" nv (ß Var.intern(CLOIURE_NS, NAMESPACE, bootNamespace))]
                    (ß nv.setMacro())
                    (§ let [#_"Var" v]
                        (ß v = Var.intern(CLOIURE_NS, IN_NAMESPACE, inNamespace))
                        (ß v.setMeta(map(DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", arglistskw, list(vector(namesym)))))
                        (ß v = Var.intern(CLOIURE_NS, LOAD_FILE, new AFn()
                            (§ reify
                                (§ method Object invoke(Object arg1)
                                    (try
                                        (ß Compiler.loadFile((String) arg1))
                                        (catch IOException e
                                            (throw (ß Util.sneakyThrow(e)))
                                        )
                                    )
                                )
                            ))
                        )
                        (ß v.setMeta(map(DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", arglistskw, list(vector(namesym)))))
                        (try
                            (ß doInit())
                            (catch Exception e
                                (throw (ß Util.sneakyThrow(e)))
                            )
                        )

                        (ß CHECK_SPECS = RT.instrumentMacros)
                    )
                )
            )
        )
    )

    (§ defn Keyword keyword(String ns, String name)
        (ß Keyword.intern((Symbol.intern(ns, name))))
    )

    (§ defn Var var(String ns, String name)
        (ß Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name)))
    )

    (§ defn Var var(String ns, String name, Object init)
        (ß Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name), init))
    )

    (§ defn void loadResourceScript(String name) (§ throws IOException)
        (ß loadResourceScript(name, true))
        nil
    )

    (§ defn void maybeLoadResourceScript(String name) (§ throws IOException)
        (ß loadResourceScript(name, false))
        nil
    )

    (§ defn void loadResourceScript(String name, boolean failIfNotFound) (§ throws IOException)
        (ß loadResourceScript(RT.class, name, failIfNotFound))
        nil
    )

    (§ defn void loadResourceScript(Class c, String name) (§ throws IOException)
        (ß loadResourceScript(c, name, true))
        nil
    )

    (§ defn void loadResourceScript(Class c, String name, boolean failIfNotFound) (§ throws IOException)
        (let [#_"int" slash (ß name.lastIndexOf(\/))]
            (let [#_"String" file (ß (slash >= 0) ? name.substring(slash + 1) :or name)]
                (let [#_"InputStream" ins (ß resourceAsStream(baseLoader(), name))]
                    (cond (ß ins != nil)
                        (do
                            (try
                                (ß Compiler.load(new InputStreamReader(ins, UTF8), name, file))
                                (finally
                                    (ß ins.close())
                                )
                            )
                        )
                        failIfNotFound
                        (do
                            (throw (ß new FileNotFoundException("Could not locate Cloiure resource on classpath: " + name)))
                        )
                    )
                    nil
                )
            )
        )
    )

    (§ defn void init()
        (ß RT.errPrintWriter().println("No need to call RT.init() anymore"))
        nil
    )

    (§ defn long lastModified(URL url, String libfile) (§ throws IOException)
        (let [#_"URLConnection" connection (ß url.openConnection())]
            (try
                (if (ß url.getProtocol().equals("jar"))
                    (do
                        (ß ((JarURLConnection) connection).getJarFile().getEntry(libfile).getTime())
                    )
                    (do
                        (ß connection.getLastModified())
                    )
                )
                (finally
                    (let [#_"InputStream" ins (ß connection.getInputStream())]
                        (when (ß ins != nil)
                            (ß ins.close())
                        )
                    )
                )
            )
        )
    )

    (§ defn void compile(String cljfile) (§ throws IOException)
        (let [#_"InputStream" ins (ß resourceAsStream(baseLoader(), cljfile))]
            (if (ß ins != nil)
                (do
                    (try
                        (ß Compiler.compile(new InputStreamReader(ins, UTF8), cljfile, cljfile.substring(1 + cljfile.lastIndexOf("/"))))
                        (finally
                            (ß ins.close())
                        )
                    )
                )
                (do
                    (throw (ß new FileNotFoundException("Could not locate Cloiure resource on classpath: " + cljfile)))
                )
            )
            nil
        )
    )

    (§ defn void load(String scriptbase) (§ throws IOException, ClassNotFoundException)
        (ß load(scriptbase, true))
        nil
    )

    (§ defn void load(String scriptbase, boolean failIfNotFound) (§ throws IOException, ClassNotFoundException)
        (let [#_"String" classfile (ß scriptbase + LOADER_SUFFIX + ".class")]
            (let [#_"String" cljfile (ß scriptbase + ".cli")]
                (let [#_"String" scriptfile cljfile]
                    (let [#_"URL" classURL (ß getResource(baseLoader(), classfile))]
                        (let [#_"URL" cljURL (ß getResource(baseLoader(), scriptfile))]
                            (when (ß cljURL == nil)
                                (ß scriptfile = scriptbase + ".clic")
                                (ß cljURL = getResource(baseLoader(), scriptfile))
                            )
                            (let [#_"boolean" loaded false]
                                (when (ß (classURL != nil && (cljURL == nil || lastModified(classURL, classfile) > lastModified(cljURL, scriptfile))) || classURL == nil)
                                    (try
                                        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
                                            #_map CURRENT_NS, CURRENT_NS.deref(),
                                            #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                                            #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
                                        )))
                                        (ß loaded = (loadClassForName(scriptbase.replace(\/, \.) + LOADER_SUFFIX) != nil))
                                        (finally
                                            (ß Var.popThreadBindings())
                                        )
                                    )
                                )
                                (cond (ß !loaded && cljURL != nil)
                                    (do
                                        (if (ß booleanCast(Compiler.COMPILE_FILES.deref()))
                                            (do
                                                (ß compile(scriptfile))
                                            )
                                            (do
                                                (ß loadResourceScript(RT.class, scriptfile))
                                            )
                                        )
                                    )
                                    (ß !loaded && failIfNotFound)
                                    (do
                                        (throw (ß new FileNotFoundException(String.format("Could not locate %s or %s on classpath.%s", classfile, cljfile, scriptbase.contains("_") ? " Please check that namespaces with dashes use underscores in the Cloiure file name." :or ""))))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn void doInit() (§ throws ClassNotFoundException, IOException)
        (ß load("cloiure/core"))

        (ß Var.pushThreadBindings(RT.mapUniqueKeys(
              #_map CURRENT_NS, CURRENT_NS.deref(),
              #_map WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
              #_map RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
        )))
        (try
            (let [(ß Symbol USER = Symbol.intern("user"))]
                (let [(ß Symbol CLOIURE = Symbol.intern("cloiure.core"))]
                    (let [#_"Var" in_ns (ß var("cloiure.core", "in-ns"))]
                        (let [#_"Var" refer (ß var("cloiure.core", "refer"))]
                            (ß in_ns.invoke(USER))
                            (ß refer.invoke(CLOIURE))
                            (ß maybeLoadResourceScript("user.cli"))

                            ;; start socket servers
                            (let [#_"Var" require (ß var("cloiure.core", "require"))]
                                (let [(ß Symbol SERVER = Symbol.intern("cloiure.core.server"))]
                                    (ß require.invoke(SERVER))
                                    (let [#_"Var" start_servers (ß var("cloiure.core.server", "start-servers"))]
                                        (ß start_servers.invoke(System.getProperties()))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (ß Var.popThreadBindings())
            )
        )
        nil
    )

    (§ defn int nextID()
        (ß id.getAndIncrement())
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    (§ defn void loadLibrary(String libname)
        (ß System.loadLibrary(libname))
        nil
    )

    (§ def- int CHUNK_SIZE = 32)

    (§ defn ISeq chunkIteratorSeq(Iterator iter)
        (when (ß iter.hasNext())
            (§ return (ß new LazySeq(new AFn()
                (§ reify
                    (§ method Object invoke()
                        (let [#_"Object[]" arr (ß new Object[CHUNK_SIZE])]
                            (let [#_"int" n 0]
                                (while (ß iter.hasNext() && n < CHUNK_SIZE)
                                    (ß arr[n++] = iter.next())
                                )
                                (ß new ChunkedCons(new ArrayChunk(arr, 0, n), chunkIteratorSeq(iter)))
                            )
                        )
                    )
                )))
            )
        )
        nil
    )

    (§ defn ISeq seq(Object coll)
        (cond (ß coll instanceof ASeq)
            (do
                (ß (ASeq) coll)
            )
            (ß coll instanceof LazySeq)
            (do
                (ß ((LazySeq) coll).seq())
            )
            :else
            (do
                (ß seqFrom(coll))
            )
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (§ defn ISeq seqFrom(Object coll)
        (cond (ß coll instanceof Seqable)
            (do
                (ß ((Seqable) coll).seq())
            )
            (ß coll == nil)
            (do
                nil
            )
            (ß coll instanceof Iterable)
            (do
                (ß chunkIteratorSeq(((Iterable) coll).iterator()))
            )
            (ß coll.getClass().isArray())
            (do
                (ß ArraySeq.createFromObject(coll))
            )
            (ß coll instanceof CharSequence)
            (do
                (ß StringSeq.create((CharSequence) coll))
            )
            (ß coll instanceof Map)
            (do
                (ß seq(((Map) coll).entrySet()))
            )
            :else
            (do
                (let [#_"Class" c (ß coll.getClass())]
                    (let [#_"Class" sc (ß c.getSuperclass())]
                        (throw (ß new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName())))
                    )
                )
            )
        )
    )

    (§ defn boolean canSeq(Object coll)
        (ß coll instanceof ISeq
            || coll instanceof Seqable
            || coll == nil
            || coll instanceof Iterable
            || coll.getClass().isArray()
            || coll instanceof CharSequence
            || coll instanceof Map)
    )

    (§ defn Iterator iter(Object coll)
        (cond (ß coll instanceof Iterable)
            (do
                (ß ((Iterable)coll).iterator())
            )
            (ß coll == nil)
            (do
                (ß new Iterator()
                    (§ reify
                        (§ method boolean hasNext()
                            false
                        )

                        (§ method Object next()
                            (throw (ß new NoSuchElementException()))
                        )

                        (§ method void remove()
                            (throw (ß new UnsupportedOperationException()))
                        )
                    )
                )
            )
            (ß coll instanceof Map)
            (do
                (ß ((Map)coll).entrySet().iterator())
            )
            (ß coll instanceof String)
            (do
                (let [#_"String" s (ß (String) coll)]
                    (ß new Iterator()
                        (§ reify
                            (let [#_"int" i 0]
                                (§ method boolean hasNext()
                                    (ß (i < s.length()))
                                )

                                (§ method Object next()
                                    (ß s.charAt(i++))
                                )

                                (§ method void remove()
                                    (throw (ß new UnsupportedOperationException()))
                                )
                            )
                        )
                    )
                )
            )
            (ß coll.getClass().isArray())
            (do
                (ß ArrayIter.createFromObject(coll))
            )
            :else
            (do
                (ß iter(seq(coll)))
            )
        )
    )

    (§ defn Object seqOrElse(Object o)
        (ß (seq(o) == nil) ? nil :or o)
    )

    (§ defn ISeq keys(Object coll)
        (if (ß coll instanceof IPersistentMap)
            (do
                (ß APersistentMap.KeySeq.createFromMap((IPersistentMap)coll))
            )
            (do
                (ß APersistentMap.KeySeq.create(seq(coll)))
            )
        )
    )

    (§ defn ISeq vals(Object coll)
        (if (ß coll instanceof IPersistentMap)
            (do
                (ß APersistentMap.ValSeq.createFromMap((IPersistentMap)coll))
            )
            (do
                (ß APersistentMap.ValSeq.create(seq(coll)))
            )
        )
    )

    (§ defn IPersistentMap meta(Object x)
        (when (ß x instanceof IMeta)
            (§ return (ß ((IMeta) x).meta()))
        )
        nil
    )

    (§ defn int count(Object o)
        (when (ß o instanceof Counted)
            (§ return (ß ((Counted) o).count()))
        )
        (ß countFrom(Util.ret1(o, o = nil)))
    )

    (§ defn int countFrom(Object o)
        (cond (ß o == nil)
            (do
                (§ return 0)
            )
            (ß o instanceof IPersistentCollection)
            (do
                (let [#_"ISeq" s (ß seq(o))]
                    (ß o = nil)
                    (let [#_"int" i 0]
                        (loop-when-recur [(ß )] (ß s != nil) [(ß s = s.next())]
                            (when (ß s instanceof Counted)
                                (§ return (ß i + s.count()))
                            )
                            (ß i++)
                        )
                        (§ return i)
                    )
                )
            )
            (ß o instanceof CharSequence)
            (do
                (§ return (ß ((CharSequence) o).length()))
            )
            (ß o instanceof Collection)
            (do
                (§ return (ß ((Collection) o).size()))
            )
            (ß o instanceof Map)
            (do
                (§ return (ß ((Map) o).size()))
            )
            (ß o instanceof Map.Entry)
            (do
                (§ return 2)
            )
            (ß o.getClass().isArray())
            (do
                (§ return (ß Array.getLength(o)))
            )
        )

        (throw (ß new UnsupportedOperationException("count not supported on this type: " + o.getClass().getSimpleName())))
    )

    (§ defn IPersistentCollection conj(IPersistentCollection coll, Object x)
        (when (ß coll == nil)
            (§ return (ß new PersistentList(x)))
        )
        (ß coll.cons(x))
    )

    (§ defn ISeq cons(Object x, Object coll)
        (cond (ß coll == nil)
            (do
                (ß new PersistentList(x))
            )
            (ß coll instanceof ISeq)
            (do
                (ß new Cons(x, (ISeq) coll))
            )
            :else
            (do
                (ß new Cons(x, seq(coll)))
            )
        )
    )

    (§ defn Object first(Object x)
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).first()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (ß seq == nil)
                (§ return nil)
            )
            (ß seq.first())
        )
    )

    (§ defn Object second(Object x)
        (ß first(next(x)))
    )

    (§ defn Object third(Object x)
        (ß first(next(next(x))))
    )

    (§ defn Object fourth(Object x)
        (ß first(next(next(next(x)))))
    )

    (§ defn ISeq next(Object x)
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).next()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (ß seq == nil)
                (§ return nil)
            )
            (ß seq.next())
        )
    )

    (§ defn ISeq more(Object x)
        (when (ß x instanceof ISeq)
            (§ return (ß ((ISeq) x).more()))
        )
        (let [#_"ISeq" seq (ß seq(x))]
            (when (ß seq == nil)
                (§ return (ß PersistentList.EMPTY))
            )
            (ß seq.more())
        )
    )

    (§ defn Object peek(Object x)
        (when (ß x == nil)
            (§ return nil)
        )
        (ß ((IPersistentStack) x).peek())
    )

    (§ defn Object pop(Object x)
        (when (ß x == nil)
            (§ return nil)
        )
        (ß ((IPersistentStack) x).pop())
    )

    (§ defn Object get(Object coll, Object key)
        (when (ß coll instanceof ILookup)
            (§ return (ß ((ILookup) coll).valAt(key)))
        )
        (ß getFrom(coll, key))
    )

    (§ defn Object getFrom(Object coll, Object key)
        (cond (ß coll == nil)
            (do
                (§ return nil)
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (§ return (ß m.get(key)))
                )
            )
            (ß coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" set (ß (IPersistentSet) coll)]
                    (§ return (ß set.get(key)))
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (when (ß n >= 0 && n < count(coll))
                        (§ return (ß nth(coll, n)))
                    )
                    (§ return nil)
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" set (ß (ITransientSet) coll)]
                    (§ return (ß set.get(key)))
                )
            )
        )

        nil
    )

    (§ defn Object get(Object coll, Object key, Object notFound)
        (when (ß coll instanceof ILookup)
            (§ return (ß ((ILookup) coll).valAt(key, notFound)))
        )
        (ß getFrom(coll, key, notFound))
    )

    (§ defn Object getFrom(Object coll, Object key, Object notFound)
        (cond (ß coll == nil)
            (do
                (§ return notFound)
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (when (ß m.containsKey(key))
                        (§ return (ß m.get(key)))
                    )
                    (§ return notFound)
                )
            )
            (ß coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" set (ß (IPersistentSet) coll)]
                    (when (ß set.contains(key))
                        (§ return (ß set.get(key)))
                    )
                    (§ return notFound)
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (§ return (ß (n >= 0 && n < count(coll)) ? nth(coll, n) :or notFound))
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" set (ß (ITransientSet) coll)]
                    (when (ß set.contains(key))
                        (§ return (ß set.get(key)))
                    )
                    (§ return notFound)
                )
            )
        )
        notFound
    )

    (§ defn Associative assoc(Object coll, Object key, Object val)
        (when (ß coll == nil)
            (§ return (ß new PersistentArrayMap(new Object[] (§ key, val ))))
        )
        (ß ((Associative) coll).assoc(key, val))
    )

    (§ defn Object contains(Object coll, Object key)
        (cond (ß coll == nil)
            (do
                (§ return (ß F))
            )
            (ß coll instanceof Associative)
            (do
                (§ return (ß ((Associative) coll).containsKey(key) ? T :or F))
            )
            (ß coll instanceof IPersistentSet)
            (do
                (§ return (ß ((IPersistentSet) coll).contains(key) ? T :or F))
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (§ return (ß m.containsKey(key) ? T :or F))
                )
            )
            (ß coll instanceof Set)
            (do
                (let [#_"Set" s (ß (Set) coll)]
                    (§ return (ß s.contains(key) ? T :or F))
                )
            )
            (ß key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
            (do
                (let [#_"int" n (ß ((Number) key).intValue())]
                    (§ return (ß (n >= 0 && n < count(coll)) ? T :or F))
                )
            )
            (ß coll instanceof ITransientSet)
            (do
                (§ return (ß ((ITransientSet)coll).contains(key) ? T :or F))
            )
            (ß coll instanceof ITransientAssociative2)
            (do
                (§ return (ß (((ITransientAssociative2)coll).containsKey(key)) ? T :or F))
            )
        )
        (throw (ß new IllegalArgumentException("contains? not supported on type: " + coll.getClass().getName())))
    )

    (§ defn Object find(Object coll, Object key)
        (cond (ß coll == nil)
            (do
                (§ return nil)
            )
            (ß coll instanceof Associative)
            (do
                (§ return (ß ((Associative) coll).entryAt(key)))
            )
            (ß coll instanceof Map)
            (do
                (let [#_"Map" m (ß (Map) coll)]
                    (when (ß m.containsKey(key))
                        (§ return (ß MapEntry.create(key, m.get(key))))
                    )
                    (§ return nil)
                )
            )
            (ß coll instanceof ITransientAssociative2)
            (do
                (§ return (ß ((ITransientAssociative2) coll).entryAt(key)))
            )
        )
        (throw (ß new IllegalArgumentException("find not supported on type: " + coll.getClass().getName())))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    (§ defn ISeq findKey(Keyword key, ISeq keyvals)
        (while (ß keyvals != nil)
            (let [#_"ISeq" r (ß keyvals.next())]
                (when (ß r == nil)
                    (throw (ß Util.runtimeException("Malformed keyword argslist")))
                )
                (when (ß keyvals.first() == key)
                    (§ return r)
                )
                (ß keyvals = r.next())
            )
        )
        nil
    )

    (§ defn Object dissoc(Object coll, Object key)
        (when (ß coll == nil)
            (§ return nil)
        )
        (ß ((IPersistentMap) coll).without(key))
    )

    (§ defn Object nth(Object coll, int n)
        (when (ß coll instanceof Indexed)
            (§ return (ß ((Indexed) coll).nth(n)))
        )
        (ß nthFrom(Util.ret1(coll, coll = nil), n))
    )

    (§ defn Object nthFrom(Object coll, int n)
        (cond (ß coll == nil)
            (do
                nil
            )
            (ß coll instanceof CharSequence)
            (do
                (ß Character.valueOf(((CharSequence) coll).charAt(n)))
            )
            (ß coll.getClass().isArray())
            (do
                (ß Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n)))
            )
            (ß coll instanceof RandomAccess)
            (do
                (ß ((List) coll).get(n))
            )
            (ß coll instanceof Matcher)
            (do
                (ß ((Matcher) coll).group(n))
            )
            (ß coll instanceof Map.Entry)
            (do
                (let [(ß Map.Entry e = (Map.Entry) coll)]
                    (cond (ß n == 0)
                        (do
                            (§ return (ß e.getKey()))
                        )
                        (ß n == 1)
                        (do
                            (§ return (ß e.getValue()))
                        )
                    )
                    (throw (ß new IndexOutOfBoundsException()))
                )
            )
            (ß coll instanceof Sequential)
            (do
                (let [#_"ISeq" seq (ß RT.seq(coll))]
                    (ß coll = nil)
                    (loop-when-recur [(ß int i = 0)] (ß i <= n && seq != nil) [(ß ++i, seq = seq.next())]
                        (when (ß i == n)
                            (§ return (ß seq.first()))
                        )
                    )
                    (throw (ß new IndexOutOfBoundsException()))
                )
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())))
            )
        )
    )

    (§ defn Object nth(Object coll, int n, Object notFound)
        (when (ß coll instanceof Indexed)
            (let [#_"Indexed" v (ß (Indexed) coll)]
                (§ return (ß v.nth(n, notFound)))
            )
        )
        (ß nthFrom(coll, n, notFound))
    )

    (§ defn Object nthFrom(Object coll, int n, Object notFound)
        (cond (ß coll == nil)
            (do
                notFound
            )
            (ß n < 0)
            (do
                notFound
            )
            (ß coll instanceof CharSequence)
            (do
                (let [#_"CharSequence" s (ß (CharSequence) coll)]
                    (when (ß n < s.length())
                        (§ return (ß Character.valueOf(s.charAt(n))))
                    )
                    notFound
                )
            )
            (ß coll.getClass().isArray())
            (do
                (when (ß n < Array.getLength(coll))
                    (§ return (ß Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))))
                )
                notFound
            )
            (ß coll instanceof RandomAccess)
            (do
                (let [#_"List" list (ß (List) coll)]
                    (when (ß n < list.size())
                        (§ return (ß list.get(n)))
                    )
                    notFound
                )
            )
            (ß coll instanceof Matcher)
            (do
                (let [#_"Matcher" m (ß (Matcher) coll)]
                    (when (ß n < m.groupCount())
                        (§ return (ß m.group(n)))
                    )
                    notFound
                )
            )
            (ß coll instanceof Map.Entry)
            (do
                (let [(ß Map.Entry e = (Map.Entry) coll)]
                    (cond (ß n == 0)
                        (do
                            (§ return (ß e.getKey()))
                        )
                        (ß n == 1)
                        (do
                            (§ return (ß e.getValue()))
                        )
                    )
                    notFound
                )
            )
            (ß coll instanceof Sequential)
            (do
                (let [#_"ISeq" seq (ß RT.seq(coll))]
                    (ß coll = nil)
                    (loop-when-recur [(ß int i = 0)] (ß i <= n && seq != nil) [(ß ++i, seq = seq.next())]
                        (when (ß i == n)
                            (§ return (ß seq.first()))
                        )
                    )
                    notFound
                )
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())))
            )
        )
    )

    (§ defn Object assocN(int n, Object val, Object coll)
        (cond (ß coll == nil)
            (do
                nil
            )
            (ß coll instanceof IPersistentVector)
            (do
                (ß ((IPersistentVector) coll).assocN(n, val))
            )
            (ß coll instanceof Object[])
            (do
                ;; hmm... this is not persistent
                (let [#_"Object[]" array (ß ((Object[]) coll))]
                    (ß array[n] = val)
                    array
                )
            )
            :else
            (do
                nil
            )
        )
    )

    (§ defn boolean hasTag(Object o, Object tag)
        (ß Util.equals(tag, RT.get(RT.meta(o), TAG_KEY)))
    )

    (§ defn Object box(Object x)
        x
    )

    (§ defn Character box(char x)
        (ß Character.valueOf(x))
    )

    (§ defn Object box(boolean x)
        (ß x ? T :or F)
    )

    (§ defn Object box(Boolean x)
        x
    )

    (§ defn Number box(byte x)
        x
    )

    (§ defn Number box(short x)
        x
    )

    (§ defn Number box(int x)
        x
    )

    (§ defn Number box(long x)
        x
    )

    (§ defn Number box(float x)
        x
    )

    (§ defn Number box(double x)
        x
    )

    (§ defn char charCast(Object x)
        (when (ß x instanceof Character)
            (§ return (ß ((Character) x).charValue()))
        )
        (let [#_"long" n (ß ((Number) x).longValue())]
            (when (ß n < Character.MIN_VALUE || n > Character.MAX_VALUE)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            (ß (char) n)
        )
    )

    (§ defn char charCast(byte x)
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn char charCast(short x)
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn char charCast(char x)
        x
    )

    (§ defn char charCast(int x)
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn char charCast(long x)
        (let [#_"char" i (ß (char) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
            )
            i
        )
    )

    (§ defn char charCast(float x)
        (when (ß x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
            (§ return (ß (char) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
    )

    (§ defn char charCast(double x)
        (when (ß x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
            (§ return (ß (char) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for char: " + x)))
    )

    (§ defn boolean booleanCast(Object x)
        (when (ß x instanceof Boolean)
            (§ return (ß ((Boolean) x).booleanValue()))
        )
        (ß (x != nil))
    )

    (§ defn boolean booleanCast(boolean x)
        x
    )

    (§ defn byte byteCast(Object x)
        (when (ß x instanceof Byte)
            (§ return (ß ((Byte) x).byteValue()))
        )
        (let [#_"long" n (ß longCast(x))]
            (when (ß n < Byte.MIN_VALUE || n > Byte.MAX_VALUE)
                (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
            )
            (ß (byte) n)
        )
    )

    (§ defn byte byteCast(byte x)
        x
    )

    (§ defn byte byteCast(short x)
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn byte byteCast(int x)
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn byte byteCast(long x)
        (let [#_"byte" i (ß (byte) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
            )
            i
        )
    )

    (§ defn byte byteCast(float x)
        (when (ß x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
            (§ return (ß (byte) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
    )

    (§ defn byte byteCast(double x)
        (when (ß x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
            (§ return (ß (byte) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for byte: " + x)))
    )

    (§ defn short shortCast(Object x)
        (when (ß x instanceof Short)
            (§ return (ß ((Short) x).shortValue()))
        )
        (let [#_"long" n (ß longCast(x))]
            (when (ß n < Short.MIN_VALUE || n > Short.MAX_VALUE)
                (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
            )
            (ß (short) n)
        )
    )

    (§ defn short shortCast(byte x)
        x
    )

    (§ defn short shortCast(short x)
        x
    )

    (§ defn short shortCast(int x)
        (let [#_"short" i (ß (short) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
            )
            i
        )
    )

    (§ defn short shortCast(long x)
        (let [#_"short" i (ß (short) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
            )
            i
        )
    )

    (§ defn short shortCast(float x)
        (when (ß x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
            (§ return (ß (short) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
    )

    (§ defn short shortCast(double x)
        (when (ß x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
            (§ return (ß (short) x))
        )
        (throw (ß new IllegalArgumentException("Value out of range for short: " + x)))
    )

    (§ defn int intCast(Object x)
        (when (ß x instanceof Integer)
            (§ return (ß ((Integer)x).intValue()))
        )
        (when (ß x instanceof Number)
            (let [#_"long" n (ß longCast(x))]
                (§ return (ß intCast(n)))
            )
        )
        (ß ((Character) x).charValue())
    )

    (§ defn int intCast(char x)
        x
    )

    (§ defn int intCast(byte x)
        x
    )

    (§ defn int intCast(short x)
        x
    )

    (§ defn int intCast(int x)
        x
    )

    (§ defn int intCast(float x)
        (when (ß x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for int: " + x)))
        )
        (ß (int) x)
    )

    (§ defn int intCast(long x)
        (let [#_"int" i (ß (int) x)]
            (when (ß i != x)
                (throw (ß new IllegalArgumentException("Value out of range for int: " + x)))
            )
            i
        )
    )

    (§ defn int intCast(double x)
        (when (ß x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for int: " + x)))
        )
        (ß (int) x)
    )

    (§ defn long longCast(Object x)
        (cond (ß x instanceof Integer || x instanceof Long)
            (do
                (ß ((Number) x).longValue())
            )
            (ß x instanceof BigInt)
            (do
                (let [#_"BigInt" bi (ß (BigInt) x)]
                    (if (ß bi.bipart == nil)
                        (do
                            (ß bi.lpart)
                        )
                        (do
                            (throw (ß new IllegalArgumentException("Value out of range for long: " + x)))
                        )
                    )
                )
            )
            (ß x instanceof BigInteger)
            (do
                (let [#_"BigInteger" bi (ß (BigInteger) x)]
                    (if (ß bi.bitLength() < 64)
                        (do
                            (ß bi.longValue())
                        )
                        (do
                            (throw (ß new IllegalArgumentException("Value out of range for long: " + x)))
                        )
                    )
                )
            )
            (ß x instanceof Byte || x instanceof Short)
            (do
                (ß ((Number) x).longValue())
            )
            (ß x instanceof Ratio)
            (do
                (ß longCast(((Ratio)x).bigIntegerValue()))
            )
            (ß x instanceof Character)
            (do
                (ß longCast(((Character) x).charValue()))
            )
            :else
            (do
                (ß longCast(((Number)x).doubleValue()))
            )
        )
    )

    (§ defn long longCast(byte x)
        x
    )

    (§ defn long longCast(short x)
        x
    )

    (§ defn long longCast(int x)
        x
    )

    (§ defn long longCast(float x)
        (when (ß x < Long.MIN_VALUE || x > Long.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for long: " + x)))
        )
        (ß (long) x)
    )

    (§ defn long longCast(long x)
        x
    )

    (§ defn long longCast(double x)
        (when (ß x < Long.MIN_VALUE || x > Long.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for long: " + x)))
        )
        (ß (long) x)
    )

    (§ defn float floatCast(Object x)
        (when (ß x instanceof Float)
            (§ return (ß ((Float) x).floatValue()))
        )
        (let [#_"double" n (ß ((Number) x).doubleValue())]
            (when (ß n < -Float.MAX_VALUE || n > Float.MAX_VALUE)
                (throw (ß new IllegalArgumentException("Value out of range for float: " + x)))
            )
            (ß (float) n)
        )
    )

    (§ defn float floatCast(byte x)
        x
    )

    (§ defn float floatCast(short x)
        x
    )

    (§ defn float floatCast(int x)
        x
    )

    (§ defn float floatCast(float x)
        x
    )

    (§ defn float floatCast(long x)
        x
    )

    (§ defn float floatCast(double x)
        (when (ß x < -Float.MAX_VALUE || x > Float.MAX_VALUE)
            (throw (ß new IllegalArgumentException("Value out of range for float: " + x)))
        )
        (ß (float) x)
    )

    (§ defn double doubleCast(Object x)
        (ß ((Number) x).doubleValue())
    )

    (§ defn double doubleCast(byte x)
        x
    )

    (§ defn double doubleCast(short x)
        x
    )

    (§ defn double doubleCast(int x)
        x
    )

    (§ defn double doubleCast(float x)
        x
    )

    (§ defn double doubleCast(long x)
        x
    )

    (§ defn double doubleCast(double x)
        x
    )

    (§ defn byte uncheckedByteCast(Object x)
        (ß ((Number) x).byteValue())
    )

    (§ defn byte uncheckedByteCast(byte x)
        x
    )

    (§ defn byte uncheckedByteCast(short x)
        (ß (byte) x)
    )

    (§ defn byte uncheckedByteCast(int x)
        (ß (byte) x)
    )

    (§ defn byte uncheckedByteCast(long x)
        (ß (byte) x)
    )

    (§ defn byte uncheckedByteCast(float x)
        (ß (byte) x)
    )

    (§ defn byte uncheckedByteCast(double x)
        (ß (byte) x)
    )

    (§ defn short uncheckedShortCast(Object x)
        (ß ((Number) x).shortValue())
    )

    (§ defn short uncheckedShortCast(byte x)
        x
    )

    (§ defn short uncheckedShortCast(short x)
        x
    )

    (§ defn short uncheckedShortCast(int x)
        (ß (short) x)
    )

    (§ defn short uncheckedShortCast(long x)
        (ß (short) x)
    )

    (§ defn short uncheckedShortCast(float x)
        (ß (short) x)
    )

    (§ defn short uncheckedShortCast(double x)
        (ß (short) x)
    )

    (§ defn char uncheckedCharCast(Object x)
        (when (ß x instanceof Character)
            (§ return (ß ((Character) x).charValue()))
        )
        (ß (char) ((Number) x).longValue())
    )

    (§ defn char uncheckedCharCast(byte x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(short x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(char x)
        x
    )

    (§ defn char uncheckedCharCast(int x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(long x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(float x)
        (ß (char) x)
    )

    (§ defn char uncheckedCharCast(double x)
        (ß (char) x)
    )

    (§ defn int uncheckedIntCast(Object x)
        (when (ß x instanceof Number)
            (§ return (ß ((Number)x).intValue()))
        )
        (ß ((Character) x).charValue())
    )

    (§ defn int uncheckedIntCast(byte x)
        x
    )

    (§ defn int uncheckedIntCast(short x)
        x
    )

    (§ defn int uncheckedIntCast(char x)
        x
    )

    (§ defn int uncheckedIntCast(int x)
        x
    )

    (§ defn int uncheckedIntCast(long x)
        (ß (int) x)
    )

    (§ defn int uncheckedIntCast(float x)
        (ß (int) x)
    )

    (§ defn int uncheckedIntCast(double x)
        (ß (int) x)
    )

    (§ defn long uncheckedLongCast(Object x)
        (ß ((Number) x).longValue())
    )

    (§ defn long uncheckedLongCast(byte x)
        x
    )

    (§ defn long uncheckedLongCast(short x)
        x
    )

    (§ defn long uncheckedLongCast(int x)
        x
    )

    (§ defn long uncheckedLongCast(long x)
        x
    )

    (§ defn long uncheckedLongCast(float x)
        (ß (long) x)
    )

    (§ defn long uncheckedLongCast(double x)
        (ß (long) x)
    )

    (§ defn float uncheckedFloatCast(Object x)
        (ß ((Number) x).floatValue())
    )

    (§ defn float uncheckedFloatCast(byte x)
        x
    )

    (§ defn float uncheckedFloatCast(short x)
        x
    )

    (§ defn float uncheckedFloatCast(int x)
        x
    )

    (§ defn float uncheckedFloatCast(long x)
        x
    )

    (§ defn float uncheckedFloatCast(float x)
        x
    )

    (§ defn float uncheckedFloatCast(double x)
        (ß (float) x)
    )

    (§ defn double uncheckedDoubleCast(Object x)
        (ß ((Number) x).doubleValue())
    )

    (§ defn double uncheckedDoubleCast(byte x)
        x
    )

    (§ defn double uncheckedDoubleCast(short x)
        x
    )

    (§ defn double uncheckedDoubleCast(int x)
        x
    )

    (§ defn double uncheckedDoubleCast(long x)
        x
    )

    (§ defn double uncheckedDoubleCast(float x)
        x
    )

    (§ defn double uncheckedDoubleCast(double x)
        x
    )

    (§ defn IPersistentMap map(Object... init)
        (cond (ß init == nil)
            (do
                (§ return (ß PersistentArrayMap.EMPTY))
            )
            (ß init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
            (do
                (§ return (ß PersistentArrayMap.createWithCheck(init)))
            )
        )
        (ß PersistentHashMap.createWithCheck(init))
    )

    (§ defn IPersistentMap mapUniqueKeys(Object... init)
        (cond (ß init == nil)
            (do
                (§ return (ß PersistentArrayMap.EMPTY))
            )
            (ß init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
            (do
                (§ return (ß new PersistentArrayMap(init)))
            )
        )
        (ß PersistentHashMap.create(init))
    )

    (§ defn IPersistentSet set(Object... init)
        (ß PersistentHashSet.createWithCheck(init))
    )

    (§ defn IPersistentVector vector(Object... init)
        (ß LazilyPersistentVector.createOwning(init))
    )

    (§ defn IPersistentVector subvec(IPersistentVector v, int start, int end)
        (when (ß end < start || start < 0 || end > v.count())
            (throw (ß new IndexOutOfBoundsException()))
        )
        (when (ß start == end)
            (§ return (ß PersistentVector.EMPTY))
        )
        (ß new APersistentVector.SubVector(nil, v, start, end))
    )

    (§ defn ISeq list()
        nil
    )

    (§ defn ISeq list(Object arg1)
        (ß new PersistentList(arg1))
    )

    (§ defn ISeq list(Object arg1, Object arg2)
        (ß listStar(arg1, arg2, nil))
    )

    (§ defn ISeq list(Object arg1, Object arg2, Object arg3)
        (ß listStar(arg1, arg2, arg3, nil))
    )

    (§ defn ISeq list(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß listStar(arg1, arg2, arg3, arg4, nil))
    )

    (§ defn ISeq list(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß listStar(arg1, arg2, arg3, arg4, arg5, nil))
    )

    (§ defn ISeq listStar(Object arg1, ISeq rest)
        (ß (ISeq) cons(arg1, rest))
    )

    (§ defn ISeq listStar(Object arg1, Object arg2, ISeq rest)
        (ß (ISeq) cons(arg1, cons(arg2, rest)))
    )

    (§ defn ISeq listStar(Object arg1, Object arg2, Object arg3, ISeq rest)
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, rest))))
    )

    (§ defn ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, ISeq rest)
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, rest)))))
    )

    (§ defn ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, ISeq rest)
        (ß (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, cons(arg5, rest))))))
    )

    (§ defn ISeq arrayToList(Object[] a)
        (let [#_"ISeq" ret nil]
            (loop-when-recur [(ß int i = a.length - 1)] (ß i >= 0) [(ß --i)]
                (ß ret = (ISeq) cons(a[i], ret))
            )
            ret
        )
    )

    (§ defn Object[] object_array(Object sizeOrSeq)
        (if (ß sizeOrSeq instanceof Number)
            (do
                (ß new Object[((Number) sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" s (ß RT.seq(sizeOrSeq))]
                    (let [#_"int" size (ß RT.count(s))]
                        (let [#_"Object[]" ret (ß new Object[size])]
                            (loop-when-recur [(ß int i = 0)] (ß i < size && s != nil) [(ß i++, s = s.next())]
                                (ß ret[i] = s.first())
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn Object[] toArray(Object coll)
        (cond (ß coll == nil)
            (do
                (ß EMPTY_ARRAY)
            )
            (ß coll instanceof Object[])
            (do
                (ß (Object[]) coll)
            )
            (ß coll instanceof Collection)
            (do
                (ß ((Collection) coll).toArray())
            )
            (ß coll instanceof Iterable)
            (do
                (let [#_"ArrayList" ret (ß new ArrayList())]
                    (doseq [#_"Object" o (ß (Iterable)coll)]
                        (ß ret.add(o))
                    )
                    (ß ret.toArray())
                )
            )
            (ß coll instanceof Map)
            (do
                (ß ((Map) coll).entrySet().toArray())
            )
            (ß coll instanceof String)
            (do
                (let [#_"char[]" chars (ß ((String) coll).toCharArray())]
                    (let [#_"Object[]" ret (ß new Object[chars.length])]
                        (loop-when-recur [(ß int i = 0)] (ß i < chars.length) [(ß i++)]
                            (ß ret[i] = chars[i])
                        )
                        ret
                    )
                )
            )
            (ß coll.getClass().isArray())
            (do
                (let [#_"ISeq" s (ß (seq(coll)))]
                    (let [#_"Object[]" ret (ß new Object[count(s)])]
                        (loop-when-recur [(ß int i = 0)] (ß i < ret.length) [(ß i++, s = s.next())]
                            (ß ret[i] = s.first())
                        )
                        ret
                    )
                )
            )
            :else
            (do
                (throw (ß Util.runtimeException("Unable to convert: " + coll.getClass() + " to Object[]")))
            )
        )
    )

    (§ defn Object[] seqToArray(ISeq seq)
        (let [#_"int" len (ß length(seq))]
            (let [#_"Object[]" ret (ß new Object[len])]
                (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                    (ß ret[i] = seq.first())
                )
                ret
            )
        )
    )

    ;; supports java Collection.toArray(T[])
    (§ defn Object[] seqToPassedArray(ISeq seq, Object[] passed)
        (let [#_"Object[]" dest passed]
            (let [#_"int" len (ß count(seq))]
                (when (ß len > dest.length)
                    (ß dest = (Object[]) Array.newInstance(passed.getClass().getComponentType(), len))
                )
                (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                    (ß dest[i] = seq.first())
                )
                (when (ß len < passed.length)
                    (ß dest[len] = nil)
                )
                dest
            )
        )
    )

    (§ defn Object seqToTypedArray(ISeq seq)
        (let [#_"Class" type (ß (seq != nil && seq.first() != nil) ? seq.first().getClass() :or Object.class)]
            (ß seqToTypedArray(type, seq))
        )
    )

    (§ defn Object seqToTypedArray(Class type, ISeq seq)
        (let [#_"Object" ret (ß Array.newInstance(type, length(seq)))]
            (cond (ß type == Integer.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, intCast(seq.first())))
                    )
                )
                (ß type == Byte.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, byteCast(seq.first())))
                    )
                )
                (ß type == Float.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, floatCast(seq.first())))
                    )
                )
                (ß type == Short.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, shortCast(seq.first())))
                    )
                )
                (ß type == Character.TYPE)
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, charCast(seq.first())))
                    )
                )
                :else
                (do
                    (loop-when-recur [(ß int i = 0)] (ß seq != nil) [(ß ++i, seq = seq.next())]
                        (ß Array.set(ret, i, seq.first()))
                    )
                )
            )
            ret
        )
    )

    (§ defn int length(ISeq list)
        (let [#_"int" i 0]
            (loop-when-recur [(ß ISeq c = list)] (ß c != nil) [(ß c = c.next())]
                (ß i++)
            )
            i
        )
    )

    (§ defn int boundedLength(ISeq list, int limit)
        (let [#_"int" i 0]
            (loop-when-recur [(ß ISeq c = list)] (ß c != nil && i <= limit) [(ß c = c.next())]
                (ß i++)
            )
            i
        )
    )

    (§ defn Character readRet(int ret)
        (when (ß ret == -1)
            (§ return nil)
        )
        (ß box((char) ret))
    )

    (§ defn Character readChar(Reader r) (§ throws IOException)
        (let [#_"int" ret (ß r.read())]
            (ß readRet(ret))
        )
    )

    (§ defn Character peekChar(Reader r) (§ throws IOException)
        (§ let [#_"int" ret]
            (if (ß r instanceof PushbackReader)
                (do
                    (ß ret = r.read())
                    (ß ((PushbackReader) r).unread(ret))
                )
                (do
                    (ß r.mark(1))
                    (ß ret = r.read())
                    (ß r.reset())
                )
            )

            (ß readRet(ret))
        )
    )

    (§ defn int getLineNumber(Reader r)
        (when (ß r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) r).getLineNumber()))
        )
        0
    )

    (§ defn int getColumnNumber(Reader r)
        (when (ß r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) r).getColumnNumber()))
        )
        0
    )

    (§ defn LineNumberingPushbackReader getLineNumberingReader(Reader r)
        (when (ß isLineNumberingReader(r))
            (§ return (ß (LineNumberingPushbackReader) r))
        )
        (ß new LineNumberingPushbackReader(r))
    )

    (§ defn boolean isLineNumberingReader(Reader r)
        (ß (r instanceof LineNumberingPushbackReader))
    )

    (§ defn boolean isReduced(Object r)
        (ß (r instanceof Reduced))
    )

    (§ defn String resolveClassNameInContext(String className)
        ;; todo - look up in context var
        className
    )

    (§ defn boolean suppressRead()
        (ß booleanCast(SUPPRESS_READ.deref()))
    )

    (§ defn String printString(Object x)
        (try
            (let [#_"StringWriter" sw (ß new StringWriter())]
                (ß print(x, sw))
                (ß sw.toString())
            )
            (catch Exception e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ defn Object readString(String s)
        (ß readString(s, nil))
    )

    (§ defn Object readString(String s, Object opts)
        (let [#_"PushbackReader" r (ß new PushbackReader(new StringReader(s)))]
            (ß LispReader.read(r, opts))
        )
    )

    (§ defn void print(Object x, Writer w) (§ throws IOException)
        ;; call multimethod
        (if (ß PRINT_INITIALIZED.isBound() && RT.booleanCast(PRINT_INITIALIZED.deref()))
            (do
                (ß PR_ON.invoke(x, w))
            )
            (do
                (let [#_"boolean" readably (ß booleanCast(PRINT_READABLY.deref()))]
                    (when (ß x instanceof Obj)
                        (let [#_"Obj" o (ß (Obj) x)]
                            (when (ß RT.count(o.meta()) > 0 && ((readably && booleanCast(PRINT_META.deref())) || booleanCast(PRINT_DUP.deref())))
                                (let [#_"IPersistentMap" meta (ß o.meta())]
                                    (ß w.write("#^"))
                                    (if (ß meta.count() == 1 && meta.containsKey(TAG_KEY))
                                        (do
                                            (ß print(meta.valAt(TAG_KEY), w))
                                        )
                                        (do
                                            (ß print(meta, w))
                                        )
                                    )
                                    (ß w.write(\space))
                                )
                            )
                        )
                    )
                    (cond (ß x == nil)
                        (do
                            (ß w.write("nil"))
                        )
                        (ß x instanceof ISeq || x instanceof IPersistentList)
                        (do
                            (ß w.write(\())
                            (ß printInnerSeq(seq(x), w))
                            (ß w.write(\)))
                        )
                        (ß x instanceof String)
                        (do
                            (let [#_"String" s (ß (String) x)]
                                (if (ß !readably)
                                    (do
                                        (ß w.write(s))
                                    )
                                    (do
                                        (ß w.write(\")) ;; oops! "
                                        (loop-when-recur [(ß int i = 0)] (ß i < s.length()) [(ß i++)]
                                            (let [#_"char" c (ß s.charAt(i))]
                                                (§ switch c
                                                    (§ case \newline)
                                                    (do
                                                        (ß w.write("\\n"))
                                                        (§ break )
                                                    )
                                                    (§ case \tab)
                                                    (do
                                                        (ß w.write("\\t"))
                                                        (§ break )
                                                    )
                                                    (§ case \return)
                                                    (do
                                                        (ß w.write("\\r"))
                                                        (§ break )
                                                    )
                                                    (§ case \")
                                                    (do
                                                        (ß w.write("\\\""))
                                                        (§ break )
                                                    )
                                                    (§ case \\)
                                                    (do
                                                        (ß w.write("\\\\"))
                                                        (§ break )
                                                    )
                                                    (§ case \formfeed)
                                                    (do
                                                        (ß w.write("\\f"))
                                                        (§ break )
                                                    )
                                                    (§ case \backspace)
                                                    (do
                                                        (ß w.write("\\b"))
                                                        (§ break )
                                                    )
                                                    (§ default )
                                                    (do
                                                        (ß w.write(c))
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                        (ß w.write(\")) ;; oops! "
                                    )
                                )
                            )
                        )
                        (ß x instanceof IPersistentMap)
                        (do
                            (ß w.write(\{))
                            (loop-when-recur [(ß ISeq s = seq(x))] (ß s != nil) [(ß s = s.next())]
                                (let [#_"IMapEntry" e (ß (IMapEntry) s.first())]
                                    (ß print(e.key(), w))
                                    (ß w.write(\space))
                                    (ß print(e.val(), w))
                                    (when (ß s.next() != nil)
                                        (ß w.write(", "))
                                    )
                                )
                            )
                            (ß w.write(\}))
                        )
                        (ß x instanceof IPersistentVector)
                        (do
                            (let [#_"IPersistentVector" a (ß (IPersistentVector) x)]
                                (ß w.write(\[))
                                (loop-when-recur [(ß int i = 0)] (ß i < a.count()) [(ß i++)]
                                    (ß print(a.nth(i), w))
                                    (when (ß i < a.count() - 1)
                                        (ß w.write(\space))
                                    )
                                )
                                (ß w.write(\]))
                            )
                        )
                        (ß x instanceof IPersistentSet)
                        (do
                            (ß w.write("#{"))
                            (loop-when-recur [(ß ISeq s = seq(x))] (ß s != nil) [(ß s = s.next())]
                                (ß print(s.first(), w))
                                (when (ß s.next() != nil)
                                    (ß w.write(" "))
                                )
                            )
                            (ß w.write(\}))
                        )
                        (ß x instanceof Character)
                        (do
                            (let [#_"char" c (ß ((Character) x).charValue())]
                                (if (ß !readably)
                                    (do
                                        (ß w.write(c))
                                    )
                                    (do
                                        (ß w.write(\\))
                                        (§ switch c
                                            (§ case \newline)
                                            (do
                                                (ß w.write("newline"))
                                                (§ break )
                                            )
                                            (§ case \tab)
                                            (do
                                                (ß w.write("tab"))
                                                (§ break )
                                            )
                                            (§ case \space)
                                            (do
                                                (ß w.write("space"))
                                                (§ break )
                                            )
                                            (§ case \backspace)
                                            (do
                                                (ß w.write("backspace"))
                                                (§ break )
                                            )
                                            (§ case \formfeed)
                                            (do
                                                (ß w.write("formfeed"))
                                                (§ break )
                                            )
                                            (§ case \return)
                                            (do
                                                (ß w.write("return"))
                                                (§ break )
                                            )
                                            (§ default )
                                            (do
                                                (ß w.write(c))
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß x instanceof Class)
                        (do
                            (ß w.write("#="))
                            (ß w.write(((Class) x).getName()))
                        )
                        (ß x instanceof BigDecimal && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write(\M))
                        )
                        (ß x instanceof BigInt && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write(\N))
                        )
                        (ß x instanceof BigInteger && readably)
                        (do
                            (ß w.write(x.toString()))
                            (ß w.write("BIGINT"))
                        )
                        (ß x instanceof Var)
                        (do
                            (let [#_"Var" v (ß (Var) x)]
                                (ß w.write("#=(var " + v.ns.name + "/" + v.sym + ")"))
                            )
                        )
                        (ß x instanceof Pattern)
                        (do
                            (let [#_"Pattern" p (ß (Pattern) x)]
                                (ß w.write("#\"" + p.pattern() + "\""))
                            )
                        )
                        :else
                        (do
                            (ß w.write(x.toString()))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- void printInnerSeq(ISeq x, Writer w) (§ throws IOException)
        (loop-when-recur [(ß ISeq s = x)] (ß s != nil) [(ß s = s.next())]
            (ß print(s.first(), w))
            (when (ß s.next() != nil)
                (ß w.write(\space))
            )
        )
        nil
    )

    (§ defn void formatAesthetic(Writer w, Object obj) (§ throws IOException)
        (if (ß obj == nil)
            (do
                (ß w.write("nil"))
            )
            (do
                (ß w.write(obj.toString()))
            )
        )
        nil
    )

    (§ defn void formatStandard(Writer w, Object obj) (§ throws IOException)
        (cond (ß obj == nil)
            (do
                (ß w.write("nil"))
            )
            (ß obj instanceof String)
            (do
                (ß w.write(\")) ;; oops! "
                (ß w.write((String) obj))
                (ß w.write(\")) ;; oops! "
            )
            (ß obj instanceof Character)
            (do
                (ß w.write(\\))
                (let [#_"char" c (ß ((Character) obj).charValue())]
                    (§ switch c
                        (§ case \newline)
                        (do
                            (ß w.write("newline"))
                            (§ break )
                        )
                        (§ case \tab)
                        (do
                            (ß w.write("tab"))
                            (§ break )
                        )
                        (§ case \space)
                        (do
                            (ß w.write("space"))
                            (§ break )
                        )
                        (§ case \backspace)
                        (do
                            (ß w.write("backspace"))
                            (§ break )
                        )
                        (§ case \formfeed)
                        (do
                            (ß w.write("formfeed"))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (ß w.write(c))
                            (§ break )
                        )
                    )
                )
            )
            :else
            (do
                (ß w.write(obj.toString()))
            )
        )
        nil
    )

    (§ defn Object format(Object o, String s, Object... args) (§ throws IOException)
        (§ let [#_"Writer" w]
            (cond (ß o == nil)
                (do
                    (ß w = new StringWriter())
                )
                (ß Util.equals(o, T))
                (do
                    (ß w = (Writer) OUT.deref())
                )
                :else
                (do
                    (ß w = (Writer) o)
                )
            )
            (ß doFormat(w, s, ArraySeq.create(args)))
            (when (ß o == nil)
                (§ return (ß w.toString()))
            )
            nil
        )
    )

    (§ defn ISeq doFormat(Writer w, String s, ISeq args) (§ throws IOException)
        (loop-when-recur [(ß int i = 0)] (ß i < s.length()) [(ß )]
            (let [#_"char" c (ß s.charAt(i++))]
                (§ switch (ß Character.toLowerCase(c))
                    (§ case \~)
                    (do
                        (let [#_"char" d (ß s.charAt(i++))]
                            (§ switch (ß Character.toLowerCase(d))
                                (§ case \%)
                                (do
                                    (ß w.write(\newline))
                                    (§ break )
                                )
                                (§ case \t)
                                (do
                                    (ß w.write(\tab))
                                    (§ break )
                                )
                                (§ case \a)
                                (do
                                    (when (ß args == nil)
                                        (throw (ß new IllegalArgumentException("Missing argument")))
                                    )
                                    (ß RT.formatAesthetic(w, RT.first(args)))
                                    (ß args = RT.next(args))
                                    (§ break )
                                )
                                (§ case \s)
                                (do
                                    (when (ß args == nil)
                                        (throw (ß new IllegalArgumentException("Missing argument")))
                                    )
                                    (ß RT.formatStandard(w, RT.first(args)))
                                    (ß args = RT.next(args))
                                    (§ break )
                                )
                                (§ case \{)
                                (do
                                    (let [#_"int" j (ß s.indexOf("~}", i))] ;; note - does not nest
                                        (when (ß j == -1)
                                            (throw (ß new IllegalArgumentException("Missing ~}")))
                                        )
                                        (let [#_"String" subs (ß s.substring(i, j))]
                                            (loop-when-recur [(ß ISeq sargs = RT.seq(RT.first(args)))] (ß sargs != nil) [(ß )]
                                                (ß sargs = doFormat(w, subs, sargs))
                                            )
                                            (ß args = RT.next(args))
                                            (ß i = j + 2) ;; skip "~}"
                                            (§ break )
                                        )
                                    )
                                )
                                (§ case \^)
                                (do
                                    (when (ß args == nil)
                                        (§ return nil)
                                    )
                                    (§ break )
                                )
                                (§ case \~)
                                (do
                                    (ß w.write(\~))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (throw (ß new IllegalArgumentException("Unsupported ~ directive: " + d)))
                                )
                            )
                            (§ break )
                        )
                    )
                    (§ default )
                    (do
                        (ß w.write(c))
                        (§ break )
                    )
                )
            )
        )
        args
    )

    (§ defn Object[] setValues(Object... vals)
        (when (ß vals.length > 0)
            (§ return vals)
        )
        nil
    )

    (§ defn ClassLoader makeClassLoader()
        (ß (ClassLoader) AccessController.doPrivileged(new PrivilegedAction()
            (§ reify
                (§ method Object run()
                    (try
                        (ß Var.pushThreadBindings(RT.map(USE_CONTEXT_CLASSLOADER, RT.T)))
                        (ß new DynamicClassLoader(baseLoader()))
                        (finally
                            (ß Var.popThreadBindings())
                        )
                    )
                )
            ))
        )
    )

    (§ defn ClassLoader baseLoader()
        (cond (ß Compiler.LOADER.isBound())
            (do
                (§ return (ß (ClassLoader) Compiler.LOADER.deref()))
            )
            (ß booleanCast(USE_CONTEXT_CLASSLOADER.deref()))
            (do
                (§ return (ß Thread.currentThread().getContextClassLoader()))
            )
        )
        (ß Compiler.class.getClassLoader())
    )

    (§ defn InputStream resourceAsStream(ClassLoader loader, String name)
        (if (ß loader == nil)
            (do
                (ß ClassLoader.getSystemResourceAsStream(name))
            )
            (do
                (ß loader.getResourceAsStream(name))
            )
        )
    )

    (§ defn URL getResource(ClassLoader loader, String name)
        (if (ß loader == nil)
            (do
                (ß ClassLoader.getSystemResource(name))
            )
            (do
                (ß loader.getResource(name))
            )
        )
    )

    (§ defn Class classForName(String name, boolean load, ClassLoader loader)
        (try
            (let [#_"Class" c nil]
                (when (ß !(loader instanceof DynamicClassLoader))
                    (ß c = DynamicClassLoader.findInMemoryClass(name))
                )
                (when (ß c != nil)
                    (§ return c)
                )
                (ß Class.forName(name, load, loader))
            )
            (catch ClassNotFoundException e
                (throw (ß Util.sneakyThrow(e)))
            )
        )
    )

    (§ defn Class classForName(String name)
        (ß classForName(name, true, baseLoader()))
    )

    (§ defn Class classForNameNonLoading(String name)
        (ß classForName(name, false, baseLoader()))
    )

    (§ defn Class loadClassForName(String name)
        (try
            (ß classForNameNonLoading(name))
            (catch Exception e
                (if (ß e instanceof ClassNotFoundException)
                    (do
                        (§ return nil)
                    )
                    (do
                        (throw (ß Util.sneakyThrow(e)))
                    )
                )
            )
        )
        (ß classForName(name))
    )

    (§ defn float aget(float[] xs, int i)
        (ß xs[i])
    )

    (§ defn float aset(float[] xs, int i, float v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(float[] xs)
        (ß xs.length)
    )

    (§ defn float[] aclone(float[] xs)
        (ß xs.clone())
    )

    (§ defn double aget(double[] xs, int i)
        (ß xs[i])
    )

    (§ defn double aset(double[] xs, int i, double v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(double[] xs)
        (ß xs.length)
    )

    (§ defn double[] aclone(double[] xs)
        (ß xs.clone())
    )

    (§ defn int aget(int[] xs, int i)
        (ß xs[i])
    )

    (§ defn int aset(int[] xs, int i, int v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(int[] xs)
        (ß xs.length)
    )

    (§ defn int[] aclone(int[] xs)
        (ß xs.clone())
    )

    (§ defn long aget(long[] xs, int i)
        (ß xs[i])
    )

    (§ defn long aset(long[] xs, int i, long v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(long[] xs)
        (ß xs.length)
    )

    (§ defn long[] aclone(long[] xs)
        (ß xs.clone())
    )

    (§ defn char aget(char[] xs, int i)
        (ß xs[i])
    )

    (§ defn char aset(char[] xs, int i, char v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(char[] xs)
        (ß xs.length)
    )

    (§ defn char[] aclone(char[] xs)
        (ß xs.clone())
    )

    (§ defn byte aget(byte[] xs, int i)
        (ß xs[i])
    )

    (§ defn byte aset(byte[] xs, int i, byte v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(byte[] xs)
        (ß xs.length)
    )

    (§ defn byte[] aclone(byte[] xs)
        (ß xs.clone())
    )

    (§ defn short aget(short[] xs, int i)
        (ß xs[i])
    )

    (§ defn short aset(short[] xs, int i, short v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(short[] xs)
        (ß xs.length)
    )

    (§ defn short[] aclone(short[] xs)
        (ß xs.clone())
    )

    (§ defn boolean aget(boolean[] xs, int i)
        (ß xs[i])
    )

    (§ defn boolean aset(boolean[] xs, int i, boolean v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(boolean[] xs)
        (ß xs.length)
    )

    (§ defn boolean[] aclone(boolean[] xs)
        (ß xs.clone())
    )

    (§ defn Object aget(Object[] xs, int i)
        (ß xs[i])
    )

    (§ defn Object aset(Object[] xs, int i, Object v)
        (ß xs[i] = v)
        v
    )

    (§ defn int alength(Object[] xs)
        (ß xs.length)
    )

    (§ defn Object[] aclone(Object[] xs)
        (ß xs.clone())
    )
)
)

(java-ns cloiure.lang.Seqable

(§ interface Seqable
    (§ abstract ISeq seq())
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(class-ns SeqEnumeration (§ implements Enumeration)
    (§ field ISeq seq)

    (§ constructor SeqEnumeration(ISeq seq)
        (ß this.seq = seq)
        this
    )

    (§ method boolean hasMoreElements()
        (ß (seq != nil))
    )

    (§ method Object nextElement()
        (let [#_"Object" ret (ß RT.first(seq))]
            (ß seq = RT.next(seq))
            ret
        )
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (§ def Object START = new Object())

    (§ field Object seq)
    (§ field Object next)

    (§ constructor SeqIterator(Object o)
        (ß seq = START)
        (ß next = o)
        this
    )

    ;; preserved for binary compatibility
    (§ constructor SeqIterator(ISeq o)
        (ß seq = START)
        (ß next = o)
        this
    )

    (§ method boolean hasNext()
        (cond (ß seq == START)
            (do
                (ß seq = nil)
                (ß next = RT.seq(next))
            )
            (ß seq == next)
            (do
                (ß next = RT.next(seq))
            )
        )
        (ß (next != nil))
    )

    (§ method Object next() (§ throws NoSuchElementException)
        (when (ß !hasNext())
            (throw (ß new NoSuchElementException()))
        )
        (ß seq = next)
        (ß RT.first(next))
    )

    (§ method void remove()
        (throw (ß new UnsupportedOperationException()))
    )
)
)

(java-ns cloiure.lang.Sequential

(§ interface Sequential
)
)

(java-ns cloiure.lang.Settable

(§ interface Settable
    (§ abstract Object doSet(Object val))
    (§ abstract Object doReset(Object val))
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(§ interface Sorted
    (§ abstract Comparator comparator())
    (§ abstract Object entryKey(Object entry))
    (§ abstract ISeq seq(boolean ascending))
    (§ abstract ISeq seqFrom(Object key, boolean ascending))
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (§ field CharSequence s)
    (§ field int i)

    (§ defn StringSeq create(CharSequence s)
        (when (ß s.length() == 0)
            (§ return nil)
        )
        (ß new StringSeq(nil, s, 0))
    )

    (§ constructor StringSeq(IPersistentMap meta, CharSequence s, int i)
        (§ super(meta))
        (ß this.s = s)
        (ß this.i = i)
        this
    )

    (§ method Obj withMeta(IPersistentMap meta)
        (when (ß meta == meta())
            (§ return this)
        )
        (ß new StringSeq(meta, s, i))
    )

    (§ method Object first()
        (ß Character.valueOf(s.charAt(i)))
    )

    (§ method ISeq next()
        (when (ß i + 1 < s.length())
            (§ return (ß new StringSeq(_meta, s, i + 1)))
        )
        nil
    )

    (§ method int index()
        i
    )

    (§ method int count()
        (ß s.length() - i)
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    (§ field String ns)
    (§ field String name)
    (§ field- int _hasheq)
    (§ field IPersistentMap _meta)
    #_transient
    (§ field String _str)

    (§ method String toString()
        (when (ß _str == nil)
            (if (ß ns != nil)
                (do
                    (ß _str = (ns + "/" + name))
                )
                (do
                    (ß _str = name)
                )
            )
        )
        (ß _str)
    )

    (§ method String getNamespace()
        ns
    )

    (§ method String getName()
        name
    )

    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (§ defn Symbol create(String ns, String name)
        (ß Symbol.intern(ns, name))
    )

    (§ defn Symbol create(String nsname)
        (ß Symbol.intern(nsname))
    )

    (§ defn Symbol intern(String ns, String name)
        (ß new Symbol(ns, name))
    )

    (§ defn Symbol intern(String nsname)
        (let [#_"int" i (ß nsname.indexOf(\/))]
            (if (ß i == -1 || nsname.equals("/"))
                (do
                    (ß new Symbol(nil, nsname))
                )
                (do
                    (ß new Symbol(nsname.substring(0, i), nsname.substring(i + 1)))
                )
            )
        )
    )

    (§ constructor- Symbol(String ns_interned, String name_interned)
        (ß this.name = name_interned)
        (ß this.ns = ns_interned)
        (ß this._meta = nil)
        this
    )

    (§ method boolean equals(Object o)
        (when (ß this == o)
            (§ return true)
        )
        (when (ß !(o instanceof Symbol))
            (§ return false)
        )

        (let [#_"Symbol" symbol (ß (Symbol) o)]
            (ß Util.equals(ns, symbol.ns) && name.equals(symbol.name))
        )
    )

    (§ method int hashCode()
        (ß Util.hashCombine(name.hashCode(), Util.hash(ns)))
    )

    (§ method int hasheq()
        (when (ß _hasheq == 0)
            (ß _hasheq = Util.hashCombine(Murmur3.hashUnencodedChars(name), Util.hash(ns)))
        )
        (ß _hasheq)
    )

    (§ method IObj withMeta(IPersistentMap meta)
        (ß new Symbol(meta, ns, name))
    )

    (§ constructor- Symbol(IPersistentMap meta, String ns, String name)
        (ß this.name = name)
        (ß this.ns = ns)
        (ß this._meta = meta)
        this
    )

    (§ method int compareTo(Object o)
        (let [#_"Symbol" s (ß (Symbol) o)]
            (when (ß this.equals(o))
                (§ return 0)
            )
            (when (ß this.ns == nil && s.ns != nil)
                (§ return -1)
            )
            (when (ß this.ns != nil)
                (when (ß s.ns == nil)
                    (§ return 1)
                )
                (let [#_"int" nsc (ß this.ns.compareTo(s.ns))]
                    (when (ß nsc != 0)
                        (§ return nsc)
                    )
                )
            )
            (ß this.name.compareTo(s.name))
        )
    )

    (§ method Object invoke(Object obj)
        (ß RT.get(obj, this))
    )

    (§ method Object invoke(Object obj, Object notFound)
        (ß RT.get(obj, this, notFound))
    )

    (§ method IPersistentMap meta()
        (ß _meta)
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(class-ns TaggedLiteral (§ implements ILookup)
    (§ def Keyword TAG_KW = Keyword.intern("tag"))
    (§ def Keyword FORM_KW = Keyword.intern("form"))

    (§ field Symbol tag)
    (§ field Object form)

    (§ defn TaggedLiteral create(Symbol tag, Object form)
        (ß new TaggedLiteral(tag, form))
    )

    (§ constructor- TaggedLiteral(Symbol tag, Object form)
        (ß this.tag = tag)
        (ß this.form = form)
        this
    )

    (§ method Object valAt(Object key)
        (ß valAt(key, nil))
    )

    (§ method Object valAt(Object key, Object notFound)
        (cond (ß FORM_KW.equals(key))
            (do
                (ß this.form)
            )
            (ß TAG_KW.equals(key))
            (do
                (ß this.tag)
            )
            :else
            (do
                notFound
            )
        )
    )

    (§ anno @Override)
    (§ method boolean equals(Object o)
        (when (ß this == o)
            (§ return true)
        )
        (when (ß o == nil || getClass() != o.getClass())
            (§ return false)
        )

        (let [#_"TaggedLiteral" that (ß (TaggedLiteral) o)]
            (when (ß (form != nil) ? !form.equals(that.form) :or that.form != nil)
                (§ return false)
            )
            (when (ß (tag != nil) ? !tag.equals(that.tag) :or that.tag != nil)
                (§ return false)
            )

            true
        )
    )

    (§ anno @Override)
    (§ method int hashCode()
        (let [#_"int" result (ß Util.hash(tag))]
            (ß result = 31 * result + Util.hash(form))
            result
        )
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (§ field Ref[] bins)

    (§ method IPersistentMap mapAt(int bin)
        (ß (IPersistentMap) bins[bin].deref())
    )

    (§ method int binFor(Object k)
        ;; spread hashes, a la Cliff Click
        (let [#_"int" h (ß k.hashCode())]
            (ß h ^= (h >>> 20) :xor (h >>> 12))
            (ß h ^= (h >>> 7) :xor (h >>> 4))
            (ß h % bins.length)
        )
    )

    (§ method Entry entryAt(Object k)
        (ß mapAt(binFor(k)).entryAt(k))
    )

    (§ constructor TransactionalHashMap()
        (§ this(421))
        this
    )

    (§ constructor TransactionalHashMap(int nBins)
        (ß bins = new Ref[nBins])
        (loop-when-recur [(ß int i = 0)] (ß i < nBins) [(ß i++)]
            (ß bins[i] = new Ref(PersistentHashMap.EMPTY))
        )
        this
    )

    (§ constructor TransactionalHashMap(Map<? extends K, ? extends V> m)
        (§ this(m.size()))
        (ß putAll(m))
        this
    )

    (§ method int size()
        (let [#_"int" n 0]
            (loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
                (ß n += mapAt(i).count())
            )
            n
        )
    )

    (§ method boolean isEmpty()
        (ß (size() == 0))
    )

    (§ method boolean containsKey(Object k)
        (ß (entryAt(k) != nil))
    )

    (§ method V get(Object k)
        (let [#_"Entry" e (ß entryAt(k))]
            (when (ß e != nil)
                (§ return (ß (V) e.getValue()))
            )
            nil
        )
    )

    (§ method V put(K k, V v)
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Object" ret (ß map.valAt(k))]
                    (ß r.set(map.assoc(k, v)))
                    (ß (V) ret)
                )
            )
        )
    )

    (§ method V remove(Object k)
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Object" ret (ß map.valAt(k))]
                    (ß r.set(map.without(k)))
                    (ß (V) ret)
                )
            )
        )
    )

    (§ method void putAll(Map<? extends K, ? extends V> map)
        (loop-when-recur [(ß Iterator i = map.entrySet().iterator())] (ß i.hasNext()) [(ß )]
            (let [(ß Entry<K, V> e = (Entry) i.next())]
                (ß put(e.getKey(), e.getValue()))
            )
        )
        nil
    )

    (§ method void clear()
        (loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
            (let [#_"Ref" r (ß bins[i])]
                (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                    (when (ß map.count() > 0)
                        (ß r.set(PersistentHashMap.EMPTY))
                    )
                )
            )
        )
        nil
    )

    (§ method Set<Entry<K, V>> entrySet()
        (let [(ß ArrayList<Map.Entry<K, V>> entries = new ArrayList(bins.length))]
            (loop-when-recur [(ß int i = 0)] (ß i < bins.length) [(ß i++)]
                (let [#_"IPersistentMap" map (ß mapAt(i))]
                    (when (ß map.count() > 0)
                        (ß entries.addAll((Collection) RT.seq(map)))
                    )
                )
            )
            (ß new AbstractSet<Entry<K, V>>()
                (§ reify
                    (§ method Iterator iterator()
                        (ß Collections.unmodifiableList(entries).iterator())
                    )

                    (§ method int size()
                        (ß entries.size())
                    )
                )
            )
        )
    )

    (§ method V putIfAbsent(K k, V v)
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (if (ß e == nil)
                        (do
                            (ß r.set(map.assoc(k, v)))
                            nil
                        )
                        (do
                            (ß (V) e.getValue())
                        )
                    )
                )
            )
        )
    )

    (§ method boolean remove(Object k, Object v)
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (ß e != nil && e.getValue().equals(v))
                        (ß r.set(map.without(k)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    (§ method boolean replace(K k, V oldv, V newv)
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (ß e != nil && e.getValue().equals(oldv))
                        (ß r.set(map.assoc(k, newv)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    (§ method V replace(K k, V v)
        (let [#_"Ref" r (ß bins[binFor(k)])]
            (let [#_"IPersistentMap" map (ß (IPersistentMap) r.deref())]
                (let [#_"Entry" e (ß map.entryAt(k))]
                    (when (ß e != nil)
                        (ß r.set(map.assoc(k, v)))
                        (§ return (ß (V) e.getValue()))
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

(class-ns TransformerIterator (§ implements Iterator)
    (§ def- Buffer EMPTY = new Empty())
    (§ def- Object NONE = new Object())

    ;; Source
    (§ field- Iterator sourceIter)
    (§ field- IFn xf)
    (§ field- boolean multi)

    ;; Iteration state
    #_volatile
    (§ field- Buffer buffer = EMPTY)
    #_volatile
    (§ field- Object next = NONE)
    #_volatile
    (§ field- boolean completed = false)

    (§ constructor- TransformerIterator(IFn xform, Iterator sourceIter, boolean multi)
        (ß this.sourceIter = sourceIter)
        (ß this.xf = (IFn) xform.invoke(new AFn()
            (§ reify
                (§ method Object invoke()
                    nil
                )

                (§ method Object invoke(Object acc)
                    acc
                )

                (§ method Object invoke(Object acc, Object o)
                    (ß buffer = buffer.add(o))
                    acc
                )
            ))
        )
        (ß this.multi = multi)
        this
    )

    (§ defn Iterator create(IFn xform, Iterator source)
        (ß new TransformerIterator(xform, source, false))
    )

    (§ defn Iterator createMulti(IFn xform, List sources)
        (let [#_"Iterator[]" iters (ß new Iterator[sources.size()])]
            (loop-when-recur [(ß int i = 0)] (ß i < sources.size()) [(ß i++)]
                (ß iters[i] = (Iterator)sources.get(i))
            )
            (ß new TransformerIterator(xform, new MultiIterator(iters), true))
        )
    )

    (§ method- boolean step()
        (when (ß next != NONE)
            (§ return true)
        )

        (while (ß next == NONE)
            (if (ß buffer.isEmpty())
                (do
                    (cond completed
                        (do
                            (§ return false)
                        )
                        (ß sourceIter.hasNext())
                        (do
                            (let [#_"Object" iter nil]
                                (if multi
                                    (do
                                        (ß iter = xf.applyTo(RT.cons(nil, sourceIter.next())))
                                    )
                                    (do
                                        (ß iter = xf.invoke(nil, sourceIter.next()))
                                    )
                                )

                                (when (ß RT.isReduced(iter))
                                    (ß xf.invoke(nil))
                                    (ß completed = true)
                                )
                            )
                        )
                        :else
                        (do
                            (ß xf.invoke(nil))
                            (ß completed = true)
                        )
                    )
                )
                (do
                    (ß next = buffer.remove())
                )
            )
        )
        true
    )

    (§ method boolean hasNext()
        (ß step())
    )

    (§ method Object next()
        (when (ß hasNext())
            (let [#_"Object" ret next]
                (ß next = NONE)
                (§ return ret)
            )
        )
        (throw (ß new NoSuchElementException()))
    )

    (§ method void remove()
        (throw (ß new UnsupportedOperationException()))
    )

    #_private
    (§ interface Buffer
        (§ abstract Buffer add(Object o))
        (§ abstract Object remove())
        (§ abstract boolean isEmpty())
    )

    #_private
    (class-ns Empty (§ implements Buffer)
        (§ method Buffer add(Object o)
            (ß new Single(o))
        )

        (§ method Object remove()
            (throw (ß new IllegalStateException("Removing object from empty buffer")))
        )

        (§ method boolean isEmpty()
            true
        )

        (§ method String toString()
            (ß "Empty")
        )
    )

    #_private
    (class-ns Single (§ implements Buffer)
        #_volatile
        (§ field- Object val)

        (§ constructor Single(Object o)
            (ß this.val = o)
            this
        )

        (§ method Buffer add(Object o)
            (if (ß val == NONE)
                (do
                    (ß val = o)
                    this
                )
                (do
                    (ß new Many(val, o))
                )
            )
        )

        (§ method Object remove()
            (when (ß val == NONE)
                (throw (ß new IllegalStateException("Removing object from empty buffer")))
            )
            (let [#_"Object" ret val]
                (ß val = NONE)
                ret
            )
        )

        (§ method boolean isEmpty()
            (ß (val == NONE))
        )

        (§ method String toString()
            (ß "Single: " + val)
        )
    )

    #_private
    (class-ns Many (§ implements Buffer)
        (§ field- Queue vals = new LinkedList())

        (§ constructor Many(Object o1, Object o2)
            (ß vals.add(o1))
            (ß vals.add(o2))
            this
        )

        (§ method Buffer add(Object o)
            (ß vals.add(o))
            this
        )

        (§ method Object remove()
            (ß vals.remove())
        )

        (§ method boolean isEmpty()
            (ß vals.isEmpty())
        )

        (§ method String toString()
            (ß "Many: " + vals.toString())
        )
    )

    #_private
    (class-ns MultiIterator (§ implements Iterator)
        (§ field- Iterator[] iters)

        (§ constructor MultiIterator(Iterator[] iters)
            (ß this.iters = iters)
            this
        )

        (§ method boolean hasNext()
            (doseq [#_"Iterator" iter iters]
                (when (ß !iter.hasNext())
                    (§ return false)
                )
            )
            true
        )

        (§ method Object next()
            (let [#_"Object[]" nexts (ß new Object[iters.length])]
                (loop-when-recur [(ß int i = 0)] (ß i < iters.length) [(ß i++)]
                    (ß nexts[i] = iters[i].next())
                )
                (ß new ArraySeq(nexts, 0))
            )
        )

        (§ method void remove()
            (throw (ß new UnsupportedOperationException()))
        )
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

(class-ns Tuple
    (§ def int MAX_SIZE = 6)

    (§ defn IPersistentVector create()
        (ß PersistentVector.EMPTY)
    )

    (§ defn IPersistentVector create(Object v0)
        (ß RT.vector(v0))
    )

    (§ defn IPersistentVector create(Object v0, Object v1)
        (ß RT.vector(v0, v1))
    )

    (§ defn IPersistentVector create(Object v0, Object v1, Object v2)
        (ß RT.vector(v0, v1, v2))
    )

    (§ defn IPersistentVector create(Object v0, Object v1, Object v2, Object v3)
        (ß RT.vector(v0, v1, v2, v3))
    )

    (§ defn IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4)
        (ß RT.vector(v0, v1, v2, v3, v4))
    )

    (§ defn IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4, Object v5)
        (ß RT.vector(v0, v1, v2, v3, v4, v5))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(class-ns Util
    (§ defn boolean equiv(Object k1, Object k2)
        (when (ß k1 == k2)
            (§ return true)
        )
        (when (ß k1 != nil)
            (cond (ß k1 instanceof Number && k2 instanceof Number)
                (do
                    (§ return (ß Numbers.equal((Number)k1, (Number)k2)))
                )
                (ß k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
                (do
                    (§ return (ß pcequiv(k1, k2)))
                )
            )
            (§ return (ß k1.equals(k2)))
        )
        false
    )

    #_non-static
    (§ interface EquivPred
        (§ abstract boolean equiv(Object k1, Object k2))
    )

    (§ def EquivPred equivNull = new EquivPred()
        (§ reify
            (§ method boolean equiv(Object k1, Object k2)
                (ß (k2 == nil))
            )
        )
    )

    (§ def EquivPred equivEquals = new EquivPred()
        (§ reify
            (§ method boolean equiv(Object k1, Object k2)
                (ß k1.equals(k2))
            )
        )
    )

    (§ def EquivPred equivNumber = new EquivPred()
        (§ reify
            (§ method boolean equiv(Object k1, Object k2)
                (when (ß k2 instanceof Number)
                    (§ return (ß Numbers.equal((Number) k1, (Number) k2)))
                )
                false
            )
        )
    )

    (§ def EquivPred equivColl = new EquivPred()
        (§ reify
            (§ method boolean equiv(Object k1, Object k2)
                (when (ß k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
                    (§ return (ß pcequiv(k1, k2)))
                )
                (ß k1.equals(k2))
            )
        )
    )

    (§ defn EquivPred equivPred(Object k1)
        (cond (ß k1 == nil)
            (do
                (§ return equivNull)
            )
            (ß k1 instanceof Number)
            (do
                (§ return equivNumber)
            )
            (ß k1 instanceof String || k1 instanceof Symbol)
            (do
                (§ return equivEquals)
            )
            (ß k1 instanceof Collection || k1 instanceof Map)
            (do
                (§ return equivColl)
            )
        )
        equivEquals
    )

    (§ defn boolean equiv(long k1, long k2)
        (ß (k1 == k2))
    )

    (§ defn boolean equiv(Object k1, long k2)
        (ß equiv(k1, (Object)k2))
    )

    (§ defn boolean equiv(long k1, Object k2)
        (ß equiv((Object)k1, k2))
    )

    (§ defn boolean equiv(double k1, double k2)
        (ß (k1 == k2))
    )

    (§ defn boolean equiv(Object k1, double k2)
        (ß equiv(k1, (Object)k2))
    )

    (§ defn boolean equiv(double k1, Object k2)
        (ß equiv((Object)k1, k2))
    )

    (§ defn boolean equiv(boolean k1, boolean k2)
        (ß (k1 == k2))
    )

    (§ defn boolean equiv(Object k1, boolean k2)
        (ß equiv(k1, (Object)k2))
    )

    (§ defn boolean equiv(boolean k1, Object k2)
        (ß equiv((Object)k1, k2))
    )

    (§ defn boolean equiv(char c1, char c2)
        (ß (c1 == c2))
    )

    (§ defn boolean pcequiv(Object k1, Object k2)
        (when (ß k1 instanceof IPersistentCollection)
            (§ return (ß ((IPersistentCollection)k1).equiv(k2)))
        )
        (ß ((IPersistentCollection)k2).equiv(k1))
    )

    (§ defn boolean equals(Object k1, Object k2)
        (when (ß k1 == k2)
            (§ return true)
        )
        (ß (k1 != nil && k1.equals(k2)))
    )

    (§ defn boolean identical(Object k1, Object k2)
        (ß (k1 == k2))
    )

    (§ defn Class classOf(Object x)
        (when (ß x != nil)
            (§ return (ß x.getClass()))
        )
        nil
    )

    (§ defn int compare(Object k1, Object k2)
        (when (ß k1 == k2)
            (§ return 0)
        )
        (when (ß k1 != nil)
            (when (ß k2 == nil)
                (§ return 1)
            )
            (when (ß k1 instanceof Number)
                (§ return (ß Numbers.compare((Number) k1, (Number) k2)))
            )
            (§ return (ß ((Comparable) k1).compareTo(k2)))
        )
        -1
    )

    (§ defn int hash(Object o)
        (when (ß o == nil)
            (§ return 0)
        )
        (ß o.hashCode())
    )

    (§ defn int hasheq(Object o)
        (when (ß o == nil)
            (§ return 0)
        )
        (when (ß o instanceof IHashEq)
            (§ return (ß dohasheq((IHashEq) o)))
        )
        (when (ß o instanceof Number)
            (§ return (ß Numbers.hasheq((Number)o)))
        )
        (when (ß o instanceof String)
            (§ return (ß Murmur3.hashInt(o.hashCode())))
        )
        (ß o.hashCode())
    )

    (§ defn- int dohasheq(IHashEq o)
        (ß o.hasheq())
    )

    (§ defn int hashCombine(int seed, int hash)
        ;; a la boost
        (ß seed ^= hash + 0x9e3779b9 + (seed << 6) + (seed >> 2))
        seed
    )

    (§ defn boolean isPrimitive(Class c)
        (ß (c != nil && c.isPrimitive() && !(c == Void.TYPE)))
    )

    (§ defn boolean isInteger(Object x)
        (ß (x instanceof Integer || x instanceof Long || x instanceof BigInt || x instanceof BigInteger))
    )

    (§ defn Object ret1(Object ret, Object nil)
        ret
    )

    (§ defn ISeq ret1(ISeq ret, Object nil)
        ret
    )

    (§ defn <K, V> void clearCache(ReferenceQueue rq, ConcurrentHashMap<K, Reference<V>> cache)
        ;; cleanup any dead entries
        (when (ß rq.poll() != nil)
            (while (ß rq.poll() != nil)
            )
            (doseq [#_"Map.Entry<K, Reference<V>>" (ß e cache.entrySet())]
                (let [#_"Reference<V>" val (ß e.getValue())]
                    (when (ß val != nil && val.get() == nil)
                        (ß cache.remove(e.getKey(), val))
                    )
                )
            )
        )
        nil
    )

    (§ defn RuntimeException runtimeException(String s)
        (ß new RuntimeException(s))
    )

    (§ defn RuntimeException runtimeException(String s, Throwable e)
        (ß new RuntimeException(s, e))
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (§ defn RuntimeException sneakyThrow(Throwable t)
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (ß t == nil)
            (throw (ß new NullPointerException()))
        )
        (ß Util.<RuntimeException>sneakyThrow0(t))
        nil
    )

    (§ anno @SuppressWarnings("unchecked"))
    (§ defn- <T extends Throwable> void sneakyThrow0(Throwable t) (§ throws T)
        (throw (ß (T) t))
    )

    (§ defn Object loadWithClass(String scriptbase, Class<?> loadFrom) (§ throws IOException, ClassNotFoundException)
        (ß Var.pushThreadBindings(RT.map(new Object[] (§ Compiler.LOADER, loadFrom.getClassLoader() ))))
        (try
            (ß RT.var("cloiure.core", "load").invoke(scriptbase))
            (finally
                (ß Var.popThreadBindings())
            )
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (class-ns TBox
        #_volatile
        (§ field Object val)
        (§ field Thread thread)

        (§ constructor TBox(Thread t, Object val)
            (ß this.thread = t)
            (ß this.val = val)
            this
        )
    )

    (class-ns Unbound (§ extends AFn)
        (§ field Var v)

        (§ constructor Unbound(Var v)
            (ß this.v = v)
            this
        )

        (§ method String toString()
            (ß "Unbound: " + v)
        )

        (§ method Object throwArity(int n)
            (throw (ß new IllegalStateException("Attempting to call unbound fn: " + v)))
        )
    )

    (class-ns Frame
        (§ def Frame TOP = new Frame(PersistentHashMap.EMPTY, nil))
        ;; Var->TBox
        (§ field Associative bindings)
        ;; Var->val
        (§ field Frame prev)

        (§ constructor Frame(Associative bindings, Frame prev)
            (ß this.bindings = bindings)
            (ß this.prev = prev)
            this
        )

        #_protected
        (§ method Object clone()
            (ß new Frame(this.bindings, nil))
        )
    )

    (§ def ThreadLocal<Frame> dvals = new ThreadLocal<Frame>()
        (§ reify
            #_protected
            (§ method Frame initialValue()
                (ß Frame.TOP)
            )
        )
    )

    #_volatile
    (§ def int rev = 0)

    (§ def Keyword privateKey = Keyword.intern(nil, "private"))
    (§ def IPersistentMap privateMeta = new PersistentArrayMap(new Object[] (§ privateKey, Boolean.TRUE )))
    (§ def Keyword macroKey = Keyword.intern(nil, "macro"))
    (§ def Keyword nameKey = Keyword.intern(nil, "name"))
    (§ def Keyword nsKey = Keyword.intern(nil, "ns"))

    #_volatile
    (§ field Object root)

    #_volatile
    (§ field boolean dynamic = false)
    #_transient
    (§ field AtomicBoolean threadBound)
    (§ field Symbol sym)
    (§ field Namespace ns)

    (§ defn Object getThreadBindingFrame()
        (ß dvals.get())
    )

    (§ defn Object cloneThreadBindingFrame()
        (ß dvals.get().clone())
    )

    (§ defn void resetThreadBindingFrame(Object frame)
        (ß dvals.set((Frame) frame))
        nil
    )

    (§ method Var setDynamic()
        (ß this.dynamic = true)
        this
    )

    (§ method Var setDynamic(boolean b)
        (ß this.dynamic = b)
        this
    )

    (§ method boolean isDynamic()
        dynamic
    )

    (§ defn Var intern(Namespace ns, Symbol sym, Object root)
        (ß intern(ns, sym, root, true))
    )

    (§ defn Var intern(Namespace ns, Symbol sym, Object root, boolean replaceRoot)
        (let [#_"Var" dvout (ß ns.intern(sym))]
            (when (ß !dvout.hasRoot() || replaceRoot)
                (ß dvout.bindRoot(root))
            )
            dvout
        )
    )

    (§ method String toString()
        (when (ß ns != nil)
            (§ return (ß "#'" + ns.name + "/" + sym))
        )
        (ß "#<Var: " + ((sym != nil) ? sym.toString() :or "--unnamed--") + ">")
    )

    (§ defn Var find(Symbol nsQualifiedSym)
        (when (ß nsQualifiedSym.ns == nil)
            (throw (ß new IllegalArgumentException("Symbol must be namespace-qualified")))
        )
        (let [#_"Namespace" ns (ß Namespace.find(Symbol.intern(nsQualifiedSym.ns)))]
            (when (ß ns == nil)
                (throw (ß new IllegalArgumentException("No such namespace: " + nsQualifiedSym.ns)))
            )
            (ß ns.findInternedVar(Symbol.intern(nsQualifiedSym.name)))
        )
    )

    (§ defn Var intern(Symbol nsName, Symbol sym)
        (let [#_"Namespace" ns (ß Namespace.findOrCreate(nsName))]
            (ß intern(ns, sym))
        )
    )

    (§ defn Var internPrivate(String nsName, String sym)
        (let [#_"Namespace" ns (ß Namespace.findOrCreate(Symbol.intern(nsName)))]
            (let [#_"Var" ret (ß intern(ns, Symbol.intern(sym)))]
                (ß ret.setMeta(privateMeta))
                ret
            )
        )
    )

    (§ defn Var intern(Namespace ns, Symbol sym)
        (ß ns.intern(sym))
    )

    (§ defn Var create()
        (ß new Var(nil, nil))
    )

    (§ defn Var create(Object root)
        (ß new Var(nil, nil, root))
    )

    (§ constructor Var(Namespace ns, Symbol sym)
        (ß this.ns = ns)
        (ß this.sym = sym)
        (ß this.threadBound = new AtomicBoolean(false))
        (ß this.root = new Unbound(this))
        (ß setMeta(PersistentHashMap.EMPTY))
        this
    )

    (§ constructor Var(Namespace ns, Symbol sym, Object root)
        (§ this(ns, sym))
        (ß this.root = root)
        (ß ++rev)
        this
    )

    (§ method boolean isBound()
        (ß (hasRoot() || (threadBound.get() && dvals.get().bindings.containsKey(this))))
    )

    (§ method Object get()
        (when (ß !threadBound.get())
            (§ return root)
        )
        (ß deref())
    )

    (§ method Object deref()
        (let [#_"TBox" b (ß getThreadBinding())]
            (when (ß b != nil)
                (§ return (ß b.val))
            )
            root
        )
    )

    (§ method void setValidator(IFn vf)
        (when (ß hasRoot())
            (ß validate(vf, root))
        )
        (ß validator = vf)
        nil
    )

    (§ method Object alter(IFn fn, ISeq args)
        (ß set(fn.applyTo(RT.cons(deref(), args))))
        this
    )

    (§ method Object set(Object val)
        (ß validate(getValidator(), val))
        (let [#_"TBox" b (ß getThreadBinding())]
            (when (ß b != nil)
                (when (ß Thread.currentThread() != b.thread)
                    (throw (ß new IllegalStateException(String.format("Can't set!: %s from non-binding thread", sym))))
                )
                (§ return (ß (b.val = val)))
            )
            (throw (ß new IllegalStateException(String.format("Can't change/establish root binding of: %s with set", sym))))
        )
    )

    (§ method Object doSet(Object val)
        (ß set(val))
    )

    (§ method Object doReset(Object val)
        (ß bindRoot(val))
        val
    )

    (§ method void setMeta(IPersistentMap m)
        ;; ensure these basis keys
        (ß resetMeta(m.assoc(nameKey, sym).assoc(nsKey, ns)))
        nil
    )

    (§ method void setMacro()
        (ß alterMeta(assoc, RT.list(macroKey, RT.T)))
        nil
    )

    (§ method boolean isMacro()
        (ß RT.booleanCast(meta().valAt(macroKey)))
    )

    (§ method boolean isPublic()
        (ß !RT.booleanCast(meta().valAt(privateKey)))
    )

    (§ method Object getRawRoot()
        root
    )

    (§ method Object getTag()
        (ß meta().valAt(RT.TAG_KEY))
    )

    (§ method void setTag(Symbol tag)
        (ß alterMeta(assoc, RT.list(RT.TAG_KEY, tag)))
        nil
    )

    (§ method boolean hasRoot()
        (ß !(root instanceof Unbound))
    )

    ;; binding root always clears macro flag
    (§ method void bindRoot(Object root)
        (§ sync this
            (ß validate(getValidator(), root))
            (let [#_"Object" oldroot (ß this.root)]
                (ß this.root = root)
                (ß ++rev)
                (ß alterMeta(dissoc, RT.list(macroKey)))
                (ß notifyWatches(oldroot, this.root))
            )
        )
        nil
    )

    (§ method void swapRoot(Object root)
        (§ sync this
            (ß validate(getValidator(), root))
            (let [#_"Object" oldroot (ß this.root)]
                (ß this.root = root)
                (ß ++rev)
                (ß notifyWatches(oldroot, root))
            )
        )
        nil
    )

    (§ method void unbindRoot()
        (§ sync this
            (ß this.root = new Unbound(this))
            (ß ++rev)
        )
        nil
    )

    (§ method void commuteRoot(IFn fn)
        (§ sync this
            (let [#_"Object" newRoot (ß fn.invoke(root))]
                (ß validate(getValidator(), newRoot))
                (let [#_"Object" oldroot root]
                    (ß this.root = newRoot)
                    (ß ++rev)
                    (ß notifyWatches(oldroot, newRoot))
                )
            )
        )
        nil
    )

    (§ method Object alterRoot(IFn fn, ISeq args)
        (§ sync this
            (let [#_"Object" newRoot (ß fn.applyTo(RT.cons(root, args)))]
                (ß validate(getValidator(), newRoot))
                (let [#_"Object" oldroot root]
                    (ß this.root = newRoot)
                    (ß ++rev)
                    (ß notifyWatches(oldroot, newRoot))
                    newRoot
                )
            )
        )
    )

    (§ defn void pushThreadBindings(Associative bindings)
        (let [#_"Frame" f (ß dvals.get())]
            (let [#_"Associative" bmap (ß f.bindings)]
                (loop-when-recur [(ß ISeq bs = bindings.seq())] (ß bs != nil) [(ß bs = bs.next())]
                    (let [#_"IMapEntry" e (ß (IMapEntry) bs.first())]
                        (let [#_"Var" v (ß (Var) e.key())]
                            (when (ß !v.dynamic)
                                (throw (ß new IllegalStateException(String.format("Can't dynamically bind non-dynamic var: %s/%s", v.ns, v.sym))))
                            )
                            (ß v.validate(v.getValidator(), e.val()))
                            (ß v.threadBound.set(true))
                            (ß bmap = bmap.assoc(v, new TBox(Thread.currentThread(), e.val())))
                        )
                    )
                )
                (ß dvals.set(new Frame(bmap, f)))
                nil
            )
        )
    )

    (§ defn void popThreadBindings()
        (let [#_"Frame" f (ß dvals.get().prev)]
            (cond (ß f == nil)
                (do
                    (throw (ß new IllegalStateException("Pop without matching push")))
                )
                (ß f == Frame.TOP)
                (do
                    (ß dvals.remove())
                )
                :else
                (do
                    (ß dvals.set(f))
                )
            )
            nil
        )
    )

    (§ defn Associative getThreadBindings()
        (let [#_"Frame" f (ß dvals.get())]
            (let [#_"IPersistentMap" ret (ß PersistentHashMap.EMPTY)]
                (loop-when-recur [(ß ISeq bs = f.bindings.seq())] (ß bs != nil) [(ß bs = bs.next())]
                    (let [#_"IMapEntry" e (ß (IMapEntry) bs.first())]
                        (let [#_"Var" v (ß (Var) e.key())]
                            (let [#_"TBox" b (ß (TBox) e.val())]
                                (ß ret = ret.assoc(v, b.val))
                            )
                        )
                    )
                )
                ret
            )
        )
    )

    (§ method TBox getThreadBinding()
        (when (ß threadBound.get())
            (let [#_"IMapEntry" e (ß dvals.get().bindings.entryAt(this))]
                (when (ß e != nil)
                    (§ return (ß (TBox) e.val()))
                )
            )
        )
        nil
    )

    (§ method IFn fn()
        (ß (IFn) deref())
    )

    (§ method Object call()
        (ß invoke())
    )

    (§ method void run()
        (ß invoke())
        nil
    )

    (§ method Object invoke()
        (ß fn().invoke())
    )

    (§ method Object invoke(Object arg1)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil),
                Util.ret1(arg20, arg20 = nil)))
    )

    (§ method Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
        (ß fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil),
                Util.ret1(arg20, arg20 = nil),
                (Object[])Util.ret1(args, args = nil)))
    )

    (§ method Object applyTo(ISeq arglist)
        (ß fn().applyTo(arglist))
    )

    (§ def IFn assoc = new AFn()
        (§ reify
            (§ anno @Override)
            (§ method Object invoke(Object m, Object k, Object v)
                (ß RT.assoc(m, k, v))
            )
        )
    )

    (§ def IFn dissoc = new AFn()
        (§ reify
            (§ anno @Override)
            (§ method Object invoke(Object c, Object k)
                (ß RT.dissoc(c, k))
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    #_volatile
    (§ field Object val)

    (§ constructor Volatile(Object val)
        (ß this.val = val)
        this
    )

    (§ method Object deref()
        val
    )

    (§ method Object reset(Object newval)
        (ß this.val = newval)
    )
)
)

(java-ns cloiure.lang.WarnBoxedMath

(§ import java.lang.annotation.Retention)
(§ import java.lang.annotation.RetentionPolicy)
(§ import java.lang.annotation.ElementType)
(§ import java.lang.annotation.Target)

(§ anno @Retention(RetentionPolicy.RUNTIME))
(§ anno @Target(ElementType.METHOD))
(§ @interface WarnBoxedMath)
    (§ @abstract boolean value() default true)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

(class-ns main
    (§ def- Symbol CLOIURE_MAIN = Symbol.intern("cloiure.main"))
    (§ def- Var REQUIRE = RT.var("cloiure.core", "require"))
    (§ def- Var MAIN = RT.var("cloiure.main", "main"))

    (§ defn void main(String[] args)
        (ß REQUIRE.invoke(CLOIURE_MAIN))
        (ß MAIN.applyTo(RT.seq(args)))
        nil
    )
)
)
