(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(java-ns cloiure.lang.AFn

#_stateless
#_abstract
(class-ns AFn (§ implements IFn)
    #_method
    (§ defn #_"Object" call [#_"AFn" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"AFn" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this]
        (ß throwArity(0))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1]
        (ß throwArity(1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß throwArity(2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß throwArity(3))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß throwArity(4))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß throwArity(5))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß throwArity(6))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß throwArity(7))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß throwArity(8))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß throwArity(9))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß throwArity(10))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß throwArity(11))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß throwArity(12))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß throwArity(13))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß throwArity(14))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß throwArity(15))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß throwArity(16))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß throwArity(17))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß throwArity(18))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß throwArity(19))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß throwArity(20))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß throwArity(21))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"AFn" this, #_"ISeq" ___arglist]
        (ß AFn'applyToHelper(this, Util'ret1(___arglist, (§ ass ___arglist nil))))
    )

    (§ defn #_"Object" AFn'applyToHelper [#_"IFn" ___ifn, #_"ISeq" ___arglist]
        (§ switch (ß RT'boundedLength(___arglist, 20))
            (§ case 0)
            (do
                (§ ass ___arglist nil)
                (ß ___ifn.invoke())
            )
            (§ case 1)
            (do
                (ß ___ifn.invoke(Util'ret1(___arglist.first(), (§ ass ___arglist nil))))
            )
            (§ case 2)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 3)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 4)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 5)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 6)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 7)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 8)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 9)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 10)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 11)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 12)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 13)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 14)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 15)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 16)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 17)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 18)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 19)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 20)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ default )
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        RT'seqToArray(Util'ret1(___arglist.next(), (§ ass ___arglist nil)))))
            )
        )
    )

    #_method
    (§ defn #_"Object" throwArity [#_"AFn" this, #_"int" ___n]
        (let [#_"String" ___name (ß getClass().getSimpleName())]
            (throw (ß new ArityException(___n, Compiler'demunge(___name))))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    (§ init
        #_volatile
        (§ field #_"MethodImplCache" __methodImplCache nil)
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"AFunction" this]
        nil
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"AFunction" this, #_"IPersistentMap" ___meta]
        (§ reify RestFn()
            #_protected
            #_method
            (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___args]
                (ß (§ this AFunction).applyTo((ISeq) ___args))
            )

            #_method
            (§ defn #_"IPersistentMap" meta [#_"RestFn" this]
                ___meta
            )

            #_method
            (§ defn #_"IObj" withMeta [#_"RestFn" this, #_"IPersistentMap" ___meta]
                (ß (§ this AFunction).withMeta(___meta))
            )

            #_method
            (§ defn #_"int" getRequiredArity [#_"RestFn" this]
                0
            )
        )
    )

    #_method
    (§ defn #_"int" compare [#_"AFunction" this, #_"Object" ___o1, #_"Object" ___o2]
        (let [#_"Object" ___o (ß invoke(___o1, ___o2))]
            (when (ß ___o instanceof Boolean)
                (when (ß RT'booleanCast(___o))
                    (§ return -1)
                )
                (§ return (ß RT'booleanCast(invoke(___o2, ___o1)) ? 1 :or 0))
            )

            (let [#_"Number" ___n (ß (Number) ___o)]
                (ß ___n.intValue())
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns ActionQueue
    (§ def #_"ActionQueue" ActionQueue'EMPTY (ß new ActionQueue(PersistentQueue'EMPTY, nil)))

    (§ init
        (§ field #_"IPersistentStack" q nil)
        (§ field #_"Throwable" error nil) ;; non-null indicates fail state
    )

    (§ constructor #_"ActionQueue" ActionQueue [#_"IPersistentStack" ___q, #_"Throwable" ___error]
        (let [this (ß super())]
            (§ ass (ß this.q) ___q)
            (§ ass (ß this.error) ___error)
            this
        )
    )
)

(class-ns AgentAction (§ implements Runnable)
    (§ init
        (§ field #_"Agent" agent nil)
        (§ field #_"IFn" fn nil)
        (§ field #_"ISeq" args nil)
        (§ field #_"Executor" exec nil)
    )

    (§ constructor #_"AgentAction" AgentAction [#_"Agent" ___agent, #_"IFn" ___fn, #_"ISeq" ___args, #_"Executor" ___exec]
        (let [this (ß super())]
            (§ ass (ß this.agent) ___agent)
            (§ ass (ß this.args) ___args)
            (§ ass (ß this.fn) ___fn)
            (§ ass (ß this.exec) ___exec)
            this
        )
    )

    #_method
    (§ defn #_"void" execute [#_"AgentAction" this]
        (try
            (ß exec.execute(this))
            (catch Throwable ___error
                (when (ß agent.errorHandler != nil)
                    (try
                        (ß agent.errorHandler.invoke(agent, ___error))
                        (catch Throwable ___e
                            ;; ignore errorHandler errors
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"void" AgentAction'doRun [#_"AgentAction" ___action]
        (try
            (ß nested.set(PersistentVector'EMPTY))

            (let [#_"Throwable" ___error nil]
                (try
                    (let [#_"Object" ___oldval (ß ___action.agent.state)]
                        (let [#_"Object" ___newval (ß ___action.fn.applyTo(RT'cons(___action.agent.state, ___action.args)))]
                            (ß ___action.agent.setState(___newval))
                            (ß ___action.agent.notifyWatches(___oldval, ___newval))
                        )
                    )
                    (catch Throwable ___e
                        (§ ass ___error ___e)
                    )
                )

                (if (nil? ___error)
                    (do
                        (ß releasePendingSends())
                    )
                    (do
                        (ß nested.set(nil)) ;; allow errorHandler to send
                        (when (ß ___action.agent.errorHandler != nil)
                            (try
                                (ß ___action.agent.errorHandler.invoke(___action.agent, ___error))
                                (catch Throwable ___e
                                    ;; ignore errorHandler errors
                                )
                            )
                        )
                        (when (ß ___action.agent.errorMode == CONTINUE)
                            (§ ass ___error nil)
                        )
                    )
                )

                (let [#_"boolean" ___popped false]
                    (let [#_"ActionQueue" ___next nil]
                        (while (ß !___popped)
                            (let [#_"ActionQueue" ___prior (ß ___action.agent.aq.get())]
                                (§ ass ___next (ß new ActionQueue(___prior.q.pop(), ___error)))
                                (§ ass ___popped (ß ___action.agent.aq.compareAndSet(___prior, ___next)))
                            )
                        )

                        (when (ß ___error == nil && ___next.q.count() > 0)
                            (ß ((AgentAction) ___next.q.peek()).execute())
                        )
                    )
                )
            )
            (finally
                (ß nested.set(nil))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" run [#_"AgentAction" this]
        (ß AgentAction'doRun(this))
        nil
    )
)

(class-ns Agent (§ extends ARef)
    (§ def #_"Keyword" Agent'CONTINUE (ß Keyword'intern(nil, "continue")))
    (§ def #_"Keyword" Agent'FAIL (ß Keyword'intern(nil, "fail")))

    (§ def- #_"AtomicLong" Agent'sendThreadPoolCounter (AtomicLong. 0))
    (§ def- #_"AtomicLong" Agent'sendOffThreadPoolCounter (AtomicLong. 0))

    (§ defn- #_"ThreadFactory" Agent'createThreadFactory [#_"String" ___format, #_"AtomicLong" ___threadPoolCounter]
        (§ reify ThreadFactory()
            #_method
            (§ defn #_"Thread" newThread [#_"ThreadFactory" this, #_"Runnable" ___runnable]
                (let [#_"Thread" ___thread (Thread. ___runnable)]
                    (ß ___thread.setName(String/format(___format, ___threadPoolCounter.getAndIncrement())))
                    thread
                )
            )
        )
    )

    #_volatile
    (§ def #_"ExecutorService" Agent'pooledExecutor (ß Executors/newFixedThreadPool(2 + Runtime/getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter))))

    #_volatile
    (§ def #_"ExecutorService" Agent'soloExecutor (ß Executors/newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter))))

    (§ def #_"ThreadLocal<IPersistentVector>" Agent'nested (ß new ThreadLocal<IPersistentVector>()))

    (§ defn #_"void" Agent'shutdown []
        (ß soloExecutor.shutdown())
        (ß pooledExecutor.shutdown())
        nil
    )

    (§ init
        #_volatile
        (§ field #_"Object" state nil)
        (§ field #_"AtomicReference<ActionQueue>" aq (ß new AtomicReference<ActionQueue>(ActionQueue'EMPTY)))

        #_volatile
        (§ field #_"Keyword" errorMode CONTINUE)
        #_volatile
        (§ field #_"IFn" errorHandler nil)
    )

    (§ constructor #_"Agent" Agent [#_"Object" ___state]
        (let [this (ß this(___state, nil))]
            this
        )
    )

    (§ constructor #_"Agent" Agent [#_"Object" ___state, #_"IPersistentMap" ___meta]
        (let [this (ß super(___meta))]
            (ß setState(___state))
            this
        )
    )

    #_method
    (§ defn #_"boolean" setState [#_"Agent" this, #_"Object" ___newState]
        (ß validate(___newState))
        (let [#_"boolean" ___ret (ß (state != ___newState))]
            (§ ass state ___newState)
            ret
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Agent" this]
        state
    )

    #_method
    (§ defn #_"Throwable" getError [#_"Agent" this]
        (ß aq.get().error)
    )

    #_method
    (§ defn #_"void" setErrorMode [#_"Agent" this, #_"Keyword" ___k]
        (§ ass errorMode ___k)
        nil
    )

    #_method
    (§ defn #_"Keyword" getErrorMode [#_"Agent" this]
        errorMode
    )

    #_method
    (§ defn #_"void" setErrorHandler [#_"Agent" this, #_"IFn" ___f]
        (§ ass errorHandler ___f)
        nil
    )

    #_method
    (§ defn #_"IFn" getErrorHandler [#_"Agent" this]
        errorHandler
    )

    #_method
    (§ defn #_"Object" restart [#_"Agent" this, #_"Object" ___newState, #_"boolean" ___clearActions]
        (§ sync this
            (when (ß getError() == nil)
                (throw (ß Util'runtimeException("Agent does not need a restart")))
            )
            (ß validate(___newState))
            (§ ass state ___newState)

            (if ___clearActions
                (do
                    (ß aq.set(ActionQueue'EMPTY))
                )
                (do
                    (let [#_"boolean" ___restarted false]
                        (let [#_"ActionQueue" ___prior nil]
                            (while (ß !___restarted)
                                (§ ass ___prior (ß aq.get()))
                                (§ ass ___restarted (ß aq.compareAndSet(___prior, new ActionQueue(___prior.q, nil))))
                            )

                            (when (ß ___prior.q.count() > 0)
                                (ß ((AgentAction) ___prior.q.peek()).execute())
                            )
                        )
                    )
                )
            )

            ___newState
        )
    )

    #_method
    (§ defn #_"Object" dispatch [#_"Agent" this, #_"IFn" ___fn, #_"ISeq" ___args, #_"Executor" ___exec]
        (let [#_"Throwable" ___error (ß getError())]
            (when (some? ___error)
                (throw (ß Util'runtimeException("Agent is failed, needs restart", ___error)))
            )
            (let [#_"AgentAction" ___action (ß new AgentAction(this, ___fn, ___args, ___exec))]
                (ß dispatchAction(___action))

                this
            )
        )
    )

    (§ defn #_"void" Agent'dispatchAction [#_"AgentAction" ___action]
        (let [#_"LockingTransaction" ___trans (ß LockingTransaction'getRunning())]
            (cond (some? ___trans)
                (do
                    (ß ___trans.enqueue(___action))
                )
                (ß nested.get() != nil)
                (do
                    (ß nested.set(nested.get().cons(___action)))
                )
                :else
                (do
                    (ß ___action.agent.enqueue(___action))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" enqueue [#_"Agent" this, #_"AgentAction" ___action]
        (let [#_"boolean" ___queued false]
            (let [#_"ActionQueue" ___prior nil]
                (while (ß !___queued)
                    (§ ass ___prior (ß aq.get()))
                    (§ ass ___queued (ß aq.compareAndSet(___prior, new ActionQueue((IPersistentStack)___prior.q.cons(___action), ___prior.error))))
                )

                (when (ß ___prior.q.count() == 0 && ___prior.error == nil)
                    (ß ___action.execute())
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" getQueueCount [#_"Agent" this]
        (ß aq.get().q.count())
    )

    (§ defn #_"int" Agent'releasePendingSends []
        (let [#_"IPersistentVector" ___sends (ß nested.get())]
            (when (nil? ___sends)
                (§ return 0)
            )
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___sends.count()) [(§ ass ___i (ß ___i + 1))]
                (let [#_"AgentAction" ___a (ß (AgentAction) ___sends.valAt(___i))]
                    (ß ___a.agent.enqueue(___a))
                )
            )
            (ß nested.set(PersistentVector'EMPTY))
            (ß ___sends.count())
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_stateless
#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_method
    (§ defn #_"Object" nth [#_"AMapEntry" this, #_"int" ___i]
        (cond (ß ___i == 0)
            (do
                (ß key())
            )
            (ß ___i == 1)
            (do
                (ß val())
            )
            :else
            (do
                (throw (IndexOutOfBoundsException.))
            )
        )
    )

    #_method
    (§ defn- #_"IPersistentVector" asVector [#_"AMapEntry" this]
        (ß LazilyPersistentVector'createOwning(key(), val()))
    )

    #_method
    (§ defn #_"IPersistentVector" assocN [#_"AMapEntry" this, #_"int" ___i, #_"Object" ___val]
        (ß asVector().assocN(___i, ___val))
    )

    #_method
    (§ defn #_"int" count [#_"AMapEntry" this]
        2
    )

    #_method
    (§ defn #_"ISeq" seq [#_"AMapEntry" this]
        (ß asVector().seq())
    )

    #_method
    (§ defn #_"IPersistentVector" cons [#_"AMapEntry" this, #_"Object" ___o]
        (ß asVector().cons(___o))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"AMapEntry" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentStack" pop [#_"AMapEntry" this]
        (ß LazilyPersistentVector'createOwning(key()))
    )

    #_method
    (§ defn #_"Object" setValue [#_"AMapEntry" this, #_"Object" ___value]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

(class-ns KeySeq (§ extends ASeq)
    (§ defn #_"KeySeq" KeySeq'create [#_"ISeq" ___seq]
        (when (nil? ___seq)
            (§ return nil)
        )
        (ß new KeySeq(___seq, nil))
    )

    (§ defn #_"KeySeq" KeySeq'createFromMap [#_"IPersistentMap" ___map]
        (when (nil? ___map)
            (§ return nil)
        )
        (let [#_"ISeq" ___seq (ß ___map.seq())]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ß new KeySeq(___seq, ___map))
        )
    )

    (§ init
        (§ field #_"ISeq" seq nil)
        (§ field #_"Iterable" iterable nil)
    )

    (§ constructor- #_"KeySeq" KeySeq [#_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (ß super())]
            (§ ass (ß this.seq) ___seq)
            (§ ass (ß this.iterable) ___iterable)
            this
        )
    )

    (§ constructor- #_"KeySeq" KeySeq [#_"IPersistentMap" ___meta, #_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (ß super(___meta))]
            (§ ass (ß this.seq) ___seq)
            (§ ass (ß this.iterable) ___iterable)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"KeySeq" this]
        (ß ((Map$Entry) seq.first()).getKey())
    )

    #_method
    (§ defn #_"ISeq" next [#_"KeySeq" this]
        (ß create(seq.next()))
    )

    #_method
    (§ defn #_"KeySeq" withMeta [#_"KeySeq" this, #_"IPersistentMap" ___meta]
        (ß new KeySeq(___meta, seq, iterable))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"KeySeq" this]
        (when (nil? iterable)
            (§ return (ß super.iterator()))
        )

        (when (ß iterable instanceof IMapIterable)
            (§ return (ß ((IMapIterable)iterable).keyIterator()))
        )

        (let [#_"Iterator" ___mapIter (ß iterable.iterator())]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß ___mapIter.hasNext())
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (ß ((Map$Entry)___mapIter.next()).getKey())
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)

(class-ns ValSeq (§ extends ASeq)
    (§ defn #_"ValSeq" ValSeq'create [#_"ISeq" ___seq]
        (when (nil? ___seq)
            (§ return nil)
        )
        (ß new ValSeq(___seq, nil))
    )

    (§ defn #_"ValSeq" ValSeq'createFromMap [#_"IPersistentMap" ___map]
        (when (nil? ___map)
            (§ return nil)
        )
        (let [#_"ISeq" ___seq (ß ___map.seq())]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ß new ValSeq(___seq, ___map))
        )
    )

    (§ init
        (§ field #_"ISeq" seq nil)
        (§ field #_"Iterable" iterable nil)
    )

    (§ constructor- #_"ValSeq" ValSeq [#_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (ß super())]
            (§ ass (ß this.seq) ___seq)
            (§ ass (ß this.iterable) ___iterable)
            this
        )
    )

    (§ constructor- #_"ValSeq" ValSeq [#_"IPersistentMap" ___meta, #_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (ß super(___meta))]
            (§ ass (ß this.seq) ___seq)
            (§ ass (ß this.iterable) ___iterable)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ValSeq" this]
        (ß ((Map$Entry) seq.first()).getValue())
    )

    #_method
    (§ defn #_"ISeq" next [#_"ValSeq" this]
        (ß create(seq.next()))
    )

    #_method
    (§ defn #_"ValSeq" withMeta [#_"ValSeq" this, #_"IPersistentMap" ___meta]
        (ß new ValSeq(___meta, seq, iterable))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"ValSeq" this]
        (when (nil? iterable)
            (§ return (ß super.iterator()))
        )

        (when (ß iterable instanceof IMapIterable)
            (§ return (ß ((IMapIterable)iterable).valIterator()))
        )

        (let [#_"Iterator" ___mapIter (ß iterable.iterator())]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß ___mapIter.hasNext())
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (ß ((Map$Entry)___mapIter.next()).getValue())
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (§ init
        (§ field #_"int" _hash 0)
        (§ field #_"int" _hasheq 0)
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentMap" this]
        (ß RT'printString(this))
    )

    #_method
    (§ defn #_"IPersistentCollection" cons [#_"APersistentMap" this, #_"Object" ___o]
        (cond (ß ___o instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (§ return (ß assoc(___e.getKey(), ___e.getValue())))
                )
            )
            (ß ___o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
                    (when (ß ___v.count() != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß assoc(___v.nth(0), ___v.nth(1))))
                )
            )
        )

        (let [#_"IPersistentMap" ___ret this]
            (loop-when-recur [(§ var #_"ISeq" ___es (ß RT'seq(___o)))] (some? ___es) [(§ ass ___es (ß ___es.next()))]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___es.first())]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentMap" this, #_"Object" ___obj]
        (ß mapEquals(this, ___obj))
    )

    (§ defn #_"boolean" APersistentMap'mapEquals [#_"IPersistentMap" ___m1, #_"Object" ___obj]
        (when (ß ___m1 == ___obj)
            (§ return true)
        )
        (when (ß !(___obj instanceof Map))
            (§ return false)
        )
        (let [#_"Map" ___m (ß (Map) ___obj)]
            (when (ß ___m.size() != ___m1.count())
                (§ return false)
            )

            (loop-when-recur [(§ var #_"ISeq" ___s (ß ___m1.seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___s.first())]
                    (let [#_"boolean" ___found (ß ___m.containsKey(___e.getKey()))]
                        (when (ß !___found || !Util'equals(___e.getValue(), ___m.get(___e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentMap" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Map))
            (§ return false)
        )
        (when (ß ___obj instanceof IPersistentMap && !(___obj instanceof MapEquivalence))
            (§ return false)
        )

        (let [#_"Map" ___m (ß (Map) ___obj)]
            (when (ß ___m.size() != size())
                (§ return false)
            )

            (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___s.first())]
                    (let [#_"boolean" ___found (ß ___m.containsKey(___e.getKey()))]
                        (when (ß !___found || !Util'equiv(___e.getValue(), ___m.get(___e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentMap" this]
        (let [#_"int" ___cached (ß this._hash)]
            (when (ß ___cached == 0)
                (§ ass (ß this._hash) (§ ass ___cached (ß mapHash(this))))
            )
            cached
        )
    )

    (§ defn #_"int" APersistentMap'mapHash [#_"IPersistentMap" ___m]
        (let [#_"int" ___hash 0]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß ___m.seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___s.first())]
                    (§ ass ___hash (ß ___hash + (((___e.getKey() == nil) ? 0 :or ___e.getKey().hashCode()) :xor ((___e.getValue() == nil) ? 0 :or ___e.getValue().hashCode()))))
                )
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentMap" this]
        (let [#_"int" ___cached (ß this._hasheq)]
            (when (ß ___cached == 0)
                (§ ass (ß this._hasheq) (§ ass ___cached (ß Murmur3'hashUnordered(this))))
            )
            cached
        )
    )

    (§ defn #_"int" APersistentMap'mapHasheq [#_"IPersistentMap" ___m]
        (ß Murmur3'hashUnordered(___m))
    )

    (§ def #_"IFn" APersistentMap'MAKE_ENTRY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                (ß MapEntry'create(___key, ___val))
            )
        )
    )

    (§ def #_"IFn" APersistentMap'MAKE_KEY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                key
            )
        )
    )

    (§ def #_"IFn" APersistentMap'MAKE_VAL
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                val
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentMap" this, #_"Object" ___arg1]
        (ß valAt(___arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentMap" this, #_"Object" ___arg1, #_"Object" ___notFound]
        (ß valAt(___arg1, ___notFound))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentMap" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsValue [#_"APersistentMap" this, #_"Object" ___value]
        (ß values().contains(___value))
    )

    #_method
    (§ defn #_"Set" entrySet [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractSet" this]
                (ß (§ this APersistentMap).iterator())
            )

            #_method
            (§ defn #_"int" size [#_"AbstractSet" this]
                (ß count())
            )

            #_method
            (§ defn #_"int" hashCode [#_"AbstractSet" this]
                (ß (§ this APersistentMap).hashCode())
            )

            #_method
            (§ defn #_"boolean" contains [#_"AbstractSet" this, #_"Object" ___o]
                (when (ß ___o instanceof Entry)
                    (let [#_"Entry" ___e (ß (Entry) ___o)]
                        (let [#_"Entry" ___found (ß entryAt(___e.getKey()))]
                            (when (ß ___found != nil && Util'equals(___found.getValue(), ___e.getValue()))
                                (§ return true)
                            )
                        )
                    )
                )
                false
            )
        )
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentMap" this, #_"Object" ___key]
        (ß valAt(___key))
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentMap" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"Set" keySet [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractSet" this]
                (let [#_"Iterator" ___mi (ß (§ this APersistentMap).iterator())]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (ß ___mi.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [#_"Entry" ___e (ß (Entry) ___mi.next())]
                                (ß ___e.getKey())
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" size [#_"AbstractSet" this]
                (ß count())
            )

            #_method
            (§ defn #_"boolean" contains [#_"AbstractSet" this, #_"Object" ___o]
                (ß (§ this APersistentMap).containsKey(___o))
            )
        )
    )

    #_method
    (§ defn #_"Object" put [#_"APersistentMap" this, #_"Object" ___key, #_"Object" ___value]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" putAll [#_"APersistentMap" this, #_"Map" ___t]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"APersistentMap" this, #_"Object" ___key]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentMap" this]
        (ß count())
    )

    #_method
    (§ defn #_"Collection" values [#_"APersistentMap" this]
        (§ reify AbstractCollection()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractCollection" this]
                (let [#_"Iterator" ___mi (ß (§ this APersistentMap).iterator())]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (ß ___mi.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [#_"Entry" ___e (ß (Entry) ___mi.next())]
                                (ß ___e.getValue())
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" size [#_"AbstractCollection" this]
                (ß count())
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (§ init
        (§ field #_"int" _hash 0)
        (§ field #_"int" _hasheq 0)
        (§ field #_"IPersistentMap" impl nil)
    )

    #_protected
    (§ constructor #_"APersistentSet" APersistentSet [#_"IPersistentMap" ___impl]
        (let [this (ß super())]
            (§ ass (ß this.impl) ___impl)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentSet" this]
        (ß RT'printString(this))
    )

    #_method
    (§ defn #_"boolean" contains [#_"APersistentSet" this, #_"Object" ___key]
        (ß impl.containsKey(___key))
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentSet" this, #_"Object" ___key]
        (ß impl.valAt(___key))
    )

    #_method
    (§ defn #_"int" count [#_"APersistentSet" this]
        (ß impl.count())
    )

    #_method
    (§ defn #_"ISeq" seq [#_"APersistentSet" this]
        (ß RT'keys(impl))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentSet" this, #_"Object" ___arg1]
        (ß get(___arg1))
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentSet" this, #_"Object" ___obj]
        (ß APersistentSet'setEquals(this, ___obj))
    )

    (§ defn #_"boolean" APersistentSet'setEquals [#_"IPersistentSet" ___s1, #_"Object" ___obj]
        (when (ß ___s1 == ___obj)
            (§ return true)
        )
        (when (ß !(___obj instanceof Set))
            (§ return false)
        )
        (let [#_"Set" ___m (ß (Set) ___obj)]
            (when (ß ___m.size() != ___s1.count())
                (§ return false)
            )

            (doseq [#_"Object" ___aM ___m]
                (when (ß !___s1.contains(___aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentSet" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Set))
            (§ return false)
        )

        (let [#_"Set" ___m (ß (Set) ___obj)]
            (when (ß ___m.size() != size())
                (§ return false)
            )

            (doseq [#_"Object" ___aM ___m]
                (when (ß !contains(___aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentSet" this]
        (let [#_"int" ___hash (ß this._hash)]
            (when (ß ___hash == 0)
                (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (let [#_"Object" ___e (ß ___s.first())]
                        (§ ass ___hash (ß ___hash + Util'hash(___e)))
                    )
                )
                (§ ass (ß this._hash) ___hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentSet" this]
        (let [#_"int" ___cached (ß this._hasheq)]
            (when (ß ___cached == 0)
                (§ ass (ß this._hasheq) (§ ass ___cached (ß Murmur3'hashUnordered(this))))
            )
            cached
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentSet" this]
        (ß RT'seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"APersistentSet" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"APersistentSet" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentSet" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"APersistentSet" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß !contains(___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentSet" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentSet" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentSet" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"APersistentSet" this]
        (if (ß impl instanceof IMapIterable)
            (do
                (ß ((IMapIterable)impl).keyIterator())
            )
            (do
                (§ reify Iterator()
                    (§ init
                        (§ field- #_"Iterator" iter (ß impl.iterator()))
                    )

                    #_method
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        (ß iter.hasNext())
                    )

                    #_method
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (ß ((IMapEntry)iter.next()).key())
                    )

                    #_method
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

(class-ns VSeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        ;; todo - something more efficient
        (§ field #_"IPersistentVector" v nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"VSeq" VSeq [#_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.v) ___v)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    (§ constructor #_"VSeq" VSeq [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.v) ___v)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"VSeq" this]
        (ß v.nth(i))
    )

    #_method
    (§ defn #_"ISeq" next [#_"VSeq" this]
        (when (ß i + 1 < v.count())
            (§ return (ß new VSeq(v, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" index [#_"VSeq" this]
        i
    )

    #_method
    (§ defn #_"int" count [#_"VSeq" this]
        (ß v.count() - i)
    )

    #_method
    (§ defn #_"VSeq" withMeta [#_"VSeq" this, #_"IPersistentMap" ___meta]
        (ß new VSeq(___meta, v, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"VSeq" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß v.nth(i))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < v.count()) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, v.nth(___x))))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"VSeq" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, v.nth(i)))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < v.count()) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, v.nth(___x))))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )
)

(class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
    (§ init
        (§ field #_"IPersistentVector" v nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"RSeq" RSeq [#_"IPersistentVector" ___vector, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.v) ___vector)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    (§ constructor #_"RSeq" RSeq [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.v) ___v)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"RSeq" this]
        (ß v.nth(i))
    )

    #_method
    (§ defn #_"ISeq" next [#_"RSeq" this]
        (when (ß i > 0)
            (§ return (ß new RSeq(v, i - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" index [#_"RSeq" this]
        i
    )

    #_method
    (§ defn #_"int" count [#_"RSeq" this]
        (ß i + 1)
    )

    #_method
    (§ defn #_"RSeq" withMeta [#_"RSeq" this, #_"IPersistentMap" ___meta]
        (ß new RSeq(___meta, v, i))
    )
)

(class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
    (§ init
        (§ field #_"IPersistentVector" v nil)
        (§ field #_"int" start 0)
        (§ field #_"int" end 0)
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"SubVector" SubVector [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___start, #_"int" ___end]
        (let [this (ß super())]
            (§ ass (ß this._meta) ___meta)

            (when (ß ___v instanceof SubVector)
                (let [#_"SubVector" ___sv (ß (SubVector) ___v)]
                    (§ ass ___start (ß ___start + ___sv.start))
                    (§ ass ___end (ß ___end + ___sv.start))
                    (§ ass ___v (ß ___sv.v))
                )
            )
            (§ ass (ß this.v) ___v)
            (§ ass (ß this.start) ___start)
            (§ ass (ß this.end) ___end)
            this
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"SubVector" this]
        (when (ß v instanceof APersistentVector)
            (§ return (ß ((APersistentVector)v).rangedIterator(start, end)))
        )
        (ß super.iterator())
    )

    #_method
    (§ defn #_"Object" nth [#_"SubVector" this, #_"int" ___i]
        (when (ß (start + ___i >= end) || (___i < 0))
            (throw (IndexOutOfBoundsException.))
        )
        (ß v.nth(start + ___i))
    )

    #_method
    (§ defn #_"IPersistentVector" assocN [#_"SubVector" this, #_"int" ___i, #_"Object" ___val]
        (cond (ß start + ___i > end)
            (do
                (throw (IndexOutOfBoundsException.))
            )
            (ß start + ___i == end)
            (do
                (§ return (ß cons(___val)))
            )
        )
        (ß new SubVector(_meta, v.assocN(start + ___i, ___val), start, end))
    )

    #_method
    (§ defn #_"int" count [#_"SubVector" this]
        (ß end - start)
    )

    #_method
    (§ defn #_"IPersistentVector" cons [#_"SubVector" this, #_"Object" ___o]
        (ß new SubVector(_meta, v.assocN(end, ___o), start, end + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"SubVector" this]
        (ß PersistentVector'EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"IPersistentStack" pop [#_"SubVector" this]
        (when (ß end - 1 == start)
            (§ return (ß PersistentVector'EMPTY))
        )
        (ß new SubVector(_meta, v, start, end - 1))
    )

    #_method
    (§ defn #_"SubVector" withMeta [#_"SubVector" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == _meta)
            (§ return this)
        )
        (ß new SubVector(___meta, v, start, end))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"SubVector" this]
        _meta
    )
)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (§ init
        (§ field #_"int" _hash 0)
        (§ field #_"int" _hasheq 0)
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentVector" this]
        (ß RT'printString(this))
    )

    #_method
    (§ defn #_"ISeq" seq [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (ß new VSeq(this, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (ß new RSeq(this, count() - 1)))
        )
        nil
    )

    (§ defn #_"boolean" APersistentVector'doEquals [#_"IPersistentVector" ___v, #_"Object" ___obj]
        (cond (ß ___obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___ov (ß (IPersistentVector) ___obj)]
                    (when (ß ___ov.count() != ___v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___v.count()) [(§ ass ___i (ß ___i + 1))]
                        (when (ß !Util'equals(___v.nth(___i), ___ov.nth(___i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß ___obj instanceof List)
            (do
                (let [#_"Collection" ___ma (ß (Collection) ___obj)]
                    (when (ß ___ma.size() != ___v.count() || ___ma.hashCode() != ___v.hashCode())
                        (§ return false)
                    )
                    (loop-when-recur [(§ var #_"Iterator" ___i1 (ß ((List) ___v).iterator()), ___i2 (ß ___ma.iterator()))] (ß ___i1.hasNext()) [(ß )]
                        (when (ß !Util'equals(___i1.next(), ___i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(___obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ___ms (ß RT'seq(___obj))]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___v.count()) [(§ ass ___i (ß ___i + 1), ___ms (ß ___ms.next()))]
                        (when (ß ___ms == nil || !Util'equals(___v.nth(___i), ___ms.first()))
                            (§ return false)
                        )
                    )
                    (when (some? ___ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    (§ defn #_"boolean" APersistentVector'doEquiv [#_"IPersistentVector" ___v, #_"Object" ___obj]
        (cond (ß ___obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___ov (ß (IPersistentVector) ___obj)]
                    (when (ß ___ov.count() != ___v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___v.count()) [(§ ass ___i (ß ___i + 1))]
                        (when (ß !Util'equiv(___v.nth(___i), ___ov.nth(___i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß ___obj instanceof List)
            (do
                (let [#_"Collection" ___ma (ß (Collection) ___obj)]
                    (when (ß ___ma.size() != ___v.count())
                        (§ return false)
                    )
                    (loop-when-recur [(§ var #_"Iterator" ___i1 (ß ((List) ___v).iterator()), ___i2 (ß ___ma.iterator()))] (ß ___i1.hasNext()) [(ß )]
                        (when (ß !Util'equiv(___i1.next(), ___i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(___obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ___ms (ß RT'seq(___obj))]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___v.count()) [(§ ass ___i (ß ___i + 1), ___ms (ß ___ms.next()))]
                        (when (ß ___ms == nil || !Util'equiv(___v.nth(___i), ___ms.first()))
                            (§ return false)
                        )
                    )
                    (when (some? ___ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentVector" this, #_"Object" ___obj]
        (when (ß ___obj == this)
            (§ return true)
        )
        (ß doEquals(this, ___obj))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentVector" this, #_"Object" ___obj]
        (when (ß ___obj == this)
            (§ return true)
        )
        (ß APersistentVector'doEquiv(this, ___obj))
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentVector" this]
        (let [#_"int" ___hash (ß this._hash)]
            (when (ß ___hash == 0)
                (§ ass ___hash 1)
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < count()) [(§ ass ___i (ß ___i + 1))]
                    (let [#_"Object" ___obj (ß nth(___i))]
                        (§ ass ___hash (ß 31 * ___hash + ((___obj == nil) ? 0 :or ___obj.hashCode())))
                    )
                )
                (§ ass (ß this._hash) ___hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentVector" this]
        (let [#_"int" ___hash (ß this._hasheq)]
            (when (ß ___hash == 0)
                (§ let [#_"int" ___n]
                    (§ ass ___hash 1)

                    (loop-when-recur [(§ ass ___n 0)] (ß ___n < count()) [(§ ass ___n (ß ___n + 1))]
                        (§ ass ___hash (ß 31 * ___hash + Util'hasheq(nth(___n))))
                    )

                    (§ ass (ß this._hasheq) (§ ass ___hash (ß Murmur3'mixCollHash(___hash, ___n))))
                )
            )
            hash
        )
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentVector" this, #_"int" ___index]
        (ß nth(___index))
    )

    #_method
    (§ defn #_"Object" nth [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < count())
            (§ return (ß nth(___i)))
        )
        notFound
    )

    #_method
    (§ defn #_"Object" remove [#_"APersistentVector" this, #_"int" ___i]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < count()) [(§ ass ___i (ß ___i + 1))]
            (when (ß Util'equiv(nth(___i), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [(§ var #_"int" ___i (ß count() - 1))] (ß ___i >= 0) [(§ ass ___i (ß ___i - 1))]
            (when (ß Util'equiv(nth(___i), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"APersistentVector" this]
        (ß listIterator(0))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"APersistentVector" this, #_"int" ___index]
        (§ reify ListIterator()
            (let [#_"int" ___nexti ___index]
                #_method
                (§ defn #_"boolean" hasNext [#_"ListIterator" this]
                    (ß (___nexti < count()))
                )

                #_method
                (§ defn #_"Object" next [#_"ListIterator" this]
                    (if (ß ___nexti < count())
                        (let [_ (ß nth(___nexti))]
                            (§ ass ___nexti (ß ___nexti + 1))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"boolean" hasPrevious [#_"ListIterator" this]
                    (ß (___nexti > 0))
                )

                #_method
                (§ defn #_"Object" previous [#_"ListIterator" this]
                    (if (ß ___nexti > 0)
                        (do
                            (§ ass ___nexti (ß ___nexti - 1))
                            (ß nth(___nexti))
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"int" nextIndex [#_"ListIterator" this]
                    ___nexti
                )

                #_method
                (§ defn #_"int" previousIndex [#_"ListIterator" this]
                    (ß ___nexti - 1)
                )

                #_method
                (§ defn #_"void" remove [#_"ListIterator" this]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" set [#_"ListIterator" this, #_"Object" ___o]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" add [#_"ListIterator" this, #_"Object" ___o]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" rangedIterator [#_"APersistentVector" this, #_"int" ___start, #_"int" ___end]
        (§ reify Iterator()
            (let [#_"int" ___i ___start]
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß (___i < ___end))
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (if (ß ___i < ___end)
                        (let [_ (ß nth(___i))]
                            (§ ass ___i (ß ___i + 1))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"List" subList [#_"APersistentVector" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (List) RT'subvec(this, ___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" add [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentVector" this, #_"int" ___i, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentVector" this, #_"Object" ___arg1]
        (when (ß Util'isInteger(___arg1))
            (§ return (ß nth(((Number) ___arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"APersistentVector" this]
        ;; todo - something more efficient
        (§ reify Iterator()
            (let [#_"int" ___i 0]
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß (___i < count()))
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (if (ß ___i < count())
                        (let [_ (ß nth(___i))]
                            (§ ass ___i (ß ___i + 1))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" peek [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (ß nth(count() - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"APersistentVector" this, #_"Object" ___key]
        (when (ß !(Util'isInteger(___key)))
            (§ return false)
        )
        (let [#_"int" ___i (ß ((Number) ___key).intValue())]
            (ß (___i >= 0 && ___i < count()))
        )
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"APersistentVector" this, #_"Object" ___key]
        (when (ß Util'isInteger(___key))
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (when (ß ___i >= 0 && ___i < count())
                    (§ return (ß (IMapEntry) MapEntry'create(___key, nth(___i))))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentVector" assoc [#_"APersistentVector" this, #_"Object" ___key, #_"Object" ___val]
        (when (ß Util'isInteger(___key))
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (§ return (ß assocN(___i, ___val)))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" valAt [#_"APersistentVector" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (ß Util'isInteger(___key))
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (when (ß ___i >= 0 && ___i < count())
                    (§ return (ß nth(___i)))
                )
            )
        )
        notFound
    )

    #_method
    (§ defn #_"Object" valAt [#_"APersistentVector" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentVector" this]
        (let [#_"Object[]" ___ret (ß new Object[count()])]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < count()) [(§ ass ___i (ß ___i + 1))]
                (§ ass (ß ___ret[___i]) (ß nth(___i)))
            )
            ret
        )
    )

    #_method
    (§ defn #_"boolean" add [#_"APersistentVector" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"APersistentVector" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentVector" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"APersistentVector" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß !contains(___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentVector" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentVector" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentVector" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"boolean" contains [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
            (when (ß Util'equiv(___s.first(), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"int" length [#_"APersistentVector" this]
        (ß count())
    )

    #_method
    (§ defn #_"int" compareTo [#_"APersistentVector" this, #_"Object" ___o]
        (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
            (cond (ß count() < ___v.count())
                (do
                    (§ return -1)
                )
                (ß count() > ___v.count())
                (do
                    (§ return 1)
                )
            )
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < count()) [(§ ass ___i (ß ___i + 1))]
                (let [#_"int" ___c (ß Util'compare(nth(___i), ___v.nth(___i)))]
                    (when (ß ___c != 0)
                        (§ return ___c)
                    )
                )
            )
            0
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    (§ init
        #_protected
        #_volatile
        (§ field #_"IFn" validator nil)
        #_volatile
        (§ field- #_"IPersistentMap" watches (ß PersistentHashMap'EMPTY))
    )

    (§ constructor #_"ARef" ARef []
        (let [this (ß super())]
            this
        )
    )

    (§ constructor #_"ARef" ARef [#_"IPersistentMap" ___meta]
        (let [this (ß super(___meta))]
            this
        )
    )

    #_method
    (§ defn #_"void" validate [#_"ARef" this, #_"IFn" ___vf, #_"Object" ___val]
        (try
            (when (ß ___vf != nil && !RT'booleanCast(___vf.invoke(___val)))
                (throw (IllegalStateException. "Invalid reference state"))
            )
            (catch RuntimeException ___re
                (throw ___re)
            )
            (catch Exception ___e
                (throw (ß new IllegalStateException("Invalid reference state", ___e)))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" validate [#_"ARef" this, #_"Object" ___val]
        (ß validate(validator, ___val))
        nil
    )

    #_method
    (§ defn #_"void" setValidator [#_"ARef" this, #_"IFn" ___vf]
        (ß validate(___vf, deref()))
        (§ ass validator ___vf)
        nil
    )

    #_method
    (§ defn #_"IFn" getValidator [#_"ARef" this]
        validator
    )

    #_method
    (§ defn #_"IPersistentMap" getWatches [#_"ARef" this]
        watches
    )

    #_method
    (§ defn #_"IRef" addWatch [#_"ARef" this, #_"Object" ___key, #_"IFn" ___callback]
        (§ sync this
            (§ ass watches (ß watches.assoc(___key, ___callback)))
            this
        )
    )

    #_method
    (§ defn #_"IRef" removeWatch [#_"ARef" this, #_"Object" ___key]
        (§ sync this
            (§ ass watches (ß watches.without(___key)))
            this
        )
    )

    #_method
    (§ defn #_"void" notifyWatches [#_"ARef" this, #_"Object" ___oldval, #_"Object" ___newval]
        (let [#_"IPersistentMap" ___ws watches]
            (when (ß ___ws.count() > 0)
                (loop-when-recur [(§ var #_"ISeq" ___s (ß ___ws.seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (let [#_"Map$Entry" ___e (ß (Map$Entry) ___s.first())]
                        (let [#_"IFn" ___fn (ß (IFn) ___e.getValue())]
                            (when (some? ___fn)
                                (ß ___fn.invoke(___e.getKey(), this, ___oldval, ___newval))
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (§ init
        (§ field- #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"AReference" AReference []
        (let [this (ß this(nil))]
            this
        )
    )

    (§ constructor #_"AReference" AReference [#_"IPersistentMap" ___meta]
        (let [this (ß super())]
            (§ ass _meta ___meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"AReference" this]
        (§ sync this
            _meta
        )
    )

    #_method
    (§ defn #_"IPersistentMap" alterMeta [#_"AReference" this, #_"IFn" ___alter, #_"ISeq" ___args]
        (§ sync this
            (§ ass _meta (ß (IPersistentMap) ___alter.applyTo(new Cons(_meta, ___args))))
            _meta
        )
    )

    #_method
    (§ defn #_"IPersistentMap" resetMeta [#_"AReference" this, #_"IPersistentMap" ___m]
        (§ sync this
            (§ ass _meta ___m)
            ___m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (§ init
        (§ field #_"int" actual 0)
        (§ field #_"String" name nil)
    )

    (§ constructor #_"ArityException" ArityException [#_"int" ___actual, #_"String" ___name]
        (let [this (ß this(___actual, ___name, nil))]
            this
        )
    )

    (§ constructor #_"ArityException" ArityException [#_"int" ___actual, #_"String" ___name, #_"Throwable" ___cause]
        (let [this (ß super("Wrong number of args (" + ___actual + ") passed to: " + ___name, ___cause))]
            (§ ass (ß this.actual) ___actual)
            (§ ass (ß this.name) ___name)
            this
        )
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"int" off 0)
        (§ field #_"int" end 0)
    )

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" ___array]
        (let [this (ß this(___array, 0, ___array.length))]
            this
        )
    )

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" ___array, #_"int" ___off]
        (let [this (ß this(___array, ___off, ___array.length))]
            this
        )
    )

    (§ constructor #_"ArrayChunk" ArrayChunk [#_"Object[]" ___array, #_"int" ___off, #_"int" ___end]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.off) ___off)
            (§ ass (ß this.end) ___end)
            this
        )
    )

    #_method
    (§ defn #_"Object" nth [#_"ArrayChunk" this, #_"int" ___i]
        (ß array[off + ___i])
    )

    #_method
    (§ defn #_"Object" nth [#_"ArrayChunk" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < count())
            (§ return (ß nth(___i)))
        )
        notFound
    )

    #_method
    (§ defn #_"int" count [#_"ArrayChunk" this]
        (ß end - off)
    )

    #_method
    (§ defn #_"IChunk" dropFirst [#_"ArrayChunk" this]
        (when (ß off == end)
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß new ArrayChunk(array, off + 1, end))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArrayChunk" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, array[off]))]
            (when (ß RT'isReduced(___ret))
                (§ return ___ret)
            )
            (loop-when-recur [(§ var #_"int" ___x (ß off + 1))] (ß ___x < end) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                (when (ß RT'isReduced(___ret))
                    (§ return ___ret)
                )
            )
            ret
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(class-ns ArrayIter_int (§ implements Iterator<Long>)
    (§ init
        (§ field #_"int[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter_int" ArrayIter_int [#_"int[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_int" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Long" next [#_"ArrayIter_int" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß Long/valueOf(array[i]))]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_int" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)

(class-ns ArrayIter_float (§ implements Iterator<Double>)
    (§ init
        (§ field #_"float[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter_float" ArrayIter_float [#_"float[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_float" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Double" next [#_"ArrayIter_float" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß Double/valueOf(array[i]))]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_float" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)

(class-ns ArrayIter_double (§ implements Iterator<Double>)
    (§ init
        (§ field #_"double[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter_double" ArrayIter_double [#_"double[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_double" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Double" next [#_"ArrayIter_double" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß array[i])]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_double" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)

(class-ns ArrayIter_long (§ implements Iterator<Long>)
    (§ init
        (§ field #_"long[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter_long" ArrayIter_long [#_"long[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_long" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Long" next [#_"ArrayIter_long" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß Long/valueOf(array[i]))]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_long" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)

(class-ns ArrayIter_byte (§ implements Iterator<Byte>)
    (§ init
        (§ field #_"byte[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter_byte" ArrayIter_byte [#_"byte[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_byte" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Byte" next [#_"ArrayIter_byte" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß array[i])]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_byte" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)

(class-ns ArrayIter_char (§ implements Iterator<Character>)
    (§ init
        (§ field #_"char[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter_char" ArrayIter_char [#_"char[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_char" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Character" next [#_"ArrayIter_char" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß array[i])]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_char" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)

(class-ns ArrayIter_short (§ implements Iterator<Long>)
    (§ init
        (§ field #_"short[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter_short" ArrayIter_short [#_"short[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_short" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Long" next [#_"ArrayIter_short" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß Long/valueOf(array[i]))]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_short" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)

(class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
    (§ init
        (§ field #_"boolean[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter_boolean" ArrayIter_boolean [#_"boolean[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_boolean" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Boolean" next [#_"ArrayIter_boolean" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß Boolean/valueOf(array[i]))]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_boolean" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)

(class-ns ArrayIter (§ implements Iterator)
    (§ def #_"Iterator" ArrayIter'EMPTY_ITERATOR
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (ß new java.util.NoSuchElementException()))
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (ß new UnsupportedOperationException("remove() not supported")))
            )
        )
    )

    (§ defn #_"Iterator" ArrayIter'create []
        EMPTY_ITERATOR
    )

    (§ defn #_"Iterator" ArrayIter'create [#_"Object..." ___array]
        (when (ß ___array == nil || ___array.length == 0)
            (§ return EMPTY_ITERATOR)
        )
        (ß new ArrayIter(___array, 0))
    )

    (§ defn #_"Iterator" ArrayIter'createFromObject [#_"Object" ___array]
        (when (ß ___array == nil || Array/getLength(___array) == 0)
            (§ return EMPTY_ITERATOR)
        )
        (let [#_"Class" ___aclass (ß ___array.getClass())]
            (when (ß ___aclass == (§ class int[]))
                (§ return (ß new ArrayIter_int((int[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class float[]))
                (§ return (ß new ArrayIter_float((float[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class double[]))
                (§ return (ß new ArrayIter_double((double[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class long[]))
                (§ return (ß new ArrayIter_long((long[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class byte[]))
                (§ return (ß new ArrayIter_byte((byte[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class char[]))
                (§ return (ß new ArrayIter_char((char[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class short[]))
                (§ return (ß new ArrayIter_short((short[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class boolean[]))
                (§ return (ß new ArrayIter_boolean((boolean[]) ___array, 0)))
            )
            (ß new ArrayIter(___array, 0))
        )
    )

    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArrayIter" ArrayIter [#_"Object" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.array) (ß (Object[]) ___array))
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter" this]
        (ß (array != nil && i < array.length))
    )

    #_method
    (§ defn #_"Object" next [#_"ArrayIter" this]
        (when (ß array != nil && i < array.length)
            (let [_ (ß array[i])]
                (§ ass i (ß i + 1))
                (§ return _)
            )
        )
        (throw (ß new java.util.NoSuchElementException()))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter" this]
        (throw (ß new UnsupportedOperationException("remove() not supported")))
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        (§ field #_"int[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq_int" ArraySeq_int [#_"IPersistentMap" ___meta, #_"int[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_int" this]
        (ß array[i])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_int" this]
        (when (ß i + 1 < array.length)
            (§ return (ß new ArraySeq_int(meta(), array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_int" this]
        (ß array.length - i)
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_int" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq_int" withMeta [#_"ArraySeq_int" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq_int(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_int" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß array[i])]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_int" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, array[i]))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_int" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"int" ___k (ß ((Number) ___o).intValue())]
                (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                    (when (ß ___k == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_int" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"int" ___k (ß ((Number) ___o).intValue())]
                (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                    (when (ß ___k == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        (§ field #_"float[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq_float" ArraySeq_float [#_"IPersistentMap" ___meta, #_"float[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_float" this]
        (ß Numbers'num(array[i]))
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_float" this]
        (when (ß i + 1 < array.length)
            (§ return (ß new ArraySeq_float(meta(), array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_float" this]
        (ß array.length - i)
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_float" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq_float" withMeta [#_"ArraySeq_float" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq_float(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_float" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß Numbers'num(array[i]))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num(array[___x]))))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_float" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, Numbers'num(array[i])))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num(array[___x]))))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_float" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"float" ___f (ß ((Number) ___o).floatValue())]
                (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                    (when (ß ___f == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_float" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"float" ___f (ß ((Number) ___o).floatValue())]
                (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                    (when (ß ___f == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        -1
    )
)

(class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        (§ field #_"double[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq_double" ArraySeq_double [#_"IPersistentMap" ___meta, #_"double[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_double" this]
        (ß array[i])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_double" this]
        (when (ß i + 1 < array.length)
            (§ return (ß new ArraySeq_double(meta(), array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_double" this]
        (ß array.length - i)
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_double" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq_double" withMeta [#_"ArraySeq_double" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq_double(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_double" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß array[i])]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_double" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, array[i]))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_double" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"double" ___d (ß ((Number) ___o).doubleValue())]
                (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                    (when (ß ___d == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_double" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"double" ___d (ß ((Number) ___o).doubleValue())]
                (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                    (when (ß ___d == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        (§ field #_"long[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq_long" ArraySeq_long [#_"IPersistentMap" ___meta, #_"long[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_long" this]
        (ß Numbers'num(array[i]))
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_long" this]
        (when (ß i + 1 < array.length)
            (§ return (ß new ArraySeq_long(meta(), array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_long" this]
        (ß array.length - i)
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_long" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq_long" withMeta [#_"ArraySeq_long" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq_long(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_long" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß Numbers'num(array[i]))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num(array[___x]))))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_long" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, Numbers'num(array[i])))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num(array[___x]))))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_long" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"long" ___l (ß ((Number) ___o).longValue())]
                (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                    (when (ß ___l == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_long" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"long" ___l (ß ((Number) ___o).longValue())]
                (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                    (when (ß ___l == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        (§ field #_"byte[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq_byte" ArraySeq_byte [#_"IPersistentMap" ___meta, #_"byte[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_byte" this]
        (ß array[i])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_byte" this]
        (when (ß i + 1 < array.length)
            (§ return (ß new ArraySeq_byte(meta(), array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_byte" this]
        (ß array.length - i)
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_byte" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq_byte" withMeta [#_"ArraySeq_byte" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq_byte(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_byte" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß array[i])]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_byte" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, array[i]))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_byte" this, #_"Object" ___o]
        (when (ß ___o instanceof Byte)
            (let [#_"byte" ___b (ß ((Byte) ___o).byteValue())]
                (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                    (when (ß ___b == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
            (when (ß ___o.equals(array[___j]))
                (§ return (ß ___j - i))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_byte" this, #_"Object" ___o]
        (when (ß ___o instanceof Byte)
            (let [#_"byte" ___b (ß ((Byte) ___o).byteValue())]
                (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                    (when (ß ___b == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
            (when (ß ___o.equals(array[___j]))
                (§ return (ß ___j - i))
            )
        )
        -1
    )
)

(class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        (§ field #_"char[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq_char" ArraySeq_char [#_"IPersistentMap" ___meta, #_"char[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_char" this]
        (ß array[i])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_char" this]
        (when (ß i + 1 < array.length)
            (§ return (ß new ArraySeq_char(meta(), array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_char" this]
        (ß array.length - i)
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_char" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq_char" withMeta [#_"ArraySeq_char" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq_char(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_char" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß array[i])]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_char" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, array[i]))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_char" this, #_"Object" ___o]
        (when (ß ___o instanceof Character)
            (let [#_"char" ___c (ß ((Character) ___o).charValue())]
                (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                    (when (ß ___c == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
            (when (ß ___o.equals(array[___j]))
                (§ return (ß ___j - i))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_char" this, #_"Object" ___o]
        (when (ß ___o instanceof Character)
            (let [#_"char" ___c (ß ((Character) ___o).charValue())]
                (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                    (when (ß ___c == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
            (when (ß ___o.equals(array[___j]))
                (§ return (ß ___j - i))
            )
        )
        -1
    )
)

(class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        (§ field #_"short[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq_short" ArraySeq_short [#_"IPersistentMap" ___meta, #_"short[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_short" this]
        (ß array[i])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_short" this]
        (when (ß i + 1 < array.length)
            (§ return (ß new ArraySeq_short(meta(), array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_short" this]
        (ß array.length - i)
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_short" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq_short" withMeta [#_"ArraySeq_short" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq_short(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_short" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß array[i])]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_short" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, array[i]))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_short" this, #_"Object" ___o]
        (when (ß ___o instanceof Short)
            (let [#_"short" ___s (ß ((Short) ___o).shortValue())]
                (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                    (when (ß ___s == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
            (when (ß ___o.equals(array[___j]))
                (§ return (ß ___j - i))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_short" this, #_"Object" ___o]
        (when (ß ___o instanceof Short)
            (let [#_"short" ___s (ß ((Short) ___o).shortValue())]
                (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                    (when (ß ___s == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
            (when (ß ___o.equals(array[___j]))
                (§ return (ß ___j - i))
            )
        )
        -1
    )
)

(class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ init
        (§ field #_"boolean[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq_boolean" ArraySeq_boolean [#_"IPersistentMap" ___meta, #_"boolean[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_boolean" this]
        (ß array[i])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_boolean" this]
        (when (ß i + 1 < array.length)
            (§ return (ß new ArraySeq_boolean(meta(), array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_boolean" this]
        (ß array.length - i)
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_boolean" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq_boolean" withMeta [#_"ArraySeq_boolean" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq_boolean(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_boolean" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß array[i])]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_boolean" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, array[i]))]
            (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_boolean" this, #_"Object" ___o]
        (when (ß ___o instanceof Boolean)
            (let [#_"boolean" ___b (ß ((Boolean) ___o).booleanValue())]
                (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                    (when (ß ___b == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
            (when (ß ___o.equals(array[___j]))
                (§ return (ß ___j - i))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_boolean" this, #_"Object" ___o]
        (when (ß ___o instanceof Boolean)
            (let [#_"boolean" ___b (ß ((Boolean) ___o).booleanValue())]
                (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                    (when (ß ___b == array[___j])
                        (§ return (ß ___j - i))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
            (when (ß ___o.equals(array[___j]))
                (§ return (ß ___j - i))
            )
        )
        -1
    )
)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (§ defn #_"ArraySeq" ArraySeq'create []
        nil
    )

    (§ defn #_"ArraySeq" ArraySeq'create [#_"Object..." ___array]
        (when (ß ___array == nil || ___array.length == 0)
            (§ return nil)
        )
        (ß new ArraySeq(___array, 0))
    )

    (§ defn #_"ISeq" ArraySeq'createFromObject [#_"Object" ___array]
        (when (ß ___array == nil || Array/getLength(___array) == 0)
            (§ return nil)
        )
        (let [#_"Class" ___aclass (ß ___array.getClass())]
            (when (ß ___aclass == (§ class int[]))
                (§ return (ß new ArraySeq_int(nil, (int[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class float[]))
                (§ return (ß new ArraySeq_float(nil, (float[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class double[]))
                (§ return (ß new ArraySeq_double(nil, (double[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class long[]))
                (§ return (ß new ArraySeq_long(nil, (long[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class byte[]))
                (§ return (ß new ArraySeq_byte(nil, (byte[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class char[]))
                (§ return (ß new ArraySeq_char(nil, (char[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class short[]))
                (§ return (ß new ArraySeq_short(nil, (short[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class boolean[]))
                (§ return (ß new ArraySeq_boolean(nil, (boolean[]) ___array, 0)))
            )
            (ß new ArraySeq(___array, 0))
        )
    )

    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"ArraySeq" ArraySeq [#_"Object" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.array) (ß (Object[]) ___array))
            this
        )
    )

    (§ constructor #_"ArraySeq" ArraySeq [#_"IPersistentMap" ___meta, #_"Object" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.array) (ß (Object[]) ___array))
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq" this]
        (when (some? array)
            (§ return (ß array[i]))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq" this]
        (when (ß array != nil && i + 1 < array.length)
            (§ return (ß new ArraySeq(array, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq" this]
        (when (some? array)
            (§ return (ß array.length - i))
        )
        0
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq" this]
        i
    )

    #_method
    (§ defn #_"ArraySeq" withMeta [#_"ArraySeq" this, #_"IPersistentMap" ___meta]
        (ß new ArraySeq(___meta, array, i))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq" this, #_"IFn" ___f]
        (when (some? array)
            (let [#_"Object" ___ret (ß array[i])]
                (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                    (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                    (when (ß RT'isReduced(___ret))
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                )
                (§ return ___ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq" this, #_"IFn" ___f, #_"Object" ___start]
        (when (some? array)
            (let [#_"Object" ___ret (ß ___f.invoke(___start, array[i]))]
                (loop-when-recur [(§ var #_"int" ___x (ß i + 1))] (ß ___x < array.length) [(§ ass ___x (ß ___x + 1))]
                    (when (ß RT'isReduced(___ret))
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                    (§ ass ___ret (ß ___f.invoke(___ret, array[___x])))
                )
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ return ___ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq" this, #_"Object" ___o]
        (when (some? array)
            (loop-when-recur [(§ var #_"int" ___j i)] (ß ___j < array.length) [(§ ass ___j (ß ___j + 1))]
                (when (ß Util'equals(___o, array[___j]))
                    (§ return (ß ___j - i))
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq" this, #_"Object" ___o]
        (when (some? array)
            (if (nil? ___o)
                (do
                    (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                        (when (ß array[___j] == nil)
                            (§ return (ß ___j - i))
                        )
                    )
                )
                (do
                    (loop-when-recur [(§ var #_"int" ___j (ß array.length - 1))] (ß ___j >= i) [(§ ass ___j (ß ___j - 1))]
                        (when (ß ___o.equals(array[___j]))
                            (§ return (ß ___j - i))
                        )
                    )
                )
            )
        )
        -1
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    (§ init
        #_transient
        (§ field #_"int" _hash 0)
        #_transient
        (§ field #_"int" _hasheq 0)
    )

    #_protected
    (§ constructor #_"ASeq" ASeq [#_"IPersistentMap" ___meta]
        (let [this (ß super(___meta))]
            this
        )
    )

    #_protected
    (§ constructor #_"ASeq" ASeq []
        (let [this (ß super())]
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"ASeq" this]
        (ß RT'printString(this))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"ASeq" this]
        (ß PersistentList'EMPTY)
    )

    #_method
    (§ defn #_"boolean" equiv [#_"ASeq" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Sequential || ___obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (ß RT'seq(___obj))]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()), ___ms (ß ___ms.next()))]
                (when (ß ___ms == nil || !Util'equiv(___s.first(), ___ms.first()))
                    (§ return false)
                )
            )
            (ß (___ms == nil))
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"ASeq" this, #_"Object" ___obj]
        (when (ß this == ___obj)
            (§ return true)
        )
        (when (ß !(___obj instanceof Sequential || ___obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (ß RT'seq(___obj))]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()), ___ms (ß ___ms.next()))]
                (when (ß ___ms == nil || !Util'equals(___s.first(), ___ms.first()))
                    (§ return false)
                )
            )
            (ß (___ms == nil))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"ASeq" this]
        (when (ß _hash == 0)
            (let [#_"int" ___hash 1]
                (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (§ ass ___hash (ß 31 * ___hash + ((___s.first() == nil) ? 0 :or ___s.first().hashCode())))
                )
                (§ ass (ß this._hash) ___hash)
            )
        )
        _hash
    )

    #_method
    (§ defn #_"int" hasheq [#_"ASeq" this]
        (when (ß _hasheq == 0)
            (§ ass _hasheq (ß Murmur3'hashOrdered(this)))
        )
        _hasheq
    )

    #_method
    (§ defn #_"int" count [#_"ASeq" this]
        (let [#_"int" ___i 1]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß next()))] (some? ___s) [(§ ass ___s (ß ___s.next()), ___i (ß ___i + 1))]
                (when (ß ___s instanceof Counted)
                    (§ return (ß ___i + ___s.count()))
                )
            )
            i
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"ASeq" this]
        this
    )

    #_method
    (§ defn #_"ISeq" cons [#_"ASeq" this, #_"Object" ___o]
        (ß new Cons(___o, this))
    )

    #_method
    (§ defn #_"ISeq" more [#_"ASeq" this]
        (let [#_"ISeq" ___s (ß next())]
            (when (nil? ___s)
                (§ return (ß PersistentList'EMPTY))
            )
            s
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"ASeq" this]
        (ß RT'seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"ASeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"ASeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"ASeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"ASeq" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß !contains(___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"ASeq" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"ASeq" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"ASeq" this]
        (ß (seq() == nil))
    )

    #_method
    (§ defn #_"boolean" contains [#_"ASeq" this, #_"Object" ___o]
        (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
            (when (ß Util'equiv(___s.first(), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"ASeq" this]
        (SeqIterator. this)
    )

    #_method
    (§ defn- #_"List" reify [#_"ASeq" this]
        (ß Collections/unmodifiableList(new ArrayList(this)))
    )

    #_method
    (§ defn #_"List" subList [#_"ASeq" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß reify().subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"ASeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"ASeq" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"ASeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (ß seq())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___s) [(§ ass ___s (ß ___s.next()), ___i (ß ___i + 1))]
                (when (ß Util'equiv(___s.first(), ___o))
                    (§ return ___i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ASeq" this, #_"Object" ___o]
        (ß reify().lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"ASeq" this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"ASeq" this, #_"int" ___index]
        (ß reify().listIterator(___index))
    )

    #_method
    (§ defn #_"Object" get [#_"ASeq" this, #_"int" ___index]
        (ß RT'nth(this, ___index))
    )

    #_method
    (§ defn #_"void" add [#_"ASeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"ASeq" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Associative

(defprotocol Associative #_(§ extends IPersistentCollection, ILookup)
    #_abstract
    (#_"boolean" Associative'''containsKey [#_"Associative" this, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" Associative'''entryAt [#_"Associative" this, #_"Object" ___key])
    #_abstract
    (#_"Associative" Associative'''assoc [#_"Associative" this, #_"Object" ___key, #_"Object" ___val])
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (§ init
        (§ field #_"AtomicReference" state nil)
    )

    (§ constructor #_"Atom" Atom [#_"Object" ___state]
        (let [this (ß super())]
            (§ ass (ß this.state) (AtomicReference. ___state))
            this
        )
    )

    (§ constructor #_"Atom" Atom [#_"Object" ___state, #_"IPersistentMap" ___meta]
        (let [this (ß super(___meta))]
            (§ ass (ß this.state) (AtomicReference. ___state))
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Atom" this]
        (ß state.get())
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" ___f]
        (while true
            (let [#_"Object" ___v (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___v))]
                    (ß validate(___newv))
                    (when (ß state.compareAndSet(___v, ___newv))
                        (ß notifyWatches(___v, ___newv))
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg]
        (while true
            (let [#_"Object" ___v (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___v, ___arg))]
                    (ß validate(___newv))
                    (when (ß state.compareAndSet(___v, ___newv))
                        (ß notifyWatches(___v, ___newv))
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2]
        (while true
            (let [#_"Object" ___v (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___v, ___arg1, ___arg2))]
                    (ß validate(___newv))
                    (when (ß state.compareAndSet(___v, ___newv))
                        (ß notifyWatches(___v, ___newv))
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args]
        (while true
            (let [#_"Object" ___v (ß deref())]
                (let [#_"Object" ___newv (ß ___f.applyTo(RT'listStar(___v, ___x, ___y, ___args)))]
                    (ß validate(___newv))
                    (when (ß state.compareAndSet(___v, ___newv))
                        (ß notifyWatches(___v, ___newv))
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" ___f]
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___oldv))]
                    (ß validate(___newv))
                    (when (ß state.compareAndSet(___oldv, ___newv))
                        (ß notifyWatches(___oldv, ___newv))
                        (§ return (ß LazilyPersistentVector'createOwning(___oldv, ___newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg]
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___oldv, ___arg))]
                    (ß validate(___newv))
                    (when (ß state.compareAndSet(___oldv, ___newv))
                        (ß notifyWatches(___oldv, ___newv))
                        (§ return (ß LazilyPersistentVector'createOwning(___oldv, ___newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2]
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___oldv, ___arg1, ___arg2))]
                    (ß validate(___newv))
                    (when (ß state.compareAndSet(___oldv, ___newv))
                        (ß notifyWatches(___oldv, ___newv))
                        (§ return (ß LazilyPersistentVector'createOwning(___oldv, ___newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args]
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (let [#_"Object" ___newv (ß ___f.applyTo(RT'listStar(___oldv, ___x, ___y, ___args)))]
                    (ß validate(___newv))
                    (when (ß state.compareAndSet(___oldv, ___newv))
                        (ß notifyWatches(___oldv, ___newv))
                        (§ return (ß LazilyPersistentVector'createOwning(___oldv, ___newv)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" compareAndSet [#_"Atom" this, #_"Object" ___oldv, #_"Object" ___newv]
        (ß validate(___newv))
        (let [#_"boolean" ___ret (ß state.compareAndSet(___oldv, ___newv))]
            (when ___ret
                (ß notifyWatches(___oldv, ___newv))
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reset [#_"Atom" this, #_"Object" ___newval]
        (let [#_"Object" ___oldval (ß state.get())]
            (ß validate(___newval))
            (ß state.set(___newval))
            (ß notifyWatches(___oldval, ___newval))
            ___newval
        )
    )

    #_method
    (§ defn #_"IPersistentVector" resetVals [#_"Atom" this, #_"Object" ___newv]
        (ß validate(___newv))
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (when (ß state.compareAndSet(___oldv, ___newv))
                    (ß notifyWatches(___oldv, ___newv))
                    (§ return (ß LazilyPersistentVector'createOwning(___oldv, ___newv)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

#_stateless
#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    #_abstract
    (§ defn #_"void" ensureEditable [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"ITransientMap" doAssoc [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (§ defn #_"ITransientMap" doWithout [#_"ATransientMap" this, #_"Object" ___key])
    #_abstract
    (§ defn #_"Object" doValAt [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___notFound])
    #_abstract
    (§ defn #_"int" doCount [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"IPersistentMap" doPersistent [#_"ATransientMap" this])

    #_method
    (§ defn #_"ITransientMap" conj [#_"ATransientMap" this, #_"Object" ___o]
        (ß ensureEditable())
        (cond (ß ___o instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (§ return (ß assoc(___e.getKey(), ___e.getValue())))
                )
            )
            (ß ___o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
                    (when (ß ___v.count() != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß assoc(___v.nth(0), ___v.nth(1))))
                )
            )
        )

        (let [#_"ITransientMap" ___ret this]
            (loop-when-recur [(§ var #_"ISeq" ___es (ß RT'seq(___o)))] (some? ___es) [(§ ass ___es (ß ___es.next()))]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___es.first())]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientMap" this, #_"Object" ___arg1]
        (ß valAt(___arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientMap" this, #_"Object" ___arg1, #_"Object" ___notFound]
        (ß valAt(___arg1, ___notFound))
    )

    #_method
    (§ defn #_"Object" valAt [#_"ATransientMap" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"ITransientMap" assoc [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___val]
        (ß ensureEditable())
        (ß doAssoc(___key, ___val))
    )

    #_method
    (§ defn #_"ITransientMap" without [#_"ATransientMap" this, #_"Object" ___key]
        (ß ensureEditable())
        (ß doWithout(___key))
    )

    #_method
    (§ defn #_"IPersistentMap" persistent [#_"ATransientMap" this]
        (ß ensureEditable())
        (ß doPersistent())
    )

    #_method
    (§ defn #_"Object" valAt [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (ß ensureEditable())
        (ß doValAt(___key, ___notFound))
    )

    (§ def- #_"Object" ATransientMap'NOT_FOUND (Object.))
    #_method
    (§ defn #_"boolean" containsKey [#_"ATransientMap" this, #_"Object" ___key]
        (ß (valAt(___key, ATransientMap'NOT_FOUND) != ATransientMap'NOT_FOUND))
    )
    #_method
    (§ defn #_"IMapEntry" entryAt [#_"ATransientMap" this, #_"Object" ___key]
        (let [#_"Object" ___v (ß valAt(___key, ATransientMap'NOT_FOUND))]
            (when (ß ___v != ATransientMap'NOT_FOUND)
                (§ return (ß MapEntry'create(___key, ___v)))
            )
            nil
        )
    )

    #_method
    (§ defn #_"int" count [#_"ATransientMap" this]
        (ß ensureEditable())
        (ß doCount())
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    (§ init
        #_volatile
        (§ field #_"ITransientMap" impl nil)
    )

    (§ constructor #_"ATransientSet" ATransientSet [#_"ITransientMap" ___impl]
        (let [this (ß super())]
            (§ ass (ß this.impl) ___impl)
            this
        )
    )

    #_method
    (§ defn #_"int" count [#_"ATransientSet" this]
        (ß impl.count())
    )

    #_method
    (§ defn #_"ITransientSet" conj [#_"ATransientSet" this, #_"Object" ___val]
        (let [#_"ITransientMap" ___m (ß impl.assoc(___val, ___val))]
            (when (ß ___m != impl)
                (§ ass (ß this.impl) ___m)
            )
            this
        )
    )

    #_method
    (§ defn #_"boolean" contains [#_"ATransientSet" this, #_"Object" ___key]
        (ß (this != impl.valAt(___key, this)))
    )

    #_method
    (§ defn #_"ITransientSet" disjoin [#_"ATransientSet" this, #_"Object" ___key]
        (let [#_"ITransientMap" ___m (ß impl.without(___key))]
            (when (ß ___m != impl)
                (§ ass (ß this.impl) ___m)
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" get [#_"ATransientSet" this, #_"Object" ___key]
        (ß impl.valAt(___key))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientSet" this, #_"Object" ___key, #_"Object" ___notFound]
        (ß impl.valAt(___key, ___notFound))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientSet" this, #_"Object" ___key]
        (ß impl.valAt(___key))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ def #_"BigInt" BigInt'ZERO (ß new BigInt(0, nil)))
    (§ def #_"BigInt" BigInt'ONE (ß new BigInt(1, nil)))

    (§ init
        (§ field #_"long" lpart 0)
        (§ field #_"BigInteger" bipart nil)
    )

    (§ constructor- #_"BigInt" BigInt [#_"long" ___lpart, #_"BigInteger" ___bipart]
        (let [this (ß super())]
            (§ ass (ß this.lpart) ___lpart)
            (§ ass (ß this.bipart) ___bipart)
            this
        )
    )

    ;; must follow Long
    #_method
    (§ defn #_"int" hashCode [#_"BigInt" this]
        (when (nil? bipart)
            (§ return (ß (int) (this.lpart :xor (this.lpart >>> 32))))
        )
        (ß bipart.hashCode())
    )

    #_method
    (§ defn #_"int" hasheq [#_"BigInt" this]
        (when (nil? bipart)
            (§ return (ß Murmur3'hashLong(lpart)))
        )
        (ß bipart.hashCode())
    )

    #_method
    (§ defn #_"boolean" equals [#_"BigInt" this, #_"Object" ___obj]
        (when (ß this == ___obj)
            (§ return true)
        )
        (when (ß ___obj instanceof BigInt)
            (let [#_"BigInt" ___o (ß (BigInt) ___obj)]
                (when (nil? bipart)
                    (§ return (ß (___o.bipart == nil && this.lpart == ___o.lpart)))
                )
                (§ return (ß (___o.bipart != nil && this.bipart.equals(___o.bipart))))
            )
        )
        false
    )

    (§ defn #_"BigInt" BigInt'fromBigInteger [#_"BigInteger" ___val]
        (if (ß ___val.bitLength() < 64)
            (do
                (ß new BigInt(___val.longValue(), nil))
            )
            (do
                (ß new BigInt(0, ___val))
            )
        )
    )

    (§ defn #_"BigInt" BigInt'fromLong [#_"long" ___val]
        (ß new BigInt(___val, nil))
    )

    #_method
    (§ defn #_"BigInteger" toBigInteger [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß BigInteger/valueOf(lpart))
            )
            (do
                bipart
            )
        )
    )

    #_method
    (§ defn #_"BigDecimal" toBigDecimal [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß BigDecimal/valueOf(lpart))
            )
            (do
                (BigDecimal. bipart)
            )
        )
    )

    #_method
    (§ defn #_"int" intValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß (int) lpart)
            )
            (do
                (ß bipart.intValue())
            )
        )
    )

    #_method
    (§ defn #_"long" longValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                lpart
            )
            (do
                (ß bipart.longValue())
            )
        )
    )

    #_method
    (§ defn #_"float" floatValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                lpart
            )
            (do
                (ß bipart.floatValue())
            )
        )
    )

    #_method
    (§ defn #_"double" doubleValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                lpart
            )
            (do
                (ß bipart.doubleValue())
            )
        )
    )

    #_method
    (§ defn #_"byte" byteValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß (byte) lpart)
            )
            (do
                (ß bipart.byteValue())
            )
        )
    )

    #_method
    (§ defn #_"short" shortValue [#_"BigInt" this]
        (if (nil? bipart)
            (do
                (ß (short) lpart)
            )
            (do
                (ß bipart.shortValue())
            )
        )
    )

    (§ defn #_"BigInt" BigInt'valueOf [#_"long" ___val]
        (ß new BigInt(___val, nil))
    )

    #_method
    (§ defn #_"String" toString [#_"BigInt" this]
        (when (nil? bipart)
            (§ return (ß String/valueOf(lpart)))
        )
        (ß bipart.toString())
    )

    #_method
    (§ defn #_"int" bitLength [#_"BigInt" this]
        (ß toBigInteger().bitLength())
    )

    #_method
    (§ defn #_"BigInt" add [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß (bipart == nil) && (___y.bipart == nil))
            (let [#_"long" ___ret (ß lpart + ___y.lpart)]
                (when (ß (___ret :xor lpart) >= 0 || (___ret :xor ___y.lpart) >= 0)
                    (§ return (ß BigInt'valueOf(___ret)))
                )
            )
        )
        (ß BigInt'fromBigInteger(this.toBigInteger().add(___y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" multiply [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß (bipart == nil) && (___y.bipart == nil))
            (let [#_"long" ___ret (ß lpart * ___y.lpart)]
                (when (ß ___y.lpart == 0 || (___ret / ___y.lpart == lpart && lpart != Long/MIN_VALUE))
                    (§ return (ß BigInt'valueOf(___ret)))
                )
            )
        )
        (ß BigInt'fromBigInteger(this.toBigInteger().multiply(___y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" quotient [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß (bipart == nil) && (___y.bipart == nil))
            (when (ß lpart == Long/MIN_VALUE && ___y.lpart == -1)
                (§ return (ß BigInt'fromBigInteger(this.toBigInteger().negate())))
            )
            (§ return (ß BigInt'valueOf(lpart / ___y.lpart)))
        )
        (ß BigInt'fromBigInteger(this.toBigInteger().divide(___y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" remainder [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß (bipart == nil) && (___y.bipart == nil))
            (§ return (ß BigInt'valueOf(lpart % ___y.lpart)))
        )
        (ß BigInt'fromBigInteger(this.toBigInteger().remainder(___y.toBigInteger())))
    )

    #_method
    (§ defn #_"boolean" lt [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß (bipart == nil) && (___y.bipart == nil))
            (§ return (ß (lpart < ___y.lpart)))
        )
        (ß (this.toBigInteger().compareTo(___y.toBigInteger()) < 0))
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (§ init
        (§ field #_"T" val nil)
        (§ field #_"Binding" rest nil)
    )

    (§ constructor #_"Binding" Binding [#_"T" ___val]
        (let [this (ß super())]
            (§ ass (ß this.val) ___val)
            (§ ass (ß this.rest) nil)
            this
        )
    )

    (§ constructor #_"Binding" Binding [#_"T" ___val, #_"Binding" ___rest]
        (let [this (ß super())]
            (§ ass (ß this.val) ___val)
            (§ ass (ß this.rest) ___rest)
            this
        )
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (§ init
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"Box" Box [#_"Object" ___val]
        (let [this (ß super())]
            (§ ass (ß this.val) ___val)
            this
        )
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (§ init
        (§ field #_"Object[]" buffer nil)
        (§ field #_"int" end 0)
    )

    (§ constructor #_"ChunkBuffer" ChunkBuffer [#_"int" ___capacity]
        (let [this (ß super())]
            (§ ass buffer (ß new Object[___capacity]))
            (§ ass end 0)
            this
        )
    )

    #_method
    (§ defn #_"void" add [#_"ChunkBuffer" this, #_"Object" ___o]
        (§ ass (ß buffer[end]) ___o)
        (§ ass end (ß end + 1))
        nil
    )

    #_method
    (§ defn #_"IChunk" chunk [#_"ChunkBuffer" this]
        (let [#_"ArrayChunk" ___ret (ß new ArrayChunk(buffer, 0, end))]
            (§ ass buffer nil)
            ret
        )
    )

    #_method
    (§ defn #_"int" count [#_"ChunkBuffer" this]
        end
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (§ init
        (§ field #_"IChunk" chunk nil)
        (§ field #_"ISeq" _more nil)
    )

    (§ constructor #_"ChunkedCons" ChunkedCons [#_"IPersistentMap" ___meta, #_"IChunk" ___chunk, #_"ISeq" ___more]
        (let [this (ß super(___meta))]
            (§ ass (ß this.chunk) ___chunk)
            (§ ass (ß this._more) ___more)
            this
        )
    )

    (§ constructor #_"ChunkedCons" ChunkedCons [#_"IChunk" ___chunk, #_"ISeq" ___more]
        (let [this (ß this(nil, ___chunk, ___more))]
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"ChunkedCons" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != _meta)
            (§ return (ß new ChunkedCons(___meta, chunk, _more)))
        )
        this
    )

    #_method
    (§ defn #_"Object" first [#_"ChunkedCons" this]
        (ß chunk.nth(0))
    )

    #_method
    (§ defn #_"ISeq" next [#_"ChunkedCons" this]
        (when (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"ISeq" more [#_"ChunkedCons" this]
        (when (ß chunk.count() > 1)
            (§ return (ß new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (when (nil? _more)
            (§ return (ß PersistentList'EMPTY))
        )
        _more
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"ChunkedCons" this]
        chunk
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"ChunkedCons" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"ChunkedCons" this]
        (when (nil? _more)
            (§ return (ß PersistentList'EMPTY))
        )
        _more
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

#_stateless
(class-ns Compile
    (§ def- #_"String" Compile'PATH_PROP "cloiure.compile.path")
    (§ def- #_"String" Compile'REFLECTION_WARNING_PROP "cloiure.compile.warn-on-reflection")
    (§ def- #_"String" Compile'UNCHECKED_MATH_PROP "cloiure.compile.unchecked-math")

    (§ def- #_"Var" Compile'compile_path (ß RT'var("cloiure.core", "*compile-path*")))
    (§ def- #_"Var" Compile'compile (ß RT'var("cloiure.core", "compile")))
    (§ def- #_"Var" Compile'warn_on_reflection (ß RT'var("cloiure.core", "*warn-on-reflection*")))
    (§ def- #_"Var" Compile'unchecked_math (ß RT'var("cloiure.core", "*unchecked-math*")))

    (§ defn #_"void" Compile'main [#_"String[]" ___args] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"OutputStreamWriter" ___out (ß (OutputStreamWriter) RT'OUT.deref())]
            (let [#_"PrintWriter" ___err (ß RT'errPrintWriter())]
                (let [#_"String" ___path (ß System/getProperty(PATH_PROP))]
                    (let [#_"int" ___count (ß ___args.length)]
                        (when (nil? ___path)
                            (ß ___err.println("ERROR: Must set system property " + PATH_PROP + "\nto the location for compiled .class files." + "\nThis directory must also be on your CLASSPATH."))
                            (ß System/exit(1))
                        )

                        (let [#_"boolean" ___warnOnReflection (ß System/getProperty(REFLECTION_WARNING_PROP, "false").equals("true"))]
                            (let [#_"String" ___uncheckedMathProp (ß System/getProperty(UNCHECKED_MATH_PROP))]
                                (let [#_"Object" ___uncheckedMath (ß Boolean/FALSE)]
                                    (cond (ß "true".equals(___uncheckedMathProp))
                                        (do
                                            (§ ass ___uncheckedMath (ß Boolean/TRUE))
                                        )
                                        (ß "warn-on-boxed".equals(___uncheckedMathProp))
                                        (do
                                            (§ ass ___uncheckedMath (ß Keyword'intern("warn-on-boxed")))
                                        )
                                    )

                                    ;; force load to avoid transitive compilation during lazy load
                                    (ß RT'load("cloiure/core/specs/alpha"))

                                    (try
                                        (ß Var'pushThreadBindings(RT'map(compile_path, ___path, warn_on_reflection, ___warnOnReflection, unchecked_math, ___uncheckedMath)))

                                        (doseq [#_"String" ___lib ___args]
                                            (ß ___out.write("Compiling " + ___lib + " to " + ___path + "\n"))
                                            (ß ___out.flush())
                                            (ß compile.invoke(Symbol'intern(___lib)))
                                        )
                                        (finally
                                            (ß Var'popThreadBindings())
                                            (try
                                                (ß ___out.flush())
                                                (catch IOException ___e
                                                    (ß ___e.printStackTrace(___err))
                                                )
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(def Context'enum-set
    (hash-set
        :Context'STATEMENT ;; value ignored
        :Context'EXPRESSION ;; value required
        :Context'RETURN ;; tail position relative to enclosing recur frame
        :Context'EVAL
    )
)

#_private
#_stateless
(class-ns Recur
)

(defprotocol Expr
    #_abstract
    (#_"Object" Expr'''eval [#_"Expr" this])
    #_abstract
    (#_"void" Expr'''emit [#_"Expr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen])
    #_abstract
    (#_"boolean" Expr'''hasJavaClass [#_"Expr" this])
    #_abstract
    (#_"Class" Expr'''getJavaClass [#_"Expr" this])
)

#_stateless
#_abstract
(class-ns UntypedExpr (§ implements Expr)
    #_method
    (§ defn #_"Class" getJavaClass [#_"UntypedExpr" this]
        (throw (IllegalArgumentException. "Has no Java class"))
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"UntypedExpr" this]
        false
    )
)

(defprotocol IParser
    #_abstract
    (#_"Expr" IParser'''parse [#_"IParser" this, #_"Context" ___context, #_"Object" ___form])
)

#_stateless
(class-ns DefParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"DefParser" this, #_"Context" ___context, #_"Object" ___form]
        ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
        (let [#_"String" ___docstring nil]
            (when (ß RT'count(___form) == 4 && (RT'third(___form) instanceof String))
                (§ ass ___docstring (ß (String) RT'third(___form)))
                (§ ass ___form (ß RT'list(RT'first(___form), RT'second(___form), RT'fourth(___form))))
            )
            (cond (ß RT'count(___form) > 3)
                (do
                    (throw (ß Util'runtimeException("Too many arguments to def")))
                )
                (ß RT'count(___form) < 2)
                (do
                    (throw (ß Util'runtimeException("Too few arguments to def")))
                )
                (ß !(RT'second(___form) instanceof Symbol))
                (do
                    (throw (ß Util'runtimeException("First argument to def must be a Symbol")))
                )
            )
            (let [#_"Symbol" ___sym (ß (Symbol) RT'second(___form))]
                (let [#_"Var" ___v (ß lookupVar(___sym, true))]
                    (when (nil? ___v)
                        (throw (ß Util'runtimeException("Can't refer to qualified var that doesn't exist")))
                    )
                    (let [#_"boolean" ___shadowsCoreMapping false]
                        (when (ß !___v.ns.equals(currentNS()))
                            (if (ß ___sym.ns == nil)
                                (do
                                    (§ ass ___v (ß currentNS().intern(___sym)))
                                    (§ ass ___shadowsCoreMapping true)
                                    (ß registerVar(___v))
                                )
                                (do
                                    (throw (ß Util'runtimeException("Can't create defs outside of current ns")))
                                )
                            )
                        )
                        (let [#_"IPersistentMap" ___mm (ß ___sym.meta())]
                            (let [#_"boolean" ___isDynamic (ß RT'booleanCast(RT'get(___mm, dynamicKey)))]
                                (when ___isDynamic
                                    (ß ___v.setDynamic())
                                )
                                (when (ß !___isDynamic && ___sym.name.startsWith("*") && ___sym.name.endsWith("*") && ___sym.name.length() > 2)
                                    (ß RT'errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, " + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", ___sym, SOURCE_PATH.get(), LINE.get()))
                                )
                                (when (ß RT'booleanCast(RT'get(___mm, arglistsKey)))
                                    (let [#_"IPersistentMap" ___vm (ß ___v.meta())]
                                        ;; drop quote
                                        (§ ass ___vm (ß (IPersistentMap) RT'assoc(___vm, arglistsKey, RT'second(___mm.valAt(arglistsKey)))))
                                        (ß ___v.setMeta(___vm))
                                    )
                                )
                                (let [#_"Object" ___source_path (ß SOURCE_PATH.get())]
                                    (§ ass ___source_path (ß (___source_path == nil) ? "NO_SOURCE_FILE" :or ___source_path))
                                    (§ ass ___mm (ß (IPersistentMap) RT'assoc(___mm, RT'LINE_KEY, LINE.get()).assoc(RT'COLUMN_KEY, COLUMN.get()).assoc(RT'FILE_KEY, ___source_path)))
                                    (when (some? ___docstring)
                                        (§ ass ___mm (ß (IPersistentMap) RT'assoc(___mm, RT'DOC_KEY, ___docstring)))
                                    )
                                    (§ ass ___mm (ß (IPersistentMap) elideMeta(___mm)))
                                    (let [#_"Expr" ___meta (ß (___mm.count() == 0) ? nil :or analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___mm))]
                                        (ß new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), ___v, analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, RT'third(___form), ___v.sym.name), ___meta, (RT'count(___form) == 3), ___isDynamic, ___shadowsCoreMapping))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns DefExpr (§ implements Expr)
    (§ def #_"Method" DefExpr'bindRootMethod (ß Method/getMethod("void bindRoot(Object)")))
    (§ def #_"Method" DefExpr'setTagMethod (ß Method/getMethod("void setTag(cloiure.lang.Symbol)")))
    (§ def #_"Method" DefExpr'setMetaMethod (ß Method/getMethod("void setMeta(cloiure.lang.IPersistentMap)")))
    (§ def #_"Method" DefExpr'setDynamicMethod (ß Method/getMethod("cloiure.lang.Var setDynamic(boolean)")))
    (§ def #_"Method" DefExpr'symintern (ß Method/getMethod("cloiure.lang.Symbol intern(String, String)")))
    (§ def #_"Method" DefExpr'internVar (ß Method/getMethod("cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)")))

    (§ init
        (§ field #_"Var" var nil)
        (§ field #_"Expr" init nil)
        (§ field #_"Expr" meta nil)
        (§ field #_"boolean" initProvided false)
        (§ field #_"boolean" isDynamic false)
        (§ field #_"boolean" shadowsCoreMapping false)
        (§ field #_"String" source nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
    )

    (§ constructor #_"DefExpr" DefExpr [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Var" ___var, #_"Expr" ___init, #_"Expr" ___meta, #_"boolean" ___initProvided, #_"boolean" ___isDynamic, #_"boolean" ___shadowsCoreMapping]
        (let [this (ß super())]
            (§ ass (ß this.source) ___source)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (§ ass (ß this.var) ___var)
            (§ ass (ß this.init) ___init)
            (§ ass (ß this.meta) ___meta)
            (§ ass (ß this.isDynamic) ___isDynamic)
            (§ ass (ß this.shadowsCoreMapping) ___shadowsCoreMapping)
            (§ ass (ß this.initProvided) ___initProvided)
            this
        )
    )

    #_method
    (§ defn- #_"boolean" includesExplicitMetadata [#_"DefExpr" this, #_"MapExpr" ___expr]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___expr.keyvals.count()) [(§ ass ___i (ß ___i + 2))]
            (let [#_"Keyword" ___k (ß ((KeywordExpr) ___expr.keyvals.nth(___i)).k)]
                (when (ß (___k != RT'FILE_KEY) && (___k != RT'DECLARED_KEY) && (___k != RT'LINE_KEY) && (___k != RT'COLUMN_KEY))
                    (§ return true)
                )
            )
        )
        false
    )

    #_method
    (§ defn #_"Object" eval [#_"DefExpr" this]
        (try
            (when initProvided
                (ß var.bindRoot(init.eval()))
            )
            (when (some? meta)
                (let [#_"IPersistentMap" ___metaMap (ß (IPersistentMap) meta.eval())]
                    (when (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                        (ß var.setMeta(___metaMap))
                    )
                )
            )
            (ß var.setDynamic(isDynamic))
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException(source, line, column, ___e)))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emit [#_"DefExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitVar(___gen, var))

        (when shadowsCoreMapping
            (ß ___gen.dup())
            (ß ___gen.getField(VAR_TYPE, "ns", NS_TYPE))
            (ß ___gen.swap())
            (ß ___gen.dup())
            (ß ___gen.getField(VAR_TYPE, "sym", SYMBOL_TYPE))
            (ß ___gen.swap())
            (ß ___gen.invokeVirtual(NS_TYPE, DefExpr'internVar))
        )

        (when isDynamic
            (ß ___gen.push(isDynamic))
            (ß ___gen.invokeVirtual(VAR_TYPE, setDynamicMethod))
        )
        (when (some? meta)
            (when (ß initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                (ß ___gen.dup())
                (ß meta.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(IPERSISTENTMAP_TYPE))
                (ß ___gen.invokeVirtual(VAR_TYPE, setMetaMethod))
            )
        )
        (when initProvided
            (ß ___gen.dup())
            (if (ß init instanceof FnExpr)
                (do
                    (ß ((FnExpr)init).emitForDefn(___objx, ___gen))
                )
                (do
                    (ß init.emit(:Context'EXPRESSION, ___objx, ___gen))
                )
            )
            (ß ___gen.invokeVirtual(VAR_TYPE, bindRootMethod))
        )

        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"DefExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"DefExpr" this]
        (§ class Var)
    )
)

#_stateless
(class-ns AssignParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"AssignParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß RT'length(___form) != 3)
                (throw (ß new IllegalArgumentException("Malformed assignment, expecting (set! target val)")))
            )
            (let [#_"Expr" ___target (ß analyze(:Context'EXPRESSION, RT'second(___form)))]
                (when (ß !(___target instanceof AssignableExpr))
                    (throw (IllegalArgumentException. "Invalid assignment target"))
                )
                (ß new AssignExpr((AssignableExpr) ___target, analyze(:Context'EXPRESSION, RT'third(___form))))
            )
        )
    )
)

(class-ns AssignExpr (§ implements Expr)
    (§ init
        (§ field #_"AssignableExpr" target nil)
        (§ field #_"Expr" val nil)
    )

    (§ constructor #_"AssignExpr" AssignExpr [#_"AssignableExpr" ___target, #_"Expr" ___val]
        (let [this (ß super())]
            (§ ass (ß this.target) ___target)
            (§ ass (ß this.val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"AssignExpr" this]
        (ß target.evalAssign(val))
    )

    #_method
    (§ defn #_"void" emit [#_"AssignExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß target.emitAssign(___context, ___objx, ___gen, val))
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"AssignExpr" this]
        (ß val.hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"AssignExpr" this]
        (ß val.getJavaClass())
    )
)

(class-ns VarExpr (§ implements Expr, AssignableExpr)
    (§ def #_"Method" VarExpr'getMethod (ß Method/getMethod("Object get()")))
    (§ def #_"Method" VarExpr'setMethod (ß Method/getMethod("Object set(Object)")))

    (§ init
        (§ field #_"Var" var nil)
        (§ field #_"Object" tag nil)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"VarExpr" VarExpr [#_"Var" ___var, #_"Symbol" ___tag]
        (let [this (ß super())]
            (§ ass (ß this.var) ___var)
            (§ ass (ß this.tag) (ß (___tag != nil) ? ___tag :or ___var.getTag()))
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"VarExpr" this]
        (ß var.deref())
    )

    #_method
    (§ defn #_"void" emit [#_"VarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitVarValue(___gen, var))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"VarExpr" this]
        (ß (tag != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"VarExpr" this]
        (when (nil? jc)
            (§ ass jc (ß HostExpr'tagToClass(tag)))
        )
        jc
    )

    #_method
    (§ defn #_"Object" evalAssign [#_"VarExpr" this, #_"Expr" ___val]
        (ß var.set(___val.eval()))
    )

    #_method
    (§ defn #_"void" emitAssign [#_"VarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (ß ___objx.emitVar(___gen, var))
        (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.invokeVirtual(VAR_TYPE, VarExpr'setMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )
)

#_stateless
(class-ns TheVarParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"TheVarParser" this, #_"Context" ___context, #_"Object" ___form]
        (let [#_"Symbol" ___sym (ß (Symbol) RT'second(___form))]
            (let [#_"Var" ___v (ß lookupVar(___sym, false))]
                (when (some? ___v)
                    (§ return (TheVarExpr. ___v))
                )
                (throw (ß Util'runtimeException("Unable to resolve var: " + ___sym + " in this context")))
            )
        )
    )
)

(class-ns TheVarExpr (§ implements Expr)
    (§ init
        (§ field #_"Var" var nil)
    )

    (§ constructor #_"TheVarExpr" TheVarExpr [#_"Var" ___var]
        (let [this (ß super())]
            (§ ass (ß this.var) ___var)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"TheVarExpr" this]
        var
    )

    #_method
    (§ defn #_"void" emit [#_"TheVarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitVar(___gen, var))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"TheVarExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"TheVarExpr" this]
        (§ class Var)
    )
)

(class-ns KeywordExpr (§ extends LiteralExpr)
    (§ init
        (§ field #_"Keyword" k nil)
    )

    (§ constructor #_"KeywordExpr" KeywordExpr [#_"Keyword" ___k]
        (let [this (ß super())]
            (§ ass (ß this.k) ___k)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"KeywordExpr" this]
        k
    )

    #_method
    (§ defn #_"Object" eval [#_"KeywordExpr" this]
        k
    )

    #_method
    (§ defn #_"void" emit [#_"KeywordExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitKeyword(___gen, k))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"KeywordExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"KeywordExpr" this]
        (§ class Keyword)
    )
)

#_stateless
(class-ns ImportParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"ImportParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß new ImportExpr((String) RT'second(___form)))
    )
)

(class-ns ImportExpr (§ implements Expr)
    (§ def #_"Method" ImportExpr'forNameMethod (ß Method/getMethod("Class classForNameNonLoading(String)")))
    (§ def #_"Method" ImportExpr'importClassMethod (ß Method/getMethod("Class importClass(Class)")))
    (§ def #_"Method" ImportExpr'derefMethod (ß Method/getMethod("Object deref()")))

    (§ init
        (§ field #_"String" c nil)
    )

    (§ constructor #_"ImportExpr" ImportExpr [#_"String" ___c]
        (let [this (ß super())]
            (§ ass (ß this.c) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"ImportExpr" this]
        (let [#_"Namespace" ___ns (ß (Namespace) RT'CURRENT_NS.deref())]
            (ß ___ns.importClass(RT'classForNameNonLoading(c)))
            nil
        )
    )

    #_method
    (§ defn #_"void" emit [#_"ImportExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.getStatic(RT_TYPE, "CURRENT_NS", VAR_TYPE))
        (ß ___gen.invokeVirtual(VAR_TYPE, ImportExpr'derefMethod))
        (ß ___gen.checkCast(NS_TYPE))
        (ß ___gen.push(c))
        (ß ___gen.invokeStatic(RT_TYPE, forNameMethod))
        (ß ___gen.invokeVirtual(NS_TYPE, importClassMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"ImportExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"ImportExpr" this]
        (throw (IllegalArgumentException. "ImportExpr has no Java class"))
    )
)

#_stateless
#_abstract
(class-ns LiteralExpr (§ implements Expr)
    #_abstract
    (§ defn #_"Object" val [#_"LiteralExpr" this])

    #_method
    (§ defn #_"Object" eval [#_"LiteralExpr" this]
        (ß val())
    )
)

(defprotocol AssignableExpr
    #_abstract
    (#_"Object" AssignableExpr'''evalAssign [#_"AssignableExpr" this, #_"Expr" ___val])
    #_abstract
    (#_"void" AssignableExpr'''emitAssign [#_"AssignableExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val])
)

(defprotocol MaybePrimitiveExpr #_(§ extends Expr)
    #_abstract
    (#_"boolean" MaybePrimitiveExpr'''canEmitPrimitive [#_"MaybePrimitiveExpr" this])
    #_abstract
    (#_"void" MaybePrimitiveExpr'''emitUnboxed [#_"MaybePrimitiveExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen])
)

#_stateless
(class-ns HostParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"HostParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (. x fieldname-sym) or
            ;; (. x 0-ary-method)
            ;; (. x methodname-sym args+)
            ;; (. x (methodname-sym args?))
            (when (ß RT'length(___form) < 3)
                (throw (ß new IllegalArgumentException("Malformed member expression, expecting (. target member ...)")))
            )
            ;; determine static or instance
            ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
            (let [#_"int" ___line (ß lineDeref())]
                (let [#_"int" ___column (ß columnDeref())]
                    (let [#_"String" ___source (ß (String) SOURCE.deref())]
                        (let [#_"Class" ___c (ß maybeClass(RT'second(___form), false))]
                            ;; at this point c will be non-null if static
                            (let [#_"Expr" ___instance nil]
                                (when (nil? ___c)
                                    (§ ass ___instance (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, RT'second(___form))))
                                )

                                (let [#_"boolean" ___maybeField (ß (RT'length(___form) == 3) && (RT'third(___form) instanceof Symbol))]
                                    (when (ß ___maybeField && !(((Symbol)RT'third(___form)).name.charAt(0) == \-))
                                        (let [#_"Symbol" ___sym (ß (Symbol) RT'third(___form))]
                                            (cond (some? ___c)
                                                (do
                                                    (§ ass ___maybeField (ß Reflector'getMethods(___c, 0, munge(___sym.name), true).size() == 0))
                                                )
                                                (ß ___instance != nil && ___instance.hasJavaClass() && ___instance.getJavaClass() != nil)
                                                (do
                                                    (§ ass ___maybeField (ß Reflector'getMethods(___instance.getJavaClass(), 0, munge(___sym.name), false).size() == 0))
                                                )
                                            )
                                        )
                                    )

                                    (if ___maybeField ;; field
                                        (do
                                            (let [#_"Symbol" ___sym (ß (((Symbol)RT'third(___form)).name.charAt(0) == \-) ? Symbol'intern(((Symbol)RT'third(___form)).name.substring(1)) :or (Symbol) RT'third(___form))]
                                                (let [#_"Symbol" ___tag (ß tagOf(___form))]
                                                    (if (some? ___c)
                                                        (do
                                                            (ß new StaticFieldExpr(___line, ___column, ___c, munge(___sym.name), ___tag))
                                                        )
                                                        (do
                                                            (ß new InstanceFieldExpr(___line, ___column, ___instance, munge(___sym.name), ___tag, (((Symbol)RT'third(___form)).name.charAt(0) == \-)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (let [#_"ISeq" ___call (ß (ISeq) ((RT'third(___form) instanceof ISeq) ? RT'third(___form) :or RT'next(RT'next(___form))))]
                                                (when (ß !(RT'first(___call) instanceof Symbol))
                                                    (throw (IllegalArgumentException. "Malformed member expression"))
                                                )
                                                (let [#_"Symbol" ___sym (ß (Symbol) RT'first(___call))]
                                                    (let [#_"Symbol" ___tag (ß tagOf(___form))]
                                                        (let [#_"PersistentVector" ___args (ß PersistentVector'EMPTY)]
                                                            (let [#_"boolean" ___tailPosition (ß inTailCall(___context))]
                                                                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'next(___call)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                                                    (§ ass ___args (ß ___args.cons(analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___s.first()))))
                                                                )
                                                                (if (some? ___c)
                                                                    (do
                                                                        (ß new StaticMethodExpr(___source, ___line, ___column, ___tag, ___c, munge(___sym.name), ___args, ___tailPosition))
                                                                    )
                                                                    (do
                                                                        (ß new InstanceMethodExpr(___source, ___line, ___column, ___tag, ___instance, munge(___sym.name), ___args, ___tailPosition))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
#_abstract
(class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ def #_"Type" HostExpr'BOOLEAN_TYPE (ß Type/getType((§ class Boolean))))
    (§ def #_"Type" HostExpr'CHAR_TYPE (ß Type/getType((§ class Character))))
    (§ def #_"Type" HostExpr'INTEGER_TYPE (ß Type/getType((§ class Integer))))
    (§ def #_"Type" HostExpr'LONG_TYPE (ß Type/getType((§ class Long))))
    (§ def #_"Type" HostExpr'FLOAT_TYPE (ß Type/getType((§ class Float))))
    (§ def #_"Type" HostExpr'DOUBLE_TYPE (ß Type/getType((§ class Double))))
    (§ def #_"Type" HostExpr'SHORT_TYPE (ß Type/getType((§ class Short))))
    (§ def #_"Type" HostExpr'BYTE_TYPE (ß Type/getType((§ class Byte))))
    (§ def #_"Type" HostExpr'NUMBER_TYPE (ß Type/getType((§ class Number))))

    (§ def #_"Method" HostExpr'charValueMethod (ß Method/getMethod("char charValue()")))
    (§ def #_"Method" HostExpr'booleanValueMethod (ß Method/getMethod("boolean booleanValue()")))

    (§ def #_"Method" HostExpr'charValueOfMethod (ß Method/getMethod("Character valueOf(char)")))
    (§ def #_"Method" HostExpr'intValueOfMethod (ß Method/getMethod("Integer valueOf(int)")))
    (§ def #_"Method" HostExpr'longValueOfMethod (ß Method/getMethod("Long valueOf(long)")))
    (§ def #_"Method" HostExpr'floatValueOfMethod (ß Method/getMethod("Float valueOf(float)")))
    (§ def #_"Method" HostExpr'doubleValueOfMethod (ß Method/getMethod("Double valueOf(double)")))
    (§ def #_"Method" HostExpr'shortValueOfMethod (ß Method/getMethod("Short valueOf(short)")))
    (§ def #_"Method" HostExpr'byteValueOfMethod (ß Method/getMethod("Byte valueOf(byte)")))

    (§ def #_"Method" HostExpr'intValueMethod (ß Method/getMethod("int intValue()")))
    (§ def #_"Method" HostExpr'longValueMethod (ß Method/getMethod("long longValue()")))
    (§ def #_"Method" HostExpr'floatValueMethod (ß Method/getMethod("float floatValue()")))
    (§ def #_"Method" HostExpr'doubleValueMethod (ß Method/getMethod("double doubleValue()")))
    (§ def #_"Method" HostExpr'byteValueMethod (ß Method/getMethod("byte byteValue()")))
    (§ def #_"Method" HostExpr'shortValueMethod (ß Method/getMethod("short shortValue()")))

    (§ def #_"Method" HostExpr'fromIntMethod (ß Method/getMethod("cloiure.lang.Num from(int)")))
    (§ def #_"Method" HostExpr'fromLongMethod (ß Method/getMethod("cloiure.lang.Num from(long)")))
    (§ def #_"Method" HostExpr'fromDoubleMethod (ß Method/getMethod("cloiure.lang.Num from(double)")))

    (§ defn #_"void" HostExpr'emitBoxReturn [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___returnType]
        (when (ß ___returnType.isPrimitive())
            (cond (ß ___returnType == (§ class boolean))
                (do
                    (let [#_"Label" ___falseLabel (ß ___gen.newLabel())]
                        (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
                            (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___falseLabel))
                            (ß ___gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                            (ß ___gen.goTo(___endLabel))
                            (ß ___gen.mark(___falseLabel))
                            (ß ___gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                            (ß ___gen.mark(___endLabel))
                        )
                    )
                )
                (ß ___returnType == (§ class void))
                (do
                    (ß NIL_EXPR.emit(:Context'EXPRESSION, ___objx, ___gen))
                )
                (ß ___returnType == (§ class char))
                (do
                    (ß ___gen.invokeStatic(CHAR_TYPE, charValueOfMethod))
                )
                :else
                (do
                    (cond (ß ___returnType == (§ class int))
                        (do
                            (ß ___gen.invokeStatic(INTEGER_TYPE, intValueOfMethod))
                        )
                        (ß ___returnType == (§ class float))
                        (do
                            (ß ___gen.invokeStatic(FLOAT_TYPE, floatValueOfMethod))
                        )
                        (ß ___returnType == (§ class double))
                        (do
                            (ß ___gen.invokeStatic(DOUBLE_TYPE, doubleValueOfMethod))
                        )
                        (ß ___returnType == (§ class long))
                        (do
                            (ß ___gen.invokeStatic(NUMBERS_TYPE, Method/getMethod("Number num(long)")))
                        )
                        (ß ___returnType == (§ class byte))
                        (do
                            (ß ___gen.invokeStatic(BYTE_TYPE, byteValueOfMethod))
                        )
                        (ß ___returnType == (§ class short))
                        (do
                            (ß ___gen.invokeStatic(SHORT_TYPE, shortValueOfMethod))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"void" HostExpr'emitUnboxArg [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___paramType]
        (if (ß ___paramType.isPrimitive())
            (do
                (cond (ß ___paramType == (§ class boolean))
                    (do
                        (ß ___gen.checkCast(BOOLEAN_TYPE))
                        (ß ___gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod))
                    )
                    (ß ___paramType == (§ class char))
                    (do
                        (ß ___gen.checkCast(CHAR_TYPE))
                        (ß ___gen.invokeVirtual(CHAR_TYPE, charValueMethod))
                    )
                    :else
                    (do
                        (let [#_"Method" ___m nil]
                            (ß ___gen.checkCast(NUMBER_TYPE))
                            (if (ß RT'booleanCast(RT'UNCHECKED_MATH.deref()))
                                (do
                                    (cond (ß ___paramType == (§ class int))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("int uncheckedIntCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class float))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("float uncheckedFloatCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class double))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("double uncheckedDoubleCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class long))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("long uncheckedLongCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class byte))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("byte uncheckedByteCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class short))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("short uncheckedShortCast(Object)")))
                                        )
                                    )
                                )
                                (do
                                    (cond (ß ___paramType == (§ class int))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("int intCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class float))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("float floatCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class double))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("double doubleCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class long))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("long longCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class byte))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("byte byteCast(Object)")))
                                        )
                                        (ß ___paramType == (§ class short))
                                        (do
                                            (§ ass ___m (ß Method/getMethod("short shortCast(Object)")))
                                        )
                                    )
                                )
                            )
                            (ß ___gen.invokeStatic(RT_TYPE, ___m))
                        )
                    )
                )
            )
            (do
                (ß ___gen.checkCast(Type/getType(___paramType)))
            )
        )
        nil
    )

    (§ defn #_"Class" HostExpr'maybeClass [#_"Object" ___form, #_"boolean" ___stringOk]
        (when (ß ___form instanceof Class)
            (§ return (ß (Class) ___form))
        )
        (let [#_"Class" ___c nil]
            (cond (ß ___form instanceof Symbol)
                (do
                    (let [#_"Symbol" ___sym (ß (Symbol) ___form)]
                        (when (ß ___sym.ns == nil) ;; if ns-qualified can't be classname
                            (when (ß Util'equals(___sym, COMPILE_STUB_SYM.get()))
                                (§ return (ß (Class) COMPILE_STUB_CLASS.get()))
                            )
                            (if (ß ___sym.name.indexOf(\.) > 0 || ___sym.name.charAt(0) == \[)
                                (do
                                    (§ ass ___c (ß RT'classForNameNonLoading(___sym.name)))
                                )
                                (do
                                    (let [#_"Object" ___o (ß currentNS().getMapping(___sym))]
                                        (cond (ß ___o instanceof Class)
                                            (do
                                                (§ ass ___c (ß (Class) ___o))
                                            )
                                            (ß LOCAL_ENV.deref() != nil && ((java.util.Map)LOCAL_ENV.deref()).containsKey(___form))
                                            (do
                                                (§ return nil)
                                            )
                                            :else
                                            (do
                                                (try
                                                    (§ ass ___c (ß RT'classForNameNonLoading(___sym.name)))
                                                    (catch Exception ___e
                                                        ;; aargh
                                                        ;; leave c set to nil -> return nil
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (ß ___stringOk && ___form instanceof String)
                (do
                    (§ ass ___c (ß RT'classForNameNonLoading((String) ___form)))
                )
            )
            c
        )
    )

    (§ defn #_"Class" HostExpr'maybeSpecialTag [#_"Symbol" ___sym]
        (let [#_"Class" ___c (ß primClass(___sym))]
            (cond (some? ___c)
                (do
                    (§ return ___c)
                )
                (ß ___sym.name.equals("objects"))
                (do
                    (§ ass ___c (§ class Object[]))
                )
                (ß ___sym.name.equals("ints"))
                (do
                    (§ ass ___c (§ class int[]))
                )
                (ß ___sym.name.equals("longs"))
                (do
                    (§ ass ___c (§ class long[]))
                )
                (ß ___sym.name.equals("floats"))
                (do
                    (§ ass ___c (§ class float[]))
                )
                (ß ___sym.name.equals("doubles"))
                (do
                    (§ ass ___c (§ class double[]))
                )
                (ß ___sym.name.equals("chars"))
                (do
                    (§ ass ___c (§ class char[]))
                )
                (ß ___sym.name.equals("shorts"))
                (do
                    (§ ass ___c (§ class short[]))
                )
                (ß ___sym.name.equals("bytes"))
                (do
                    (§ ass ___c (§ class byte[]))
                )
                (ß ___sym.name.equals("booleans"))
                (do
                    (§ ass ___c (§ class boolean[]))
                )
            )
            c
        )
    )

    (§ defn #_"Class" HostExpr'tagToClass [#_"Object" ___tag]
        (let [#_"Class" ___c nil]
            (when (ß ___tag instanceof Symbol)
                (let [#_"Symbol" ___sym (ß (Symbol) ___tag)]
                    (when (ß ___sym.ns == nil) ;; if ns-qualified can't be classname
                        (§ ass ___c (ß maybeSpecialTag(___sym)))
                    )
                )
            )
            (when (nil? ___c)
                (§ ass ___c (ß maybeClass(___tag, true)))
            )
            (when (some? ___c)
                (§ return ___c)
            )
            (throw (IllegalArgumentException. (ß "Unable to resolve classname: " + ___tag)))
        )
    )
)

#_stateless
#_abstract
(class-ns FieldExpr (§ extends HostExpr)
)

(class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (§ def #_"Method" InstanceFieldExpr'invokeNoArgInstanceMember (ß Method/getMethod("Object invokeNoArgInstanceMember(Object,String,boolean)")))
    (§ def #_"Method" InstanceFieldExpr'setInstanceFieldMethod (ß Method/getMethod("Object setInstanceField(Object,String,Object)")))

    (§ init
        (§ field #_"Expr" target nil)
        (§ field #_"Class" targetClass nil)
        (§ field #_"java.lang.reflect.Field" field nil)
        (§ field #_"String" fieldName nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
        (§ field #_"Symbol" tag nil)
        (§ field #_"boolean" requireField false)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"InstanceFieldExpr" InstanceFieldExpr [#_"int" ___line, #_"int" ___column, #_"Expr" ___target, #_"String" ___fieldName, #_"Symbol" ___tag, #_"boolean" ___requireField]
        (let [this (ß super())]
            (§ ass (ß this.target) ___target)
            (§ ass (ß this.targetClass) (ß ___target.hasJavaClass() ? ___target.getJavaClass() :or nil))
            (§ ass (ß this.field) (ß (targetClass != nil) ? Reflector'getField(targetClass, ___fieldName, false) :or nil))
            (§ ass (ß this.fieldName) ___fieldName)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (§ ass (ß this.tag) ___tag)
            (§ ass (ß this.requireField) ___requireField)

            (when (ß field == nil && RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                (if (nil? targetClass)
                    (do
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", SOURCE_PATH.deref(), ___line, ___column, ___fieldName))
                    )
                    (do
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", SOURCE_PATH.deref(), ___line, ___column, ___fieldName, targetClass.getName()))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"InstanceFieldExpr" this]
        (ß Reflector'invokeNoArgInstanceMember(target.eval(), fieldName, requireField))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"InstanceFieldExpr" this]
        (ß (targetClass != nil && field != nil && Util'isPrimitive(field.getType())))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß targetClass != nil && field != nil)
            (do
                (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.checkCast(getType(targetClass)))
                (ß ___gen.getField(getType(targetClass), fieldName, Type/getType(field.getType())))
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß targetClass != nil && field != nil)
            (do
                (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.checkCast(getType(targetClass)))
                (ß ___gen.getField(getType(targetClass), fieldName, Type/getType(field.getType())))
                (ß HostExpr'emitBoxReturn(___objx, ___gen, field.getType()))
                (when (ß ___context == :Context'STATEMENT)
                    (ß ___gen.pop())
                )
            )
            (do
                (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.push(fieldName))
                (ß ___gen.push(requireField))
                (ß ___gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstanceMember))
                (when (ß ___context == :Context'STATEMENT)
                    (ß ___gen.pop())
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"InstanceFieldExpr" this]
        (ß (field != nil || tag != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"InstanceFieldExpr" this]
        (when (nil? jc)
            (§ ass jc (ß (tag != nil) ? HostExpr'tagToClass(tag) :or field.getType()))
        )
        jc
    )

    #_method
    (§ defn #_"Object" evalAssign [#_"InstanceFieldExpr" this, #_"Expr" ___val]
        (ß Reflector'setInstanceField(target.eval(), fieldName, ___val.eval()))
    )

    #_method
    (§ defn #_"void" emitAssign [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (if (ß targetClass != nil && field != nil)
            (do
                (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(getType(targetClass)))
                (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.dupX1())
                (ß HostExpr'emitUnboxArg(___objx, ___gen, field.getType()))
                (ß ___gen.putField(getType(targetClass), fieldName, Type/getType(field.getType())))
            )
            (do
                (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.push(fieldName))
                (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.invokeStatic(REFLECTOR_TYPE, InstanceFieldExpr'setInstanceFieldMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )
)

(class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (§ init
        (§ field #_"String" fieldName nil)
        (§ field #_"Class" c nil)
        (§ field #_"java.lang.reflect.Field" field nil)
        (§ field #_"Symbol" tag nil)

        (§ field #_"int" line 0)
        (§ field #_"int" column 0)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"StaticFieldExpr" StaticFieldExpr [#_"int" ___line, #_"int" ___column, #_"Class" ___c, #_"String" ___fieldName, #_"Symbol" ___tag]
        (let [this (ß super())]
            (§ ass (ß this.fieldName) ___fieldName)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (§ ass (ß this.c) ___c)
            (try
                (§ ass field (ß ___c.getField(___fieldName)))
                (catch NoSuchFieldException ___e
                    (throw (ß Util'sneakyThrow(___e)))
                )
            )
            (§ ass (ß this.tag) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"StaticFieldExpr" this]
        (ß Reflector'getStaticField(c, fieldName))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"StaticFieldExpr" this]
        (ß Util'isPrimitive(field.getType()))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitLineNumber(line, ___gen.mark()))
        (ß ___gen.getStatic(Type/getType(c), fieldName, Type/getType(field.getType())))
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitLineNumber(line, ___gen.mark()))

        (ß ___gen.getStatic(Type/getType(c), fieldName, Type/getType(field.getType())))
        (ß HostExpr'emitBoxReturn(___objx, ___gen, field.getType()))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"StaticFieldExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"StaticFieldExpr" this]
        (when (nil? jc)
            (§ ass jc (ß (tag != nil) ? HostExpr'tagToClass(tag) :or field.getType()))
        )
        jc
    )

    #_method
    (§ defn #_"Object" evalAssign [#_"StaticFieldExpr" this, #_"Expr" ___val]
        (ß Reflector'setStaticField(c, fieldName, ___val.eval()))
    )

    #_method
    (§ defn #_"void" emitAssign [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.visitLineNumber(line, ___gen.mark()))
        (ß ___gen.dup())
        (ß HostExpr'emitUnboxArg(___objx, ___gen, field.getType()))
        (ß ___gen.putStatic(Type/getType(c), fieldName, Type/getType(field.getType())))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )
)

#_stateless
#_abstract
(class-ns MethodExpr (§ extends HostExpr)
    (§ defn #_"void" MethodExpr'emitArgsAsArray [#_"IPersistentVector" ___args, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.push(___args.count()))
        (ß ___gen.newArray(OBJECT_TYPE))
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___args.count()) [(§ ass ___i (ß ___i + 1))]
            (ß ___gen.dup())
            (ß ___gen.push(___i))
            (ß ((Expr) ___args.nth(___i)).emit(:Context'EXPRESSION, ___objx, ___gen))
            (ß ___gen.arrayStore(OBJECT_TYPE))
        )
        nil
    )

    (§ defn #_"void" MethodExpr'emitTypedArgs [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class[]" ___parameterTypes, #_"IPersistentVector" ___args]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___parameterTypes.length) [(§ ass ___i (ß ___i + 1))]
            (let [#_"Expr" ___e (ß (Expr) ___args.nth(___i))]
                (try
                    (let [#_"Class" ___primc (ß maybePrimitiveType(___e))]
                        (cond (ß ___primc == ___parameterTypes[___i])
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                )
                            )
                            (ß ___primc == (§ class int) && ___parameterTypes[___i] == (§ class long))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß ___gen.visitInsn(I2L))
                                )
                            )
                            (ß ___primc == (§ class long) && ___parameterTypes[___i] == (§ class int))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (if (ß RT'booleanCast(RT'UNCHECKED_MATH.deref()))
                                        (do
                                            (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("int uncheckedIntCast(long)")))
                                        )
                                        (do
                                            (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("int intCast(long)")))
                                        )
                                    )
                                )
                            )
                            (ß ___primc == (§ class float) && ___parameterTypes[___i] == (§ class double))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß ___gen.visitInsn(F2D))
                                )
                            )
                            (ß ___primc == (§ class double) && ___parameterTypes[___i] == (§ class float))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß ___gen.visitInsn(D2F))
                                )
                            )
                            :else
                            (do
                                (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (ß HostExpr'emitUnboxArg(___objx, ___gen, ___parameterTypes[___i]))
                            )
                        )
                    )
                    (catch Exception ___e1
                        (throw (ß Util'sneakyThrow(___e1)))
                    )
                )
            )
        )
        nil
    )
)

(class-ns InstanceMethodExpr (§ extends MethodExpr)
    (§ def #_"Method" InstanceMethodExpr'invokeInstanceMethodMethod (ß Method/getMethod("Object invokeInstanceMethod(Object,String,Object[])")))

    (§ init
        (§ field #_"Expr" target nil)
        (§ field #_"String" methodName nil)
        (§ field #_"IPersistentVector" args nil)
        (§ field #_"String" source nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
        (§ field #_"Symbol" tag nil)
        (§ field #_"boolean" tailPosition false)
        (§ field #_"java.lang.reflect.Method" method nil)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"InstanceMethodExpr" InstanceMethodExpr [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Expr" ___target, #_"String" ___methodName, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (ß super())]
            (§ ass (ß this.source) ___source)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (§ ass (ß this.args) ___args)
            (§ ass (ß this.methodName) ___methodName)
            (§ ass (ß this.target) ___target)
            (§ ass (ß this.tag) ___tag)
            (§ ass (ß this.tailPosition) ___tailPosition)
            (if (ß ___target.hasJavaClass() && ___target.getJavaClass() != nil)
                (do
                    (let [#_"List" ___methods (ß Reflector'getMethods(___target.getJavaClass(), ___args.count(), ___methodName, false))]
                        (if (ß ___methods.isEmpty())
                            (do
                                (§ ass method nil)
                                (when (ß RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                                    (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", SOURCE_PATH.deref(), ___line, ___column, ___methodName, ___target.getJavaClass().getName()))
                                )
                            )
                            (do
                                (let [#_"int" ___methodidx 0]
                                    (when (ß ___methods.size() > 1)
                                        (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                                            (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___methods.size()) [(§ ass ___i (ß ___i + 1))]
                                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___methods.get(___i))]
                                                        (ß ___params.add(___m.getParameterTypes()))
                                                        (ß ___rets.add(___m.getReturnType()))
                                                    )
                                                )
                                                (§ ass ___methodidx (ß getMatchingParams(___methodName, ___params, ___args, ___rets)))
                                            )
                                        )
                                    )
                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ((___methodidx >= 0) ? ___methods.get(___methodidx) :or nil))]
                                        (when (ß ___m != nil && !Modifier/isPublic(___m.getDeclaringClass().getModifiers()))
                                            ;; public method of non-public class, try to find it in hierarchy
                                            (§ ass ___m (ß Reflector'getAsMethodOfPublicBase(___m.getDeclaringClass(), ___m)))
                                        )
                                        (§ ass method ___m)
                                        (when (ß method == nil && RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                                            (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), ___line, ___column, ___methodName, ___target.getJavaClass().getName(), getTypeStringForArgs(___args)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (§ ass method nil)
                    (when (ß RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", SOURCE_PATH.deref(), ___line, ___column, ___methodName))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"InstanceMethodExpr" this]
        (try
            (let [#_"Object" ___targetval (ß target.eval())]
                (let [#_"Object[]" ___argvals (ß new Object[args.count()])]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < args.count()) [(§ ass ___i (ß ___i + 1))]
                        (§ ass (ß ___argvals[___i]) (ß ((Expr) args.nth(___i)).eval()))
                    )
                    (when (some? method)
                        (let [#_"LinkedList" ___ms (LinkedList.)]
                            (ß ___ms.add(method))
                            (§ return (ß Reflector'invokeMatchingMethod(methodName, ___ms, ___targetval, ___argvals)))
                        )
                    )
                    (ß Reflector'invokeInstanceMethod(___targetval, methodName, ___argvals))
                )
            )
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException(source, line, column, ___e)))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"InstanceMethodExpr" this]
        (ß (method != nil && Util'isPrimitive(method.getReturnType())))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"InstanceMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? method)
            (do
                (let [#_"Type" ___type (ß Type/getType(method.getDeclaringClass()))]
                    (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.checkCast(___type))
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, method.getParameterTypes(), args))
                    (ß ___gen.visitLineNumber(line, ___gen.mark()))
                    (when (ß tailPosition && !___objx.canBeDirect)
                        (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                            (ß ___method.emitClearThis(___gen))
                        )
                    )
                    (let [#_"Method" ___m (ß new Method(methodName, Type/getReturnType(method), Type/getArgumentTypes(method)))]
                        (if (ß method.getDeclaringClass().isInterface())
                            (do
                                (ß ___gen.invokeInterface(___type, ___m))
                            )
                            (do
                                (ß ___gen.invokeVirtual(___type, ___m))
                            )
                        )
                    )
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"InstanceMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? method)
            (do
                (let [#_"Type" ___type (ß Type/getType(method.getDeclaringClass()))]
                    (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.checkCast(___type))
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, method.getParameterTypes(), args))
                    (ß ___gen.visitLineNumber(line, ___gen.mark()))
                    (when (ß ___context == :Context'RETURN)
                        (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                            (ß ___method.emitClearLocals(___gen))
                        )
                    )
                    (let [#_"Method" ___m (ß new Method(methodName, Type/getReturnType(method), Type/getArgumentTypes(method)))]
                        (if (ß method.getDeclaringClass().isInterface())
                            (do
                                (ß ___gen.invokeInterface(___type, ___m))
                            )
                            (do
                                (ß ___gen.invokeVirtual(___type, ___m))
                            )
                        )
                        (ß HostExpr'emitBoxReturn(___objx, ___gen, method.getReturnType()))
                    )
                )
            )
            (do
                (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.push(methodName))
                (ß emitArgsAsArray(args, ___objx, ___gen))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                        (ß ___method.emitClearLocals(___gen))
                    )
                )
                (ß ___gen.invokeStatic(REFLECTOR_TYPE, InstanceMethodExpr'invokeInstanceMethodMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"InstanceMethodExpr" this]
        (ß (method != nil || tag != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"InstanceMethodExpr" this]
        (when (nil? jc)
            (§ ass jc (ß retType((tag != nil) ? HostExpr'tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil)))
        )
        jc
    )
)

(class-ns StaticMethodExpr (§ extends MethodExpr)
    (§ def #_"Method" StaticMethodExpr'forNameMethod (ß Method/getMethod("Class classForName(String)")))
    (§ def #_"Method" StaticMethodExpr'invokeStaticMethodMethod (ß Method/getMethod("Object invokeStaticMethod(Class,String,Object[])")))
    (§ def #_"Keyword" StaticMethodExpr'warnOnBoxedKeyword (ß Keyword'intern("warn-on-boxed")))

    (§ init
        (§ field #_"Class" c nil)
        (§ field #_"String" methodName nil)
        (§ field #_"IPersistentVector" args nil)
        (§ field #_"String" source nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
        (§ field #_"java.lang.reflect.Method" method nil)
        (§ field #_"Symbol" tag nil)
        (§ field #_"boolean" tailPosition false)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"StaticMethodExpr" StaticMethodExpr [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Class" ___c, #_"String" ___methodName, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (ß super())]
            (§ ass (ß this.c) ___c)
            (§ ass (ß this.methodName) ___methodName)
            (§ ass (ß this.args) ___args)
            (§ ass (ß this.source) ___source)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (§ ass (ß this.tag) ___tag)
            (§ ass (ß this.tailPosition) ___tailPosition)

            (let [#_"List" ___methods (ß Reflector'getMethods(___c, ___args.count(), ___methodName, true))]
                (when (ß ___methods.isEmpty())
                    (throw (IllegalArgumentException. (ß "No matching method: " + ___methodName)))
                )

                (let [#_"int" ___methodidx 0]
                    (when (ß ___methods.size() > 1)
                        (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                            (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___methods.size()) [(§ ass ___i (ß ___i + 1))]
                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___methods.get(___i))]
                                        (ß ___params.add(___m.getParameterTypes()))
                                        (ß ___rets.add(___m.getReturnType()))
                                    )
                                )
                                (§ ass ___methodidx (ß getMatchingParams(___methodName, ___params, ___args, ___rets)))
                            )
                        )
                    )
                    (§ ass method (ß (java.lang.reflect.Method) ((___methodidx >= 0) ? ___methods.get(___methodidx) :or nil)))
                    (when (ß method == nil && RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), ___line, ___column, ___methodName, ___c.getName(), getTypeStringForArgs(___args)))
                    )
                    (when (ß method != nil && warnOnBoxedKeyword.equals(RT'UNCHECKED_MATH.deref()) && StaticMethodExpr'isBoxedMath(method))
                        (ß RT'errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", SOURCE_PATH.deref(), ___line, ___column, method.toString()))
                    )
                    this
                )
            )
        )
    )

    (§ defn #_"boolean" StaticMethodExpr'isBoxedMath [#_"java.lang.reflect.Method" ___m]
        (let [#_"Class" ___c (ß ___m.getDeclaringClass())]
            (when (ß ___c.equals((§ class Numbers)))
                (let [#_"Class[]" ___argTypes (ß ___m.getParameterTypes())]
                    (doseq [#_"Class" ___argType ___argTypes]
                        (when (ß ___argType.equals((§ class Object)) || ___argType.equals((§ class Number)))
                            (§ return true)
                        )
                    )
                )
            )
            false
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"StaticMethodExpr" this]
        (try
            (let [#_"Object[]" ___argvals (ß new Object[args.count()])]
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < args.count()) [(§ ass ___i (ß ___i + 1))]
                    (§ ass (ß ___argvals[___i]) (ß ((Expr) args.nth(___i)).eval()))
                )
                (when (some? method)
                    (let [#_"LinkedList" ___ms (LinkedList.)]
                        (ß ___ms.add(method))
                        (§ return (ß Reflector'invokeMatchingMethod(methodName, ___ms, nil, ___argvals)))
                    )
                )
                (ß Reflector'invokeStaticMethod(c, methodName, ___argvals))
            )
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException(source, line, column, ___e)))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"StaticMethodExpr" this]
        (ß (method != nil && Util'isPrimitive(method.getReturnType())))
    )

    #_method
    (§ defn #_"boolean" canEmitIntrinsicPredicate [#_"StaticMethodExpr" this]
        (ß (method != nil && RT'get(Intrinsics'preds, method.toString()) != nil))
    )

    #_method
    (§ defn #_"void" emitIntrinsicPredicate [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Label" ___falseLabel]
        (ß ___gen.visitLineNumber(line, ___gen.mark()))
        (if (some? method)
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, method.getParameterTypes(), args))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                        (ß ___method.emitClearLocals(___gen))
                    )
                )
                (let [#_"Object[]" ___predOps (ß (Object[]) RT'get(Intrinsics'preds, method.toString()))]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___predOps.length - 1) [(§ ass ___i (ß ___i + 1))]
                        (ß ___gen.visitInsn((Integer)___predOps[___i]))
                    )
                    (ß ___gen.visitJumpInsn((Integer)___predOps[___predOps.length - 1], ___falseLabel))
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? method)
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, method.getParameterTypes(), args))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                        (ß ___method.emitClearLocals(___gen))
                    )
                )
                (let [#_"Object" ___ops (ß RT'get(Intrinsics'ops, method.toString()))]
                    (if (some? ___ops)
                        (do
                            (if (ß ___ops instanceof Object[])
                                (do
                                    (doseq [#_"Object" ___op (ß (Object[])___ops)]
                                        (ß ___gen.visitInsn((Integer) ___op))
                                    )
                                )
                                (do
                                    (ß ___gen.visitInsn((Integer) ___ops))
                                )
                            )
                        )
                        (do
                            (let [#_"Type" ___type (ß Type/getType(c))]
                                (let [#_"Method" ___m (ß new Method(methodName, Type/getReturnType(method), Type/getArgumentTypes(method)))]
                                    (ß ___gen.invokeStatic(___type, ___m))
                                )
                            )
                        )
                    )
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? method)
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, method.getParameterTypes(), args))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (when (ß tailPosition && !___objx.canBeDirect)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                        (ß ___method.emitClearThis(___gen))
                    )
                )
                (let [#_"Type" ___type (ß Type/getType(c))]
                    (let [#_"Method" ___m (ß new Method(methodName, Type/getReturnType(method), Type/getArgumentTypes(method)))]
                        (ß ___gen.invokeStatic(___type, ___m))
                        (let [#_"Class" ___retClass (ß method.getReturnType())]
                            (if (ß ___context == :Context'STATEMENT)
                                (do
                                    (cond (ß ___retClass == (§ class long) || ___retClass == (§ class double))
                                        (do
                                            (ß ___gen.pop2())
                                        )
                                        (ß ___retClass != (§ class void))
                                        (do
                                            (ß ___gen.pop())
                                        )
                                    )
                                )
                                (do
                                    (ß HostExpr'emitBoxReturn(___objx, ___gen, method.getReturnType()))
                                )
                            )
                        )
                    )
                )
            )
            (do
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.push(c.getName()))
                (ß ___gen.invokeStatic(RT_TYPE, forNameMethod))
                (ß ___gen.push(methodName))
                (ß emitArgsAsArray(args, ___objx, ___gen))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                        (ß ___method.emitClearLocals(___gen))
                    )
                )
                (ß ___gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodMethod))
                (when (ß ___context == :Context'STATEMENT)
                    (ß ___gen.pop())
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"StaticMethodExpr" this]
        (ß (method != nil || tag != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"StaticMethodExpr" this]
        (when (nil? jc)
            (§ ass jc (ß retType((tag != nil) ? HostExpr'tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil)))
        )
        jc
    )
)

(class-ns UnresolvedVarExpr (§ implements Expr)
    (§ init
        (§ field #_"Symbol" symbol nil)
    )

    (§ constructor #_"UnresolvedVarExpr" UnresolvedVarExpr [#_"Symbol" ___symbol]
        (let [this (ß super())]
            (§ ass (ß this.symbol) ___symbol)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"UnresolvedVarExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr has no Java class"))
    )

    #_method
    (§ defn #_"void" emit [#_"UnresolvedVarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"Object" eval [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr cannot be evalled"))
    )
)

(class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
    (§ init
        (§ field #_"Number" n nil)
        (§ field #_"int" id 0)
    )

    (§ constructor #_"NumberExpr" NumberExpr [#_"Number" ___n]
        (let [this (ß super())]
            (§ ass (ß this.n) ___n)
            (§ ass (ß this.id) (ß registerConstant(___n)))
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"NumberExpr" this]
        n
    )

    #_method
    (§ defn #_"void" emit [#_"NumberExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (ß ___objx.emitConstant(___gen, id))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"NumberExpr" this]
        (cond (ß n instanceof Integer)
            (do
                (§ class long)
            )
            (ß n instanceof Double)
            (do
                (§ class double)
            )
            (ß n instanceof Long)
            (do
                (§ class long)
            )
            :else
            (do
                (throw (ß new IllegalStateException("Unsupported Number type: " + n.getClass().getName())))
            )
        )
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"NumberExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (cond (ß n instanceof Integer)
            (do
                (ß ___gen.push(n.longValue()))
            )
            (ß n instanceof Double)
            (do
                (ß ___gen.push(n.doubleValue()))
            )
            (ß n instanceof Long)
            (do
                (ß ___gen.push(n.longValue()))
            )
        )
        nil
    )

    (§ defn #_"Expr" NumberExpr'parse [#_"Number" ___form]
        (if (ß ___form instanceof Integer || ___form instanceof Double || ___form instanceof Long)
            (do
                (NumberExpr. ___form)
            )
            (do
                (ConstantExpr. ___form)
            )
        )
    )
)

#_stateless
(class-ns ConstantParser (§ implements IParser)
    (§ def #_"Keyword" ConstantParser'formKey (ß Keyword'intern("form")))

    #_method
    (§ defn #_"Expr" parse [#_"ConstantParser" this, #_"Context" ___context, #_"Object" ___form]
        (let [#_"int" ___argCount (ß RT'count(___form) - 1)]
            (when (ß ___argCount != 1)
                (let [#_"IPersistentMap" ___exData (ß new PersistentArrayMap(new Object[] (§ array ConstantParser'formKey, ___form )))]
                    (throw (ß new ExceptionInfo("Wrong number of args (" + ___argCount + ") passed to quote", ___exData)))
                )
            )
            (let [#_"Object" ___v (ß RT'second(___form))]
                (cond (nil? ___v)
                    (do
                        (§ return NIL_EXPR)
                    )
                    (ß ___v == Boolean/TRUE)
                    (do
                        (§ return TRUE_EXPR)
                    )
                    (ß ___v == Boolean/FALSE)
                    (do
                        (§ return FALSE_EXPR)
                    )
                )
                (cond (ß ___v instanceof Number)
                    (do
                        (ß NumberExpr'parse((Number)___v))
                    )
                    (ß ___v instanceof String)
                    (do
                        (ß new StringExpr((String) ___v))
                    )
                    (ß ___v instanceof IPersistentCollection && ((IPersistentCollection) ___v).count() == 0)
                    (do
                        (EmptyExpr. ___v)
                    )
                    :else
                    (do
                        (ConstantExpr. ___v)
                    )
                )
            )
        )
    )
)

(class-ns ConstantExpr (§ extends LiteralExpr)
    (§ init
        ;; stuff quoted vals in classloader at compile time, pull out at runtime
        ;; this won't work for static compilation...
        (§ field #_"Object" v nil)
        (§ field #_"int" id 0)
    )

    (§ constructor #_"ConstantExpr" ConstantExpr [#_"Object" ___v]
        (let [this (ß super())]
            (§ ass (ß this.v) ___v)
            (§ ass (ß this.id) (ß registerConstant(___v)))
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"ConstantExpr" this]
        v
    )

    #_method
    (§ defn #_"void" emit [#_"ConstantExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitConstant(___gen, id))

        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"ConstantExpr" this]
        (ß Modifier/isPublic(v.getClass().getModifiers()))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"ConstantExpr" this]
        (cond (ß v instanceof APersistentMap)
            (do
                (§ class APersistentMap)
            )
            (ß v instanceof APersistentSet)
            (do
                (§ class APersistentSet)
            )
            (ß v instanceof APersistentVector)
            (do
                (§ class APersistentVector)
            )
            :else
            (do
                (ß v.getClass())
            )
        )
    )
)

#_stateless
(class-ns NilExpr (§ extends LiteralExpr)
    #_method
    (§ defn #_"Object" val [#_"NilExpr" this]
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"NilExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"NilExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"NilExpr" this]
        nil
    )
)

(class-ns BooleanExpr (§ extends LiteralExpr)
    (§ init
        (§ field #_"boolean" val false)
    )

    (§ constructor #_"BooleanExpr" BooleanExpr [#_"boolean" ___val]
        (let [this (ß super())]
            (§ ass (ß this.val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"BooleanExpr" this]
        (ß val ? RT'T :or RT'F)
    )

    #_method
    (§ defn #_"void" emit [#_"BooleanExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if val
            (do
                (ß ___gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
            )
            (do
                (ß ___gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"BooleanExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"BooleanExpr" this]
        (§ class Boolean)
    )
)

(class-ns StringExpr (§ extends LiteralExpr)
    (§ init
        (§ field #_"String" str nil)
    )

    (§ constructor #_"StringExpr" StringExpr [#_"String" ___str]
        (let [this (ß super())]
            (§ ass (ß this.str) ___str)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"StringExpr" this]
        str
    )

    #_method
    (§ defn #_"void" emit [#_"StringExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (ß ___gen.push(str))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"StringExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"StringExpr" this]
        (§ class String)
    )
)

#_stateless
(class-ns MonitorEnterParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"MonitorEnterParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß new MonitorEnterExpr(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns MonitorEnterExpr (§ extends UntypedExpr)
    (§ init
        (§ field #_"Expr" target nil)
    )

    (§ constructor #_"MonitorEnterExpr" MonitorEnterExpr [#_"Expr" ___target]
        (let [this (ß super())]
            (§ ass (ß this.target) ___target)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MonitorEnterExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-enter"))
    )

    #_method
    (§ defn #_"void" emit [#_"MonitorEnterExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.monitorEnter())
        (ß NIL_EXPR.emit(___context, ___objx, ___gen))
        nil
    )
)

#_stateless
(class-ns MonitorExitParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"MonitorExitParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß new MonitorExitExpr(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns MonitorExitExpr (§ extends UntypedExpr)
    (§ init
        (§ field #_"Expr" target nil)
    )

    (§ constructor #_"MonitorExitExpr" MonitorExitExpr [#_"Expr" ___target]
        (let [this (ß super())]
            (§ ass (ß this.target) ___target)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MonitorExitExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-exit"))
    )

    #_method
    (§ defn #_"void" emit [#_"MonitorExitExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß target.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.monitorExit())
        (ß NIL_EXPR.emit(___context, ___objx, ___gen))
        nil
    )
)

(class-ns CatchClause
    (§ init
        (§ field #_"Class" c nil)
        (§ field #_"LocalBinding" lb nil)
        (§ field #_"Expr" handler nil)
        (§ field #_"Label" label nil)
        (§ field #_"Label" endLabel nil)
    )

    (§ constructor #_"CatchClause" CatchClause [#_"Class" ___c, #_"LocalBinding" ___lb, #_"Expr" ___handler]
        (let [this (ß super())]
            (§ ass (ß this.c) ___c)
            (§ ass (ß this.lb) ___lb)
            (§ ass (ß this.handler) ___handler)
            this
        )
    )
)

#_stateless
(class-ns TryParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"TryParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß ___context != :Context'RETURN)
                (§ return (ß analyze(___context, RT'list(RT'list(FNONCE, PersistentVector'EMPTY, ___form)))))
            )

            ;; (try try-expr* catch-expr* finally-expr?)
            ;; catch-expr: (catch class sym expr*)
            ;; finally-expr: (finally expr*)

            (let [#_"PersistentVector" ___body (ß PersistentVector'EMPTY)]
                (let [#_"PersistentVector" ___catches (ß PersistentVector'EMPTY)]
                    (let [#_"Expr" ___bodyExpr nil]
                        (let [#_"Expr" ___finallyExpr nil]
                            (let [#_"boolean" ___caught false]
                                (let [#_"int" ___retLocal (ß getAndIncLocalNum())]
                                    (let [#_"int" ___finallyLocal (ß getAndIncLocalNum())]
                                        (loop-when-recur [(§ var #_"ISeq" ___fs (ß ___form.next()))] (some? ___fs) [(§ ass ___fs (ß ___fs.next()))]
                                            (let [#_"Object" ___f (ß ___fs.first())]
                                                (let [#_"Object" ___op (ß (___f instanceof ISeq) ? ((ISeq) ___f).first() :or nil)]
                                                    (if (ß !Util'equals(___op, CATCH) && !Util'equals(___op, FINALLY))
                                                        (do
                                                            (when ___caught
                                                                (throw (ß Util'runtimeException("Only catch or finally clause can follow catch in try expression")))
                                                            )
                                                            (§ ass ___body (ß ___body.cons(___f)))
                                                        )
                                                        (do
                                                            (when (nil? ___bodyExpr)
                                                                (try
                                                                    (ß Var'pushThreadBindings(RT'map(NO_RECUR, true, METHOD_RETURN_CONTEXT, nil)))
                                                                    (§ ass ___bodyExpr (ß (new BodyParser()).parse(___context, RT'seq(___body))))
                                                                    (finally
                                                                        (ß Var'popThreadBindings())
                                                                    )
                                                                )
                                                            )

                                                            (cond (ß Util'equals(___op, CATCH))
                                                                (do
                                                                    (let [#_"Class" ___c (ß HostExpr'maybeClass(RT'second(___f), false))]
                                                                        (when (nil? ___c)
                                                                            (throw (ß new IllegalArgumentException("Unable to resolve classname: " + RT'second(___f))))
                                                                        )
                                                                        (when (ß !(RT'third(___f) instanceof Symbol))
                                                                            (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + RT'third(___f))))
                                                                        )
                                                                        (let [#_"Symbol" ___sym (ß (Symbol) RT'third(___f))]
                                                                            (when (ß ___sym.getNamespace() != nil)
                                                                                (throw (ß Util'runtimeException("Can't bind qualified name:" + ___sym)))
                                                                            )

                                                                            (let [#_"IPersistentMap" ___dynamicBindings (ß RT'map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(), IN_CATCH_FINALLY, RT'T))]
                                                                                (try
                                                                                    (ß Var'pushThreadBindings(___dynamicBindings))
                                                                                    (let [#_"LocalBinding" ___lb (ß registerLocal(___sym, (Symbol) ((RT'second(___f) instanceof Symbol) ? RT'second(___f) :or nil), nil, false))]
                                                                                        (let [#_"Expr" ___handler (ß (new BodyParser()).parse(:Context'EXPRESSION, RT'next(RT'next(RT'next(___f)))))]
                                                                                            (§ ass ___catches (ß ___catches.cons(new CatchClause(___c, ___lb, ___handler))))
                                                                                        )
                                                                                    )
                                                                                    (finally
                                                                                        (ß Var'popThreadBindings())
                                                                                    )
                                                                                )
                                                                                (§ ass ___caught true)
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                :else ;; finally
                                                                (do
                                                                    (when (ß ___fs.next() != nil)
                                                                        (throw (ß Util'runtimeException("finally clause must be last in try expression")))
                                                                    )
                                                                    (try
                                                                        (ß Var'pushThreadBindings(RT'map(IN_CATCH_FINALLY, RT'T)))
                                                                        (§ ass ___finallyExpr (ß (new BodyParser()).parse(:Context'STATEMENT, RT'next(___f))))
                                                                        (finally
                                                                            (ß Var'popThreadBindings())
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (when (nil? ___bodyExpr)
                                            ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                                            ;; return a body expr directly
                                            (try
                                                (ß Var'pushThreadBindings(RT'map(NO_RECUR, true)))
                                                (§ ass ___bodyExpr (ß (new BodyParser()).parse(___context, RT'seq(___body))))
                                                (finally
                                                    (ß Var'popThreadBindings())
                                                )
                                            )
                                            (§ return ___bodyExpr)
                                        )

                                        (ß new TryExpr(___bodyExpr, ___catches, ___finallyExpr, ___retLocal, ___finallyLocal))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns TryExpr (§ implements Expr)
    (§ init
        (§ field #_"Expr" tryExpr nil)
        (§ field #_"Expr" finallyExpr nil)
        (§ field #_"PersistentVector" catchExprs nil)
        (§ field #_"int" retLocal 0)
        (§ field #_"int" finallyLocal 0)
    )

    (§ constructor #_"TryExpr" TryExpr [#_"Expr" ___tryExpr, #_"PersistentVector" ___catchExprs, #_"Expr" ___finallyExpr, #_"int" ___retLocal, #_"int" ___finallyLocal]
        (let [this (ß super())]
            (§ ass (ß this.tryExpr) ___tryExpr)
            (§ ass (ß this.catchExprs) ___catchExprs)
            (§ ass (ß this.finallyExpr) ___finallyExpr)
            (§ ass (ß this.retLocal) ___retLocal)
            (§ ass (ß this.finallyLocal) ___finallyLocal)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"TryExpr" this]
        (throw (UnsupportedOperationException. "Can't eval try"))
    )

    #_method
    (§ defn #_"void" emit [#_"TryExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___startTry (ß ___gen.newLabel())]
            (let [#_"Label" ___endTry (ß ___gen.newLabel())]
                (let [#_"Label" ___end (ß ___gen.newLabel())]
                    (let [#_"Label" ___ret (ß ___gen.newLabel())]
                        (let [#_"Label" ___finallyLabel (ß ___gen.newLabel())]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < catchExprs.count()) [(§ ass ___i (ß ___i + 1))]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) catchExprs.nth(___i))]
                                    (§ ass (ß ___clause.label) (ß ___gen.newLabel()))
                                    (§ ass (ß ___clause.endLabel) (ß ___gen.newLabel()))
                                )
                            )

                            (ß ___gen.mark(___startTry))
                            (ß tryExpr.emit(___context, ___objx, ___gen))
                            (when (ß ___context != :Context'STATEMENT)
                                (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), retLocal))
                            )
                            (ß ___gen.mark(___endTry))
                            (when (some? finallyExpr)
                                (ß finallyExpr.emit(:Context'STATEMENT, ___objx, ___gen))
                            )
                            (ß ___gen.goTo(___ret))

                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < catchExprs.count()) [(§ ass ___i (ß ___i + 1))]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) catchExprs.nth(___i))]
                                    (ß ___gen.mark(___clause.label))
                                    ;; exception should be on stack
                                    ;; put in clause local
                                    (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___clause.lb.idx))
                                    (ß ___clause.handler.emit(___context, ___objx, ___gen))
                                    (when (ß ___context != :Context'STATEMENT)
                                        (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), retLocal))
                                    )
                                    (ß ___gen.mark(___clause.endLabel))

                                    (when (some? finallyExpr)
                                        (ß finallyExpr.emit(:Context'STATEMENT, ___objx, ___gen))
                                    )
                                    (ß ___gen.goTo(___ret))
                                )
                            )
                            (when (some? finallyExpr)
                                (ß ___gen.mark(___finallyLabel))
                                ;; exception should be on stack
                                (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), finallyLocal))
                                (ß finallyExpr.emit(:Context'STATEMENT, ___objx, ___gen))
                                (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ILOAD), finallyLocal))
                                (ß ___gen.throwException())
                            )
                            (ß ___gen.mark(___ret))
                            (when (ß ___context != :Context'STATEMENT)
                                (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ILOAD), retLocal))
                            )
                            (ß ___gen.mark(___end))
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < catchExprs.count()) [(§ ass ___i (ß ___i + 1))]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) catchExprs.nth(___i))]
                                    (ß ___gen.visitTryCatchBlock(___startTry, ___endTry, ___clause.label, ___clause.c.getName().replace(\., \/)))
                                )
                            )
                            (when (some? finallyExpr)
                                (ß ___gen.visitTryCatchBlock(___startTry, ___endTry, ___finallyLabel, nil))
                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < catchExprs.count()) [(§ ass ___i (ß ___i + 1))]
                                    (let [#_"CatchClause" ___clause (ß (CatchClause) catchExprs.nth(___i))]
                                        (ß ___gen.visitTryCatchBlock(___clause.label, ___clause.endLabel, ___finallyLabel, nil))
                                    )
                                )
                            )
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < catchExprs.count()) [(§ ass ___i (ß ___i + 1))]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) catchExprs.nth(___i))]
                                    (ß ___gen.visitLocalVariable(___clause.lb.name, "Ljava/lang/Object;", nil, ___clause.label, ___clause.endLabel, ___clause.lb.idx))
                                )
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"TryExpr" this]
        (ß tryExpr.hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"TryExpr" this]
        (ß tryExpr.getJavaClass())
    )
)

#_stateless
(class-ns ThrowParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"ThrowParser" this, #_"Context" ___context, #_"Object" ___form]
        (cond (ß ___context == :Context'EVAL)
            (do
                (§ return (ß analyze(___context, RT'list(RT'list(FNONCE, PersistentVector'EMPTY, ___form)))))
            )
            (ß RT'count(___form) == 1)
            (do
                (throw (ß Util'runtimeException("Too few arguments to throw, throw expects a single Throwable instance")))
            )
            (ß RT'count(___form) > 2)
            (do
                (throw (ß Util'runtimeException("Too many arguments to throw, throw expects a single Throwable instance")))
            )
        )
        (ß new ThrowExpr(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns ThrowExpr (§ extends UntypedExpr)
    (§ init
        (§ field #_"Expr" excExpr nil)
    )

    (§ constructor #_"ThrowExpr" ThrowExpr [#_"Expr" ___excExpr]
        (let [this (ß super())]
            (§ ass (ß this.excExpr) ___excExpr)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"ThrowExpr" this]
        (throw (ß Util'runtimeException("Can't eval throw")))
    )

    #_method
    (§ defn #_"void" emit [#_"ThrowExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß excExpr.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(THROWABLE_TYPE))
        (ß ___gen.throwException())
        nil
    )
)

#_stateless
(class-ns NewParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"NewParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"int" ___line (ß lineDeref())]
            (let [#_"int" ___column (ß columnDeref())]
                (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
                    ;; (new Classname args...)
                    (when (ß ___form.count() < 2)
                        (throw (ß Util'runtimeException("wrong number of arguments, expecting: (new Classname args...)")))
                    )
                    (let [#_"Class" ___c (ß HostExpr'maybeClass(RT'second(___form), false))]
                        (when (nil? ___c)
                            (throw (ß new IllegalArgumentException("Unable to resolve classname: " + RT'second(___form))))
                        )
                        (let [#_"PersistentVector" ___args (ß PersistentVector'EMPTY)]
                            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'next(RT'next(___form))))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                (§ ass ___args (ß ___args.cons(analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___s.first()))))
                            )
                            (ß new NewExpr(___c, ___args, ___line, ___column))
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewExpr (§ implements Expr)
    (§ def #_"Method" NewExpr'invokeConstructorMethod (ß Method/getMethod("Object invokeConstructor(Class,Object[])")))
    (§ def #_"Method" NewExpr'forNameMethod (ß Method/getMethod("Class classForName(String)")))

    (§ init
        (§ field #_"IPersistentVector" args nil)
        (§ field #_"Constructor" ctor nil)
        (§ field #_"Class" c nil)
    )

    (§ constructor #_"NewExpr" NewExpr [#_"Class" ___c, #_"IPersistentVector" ___args, #_"int" ___line, #_"int" ___column]
        (let [this (ß super())]
            (§ ass (ß this.args) ___args)
            (§ ass (ß this.c) ___c)
            (let [#_"Constructor[]" ___allctors (ß ___c.getConstructors())]
                (let [#_"ArrayList" ___ctors (ArrayList.)]
                    (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                        (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___allctors.length) [(§ ass ___i (ß ___i + 1))]
                                (let [#_"Constructor" ___ctor (ß ___allctors[___i])]
                                    (when (ß ___ctor.getParameterTypes().length == ___args.count())
                                        (ß ___ctors.add(___ctor))
                                        (ß ___params.add(___ctor.getParameterTypes()))
                                        (ß ___rets.add(___c))
                                    )
                                )
                            )
                            (when (ß ___ctors.isEmpty())
                                (throw (IllegalArgumentException. (ß "No matching ctor found for " + ___c)))
                            )

                            (let [#_"int" ___ctoridx 0]
                                (when (ß ___ctors.size() > 1)
                                    (§ ass ___ctoridx (ß getMatchingParams(___c.getName(), ___params, ___args, ___rets)))
                                )

                                (§ ass (ß this.ctor) (ß (___ctoridx >= 0) ? (Constructor) ___ctors.get(___ctoridx) :or nil))
                                (when (ß ctor == nil && RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                                    (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", SOURCE_PATH.deref(), ___line, ___column, ___c.getName()))
                                )
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"NewExpr" this]
        (let [#_"Object[]" ___argvals (ß new Object[args.count()])]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < args.count()) [(§ ass ___i (ß ___i + 1))]
                (§ ass (ß ___argvals[___i]) (ß ((Expr) args.nth(___i)).eval()))
            )
            (when (ß this.ctor != nil)
                (try
                    (§ return (ß ctor.newInstance(Reflector'boxArgs(ctor.getParameterTypes(), ___argvals))))
                    (catch Exception ___e
                        (throw (ß Util'sneakyThrow(___e)))
                    )
                )
            )
            (ß Reflector'invokeConstructor(c, ___argvals))
        )
    )

    #_method
    (§ defn #_"void" emit [#_"NewExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß this.ctor != nil)
            (do
                (let [#_"Type" ___type (ß getType(c))]
                    (ß ___gen.newInstance(___type))
                    (ß ___gen.dup())
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, ctor.getParameterTypes(), args))
                    (ß ___gen.invokeConstructor(___type, new Method("<init>", Type/getConstructorDescriptor(ctor))))
                )
            )
            (do
                (ß ___gen.push(destubClassName(c.getName())))
                (ß ___gen.invokeStatic(RT_TYPE, NewExpr'forNameMethod))
                (ß MethodExpr'emitArgsAsArray(args, ___objx, ___gen))
                (ß ___gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"NewExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"NewExpr" this]
        c
    )
)

(class-ns MetaExpr (§ implements Expr)
    (§ def #_"Type" MetaExpr'IOBJ_TYPE (ß Type/getType((§ class IObj))))
    (§ def #_"Method" MetaExpr'withMetaMethod (ß Method/getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))

    (§ init
        (§ field #_"Expr" expr nil)
        (§ field #_"Expr" meta nil)
    )

    (§ constructor #_"MetaExpr" MetaExpr [#_"Expr" ___expr, #_"Expr" ___meta]
        (let [this (ß super())]
            (§ ass (ß this.expr) ___expr)
            (§ ass (ß this.meta) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MetaExpr" this]
        (ß ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval()))
    )

    #_method
    (§ defn #_"void" emit [#_"MetaExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß expr.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(IOBJ_TYPE))
        (ß meta.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(IPERSISTENTMAP_TYPE))
        (ß ___gen.invokeInterface(IOBJ_TYPE, MetaExpr'withMetaMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"MetaExpr" this]
        (ß expr.hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"MetaExpr" this]
        (ß expr.getJavaClass())
    )
)

#_stateless
(class-ns IfParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"IfParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (if test then) or (if test then else)
            (cond (ß ___form.count() > 4)
                (do
                    (throw (ß Util'runtimeException("Too many arguments to if")))
                )
                (ß ___form.count() < 3)
                (do
                    (throw (ß Util'runtimeException("Too few arguments to if")))
                )
            )
            (let [#_"PathNode" ___branch (ß new PathNode(:PathType'BRANCH, (PathNode) CLEAR_PATH.get()))]
                (let [#_"Expr" ___testexpr (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, RT'second(___form)))]
                    (let [(ß Expr thenexpr, elseexpr)]
                        (try
                            (ß Var'pushThreadBindings(RT'map(CLEAR_PATH, new PathNode(:PathType'PATH, ___branch))))
                            (§ ass thenexpr (ß analyze(___context, RT'third(___form))))
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                        (try
                            (ß Var'pushThreadBindings(RT'map(CLEAR_PATH, new PathNode(:PathType'PATH, ___branch))))
                            (§ ass elseexpr (ß analyze(___context, RT'fourth(___form))))
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                        (ß new IfExpr(lineDeref(), columnDeref(), ___testexpr, thenexpr, elseexpr))
                    )
                )
            )
        )
    )
)

(class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ init
        (§ field #_"Expr" testExpr nil)
        (§ field #_"Expr" thenExpr nil)
        (§ field #_"Expr" elseExpr nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
    )

    (§ constructor #_"IfExpr" IfExpr [#_"int" ___line, #_"int" ___column, #_"Expr" ___testExpr, #_"Expr" ___thenExpr, #_"Expr" ___elseExpr]
        (let [this (ß super())]
            (§ ass (ß this.testExpr) ___testExpr)
            (§ ass (ß this.thenExpr) ___thenExpr)
            (§ ass (ß this.elseExpr) ___elseExpr)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"IfExpr" this]
        (let [#_"Object" ___t (ß testExpr.eval())]
            (when (ß ___t != nil && ___t != Boolean/FALSE)
                (§ return (ß thenExpr.eval()))
            )
            (ß elseExpr.eval())
        )
    )

    #_method
    (§ defn #_"void" emit [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, false))
        nil
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, true))
        nil
    )

    #_method
    (§ defn #_"void" doEmit [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"Label" ___nullLabel (ß ___gen.newLabel())]
            (let [#_"Label" ___falseLabel (ß ___gen.newLabel())]
                (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
                    (ß ___gen.visitLineNumber(line, ___gen.mark()))

                    (cond (ß testExpr instanceof StaticMethodExpr && ((StaticMethodExpr)testExpr).canEmitIntrinsicPredicate())
                        (do
                            (ß ((StaticMethodExpr) testExpr).emitIntrinsicPredicate(:Context'EXPRESSION, ___objx, ___gen, ___falseLabel))
                        )
                        (ß maybePrimitiveType(testExpr) == (§ class boolean))
                        (do
                            (ß ((MaybePrimitiveExpr) testExpr).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                            (ß ___gen.ifZCmp(___gen.EQ, ___falseLabel))
                        )
                        :else
                        (do
                            (ß testExpr.emit(:Context'EXPRESSION, ___objx, ___gen))
                            (ß ___gen.dup())
                            (ß ___gen.ifNull(___nullLabel))
                            (ß ___gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                            (ß ___gen.visitJumpInsn(IF_ACMPEQ, ___falseLabel))
                        )
                    )
                    (if ___emitUnboxed
                        (do
                            (ß ((MaybePrimitiveExpr)thenExpr).emitUnboxed(___context, ___objx, ___gen))
                        )
                        (do
                            (ß thenExpr.emit(___context, ___objx, ___gen))
                        )
                    )
                    (ß ___gen.goTo(___endLabel))
                    (ß ___gen.mark(___nullLabel))
                    (ß ___gen.pop())
                    (ß ___gen.mark(___falseLabel))
                    (if ___emitUnboxed
                        (do
                            (ß ((MaybePrimitiveExpr)elseExpr).emitUnboxed(___context, ___objx, ___gen))
                        )
                        (do
                            (ß elseExpr.emit(___context, ___objx, ___gen))
                        )
                    )
                    (ß ___gen.mark(___endLabel))
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"IfExpr" this]
        (ß thenExpr.hasJavaClass()
            && elseExpr.hasJavaClass()
            && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                || thenExpr.getJavaClass() == RECUR_CLASS
                || elseExpr.getJavaClass() == RECUR_CLASS
                || (thenExpr.getJavaClass() == nil && !elseExpr.getJavaClass().isPrimitive())
                || (elseExpr.getJavaClass() == nil && !thenExpr.getJavaClass().isPrimitive())))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"IfExpr" this]
        (try
            (ß thenExpr instanceof MaybePrimitiveExpr
                && elseExpr instanceof MaybePrimitiveExpr
                && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                        || thenExpr.getJavaClass() == RECUR_CLASS
                        || elseExpr.getJavaClass() == RECUR_CLASS)
                && ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
                && ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive())
            (catch Exception ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"IfExpr" this]
        (let [#_"Class" ___thenClass (ß thenExpr.getJavaClass())]
            (when (ß ___thenClass != nil && ___thenClass != RECUR_CLASS)
                (§ return ___thenClass)
            )
            (ß elseExpr.getJavaClass())
        )
    )
)

(class-ns EmptyExpr (§ implements Expr)
    (§ def #_"Type" EmptyExpr'HASHMAP_TYPE (ß Type/getType((§ class PersistentArrayMap))))
    (§ def #_"Type" EmptyExpr'HASHSET_TYPE (ß Type/getType((§ class PersistentHashSet))))
    (§ def #_"Type" EmptyExpr'VECTOR_TYPE (ß Type/getType((§ class PersistentVector))))
    (§ def #_"Type" EmptyExpr'IVECTOR_TYPE (ß Type/getType((§ class IPersistentVector))))
    (§ def #_"Type" EmptyExpr'TUPLE_TYPE (ß Type/getType((§ class Tuple))))
    (§ def #_"Type" EmptyExpr'LIST_TYPE (ß Type/getType((§ class PersistentList))))
    (§ def #_"Type" EmptyExpr'EMPTY_LIST_TYPE (ß Type/getType((§ class EmptyList))))

    (§ init
        (§ field #_"Object" coll nil)
    )

    (§ constructor #_"EmptyExpr" EmptyExpr [#_"Object" ___coll]
        (let [this (ß super())]
            (§ ass (ß this.coll) ___coll)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"EmptyExpr" this]
        coll
    )

    #_method
    (§ defn #_"void" emit [#_"EmptyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (cond (ß coll instanceof IPersistentList)
            (do
                (ß ___gen.getStatic(LIST_TYPE, "EMPTY", EmptyExpr'EMPTY_LIST_TYPE))
            )
            (ß coll instanceof IPersistentVector)
            (do
                (ß ___gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE))
            )
            (ß coll instanceof IPersistentMap)
            (do
                (ß ___gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE))
            )
            (ß coll instanceof IPersistentSet)
            (do
                (ß ___gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Unknown Collection type"))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"EmptyExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"EmptyExpr" this]
        (cond (ß coll instanceof IPersistentList)
            (do
                (§ class IPersistentList)
            )
            (ß coll instanceof IPersistentVector)
            (do
                (§ class IPersistentVector)
            )
            (ß coll instanceof IPersistentMap)
            (do
                (§ class IPersistentMap)
            )
            (ß coll instanceof IPersistentSet)
            (do
                (§ class IPersistentSet)
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Unknown Collection type"))
            )
        )
    )
)

(class-ns ListExpr (§ implements Expr)
    (§ def #_"Method" ListExpr'arrayToListMethod (ß Method/getMethod("cloiure.lang.ISeq arrayToList(Object[])")))

    (§ init
        (§ field #_"IPersistentVector" args nil)
    )

    (§ constructor #_"ListExpr" ListExpr [#_"IPersistentVector" ___args]
        (let [this (ß super())]
            (§ ass (ß this.args) ___args)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"ListExpr" this]
        (let [#_"IPersistentVector" ___ret (ß PersistentVector'EMPTY)]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < args.count()) [(§ ass ___i (ß ___i + 1))]
                (§ ass ___ret (ß (IPersistentVector) ___ret.cons(((Expr) args.nth(___i)).eval())))
            )
            (ß ___ret.seq())
        )
    )

    #_method
    (§ defn #_"void" emit [#_"ListExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß MethodExpr'emitArgsAsArray(args, ___objx, ___gen))
        (ß ___gen.invokeStatic(RT_TYPE, ListExpr'arrayToListMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"ListExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"ListExpr" this]
        (§ class IPersistentList)
    )
)

(class-ns MapExpr (§ implements Expr)
    (§ def #_"Method" MapExpr'mapMethod (ß Method/getMethod("cloiure.lang.IPersistentMap map(Object[])")))
    (§ def #_"Method" MapExpr'mapUniqueKeysMethod (ß Method/getMethod("cloiure.lang.IPersistentMap mapUniqueKeys(Object[])")))

    (§ init
        (§ field #_"IPersistentVector" keyvals nil)
    )

    (§ constructor #_"MapExpr" MapExpr [#_"IPersistentVector" ___keyvals]
        (let [this (ß super())]
            (§ ass (ß this.keyvals) ___keyvals)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MapExpr" this]
        (let [#_"Object[]" ___ret (ß new Object[keyvals.count()])]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < keyvals.count()) [(§ ass ___i (ß ___i + 1))]
                (§ ass (ß ___ret[___i]) (ß ((Expr) keyvals.nth(___i)).eval()))
            )
            (ß RT'map(___ret))
        )
    )

    #_method
    (§ defn #_"void" emit [#_"MapExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"boolean" ___allKeysConstant true]
            (let [#_"boolean" ___allConstantKeysUnique true]
                (let [#_"IPersistentSet" ___constantKeys (ß PersistentHashSet'EMPTY)]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < keyvals.count()) [(ß ___i += 2)]
                        (let [#_"Expr" ___k (ß (Expr) keyvals.nth(___i))]
                            (if (ß ___k instanceof LiteralExpr)
                                (do
                                    (let [#_"Object" ___kval (ß ___k.eval())]
                                        (if (ß ___constantKeys.contains(___kval))
                                            (do
                                                (§ ass ___allConstantKeysUnique false)
                                            )
                                            (do
                                                (§ ass ___constantKeys (ß (IPersistentSet)___constantKeys.cons(___kval)))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (§ ass ___allKeysConstant false)
                                )
                            )
                        )
                    )
                    (ß MethodExpr'emitArgsAsArray(keyvals, ___objx, ___gen))
                    (if (ß (___allKeysConstant && ___allConstantKeysUnique) || (keyvals.count() <= 2))
                        (do
                            (ß ___gen.invokeStatic(RT_TYPE, mapUniqueKeysMethod))
                        )
                        (do
                            (ß ___gen.invokeStatic(RT_TYPE, mapMethod))
                        )
                    )
                    (when (ß ___context == :Context'STATEMENT)
                        (ß ___gen.pop())
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"MapExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"MapExpr" this]
        (§ class IPersistentMap)
    )

    (§ defn #_"Expr" MapExpr'parse [#_"Context" ___context, #_"IPersistentMap" ___form]
        (let [#_"IPersistentVector" ___keyvals (ß PersistentVector'EMPTY)]
            (let [#_"boolean" ___keysConstant true]
                (let [#_"boolean" ___valsConstant true]
                    (let [#_"boolean" ___allConstantKeysUnique true]
                        (let [#_"IPersistentSet" ___constantKeys (ß PersistentHashSet'EMPTY)]
                            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___form)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                (let [#_"IMapEntry" ___e (ß (IMapEntry) ___s.first())]
                                    (let [#_"Expr" ___k (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___e.key()))]
                                        (let [#_"Expr" ___v (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___e.val()))]
                                            (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___k)))
                                            (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___v)))
                                            (if (ß ___k instanceof LiteralExpr)
                                                (do
                                                    (let [#_"Object" ___kval (ß ___k.eval())]
                                                        (if (ß ___constantKeys.contains(___kval))
                                                            (do
                                                                (§ ass ___allConstantKeysUnique false)
                                                            )
                                                            (do
                                                                (§ ass ___constantKeys (ß (IPersistentSet)___constantKeys.cons(___kval)))
                                                            )
                                                        )
                                                    )
                                                )
                                                (do
                                                    (§ ass ___keysConstant false)
                                                )
                                            )
                                            (when (ß !(___v instanceof LiteralExpr))
                                                (§ ass ___valsConstant false)
                                            )
                                        )
                                    )
                                )
                            )

                            (let [#_"Expr" ___ret (MapExpr. ___keyvals)]
                                (cond (ß ___form instanceof IObj && ((IObj) ___form).meta() != nil)
                                    (do
                                        (ß new MetaExpr(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___form).meta())))
                                    )
                                    ___keysConstant
                                    (do
                                        ;; TBD: Add more detail to exception thrown below.
                                        (when (ß !___allConstantKeysUnique)
                                            (throw (IllegalArgumentException. "Duplicate constant keys in map"))
                                        )
                                        (if ___valsConstant
                                            (do
                                                (let [#_"IPersistentMap" ___m (ß PersistentArrayMap'EMPTY)]
                                                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___keyvals.length()) [(§ ass ___i (ß ___i + 2))]
                                                        (§ ass ___m (ß ___m.assoc(((LiteralExpr)___keyvals.nth(___i)).val(), ((LiteralExpr)___keyvals.nth(___i + 1)).val())))
                                                    )
                                                    (ConstantExpr. ___m)
                                                )
                                            )
                                            (do
                                                ___ret
                                            )
                                        )
                                    )
                                    :else
                                    (do
                                        ___ret
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns SetExpr (§ implements Expr)
    (§ def #_"Method" SetExpr'setMethod (ß Method/getMethod("cloiure.lang.IPersistentSet set(Object[])")))

    (§ init
        (§ field #_"IPersistentVector" keys nil)
    )

    (§ constructor #_"SetExpr" SetExpr [#_"IPersistentVector" ___keys]
        (let [this (ß super())]
            (§ ass (ß this.keys) ___keys)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"SetExpr" this]
        (let [#_"Object[]" ___ret (ß new Object[keys.count()])]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < keys.count()) [(§ ass ___i (ß ___i + 1))]
                (§ ass (ß ___ret[___i]) (ß ((Expr) keys.nth(___i)).eval()))
            )
            (ß RT'set(___ret))
        )
    )

    #_method
    (§ defn #_"void" emit [#_"SetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß MethodExpr'emitArgsAsArray(keys, ___objx, ___gen))
        (ß ___gen.invokeStatic(RT_TYPE, setMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"SetExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"SetExpr" this]
        (§ class IPersistentSet)
    )

    (§ defn #_"Expr" SetExpr'parse [#_"Context" ___context, #_"IPersistentSet" ___form]
        (let [#_"IPersistentVector" ___keys (ß PersistentVector'EMPTY)]
            (let [#_"boolean" ___constant true]
                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___form)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (let [#_"Object" ___e (ß ___s.first())]
                        (let [#_"Expr" ___expr (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___e))]
                            (§ ass ___keys (ß (IPersistentVector) ___keys.cons(___expr)))
                            (when (ß !(___expr instanceof LiteralExpr))
                                (§ ass ___constant false)
                            )
                        )
                    )
                )
                (let [#_"Expr" ___ret (SetExpr. ___keys)]
                    (cond (ß ___form instanceof IObj && ((IObj) ___form).meta() != nil)
                        (do
                            (ß new MetaExpr(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___form).meta())))
                        )
                        ___constant
                        (do
                            (let [#_"IPersistentSet" ___set (ß PersistentHashSet'EMPTY)]
                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___keys.count()) [(§ ass ___i (ß ___i + 1))]
                                    (let [#_"LiteralExpr" ___ve (ß (LiteralExpr)___keys.nth(___i))]
                                        (§ ass ___set (ß (IPersistentSet)___set.cons(___ve.val())))
                                    )
                                )
                                (ConstantExpr. ___set)
                            )
                        )
                        :else
                        (do
                            ___ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns VectorExpr (§ implements Expr)
    (§ def #_"Method" VectorExpr'vectorMethod (ß Method/getMethod("cloiure.lang.IPersistentVector vector(Object[])")))

    (§ init
        (§ field #_"IPersistentVector" args nil)
    )

    (§ constructor #_"VectorExpr" VectorExpr [#_"IPersistentVector" ___args]
        (let [this (ß super())]
            (§ ass (ß this.args) ___args)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"VectorExpr" this]
        (let [#_"IPersistentVector" ___ret (ß PersistentVector'EMPTY)]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < args.count()) [(§ ass ___i (ß ___i + 1))]
                (§ ass ___ret (ß (IPersistentVector) ___ret.cons(((Expr) args.nth(___i)).eval())))
            )
            ret
        )
    )

    #_method
    (§ defn #_"void" emit [#_"VectorExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß args.count() <= Tuple'MAX_SIZE)
            (do
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < args.count()) [(§ ass ___i (ß ___i + 1))]
                    (ß ((Expr) args.nth(___i)).emit(:Context'EXPRESSION, ___objx, ___gen))
                )
                (ß ___gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()]))
            )
            (do
                (ß MethodExpr'emitArgsAsArray(args, ___objx, ___gen))
                (ß ___gen.invokeStatic(RT_TYPE, vectorMethod))
            )
        )

        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"VectorExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"VectorExpr" this]
        (§ class IPersistentVector)
    )

    (§ defn #_"Expr" VectorExpr'parse [#_"Context" ___context, #_"IPersistentVector" ___form]
        (let [#_"boolean" ___constant true]
            (let [#_"IPersistentVector" ___args (ß PersistentVector'EMPTY)]
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___form.count()) [(§ ass ___i (ß ___i + 1))]
                    (let [#_"Expr" ___v (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___form.nth(___i)))]
                        (§ ass ___args (ß (IPersistentVector) ___args.cons(___v)))
                        (when (ß !(___v instanceof LiteralExpr))
                            (§ ass ___constant false)
                        )
                    )
                )
                (let [#_"Expr" ___ret (VectorExpr. ___args)]
                    (cond (ß ___form instanceof IObj && ((IObj) ___form).meta() != nil)
                        (do
                            (ß new MetaExpr(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___form).meta())))
                        )
                        ___constant
                        (do
                            (let [#_"IPersistentVector" ___rv (ß PersistentVector'EMPTY)]
                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___args.count()) [(§ ass ___i (ß ___i + 1))]
                                    (let [#_"LiteralExpr" ___ve (ß (LiteralExpr)___args.nth(___i))]
                                        (§ ass ___rv (ß ___rv.cons(___ve.val())))
                                    )
                                )
                                (ConstantExpr. ___rv)
                            )
                        )
                        :else
                        (do
                            ___ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns KeywordInvokeExpr (§ implements Expr)
    (§ def #_"Type" KeywordInvokeExpr'ILOOKUP_TYPE (ß Type/getType((§ class ILookup))))

    (§ init
        (§ field #_"KeywordExpr" kw nil)
        (§ field #_"Object" tag nil)
        (§ field #_"Expr" target nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
        (§ field #_"int" siteIndex 0)
        (§ field #_"String" source nil)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"KeywordInvokeExpr" KeywordInvokeExpr [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"KeywordExpr" ___kw, #_"Expr" ___target]
        (let [this (ß super())]
            (§ ass (ß this.source) ___source)
            (§ ass (ß this.kw) ___kw)
            (§ ass (ß this.target) ___target)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (§ ass (ß this.tag) ___tag)
            (§ ass (ß this.siteIndex) (ß registerKeywordCallsite(___kw.k)))
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"KeywordInvokeExpr" this]
        (try
            (ß kw.k.invoke(target.eval()))
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException(source, line, column, ___e)))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emit [#_"KeywordInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
            (let [#_"Label" ___faultLabel (ß ___gen.newLabel())]
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.getStatic(___objx.objtype, ___objx.thunkNameStatic(siteIndex), ObjExpr'ILOOKUP_THUNK_TYPE))
                (ß ___gen.dup()) ;; thunk, thunk
                (ß target.emit(:Context'EXPRESSION, ___objx, ___gen)) ;; thunk, thunk, target
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.dupX2()) ;; target, thunk, thunk, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_THUNK_TYPE, Method/getMethod("Object get(Object)"))) ;; target, thunk, result
                (ß ___gen.dupX2()) ;; result, target, thunk, result
                (ß ___gen.visitJumpInsn(IF_ACMPEQ, ___faultLabel)) ;; result, target
                (ß ___gen.pop()) ;; result
                (ß ___gen.goTo(___endLabel))

                (ß ___gen.mark(___faultLabel)) ;; result, target
                (ß ___gen.swap()) ;; target, result
                (ß ___gen.pop()) ;; target
                (ß ___gen.dup()) ;; target, target
                (ß ___gen.getStatic(___objx.objtype, ___objx.siteNameStatic(siteIndex), ObjExpr'KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
                (ß ___gen.swap()) ;; target, site, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_SITE_TYPE, Method/getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
                (ß ___gen.dup()) ;; target, new-thunk, new-thunk
                (ß ___gen.putStatic(___objx.objtype, ___objx.thunkNameStatic(siteIndex), ObjExpr'ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
                (ß ___gen.swap()) ;; new-thunk, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_THUNK_TYPE, Method/getMethod("Object get(Object)"))) ;; result

                (ß ___gen.mark(___endLabel))
                (when (ß ___context == :Context'STATEMENT)
                    (ß ___gen.pop())
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"KeywordInvokeExpr" this]
        (ß (tag != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"KeywordInvokeExpr" this]
        (when (nil? jc)
            (§ ass jc (ß HostExpr'tagToClass(tag)))
        )
        jc
    )
)

(class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ init
        (§ field #_"Expr" expr nil)
        (§ field #_"Class" c nil)
    )

    (§ constructor #_"InstanceOfExpr" InstanceOfExpr [#_"Class" ___c, #_"Expr" ___expr]
        (let [this (ß super())]
            (§ ass (ß this.expr) ___expr)
            (§ ass (ß this.c) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"InstanceOfExpr" this]
        (when (ß c.isInstance(expr.eval()))
            (§ return (ß RT'T))
        )
        (ß RT'F)
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"InstanceOfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß expr.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.instanceOf(getType(c)))
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"InstanceOfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß emitUnboxed(___context, ___objx, ___gen))
        (ß HostExpr'emitBoxReturn(___objx, ___gen, Boolean/TYPE))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"InstanceOfExpr" this]
        (ß Boolean/TYPE)
    )
)

(class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ init
        (§ field #_"Type" target nil)
        (§ field #_"Class" retClass nil)
        (§ field #_"Class[]" paramclasses nil)
        (§ field #_"Type[]" paramtypes nil)
        (§ field #_"IPersistentVector" args nil)
        (§ field #_"boolean" variadic false)
        (§ field #_"boolean" tailPosition false)
        (§ field #_"Object" tag nil)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"StaticInvokeExpr" StaticInvokeExpr [#_"Type" ___target, #_"Class" ___retClass, #_"Class[]" ___paramclasses, #_"Type[]" ___paramtypes, #_"boolean" ___variadic, #_"IPersistentVector" ___args, #_"Object" ___tag, #_"boolean" ___tailPosition]
        (let [this (ß super())]
            (§ ass (ß this.target) ___target)
            (§ ass (ß this.retClass) ___retClass)
            (§ ass (ß this.paramclasses) ___paramclasses)
            (§ ass (ß this.paramtypes) ___paramtypes)
            (§ ass (ß this.args) ___args)
            (§ ass (ß this.variadic) ___variadic)
            (§ ass (ß this.tailPosition) ___tailPosition)
            (§ ass (ß this.tag) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"StaticInvokeExpr" this]
        (throw (UnsupportedOperationException. "Can't eval StaticInvokeExpr"))
    )

    #_method
    (§ defn #_"void" emit [#_"StaticInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß emitUnboxed(___context, ___objx, ___gen))
        (when (ß ___context != :Context'STATEMENT)
            (ß HostExpr'emitBoxReturn(___objx, ___gen, retClass))
        )
        (when (ß ___context == :Context'STATEMENT)
            (if (ß retClass == (§ class long) || retClass == (§ class double))
                (do
                    (ß ___gen.pop2())
                )
                (do
                    (ß ___gen.pop())
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"StaticInvokeExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"StaticInvokeExpr" this]
        (when (nil? jc)
            (§ ass jc (ß retType((tag != nil) ? HostExpr'tagToClass(tag) :or nil, retClass)))
        )
        jc
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"StaticInvokeExpr" this]
        (ß retClass.isPrimitive())
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"StaticInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Method" ___ms (ß new Method("invokeStatic", getReturnType(), paramtypes))]
            (if variadic
                (do
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < paramclasses.length - 1) [(§ ass ___i (ß ___i + 1))]
                        (let [#_"Expr" ___e (ß (Expr) args.nth(___i))]
                            (if (ß maybePrimitiveType(___e) == paramclasses[___i])
                                (do
                                    (ß ((MaybePrimitiveExpr) ___e).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                )
                                (do
                                    (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß HostExpr'emitUnboxArg(___objx, ___gen, paramclasses[___i]))
                                )
                            )
                        )
                    )
                    (let [#_"IPersistentVector" ___restArgs (ß RT'subvec(args, paramclasses.length - 1, args.count()))]
                        (ß MethodExpr'emitArgsAsArray(___restArgs, ___objx, ___gen))
                        (ß ___gen.invokeStatic(Type/getType((§ class ArraySeq)), Method/getMethod("cloiure.lang.ArraySeq create(Object[])")))
                    )
                )
                (do
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, paramclasses, args))
                )
            )

            (when (ß tailPosition && !___objx.canBeDirect)
                (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                    (ß ___method.emitClearThis(___gen))
                )
            )

            (ß ___gen.invokeStatic(target, ___ms))
            nil
        )
    )

    #_method
    (§ defn- #_"Type" getReturnType [#_"StaticInvokeExpr" this]
        (ß Type/getType(retClass))
    )

    (§ defn #_"Expr" StaticInvokeExpr'parse [#_"Var" ___v, #_"ISeq" ___args, #_"Object" ___tag, #_"boolean" ___tailPosition]
        (when (ß !___v.isBound() || ___v.get() == nil)
            (§ return nil)
        )
        (let [#_"Class" ___c (ß ___v.get().getClass())]
            (let [#_"String" ___cname (ß ___c.getName())]
                (let [#_"java.lang.reflect.Method[]" ___allmethods (ß ___c.getMethods())]
                    (let [#_"boolean" ___variadic false]
                        (let [#_"int" ___argcount (ß RT'count(___args))]
                            (let [#_"java.lang.reflect.Method" ___method nil]
                                (doseq [#_"java.lang.reflect.Method" ___m ___allmethods]
                                    (when (ß Modifier/isStatic(___m.getModifiers()) && ___m.getName().equals("invokeStatic"))
                                        (let [#_"Class[]" ___params (ß ___m.getParameterTypes())]
                                            (cond (ß ___argcount == ___params.length)
                                                (do
                                                    (§ ass ___method ___m)
                                                    (§ ass ___variadic (ß (___argcount > 0 && ___params[___params.length - 1] == (§ class ISeq))))
                                                    (§ break )
                                                )
                                                (ß ___argcount > ___params.length && ___params.length > 0 && ___params[___params.length - 1] == (§ class ISeq))
                                                (do
                                                    (§ ass ___method ___m)
                                                    (§ ass ___variadic true)
                                                    (§ break )
                                                )
                                            )
                                        )
                                    )
                                )
                                (when (nil? ___method)
                                    (§ return nil)
                                )

                                (let [#_"Class" ___retClass (ß ___method.getReturnType())]
                                    (let [#_"Class[]" ___paramClasses (ß ___method.getParameterTypes())]
                                        (let [#_"Type[]" ___paramTypes (ß new Type[___paramClasses.length])]
                                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___paramClasses.length) [(§ ass ___i (ß ___i + 1))]
                                                (§ ass (ß ___paramTypes[___i]) (ß Type/getType(___paramClasses[___i])))
                                            )

                                            (let [#_"Type" ___target (ß Type/getType(___c))]
                                                (let [#_"PersistentVector" ___argv (ß PersistentVector'EMPTY)]
                                                    (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___args)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                                        (§ ass ___argv (ß ___argv.cons(analyze(:Context'EXPRESSION, ___s.first()))))
                                                    )

                                                    (ß new StaticInvokeExpr(___target, ___retClass, ___paramClasses, ___paramTypes, ___variadic, ___argv, ___tag, ___tailPosition))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns InvokeExpr (§ implements Expr)
    (§ def #_"Keyword" InvokeExpr'onKey (ß Keyword'intern("on")))
    (§ def #_"Keyword" InvokeExpr'methodMapKey (ß Keyword'intern("method-map")))

    (§ defn #_"Object" InvokeExpr'sigTag [#_"int" ___argcount, #_"Var" ___v]
        (let [#_"Object" ___arglists (ß RT'get(RT'meta(___v), arglistsKey))]
            (let [#_"Object" ___sigTag nil]
                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___arglists)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (let [#_"APersistentVector" ___sig (ß (APersistentVector) ___s.first())]
                        (let [#_"int" ___restOffset (ß ___sig.indexOf(_AMP_))]
                            (when (ß ___argcount == ___sig.count() || (___restOffset > -1 && ___argcount >= ___restOffset))
                                (§ return (ß tagOf(___sig)))
                            )
                        )
                    )
                )
                nil
            )
        )
    )

    (§ init
        (§ field #_"Expr" fexpr nil)
        (§ field #_"Object" tag nil)
        (§ field #_"IPersistentVector" args nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
        (§ field #_"boolean" tailPosition false)
        (§ field #_"String" source nil)

        (§ field #_"boolean" isProtocol false)
        (§ field #_"boolean" isDirect false)
        (§ field #_"int" siteIndex -1)
        (§ field #_"Class" protocolOn nil)
        (§ field #_"java.lang.reflect.Method" onMethod nil)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"InvokeExpr" InvokeExpr [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Expr" ___fexpr, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (ß super())]
            (§ ass (ß this.source) ___source)
            (§ ass (ß this.fexpr) ___fexpr)
            (§ ass (ß this.args) ___args)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (§ ass (ß this.tailPosition) ___tailPosition)

            (when (ß ___fexpr instanceof VarExpr)
                (let [#_"Var" ___fvar (ß ((VarExpr)___fexpr).var)]
                    (let [#_"Var" ___pvar (ß (Var)RT'get(___fvar.meta(), protocolKey))]
                        (when (ß ___pvar != nil && PROTOCOL_CALLSITES.isBound())
                            (§ ass (ß this.isProtocol) true)
                            (§ ass (ß this.siteIndex) (ß registerProtocolCallsite(((VarExpr)___fexpr).var)))
                            (let [#_"Object" ___pon (ß RT'get(___pvar.get(), onKey))]
                                (§ ass (ß this.protocolOn) (ß HostExpr'maybeClass(___pon, false)))
                                (when (ß this.protocolOn != nil)
                                    (let [#_"IPersistentMap" ___mmap (ß (IPersistentMap) RT'get(___pvar.get(), methodMapKey))]
                                        (let [#_"Keyword" ___mmapVal (ß (Keyword) ___mmap.valAt(Keyword'intern(___fvar.sym)))]
                                            (when (nil? ___mmapVal)
                                                (throw (ß new IllegalArgumentException("No method of interface: " + protocolOn.getName() + " found for function: " + ___fvar.sym + " of protocol: " + ___pvar.sym + " (The protocol method may have been defined before and removed.)")))
                                            )
                                            (let [#_"String" ___mname (ß munge(___mmapVal.sym.toString()))]
                                                (let [#_"List" ___methods (ß Reflector'getMethods(protocolOn, ___args.count() - 1, ___mname, false))]
                                                    (when (ß ___methods.size() != 1)
                                                        (throw (ß new IllegalArgumentException("No single method: " + ___mname + " of interface: " + protocolOn.getName() + " found for function: " + ___fvar.sym + " of protocol: " + ___pvar.sym)))
                                                    )
                                                    (§ ass (ß this.onMethod) (ß (java.lang.reflect.Method) ___methods.get(0)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (cond (some? ___tag)
                (do
                    (§ ass (ß this.tag) ___tag)
                )
                (ß ___fexpr instanceof VarExpr)
                (do
                    (let [#_"Var" ___v (ß ((VarExpr) ___fexpr).var)]
                        (let [#_"Object" ___arglists (ß RT'get(RT'meta(___v), arglistsKey))]
                            (let [#_"Object" ___sigTag (ß ___sigTag(___args.count(), ___v))]
                                (§ ass (ß this.tag) (ß (___sigTag == nil) ? ((VarExpr) ___fexpr).tag :or ___sigTag))
                            )
                        )
                    )
                )
                :else
                (do
                    (§ ass (ß this.tag) nil)
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"InvokeExpr" this]
        (try
            (let [#_"IFn" ___fn (ß (IFn) fexpr.eval())]
                (let [#_"PersistentVector" ___argvs (ß PersistentVector'EMPTY)]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < args.count()) [(§ ass ___i (ß ___i + 1))]
                        (§ ass ___argvs (ß ___argvs.cons(((Expr) args.nth(___i)).eval())))
                    )
                    (ß ___fn.applyTo(RT'seq(Util'ret1(___argvs, (§ ass ___argvs nil)))))
                )
            )
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException(source, line, column, ___e)))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emit [#_"InvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if isProtocol
            (do
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß emitProto(___context, ___objx, ___gen))
            )
            (do
                (ß fexpr.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber(line, ___gen.mark()))
                (ß ___gen.checkCast(IFN_TYPE))
                (ß emitArgsAndCall(0, ___context, ___objx, ___gen))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"void" emitProto [#_"InvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___onLabel (ß ___gen.newLabel())]
            (let [#_"Label" ___callLabel (ß ___gen.newLabel())]
                (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
                    (let [#_"Var" ___v (ß ((VarExpr)fexpr).var)]
                        (let [#_"Expr" ___e (ß (Expr) args.nth(0))]
                            (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                            (ß ___gen.dup()) ;; target, target
                            (ß ___gen.invokeStatic(UTIL_TYPE, Method/getMethod("Class classOf(Object)"))) ;; target, class
                            (ß ___gen.getStatic(___objx.objtype, ___objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target, class, cached-class
                            (ß ___gen.visitJumpInsn(IF_ACMPEQ, ___callLabel)) ;; target
                            (when (some? protocolOn)
                                (ß ___gen.dup()) ;; target, target
                                (ß ___gen.instanceOf(Type/getType(protocolOn)))
                                (ß ___gen.ifZCmp(GeneratorAdapter/NE, ___onLabel))
                            )

                            (ß ___gen.dup()) ;; target, target
                            (ß ___gen.invokeStatic(UTIL_TYPE, Method/getMethod("Class classOf(Object)"))) ;; target, class
                            (ß ___gen.putStatic(___objx.objtype, ___objx.cachedClassName(siteIndex), CLASS_TYPE)) ;; target

                            (ß ___gen.mark(___callLabel)) ;; target
                            (ß ___objx.emitVar(___gen, ___v))
                            (ß ___gen.invokeVirtual(VAR_TYPE, Method/getMethod("Object getRawRoot()"))) ;; target, proto-fn
                            (ß ___gen.swap())
                            (ß emitArgsAndCall(1, ___context, ___objx, ___gen))
                            (ß ___gen.goTo(___endLabel))

                            (ß ___gen.mark(___onLabel)) ;; target
                            (when (some? protocolOn)
                                (ß ___gen.checkCast(Type/getType(protocolOn)))
                                (ß MethodExpr'emitTypedArgs(___objx, ___gen, onMethod.getParameterTypes(), RT'subvec(args, 1, args.count())))
                                (when (ß ___context == :Context'RETURN)
                                    (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                                        (ß ___method.emitClearLocals(___gen))
                                    )
                                )
                                (let [#_"Method" ___m (ß new Method(onMethod.getName(), Type/getReturnType(onMethod), Type/getArgumentTypes(onMethod)))]
                                    (ß ___gen.invokeInterface(Type/getType(protocolOn), ___m))
                                    (ß HostExpr'emitBoxReturn(___objx, ___gen, onMethod.getReturnType()))
                                )
                            )
                            (ß ___gen.mark(___endLabel))
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emitArgsAndCall [#_"InvokeExpr" this, #_"int" ___firstArgToEmit, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [(§ var #_"int" ___i ___firstArgToEmit)] (ß ___i < Math/min(MAX_POSITIONAL_ARITY, args.count())) [(§ ass ___i (ß ___i + 1))]
            (let [#_"Expr" ___e (ß (Expr) args.nth(___i))]
                (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
            )
        )
        (when (ß args.count() > MAX_POSITIONAL_ARITY)
            (let [#_"PersistentVector" ___restArgs (ß PersistentVector'EMPTY)]
                (loop-when-recur [(§ var #_"int" ___i MAX_POSITIONAL_ARITY)] (ß ___i < args.count()) [(§ ass ___i (ß ___i + 1))]
                    (§ ass ___restArgs (ß ___restArgs.cons(args.nth(___i))))
                )
                (ß MethodExpr'emitArgsAsArray(___restArgs, ___objx, ___gen))
            )
        )
        (ß ___gen.visitLineNumber(line, ___gen.mark()))

        (when (ß tailPosition && !___objx.canBeDirect)
            (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                (ß ___method.emitClearThis(___gen))
            )
        )

        (ß ___gen.invokeInterface(IFN_TYPE, new Method("invoke", OBJECT_TYPE, ARG_TYPES[Math/min(MAX_POSITIONAL_ARITY + 1, args.count())])))
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"InvokeExpr" this]
        (ß (tag != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"InvokeExpr" this]
        (when (nil? jc)
            (§ ass jc (ß HostExpr'tagToClass(tag)))
        )
        jc
    )

    (§ defn #_"Expr" InvokeExpr'parse [#_"Context" ___context, #_"ISeq" ___form]
        (let [#_"boolean" ___tailPosition (ß inTailCall(___context))]
            (when (ß ___context != :Context'EVAL)
                (§ ass ___context (ß :Context'EXPRESSION))
            )
            (let [#_"Expr" ___fexpr (ß analyze(___context, ___form.first()))]
                (when (ß ___fexpr instanceof VarExpr && ((VarExpr)___fexpr).var.equals(INSTANCE) && RT'count(___form) == 3)
                    (let [#_"Expr" ___sexpr (ß analyze(:Context'EXPRESSION, RT'second(___form)))]
                        (when (ß ___sexpr instanceof ConstantExpr)
                            (let [#_"Object" ___val (ß ((ConstantExpr) ___sexpr).val())]
                                (when (ß ___val instanceof Class)
                                    (§ return (ß new InstanceOfExpr((Class) ___val, analyze(___context, RT'third(___form)))))
                                )
                            )
                        )
                    )
                )

                (when (ß RT'booleanCast(getCompilerOption(directLinkingKey)) && ___fexpr instanceof VarExpr && ___context != :Context'EVAL)
                    (let [#_"Var" ___v (ß ((VarExpr)___fexpr).var)]
                        (when (ß !___v.isDynamic() && !RT'booleanCast(RT'get(___v.meta(), redefKey, false)))
                            (let [#_"Symbol" ___formtag (ß tagOf(___form))]
                                (let [#_"Object" ___arglists (ß RT'get(RT'meta(___v), arglistsKey))]
                                    (let [#_"int" ___arity (ß RT'count(___form.next()))]
                                        (let [#_"Object" ___sigtag (ß sigTag(___arity, ___v))]
                                            (let [#_"Object" ___vtag (ß RT'get(RT'meta(___v), RT'TAG_KEY))]
                                                (let [#_"Expr" ___ret (ß StaticInvokeExpr'parse(___v, RT'next(___form), (___formtag != nil) ? ___formtag :or (___sigtag != nil) ? ___sigtag :or ___vtag, ___tailPosition))]
                                                    (when (some? ___ret)
                                                        (§ return ___ret)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (when (ß ___fexpr instanceof VarExpr && ___context != :Context'EVAL)
                    (let [#_"Var" ___v (ß ((VarExpr)___fexpr).var)]
                        (let [#_"Object" ___arglists (ß RT'get(RT'meta(___v), arglistsKey))]
                            (let [#_"int" ___arity (ß RT'count(___form.next()))]
                                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___arglists)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                    (let [#_"IPersistentVector" ___args (ß (IPersistentVector) ___s.first())]
                                        (when (ß ___args.count() == ___arity)
                                            (let [#_"String" ___primc (ß FnMethod'primInterface(___args))]
                                                (when (some? ___primc)
                                                    (§ return (ß analyze(___context, ((IObj)RT'listStar(Symbol'intern(".invokePrim"), ((Symbol) ___form.first()).withMeta(RT'map(RT'TAG_KEY, Symbol'intern(___primc))), ___form.next())).withMeta((IPersistentMap)RT'conj(RT'meta(___v), RT'meta(___form))))))
                                                )
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (when (ß ___fexpr instanceof KeywordExpr && RT'count(___form) == 2 && KEYWORD_CALLSITES.isBound())
                    (let [#_"Expr" ___target (ß analyze(___context, RT'second(___form)))]
                        (§ return (ß new KeywordInvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(___form), (KeywordExpr) ___fexpr, ___target)))
                    )
                )
                (let [#_"PersistentVector" ___args (ß PersistentVector'EMPTY)]
                    (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___form.next())))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                        (§ ass ___args (ß ___args.cons(analyze(___context, ___s.first()))))
                    )

                    (ß new InvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(___form), ___fexpr, ___args, ___tailPosition))
                )
            )
        )
    )
)

#_stateless
(class-ns SourceDebugExtensionAttribute (§ extends Attribute)
    (§ constructor #_"SourceDebugExtensionAttribute" SourceDebugExtensionAttribute []
        (let [this (ß super("SourceDebugExtension"))]
            this
        )
    )

    #_method
    (§ defn #_"void" writeSMAP [#_"SourceDebugExtensionAttribute" this, #_"ClassWriter" ___cw, #_"String" ___smap]
        (let [#_"ByteVector" ___bv (ß write(___cw, nil, -1, -1, -1))]
            (ß ___bv.putUTF8(___smap))
            nil
        )
    )
)

(class-ns FnExpr (§ extends ObjExpr)
    (§ def #_"Type" FnExpr'aFnType (ß Type/getType((§ class AFunction))))
    (§ def #_"Type" FnExpr'restFnType (ß Type/getType((§ class RestFn))))

    (§ init
        ;; if there is a variadic overload (there can only be one) it is stored here
        (§ field #_"FnMethod" variadicMethod nil)
        (§ field #_"IPersistentCollection" methods nil)
        (§ field- #_"boolean" hasPrimSigs false)
        (§ field- #_"boolean" hasMeta false)
        (§ field- #_"boolean" hasEnclosingMethod false)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"FnExpr" FnExpr [#_"Object" ___tag]
        (let [this (ß super(___tag))]
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"FnExpr" this]
        true
    )

    #_method
    (§ defn #_"boolean" supportsMeta [#_"FnExpr" this]
        hasMeta
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"FnExpr" this]
        (when (nil? jc)
            (§ ass jc (ß (tag != nil) ? HostExpr'tagToClass(tag) :or (§ class AFunction)))
        )
        jc
    )

    #_protected
    #_method
    (§ defn #_"void" emitMethods [#_"FnExpr" this, #_"ClassVisitor" ___cv]
        ;; override of invoke/doInvoke for each method
        (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(methods)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
            (let [#_"ObjMethod" ___method (ß (ObjMethod) ___s.first())]
                (ß ___method.emit(this, ___cv))
            )
        )

        (when (ß isVariadic())
            (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC, Method/getMethod("int getRequiredArity()"), nil, nil, ___cv))]
                (ß ___gen.visitCode())
                (ß ___gen.push(variadicMethod.reqParms.count()))
                (ß ___gen.returnValue())
                (ß ___gen.endMethod())
            )
        )
        nil
    )

    (§ defn #_"Expr" FnExpr'parse [#_"Context" ___context, #_"ISeq" ___form, #_"String" ___name]
        (let [#_"ISeq" ___origForm ___form]
            (let [#_"FnExpr" ___fn (ß new FnExpr(tagOf(___form)))]
                (let [#_"Keyword" ___retkey (ß Keyword'intern(nil, "rettag"))]
                    (let [#_"Object" ___rettag (ß RT'get(RT'meta(___form), ___retkey))]
                        (§ ass (ß ___fn.src) ___form)
                        (let [#_"ObjMethod" ___enclosingMethod (ß (ObjMethod) METHOD.deref())]
                            (§ ass (ß ___fn.hasEnclosingMethod) (ß ___enclosingMethod != nil))
                            (when (ß ((IMeta) ___form.first()).meta() != nil)
                                (§ ass (ß ___fn.onceOnly) (ß RT'booleanCast(RT'get(RT'meta(___form.first()), Keyword'intern(nil, "once")))))
                            )

                            (let [#_"String" ___basename (ß ((___enclosingMethod != nil) ? ___enclosingMethod.objx.name :or munge(currentNS().name.name)) + "$")]
                                (let [#_"Symbol" ___nm nil]
                                    (if (ß RT'second(___form) instanceof Symbol)
                                        (do
                                            (§ ass ___nm (ß (Symbol) RT'second(___form)))
                                            (§ ass ___name (ß ___nm.name + "__" + RT'nextID()))
                                        )
                                        (do
                                            (cond (nil? ___name)
                                                (do
                                                    (§ ass ___name (ß "fn__" + RT'nextID()))
                                                )
                                                (some? ___enclosingMethod)
                                                (do
                                                    (§ ass ___name (ß ___name + "__" + RT'nextID()))
                                                )
                                            )
                                        )
                                    )

                                    (let [#_"String" ___simpleName (ß munge(___name).replace(".", "_DOT_"))]
                                        (§ ass (ß ___fn.name) (ß ___basename + ___simpleName))
                                        (§ ass (ß ___fn.internalName) (ß ___fn.name.replace(\., \/)))
                                        (§ ass (ß ___fn.objtype) (ß Type/getObjectType(___fn.internalName)))
                                        (let [#_"ArrayList<String>" ___prims (ArrayList.)]
                                            (try
                                                (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                    (§ map
                                                        CONSTANTS          (ß PersistentVector'EMPTY)
                                                        CONSTANT_IDS       (ß new IdentityHashMap())
                                                        KEYWORDS           (ß PersistentHashMap'EMPTY)
                                                        VARS               (ß PersistentHashMap'EMPTY)
                                                        KEYWORD_CALLSITES  (ß PersistentVector'EMPTY)
                                                        PROTOCOL_CALLSITES (ß PersistentVector'EMPTY)
                                                        VAR_CALLSITES      (ß emptyVarCallSites())
                                                        NO_RECUR           nil
                                                    )
                                                )))

                                                ;; arglist might be preceded by symbol naming this fn
                                                (when (some? ___nm)
                                                    (§ ass (ß ___fn.thisName) (ß ___nm.name))
                                                    (§ ass ___form (ß RT'cons(FN, RT'next(RT'next(___form)))))
                                                )

                                                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                                                ;; turn former into latter
                                                (when (ß RT'second(___form) instanceof IPersistentVector)
                                                    (§ ass ___form (ß RT'list(FN, RT'next(___form))))
                                                )
                                                (§ ass (ß ___fn.line) (ß lineDeref()))
                                                (§ ass (ß ___fn.column) (ß columnDeref()))
                                                (let [#_"FnMethod[]" ___methodArray (ß new FnMethod[MAX_POSITIONAL_ARITY + 1])]
                                                    (let [#_"FnMethod" ___variadicMethod nil]
                                                        (let [#_"boolean" ___usesThis false]
                                                            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'next(___form)))] (some? ___s) [(§ ass ___s (ß RT'next(___s)))]
                                                                (let [#_"FnMethod" ___f (ß FnMethod'parse(___fn, (ISeq) RT'first(___s), ___rettag))]
                                                                    (when (ß ___f.usesThis)
                                                                        (§ ass ___usesThis true)
                                                                    )
                                                                    (cond (ß ___f.isVariadic())
                                                                        (do
                                                                            (if (nil? ___variadicMethod)
                                                                                (do
                                                                                    (§ ass ___variadicMethod ___f)
                                                                                )
                                                                                (do
                                                                                    (throw (ß Util'runtimeException("Can't have more than 1 variadic overload")))
                                                                                )
                                                                            )
                                                                        )
                                                                        (ß ___methodArray[___f.reqParms.count()] == nil)
                                                                        (do
                                                                            (§ ass (ß ___methodArray[___f.reqParms.count()]) ___f)
                                                                        )
                                                                        :else
                                                                        (do
                                                                            (throw (ß Util'runtimeException("Can't have 2 overloads with same arity")))
                                                                        )
                                                                    )
                                                                    (when (ß ___f.prim != nil)
                                                                        (ß ___prims.add(___f.prim))
                                                                    )
                                                                )
                                                            )
                                                            (when (some? ___variadicMethod)
                                                                (loop-when-recur [(§ var #_"int" ___i (ß ___variadicMethod.reqParms.count() + 1))] (ß ___i <= MAX_POSITIONAL_ARITY) [(§ ass ___i (ß ___i + 1))]
                                                                    (when (ß ___methodArray[___i] != nil)
                                                                        (throw (ß Util'runtimeException("Can't have fixed arity function with more params than variadic function")))
                                                                    )
                                                                )
                                                            )

                                                            (§ ass (ß ___fn.canBeDirect) (ß (!___fn.hasEnclosingMethod && ___fn.closes.count() == 0 && !___usesThis)))

                                                            (let [#_"IPersistentCollection" ___methods nil]
                                                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___methodArray.length) [(§ ass ___i (ß ___i + 1))]
                                                                    (when (ß ___methodArray[___i] != nil)
                                                                        (§ ass ___methods (ß RT'conj(___methods, ___methodArray[___i])))
                                                                    )
                                                                )
                                                                (when (some? ___variadicMethod)
                                                                    (§ ass ___methods (ß RT'conj(___methods, ___variadicMethod)))
                                                                )

                                                                (when (ß ___fn.canBeDirect)
                                                                    (doseq [#_"FnMethod" ___fm (ß (Collection<FnMethod>)___methods)]
                                                                        (when (ß ___fm.locals != nil)
                                                                            (doseq [#_"LocalBinding" ___lb (ß (Collection<LocalBinding>)RT'keys(___fm.locals))]
                                                                                (when (ß ___lb.isArg)
                                                                                    (§ ass (ß ___lb.idx) (ß ___lb.idx - 1))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )

                                                                (§ ass (ß ___fn.methods) ___methods)
                                                                (§ ass (ß ___fn.variadicMethod) ___variadicMethod)
                                                                (§ ass (ß ___fn.keywords) (ß (IPersistentMap) KEYWORDS.deref()))
                                                                (§ ass (ß ___fn.vars) (ß (IPersistentMap) VARS.deref()))
                                                                (§ ass (ß ___fn.constants) (ß (PersistentVector) CONSTANTS.deref()))
                                                                (§ ass (ß ___fn.keywordCallsites) (ß (IPersistentVector) KEYWORD_CALLSITES.deref()))
                                                                (§ ass (ß ___fn.protocolCallsites) (ß (IPersistentVector) PROTOCOL_CALLSITES.deref()))
                                                                (§ ass (ß ___fn.varCallsites) (ß (IPersistentSet) VAR_CALLSITES.deref()))

                                                                (§ ass (ß ___fn.constantsID) (ß RT'nextID()))
                                                            )
                                                        )
                                                    )
                                                )
                                                (finally
                                                    (ß Var'popThreadBindings())
                                                )
                                            )
                                            (§ ass (ß ___fn.hasPrimSigs) (ß ___prims.size() > 0))
                                            (let [#_"IPersistentMap" ___fmeta (ß RT'meta(___origForm))]
                                                (when (some? ___fmeta)
                                                    (§ ass ___fmeta (ß ___fmeta.without(RT'LINE_KEY).without(RT'COLUMN_KEY).without(RT'FILE_KEY).without(___retkey)))
                                                )

                                                (§ ass (ß ___fn.hasMeta) (ß RT'count(___fmeta) > 0))

                                                (try
                                                    (ß ___fn.compile(___fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (___prims.size() == 0) ? nil :or ___prims.toArray(new String[___prims.size()]), ___fn.onceOnly))
                                                    (catch IOException ___e
                                                        (throw (ß Util'sneakyThrow(___e)))
                                                    )
                                                )
                                                (ß ___fn.getCompiledClass())

                                                (if (ß ___fn.supportsMeta())
                                                    (do
                                                        (ß new MetaExpr(___fn, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___fmeta)))
                                                    )
                                                    (do
                                                        ___fn
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ObjMethod" variadicMethod [#_"FnExpr" this]
        variadicMethod
    )

    #_method
    (§ defn #_"boolean" isVariadic [#_"FnExpr" this]
        (ß (variadicMethod != nil))
    )

    #_method
    (§ defn #_"IPersistentCollection" methods [#_"FnExpr" this]
        methods
    )

    #_method
    (§ defn #_"void" emitForDefn [#_"FnExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß emit(:Context'EXPRESSION, ___objx, ___gen))
        nil
    )
)

(class-ns ObjExpr (§ implements Expr)
    (§ def #_"String" ObjExpr'CONST_PREFIX "const__")

    (§ def #_"Method" ObjExpr'voidctor (ß Method/getMethod("void <init>()")))

    (§ def #_"Method" ObjExpr'kwintern (ß Method/getMethod("cloiure.lang.Keyword intern(String, String)")))
    (§ def #_"Method" ObjExpr'symintern (ß Method/getMethod("cloiure.lang.Symbol intern(String)")))
    (§ def #_"Method" ObjExpr'varintern (ß Method/getMethod("cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)")))

    (§ def #_"Type" ObjExpr'DYNAMIC_CLASSLOADER_TYPE (ß Type/getType((§ class DynamicClassLoader))))
    (§ def #_"Method" ObjExpr'getClassMethod (ß Method/getMethod("Class getClass()")))
    (§ def #_"Method" ObjExpr'getClassLoaderMethod (ß Method/getMethod("ClassLoader getClassLoader()")))
    (§ def #_"Method" ObjExpr'getConstantsMethod (ß Method/getMethod("Object[] getConstants(int)")))
    (§ def #_"Method" ObjExpr'readStringMethod (ß Method/getMethod("Object readString(String)")))

    (§ def #_"Type" ObjExpr'ILOOKUP_SITE_TYPE (ß Type/getType((§ class ILookupSite))))
    (§ def #_"Type" ObjExpr'ILOOKUP_THUNK_TYPE (ß Type/getType((§ class ILookupThunk))))
    (§ def #_"Type" ObjExpr'KEYWORD_LOOKUPSITE_TYPE (ß Type/getType((§ class KeywordLookupSite))))

    (§ init
        (§ field #_"String" name nil)
        (§ field #_"String" internalName nil)
        (§ field #_"String" thisName nil)
        (§ field #_"Type" objtype nil)
        (§ field #_"Object" tag nil)
        ;; localbinding->itself
        (§ field #_"IPersistentMap" closes (ß PersistentHashMap'EMPTY))
        ;; localbndingexprs
        (§ field #_"IPersistentVector" closesExprs (ß PersistentVector'EMPTY))
        ;; symbols
        (§ field #_"IPersistentSet" volatiles (ß PersistentHashSet'EMPTY))

        ;; symbol->lb
        (§ field #_"IPersistentMap" fields nil)

        ;; hinted fields
        (§ field #_"IPersistentVector" hintedFields (ß PersistentVector'EMPTY))

        ;; Keyword->KeywordExpr
        (§ field #_"IPersistentMap" keywords (ß PersistentHashMap'EMPTY))
        (§ field #_"IPersistentMap" vars (ß PersistentHashMap'EMPTY))
        (§ field #_"Class" compiledClass nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
        (§ field #_"PersistentVector" constants nil)
        (§ field #_"IPersistentSet" usedConstants (ß PersistentHashSet'EMPTY))

        (§ field #_"int" constantsID 0)
        (§ field #_"int" altCtorDrops 0)

        (§ field #_"IPersistentVector" keywordCallsites nil)
        (§ field #_"IPersistentVector" protocolCallsites nil)
        (§ field #_"IPersistentSet" varCallsites nil)
        (§ field #_"boolean" onceOnly false)

        (§ field #_"Object" src nil)

        (§ field #_"IPersistentMap" opts (ß PersistentHashMap'EMPTY))

        #_protected
        (§ field #_"IPersistentMap" classMeta nil)
        #_protected
        (§ field #_"boolean" canBeDirect false)

        (§ field- #_"DynamicClassLoader" loader nil)
        (§ field- #_"byte[]" bytecode nil)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"ObjExpr" ObjExpr [#_"Object" ___tag]
        (let [this (ß super())]
            (§ ass (ß this.tag) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"String" name [#_"ObjExpr" this]
        name
    )

    #_method
    (§ defn #_"String" internalName [#_"ObjExpr" this]
        internalName
    )

    #_method
    (§ defn #_"String" thisName [#_"ObjExpr" this]
        thisName
    )

    #_method
    (§ defn #_"Type" objtype [#_"ObjExpr" this]
        objtype
    )

    #_method
    (§ defn #_"IPersistentMap" closes [#_"ObjExpr" this]
        closes
    )

    #_method
    (§ defn #_"IPersistentMap" keywords [#_"ObjExpr" this]
        keywords
    )

    #_method
    (§ defn #_"IPersistentMap" vars [#_"ObjExpr" this]
        vars
    )

    #_method
    (§ defn #_"Class" compiledClass [#_"ObjExpr" this]
        compiledClass
    )

    #_method
    (§ defn #_"int" line [#_"ObjExpr" this]
        line
    )

    #_method
    (§ defn #_"int" column [#_"ObjExpr" this]
        column
    )

    #_method
    (§ defn #_"PersistentVector" constants [#_"ObjExpr" this]
        constants
    )

    #_method
    (§ defn #_"int" constantsID [#_"ObjExpr" this]
        constantsID
    )

    (§ defn #_"String" ObjExpr'trimGenID [#_"String" ___name]
        (let [#_"int" ___i (ß ___name.lastIndexOf("__"))]
            (ß (___i == -1) ? ___name :or ___name.substring(0, ___i))
        )
    )

    #_method
    (§ defn #_"Type[]" ctorTypes [#_"ObjExpr" this]
        (let [#_"IPersistentVector" ___tv (ß !supportsMeta() ? PersistentVector'EMPTY :or RT'vector(IPERSISTENTMAP_TYPE))]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'keys(closes)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                    (if (ß ___lb.getPrimitiveType() != nil)
                        (do
                            (§ ass ___tv (ß ___tv.cons(Type/getType(___lb.getPrimitiveType()))))
                        )
                        (do
                            (§ ass ___tv (ß ___tv.cons(OBJECT_TYPE)))
                        )
                    )
                )
            )
            (let [#_"Type[]" ___ret (ß new Type[___tv.count()])]
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___tv.count()) [(§ ass ___i (ß ___i + 1))]
                    (§ ass (ß ___ret[___i]) (ß (Type) ___tv.nth(___i)))
                )
                ret
            )
        )
    )

    #_method
    (§ defn #_"void" compile [#_"ObjExpr" this, #_"String" ___superName, #_"String[]" ___interfaceNames, #_"boolean" ___oneTimeUse] #_(§ throws IOException)
        ;; create bytecode for a class
        ;; with name current_ns.defname[$letname]+
        ;; anonymous fns get names fn__id
        ;; derived from AFn'RestFn
        (let [#_"ClassWriter" ___cw (ClassWriter. (ß ClassWriter/COMPUTE_MAXS))]
            (let [#_"ClassVisitor" ___cv ___cw]
                (ß ___cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, internalName, nil, ___superName, ___interfaceNames))
                (let [#_"String" ___source (ß (String) SOURCE.deref())]
                    (let [#_"int" ___lineBefore (ß (Integer) LINE_BEFORE.deref())]
                        (let [#_"int" ___lineAfter (ß (Integer) LINE_AFTER.deref() + 1)]
                            (let [#_"int" ___columnBefore (ß (Integer) COLUMN_BEFORE.deref())]
                                (let [#_"int" ___columnAfter (ß (Integer) COLUMN_AFTER.deref() + 1)]
                                    (when (ß ___source != nil && SOURCE_PATH.deref() != nil)
                                        (let [#_"String" ___smap
                                                (str "SMAP\n"
                                                    (ß (___source.lastIndexOf(\.) > 0) ? ___source.substring(0, ___source.lastIndexOf(\.)) :or ___source) ;; :or simpleName
                                                    ".java\n"
                                                    "Cloiure\n"
                                                    "*S Cloiure\n"
                                                    "*F\n"
                                                    "+ 1 " ___source "\n"
                                                    (ß (String) SOURCE_PATH.deref()) "\n"
                                                    "*L\n"
                                                    (ß String/format("%d#1,%d:%d\n", ___lineBefore, ___lineAfter - ___lineBefore, ___lineBefore))
                                                    "*E"
                                                )]
                                            (ß ___cv.visitSource(___source, ___smap))
                                        )
                                    )
                                    (ß addAnnotation(___cv, classMeta))

                                    (when (ß supportsMeta())
                                        (ß ___cv.visitField(ACC_FINAL, "__meta", IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
                                    )
                                    ;; instance fields for closed-overs
                                    (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'keys(closes)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                        (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                                            (if (ß isDeftype())
                                                (do
                                                    (let [#_"int" ___access (ß isVolatile(___lb) ? ACC_VOLATILE :or isMutable(___lb) ? 0 :or (ACC_PUBLIC + ACC_FINAL))]
                                                        (§ let [#_"FieldVisitor" ___fv]
                                                            (if (ß ___lb.getPrimitiveType() != nil)
                                                                (do
                                                                    (§ ass ___fv (ß ___cv.visitField(___access, ___lb.name, Type/getType(___lb.getPrimitiveType()).getDescriptor(), nil, nil)))
                                                                )
                                                                (do
                                                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                                                    (§ ass ___fv (ß ___cv.visitField(___access, ___lb.name, OBJECT_TYPE.getDescriptor(), nil, nil)))
                                                                )
                                                            )
                                                            (ß addAnnotation(___fv, RT'meta(___lb.sym)))
                                                        )
                                                    )
                                                )
                                                (do
                                                    ;; todo - only enable this non-private+writability for letfns where we need it
                                                    (if (ß ___lb.getPrimitiveType() != nil)
                                                        (do
                                                            (ß ___cv.visitField(0 + (isVolatile(___lb) ? ACC_VOLATILE :or 0), ___lb.name, Type/getType(___lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                                        )
                                                        (do
                                                            (ß ___cv.visitField(0, ___lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )

                                    ;; static fields for callsites and thunks
                                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < protocolCallsites.count()) [(§ ass ___i (ß ___i + 1))]
                                        (ß ___cv.visitField(ACC_PRIVATE + ACC_STATIC, cachedClassName(___i), CLASS_TYPE.getDescriptor(), nil, nil))
                                    )

                                    ;; ctor that takes closed-overs and inits base + fields
                                    (let [#_"Method" ___m (ß new Method("<init>", Type/VOID_TYPE, ctorTypes()))]
                                        (let [#_"GeneratorAdapter" ___ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, ___m, nil, nil, ___cv))]
                                            (let [#_"Label" ___start (ß ___ctorgen.newLabel())]
                                                (let [#_"Label" ___end (ß ___ctorgen.newLabel())]
                                                    (ß ___ctorgen.visitCode())
                                                    (ß ___ctorgen.visitLineNumber(line, ___ctorgen.mark()))
                                                    (ß ___ctorgen.visitLabel(___start))
                                                    (ß ___ctorgen.loadThis())
                                                    (ß ___ctorgen.invokeConstructor(Type/getObjectType(___superName), voidctor))

                                                    (when (ß supportsMeta())
                                                        (ß ___ctorgen.loadThis())
                                                        (ß ___ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE.getOpcode(Opcodes/ILOAD), 1))
                                                        (ß ___ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TYPE))
                                                    )

                                                    (let [#_"int" ___a (ß supportsMeta() ? 2 :or 1)]
                                                        (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'keys(closes)))] (some? ___s) [(§ ass ___s (ß ___s.next()), ___a (ß ___a + 1))]
                                                            (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                                                                (ß ___ctorgen.loadThis())
                                                                (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                                                                    (if (some? ___primc)
                                                                        (do
                                                                            (ß ___ctorgen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), ___a))
                                                                            (ß ___ctorgen.putField(objtype, ___lb.name, Type/getType(___primc)))
                                                                            (when (ß ___primc == Long/TYPE || ___primc == Double/TYPE)
                                                                                (§ ass ___a (ß ___a + 1))
                                                                            )
                                                                        )
                                                                        (do
                                                                            (ß ___ctorgen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ILOAD), ___a))
                                                                            (ß ___ctorgen.putField(objtype, ___lb.name, OBJECT_TYPE))
                                                                        )
                                                                    )
                                                                    (§ ass closesExprs (ß closesExprs.cons(new LocalBindingExpr(___lb, nil))))
                                                                )
                                                            )
                                                        )

                                                        (ß ___ctorgen.visitLabel(___end))

                                                        (ß ___ctorgen.returnValue())

                                                        (ß ___ctorgen.endMethod())

                                                        (when (ß altCtorDrops > 0)
                                                            ;; ctor that takes closed-overs and inits base + fields
                                                            (let [#_"Type[]" ___ctorTypes (ß ___ctorTypes())]
                                                                (let [#_"Type[]" ___altCtorTypes (ß new Type[___ctorTypes.length-altCtorDrops])]
                                                                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___altCtorTypes.length) [(§ ass ___i (ß ___i + 1))]
                                                                        (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                                                    )
                                                                    (let [#_"Method" ___alt (ß new Method("<init>", Type/VOID_TYPE, ___altCtorTypes))]
                                                                        (§ ass ___ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, ___alt, nil, nil, ___cv)))
                                                                        (ß ___ctorgen.visitCode())
                                                                        (ß ___ctorgen.loadThis())
                                                                        (ß ___ctorgen.loadArgs())

                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __meta
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __extmap
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                                                        (ß ___ctorgen.invokeConstructor(objtype, new Method("<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (ß ___ctorgen.returnValue())
                                                                        (ß ___ctorgen.endMethod())

                                                                        ;; alt ctor no __hash, __hasheq
                                                                        (§ ass ___altCtorTypes (ß new Type[___ctorTypes.length-2]))
                                                                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___altCtorTypes.length) [(§ ass ___i (ß ___i + 1))]
                                                                            (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                                                        )

                                                                        (§ ass ___alt (ß new Method("<init>", Type/VOID_TYPE, ___altCtorTypes)))
                                                                        (§ ass ___ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, ___alt, nil, nil, ___cv)))
                                                                        (ß ___ctorgen.visitCode())
                                                                        (ß ___ctorgen.loadThis())
                                                                        (ß ___ctorgen.loadArgs())

                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                                                        (ß ___ctorgen.invokeConstructor(objtype, new Method("<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (ß ___ctorgen.returnValue())
                                                                        (ß ___ctorgen.endMethod())
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (when (ß supportsMeta())
                                                            ;; ctor that takes closed-overs but not meta
                                                            (let [#_"Type[]" ___ctorTypes (ß ___ctorTypes())]
                                                                (let [#_"Type[]" ___noMetaCtorTypes (ß new Type[___ctorTypes.length-1])]
                                                                    (loop-when-recur [(§ var #_"int" ___i 1)] (ß ___i < ___ctorTypes.length) [(§ ass ___i (ß ___i + 1))]
                                                                        (§ ass (ß ___noMetaCtorTypes[___i - 1]) (ß ___ctorTypes[___i]))
                                                                    )
                                                                    (let [#_"Method" ___alt (ß new Method("<init>", Type/VOID_TYPE, ___noMetaCtorTypes))]
                                                                        (§ ass ___ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, ___alt, nil, nil, ___cv)))
                                                                        (ß ___ctorgen.visitCode())
                                                                        (ß ___ctorgen.loadThis())
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; nil meta
                                                                        (ß ___ctorgen.loadArgs())
                                                                        (ß ___ctorgen.invokeConstructor(objtype, new Method("<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (ß ___ctorgen.returnValue())
                                                                        (ß ___ctorgen.endMethod())

                                                                        ;; meta()
                                                                        (let [#_"Method" ___meth (ß Method/getMethod("cloiure.lang.IPersistentMap meta()"))]
                                                                            (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC, ___meth, nil, nil, ___cv))]
                                                                                (ß ___gen.visitCode())
                                                                                (ß ___gen.loadThis())
                                                                                (ß ___gen.getField(objtype, "__meta", IPERSISTENTMAP_TYPE))

                                                                                (ß ___gen.returnValue())
                                                                                (ß ___gen.endMethod())

                                                                                ;; withMeta()
                                                                                (§ ass ___meth (ß Method/getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))

                                                                                (§ ass ___gen (ß new GeneratorAdapter(ACC_PUBLIC, ___meth, nil, nil, ___cv)))
                                                                                (ß ___gen.visitCode())
                                                                                (ß ___gen.newInstance(objtype))
                                                                                (ß ___gen.dup())
                                                                                (ß ___gen.loadArg(0))

                                                                                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'keys(closes)))] (some? ___s) [(§ ass ___s (ß ___s.next()), ___a (ß ___a + 1))]
                                                                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                                                                                        (ß ___gen.loadThis())
                                                                                        (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                                                                                            (if (some? ___primc)
                                                                                                (do
                                                                                                    (ß ___gen.getField(objtype, ___lb.name, Type/getType(___primc)))
                                                                                                )
                                                                                                (do
                                                                                                    (ß ___gen.getField(objtype, ___lb.name, OBJECT_TYPE))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )

                                                                                (ß ___gen.invokeConstructor(objtype, new Method("<init>", Type/VOID_TYPE, ___ctorTypes)))
                                                                                (ß ___gen.returnValue())
                                                                                (ß ___gen.endMethod())
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (ß emitStatics(___cv))
                                                        (ß emitMethods(___cv))

                                                        ;; static fields for constants
                                                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < constants.count()) [(§ ass ___i (ß ___i + 1))]
                                                            (when (ß usedConstants.contains(___i))
                                                                (ß ___cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, constantName(___i), constantType(___i).getDescriptor(), nil, nil))
                                                            )
                                                        )

                                                        ;; static fields for lookup sites
                                                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < keywordCallsites.count()) [(§ ass ___i (ß ___i + 1))]
                                                            (ß ___cv.visitField(ACC_FINAL + ACC_STATIC, siteNameStatic(___i), KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                                                            (ß ___cv.visitField(ACC_STATIC, thunkNameStatic(___i), ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
                                                        )

                                                        ;; static init for constants, keywords and vars
                                                        (let [#_"GeneratorAdapter" ___clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method/getMethod("void <clinit> ()"), nil, nil, ___cv))]
                                                            (ß ___clinitgen.visitCode())
                                                            (ß ___clinitgen.visitLineNumber(line, ___clinitgen.mark()))

                                                            (when (ß constants.count() > 0)
                                                                (ß emitConstants(___clinitgen))
                                                            )

                                                            (when (ß keywordCallsites.count() > 0)
                                                                (ß emitKeywordCallsites(___clinitgen))
                                                            )

                                                            (when (ß isDeftype() && RT'booleanCast(RT'get(opts, loadNs)))
                                                                (let [#_"String" ___nsname (ß ((Symbol)RT'second(src)).getNamespace())]
                                                                    (when (ß !___nsname.equals("cloiure.core"))
                                                                        (ß ___clinitgen.push("cloiure.core"))
                                                                        (ß ___clinitgen.push("require"))
                                                                        (ß ___clinitgen.invokeStatic(RT_TYPE, Method/getMethod("cloiure.lang.Var var(String,String)")))
                                                                        (ß ___clinitgen.invokeVirtual(VAR_TYPE, Method/getMethod("Object getRawRoot()")))
                                                                        (ß ___clinitgen.checkCast(IFN_TYPE))
                                                                        (ß ___clinitgen.push(___nsname))
                                                                        (ß ___clinitgen.invokeStatic(SYMBOL_TYPE, Method/getMethod("cloiure.lang.Symbol create(String)")))
                                                                        (ß ___clinitgen.invokeInterface(IFN_TYPE, Method/getMethod("Object invoke(Object)")))
                                                                        (ß ___clinitgen.pop())
                                                                    )
                                                                )
                                                            )

                                                            (ß ___clinitgen.returnValue())

                                                            (ß ___clinitgen.endMethod())

                                                            ;; end of class
                                                            (ß ___cv.visitEnd())

                                                            (§ ass bytecode (ß ___cw.toByteArray()))
                                                            (when (ß RT'booleanCast(COMPILE_FILES.deref()))
                                                                (ß writeClassFile(internalName, bytecode))
                                                            )
                                                            nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" emitKeywordCallsites [#_"ObjExpr" this, #_"GeneratorAdapter" ___clinitgen]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < keywordCallsites.count()) [(§ ass ___i (ß ___i + 1))]
            (let [#_"Keyword" ___k (ß (Keyword) keywordCallsites.nth(___i))]
                (ß ___clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE))
                (ß ___clinitgen.dup())
                (ß emitValue(___k, ___clinitgen))
                (ß ___clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE, Method/getMethod("void <init>(cloiure.lang.Keyword)")))
                (ß ___clinitgen.dup())
                (ß ___clinitgen.putStatic(objtype, siteNameStatic(___i), KEYWORD_LOOKUPSITE_TYPE))
                (ß ___clinitgen.putStatic(objtype, thunkNameStatic(___i), ILOOKUP_THUNK_TYPE))
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" emitStatics [#_"ObjExpr" this, #_"ClassVisitor" ___gen]
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" emitMethods [#_"ObjExpr" this, #_"ClassVisitor" ___gen]
        nil
    )

    #_method
    (§ defn #_"void" emitListAsObjectArray [#_"ObjExpr" this, #_"Object" ___value, #_"GeneratorAdapter" ___gen]
        (ß ___gen.push(((List) ___value).size()))
        (ß ___gen.newArray(OBJECT_TYPE))
        (let [#_"int" ___i 0]
            (loop-when-recur [(§ var #_"Iterator" ___it (ß ((List) ___value).iterator()))] (ß ___it.hasNext()) [(§ ass ___i (ß ___i + 1))]
                (ß ___gen.dup())
                (ß ___gen.push(___i))
                (ß emitValue(___it.next(), ___gen))
                (ß ___gen.arrayStore(OBJECT_TYPE))
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" emitValue [#_"ObjExpr" this, #_"Object" ___value, #_"GeneratorAdapter" ___gen]
        (let [#_"boolean" ___partial true]
            (cond (nil? ___value)
                (do
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                )
                (ß ___value instanceof String)
                (do
                    (ß ___gen.push((String) ___value))
                )
                (ß ___value instanceof Boolean)
                (do
                    (if (ß ((Boolean) ___value).booleanValue())
                        (do
                            (ß ___gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE))
                        )
                        (do
                            (ß ___gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE))
                        )
                    )
                )
                (ß ___value instanceof Integer)
                (do
                    (ß ___gen.push(((Integer) ___value).intValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Integer)), Method/getMethod("Integer valueOf(int)")))
                )
                (ß ___value instanceof Long)
                (do
                    (ß ___gen.push(((Long) ___value).longValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Long)), Method/getMethod("Long valueOf(long)")))
                )
                (ß ___value instanceof Double)
                (do
                    (ß ___gen.push(((Double) ___value).doubleValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Double)), Method/getMethod("Double valueOf(double)")))
                )
                (ß ___value instanceof Character)
                (do
                    (ß ___gen.push(((Character) ___value).charValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Character)), Method/getMethod("Character valueOf(char)")))
                )
                (ß ___value instanceof Class)
                (do
                    (let [#_"Class" ___cc (ß (Class)___value)]
                        (if (ß ___cc.isPrimitive())
                            (do
                                (§ let [#_"Type" ___bt]
                                    (cond (ß ___cc == (§ class boolean))
                                        (do
                                            (§ ass ___bt (ß Type/getType((§ class Boolean))))
                                        )
                                        (ß ___cc == (§ class byte))
                                        (do
                                            (§ ass ___bt (ß Type/getType((§ class Byte))))
                                        )
                                        (ß ___cc == (§ class char))
                                        (do
                                            (§ ass ___bt (ß Type/getType((§ class Character))))
                                        )
                                        (ß ___cc == (§ class double))
                                        (do
                                            (§ ass ___bt (ß Type/getType((§ class Double))))
                                        )
                                        (ß ___cc == (§ class float))
                                        (do
                                            (§ ass ___bt (ß Type/getType((§ class Float))))
                                        )
                                        (ß ___cc == (§ class int))
                                        (do
                                            (§ ass ___bt (ß Type/getType((§ class Integer))))
                                        )
                                        (ß ___cc == (§ class long))
                                        (do
                                            (§ ass ___bt (ß Type/getType((§ class Long))))
                                        )
                                        (ß ___cc == (§ class short))
                                        (do
                                            (§ ass ___bt (ß Type/getType((§ class Short))))
                                        )
                                        :else
                                        (do
                                            (throw (ß Util'runtimeException("Can't embed unknown primitive in code: " + ___value)))
                                        )
                                    )
                                    (ß ___gen.getStatic(___bt, "TYPE", Type/getType((§ class Class))))
                                )
                            )
                            (do
                                (ß ___gen.push(destubClassName(___cc.getName())))
                                (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("Class classForName(String)")))
                            )
                        )
                    )
                )
                (ß ___value instanceof Symbol)
                (do
                    (ß ___gen.push(((Symbol) ___value).ns))
                    (ß ___gen.push(((Symbol) ___value).name))
                    (ß ___gen.invokeStatic(Type/getType((§ class Symbol)), Method/getMethod("cloiure.lang.Symbol intern(String,String)")))
                )
                (ß ___value instanceof Keyword)
                (do
                    (ß ___gen.push(((Keyword) ___value).sym.ns))
                    (ß ___gen.push(((Keyword) ___value).sym.name))
                    (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("cloiure.lang.Keyword keyword(String,String)")))
                )
                (ß ___value instanceof Var)
                (do
                    (let [#_"Var" ___var (ß (Var) ___value)]
                        (ß ___gen.push(___var.ns.name.toString()))
                        (ß ___gen.push(___var.sym.toString()))
                        (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("cloiure.lang.Var var(String,String)")))
                    )
                )
                (ß ___value instanceof IType)
                (do
                    (let [#_"Method" ___ctor (ß new Method("<init>", Type/getConstructorDescriptor(___value.getClass().getConstructors()[0])))]
                        (ß ___gen.newInstance(Type/getType(___value.getClass())))
                        (ß ___gen.dup())
                        (let [#_"IPersistentVector" ___fields (ß (IPersistentVector) Reflector'invokeStaticMethod(___value.getClass(), "getBasis", new Object[] (§ array )))]
                            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___fields)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                (let [#_"Symbol" ___field (ß (Symbol) ___s.first())]
                                    (let [#_"Class" ___k (ß tagClass(tagOf(___field)))]
                                        (let [#_"Object" ___val (ß Reflector'getInstanceField(___value, munge(___field.name)))]
                                            (ß emitValue(___val, ___gen))

                                            (when (ß ___k.isPrimitive())
                                                (let [#_"Type" ___b (ß Type/getType(boxClass(___k)))]
                                                    (let [#_"String" ___p (ß Type/getType(___k).getDescriptor())]
                                                        (let [#_"String" ___n (ß ___k.getName())]
                                                            (ß ___gen.invokeVirtual(___b, new Method(___n + "Value", "()" + ___p)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (ß ___gen.invokeConstructor(Type/getType(___value.getClass()), ___ctor))
                        )
                    )
                )
                (ß ___value instanceof IRecord)
                (do
                    (let [#_"Method" ___createMethod (ß Method/getMethod(___value.getClass().getName() + " create(cloiure.lang.IPersistentMap)"))]
                        (ß emitValue(PersistentArrayMap'create((java.util.Map) ___value), ___gen))
                        (ß ___gen.invokeStatic(getType(___value.getClass()), ___createMethod))
                    )
                )
                (ß ___value instanceof IPersistentMap)
                (do
                    (let [#_"List" ___entries (ArrayList.)]
                        (doseq [#_"Map$Entry" ___entry (ß (Set<Map$Entry>) ((Map) ___value).entrySet())]
                            (ß ___entries.add(___entry.getKey()))
                            (ß ___entries.add(___entry.getValue()))
                        )
                        (ß emitListAsObjectArray(___entries, ___gen))
                        (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("cloiure.lang.IPersistentMap map(Object[])")))
                    )
                )
                (ß ___value instanceof IPersistentVector)
                (do
                    (let [#_"IPersistentVector" ___args (ß (IPersistentVector) ___value)]
                        (if (ß ___args.count() <= Tuple'MAX_SIZE)
                            (do
                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___args.count()) [(§ ass ___i (ß ___i + 1))]
                                    (ß emitValue(___args.nth(___i), ___gen))
                                )
                                (ß ___gen.invokeStatic(TUPLE_TYPE, createTupleMethods[___args.count()]))
                            )
                            (do
                                (ß emitListAsObjectArray(___value, ___gen))
                                (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                            )
                        )
                    )
                )
                (ß ___value instanceof PersistentHashSet)
                (do
                    (let [#_"ISeq" ___vs (ß RT'seq(___value))]
                        (if (nil? ___vs)
                            (do
                                (ß ___gen.getStatic(Type/getType((§ class PersistentHashSet)), "EMPTY", Type/getType((§ class PersistentHashSet))))
                            )
                            (do
                                (ß emitListAsObjectArray(___vs, ___gen))
                                (ß ___gen.invokeStatic(Type/getType((§ class PersistentHashSet)), Method/getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                            )
                        )
                    )
                )
                (ß ___value instanceof ISeq || ___value instanceof IPersistentList)
                (do
                    (ß emitListAsObjectArray(___value, ___gen))
                    (ß ___gen.invokeStatic(Type/getType((§ class java.util.Arrays)), Method/getMethod("java.util.List asList(Object[])")))
                    (ß ___gen.invokeStatic(Type/getType((§ class PersistentList)), Method/getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
                )
                (ß ___value instanceof Pattern)
                (do
                    (ß emitValue(___value.toString(), ___gen))
                    (ß ___gen.invokeStatic(Type/getType((§ class Pattern)), Method/getMethod("java.util.regex.Pattern compile(String)")))
                )
                :else
                (do
                    (let [#_"String" ___cs nil]
                        (try
                            (§ ass ___cs (ß RT'printString(___value)))
                            (catch Exception ___e
                                (throw (ß Util'runtimeException("Can't embed object in code, maybe print-dup not defined: " + ___value)))
                            )
                        )
                        (when (ß ___cs.length() == 0)
                            (throw (ß Util'runtimeException("Can't embed unreadable object in code: " + ___value)))
                        )

                        (when (ß ___cs.startsWith("#<"))
                            (throw (ß Util'runtimeException("Can't embed unreadable object in code: " + ___cs)))
                        )

                        (ß ___gen.push(___cs))
                        (ß ___gen.invokeStatic(RT_TYPE, readStringMethod))
                        (§ ass ___partial false)
                    )
                )
            )

            (when ___partial
                (when (ß ___value instanceof IObj && RT'count(((IObj) ___value).meta()) > 0)
                    (ß ___gen.checkCast(IOBJ_TYPE))
                    (let [#_"Object" ___m (ß ((IObj) ___value).meta())]
                        (ß emitValue(elideMeta(___m), ___gen))
                        (ß ___gen.checkCast(IPERSISTENTMAP_TYPE))
                        (ß ___gen.invokeInterface(IOBJ_TYPE, Method/getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                    )
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" emitConstants [#_"ObjExpr" this, #_"GeneratorAdapter" ___clinitgen]
        (try
            (ß Var'pushThreadBindings(RT'map(RT'PRINT_DUP, RT'T)))

            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < constants.count()) [(§ ass ___i (ß ___i + 1))]
                (when (ß usedConstants.contains(___i))
                    (ß emitValue(constants.nth(___i), ___clinitgen))
                    (ß ___clinitgen.checkCast(constantType(___i)))
                    (ß ___clinitgen.putStatic(objtype, constantName(___i), constantType(___i)))
                )
            )
            (finally
                (ß Var'popThreadBindings())
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" isMutable [#_"ObjExpr" this, #_"LocalBinding" ___lb]
        (ß isVolatile(___lb) || RT'booleanCast(RT'contains(fields, ___lb.sym)) && RT'booleanCast(RT'get(___lb.sym.meta(), Keyword'intern("unsynchronized-mutable"))))
    )

    #_method
    (§ defn #_"boolean" isVolatile [#_"ObjExpr" this, #_"LocalBinding" ___lb]
        (ß RT'booleanCast(RT'contains(fields, ___lb.sym)) && RT'booleanCast(RT'get(___lb.sym.meta(), Keyword'intern("volatile-mutable"))))
    )

    #_method
    (§ defn #_"boolean" isDeftype [#_"ObjExpr" this]
        (ß (fields != nil))
    )

    #_method
    (§ defn #_"boolean" supportsMeta [#_"ObjExpr" this]
        (ß !isDeftype())
    )

    #_method
    (§ defn #_"void" emitClearCloses [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"Class" getCompiledClass [#_"ObjExpr" this]
        (§ sync this
            (when (nil? compiledClass)
                (§ ass loader (ß (DynamicClassLoader) LOADER.deref()))
                (§ ass compiledClass (ß loader.defineClass(name, bytecode, src)))
            )
            compiledClass
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"ObjExpr" this]
        (when (ß isDeftype())
            (§ return nil)
        )
        (try
            (ß getCompiledClass().newInstance())
            (catch Exception ___e
                (throw (ß Util'sneakyThrow(___e)))
            )
        )
    )

    #_method
    (§ defn #_"void" emitLetFnInits [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"ObjExpr" ___objx, #_"IPersistentSet" ___letFnLocals]
        ;; objx arg is enclosing objx, not this
        (ß ___gen.checkCast(objtype))

        (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'keys(closes)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                (when (ß ___letFnLocals.contains(___lb))
                    (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                        (ß ___gen.dup())
                        (if (some? ___primc)
                            (do
                                (ß ___objx.emitUnboxedLocal(___gen, ___lb))
                                (ß ___gen.putField(objtype, ___lb.name, Type/getType(___primc)))
                            )
                            (do
                                (ß ___objx.emitLocal(___gen, ___lb, false))
                                (ß ___gen.putField(objtype, ___lb.name, OBJECT_TYPE))
                            )
                        )
                    )
                )
            )
        )
        (ß ___gen.pop())
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"ObjExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
        ;; objx arg is enclosing objx, not this
        (if (ß isDeftype())
            (do
                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
            )
            (do
                (ß ___gen.newInstance(objtype))
                (ß ___gen.dup())
                (when (ß supportsMeta())
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                )
                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(closesExprs)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (let [#_"LocalBindingExpr" ___lbe (ß (LocalBindingExpr) ___s.first())]
                        (let [#_"LocalBinding" ___lb (ß ___lbe.b)]
                            (if (ß ___lb.getPrimitiveType() != nil)
                                (do
                                    (ß ___objx.emitUnboxedLocal(___gen, ___lb))
                                )
                                (do
                                    (ß ___objx.emitLocal(___gen, ___lb, ___lbe.shouldClear))
                                )
                            )
                        )
                    )
                )
                (ß ___gen.invokeConstructor(objtype, new Method("<init>", Type/VOID_TYPE, ctorTypes())))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"ObjExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"ObjExpr" this]
        (when (nil? jc)
            (§ ass jc (ß (compiledClass != nil) ? compiledClass :or (tag != nil) ? HostExpr'tagToClass(tag) :or (§ class IFn)))
        )
        jc
    )

    #_method
    (§ defn #_"void" emitAssignLocal [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb, #_"Expr" ___val]
        (when (ß !isMutable(___lb))
            (throw (IllegalArgumentException. (ß "Cannot assign to non-mutable: " + ___lb.name)))
        )
        (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
            (ß ___gen.loadThis())
            (if (some? ___primc)
                (do
                    (when (ß !(___val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) ___val).canEmitPrimitive()))
                        (throw (IllegalArgumentException. (ß "Must assign primitive to primitive mutable: " + ___lb.name)))
                    )
                    (let [#_"MaybePrimitiveExpr" ___me (ß (MaybePrimitiveExpr) ___val)]
                        (ß ___me.emitUnboxed(:Context'EXPRESSION, this, ___gen))
                        (ß ___gen.putField(objtype, ___lb.name, Type/getType(___primc)))
                    )
                )
                (do
                    (ß ___val.emit(:Context'EXPRESSION, this, ___gen))
                    (ß ___gen.putField(objtype, ___lb.name, OBJECT_TYPE))
                )
            )
            nil
        )
    )

    #_method
    (§ defn- #_"void" emitLocal [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb, #_"boolean" ___clear]
        (if (ß closes.containsKey(___lb))
            (do
                (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                    (ß ___gen.loadThis())
                    (if (some? ___primc)
                        (do
                            (ß ___gen.getField(objtype, ___lb.name, Type/getType(___primc)))
                            (ß HostExpr'emitBoxReturn(this, ___gen, ___primc))
                        )
                        (do
                            (ß ___gen.getField(objtype, ___lb.name, OBJECT_TYPE))
                            (when (ß onceOnly && ___clear && ___lb.canBeCleared)
                                (ß ___gen.loadThis())
                                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                (ß ___gen.putField(objtype, ___lb.name, OBJECT_TYPE))
                            )
                        )
                    )
                )
            )
            (do
                (let [#_"int" ___argoff (ß canBeDirect ? 0 :or 1)]
                    (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                        (if (ß ___lb.isArg)
                            (do
                                (ß ___gen.loadArg(___lb.idx-argoff))
                                (cond (some? ___primc)
                                    (do
                                        (ß HostExpr'emitBoxReturn(this, ___gen, ___primc))
                                    )
                                    (ß ___clear && ___lb.canBeCleared)
                                    (do
                                        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                        (ß ___gen.storeArg(___lb.idx - ___argoff))
                                    )
                                )
                            )
                            (do
                                (if (some? ___primc)
                                    (do
                                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), ___lb.idx))
                                        (ß HostExpr'emitBoxReturn(this, ___gen, ___primc))
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ILOAD), ___lb.idx))
                                        (when (ß ___clear && ___lb.canBeCleared)
                                            (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                            (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___lb.idx))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" emitUnboxedLocal [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb]
        (let [#_"int" ___argoff (ß canBeDirect ? 0 :or 1)]
            (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                (cond (ß closes.containsKey(___lb))
                    (do
                        (ß ___gen.loadThis())
                        (ß ___gen.getField(objtype, ___lb.name, Type/getType(___primc)))
                    )
                    (ß ___lb.isArg)
                    (do
                        (ß ___gen.loadArg(___lb.idx-argoff))
                    )
                    :else
                    (do
                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), ___lb.idx))
                    )
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"void" emitVar [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Var" ___var]
        (let [#_"Integer" ___i (ß (Integer) vars.valAt(___var))]
            (ß emitConstant(___gen, ___i))
            nil
        )
    )

    (§ def #_"Method" ObjExpr'varGetMethod (ß Method/getMethod("Object get()")))
    (§ def #_"Method" ObjExpr'varGetRawMethod (ß Method/getMethod("Object getRawRoot()")))

    #_method
    (§ defn #_"void" emitVarValue [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Var" ___v]
        (let [#_"Integer" ___i (ß (Integer) vars.valAt(___v))]
            (if (ß !___v.isDynamic())
                (do
                    (ß emitConstant(___gen, ___i))
                    (ß ___gen.invokeVirtual(VAR_TYPE, ObjExpr'varGetRawMethod))
                )
                (do
                    (ß emitConstant(___gen, ___i))
                    (ß ___gen.invokeVirtual(VAR_TYPE, varGetMethod))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" emitKeyword [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Keyword" ___k]
        (let [#_"Integer" ___i (ß (Integer) keywords.valAt(___k))]
            (ß emitConstant(___gen, ___i))
            nil
        )
    )

    #_method
    (§ defn #_"void" emitConstant [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"int" ___id]
        (§ ass usedConstants (ß (IPersistentSet) usedConstants.cons(___id)))
        (ß ___gen.getStatic(objtype, constantName(___id), constantType(___id)))
        nil
    )

    #_method
    (§ defn #_"String" constantName [#_"ObjExpr" this, #_"int" ___id]
        (ß CONST_PREFIX + ___id)
    )

    #_method
    (§ defn #_"String" siteName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__site__" + ___n)
    )

    #_method
    (§ defn #_"String" siteNameStatic [#_"ObjExpr" this, #_"int" ___n]
        (ß siteName(___n) + "__")
    )

    #_method
    (§ defn #_"String" thunkName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__thunk__" + ___n)
    )

    #_method
    (§ defn #_"String" cachedClassName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__cached_class__" + ___n)
    )

    #_method
    (§ defn #_"String" cachedVarName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__cached_var__" + ___n)
    )

    #_method
    (§ defn #_"String" varCallsiteName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__var__callsite__" + ___n)
    )

    #_method
    (§ defn #_"String" thunkNameStatic [#_"ObjExpr" this, #_"int" ___n]
        (ß thunkName(___n) + "__")
    )

    #_method
    (§ defn #_"Type" constantType [#_"ObjExpr" this, #_"int" ___id]
        (let [#_"Object" ___o (ß constants.nth(___id))]
            (let [#_"Class" ___c (ß cloiure.lang.Util'classOf(___o))]
                (when (ß ___c != nil && Modifier/isPublic(___c.getModifiers()))
                    ;; can't emit derived fn types due to visibility
                    (cond (ß (§ class LazySeq).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class ISeq))))
                        )
                        (ß ___c == (§ class Keyword))
                        (do
                            (§ return (ß Type/getType((§ class Keyword))))
                        )
                        (ß (§ class RestFn).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class RestFn))))
                        )
                        (ß (§ class AFn).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class AFn))))
                        )
                        (ß ___c == (§ class Var))
                        (do
                            (§ return (ß Type/getType((§ class Var))))
                        )
                        (ß ___c == (§ class String))
                        (do
                            (§ return (ß Type/getType((§ class String))))
                        )
                    )
                )
                OBJECT_TYPE
            )
        )
    )
)

(def PathType'enum-set
    (hash-set
        :PathType'PATH
        :PathType'BRANCH
    )
)

(class-ns PathNode
    (§ init
        (§ field #_"PathType" type nil)
        (§ field #_"PathNode" parent nil)
    )

    (§ constructor #_"PathNode" PathNode [#_"PathType" ___type, #_"PathNode" ___parent]
        (let [this (ß super())]
            (§ ass (ß this.type) ___type)
            (§ ass (ß this.parent) ___parent)
            this
        )
    )
)

(def PState'enum-set
    (hash-set
        :PState'REQ
        :PState'REST
        :PState'DONE
    )
)

(class-ns FnMethod (§ extends ObjMethod)
    (§ init
        ;; localbinding->localbinding
        (§ field #_"PersistentVector" reqParms (ß PersistentVector'EMPTY))
        (§ field #_"LocalBinding" restParm nil)
        (§ field #_"Type[]" argtypes nil)
        (§ field #_"Class[]" argclasses nil)
        (§ field #_"Class" retClass nil)
        (§ field #_"String" prim nil)
    )

    (§ constructor #_"FnMethod" FnMethod [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (let [this (ß super(___objx, ___parent))]
            this
        )
    )

    (§ defn #_"char" FnMethod'classChar [#_"Object" ___x]
        (let [#_"Class" ___c nil]
            (cond (ß ___x instanceof Class)
                (do
                    (§ ass ___c (ß (Class) ___x))
                )
                (ß ___x instanceof Symbol)
                (do
                    (§ ass ___c (ß primClass((Symbol) ___x)))
                )
            )
            (when (ß ___c == nil || !___c.isPrimitive())
                (§ return (ß \O))
            )
            (when (ß ___c == (§ class long))
                (§ return (ß \L))
            )
            (when (ß ___c == (§ class double))
                (§ return (ß \D))
            )
            (throw (IllegalArgumentException. "Only long and double primitives are supported"))
        )
    )

    (§ defn #_"String" FnMethod'primInterface [#_"IPersistentVector" ___arglist]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___arglist.count()) [(§ ass ___i (ß ___i + 1))]
                (ß ___sb.append(classChar(tagOf(___arglist.nth(___i)))))
            )
            (ß ___sb.append(classChar(tagOf(___arglist))))
            (let [#_"String" ___ret (ß ___sb.toString())]
                (let [#_"boolean" ___prim (ß ___ret.contains("L") || ___ret.contains("D"))]
                    (when (ß ___prim && ___arglist.count() > 4)
                        (throw (IllegalArgumentException. "fns taking primitives support only 4 or fewer args"))
                    )
                    (when ___prim
                        (§ return (ß "cloiure.lang.IFn$" + ___ret))
                    )
                    nil
                )
            )
        )
    )

    (§ defn #_"FnMethod" FnMethod'parse [#_"ObjExpr" ___objx, #_"ISeq" ___form, #_"Object" ___rettag]
        ;; ([args] body...)
        (let [#_"IPersistentVector" ___parms (ß (IPersistentVector) RT'first(___form))]
            (let [#_"ISeq" ___body (ß RT'next(___form))]
                (try
                    (let [#_"FnMethod" ___method (ß new FnMethod(___objx, (ObjMethod) METHOD.deref()))]
                        (§ ass (ß ___method.line) (ß lineDeref()))
                        (§ ass (ß ___method.column) (ß columnDeref()))
                        ;; register as the current method and set up a new env frame
                        (let [#_"PathNode" ___pnode (ß (PathNode) CLEAR_PATH.get())]
                            (when (nil? ___pnode)
                                (§ ass ___pnode (ß new PathNode(:PathType'PATH, nil)))
                            )
                            (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                (§ map
                                    METHOD                ___method
                                    LOCAL_ENV             (ß LOCAL_ENV.deref())
                                    LOOP_LOCALS           nil
                                    NEXT_LOCAL_NUM        0
                                    CLEAR_PATH            ___pnode
                                    CLEAR_ROOT            ___pnode
                                    CLEAR_SITES           (ß PersistentHashMap'EMPTY)
                                    METHOD_RETURN_CONTEXT (ß RT'T)
                                )
                            )))

                            (§ ass (ß ___method.prim) (ß primInterface(___parms)))
                            (when (ß ___method.prim != nil)
                                (§ ass (ß ___method.prim) (ß ___method.prim.replace(\., \/)))
                            )

                            (when (ß ___rettag instanceof String)
                                (§ ass ___rettag (ß Symbol'intern(nil, (String) ___rettag)))
                            )
                            (when (ß !(___rettag instanceof Symbol))
                                (§ ass ___rettag nil)
                            )
                            (when (some? ___rettag)
                                (let [#_"String" ___retstr (ß ((Symbol)___rettag).getName())]
                                    (when (ß !(___retstr.equals("long") || ___retstr.equals("double")))
                                        (§ ass ___rettag nil)
                                    )
                                )
                            )
                            (§ ass (ß ___method.retClass) (ß tagClass((tagOf(___parms) != nil) ? tagOf(___parms) :or ___rettag)))
                            (if (ß ___method.retClass.isPrimitive())
                                (do
                                    (when (ß !(___method.retClass == (§ class double) || ___method.retClass == (§ class long)))
                                        (throw (IllegalArgumentException. "Only long and double primitives are supported"))
                                    )
                                )
                                (do
                                    (§ ass (ß ___method.retClass) (§ class Object))
                                )
                            )
                            ;; register 'this' as local 0
                            (if (ß ___objx.thisName != nil)
                                (do
                                    (ß registerLocal(Symbol'intern(___objx.thisName), nil, nil, false))
                                )
                                (do
                                    (ß getAndIncLocalNum())
                                )
                            )
                            (let [#_"PState" ___state (ß :PState'REQ)]
                                (let [#_"PersistentVector" ___argLocals (ß PersistentVector'EMPTY)]
                                    (let [#_"ArrayList<Type>" ___argtypes (ArrayList.)]
                                        (let [#_"ArrayList<Class>" ___argclasses (ArrayList.)]
                                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___parms.count()) [(§ ass ___i (ß ___i + 1))]
                                                (when (ß !(___parms.nth(___i) instanceof Symbol))
                                                    (throw (IllegalArgumentException. "fn params must be Symbols"))
                                                )
                                                (let [#_"Symbol" ___p (ß (Symbol) ___parms.nth(___i))]
                                                    (when (ß ___p.getNamespace() != nil)
                                                        (throw (ß Util'runtimeException("Can't use qualified name as parameter: " + ___p)))
                                                    )
                                                    (if (ß ___p.equals(_AMP_))
                                                        (do
                                                            (if (ß ___state == :PState'REQ)
                                                                (do
                                                                    (§ ass ___state (ß :PState'REST))
                                                                )
                                                                (do
                                                                    (throw (ß Util'runtimeException("Invalid parameter list")))
                                                                )
                                                            )
                                                        )
                                                        (do
                                                            (let [#_"Class" ___pc (ß primClass(tagClass(tagOf(___p))))]
                                                                (when (ß ___pc.isPrimitive() && !(___pc == (§ class double) || ___pc == (§ class long)))
                                                                    (throw (IllegalArgumentException. (ß "Only long and double primitives are supported: " + ___p)))
                                                                )

                                                                (when (ß ___state == :PState'REST && tagOf(___p) != nil)
                                                                    (throw (ß Util'runtimeException("& arg cannot have type hint")))
                                                                )
                                                                (when (ß ___state == :PState'REST && ___method.prim != nil)
                                                                    (throw (ß Util'runtimeException("fns taking primitives cannot be variadic")))
                                                                )

                                                                (when (ß ___state == :PState'REST)
                                                                    (§ ass ___pc (§ class ISeq))
                                                                )
                                                                (ß ___argtypes.add(Type/getType(___pc)))
                                                                (ß ___argclasses.add(___pc))
                                                                (let [#_"LocalBinding" ___lb (ß ___pc.isPrimitive() ? registerLocal(___p, nil, new MethodParamExpr(___pc), true) :or registerLocal(___p, (___state == :PState'REST) ? ISEQ :or tagOf(___p), nil, true))]
                                                                    (§ ass ___argLocals (ß ___argLocals.cons(___lb)))
                                                                    (§ switch ___state
                                                                        (§ case :PState'REQ)
                                                                        (do
                                                                            (§ ass (ß ___method.reqParms) (ß ___method.reqParms.cons(___lb)))
                                                                            (§ break )
                                                                        )
                                                                        (§ case :PState'REST)
                                                                        (do
                                                                            (§ ass (ß ___method.restParm) ___lb)
                                                                            (§ ass ___state (ß :PState'DONE))
                                                                            (§ break )
                                                                        )
                                                                        (§ default )
                                                                        (do
                                                                            (throw (ß Util'runtimeException("Unexpected parameter")))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (when (ß ___method.reqParms.count() > MAX_POSITIONAL_ARITY)
                                                (throw (ß Util'runtimeException("Can't specify more than " + MAX_POSITIONAL_ARITY + " params")))
                                            )
                                            (ß LOOP_LOCALS.set(___argLocals))
                                            (§ ass (ß ___method.argLocals) ___argLocals)
                                            (§ ass (ß ___method.argtypes) (ß ___argtypes.toArray(new Type[___argtypes.size()])))
                                            (§ ass (ß ___method.argclasses) (ß ___argclasses.toArray(new Class[___argtypes.size()])))
                                            (when (ß ___method.prim != nil)
                                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___method.argclasses.length) [(§ ass ___i (ß ___i + 1))]
                                                    (when (ß ___method.argclasses[___i] == (§ class long) || ___method.argclasses[___i] == (§ class double))
                                                        (ß getAndIncLocalNum())
                                                    )
                                                )
                                            )
                                            (§ ass (ß ___method.body) (ß (new BodyParser()).parse(:Context'RETURN, ___body)))
                                            ___method
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (finally
                        (ß Var'popThreadBindings())
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emit [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (cond (ß ___fn.canBeDirect)
            (do
                (ß doEmitStatic(___fn, ___cv))
            )
            (some? prim)
            (do
                (ß doEmitPrim(___fn, ___cv))
            )
            :else
            (do
                (ß doEmit(___fn, ___cv))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" doEmitStatic [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Type" ___returnType (ß Type/getType(retClass))]
            (let [#_"Method" ___ms (ß new Method("invokeStatic", ___returnType, argtypes))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, ___ms, nil, EXCEPTION_TYPES, ___cv))]
                    (ß ___gen.visitCode())
                    (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                        (ß ___gen.visitLineNumber(line, ___loopLabel))
                        (try
                            (ß Var'pushThreadBindings(RT'map(LOOP_LABEL, ___loopLabel, METHOD, this)))
                            (ß emitBody(objx, ___gen, retClass, body))

                            (let [#_"Label" ___end (ß ___gen.mark())]
                                (loop-when-recur [(§ var #_"ISeq" ___lbs (ß argLocals.seq()))] (some? ___lbs) [(§ ass ___lbs (ß ___lbs.next()))]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                        (ß ___gen.visitLocalVariable(___lb.name, argtypes[___lb.idx].getDescriptor(), nil, ___loopLabel, ___end, ___lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )

                        (ß ___gen.returnValue())
                        (ß ___gen.endMethod())

                        ;; generate the regular invoke, calling the static method
                        (let [#_"Method" ___m (ß new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))]
                            ;; todo don't hardwire EXCEPTION_TYPES
                            (§ ass ___gen (ß new GeneratorAdapter(ACC_PUBLIC, ___m, nil, EXCEPTION_TYPES, ___cv)))
                            (ß ___gen.visitCode())
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < argtypes.length) [(§ ass ___i (ß ___i + 1))]
                                (ß ___gen.loadArg(___i))
                                (ß HostExpr'emitUnboxArg(___fn, ___gen, argclasses[___i]))
                                (when (ß !argclasses[___i].isPrimitive())
                                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                    (ß ___gen.storeArg(___i))
                                )
                            )
                            (let [#_"Label" ___callLabel (ß ___gen.mark())]
                                (ß ___gen.visitLineNumber(line, ___callLabel))
                                (ß ___gen.invokeStatic(objx.objtype, ___ms))
                                (ß ___gen.box(___returnType))

                                (ß ___gen.returnValue())
                                (ß ___gen.endMethod())

                                ;; generate primInvoke if prim
                                (when (some? prim)
                                    (when (ß retClass == (§ class double) || retClass == (§ class long))
                                        (§ ass ___returnType (ß getReturnType()))
                                    )
                                    (let [#_"else" ___returnType OBJECT_TYPE]
                                        (let [#_"Method" ___pm (ß new Method("invokePrim", ___returnType, argtypes))]
                                            ;; todo don't hardwire EXCEPTION_TYPES
                                            (§ ass ___gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL, ___pm, nil, EXCEPTION_TYPES, ___cv)))
                                            (ß ___gen.visitCode())
                                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < argtypes.length) [(§ ass ___i (ß ___i + 1))]
                                                (ß ___gen.loadArg(___i))
                                                (when (ß !argclasses[___i].isPrimitive())
                                                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                                    (ß ___gen.storeArg(___i))
                                                )
                                            )
                                            (ß ___gen.invokeStatic(objx.objtype, ___ms))

                                            (ß ___gen.returnValue())
                                            (ß ___gen.endMethod())
                                        )
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" doEmitPrim [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (§ let [#_"Type" ___returnType]
            (if (ß retClass == (§ class double) || retClass == (§ class long))
                (do
                    (§ ass ___returnType (ß getReturnType()))
                )
                (do
                    (§ ass ___returnType OBJECT_TYPE)
                )
            )
            (let [#_"Method" ___ms (ß new Method("invokePrim", ___returnType, argtypes))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL, ___ms, nil, EXCEPTION_TYPES, ___cv))]
                    (ß ___gen.visitCode())

                    (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                        (ß ___gen.visitLineNumber(line, ___loopLabel))
                        (try
                            (ß Var'pushThreadBindings(RT'map(LOOP_LABEL, ___loopLabel, METHOD, this)))
                            (ß emitBody(objx, ___gen, retClass, body))

                            (let [#_"Label" ___end (ß ___gen.mark())]
                                (ß ___gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0))
                                (loop-when-recur [(§ var #_"ISeq" ___lbs (ß argLocals.seq()))] (some? ___lbs) [(§ ass ___lbs (ß ___lbs.next()))]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                        (ß ___gen.visitLocalVariable(___lb.name, argtypes[___lb.idx-1].getDescriptor(), nil, ___loopLabel, ___end, ___lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )

                        (ß ___gen.returnValue())
                        (ß ___gen.endMethod())

                        ;; generate the regular invoke, calling the prim method
                        (let [#_"Method" ___m (ß new Method(getMethodName(), OBJECT_TYPE, getArgTypes()))]
                            ;; todo don't hardwire EXCEPTION_TYPES
                            (§ ass ___gen (ß new GeneratorAdapter(ACC_PUBLIC, ___m, nil, EXCEPTION_TYPES, ___cv)))
                            (ß ___gen.visitCode())
                            (ß ___gen.loadThis())
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < argtypes.length) [(§ ass ___i (ß ___i + 1))]
                                (ß ___gen.loadArg(___i))
                                (ß HostExpr'emitUnboxArg(___fn, ___gen, argclasses[___i]))
                            )
                            (ß ___gen.invokeInterface(Type/getType("L"+prim+";"), ___ms))
                            (ß ___gen.box(getReturnType()))

                            (ß ___gen.returnValue())
                            (ß ___gen.endMethod())
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" doEmit [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC, ___m, nil, EXCEPTION_TYPES, ___cv))]
                (ß ___gen.visitCode())

                (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                    (ß ___gen.visitLineNumber(line, ___loopLabel))
                    (try
                        (ß Var'pushThreadBindings(RT'map(LOOP_LABEL, ___loopLabel, METHOD, this)))

                        (ß body.emit(:Context'RETURN, ___fn, ___gen))
                        (let [#_"Label" ___end (ß ___gen.mark())]
                            (ß ___gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0))
                            (loop-when-recur [(§ var #_"ISeq" ___lbs (ß argLocals.seq()))] (some? ___lbs) [(§ ass ___lbs (ß ___lbs.next()))]
                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                    (ß ___gen.visitLocalVariable(___lb.name, "Ljava/lang/Object;", nil, ___loopLabel, ___end, ___lb.idx))
                                )
                            )
                        )
                        (finally
                            (ß Var'popThreadBindings())
                        )
                    )

                    (ß ___gen.returnValue())
                    (ß ___gen.endMethod())
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"PersistentVector" reqParms [#_"FnMethod" this]
        reqParms
    )

    #_method
    (§ defn #_"LocalBinding" restParm [#_"FnMethod" this]
        restParm
    )

    #_method
    (§ defn #_"boolean" isVariadic [#_"FnMethod" this]
        (ß (restParm != nil))
    )

    #_method
    (§ defn #_"int" numParams [#_"FnMethod" this]
        (ß reqParms.count() + (isVariadic() ? 1 :or 0))
    )

    #_method
    (§ defn #_"String" getMethodName [#_"FnMethod" this]
        (ß isVariadic() ? "doInvoke" :or "invoke")
    )

    #_method
    (§ defn #_"Type" getReturnType [#_"FnMethod" this]
        (when (some? prim) ;; objx.isStatic
            (§ return (ß Type/getType(retClass)))
        )
        OBJECT_TYPE
    )

    #_method
    (§ defn #_"Type[]" getArgTypes [#_"FnMethod" this]
        (when (ß isVariadic() && reqParms.count() == MAX_POSITIONAL_ARITY)
            (let [#_"Type[]" ___ret (ß new Type[MAX_POSITIONAL_ARITY + 1])]
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < MAX_POSITIONAL_ARITY + 1) [(§ ass ___i (ß ___i + 1))]
                    (§ ass (ß ___ret[___i]) OBJECT_TYPE)
                )
                (§ return ___ret)
            )
        )
        (ß ARG_TYPES[numParams()])
    )

    #_method
    (§ defn #_"void" emitClearLocals [#_"FnMethod" this, #_"GeneratorAdapter" ___gen]
        nil
    )
)

#_abstract
(class-ns ObjMethod
    (§ init
        ;; when closures are defined inside other closures,
        ;; the closed over locals need to be propagated to the enclosing objx
        (§ field #_"ObjMethod" parent nil)
        ;; localbinding->localbinding
        (§ field #_"IPersistentMap" locals nil)
        ;; num->localbinding
        (§ field #_"IPersistentMap" indexlocals nil)
        (§ field #_"Expr" body nil)
        (§ field #_"ObjExpr" objx nil)
        (§ field #_"PersistentVector" argLocals nil)
        (§ field #_"int" maxLocal 0)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
        (§ field #_"boolean" usesThis false)
        (§ field #_"PersistentHashSet" localsUsedInCatchFinally (ß PersistentHashSet'EMPTY))
        #_protected
        (§ field #_"IPersistentMap" methodMeta nil)
    )

    (§ constructor #_"ObjMethod" ObjMethod [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (let [this (ß super())]
            (§ ass (ß this.parent) ___parent)
            (§ ass (ß this.objx) ___objx)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" locals [#_"ObjMethod" this]
        locals
    )

    #_method
    (§ defn #_"Expr" body [#_"ObjMethod" this]
        body
    )

    #_method
    (§ defn #_"ObjExpr" objx [#_"ObjMethod" this]
        objx
    )

    #_method
    (§ defn #_"PersistentVector" argLocals [#_"ObjMethod" this]
        argLocals
    )

    #_method
    (§ defn #_"int" maxLocal [#_"ObjMethod" this]
        maxLocal
    )

    #_method
    (§ defn #_"int" line [#_"ObjMethod" this]
        line
    )

    #_method
    (§ defn #_"int" column [#_"ObjMethod" this]
        column
    )

    (§ defn #_"void" ObjMethod'emitBody [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___retClass, #_"Expr" ___body]
        (let [#_"MaybePrimitiveExpr" ___be (ß (MaybePrimitiveExpr) ___body)]
            (if (ß Util'isPrimitive(___retClass) && ___be.canEmitPrimitive())
                (do
                    (let [#_"Class" ___bc (ß maybePrimitiveType(___be))]
                        (cond (ß ___bc == ___retClass)
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                            )
                            (ß ___retClass == (§ class long) && ___bc == (§ class int))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.visitInsn(I2L))
                            )
                            (ß ___retClass == (§ class double) && ___bc == (§ class float))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.visitInsn(F2D))
                            )
                            (ß ___retClass == (§ class int) && ___bc == (§ class long))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("int intCast(long)")))
                            )
                            (ß ___retClass == (§ class float) && ___bc == (§ class double))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.visitInsn(D2F))
                            )
                            :else
                            (do
                                (throw (ß new IllegalArgumentException("Mismatched primitive return, expected: " + ___retClass + ", had: " + ___be.getJavaClass())))
                            )
                        )
                    )
                )
                (do
                    (ß ___body.emit(:Context'RETURN, ___objx, ___gen))
                    (if (ß ___retClass == (§ class void))
                        (do
                            (ß ___gen.pop())
                        )
                        (do
                            (ß ___gen.unbox(Type/getType(___retClass)))
                        )
                    )
                )
            )
            nil
        )
    )

    #_abstract
    (§ defn #_"int" numParams [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"String" getMethodName [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type" getReturnType [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type[]" getArgTypes [#_"ObjMethod" this])

    #_method
    (§ defn #_"void" emit [#_"ObjMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC, ___m, nil, EXCEPTION_TYPES, ___cv))]
                (ß ___gen.visitCode())

                (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                    (ß ___gen.visitLineNumber(line, ___loopLabel))
                    (try
                        (ß Var'pushThreadBindings(RT'map(LOOP_LABEL, ___loopLabel, METHOD, this)))

                        (ß body.emit(:Context'RETURN, ___fn, ___gen))
                        (let [#_"Label" ___end (ß ___gen.mark())]
                            (ß ___gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0))
                            (loop-when-recur [(§ var #_"ISeq" ___lbs (ß argLocals.seq()))] (some? ___lbs) [(§ ass ___lbs (ß ___lbs.next()))]
                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                    (ß ___gen.visitLocalVariable(___lb.name, "Ljava/lang/Object;", nil, ___loopLabel, ___end, ___lb.idx))
                                )
                            )
                        )
                        (finally
                            (ß Var'popThreadBindings())
                        )
                    )

                    (ß ___gen.returnValue())
                    (ß ___gen.endMethod())
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emitClearLocals [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"void" emitClearLocalsOld [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < argLocals.count()) [(§ ass ___i (ß ___i + 1))]
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) argLocals.nth(___i))]
                (when (ß !localsUsedInCatchFinally.contains(___lb.idx) && ___lb.getPrimitiveType() == nil)
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                    (ß ___gen.storeArg(___lb.idx - 1))
                )
            )
        )
        (loop-when-recur [(§ var #_"int" ___i (ß numParams() + 1))] (ß ___i < maxLocal + 1) [(§ ass ___i (ß ___i + 1))]
            (when (ß !localsUsedInCatchFinally.contains(___i))
                (let [#_"LocalBinding" ___b (ß (LocalBinding) RT'get(indexlocals, ___i))]
                    (when (ß ___b == nil || maybePrimitiveType(___b.init) == nil)
                        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                        (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___i))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emitClearThis [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
        (ß ___gen.visitVarInsn(Opcodes/ASTORE, 0))
        nil
    )
)

(class-ns LocalBinding
    (§ init
        (§ field #_"Symbol" sym nil)
        (§ field #_"Symbol" tag nil)
        (§ field #_"Expr" init nil)
        (§ field #_"int" idx 0)
        (§ field #_"String" name nil)
        (§ field #_"boolean" isArg false)
        (§ field #_"PathNode" clearPathRoot nil)
        (§ field #_"boolean" canBeCleared (ß !RT'booleanCast(getCompilerOption(disableLocalsClearingKey))))
        (§ field #_"boolean" recurMistmatch false)
        (§ field #_"boolean" used false)

        (§ field #_"Boolean" hjc nil)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"LocalBinding" LocalBinding [#_"int" ___num, #_"Symbol" ___sym, #_"Symbol" ___tag, #_"Expr" ___init, #_"boolean" ___isArg, #_"PathNode" ___clearPathRoot]
        (let [this (ß super())]
            (when (ß maybePrimitiveType(___init) != nil && ___tag != nil)
                (throw (UnsupportedOperationException. "Can't type hint a local with a primitive initializer"))
            )
            (§ ass (ß this.idx) ___num)
            (§ ass (ß this.sym) ___sym)
            (§ ass (ß this.tag) ___tag)
            (§ ass (ß this.init) ___init)
            (§ ass (ß this.isArg) ___isArg)
            (§ ass (ß this.clearPathRoot) ___clearPathRoot)
            (§ ass name (ß munge(___sym.name)))
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"LocalBinding" this]
        (when (nil? hjc)
            (if (ß (init != nil) && init.hasJavaClass() && Util'isPrimitive(init.getJavaClass()) && !(init instanceof MaybePrimitiveExpr))
                (do
                    (§ ass hjc false)
                )
                (do
                    (§ ass hjc (ß (tag != nil || (init != nil && init.hasJavaClass()))))
                )
            )
        )
        hjc
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"LocalBinding" this]
        (when (nil? jc)
            (§ ass jc (ß (tag != nil) ? HostExpr'tagToClass(tag) :or init.getJavaClass()))
        )
        jc
    )

    #_method
    (§ defn #_"Class" getPrimitiveType [#_"LocalBinding" this]
        (ß maybePrimitiveType(init))
    )
)

(class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
    (§ init
        (§ field #_"LocalBinding" b nil)
        (§ field #_"Symbol" tag nil)

        (§ field #_"PathNode" clearPath nil)
        (§ field #_"PathNode" clearRoot nil)
        (§ field #_"boolean" shouldClear false)

        (§ field #_"Class" jc nil)
    )

    (§ constructor #_"LocalBindingExpr" LocalBindingExpr [#_"LocalBinding" ___b, #_"Symbol" ___tag]
        (let [this (ß super())]
            (when (ß ___b.getPrimitiveType() != nil && ___tag != nil)
                (throw (UnsupportedOperationException. "Can't type hint a primitive local"))
            )
            (§ ass (ß this.b) ___b)
            (§ ass (ß this.tag) ___tag)

            (§ ass (ß this.clearPath) (ß (PathNode)CLEAR_PATH.get()))
            (§ ass (ß this.clearRoot) (ß (PathNode)CLEAR_ROOT.get()))
            (let [#_"IPersistentCollection" ___sites (ß (IPersistentCollection) RT'get(CLEAR_SITES.get(), ___b))]
                (§ ass (ß ___b.used) true)

                (when (ß ___b.idx > 0)
                    (when (some? ___sites)
                        (loop-when-recur [(§ var #_"ISeq" ___s (ß ___sites.seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                            (let [#_"LocalBindingExpr" ___o (ß (LocalBindingExpr) ___s.first())]
                                (let [#_"PathNode" ___common (ß commonPath(clearPath, ___o.clearPath))]
                                    (when (ß ___common != nil && ___common.type == :PathType'PATH)
                                        (§ ass (ß ___o.shouldClear) false)
                                    )
                                )
                            )
                        )
                    )

                    (when (ß clearRoot == ___b.clearPathRoot)
                        (§ ass (ß this.shouldClear) true)
                        (§ ass ___sites (ß RT'conj(___sites, this)))
                        (ß CLEAR_SITES.set(RT'assoc(CLEAR_SITES.get(), ___b, ___sites)))
                    )
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"LocalBindingExpr" this]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"LocalBindingExpr" this]
        (ß (b.getPrimitiveType() != nil))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitUnboxedLocal(___gen, b))
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (ß ___objx.emitLocal(___gen, b, shouldClear))
        )
        nil
    )

    #_method
    (§ defn #_"Object" evalAssign [#_"LocalBindingExpr" this, #_"Expr" ___val]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"void" emitAssign [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (ß ___objx.emitAssignLocal(___gen, b, ___val))
        (when (ß ___context != :Context'STATEMENT)
            (ß ___objx.emitLocal(___gen, b, false))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"LocalBindingExpr" this]
        (ß (tag != nil || b.hasJavaClass()))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"LocalBindingExpr" this]
        (when (nil? jc)
            (if (some? tag)
                (do
                    (§ ass jc (ß HostExpr'tagToClass(tag)))
                )
                (do
                    (§ ass jc (ß b.getJavaClass()))
                )
            )
        )
        jc
    )
)

#_stateless
(class-ns BodyParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"BodyParser" this, #_"Context" ___context, #_"Object" ___frms]
        (let [#_"ISeq" ___forms (ß (ISeq) ___frms)]
            (when (ß Util'equals(RT'first(___forms), DO))
                (§ ass ___forms (ß RT'next(___forms)))
            )
            (let [#_"PersistentVector" ___exprs (ß PersistentVector'EMPTY)]
                (loop-when-recur [(ß )] (some? ___forms) [(§ ass ___forms (ß ___forms.next()))]
                    (let [#_"Expr" ___e (ß (___context != :Context'EVAL && (___context == :Context'STATEMENT || ___forms.next() != nil)) ? analyze(:Context'STATEMENT, ___forms.first()) :or analyze(___context, ___forms.first()))]
                        (§ ass ___exprs (ß ___exprs.cons(___e)))
                    )
                )
                (when (ß ___exprs.count() == 0)
                    (§ ass ___exprs (ß ___exprs.cons(NIL_EXPR)))
                )
                (BodyExpr. ___exprs)
            )
        )
    )
)

(class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ init
        (§ field #_"PersistentVector" exprs nil)
    )

    (§ constructor #_"BodyExpr" BodyExpr [#_"PersistentVector" ___exprs]
        (let [this (ß super())]
            (§ ass (ß this.exprs) ___exprs)
            this
        )
    )

    #_method
    (§ defn #_"PersistentVector" exprs [#_"BodyExpr" this]
        exprs
    )

    #_method
    (§ defn #_"Object" eval [#_"BodyExpr" this]
        (let [#_"Object" ___ret nil]
            (doseq [#_"Object" ___o exprs]
                (let [#_"Expr" ___e (ß (Expr) ___o)]
                    (§ ass ___ret (ß ___e.eval()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"BodyExpr" this]
        (ß (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive()))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"BodyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < exprs.count() - 1) [(§ ass ___i (ß ___i + 1))]
            (let [#_"Expr" ___e (ß (Expr) exprs.nth(___i))]
                (ß ___e.emit(:Context'STATEMENT, ___objx, ___gen))
            )
        )
        (let [#_"MaybePrimitiveExpr" ___last (ß (MaybePrimitiveExpr) exprs.nth(exprs.count() - 1))]
            (ß ___last.emitUnboxed(___context, ___objx, ___gen))
            nil
        )
    )

    #_method
    (§ defn #_"void" emit [#_"BodyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < exprs.count() - 1) [(§ ass ___i (ß ___i + 1))]
            (let [#_"Expr" ___e (ß (Expr) exprs.nth(___i))]
                (ß ___e.emit(:Context'STATEMENT, ___objx, ___gen))
            )
        )
        (let [#_"Expr" ___last (ß (Expr) exprs.nth(exprs.count() - 1))]
            (ß ___last.emit(___context, ___objx, ___gen))
            nil
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"BodyExpr" this]
        (ß lastExpr().hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"BodyExpr" this]
        (ß lastExpr().getJavaClass())
    )

    #_method
    (§ defn- #_"Expr" lastExpr [#_"BodyExpr" this]
        (ß (Expr) exprs.nth(exprs.count() - 1))
    )
)

(class-ns BindingInit
    (§ init
        (§ field #_"LocalBinding" binding nil)
        (§ field #_"Expr" init nil)
    )

    (§ constructor #_"BindingInit" BindingInit [#_"LocalBinding" ___binding, #_"Expr" ___init]
        (let [this (ß super())]
            (§ ass (ß this.binding) ___binding)
            (§ ass (ß this.init) ___init)
            this
        )
    )

    #_method
    (§ defn #_"LocalBinding" binding [#_"BindingInit" this]
        binding
    )

    #_method
    (§ defn #_"Expr" init [#_"BindingInit" this]
        init
    )
)

#_stateless
(class-ns LetFnParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"LetFnParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (letfns* [var (fn [args] body) ...] body...)
            (when (ß !(RT'second(___form) instanceof IPersistentVector))
                (throw (ß new IllegalArgumentException("Bad binding form, expected vector")))
            )

            (let [#_"IPersistentVector" ___bindings (ß (IPersistentVector) RT'second(___form))]
                (when (ß (___bindings.count() % 2) != 0)
                    (throw (ß new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")))
                )

                (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                    (when (ß ___context == :Context'EVAL)
                        (§ return (ß analyze(___context, RT'list(RT'list(FNONCE, PersistentVector'EMPTY, ___form)))))
                    )

                    (let [#_"IPersistentMap" ___dynamicBindings (ß RT'map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))]
                        (try
                            (ß Var'pushThreadBindings(___dynamicBindings))

                            ;; pre-seed env (like Lisp labels)
                            (let [#_"PersistentVector" ___lbs (ß PersistentVector'EMPTY)]
                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___bindings.count()) [(§ ass ___i (ß ___i + 2))]
                                    (when (ß !(___bindings.nth(___i) instanceof Symbol))
                                        (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + ___bindings.nth(___i))))
                                    )
                                    (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                        (when (ß ___sym.getNamespace() != nil)
                                            (throw (ß Util'runtimeException("Can't let qualified name: " + ___sym)))
                                        )
                                        (let [#_"LocalBinding" ___lb (ß registerLocal(___sym, tagOf(___sym), nil, false))]
                                            (§ ass (ß ___lb.canBeCleared) false)
                                            (§ ass ___lbs (ß ___lbs.cons(___lb)))
                                        )
                                    )
                                )
                                (let [#_"PersistentVector" ___bindingInits (ß PersistentVector'EMPTY)]
                                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___bindings.count()) [(§ ass ___i (ß ___i + 2))]
                                        (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                            (let [#_"Expr" ___init (ß analyze(:Context'EXPRESSION, ___bindings.nth(___i + 1), ___sym.name))]
                                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.nth(___i / 2))]
                                                    (§ ass (ß ___lb.init) ___init)
                                                    (let [#_"BindingInit" ___bi (ß new BindingInit(___lb, ___init))]
                                                        (§ ass ___bindingInits (ß ___bindingInits.cons(___bi)))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (ß new LetFnExpr(___bindingInits, (new BodyParser()).parse(___context, ___body)))
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetFnExpr (§ implements Expr)
    (§ init
        (§ field #_"PersistentVector" bindingInits nil)
        (§ field #_"Expr" body nil)
    )

    (§ constructor #_"LetFnExpr" LetFnExpr [#_"PersistentVector" ___bindingInits, #_"Expr" ___body]
        (let [this (ß super())]
            (§ ass (ß this.bindingInits) ___bindingInits)
            (§ ass (ß this.body) ___body)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"LetFnExpr" this]
        (throw (UnsupportedOperationException. "Can't eval letfns"))
    )

    #_method
    (§ defn #_"void" emit [#_"LetFnExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < bindingInits.count()) [(§ ass ___i (ß ___i + 1))]
            (let [#_"BindingInit" ___bi (ß (BindingInit) bindingInits.nth(___i))]
                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___bi.binding.idx))
            )
        )

        (let [#_"IPersistentSet" ___lbset (ß PersistentHashSet'EMPTY)]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < bindingInits.count()) [(§ ass ___i (ß ___i + 1))]
                (let [#_"BindingInit" ___bi (ß (BindingInit) bindingInits.nth(___i))]
                    (§ ass ___lbset (ß (IPersistentSet) ___lbset.cons(___bi.binding)))
                    (ß ___bi.init.emit(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___bi.binding.idx))
                )
            )

            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < bindingInits.count()) [(§ ass ___i (ß ___i + 1))]
                (let [#_"BindingInit" ___bi (ß (BindingInit) bindingInits.nth(___i))]
                    (let [#_"ObjExpr" ___fe (ß (ObjExpr) ___bi.init)]
                        (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ILOAD), ___bi.binding.idx))
                        (ß ___fe.emitLetFnInits(___gen, ___objx, ___lbset))
                    )
                )
            )

            (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                (ß body.emit(___context, ___objx, ___gen))

                (let [#_"Label" ___end (ß ___gen.mark())]
                    (loop-when-recur [(§ var #_"ISeq" ___bis (ß bindingInits.seq()))] (some? ___bis) [(§ ass ___bis (ß ___bis.next()))]
                        (let [#_"BindingInit" ___bi (ß (BindingInit) ___bis.first())]
                            (let [#_"String" ___lname (ß ___bi.binding.name)]
                                (when (ß ___lname.endsWith("__auto__"))
                                    (§ ass ___lname (ß ___lname + RT'nextID()))
                                )
                                (let [#_"Class" ___primc (ß maybePrimitiveType(___bi.init))]
                                    (if (some? ___primc)
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, Type/getDescriptor(___primc), nil, ___loopLabel, ___end, ___bi.binding.idx))
                                        )
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, "Ljava/lang/Object;", nil, ___loopLabel, ___end, ___bi.binding.idx))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"LetFnExpr" this]
        (ß body.hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"LetFnExpr" this]
        (ß body.getJavaClass())
    )
)

#_stateless
(class-ns LetParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"LetParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (let [var val var2 val2 ...] body...)
            (let [#_"boolean" ___isLoop (ß RT'first(___form).equals(LOOP))]
                (when (ß !(RT'second(___form) instanceof IPersistentVector))
                    (throw (ß new IllegalArgumentException("Bad binding form, expected vector")))
                )

                (let [#_"IPersistentVector" ___bindings (ß (IPersistentVector) RT'second(___form))]
                    (when (ß (___bindings.count() % 2) != 0)
                        (throw (ß new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")))
                    )

                    (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                        (when (ß ___context == :Context'EVAL || (___context == :Context'EXPRESSION && ___isLoop))
                            (§ return (ß analyze(___context, RT'list(RT'list(FNONCE, PersistentVector'EMPTY, ___form)))))
                        )

                        (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                            (let [#_"IPersistentMap" ___backupMethodLocals (ß ___method.locals)]
                                (let [#_"IPersistentMap" ___backupMethodIndexLocals (ß ___method.indexlocals)]
                                    (let [#_"IPersistentVector" ___recurMismatches (ß PersistentVector'EMPTY)]
                                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___bindings.count() / 2) [(§ ass ___i (ß ___i + 1))]
                                            (§ ass ___recurMismatches (ß ___recurMismatches.cons(RT'F)))
                                        )

                                        ;; may repeat once for each binding with a mismatch, return breaks
                                        (while true
                                            (let [#_"IPersistentMap" ___dynamicBindings (ß RT'map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref()))]
                                                (§ ass (ß ___method.locals) ___backupMethodLocals)
                                                (§ ass (ß ___method.indexlocals) ___backupMethodIndexLocals)

                                                (let [#_"PathNode" ___looproot (ß new PathNode(:PathType'PATH, (PathNode) CLEAR_PATH.get()))]
                                                    (let [#_"PathNode" ___clearroot (ß new PathNode(:PathType'PATH, ___looproot))]
                                                        (let [#_"PathNode" ___clearpath (ß new PathNode(:PathType'PATH, ___looproot))]
                                                            (when ___isLoop
                                                                (§ ass ___dynamicBindings (ß ___dynamicBindings.assoc(LOOP_LOCALS, nil)))
                                                            )

                                                            (try
                                                                (ß Var'pushThreadBindings(___dynamicBindings))

                                                                (let [#_"PersistentVector" ___bindingInits (ß PersistentVector'EMPTY)]
                                                                    (let [#_"PersistentVector" ___loopLocals (ß PersistentVector'EMPTY)]
                                                                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___bindings.count()) [(§ ass ___i (ß ___i + 2))]
                                                                            (when (ß !(___bindings.nth(___i) instanceof Symbol))
                                                                                (throw (ß new IllegalArgumentException("Bad binding form, expected symbol, got: " + ___bindings.nth(___i))))
                                                                            )
                                                                            (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                                                                (when (ß ___sym.getNamespace() != nil)
                                                                                    (throw (ß Util'runtimeException("Can't let qualified name: " + ___sym)))
                                                                                )
                                                                                (let [#_"Expr" ___init (ß analyze(:Context'EXPRESSION, ___bindings.nth(___i + 1), ___sym.name))]
                                                                                    (when ___isLoop
                                                                                        (cond (ß ___recurMismatches != nil && RT'booleanCast(___recurMismatches.nth(___i / 2)))
                                                                                            (do
                                                                                                (§ ass ___init (ß new StaticMethodExpr("", 0, 0, nil, (§ class RT), "box", RT'vector(___init), false)))
                                                                                                (when (ß RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                                                                                                    (ß RT'errPrintWriter().println("Auto-boxing loop arg: " + ___sym))
                                                                                                )
                                                                                            )
                                                                                            (ß maybePrimitiveType(___init) == (§ class int))
                                                                                            (do
                                                                                                (§ ass ___init (ß new StaticMethodExpr("", 0, 0, nil, (§ class RT), "longCast", RT'vector(___init), false)))
                                                                                            )
                                                                                            (ß maybePrimitiveType(___init) == (§ class float))
                                                                                            (do
                                                                                                (§ ass ___init (ß new StaticMethodExpr("", 0, 0, nil, (§ class RT), "doubleCast", RT'vector(___init), false)))
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                    ;; sequential enhancement of env (like Lisp let*)
                                                                                    (try
                                                                                        (when ___isLoop
                                                                                            (ß Var'pushThreadBindings(RT'map(CLEAR_PATH, ___clearpath, CLEAR_ROOT, ___clearroot, NO_RECUR, nil)))
                                                                                        )
                                                                                        (let [#_"LocalBinding" ___lb (ß registerLocal(___sym, tagOf(___sym), ___init, false))]
                                                                                            (let [#_"BindingInit" ___bi (ß new BindingInit(___lb, ___init))]
                                                                                                (§ ass ___bindingInits (ß ___bindingInits.cons(___bi)))
                                                                                                (when ___isLoop
                                                                                                    (§ ass ___loopLocals (ß ___loopLocals.cons(___lb)))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                        (finally
                                                                                            (when ___isLoop
                                                                                                (ß Var'popThreadBindings())
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (when ___isLoop
                                                                            (ß LOOP_LOCALS.set(___loopLocals))
                                                                        )
                                                                        (§ let [#_"Expr" ___bodyExpr]
                                                                            (let [#_"boolean" ___moreMismatches false]
                                                                                (try
                                                                                    (when ___isLoop
                                                                                        (let [#_"Object" ___methodReturnContext (ß (___context == :Context'RETURN) ? METHOD_RETURN_CONTEXT.deref() :or nil)]
                                                                                            (ß Var'pushThreadBindings(RT'map(
                                                                                                (§ map
                                                                                                    CLEAR_PATH            ___clearpath
                                                                                                    CLEAR_ROOT            ___clearroot
                                                                                                    NO_RECUR              nil
                                                                                                    METHOD_RETURN_CONTEXT ___methodReturnContext
                                                                                                )
                                                                                            )))
                                                                                        )
                                                                                    )
                                                                                    (§ ass ___bodyExpr (ß (new BodyParser()).parse(___isLoop ? :Context'RETURN :or ___context, ___body)))
                                                                                    (finally
                                                                                        (when ___isLoop
                                                                                            (ß Var'popThreadBindings())
                                                                                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___loopLocals.count()) [(§ ass ___i (ß ___i + 1))]
                                                                                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___loopLocals.nth(___i))]
                                                                                                    (when (ß ___lb.recurMistmatch)
                                                                                                        (§ ass ___recurMismatches (ß (IPersistentVector)___recurMismatches.assoc(___i, RT'T)))
                                                                                                        (§ ass ___moreMismatches true)
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                                (when (ß !___moreMismatches)
                                                                                    (§ return (ß new LetExpr(___bindingInits, ___bodyExpr, ___isLoop)))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                (finally
                                                                    (ß Var'popThreadBindings())
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ init
        (§ field #_"PersistentVector" bindingInits nil)
        (§ field #_"Expr" body nil)
        (§ field #_"boolean" isLoop false)
    )

    (§ constructor #_"LetExpr" LetExpr [#_"PersistentVector" ___bindingInits, #_"Expr" ___body, #_"boolean" ___isLoop]
        (let [this (ß super())]
            (§ ass (ß this.bindingInits) ___bindingInits)
            (§ ass (ß this.body) ___body)
            (§ ass (ß this.isLoop) ___isLoop)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"LetExpr" this]
        (throw (UnsupportedOperationException. "Can't eval let/loop"))
    )

    #_method
    (§ defn #_"void" emit [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, false))
        nil
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, true))
        nil
    )

    #_method
    (§ defn #_"void" doEmit [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"HashMap<BindingInit, Label>" ___bindingLabels (HashMap.)]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < bindingInits.count()) [(§ ass ___i (ß ___i + 1))]
                (let [#_"BindingInit" ___bi (ß (BindingInit) bindingInits.nth(___i))]
                    (let [#_"Class" ___primc (ß maybePrimitiveType(___bi.init))]
                        (if (some? ___primc)
                            (do
                                (ß ((MaybePrimitiveExpr) ___bi.init).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ISTORE), ___bi.binding.idx))
                            )
                            (do
                                (ß ___bi.init.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (if (ß !___bi.binding.used && ___bi.binding.canBeCleared)
                                    (do
                                        (ß ___gen.pop())
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___bi.binding.idx))
                                    )
                                )
                            )
                        )
                        (ß ___bindingLabels.put(___bi, ___gen.mark()))
                    )
                )
            )
            (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                (if isLoop
                    (do
                        (try
                            (ß Var'pushThreadBindings(RT'map(LOOP_LABEL, ___loopLabel)))
                            (if ___emitUnboxed
                                (do
                                    (ß ((MaybePrimitiveExpr)body).emitUnboxed(___context, ___objx, ___gen))
                                )
                                (do
                                    (ß body.emit(___context, ___objx, ___gen))
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                    )
                    (do
                        (if ___emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)body).emitUnboxed(___context, ___objx, ___gen))
                            )
                            (do
                                (ß body.emit(___context, ___objx, ___gen))
                            )
                        )
                    )
                )
                (let [#_"Label" ___end (ß ___gen.mark())]
                    (loop-when-recur [(§ var #_"ISeq" ___bis (ß bindingInits.seq()))] (some? ___bis) [(§ ass ___bis (ß ___bis.next()))]
                        (let [#_"BindingInit" ___bi (ß (BindingInit) ___bis.first())]
                            (let [#_"String" ___lname (ß ___bi.binding.name)]
                                (when (ß ___lname.endsWith("__auto__"))
                                    (§ ass ___lname (ß ___lname + RT'nextID()))
                                )
                                (let [#_"Class" ___primc (ß maybePrimitiveType(___bi.init))]
                                    (if (some? ___primc)
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, Type/getDescriptor(___primc), nil, ___bindingLabels.get(___bi), ___end, ___bi.binding.idx))
                                        )
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, "Ljava/lang/Object;", nil, ___bindingLabels.get(___bi), ___end, ___bi.binding.idx))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"LetExpr" this]
        (ß body.hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"LetExpr" this]
        (ß body.getJavaClass())
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"LetExpr" this]
        (ß (body instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)body).canEmitPrimitive()))
    )
)

#_stateless
(class-ns RecurParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"RecurParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"int" ___line (ß lineDeref())]
            (let [#_"int" ___column (ß columnDeref())]
                (let [#_"String" ___source (ß (String) SOURCE.deref())]
                    (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
                        (let [#_"IPersistentVector" ___loopLocals (ß (IPersistentVector) LOOP_LOCALS.deref())]
                            (when (ß ___context != :Context'RETURN || ___loopLocals == nil)
                                (throw (UnsupportedOperationException. "Can only recur from tail position"))
                            )
                            (when (ß NO_RECUR.deref() != nil)
                                (throw (UnsupportedOperationException. "Cannot recur across try"))
                            )
                            (let [#_"PersistentVector" ___args (ß PersistentVector'EMPTY)]
                                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___form.next())))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                    (§ ass ___args (ß ___args.cons(analyze(:Context'EXPRESSION, ___s.first()))))
                                )
                                (when (ß ___args.count() != ___loopLocals.count())
                                    (throw (ß new IllegalArgumentException(String/format("Mismatched argument count to recur, expected: %d args, got: %d", ___loopLocals.count(), ___args.count()))))
                                )
                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___loopLocals.count()) [(§ ass ___i (ß ___i + 1))]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___loopLocals.nth(___i))]
                                        (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                                            (when (some? ___primc)
                                                (let [#_"boolean" ___mismatch false]
                                                    (let [#_"Class" ___pc (ß maybePrimitiveType((Expr) ___args.nth(___i)))]
                                                        (cond (ß ___primc == (§ class long))
                                                            (do
                                                                (when (ß !(___pc == (§ class long) || ___pc == (§ class int) || ___pc == (§ class short) || ___pc == (§ class char) || ___pc == (§ class byte)))
                                                                    (§ ass ___mismatch true)
                                                                )
                                                            )
                                                            (ß ___primc == (§ class double))
                                                            (do
                                                                (when (ß !(___pc == (§ class double) || ___pc == (§ class float)))
                                                                    (§ ass ___mismatch true)
                                                                )
                                                            )
                                                        )
                                                        (when ___mismatch
                                                            (§ ass (ß ___lb.recurMistmatch) true)
                                                            (when (ß RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                                                                (ß RT'errPrintWriter().println(___source + ":" + ___line + " recur arg for primitive local: " + ___lb.name + " is not matching primitive, had: " + ((___pc != nil) ? ___pc.getName() :or "Object") + ", needed: " + ___primc.getName()))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (ß new RecurExpr(___loopLocals, ___args, ___line, ___column, ___source))
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ init
        (§ field #_"IPersistentVector" args nil)
        (§ field #_"IPersistentVector" loopLocals nil)

        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
        (§ field #_"String" source nil)
    )

    (§ constructor #_"RecurExpr" RecurExpr [#_"IPersistentVector" ___loopLocals, #_"IPersistentVector" ___args, #_"int" ___line, #_"int" ___column, #_"String" ___source]
        (let [this (ß super())]
            (§ ass (ß this.loopLocals) ___loopLocals)
            (§ ass (ß this.args) ___args)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (§ ass (ß this.source) ___source)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"RecurExpr" this]
        (throw (UnsupportedOperationException. "Can't eval recur"))
    )

    #_method
    (§ defn #_"void" emit [#_"RecurExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___loopLabel (ß (Label) LOOP_LABEL.deref())]
            (when (nil? ___loopLabel)
                (throw (IllegalStateException.))
            )
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < loopLocals.count()) [(§ ass ___i (ß ___i + 1))]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) loopLocals.nth(___i))]
                    (let [#_"Expr" ___arg (ß (Expr) args.nth(___i))]
                        (if (ß ___lb.getPrimitiveType() != nil)
                            (do
                                (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                                    (let [#_"Class" ___pc (ß maybePrimitiveType(___arg))]
                                        (cond (ß ___pc == ___primc)
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                            )
                                            (ß ___primc == (§ class long) && ___pc == (§ class int))
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.visitInsn(I2L))
                                            )
                                            (ß ___primc == (§ class double) && ___pc == (§ class float))
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.visitInsn(F2D))
                                            )
                                            (ß ___primc == (§ class int) && ___pc == (§ class long))
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.invokeStatic(RT_TYPE, Method/getMethod("int intCast(long)")))
                                            )
                                            (ß ___primc == (§ class float) && ___pc == (§ class double))
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.visitInsn(D2F))
                                            )
                                            :else
                                            (do
                                                (throw (ß new IllegalArgumentException("recur arg for primitive local: " + ___lb.name + " is not matching primitive, had: " + (___arg.hasJavaClass() ? ___arg.getJavaClass().getName() :or "Object") + ", needed: " + ___primc.getName())))
                                            )
                                        )
                                    )
                                )
                            )
                            (do
                                (ß ___arg.emit(:Context'EXPRESSION, ___objx, ___gen))
                            )
                        )
                    )
                )
            )

            (loop-when-recur [(§ var #_"int" ___i (ß loopLocals.count() - 1))] (ß ___i >= 0) [(§ ass ___i (ß ___i - 1))]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) loopLocals.nth(___i))]
                    (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                        (if (ß ___lb.isArg)
                            (do
                                (ß ___gen.storeArg(___lb.idx - (___objx.canBeDirect ? 0 :or 1)))
                            )
                            (do
                                (if (some? ___primc)
                                    (do
                                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ISTORE), ___lb.idx))
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___lb.idx))
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (ß ___gen.goTo(___loopLabel))
            nil
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"RecurExpr" this]
        RECUR_CLASS
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"RecurExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß emit(___context, ___objx, ___gen))
        nil
    )
)

(class-ns CompilerException (§ extends RuntimeException)
    (§ init
        (§ field #_"String" source nil)
        (§ field #_"int" line 0)
    )

    (§ constructor #_"CompilerException" CompilerException [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (ß super(errorMsg(___source, ___line, ___column, ___cause.toString()), ___cause))]
            (§ ass (ß this.source) ___source)
            (§ ass (ß this.line) ___line)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"CompilerException" this]
        (ß getMessage())
    )
)

#_stateless
(class-ns DeftypeParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"DeftypeParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___rform (ß (ISeq) ___frm)]
            ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
            (§ ass ___rform (ß RT'next(___rform)))
            (let [#_"String" ___tagname (ß ((Symbol) ___rform.first()).getName())]
                (§ ass ___rform (ß ___rform.next()))
                (let [#_"Symbol" ___classname (ß (Symbol) ___rform.first())]
                    (§ ass ___rform (ß ___rform.next()))
                    (let [#_"IPersistentVector" ___fields (ß (IPersistentVector) ___rform.first())]
                        (§ ass ___rform (ß ___rform.next()))
                        (let [#_"IPersistentMap" ___opts (ß PersistentHashMap'EMPTY)]
                            (while (ß ___rform != nil && ___rform.first() instanceof Keyword)
                                (§ ass ___opts (ß ___opts.assoc(___rform.first(), RT'second(___rform))))
                                (§ ass ___rform (ß ___rform.next().next()))
                            )

                            (let [#_"ObjExpr" ___ret (ß build((IPersistentVector)RT'get(___opts, implementsKey, PersistentVector'EMPTY), ___fields, nil, ___tagname, ___classname, (Symbol) RT'get(___opts, RT'TAG_KEY), ___rform, ___frm, ___opts))]
                                ret
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns ReifyParser (§ implements IParser)
    #_method
    (§ defn #_"Expr" parse [#_"ReifyParser" this, #_"Context" ___context, #_"Object" ___frm]
        ;; (reify this-name? [interfaces] (method-name [args] body)*)
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (let [#_"ObjMethod" ___enclosingMethod (ß (ObjMethod) METHOD.deref())]
                (let [#_"String" ___basename (ß (___enclosingMethod != nil) ? (trimGenID(___enclosingMethod.objx.name) + "$") :or (munge(currentNS().name.name) + "$"))]
                    (let [#_"String" ___simpleName (ß "reify__" + RT'nextID())]
                        (let [#_"String" ___classname (ß ___basename + ___simpleName)]
                            (let [#_"ISeq" ___rform (ß RT'next(___form))]
                                (let [#_"IPersistentVector" ___interfaces (ß ((IPersistentVector) RT'first(___rform)).cons(Symbol'intern("cloiure.lang.IObj")))]
                                    (§ ass ___rform (ß RT'next(___rform)))

                                    (let [#_"ObjExpr" ___ret (ß build(___interfaces, nil, nil, ___classname, Symbol'intern(___classname), nil, ___rform, ___frm, nil))]
                                        (if (ß ___frm instanceof IObj && ((IObj) ___frm).meta() != nil)
                                            (do
                                                (ß new MetaExpr(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___frm).meta())))
                                            )
                                            (do
                                                ___ret
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewInstanceExpr (§ extends ObjExpr)
    (§ init
        (§ field #_"IPersistentCollection" methods nil)

        (§ field #_"Map<IPersistentVector, java.lang.reflect.Method>" mmap nil)
        (§ field #_"Map<IPersistentVector, Set<Class>>" covariants nil)
    )

    (§ constructor #_"NewInstanceExpr" NewInstanceExpr [#_"Object" ___tag]
        (let [this (ß super(___tag))]
            this
        )
    )

    (§ defn #_"ObjExpr" NewInstanceExpr'build [#_"IPersistentVector" ___interfaceSyms, #_"IPersistentVector" ___fieldSyms, #_"Symbol" ___thisSym, #_"String" ___tagName, #_"Symbol" ___className, #_"Symbol" ___typeTag, #_"ISeq" ___methodForms, #_"Object" ___frm, #_"IPersistentMap" ___opts]
        (let [#_"NewInstanceExpr" ___ret (NewInstanceExpr. nil)]
            (§ ass (ß ___ret.src) ___frm)
            (§ ass (ß ___ret.name) (ß ___className.toString()))
            (§ ass (ß ___ret.classMeta) (ß RT'meta(___className)))
            (§ ass (ß ___ret.internalName) (ß ___ret.name.replace(\., \/)))
            (§ ass (ß ___ret.objtype) (ß Type/getObjectType(___ret.internalName)))
            (§ ass (ß ___ret.opts) ___opts)

            (when (some? ___thisSym)
                (§ ass (ß ___ret.thisName) (ß ___thisSym.name))
            )

            (when (some? ___fieldSyms)
                (let [#_"IPersistentMap" ___fmap (ß PersistentHashMap'EMPTY)]
                    (let [#_"Object[]" ___closesvec (ß new Object[2 * ___fieldSyms.count()])]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___fieldSyms.count()) [(§ ass ___i (ß ___i + 1))]
                            (let [#_"Symbol" ___sym (ß (Symbol) ___fieldSyms.nth(___i))]
                                (let [#_"LocalBinding" ___lb (ß new LocalBinding(-1, ___sym, nil, new MethodParamExpr(tagClass(tagOf(___sym))), false, nil))]
                                    (§ ass ___fmap (ß ___fmap.assoc(___sym, ___lb)))
                                    (§ ass (ß ___closesvec[___i * 2]) ___lb)
                                    (§ ass (ß ___closesvec[___i * 2 + 1]) ___lb)
                                )
                            )
                        )

                        ;; todo - inject __meta et al into closes - when?
                        ;; use array map to preserve ctor order
                        (§ ass (ß ___ret.closes) (PersistentArrayMap. ___closesvec))
                        (§ ass (ß ___ret.fields) ___fmap)
                        (loop-when-recur [(§ var #_"int" ___i (ß ___fieldSyms.count() - 1))] (ß ___i >= 0 && (((Symbol)___fieldSyms.nth(___i)).name.equals("__meta") || ((Symbol)___fieldSyms.nth(___i)).name.equals("__extmap") || ((Symbol)___fieldSyms.nth(___i)).name.equals("__hash") || ((Symbol)___fieldSyms.nth(___i)).name.equals("__hasheq"))) [(§ ass ___i (ß ___i - 1))]
                            (§ ass (ß ___ret.altCtorDrops) (ß ___ret.altCtorDrops + 1))
                        )
                    )
                )
            )

            (let [#_"PersistentVector" ___interfaces (ß PersistentVector'EMPTY)]
                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___interfaceSyms)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (let [#_"Class" ___c (ß (Class) resolve((Symbol) ___s.first()))]
                        (when (ß !___c.isInterface())
                            (throw (ß new IllegalArgumentException("only interfaces are supported, had: " + ___c.getName())))
                        )
                        (§ ass ___interfaces (ß ___interfaces.cons(___c)))
                    )
                )
                (let [#_"Class" ___superClass (§ class Object)]
                    (let [#_"Map[]" ___mc (ß NewInstanceExpr'gatherMethods(___superClass, RT'seq(___interfaces)))]
                        (let [#_"Map" ___overrideables (ß ___mc[0])]
                            (let [#_"Map" ___covariants (ß ___mc[1])]
                                (§ ass (ß ___ret.mmap) ___overrideables)
                                (§ ass (ß ___ret.covariants) ___covariants)

                                (let [#_"String[]" ___inames (ß interfaceNames(___interfaces))]
                                    (let [#_"Class" ___stub (ß compileStub(slashname(___superClass), ___ret, ___inames, ___frm))]
                                        (let [#_"Symbol" ___thistag (ß Symbol'intern(nil, ___stub.getName()))]
                                            (try
                                                (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                    (§ map
                                                        CONSTANTS          (ß PersistentVector'EMPTY)
                                                        CONSTANT_IDS       (ß new IdentityHashMap())
                                                        KEYWORDS           (ß PersistentHashMap'EMPTY)
                                                        VARS               (ß PersistentHashMap'EMPTY)
                                                        KEYWORD_CALLSITES  (ß PersistentVector'EMPTY)
                                                        PROTOCOL_CALLSITES (ß PersistentVector'EMPTY)
                                                        VAR_CALLSITES      (ß emptyVarCallSites())
                                                        NO_RECUR           nil
                                                    )
                                                )))
                                                (when (ß ___ret.isDeftype())
                                                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                        (§ map
                                                            METHOD             nil
                                                            LOCAL_ENV          (ß ___ret.fields)
                                                            COMPILE_STUB_SYM   (ß Symbol'intern(nil, ___tagName))
                                                            COMPILE_STUB_CLASS ___stub
                                                        )
                                                    )))

                                                    (§ ass (ß ___ret.hintedFields) (ß RT'subvec(___fieldSyms, 0, ___fieldSyms.count() - ___ret.altCtorDrops)))
                                                )

                                                ;; now (methodname [args] body)*
                                                (§ ass (ß ___ret.line) (ß lineDeref()))
                                                (§ ass (ß ___ret.column) (ß columnDeref()))
                                                (let [#_"IPersistentCollection" ___methods nil]
                                                    (loop-when-recur [(§ var #_"ISeq" ___s ___methodForms)] (some? ___s) [(§ ass ___s (ß RT'next(___s)))]
                                                        (let [#_"NewInstanceMethod" ___m (ß NewInstanceMethod'parse(___ret, (ISeq) RT'first(___s), ___thistag, ___overrideables))]
                                                            (§ ass ___methods (ß RT'conj(___methods, ___m)))
                                                        )
                                                    )

                                                    (§ ass (ß ___ret.methods) ___methods)
                                                    (§ ass (ß ___ret.keywords) (ß (IPersistentMap) KEYWORDS.deref()))
                                                    (§ ass (ß ___ret.vars) (ß (IPersistentMap) VARS.deref()))
                                                    (§ ass (ß ___ret.constants) (ß (PersistentVector) CONSTANTS.deref()))
                                                    (§ ass (ß ___ret.constantsID) (ß RT'nextID()))
                                                    (§ ass (ß ___ret.keywordCallsites) (ß (IPersistentVector) KEYWORD_CALLSITES.deref()))
                                                    (§ ass (ß ___ret.protocolCallsites) (ß (IPersistentVector) PROTOCOL_CALLSITES.deref()))
                                                    (§ ass (ß ___ret.varCallsites) (ß (IPersistentSet) VAR_CALLSITES.deref()))
                                                )
                                                (finally
                                                    (when (ß ___ret.isDeftype())
                                                        (ß Var'popThreadBindings())
                                                    )
                                                    (ß Var'popThreadBindings())
                                                )
                                            )

                                            (try
                                                (ß ___ret.compile(slashname(___superClass), ___inames, false))
                                                (catch IOException ___e
                                                    (throw (ß Util'sneakyThrow(___e)))
                                                )
                                            )
                                            (ß ___ret.getCompiledClass())
                                            ___ret
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
        ; Current host interop uses reflection, which requires pre-existing classes
        ; Work around this by:
        ; Generate a stub class that has the same interfaces and fields as the class we are generating.
        ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
        ; Unmunge the name (using a magic prefix) on any code gen for classes
        ;;
    (§ defn #_"Class" NewInstanceExpr'compileStub [#_"String" ___superName, #_"NewInstanceExpr" ___ret, #_"String[]" ___interfaceNames, #_"Object" ___frm]
        (let [#_"ClassWriter" ___cw (ClassWriter. (ß ClassWriter/COMPUTE_MAXS))]
            (let [#_"ClassVisitor" ___cv ___cw]
                (ß ___cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, COMPILE_STUB_PREFIX + "/" + ___ret.internalName, nil, ___superName, ___interfaceNames))

                ;; instance fields for closed-overs
                (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'keys(___ret.closes)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                        (let [#_"int" ___access (ß ACC_PUBLIC + (___ret.isVolatile(___lb) ? ACC_VOLATILE :or ___ret.isMutable(___lb) ? 0 :or ACC_FINAL))]
                            (if (ß ___lb.getPrimitiveType() != nil)
                                (do
                                    (ß ___cv.visitField(___access, ___lb.name, Type/getType(___lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                )
                                (do
                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                    (ß ___cv.visitField(___access, ___lb.name, OBJECT_TYPE.getDescriptor(), nil, nil))
                                )
                            )
                        )
                    )
                )

                ;; ctor that takes closed-overs and does nothing
                (let [#_"Method" ___m (ß new Method("<init>", Type/VOID_TYPE, ___ret.ctorTypes()))]
                    (let [#_"GeneratorAdapter" ___ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, ___m, nil, nil, ___cv))]
                        (ß ___ctorgen.visitCode())
                        (ß ___ctorgen.loadThis())
                        (ß ___ctorgen.invokeConstructor(Type/getObjectType(___superName), voidctor))
                        (ß ___ctorgen.returnValue())
                        (ß ___ctorgen.endMethod())

                        (when (ß ___ret.altCtorDrops > 0)
                            (let [#_"Type[]" ___ctorTypes (ß ___ret.ctorTypes())]
                                (let [#_"Type[]" ___altCtorTypes (ß new Type[___ctorTypes.length-ret.altCtorDrops])]
                                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___altCtorTypes.length) [(§ ass ___i (ß ___i + 1))]
                                        (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                    )
                                    (let [#_"Method" ___alt (ß new Method("<init>", Type/VOID_TYPE, ___altCtorTypes))]
                                        (§ ass ___ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, ___alt, nil, nil, ___cv)))
                                        (ß ___ctorgen.visitCode())
                                        (ß ___ctorgen.loadThis())
                                        (ß ___ctorgen.loadArgs())

                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __meta
                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __extmap
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                        (ß ___ctorgen.invokeConstructor(Type/getObjectType(COMPILE_STUB_PREFIX + "/" + ___ret.internalName), new Method("<init>", Type/VOID_TYPE, ___ctorTypes)))

                                        (ß ___ctorgen.returnValue())
                                        (ß ___ctorgen.endMethod())

                                        ;; alt ctor no __hash, __hasheq
                                        (§ ass ___altCtorTypes (ß new Type[___ctorTypes.length-2]))
                                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___altCtorTypes.length) [(§ ass ___i (ß ___i + 1))]
                                            (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                        )

                                        (§ ass ___alt (ß new Method("<init>", Type/VOID_TYPE, ___altCtorTypes)))
                                        (§ ass ___ctorgen (ß new GeneratorAdapter(ACC_PUBLIC, ___alt, nil, nil, ___cv)))
                                        (ß ___ctorgen.visitCode())
                                        (ß ___ctorgen.loadThis())
                                        (ß ___ctorgen.loadArgs())

                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                        (ß ___ctorgen.invokeConstructor(Type/getObjectType(COMPILE_STUB_PREFIX + "/" + ___ret.internalName), new Method("<init>", Type/VOID_TYPE, ___ctorTypes)))

                                        (ß ___ctorgen.returnValue())
                                        (ß ___ctorgen.endMethod())
                                    )
                                )
                            )
                        )
                        ;; end of class
                        (ß ___cv.visitEnd())

                        (let [#_"byte[]" ___bytecode (ß ___cw.toByteArray())]
                            (let [#_"DynamicClassLoader" ___loader (ß (DynamicClassLoader) LOADER.deref())]
                                (ß ___loader.defineClass(COMPILE_STUB_PREFIX + "." + ___ret.name, ___bytecode, ___frm))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"String[]" NewInstanceExpr'interfaceNames [#_"IPersistentVector" ___interfaces]
        (let [#_"int" ___icnt (ß ___interfaces.count())]
            (let [#_"String[]" ___inames (ß (___icnt > 0) ? new String[___icnt] :or nil)]
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___icnt) [(§ ass ___i (ß ___i + 1))]
                    (§ ass (ß ___inames[___i]) (ß slashname((Class) ___interfaces.nth(___i))))
                )
                inames
            )
        )
    )

    (§ defn #_"String" NewInstanceExpr'slashname [#_"Class" ___c]
        (ß ___c.getName().replace(\., \/))
    )

    #_protected
    #_method
    (§ defn #_"void" emitStatics [#_"NewInstanceExpr" this, #_"ClassVisitor" ___cv]
        (when (ß this.isDeftype())
            ;; getBasis()
            (let [#_"Method" ___meth (ß Method/getMethod("cloiure.lang.IPersistentVector getBasis()"))]
                (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, ___meth, nil, nil, ___cv))]
                    (ß emitValue(hintedFields, ___gen))
                    (ß ___gen.returnValue())
                    (ß ___gen.endMethod())

                    (when (ß this.isDeftype() && this.fields.count() > this.hintedFields.count())
                        ;; create(IPersistentMap)
                        (let [#_"String" ___className (ß name.replace(\., \/))]
                            (let [#_"int" ___i 1]
                                (let [#_"int" ___fieldCount (ß hintedFields.count())]
                                    (let [#_"MethodVisitor" ___mv (ß ___cv.visitMethod(ACC_PUBLIC + ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + ___className + ";", nil, nil))]
                                        (ß ___mv.visitCode())

                                        (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(hintedFields)))] (some? ___s) [(§ ass ___s (ß ___s.next()), ___i (ß ___i + 1))]
                                            (let [#_"String" ___bName (ß ((Symbol)___s.first()).name)]
                                                (let [#_"Class" ___k (ß tagClass(tagOf(___s.first())))]
                                                    (ß ___mv.visitVarInsn(ALOAD, 0))
                                                    (ß ___mv.visitLdcInsn(___bName))
                                                    (ß ___mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                    (ß ___mv.visitInsn(ACONST_NULL))
                                                    (ß ___mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"))
                                                    (when (ß ___k.isPrimitive())
                                                        (ß ___mv.visitTypeInsn(CHECKCAST, Type/getType(boxClass(___k)).getInternalName()))
                                                    )
                                                    (ß ___mv.visitVarInsn(ASTORE, ___i))
                                                    (ß ___mv.visitVarInsn(ALOAD, 0))
                                                    (ß ___mv.visitLdcInsn(___bName))
                                                    (ß ___mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                    (ß ___mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;"))
                                                    (ß ___mv.visitVarInsn(ASTORE, 0))
                                                )
                                            )
                                        )

                                        (ß ___mv.visitTypeInsn(Opcodes/NEW, ___className))
                                        (ß ___mv.visitInsn(DUP))

                                        (let [#_"Method" ___ctor (ß new Method("<init>", Type/VOID_TYPE, ctorTypes()))]
                                            (when (ß hintedFields.count() > 0)
                                                (loop-when-recur [(§ ass ___i 1)] (ß ___i <= ___fieldCount) [(§ ass ___i (ß ___i + 1))]
                                                    (ß ___mv.visitVarInsn(ALOAD, ___i))
                                                    (let [#_"Class" ___k (ß tagClass(tagOf(hintedFields.nth(___i - 1))))]
                                                        (when (ß ___k.isPrimitive())
                                                            (let [#_"String" ___b (ß Type/getType(boxClass(___k)).getInternalName())]
                                                                (let [#_"String" ___p (ß Type/getType(___k).getDescriptor())]
                                                                    (let [#_"String" ___n (ß ___k.getName())]
                                                                        (ß ___mv.visitMethodInsn(INVOKEVIRTUAL, ___b, ___n + "Value", "()" + ___p))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )

                                            (ß ___mv.visitInsn(ACONST_NULL)) ;; __meta
                                            (ß ___mv.visitVarInsn(ALOAD, 0)) ;; __extmap
                                            (ß ___mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;"))
                                            (ß ___mv.visitInsn(ICONST_0)) ;; __hash
                                            (ß ___mv.visitInsn(ICONST_0)) ;; __hasheq
                                            (ß ___mv.visitMethodInsn(INVOKESPECIAL, ___className, "<init>", ___ctor.getDescriptor()))
                                            (ß ___mv.visitInsn(ARETURN))
                                            (ß ___mv.visitMaxs(4 + ___fieldCount, 1 + ___fieldCount))
                                            (ß ___mv.visitEnd())
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" emitMethods [#_"NewInstanceExpr" this, #_"ClassVisitor" ___cv]
        (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(methods)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
            (let [#_"ObjMethod" ___method (ß (ObjMethod) ___s.first())]
                (ß ___method.emit(this, ___cv))
            )
        )
        ;; emit bridge methods
        (doseq [#_"Map$Entry<IPersistentVector, Set<Class>>" ___e (ß covariants.entrySet())]
            (let [#_"java.lang.reflect.Method" ___m (ß mmap.get(___e.getKey()))]
                (let [#_"Class[]" ___params (ß ___m.getParameterTypes())]
                    (let [#_"Type[]" ___argTypes (ß new Type[___params.length])]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___params.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___argTypes[___i]) (ß Type/getType(___params[___i])))
                        )

                        (let [#_"Method" ___target (ß new Method(___m.getName(), Type/getType(___m.getReturnType()), ___argTypes))]
                            (doseq [#_"Class" ___retType (ß ___e.getValue())]
                                (let [#_"Method" ___meth (ß new Method(___m.getName(), Type/getType(___retType), ___argTypes))]
                                    ;; todo don't hardwire EXCEPTION_TYPES
                                    (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE, ___meth, nil, EXCEPTION_TYPES, ___cv))]
                                        (ß ___gen.visitCode())
                                        (ß ___gen.loadThis())
                                        (ß ___gen.loadArgs())
                                        (ß ___gen.invokeInterface(Type/getType(___m.getDeclaringClass()), ___target))
                                        (ß ___gen.returnValue())
                                        (ß ___gen.endMethod())
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"IPersistentVector" NewInstanceExpr'msig [#_"java.lang.reflect.Method" ___m]
        (ß RT'vector(___m.getName(), RT'seq(___m.getParameterTypes()), ___m.getReturnType()))
    )

    (§ defn #_"void" NewInstanceExpr'considerMethod [#_"java.lang.reflect.Method" ___m, #_"Map" ___mm]
        (let [#_"IPersistentVector" ___mk (ß msig(___m))]
            (let [#_"int" ___mods (ß ___m.getModifiers())]
                (when (ß !(___mm.containsKey(___mk) || !(Modifier/isPublic(___mods) || Modifier/isProtected(___mods)) || Modifier/isStatic(___mods) || Modifier/isFinal(___mods)))
                    (ß ___mm.put(___mk, ___m))
                )
                nil
            )
        )
    )

    (§ defn #_"void" NewInstanceExpr'gatherMethods [#_"Class" ___c, #_"Map" ___mm]
        (loop-when-recur [(ß )] (some? ___c) [(§ ass ___c (ß ___c.getSuperclass()))]
            (doseq [#_"java.lang.reflect.Method" ___m (ß ___c.getDeclaredMethods())]
                (ß considerMethod(___m, ___mm))
            )
            (doseq [#_"java.lang.reflect.Method" ___m (ß ___c.getMethods())]
                (ß considerMethod(___m, ___mm))
            )
        )
        nil
    )

    (§ defn #_"Map[]" NewInstanceExpr'gatherMethods [#_"Class" ___sc, #_"ISeq" ___interfaces]
        (let [#_"Map" ___allm (HashMap.)]
            (ß NewInstanceExpr'gatherMethods(___sc, ___allm))
            (loop-when-recur [(ß )] (some? ___interfaces) [(§ ass ___interfaces (ß ___interfaces.next()))]
                (ß NewInstanceExpr'gatherMethods((Class) ___interfaces.first(), ___allm))
            )

            (let [#_"Map<IPersistentVector, java.lang.reflect.Method>" ___mm (ß new HashMap<IPersistentVector, java.lang.reflect.Method>())]
                (let [#_"Map<IPersistentVector, Set<Class>>" ___covariants (ß new HashMap<IPersistentVector, Set<Class>>())]
                    (doseq [#_"Object" ___o (ß ___allm.entrySet())]
                        (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                            (let [#_"IPersistentVector" ___mk (ß (IPersistentVector) ___e.getKey())]
                                (§ ass ___mk (ß (IPersistentVector) ___mk.pop()))
                                (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___e.getValue())]
                                    (if (ß ___mm.containsKey(___mk)) ;; covariant return
                                        (do
                                            (let [#_"Set<Class>" ___cvs (ß ___covariants.get(___mk))]
                                                (when (nil? ___cvs)
                                                    (§ ass ___cvs (ß new HashSet<Class>()))
                                                    (ß ___covariants.put(___mk, ___cvs))
                                                )
                                                (let [#_"java.lang.reflect.Method" ___om (ß ___mm.get(___mk))]
                                                    (if (ß ___om.getReturnType().isAssignableFrom(___m.getReturnType()))
                                                        (do
                                                            (ß ___cvs.add(___om.getReturnType()))
                                                            (ß ___mm.put(___mk, ___m))
                                                        )
                                                        (do
                                                            (ß ___cvs.add(___m.getReturnType()))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (ß ___mm.put(___mk, ___m))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (ß new Map[] (§ array ___mm, ___covariants ))
                )
            )
        )
    )
)

(class-ns NewInstanceMethod (§ extends ObjMethod)
    (§ def #_"Symbol" NewInstanceMethod'dummyThis (ß Symbol'intern(nil, "dummy_this_dlskjsdfower")))

    (§ init
        (§ field #_"String" name nil)
        (§ field #_"Type[]" argTypes nil)
        (§ field #_"Type" retType nil)
        (§ field #_"Class" retClass nil)
        (§ field #_"Class[]" exclasses nil)

        (§ field- #_"IPersistentVector" parms nil)
    )

    (§ constructor #_"NewInstanceMethod" NewInstanceMethod [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (let [this (ß super(___objx, ___parent))]
            this
        )
    )

    #_method
    (§ defn #_"int" numParams [#_"NewInstanceMethod" this]
        (ß argLocals.count())
    )

    #_method
    (§ defn #_"String" getMethodName [#_"NewInstanceMethod" this]
        name
    )

    #_method
    (§ defn #_"Type" getReturnType [#_"NewInstanceMethod" this]
        retType
    )

    #_method
    (§ defn #_"Type[]" getArgTypes [#_"NewInstanceMethod" this]
        argTypes
    )

    (§ defn #_"IPersistentVector" NewInstanceMethod'msig [#_"String" ___name, #_"Class[]" ___paramTypes]
        (ß RT'vector(___name, RT'seq(___paramTypes)))
    )

    (§ defn #_"NewInstanceMethod" NewInstanceMethod'parse [#_"ObjExpr" ___objx, #_"ISeq" ___form, #_"Symbol" ___thistag, #_"Map" ___overrideables]
        ;; (methodname [this-name args*] body...)
        ;; this-name might be nil
        (let [#_"NewInstanceMethod" ___method (ß new NewInstanceMethod(___objx, (ObjMethod) METHOD.deref()))]
            (let [#_"Symbol" ___dotname (ß (Symbol)RT'first(___form))]
                (let [#_"Symbol" ___name (ß (Symbol) Symbol'intern(nil, munge(___dotname.name)).withMeta(RT'meta(___dotname)))]
                    (let [#_"IPersistentVector" ___parms (ß (IPersistentVector) RT'second(___form))]
                        (when (ß ___parms.count() == 0)
                            (throw (IllegalArgumentException. (ß "Must supply at least one argument for 'this' in: " + ___dotname)))
                        )
                        (let [#_"Symbol" ___thisName (ß (Symbol) ___parms.nth(0))]
                            (§ ass ___parms (ß RT'subvec(___parms, 1, ___parms.count())))
                            (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                                (try
                                    (§ ass (ß ___method.line) (ß lineDeref()))
                                    (§ ass (ß ___method.column) (ß columnDeref()))
                                    ;; register as the current method and set up a new env frame
                                    (let [#_"PathNode" ___pnode (ß new PathNode(:PathType'PATH, (PathNode) CLEAR_PATH.get()))]
                                        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                            (§ map
                                                METHOD                ___method
                                                LOCAL_ENV             (ß LOCAL_ENV.deref())
                                                LOOP_LOCALS           nil
                                                NEXT_LOCAL_NUM        0
                                                CLEAR_PATH            ___pnode
                                                CLEAR_ROOT            ___pnode
                                                CLEAR_SITES           (ß PersistentHashMap'EMPTY)
                                                METHOD_RETURN_CONTEXT (ß RT'T)
                                            )
                                        )))

                                        ;; register 'this' as local 0
                                        (if (some? ___thisName)
                                            (do
                                                (ß registerLocal((___thisName == nil) ? dummyThis :or ___thisName, ___thistag, nil, false))
                                            )
                                            (do
                                                (ß getAndIncLocalNum())
                                            )
                                        )

                                        (let [#_"PersistentVector" ___argLocals (ß PersistentVector'EMPTY)]
                                            (§ ass (ß ___method.retClass) (ß tagClass(tagOf(___name))))
                                            (§ ass (ß ___method.argTypes) (ß new Type[___parms.count()]))
                                            (let [#_"boolean" ___hinted (ß tagOf(___name) != nil)]
                                                (let [#_"Class[]" ___pclasses (ß new Class[___parms.count()])]
                                                    (let [#_"Symbol[]" ___psyms (ß new Symbol[___parms.count()])]
                                                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___parms.count()) [(§ ass ___i (ß ___i + 1))]
                                                            (when (ß !(___parms.nth(___i) instanceof Symbol))
                                                                (throw (IllegalArgumentException. "params must be Symbols"))
                                                            )
                                                            (let [#_"Symbol" ___p (ß (Symbol) ___parms.nth(___i))]
                                                                (let [#_"Object" ___tag (ß tagOf(___p))]
                                                                    (when (some? ___tag)
                                                                        (§ ass ___hinted true)
                                                                    )
                                                                    (when (ß ___p.getNamespace() != nil)
                                                                        (§ ass ___p (ß Symbol'intern(___p.name)))
                                                                    )
                                                                    (let [#_"Class" ___pclass (ß tagClass(___tag))]
                                                                        (§ ass (ß ___pclasses[___i]) ___pclass)
                                                                        (§ ass (ß ___psyms[___i]) ___p)
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (let [#_"Map" ___matches (ß findMethodsWithNameAndArity(___name.name, ___parms.count(), ___overrideables))]
                                                            (let [#_"Object" ___mk (ß msig(___name.name, ___pclasses))]
                                                                (let [#_"java.lang.reflect.Method" ___m nil]
                                                                    (if (ß ___matches.size() > 0)
                                                                        (do
                                                                            ;; multiple methods
                                                                            (cond (ß ___matches.size() > 1)
                                                                                (do
                                                                                    ;; must be hinted and match one method
                                                                                    (when (ß !___hinted)
                                                                                        (throw (IllegalArgumentException. (ß "Must hint overloaded method: " + ___name.name)))
                                                                                    )
                                                                                    (§ ass ___m (ß (java.lang.reflect.Method) ___matches.get(___mk)))
                                                                                    (when (nil? ___m)
                                                                                        (throw (IllegalArgumentException. (ß "Can't find matching overloaded method: " + ___name.name)))
                                                                                    )
                                                                                    (when (ß ___m.getReturnType() != ___method.retClass)
                                                                                        (throw (ß new IllegalArgumentException("Mismatched return type: " + ___name.name + ", expected: " + ___m.getReturnType().getName() + ", had: " + ___method.retClass.getName())))
                                                                                    )
                                                                                )
                                                                                :else ;; one match
                                                                                (do
                                                                                    ;; if hinted, validate match
                                                                                    (cond ___hinted
                                                                                        (do
                                                                                            (§ ass ___m (ß (java.lang.reflect.Method) ___matches.get(___mk)))
                                                                                            (when (nil? ___m)
                                                                                                (throw (ß new IllegalArgumentException("Can't find matching method: " + ___name.name + ", leave off hints for auto match.")))
                                                                                            )
                                                                                            (when (ß ___m.getReturnType() != ___method.retClass)
                                                                                                (throw (ß new IllegalArgumentException("Mismatched return type: " + ___name.name + ", expected: " + ___m.getReturnType().getName() + ", had: " + ___method.retClass.getName())))
                                                                                            )
                                                                                        )
                                                                                        :else ;; adopt found method sig
                                                                                        (do
                                                                                            (§ ass ___m (ß (java.lang.reflect.Method) ___matches.values().iterator().next()))
                                                                                            (§ ass (ß ___method.retClass) (ß ___m.getReturnType()))
                                                                                            (§ ass ___pclasses (ß ___m.getParameterTypes()))
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (do
                                                                            (throw (IllegalArgumentException. (ß "Can't define method not in interfaces: " + ___name.name)))
                                                                        )
                                                                    )

                                                                    ;; validate unque name+arity among additional methods

                                                                    (§ ass (ß ___method.retType) (ß Type/getType(___method.retClass)))
                                                                    (§ ass (ß ___method.exclasses) (ß ___m.getExceptionTypes()))

                                                                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___parms.count()) [(§ ass ___i (ß ___i + 1))]
                                                                        (let [#_"LocalBinding" ___lb (ß registerLocal(___psyms[___i], nil, new MethodParamExpr(___pclasses[___i]), true))]
                                                                            (§ ass ___argLocals (ß ___argLocals.assocN(___i, ___lb)))
                                                                            (§ ass (ß ___method.argTypes[___i]) (ß Type/getType(___pclasses[___i])))
                                                                        )
                                                                    )
                                                                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___parms.count()) [(§ ass ___i (ß ___i + 1))]
                                                                        (when (ß ___pclasses[___i] == (§ class long) || ___pclasses[___i] == (§ class double))
                                                                            (ß getAndIncLocalNum())
                                                                        )
                                                                    )
                                                                    (ß LOOP_LOCALS.set(___argLocals))
                                                                    (§ ass (ß ___method.name) (ß ___name.name))
                                                                    (§ ass (ß ___method.methodMeta) (ß RT'meta(___name)))
                                                                    (§ ass (ß ___method.parms) ___parms)
                                                                    (§ ass (ß ___method.argLocals) ___argLocals)
                                                                    (§ ass (ß ___method.body) (ß (new BodyParser()).parse(:Context'RETURN, ___body)))
                                                                    ___method
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (finally
                                        (ß Var'popThreadBindings())
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"Map" NewInstanceMethod'findMethodsWithNameAndArity [#_"String" ___name, #_"int" ___arity, #_"Map" ___mm]
        (let [#_"Map" ___ret (HashMap.)]
            (doseq [#_"Object" ___o (ß ___mm.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___e.getValue())]
                        (when (ß ___name.equals(___m.getName()) && ___m.getParameterTypes().length == ___arity)
                            (ß ___ret.put(___e.getKey(), ___e.getValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn- #_"Map" NewInstanceMethod'findMethodsWithName [#_"String" ___name, #_"Map" ___mm]
        (let [#_"Map" ___ret (HashMap.)]
            (doseq [#_"Object" ___o (ß ___mm.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___e.getValue())]
                        (when (ß ___name.equals(___m.getName()))
                            (ß ___ret.put(___e.getKey(), ___e.getValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"void" emit [#_"NewInstanceMethod" this, #_"ObjExpr" ___obj, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (ß new Method(getMethodName(), getReturnType(), getArgTypes()))]
            (let [#_"Type[]" ___extypes nil]
                (when (ß exclasses.length > 0)
                    (§ ass ___extypes (ß new Type[exclasses.length]))
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < exclasses.length) [(§ ass ___i (ß ___i + 1))]
                        (§ ass (ß ___extypes[___i]) (ß Type/getType(exclasses[___i])))
                    )
                )
                (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC, ___m, nil, ___extypes, ___cv))]
                    (ß addAnnotation(___gen, methodMeta))
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < parms.count()) [(§ ass ___i (ß ___i + 1))]
                        (let [#_"IPersistentMap" ___meta (ß RT'meta(parms.nth(___i)))]
                            (ß addParameterAnnotation(___gen, ___meta, ___i))
                        )
                    )
                    (ß ___gen.visitCode())

                    (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                        (ß ___gen.visitLineNumber(line, ___loopLabel))
                        (try
                            (ß Var'pushThreadBindings(RT'map(LOOP_LABEL, ___loopLabel, METHOD, this)))

                            (ß emitBody(objx, ___gen, retClass, body))
                            (let [#_"Label" ___end (ß ___gen.mark())]
                                (ß ___gen.visitLocalVariable("this", ___obj.objtype.getDescriptor(), nil, ___loopLabel, ___end, 0))
                                (loop-when-recur [(§ var #_"ISeq" ___lbs (ß argLocals.seq()))] (some? ___lbs) [(§ ass ___lbs (ß ___lbs.next()))]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                        (ß ___gen.visitLocalVariable(___lb.name, argTypes[___lb.idx-1].getDescriptor(), nil, ___loopLabel, ___end, ___lb.idx))
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )

                        (ß ___gen.returnValue())
                        (ß ___gen.endMethod())
                        nil
                    )
                )
            )
        )
    )
)

(class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ init
        (§ field #_"Class" c nil)
    )

    (§ constructor #_"MethodParamExpr" MethodParamExpr [#_"Class" ___c]
        (let [this (ß super())]
            (§ ass (ß this.c) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MethodParamExpr" this]
        (throw (ß Util'runtimeException("Can't eval")))
    )

    #_method
    (§ defn #_"void" emit [#_"MethodParamExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (throw (ß Util'runtimeException("Can't emit")))
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"MethodParamExpr" this]
        (ß (c != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"MethodParamExpr" this]
        c
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"MethodParamExpr" this]
        (ß Util'isPrimitive(c))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"MethodParamExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (throw (ß Util'runtimeException("Can't emit")))
    )
)

#_stateless
(class-ns CaseParser (§ implements IParser)
    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    ;; prepared by case macro and presumed correct
    ;; case macro binds actual expr in let so expr is always a local,
    ;; no need to worry about multiple evaluation
    #_method
    (§ defn #_"Expr" parse [#_"CaseParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß ___context == :Context'EVAL)
                (§ return (ß analyze(___context, RT'list(RT'list(FNONCE, PersistentVector'EMPTY, ___form)))))
            )
            (let [#_"IPersistentVector" ___args (ß LazilyPersistentVector'create(___form.next()))]
                (let [#_"Object" ___exprForm (ß ___args.nth(0))]
                    (let [#_"int" ___shift (ß ((Number)___args.nth(1)).intValue())]
                        (let [#_"int" ___mask (ß ((Number)___args.nth(2)).intValue())]
                            (let [#_"Object" ___defaultForm (ß ___args.nth(3))]
                                (let [#_"Map" ___caseMap (ß (Map)___args.nth(4))]
                                    (let [#_"Keyword" ___switchType (ß ((Keyword)___args.nth(5)))]
                                        (let [#_"Keyword" ___testType (ß ((Keyword)___args.nth(6)))]
                                            (let [#_"Set" ___skipCheck (ß (RT'count(___args) < 8) ? nil :or (Set)___args.nth(7))]
                                                (let [#_"ISeq" ___keys (ß RT'keys(___caseMap))]
                                                    (let [#_"int" ___low (ß ((Number)RT'first(___keys)).intValue())]
                                                        (let [#_"int" ___high (ß ((Number)RT'nth(___keys, RT'count(___keys) - 1)).intValue())]
                                                            (let [#_"LocalBindingExpr" ___testexpr (ß (LocalBindingExpr) analyze(:Context'EXPRESSION, ___exprForm))]
                                                                (§ ass (ß ___testexpr.shouldClear) false)

                                                                (let [#_"SortedMap<Integer, Expr>" ___tests (TreeMap.)]
                                                                    (let [#_"HashMap<Integer, Expr>" ___thens (HashMap.)]
                                                                        (let [#_"PathNode" ___branch (ß new PathNode(:PathType'BRANCH, (PathNode) CLEAR_PATH.get()))]
                                                                            (doseq [#_"Object" ___o (ß ___caseMap.entrySet())]
                                                                                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                                                                                    (let [#_"Integer" ___minhash (ß ((Number)___e.getKey()).intValue())]
                                                                                        (let [#_"Object" ___pair (ß ___e.getValue())] ;; [test-val then-expr]
                                                                                            (let [#_"Expr" ___testExpr (ß (___testType == intKey) ? NumberExpr'parse(((Number)RT'first(___pair)).intValue()) :or new ConstantExpr(RT'first(___pair)))]
                                                                                                (ß ___tests.put(___minhash, ___testExpr))

                                                                                                (§ let [#_"Expr" ___thenExpr]
                                                                                                    (try
                                                                                                        (ß Var'pushThreadBindings(RT'map(CLEAR_PATH, new PathNode(:PathType'PATH, ___branch))))
                                                                                                        (§ ass ___thenExpr (ß analyze(___context, RT'second(___pair))))
                                                                                                        (finally
                                                                                                            (ß Var'popThreadBindings())
                                                                                                        )
                                                                                                    )
                                                                                                    (ß ___thens.put(___minhash, ___thenExpr))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )

                                                                            (§ let [#_"Expr" ___defaultExpr]
                                                                                (try
                                                                                    (ß Var'pushThreadBindings(RT'map(CLEAR_PATH, new PathNode(:PathType'PATH, ___branch))))
                                                                                    (§ ass ___defaultExpr (ß analyze(___context, ___args.nth(3))))
                                                                                    (finally
                                                                                        (ß Var'popThreadBindings())
                                                                                    )
                                                                                )

                                                                                (let [#_"int" ___line (ß ((Number)LINE.deref()).intValue())]
                                                                                    (let [#_"int" ___column (ß ((Number)COLUMN.deref()).intValue())]
                                                                                        (ß new CaseExpr(___line, ___column, ___testexpr, ___shift, ___mask, ___low, ___high, ___defaultExpr, ___tests, ___thens, ___switchType, ___testType, ___skipCheck))
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
    (§ def #_"Type" CaseExpr'NUMBER_TYPE (ß Type/getType((§ class Number))))
    (§ def #_"Method" CaseExpr'intValueMethod (ß Method/getMethod("int intValue()")))

    (§ def #_"Method" CaseExpr'hashMethod (ß Method/getMethod("int hash(Object)")))
    (§ def #_"Method" CaseExpr'hashCodeMethod (ß Method/getMethod("int hashCode()")))
    (§ def #_"Method" CaseExpr'equivMethod (ß Method/getMethod("boolean equiv(Object, Object)")))
    (§ def #_"Keyword" CaseExpr'compactKey (ß Keyword'intern(nil, "compact")))
    (§ def #_"Keyword" CaseExpr'sparseKey (ß Keyword'intern(nil, "sparse")))
    (§ def #_"Keyword" CaseExpr'hashIdentityKey (ß Keyword'intern(nil, "hash-identity")))
    (§ def #_"Keyword" CaseExpr'hashEquivKey (ß Keyword'intern(nil, "hash-equiv")))
    (§ def #_"Keyword" CaseExpr'intKey (ß Keyword'intern(nil, "int")))

    (§ init
        (§ field #_"LocalBindingExpr" expr nil)
        (§ field #_"int" shift 0)
        (§ field #_"int" mask 0)
        (§ field #_"int" low 0)
        (§ field #_"int" high 0)
        (§ field #_"Expr" defaultExpr nil)
        (§ field #_"SortedMap<Integer, Expr>" tests nil)
        (§ field #_"HashMap<Integer, Expr>" thens nil)
        (§ field #_"Keyword" switchType nil)
        (§ field #_"Keyword" testType nil)
        (§ field #_"Set<Integer>" skipCheck nil)
        (§ field #_"Class" returnType nil)
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    (§ constructor #_"CaseExpr" CaseExpr [#_"int" ___line, #_"int" ___column, #_"LocalBindingExpr" ___expr, #_"int" ___shift, #_"int" ___mask, #_"int" ___low, #_"int" ___high, #_"Expr" ___defaultExpr, #_"SortedMap<Integer, Expr>" ___tests, #_"HashMap<Integer, Expr>" ___thens, #_"Keyword" ___switchType, #_"Keyword" ___testType, #_"Set<Integer>" ___skipCheck]
        (let [this (ß super())]
            (§ ass (ß this.expr) ___expr)
            (§ ass (ß this.shift) ___shift)
            (§ ass (ß this.mask) ___mask)
            (§ ass (ß this.low) ___low)
            (§ ass (ß this.high) ___high)
            (§ ass (ß this.defaultExpr) ___defaultExpr)
            (§ ass (ß this.tests) ___tests)
            (§ ass (ß this.thens) ___thens)
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            (when (ß ___switchType != compactKey && ___switchType != sparseKey)
                (throw (IllegalArgumentException. (ß "Unexpected switch type: " + ___switchType)))
            )
            (§ ass (ß this.switchType) ___switchType)
            (when (ß ___testType != intKey && ___testType != hashEquivKey && ___testType != hashIdentityKey)
                (throw (IllegalArgumentException. (ß "Unexpected test type: " + ___switchType)))
            )
            (§ ass (ß this.testType) ___testType)
            (§ ass (ß this.skipCheck) ___skipCheck)
            (let [#_"Collection<Expr>" ___returns (ß new ArrayList(___thens.values()))]
                (ß ___returns.add(___defaultExpr))
                (§ ass (ß this.returnType) (ß maybeJavaClass(___returns)))
                (when (ß RT'count(___skipCheck) > 0 && RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                    (ß RT'errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", SOURCE_PATH.deref(), ___line, ___column))
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"CaseExpr" this]
        (ß (returnType != nil))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"CaseExpr" this]
        (ß Util'isPrimitive(returnType))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"CaseExpr" this]
        returnType
    )

    #_method
    (§ defn #_"Object" eval [#_"CaseExpr" this]
        (throw (UnsupportedOperationException. "Can't eval case"))
    )

    #_method
    (§ defn #_"void" emit [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, false))
        nil
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, true))
        nil
    )

    #_method
    (§ defn #_"void" doEmit [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"Label" ___defaultLabel (ß ___gen.newLabel())]
            (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
                (let [#_"SortedMap<Integer, Label>" ___labels (TreeMap.)]
                    (doseq [#_"Integer" ___i (ß tests.keySet())]
                        (ß ___labels.put(___i, ___gen.newLabel()))
                    )

                    (ß ___gen.visitLineNumber(line, ___gen.mark()))

                    (let [#_"Class" ___primExprClass (ß maybePrimitiveType(expr))]
                        (let [#_"Type" ___primExprType (ß (___primExprClass == nil) ? nil :or Type/getType(___primExprClass))]
                            (if (ß testType == intKey)
                                (do
                                    (ß emitExprForInts(___objx, ___gen, ___primExprType, ___defaultLabel))
                                )
                                (do
                                    (ß emitExprForHashes(___objx, ___gen))
                                )
                            )

                            (if (ß switchType == sparseKey)
                                (do
                                    (let [#_"Label[]" ___la (ß new Label[___labels.size()])]
                                        (§ ass ___la (ß ___labels.values().toArray(___la)))
                                        (let [#_"int[]" ___ints (ß Numbers'int_array(tests.keySet()))]
                                            (ß ___gen.visitLookupSwitchInsn(___defaultLabel, ___ints, ___la))
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Label[]" ___la (ß new Label[(high - low) + 1])]
                                        (loop-when-recur [(§ var #_"int" ___i low)] (ß ___i <= high) [(§ ass ___i (ß ___i + 1))]
                                            (§ ass (ß ___la[___i - low]) (ß ___labels.containsKey(___i) ? ___labels.get(___i) :or ___defaultLabel))
                                        )
                                        (ß ___gen.visitTableSwitchInsn(low, high, ___defaultLabel, ___la))
                                    )
                                )
                            )

                            (doseq [#_"Integer" ___i (ß ___labels.keySet())]
                                (ß ___gen.mark(___labels.get(___i)))
                                (cond (ß testType == intKey)
                                    (do
                                        (ß emitThenForInts(___objx, ___gen, ___primExprType, tests.get(___i), thens.get(___i), ___defaultLabel, ___emitUnboxed))
                                    )
                                    (ß RT'contains(skipCheck, ___i) == RT'T)
                                    (do
                                        (ß CaseExpr'emitExpr(___objx, ___gen, thens.get(___i), ___emitUnboxed))
                                    )
                                    :else
                                    (do
                                        (ß emitThenForHashes(___objx, ___gen, tests.get(___i), thens.get(___i), ___defaultLabel, ___emitUnboxed))
                                    )
                                )
                                (ß ___gen.goTo(___endLabel))
                            )

                            (ß ___gen.mark(___defaultLabel))
                            (ß CaseExpr'emitExpr(___objx, ___gen, defaultExpr, ___emitUnboxed))
                            (ß ___gen.mark(___endLabel))
                            (when (ß ___context == :Context'STATEMENT)
                                (ß ___gen.pop())
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"boolean" isShiftMasked [#_"CaseExpr" this]
        (ß (mask != 0))
    )

    #_method
    (§ defn- #_"void" emitShiftMask [#_"CaseExpr" this, #_"GeneratorAdapter" ___gen]
        (when (ß isShiftMasked())
            (ß ___gen.push(shift))
            (ß ___gen.visitInsn(ISHR))
            (ß ___gen.push(mask))
            (ß ___gen.visitInsn(IAND))
        )
        nil
    )

    #_method
    (§ defn- #_"void" emitExprForInts [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Type" ___exprType, #_"Label" ___defaultLabel]
        (cond (nil? ___exprType)
            (do
                (when (ß RT'booleanCast(RT'WARN_ON_REFLECTION.deref()))
                    (ß RT'errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", SOURCE_PATH.deref(), line, column))
                )
                (ß expr.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.instanceOf(NUMBER_TYPE))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
                (ß expr.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(NUMBER_TYPE))
                (ß ___gen.invokeVirtual(NUMBER_TYPE, intValueMethod))
                (ß emitShiftMask(___gen))
            )
            (ß ___exprType == Type/LONG_TYPE || ___exprType == Type/INT_TYPE || ___exprType == Type/SHORT_TYPE || ___exprType == Type/BYTE_TYPE)
            (do
                (ß expr.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.cast(___exprType, Type/INT_TYPE))
                (ß emitShiftMask(___gen))
            )
            :else
            (do
                (ß ___gen.goTo(___defaultLabel))
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" emitThenForInts [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Type" ___exprType, #_"Expr" ___test, #_"Expr" ___then, #_"Label" ___defaultLabel, #_"boolean" ___emitUnboxed]
        (cond (nil? ___exprType)
            (do
                (ß expr.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___test.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.invokeStatic(UTIL_TYPE, equivMethod))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
                (ß CaseExpr'emitExpr(___objx, ___gen, ___then, ___emitUnboxed))
            )
            (ß ___exprType == Type/LONG_TYPE)
            (do
                (ß ((NumberExpr)___test).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß expr.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.ifCmp(Type/LONG_TYPE, GeneratorAdapter/NE, ___defaultLabel))
                (ß CaseExpr'emitExpr(___objx, ___gen, ___then, ___emitUnboxed))
            )
            (ß ___exprType == Type/INT_TYPE || ___exprType == Type/SHORT_TYPE || ___exprType == Type/BYTE_TYPE)
            (do
                (when (ß isShiftMasked())
                    (ß ((NumberExpr)___test).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                    (ß expr.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.cast(___exprType, Type/LONG_TYPE))
                    (ß ___gen.ifCmp(Type/LONG_TYPE, GeneratorAdapter/NE, ___defaultLabel))
                )
                ;; else direct match
                (ß CaseExpr'emitExpr(___objx, ___gen, ___then, ___emitUnboxed))
            )
            :else
            (do
                (ß ___gen.goTo(___defaultLabel))
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" emitExprForHashes [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß expr.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.invokeStatic(UTIL_TYPE, hashMethod))
        (ß emitShiftMask(___gen))
        nil
    )

    #_method
    (§ defn- #_"void" emitThenForHashes [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___test, #_"Expr" ___then, #_"Label" ___defaultLabel, #_"boolean" ___emitUnboxed]
        (ß expr.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___test.emit(:Context'EXPRESSION, ___objx, ___gen))
        (if (ß testType == hashIdentityKey)
            (do
                (ß ___gen.visitJumpInsn(IF_ACMPNE, ___defaultLabel))
            )
            (do
                (ß ___gen.invokeStatic(UTIL_TYPE, equivMethod))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
            )
        )
        (ß CaseExpr'emitExpr(___objx, ___gen, ___then, ___emitUnboxed))
        nil
    )

    (§ defn- #_"void" CaseExpr'emitExpr [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___expr, #_"boolean" ___emitUnboxed]
        (if (ß ___emitUnboxed && ___expr instanceof MaybePrimitiveExpr)
            (do
                (ß ((MaybePrimitiveExpr)___expr).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
            )
            (do
                (ß ___expr.emit(:Context'EXPRESSION, ___objx, ___gen))
            )
        )
        nil
    )
)

#_stateless
(class-ns Compiler (§ implements Opcodes)
    (§ def #_"Symbol" Compiler'DEF (ß Symbol'intern("def")))
    (§ def #_"Symbol" Compiler'LOOP (ß Symbol'intern("loop*")))
    (§ def #_"Symbol" Compiler'RECUR (ß Symbol'intern("recur")))
    (§ def #_"Symbol" Compiler'IF (ß Symbol'intern("if")))
    (§ def #_"Symbol" Compiler'LET (ß Symbol'intern("let*")))
    (§ def #_"Symbol" Compiler'LETFN (ß Symbol'intern("letfn*")))
    (§ def #_"Symbol" Compiler'DO (ß Symbol'intern("do")))
    (§ def #_"Symbol" Compiler'FN (ß Symbol'intern("fn*")))
    (§ def #_"Symbol" Compiler'FNONCE (ß (Symbol) Symbol'intern("fn*").withMeta(RT'map(Keyword'intern(nil, "once"), RT'T))))
    (§ def #_"Symbol" Compiler'QUOTE (ß Symbol'intern("quote")))
    (§ def #_"Symbol" Compiler'THE_VAR (ß Symbol'intern("var")))
    (§ def #_"Symbol" Compiler'DOT (ß Symbol'intern(".")))
    (§ def #_"Symbol" Compiler'ASSIGN (ß Symbol'intern("set!")))
    (§ def #_"Symbol" Compiler'TRY (ß Symbol'intern("try")))
    (§ def #_"Symbol" Compiler'CATCH (ß Symbol'intern("catch")))
    (§ def #_"Symbol" Compiler'FINALLY (ß Symbol'intern("finally")))
    (§ def #_"Symbol" Compiler'THROW (ß Symbol'intern("throw")))
    (§ def #_"Symbol" Compiler'MONITOR_ENTER (ß Symbol'intern("monitor-enter")))
    (§ def #_"Symbol" Compiler'MONITOR_EXIT (ß Symbol'intern("monitor-exit")))
    (§ def #_"Symbol" Compiler'IMPORT (ß Symbol'intern("cloiure.core", "import*")))
    (§ def #_"Symbol" Compiler'DEFTYPE (ß Symbol'intern("deftype*")))
    (§ def #_"Symbol" Compiler'CASE (ß Symbol'intern("case*")))

    (§ def #_"Symbol" Compiler'CLASS (ß Symbol'intern("Class")))
    (§ def #_"Symbol" Compiler'NEW (ß Symbol'intern("new")))
    (§ def #_"Symbol" Compiler'THIS (ß Symbol'intern("this")))
    (§ def #_"Symbol" Compiler'REIFY (ß Symbol'intern("reify*")))
    (§ def #_"Symbol" Compiler'LIST (ß Symbol'intern("cloiure.core", "list")))
    (§ def #_"Symbol" Compiler'HASHMAP (ß Symbol'intern("cloiure.core", "hash-map")))
    (§ def #_"Symbol" Compiler'VECTOR (ß Symbol'intern("cloiure.core", "vector")))
    (§ def #_"Symbol" Compiler'IDENTITY (ß Symbol'intern("cloiure.core", "identity")))

    (§ def #_"Symbol" Compiler'_AMP_ (ß Symbol'intern("&")))
    (§ def #_"Symbol" Compiler'ISEQ (ß Symbol'intern("cloiure.lang.ISeq")))

    (§ def #_"Keyword" Compiler'loadNs (ß Keyword'intern(nil, "load-ns")))
    (§ def #_"Keyword" Compiler'inlineKey (ß Keyword'intern(nil, "inline")))
    (§ def #_"Keyword" Compiler'inlineAritiesKey (ß Keyword'intern(nil, "inline-arities")))
    (§ def #_"Keyword" Compiler'staticKey (ß Keyword'intern(nil, "static")))
    (§ def #_"Keyword" Compiler'arglistsKey (ß Keyword'intern(nil, "arglists")))
    (§ def #_"Symbol" Compiler'INVOKE_STATIC (ß Symbol'intern("invokeStatic")))

    (§ def #_"Keyword" Compiler'volatileKey (ß Keyword'intern(nil, "volatile")))
    (§ def #_"Keyword" Compiler'implementsKey (ß Keyword'intern(nil, "implements")))
    (§ def #_"String" Compiler'COMPILE_STUB_PREFIX "compile__stub")

    (§ def #_"Keyword" Compiler'protocolKey (ß Keyword'intern(nil, "protocol")))
    (§ def #_"Keyword" Compiler'onKey (ß Keyword'intern(nil, "on")))
    (§ def #_"Keyword" Compiler'dynamicKey (ß Keyword'intern("dynamic")))
    (§ def #_"Keyword" Compiler'redefKey (ß Keyword'intern(nil, "redef")))

    (§ def #_"Symbol" Compiler'NS (ß Symbol'intern("ns")))
    (§ def #_"Symbol" Compiler'IN_NS (ß Symbol'intern("in-ns")))

    (§ def #_"IPersistentMap" Compiler'specials (ß PersistentHashMap'create(
        (§ map
            DEF           (ß new DefParser())
            LOOP          (ß new LetParser())
            RECUR         (ß new RecurParser())
            IF            (ß new IfParser())
            CASE          (ß new CaseParser())
            LET           (ß new LetParser())
            LETFN         (ß new LetFnParser())
            DO            (ß new BodyParser())
            FN            nil
            QUOTE         (ß new ConstantParser())
            THE_VAR       (ß new TheVarParser())
            IMPORT        (ß new ImportParser())
            DOT           (ß new HostParser())
            ASSIGN        (ß new AssignParser())
            DEFTYPE       (ß new DeftypeParser())
            REIFY         (ß new ReifyParser())
            TRY           (ß new TryParser())
            THROW         (ß new ThrowParser())
            MONITOR_ENTER (ß new MonitorEnterParser())
            MONITOR_EXIT  (ß new MonitorExitParser())
            CATCH         nil
            FINALLY       nil
            NEW           (ß new NewParser())
            _AMP_         nil
        )
    )))

    (§ def- #_"int" Compiler'MAX_POSITIONAL_ARITY 20)
    (§ def- #_"Type" Compiler'OBJECT_TYPE nil)
    (§ def- #_"Type" Compiler'KEYWORD_TYPE (ß Type/getType((§ class Keyword))))
    (§ def- #_"Type" Compiler'VAR_TYPE (ß Type/getType((§ class Var))))
    (§ def- #_"Type" Compiler'SYMBOL_TYPE (ß Type/getType((§ class Symbol))))
    (§ def- #_"Type" Compiler'IFN_TYPE (ß Type/getType((§ class IFn))))
    (§ def- #_"Type" Compiler'AFUNCTION_TYPE (ß Type/getType((§ class AFunction))))
    (§ def- #_"Type" Compiler'RT_TYPE (ß Type/getType((§ class RT))))
    (§ def- #_"Type" Compiler'NUMBERS_TYPE (ß Type/getType((§ class Numbers))))

    (§ def #_"Type" Compiler'CLASS_TYPE (ß Type/getType((§ class Class))))
    (§ def #_"Type" Compiler'NS_TYPE (ß Type/getType((§ class Namespace))))
    (§ def #_"Type" Compiler'UTIL_TYPE (ß Type/getType((§ class Util))))
    (§ def #_"Type" Compiler'REFLECTOR_TYPE (ß Type/getType((§ class Reflector))))
    (§ def #_"Type" Compiler'THROWABLE_TYPE (ß Type/getType((§ class Throwable))))
    (§ def #_"Type" Compiler'BOOLEAN_OBJECT_TYPE (ß Type/getType((§ class Boolean))))
    (§ def #_"Type" Compiler'IPERSISTENTMAP_TYPE (ß Type/getType((§ class IPersistentMap))))
    (§ def #_"Type" Compiler'IOBJ_TYPE (ß Type/getType((§ class IObj))))
    (§ def #_"Type" Compiler'TUPLE_TYPE (ß Type/getType((§ class Tuple))))

    (§ def #_"Method[]" Compiler'createTupleMethods (§ array
        (ß Method/getMethod("cloiure.lang.IPersistentVector create()"))
        (ß Method/getMethod("cloiure.lang.IPersistentVector create(Object)"))
        (ß Method/getMethod("cloiure.lang.IPersistentVector create(Object,Object)"))
        (ß Method/getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object)"))
        (ß Method/getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object)"))
        (ß Method/getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)"))
        (ß Method/getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)"))
    ))

    (§ def- #_"Type[][]" Compiler'ARG_TYPES nil)
    (§ def- #_"Type[]" Compiler'EXCEPTION_TYPES (§ array ))

    (§ static
        (§ ass OBJECT_TYPE (ß Type/getType((§ class Object))))
        (§ ass ARG_TYPES (ß new Type[MAX_POSITIONAL_ARITY + 2][]))
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i <= MAX_POSITIONAL_ARITY) [(§ ass ___i (ß ___i + 1))]
            (let [#_"Type[]" ___a (ß new Type[___i])]
                (loop-when-recur [(§ var #_"int" ___j 0)] (ß ___j < ___i) [(§ ass ___j (ß ___j + 1))]
                    (§ ass (ß ___a[___j]) OBJECT_TYPE)
                )
                (§ ass (ß ARG_TYPES[___i]) ___a)
            )
        )
        (let [#_"Type[]" ___a (ß new Type[MAX_POSITIONAL_ARITY + 1])]
            (loop-when-recur [(§ var #_"int" ___j 0)] (ß ___j < MAX_POSITIONAL_ARITY) [(§ ass ___j (ß ___j + 1))]
                (§ ass (ß ___a[___j]) OBJECT_TYPE)
            )
            (§ ass (ß ___a[MAX_POSITIONAL_ARITY]) (ß Type/getType("[Ljava/lang/Object;")))
            (§ ass (ß ARG_TYPES[MAX_POSITIONAL_ARITY + 1]) ___a)
        )
    )

    ;; symbol->localbinding
    (§ def #_"Var" Compiler'LOCAL_ENV (ß Var'create(nil).setDynamic()))

    ;; vector<localbinding>
    (§ def #_"Var" Compiler'LOOP_LOCALS (ß Var'create().setDynamic()))

    ;; Label
    (§ def #_"Var" Compiler'LOOP_LABEL (ß Var'create().setDynamic()))

    ;; vector<object>
    (§ def #_"Var" Compiler'CONSTANTS (ß Var'create().setDynamic()))

    ;; IdentityHashMap
    (§ def #_"Var" Compiler'CONSTANT_IDS (ß Var'create().setDynamic()))

    ;; vector<keyword>
    (§ def #_"Var" Compiler'KEYWORD_CALLSITES (ß Var'create().setDynamic()))

    ;; vector<var>
    (§ def #_"Var" Compiler'PROTOCOL_CALLSITES (ß Var'create().setDynamic()))

    ;; set<var>
    (§ def #_"Var" Compiler'VAR_CALLSITES (ß Var'create().setDynamic()))

    ;; keyword->constid
    (§ def #_"Var" Compiler'KEYWORDS (ß Var'create().setDynamic()))

    ;; var->constid
    (§ def #_"Var" Compiler'VARS (ß Var'create().setDynamic()))

    ;; FnFrame
    (§ def #_"Var" Compiler'METHOD (ß Var'create(nil).setDynamic()))

    ;; nil or not
    (§ def #_"Var" Compiler'IN_CATCH_FINALLY (ß Var'create(nil).setDynamic()))

    (§ def #_"Var" Compiler'METHOD_RETURN_CONTEXT (ß Var'create(nil).setDynamic()))

    (§ def #_"Var" Compiler'NO_RECUR (ß Var'create(nil).setDynamic()))

    ;; DynamicClassLoader
    (§ def #_"Var" Compiler'LOADER (ß Var'create().setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'SOURCE (ß Var'intern(Namespace'findOrCreate(Symbol'intern("cloiure.core")), Symbol'intern("*source-path*"), "NO_SOURCE_FILE").setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'SOURCE_PATH (ß Var'intern(Namespace'findOrCreate(Symbol'intern("cloiure.core")), Symbol'intern("*file*"), "NO_SOURCE_PATH").setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'COMPILE_PATH (ß Var'intern(Namespace'findOrCreate(Symbol'intern("cloiure.core")), Symbol'intern("*compile-path*"), nil).setDynamic()))
    ;; boolean
    (§ def #_"Var" Compiler'COMPILE_FILES (ß Var'intern(Namespace'findOrCreate(Symbol'intern("cloiure.core")), Symbol'intern("*compile-files*"), Boolean/FALSE).setDynamic()))

    (§ def #_"Var" Compiler'INSTANCE (ß Var'intern(Namespace'findOrCreate(Symbol'intern("cloiure.core")), Symbol'intern("instance?"))))

    (§ def #_"Var" Compiler'ADD_ANNOTATIONS (ß Var'intern(Namespace'findOrCreate(Symbol'intern("cloiure.core")), Symbol'intern("add-annotations"))))

    (§ def #_"Keyword" Compiler'disableLocalsClearingKey (ß Keyword'intern("disable-locals-clearing")))
    (§ def #_"Keyword" Compiler'directLinkingKey (ß Keyword'intern("direct-linking")))
    (§ def #_"Keyword" Compiler'elideMetaKey (ß Keyword'intern("elide-meta")))

    (§ def #_"Var" Compiler'COMPILER_OPTIONS nil)

    (§ defn #_"Object" Compiler'getCompilerOption [#_"Keyword" ___k]
        (ß RT'get(COMPILER_OPTIONS.deref(), ___k))
    )

    (§ static
        (let [#_"Object" ___compilerOptions nil]
            (doseq [#_"Map$Entry" ___e (ß System/getProperties().entrySet())]
                (let [#_"String" ___name (ß (String) ___e.getKey())]
                    (let [#_"String" ___v (ß (String) ___e.getValue())]
                        (when (ß ___name.startsWith("cloiure.compiler."))
                            (§ ass ___compilerOptions (ß RT'assoc(___compilerOptions, RT'keyword(nil, ___name.substring(1 + ___name.lastIndexOf(\.))), RT'readString(___v))))
                        )
                    )
                )
            )

            (§ ass COMPILER_OPTIONS (ß Var'intern(Namespace'findOrCreate(Symbol'intern("cloiure.core")), Symbol'intern("*compiler-options*"), ___compilerOptions).setDynamic()))
        )
    )

    (§ defn #_"Object" Compiler'elideMeta [#_"Object" ___m]
        (let [#_"Collection<Object>" ___elides (ß (Collection<Object>) getCompilerOption(elideMetaKey))]
            (when (some? ___elides)
                (doseq [#_"Object" ___k ___elides]
                    (§ ass ___m (ß RT'dissoc(___m, ___k)))
                )
            )
            ___m
        )
    )

    ;; Integer
    (§ def #_"Var" Compiler'LINE (ß Var'create(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN (ß Var'create(0).setDynamic()))

    (§ defn #_"int" Compiler'lineDeref []
        (ß ((Number)LINE.deref()).intValue())
    )

    (§ defn #_"int" Compiler'columnDeref []
        (ß ((Number)COLUMN.deref()).intValue())
    )

    ;; Integer
    (§ def #_"Var" Compiler'LINE_BEFORE (ß Var'create(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN_BEFORE (ß Var'create(0).setDynamic()))
    (§ def #_"Var" Compiler'LINE_AFTER (ß Var'create(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN_AFTER (ß Var'create(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" Compiler'NEXT_LOCAL_NUM (ß Var'create(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" Compiler'RET_LOCAL_NUM (ß Var'create().setDynamic()))

    (§ def #_"Var" Compiler'COMPILE_STUB_SYM (ß Var'create(nil).setDynamic()))
    (§ def #_"Var" Compiler'COMPILE_STUB_CLASS (ß Var'create(nil).setDynamic()))

    ;; PathNode chain
    (§ def #_"Var" Compiler'CLEAR_PATH (ß Var'create(nil).setDynamic()))

    ;; tail of PathNode chain
    (§ def #_"Var" Compiler'CLEAR_ROOT (ß Var'create(nil).setDynamic()))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def #_"Var" Compiler'CLEAR_SITES (ß Var'create(nil).setDynamic()))

    (§ def #_"Class" Compiler'RECUR_CLASS (§ class Recur))

    (§ defn #_"boolean" Compiler'isSpecial [#_"Object" ___sym]
        (ß specials.containsKey(___sym))
    )

    (§ defn #_"boolean" Compiler'inTailCall [#_"Context" ___context]
        (ß (___context == :Context'RETURN) && (METHOD_RETURN_CONTEXT.deref() != nil) && (IN_CATCH_FINALLY.deref() == nil))
    )

    (§ defn #_"Symbol" Compiler'resolveSymbol [#_"Symbol" ___sym]
        ;; already qualified or classname?
        (when (ß ___sym.name.indexOf(\.) > 0)
            (§ return ___sym)
        )
        (when (ß ___sym.ns != nil)
            (let [#_"Namespace" ___ns (ß namespaceFor(___sym))]
                (when (ß ___ns == nil || ((___ns.name.name == nil) ? (___sym.ns == nil) :or ___ns.name.name.equals(___sym.ns)))
                    (§ return ___sym)
                )
                (§ return (ß Symbol'intern(___ns.name.name, ___sym.name)))
            )
        )
        (let [#_"Object" ___o (ß currentNS().getMapping(___sym))]
            (cond (nil? ___o)
                (do
                    (§ return (ß Symbol'intern(currentNS().name.name, ___sym.name)))
                )
                (ß ___o instanceof Class)
                (do
                    (§ return (ß Symbol'intern(nil, ((Class) ___o).getName())))
                )
                (ß ___o instanceof Var)
                (do
                    (let [#_"Var" ___v (ß (Var) ___o)]
                        (§ return (ß Symbol'intern(___v.ns.name.name, ___v.sym.name)))
                    )
                )
            )
            nil
        )
    )

    (§ defn #_"Class" Compiler'maybePrimitiveType [#_"Expr" ___e]
        (when (ß ___e instanceof MaybePrimitiveExpr && ___e.hasJavaClass() && ((MaybePrimitiveExpr)___e).canEmitPrimitive())
            (let [#_"Class" ___c (ß ___e.getJavaClass())]
                (when (ß Util'isPrimitive(___c))
                    (§ return ___c)
                )
            )
        )
        nil
    )

    (§ defn #_"Class" Compiler'maybeJavaClass [#_"Collection<Expr>" ___exprs]
        (let [#_"Class" ___match nil]
            (try
                (doseq [#_"Expr" ___e ___exprs]
                    (when (ß ___e instanceof ThrowExpr)
                        (§ continue )
                    )
                    (when (ß !___e.hasJavaClass())
                        (§ return nil)
                    )
                    (let [#_"Class" ___c (ß ___e.getJavaClass())]
                        (cond (nil? ___match)
                            (do
                                (§ ass ___match ___c)
                            )
                            (ß ___match != ___c)
                            (do
                                (§ return nil)
                            )
                        )
                    )
                )
                (catch Exception ___e
                    (§ return nil)
                )
            )
            match
        )
    )

    (§ def #_"NilExpr" Compiler'NIL_EXPR (NilExpr.))

    (§ def #_"BooleanExpr" Compiler'TRUE_EXPR (BooleanExpr. true))
    (§ def #_"BooleanExpr" Compiler'FALSE_EXPR (BooleanExpr. false))

    (§ defn #_"boolean" Compiler'subsumes [#_"Class[]" ___c1, #_"Class[]" ___c2]
        ;; presumes matching lengths
        (let [#_"Boolean" ___better false]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___c1.length) [(§ ass ___i (ß ___i + 1))]
                (when (ß ___c1[___i] != ___c2[___i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
                    (if (ß !___c1[___i].isPrimitive() && ___c2[___i].isPrimitive() || ___c2[___i].isAssignableFrom(___c1[___i]))
                        (do
                            (§ ass ___better true)
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )
            better
        )
    )

    (§ defn #_"String" Compiler'getTypeStringForArgs [#_"IPersistentVector" ___args]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___args.count()) [(§ ass ___i (ß ___i + 1))]
                (let [#_"Expr" ___arg (ß (Expr) ___args.nth(___i))]
                    (when (ß ___i > 0)
                        (ß ___sb.append(", "))
                    )
                    (ß ___sb.append((___arg.hasJavaClass() && ___arg.getJavaClass() != nil) ? ___arg.getJavaClass().getName() :or "unknown"))
                )
            )
            (ß ___sb.toString())
        )
    )

    (§ defn #_"int" Compiler'getMatchingParams [#_"String" ___methodName, #_"ArrayList<Class[]>" ___paramlists, #_"IPersistentVector" ___argexprs, #_"List<Class>" ___rets]
        ;; presumes matching lengths
        (let [#_"int" ___matchIdx -1]
            (let [#_"boolean" ___tied false]
                (let [#_"boolean" ___foundExact false]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___paramlists.size()) [(§ ass ___i (ß ___i + 1))]
                        (let [#_"boolean" ___match true]
                            (let [#_"ISeq" ___aseq (ß ___argexprs.seq())]
                                (let [#_"int" ___exact 0]
                                    (loop-when-recur [(§ var #_"int" ___p 0)] (ß ___match && ___p < ___argexprs.count() && ___aseq != nil) [(§ ass ___p (ß ___p + 1), ___aseq (ß ___aseq.next()))]
                                        (let [#_"Expr" ___arg (ß (Expr) ___aseq.first())]
                                            (let [#_"Class" ___aclass (ß ___arg.hasJavaClass() ? ___arg.getJavaClass() :or (§ class Object))]
                                                (let [#_"Class" ___pclass (ß ___paramlists.get(___i)[___p])]
                                                    (if (ß ___arg.hasJavaClass() && ___aclass == ___pclass)
                                                        (do
                                                            (§ ass ___exact (ß ___exact + 1))
                                                        )
                                                        (do
                                                            (§ ass ___match (ß Reflector'paramArgTypeMatch(___pclass, ___aclass)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (cond (ß ___exact == ___argexprs.count())
                                        (do
                                            (when (ß !___foundExact || ___matchIdx == -1 || ___rets.get(___matchIdx).isAssignableFrom(___rets.get(___i)))
                                                (§ ass ___matchIdx ___i)
                                            )
                                            (§ ass ___tied false)
                                            (§ ass ___foundExact true)
                                        )
                                        (ß ___match && !___foundExact)
                                        (do
                                            (if (ß ___matchIdx == -1)
                                                (do
                                                    (§ ass ___matchIdx ___i)
                                                )
                                                (do
                                                    (cond (ß subsumes(___paramlists.get(___i), ___paramlists.get(___matchIdx)))
                                                        (do
                                                            (§ ass ___matchIdx ___i)
                                                            (§ ass ___tied false)
                                                        )
                                                        (ß Arrays/equals(___paramlists.get(___matchIdx), ___paramlists.get(___i)))
                                                        (do
                                                            (when (ß ___rets.get(___matchIdx).isAssignableFrom(___rets.get(___i)))
                                                                (§ ass ___matchIdx ___i)
                                                            )
                                                        )
                                                        (ß !(subsumes(___paramlists.get(___matchIdx), ___paramlists.get(___i))))
                                                        (do
                                                            (§ ass ___tied true)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when ___tied
                        (throw (IllegalArgumentException. (ß "More than one matching method found: " + ___methodName)))
                    )

                    ___matchIdx
                )
            )
        )
    )

    (§ def #_"IPersistentMap" Compiler'CHAR_MAP (ß PersistentHashMap'create(
        (§ map
            \- "_"
            \: "_COLON_"
            \+ "_PLUS_"
            \> "_GT_"
            \< "_LT_"
            \= "_EQ_"
            \~ "_TILDE_"
            \! "_BANG_"
            \@ "_CIRCA_"
            \# "_SHARP_"
            \' "_SINGLEQUOTE_"
            \" "_DOUBLEQUOTE_" ;; oops! "
            \% "_PERCENT_"
            \^ "_CARET_"
            \& "_AMPERSAND_"
            \* "_STAR_"
            \| "_BAR_"
            \{ "_LBRACE_"
            \} "_RBRACE_"
            \[ "_LBRACK_"
            \] "_RBRACK_"
            \/ "_SLASH_"
            \\ "_BSLASH_"
            \? "_QMARK_"
        )
    )))

    (§ def #_"IPersistentMap" Compiler'DEMUNGE_MAP nil)
    (§ def #_"Pattern" Compiler'DEMUNGE_PATTERN nil)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (let [#_"IPersistentMap" ___m (ß RT'map("$", \/))]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(CHAR_MAP)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (let [#_"IMapEntry" ___e (ß (IMapEntry) ___s.first())]
                    (let [#_"Character" ___origCh (ß (Character) ___e.key())]
                        (let [#_"String" ___escapeStr (ß (String) ___e.val())]
                            (§ ass ___m (ß ___m.assoc(___escapeStr, ___origCh)))
                        )
                    )
                )
            )
            (§ ass DEMUNGE_MAP ___m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of
            ;; the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
            ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
            ;; as desired. Sorting string keys of DEMUNGE_MAP from longest to
            ;; shortest ensures correct matching behavior, even if some strings are
            ;; prefixes of others.
            (let [#_"Object[]" ___mungeStrs (ß RT'toArray(RT'keys(___m)))]
                (ß Arrays/sort(___mungeStrs,
                        (§ reify Comparator()
                            #_method
                            (§ defn #_"int" compare [#_"Comparator" this, #_"Object" ___s1, #_"Object" ___s2]
                                (ß ((String) ___s2).length() - ((String) ___s1).length())
                            )
                        )
                    )
                )
                (let [#_"StringBuilder" ___sb (StringBuilder.)]
                    (let [#_"boolean" ___first true]
                        (doseq [#_"Object" ___s ___mungeStrs]
                            (let [#_"String" ___escapeStr (ß (String) ___s)]
                                (when (ß !___first)
                                    (ß ___sb.append("|"))
                                )
                                (§ ass ___first false)
                                (ß ___sb.append("\\Q"))
                                (ß ___sb.append(___escapeStr))
                                (ß ___sb.append("\\E"))
                            )
                        )
                        (§ ass DEMUNGE_PATTERN (ß Pattern/compile(___sb.toString())))
                    )
                )
            )
        )
    )

    (§ defn #_"String" Compiler'munge [#_"String" ___name]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (doseq [#_"char" ___c (ß ___name.toCharArray())]
                (let [#_"String" ___sub (ß (String) CHAR_MAP.valAt(___c))]
                    (if (some? ___sub)
                        (do
                            (ß ___sb.append(___sub))
                        )
                        (do
                            (ß ___sb.append(___c))
                        )
                    )
                )
            )
            (ß ___sb.toString())
        )
    )

    (§ defn #_"String" Compiler'demunge [#_"String" ___mungedName]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Matcher" ___m (ß DEMUNGE_PATTERN.matcher(___mungedName))]
                (let [#_"int" ___lastMatchEnd 0]
                    (while (ß ___m.find())
                        (let [#_"int" ___start (ß ___m.start())]
                            (let [#_"int" ___end (ß ___m.end())]
                                ;; Keep everything before the match
                                (ß ___sb.append(___mungedName.substring(___lastMatchEnd, ___start)))
                                (§ ass ___lastMatchEnd ___end)
                                ;; Replace the match with DEMUNGE_MAP result
                                (let [#_"Character" ___origCh (ß (Character) DEMUNGE_MAP.valAt(___m.group()))]
                                    (ß ___sb.append(___origCh))
                                )
                            )
                        )
                    )
                    ;; Keep everything after the last match
                    (ß ___sb.append(___mungedName.substring(___lastMatchEnd)))
                    (ß ___sb.toString())
                )
            )
        )
    )

    (§ defn #_"PathNode" Compiler'clearPathRoot []
        (ß (PathNode) CLEAR_ROOT.get())
    )

    (§ defn- #_"LocalBinding" Compiler'registerLocal [#_"Symbol" ___sym, #_"Symbol" ___tag, #_"Expr" ___init, #_"boolean" ___isArg]
        (let [#_"int" ___num (ß getAndIncLocalNum())]
            (let [#_"LocalBinding" ___b (ß new LocalBinding(___num, ___sym, ___tag, ___init, ___isArg, clearPathRoot()))]
                (let [#_"IPersistentMap" ___localsMap (ß (IPersistentMap) LOCAL_ENV.deref())]
                    (ß LOCAL_ENV.set(RT'assoc(___localsMap, ___b.sym, ___b)))
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                        (§ ass (ß ___method.locals) (ß (IPersistentMap) RT'assoc(___method.locals, ___b, ___b)))
                        (§ ass (ß ___method.indexlocals) (ß (IPersistentMap) RT'assoc(___method.indexlocals, ___num, ___b)))
                        ___b
                    )
                )
            )
        )
    )

    (§ defn- #_"int" Compiler'getAndIncLocalNum []
        (let [#_"int" ___num (ß ((Number) NEXT_LOCAL_NUM.deref()).intValue())]
            (let [#_"ObjMethod" ___m (ß (ObjMethod) METHOD.deref())]
                (when (ß ___num > ___m.maxLocal)
                    (§ ass (ß ___m.maxLocal) ___num)
                )
                (ß NEXT_LOCAL_NUM.set(___num + 1))
                ___num
            )
        )
    )

    (§ defn #_"Expr" Compiler'analyze [#_"Context" ___context, #_"Object" ___form]
        (ß analyze(___context, ___form, nil))
    )

    (§ defn- #_"Expr" Compiler'analyze [#_"Context" ___context, #_"Object" ___form, #_"String" ___name]
        ;; todo symbol macro expansion?
        (try
            (when (ß ___form instanceof LazySeq)
                (let [#_"Object" ___mform ___form]
                    (§ ass ___form (ß RT'seq(___form)))
                    (when (nil? ___form)
                        (§ ass ___form (ß PersistentList'EMPTY))
                    )
                    (§ ass ___form (ß ((IObj)___form).withMeta(RT'meta(___mform))))
                )
            )
            (cond (nil? ___form)
                (do
                    (§ return NIL_EXPR)
                )
                (ß ___form == Boolean/TRUE)
                (do
                    (§ return TRUE_EXPR)
                )
                (ß ___form == Boolean/FALSE)
                (do
                    (§ return FALSE_EXPR)
                )
            )
            (let [#_"Class" ___fclass (ß ___form.getClass())]
                (cond (ß ___fclass == (§ class Symbol))
                    (do
                        (§ return (ß analyzeSymbol((Symbol) ___form)))
                    )
                    (ß ___fclass == (§ class Keyword))
                    (do
                        (§ return (ß registerKeyword((Keyword) ___form)))
                    )
                    (ß ___form instanceof Number)
                    (do
                        (§ return (ß NumberExpr'parse((Number) ___form)))
                    )
                    (ß ___fclass == (§ class String))
                    (do
                        (§ return (ß new StringExpr(((String) ___form).intern())))
                    )
                    (ß ___form instanceof IPersistentCollection && !(___form instanceof IRecord) && !(___form instanceof IType) && ((IPersistentCollection) ___form).count() == 0)
                    (do
                        (let [#_"Expr" ___ret (EmptyExpr. ___form)]
                            (when (ß RT'meta(___form) != nil)
                                (§ ass ___ret (ß new MetaExpr(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___form).meta()))))
                            )
                            (§ return ___ret)
                        )
                    )
                    (ß ___form instanceof ISeq)
                    (do
                        (§ return (ß analyzeSeq(___context, (ISeq) ___form, ___name)))
                    )
                    (ß ___form instanceof IPersistentVector)
                    (do
                        (§ return (ß VectorExpr'parse(___context, (IPersistentVector) ___form)))
                    )
                    (ß ___form instanceof IRecord)
                    (do
                        (§ return (ConstantExpr. ___form))
                    )
                    (ß ___form instanceof IType)
                    (do
                        (§ return (ConstantExpr. ___form))
                    )
                    (ß ___form instanceof IPersistentMap)
                    (do
                        (§ return (ß MapExpr'parse(___context, (IPersistentMap) ___form)))
                    )
                    (ß ___form instanceof IPersistentSet)
                    (do
                        (§ return (ß SetExpr'parse(___context, (IPersistentSet) ___form)))
                    )
                )

                (ConstantExpr. ___form)
            )
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), ___e)))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    (§ defn #_"Var" Compiler'isMacro [#_"Object" ___op]
        ;; no local macros for now
        (when (ß ___op instanceof Symbol && referenceLocal((Symbol) ___op) != nil)
            (§ return nil)
        )
        (when (ß ___op instanceof Symbol || ___op instanceof Var)
            (let [#_"Var" ___v (ß (___op instanceof Var) ? (Var) ___op :or lookupVar((Symbol) ___op, false, false))]
                (when (ß ___v != nil && ___v.isMacro())
                    (when (ß ___v.ns != currentNS() && !___v.isPublic())
                        (throw (IllegalStateException. (ß "var: " + ___v + " is not public")))
                    )
                    (§ return ___v)
                )
            )
        )
        nil
    )

    (§ defn #_"IFn" Compiler'isInline [#_"Object" ___op, #_"int" ___arity]
        ;; no local inlines for now
        (when (ß ___op instanceof Symbol && referenceLocal((Symbol) ___op) != nil)
            (§ return nil)
        )
        (when (ß ___op instanceof Symbol || ___op instanceof Var)
            (let [#_"Var" ___v (ß (___op instanceof Var) ? (Var) ___op :or lookupVar((Symbol) ___op, false))]
                (when (some? ___v)
                    (when (ß ___v.ns != currentNS() && !___v.isPublic())
                        (throw (IllegalStateException. (ß "var: " + ___v + " is not public")))
                    )
                    (let [#_"IFn" ___ret (ß (IFn) RT'get(___v.meta(), inlineKey))]
                        (when (some? ___ret)
                            (let [#_"IFn" ___arityPred (ß (IFn) RT'get(___v.meta(), inlineAritiesKey))]
                                (when (ß ___arityPred == nil || RT'booleanCast(___arityPred.invoke(___arity)))
                                    (§ return ___ret)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"boolean" Compiler'namesStaticMember [#_"Symbol" ___sym]
        (ß (___sym.ns != nil && namespaceFor(___sym) == nil))
    )

    (§ defn #_"Object" Compiler'preserveTag [#_"ISeq" ___src, #_"Object" ___dst]
        (let [#_"Symbol" ___tag (ß tagOf(___src))]
            (when (ß ___tag != nil && ___dst instanceof IObj)
                (let [#_"IPersistentMap" ___meta (ß RT'meta(___dst))]
                    (§ return (ß ((IObj) ___dst).withMeta((IPersistentMap) RT'assoc(___meta, RT'TAG_KEY, ___tag))))
                )
            )
            ___dst
        )
    )

    #_volatile
    (§ def- #_"Var" Compiler'MACRO_CHECK nil)
    #_volatile
    (§ def- #_"boolean" Compiler'MACRO_CHECK_LOADING false)
    (§ def- #_"Object" Compiler'MACRO_CHECK_LOCK (Object.))

    (§ defn- #_"Var" Compiler'ensureMacroCheck [] #_(§ throws ClassNotFoundException, IOException)
        (when (nil? MACRO_CHECK)
            (§ sync MACRO_CHECK_LOCK
                (when (nil? MACRO_CHECK)
                    (§ ass MACRO_CHECK_LOADING true)
                    (ß RT'load("cloiure/spec/alpha"))
                    (ß RT'load("cloiure/core/specs/alpha"))
                    (§ ass MACRO_CHECK (ß Var'find(Symbol'intern("cloiure.spec.alpha", "macroexpand-check"))))
                    (§ ass MACRO_CHECK_LOADING false)
                )
            )
        )
        MACRO_CHECK
    )

    (§ defn #_"void" Compiler'checkSpecs [#_"Var" ___v, #_"ISeq" ___form]
        (when (ß RT'CHECK_SPECS && !MACRO_CHECK_LOADING)
            (try
                (ß ensureMacroCheck().applyTo(RT'cons(___v, RT'list(___form.next()))))
                (catch Exception ___e
                    (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), ___e)))
                )
            )
        )
        nil
    )

    (§ defn #_"Object" Compiler'macroexpand1 [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (let [#_"ISeq" ___form (ß (ISeq) ___x)]
                (let [#_"Object" ___op (ß RT'first(___form))]
                    (when (ß isSpecial(___op))
                        (§ return ___x)
                    )
                    ;; macro expansion
                    (let [#_"Var" ___v (ß isMacro(___op))]
                        (if (some? ___v)
                            (do
                                (ß checkSpecs(___v, ___form))

                                (try
                                    (let [#_"ISeq" ___args (ß RT'cons(___form, RT'cons(Compiler'LOCAL_ENV.get(), ___form.next())))]
                                        (§ return (ß ___v.applyTo(___args)))
                                    )
                                    (catch ArityException ___e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ß new ArityException(___e.actual - 2, ___e.name)))
                                    )
                                )
                            )
                            (do
                                (when (ß ___op instanceof Symbol)
                                    (let [#_"Symbol" ___sym (ß (Symbol) ___op)]
                                        (let [#_"String" ___sname (ß ___sym.name)]
                                            ;; (.substring s 2 5) => (. s substring 2 5)
                                            (cond (ß ___sym.name.charAt(0) == \.)
                                                (do
                                                    (when (ß RT'length(___form) < 2)
                                                        (throw (ß new IllegalArgumentException("Malformed member expression, expecting (.member target ...)")))
                                                    )
                                                    (let [#_"Symbol" ___meth (ß Symbol'intern(___sname.substring(1)))]
                                                        (let [#_"Object" ___target (ß RT'second(___form))]
                                                            (when (ß HostExpr'maybeClass(___target, false) != nil)
                                                                (§ ass ___target (ß ((IObj)RT'list(IDENTITY, ___target)).withMeta(RT'map(RT'TAG_KEY, CLASS))))
                                                            )
                                                            (§ return (ß preserveTag(___form, RT'listStar(DOT, ___target, ___meth, ___form.next().next()))))
                                                        )
                                                    )
                                                )
                                                (ß namesStaticMember(___sym))
                                                (do
                                                    (let [#_"Symbol" ___target (ß Symbol'intern(___sym.ns))]
                                                        (let [#_"Class" ___c (ß HostExpr'maybeClass(___target, false))]
                                                            (when (some? ___c)
                                                                (let [#_"Symbol" ___meth (ß Symbol'intern(___sym.name))]
                                                                    (§ return (ß preserveTag(___form, RT'listStar(DOT, ___target, ___meth, ___form.next()))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                :else
                                                (do
                                                    ;; (s.substring 2 5) => (. s substring 2 5)
                                                    ;; also (package.class.name ...) (. package.class name ...)
                                                    (let [#_"int" ___idx (ß ___sname.lastIndexOf(\.))]
                                                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                                                        (when (ß ___idx == ___sname.length() - 1)
                                                            (§ return (ß RT'listStar(NEW, Symbol'intern(___sname.substring(0, ___idx)), ___form.next())))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        x
    )

    (§ defn #_"Object" Compiler'macroexpand [#_"Object" ___form]
        (let [#_"Object" ___exf (ß macroexpand1(___form))]
            (when (ß ___exf != ___form)
                (§ return (ß macroexpand(___exf)))
            )
            ___form
        )
    )

    (§ defn- #_"Expr" Compiler'analyzeSeq [#_"Context" ___context, #_"ISeq" ___form, #_"String" ___name]
        (let [#_"Object" ___line (ß lineDeref())]
            (let [#_"Object" ___column (ß columnDeref())]
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                    (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                )
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                    (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                )
                (ß Var'pushThreadBindings(RT'map(LINE, ___line, COLUMN, ___column)))
                (try
                    (let [#_"Object" ___me (ß macroexpand1(___form))]
                        (when (ß ___me != ___form)
                            (§ return (ß analyze(___context, ___me, ___name)))
                        )

                        (let [#_"Object" ___op (ß RT'first(___form))]
                            (when (nil? ___op)
                                (throw (ß new IllegalArgumentException("Can't call nil, form: " + ___form)))
                            )
                            (let [#_"IFn" ___inline (ß isInline(___op, RT'count(RT'next(___form))))]
                                (when (some? ___inline)
                                    (§ return (ß analyze(___context, preserveTag(___form, ___inline.applyTo(RT'next(___form))))))
                                )
                                (§ let [#_"IParser" ___p]
                                    (cond (ß ___op.equals(FN))
                                        (do
                                            (ß FnExpr'parse(___context, ___form, ___name))
                                        )
                                        (some? (§ ass ___p (ß (IParser) specials.valAt(___op))))
                                        (do
                                            (ß ___p.parse(___context, ___form))
                                        )
                                        :else
                                        (do
                                            (ß InvokeExpr'parse(___context, ___form))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (catch Throwable ___e
                        (if (ß !(___e instanceof CompilerException))
                            (do
                                (throw (ß new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), ___e)))
                            )
                            (do
                                (throw (ß (CompilerException) ___e))
                            )
                        )
                    )
                    (finally
                        (ß Var'popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn #_"String" Compiler'errorMsg [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"String" ___s]
        (ß String/format("%s, compiling:(%s:%d:%d)", ___s, ___source, ___line, ___column))
    )

    (§ defn #_"Object" Compiler'eval [#_"Object" ___form]
        (ß eval(___form, true))
    )

    (§ defn #_"Object" Compiler'eval [#_"Object" ___form, #_"boolean" ___freshLoader]
        (let [#_"boolean" ___createdLoader false]
            (when true ;; !LOADER.isBound()
                (ß Var'pushThreadBindings(RT'map(LOADER, RT'makeClassLoader())))
                (§ ass ___createdLoader true)
            )
            (try
                (let [#_"Object" ___line (ß lineDeref())]
                    (let [#_"Object" ___column (ß columnDeref())]
                        (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                            (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                        )
                        (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                            (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                        )
                        (ß Var'pushThreadBindings(RT'map(LINE, ___line, COLUMN, ___column)))
                        (try
                            (§ ass ___form (ß macroexpand(___form)))
                            (cond (ß ___form instanceof ISeq && Util'equals(RT'first(___form), DO))
                                (do
                                    (let [#_"ISeq" ___s (ß RT'next(___form))]
                                        (loop-when-recur [(ß )] (ß RT'next(___s) != nil) [(§ ass ___s (ß RT'next(___s)))]
                                            (ß eval(RT'first(___s), false))
                                        )
                                        (ß eval(RT'first(___s), false))
                                    )
                                )
                                (ß (___form instanceof IType) || (___form instanceof IPersistentCollection && !(RT'first(___form) instanceof Symbol && ((Symbol) RT'first(___form)).name.startsWith("def"))))
                                (do
                                    (let [#_"ObjExpr" ___fexpr (ß (ObjExpr) analyze(:Context'EXPRESSION, RT'list(FN, PersistentVector'EMPTY, ___form), "eval" + RT'nextID()))]
                                        (let [#_"IFn" ___fn (ß (IFn) ___fexpr.eval())]
                                            (ß ___fn.invoke())
                                        )
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Expr" ___expr (ß analyze(:Context'EVAL, ___form))]
                                        (ß ___expr.eval())
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                    )
                )
                (finally
                    (when ___createdLoader
                        (ß Var'popThreadBindings())
                    )
                )
            )
        )
    )

    (§ defn- #_"int" Compiler'registerConstant [#_"Object" ___o]
        (when (ß !CONSTANTS.isBound())
            (§ return -1)
        )
        (let [#_"PersistentVector" ___v (ß (PersistentVector) CONSTANTS.deref())]
            (let [#_"IdentityHashMap<Object, Integer>" ___ids (ß (IdentityHashMap<Object, Integer>) CONSTANT_IDS.deref())]
                (let [#_"Integer" ___i (ß ___ids.get(___o))]
                    (when (some? ___i)
                        (§ return ___i)
                    )
                    (ß CONSTANTS.set(RT'conj(___v, ___o)))
                    (ß ___ids.put(___o, ___v.count()))
                    (ß ___v.count())
                )
            )
        )
    )

    (§ defn- #_"KeywordExpr" Compiler'registerKeyword [#_"Keyword" ___keyword]
        (when (ß !KEYWORDS.isBound())
            (§ return (KeywordExpr. ___keyword))
        )

        (let [#_"IPersistentMap" ___keywordsMap (ß (IPersistentMap) KEYWORDS.deref())]
            (let [#_"Object" ___id (ß RT'get(___keywordsMap, ___keyword))]
                (when (nil? ___id)
                    (ß KEYWORDS.set(RT'assoc(___keywordsMap, ___keyword, registerConstant(___keyword))))
                )
                (KeywordExpr. ___keyword)
            )
        )
    )

    (§ defn- #_"int" Compiler'registerKeywordCallsite [#_"Keyword" ___keyword]
        (when (ß !KEYWORD_CALLSITES.isBound())
            (throw (IllegalAccessError. "KEYWORD_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" ___keywordCallsites (ß (IPersistentVector) KEYWORD_CALLSITES.deref())]
            (§ ass ___keywordCallsites (ß ___keywordCallsites.cons(___keyword)))
            (ß KEYWORD_CALLSITES.set(___keywordCallsites))
            (ß ___keywordCallsites.count() - 1)
        )
    )

    (§ defn- #_"int" Compiler'registerProtocolCallsite [#_"Var" ___v]
        (when (ß !PROTOCOL_CALLSITES.isBound())
            (throw (IllegalAccessError. "PROTOCOL_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" ___protocolCallsites (ß (IPersistentVector) PROTOCOL_CALLSITES.deref())]
            (§ ass ___protocolCallsites (ß ___protocolCallsites.cons(___v)))
            (ß PROTOCOL_CALLSITES.set(___protocolCallsites))
            (ß ___protocolCallsites.count() - 1)
        )
    )

    (§ defn- #_"void" Compiler'registerVarCallsite [#_"Var" ___v]
        (when (ß !VAR_CALLSITES.isBound())
            (throw (IllegalAccessError. "VAR_CALLSITES is not bound"))
        )

        (let [#_"IPersistentCollection" ___varCallsites (ß (IPersistentCollection) VAR_CALLSITES.deref())]
            (§ ass ___varCallsites (ß ___varCallsites.cons(___v)))
            (ß VAR_CALLSITES.set(___varCallsites))
            nil
        )
    )

    (§ defn #_"ISeq" Compiler'fwdPath [#_"PathNode" ___p1]
        (let [#_"ISeq" ___ret nil]
            (loop-when-recur [(ß )] (some? ___p1) [(§ ass ___p1 (ß ___p1.parent))]
                (§ ass ___ret (ß RT'cons(___p1, ___ret)))
            )
            ret
        )
    )

    (§ defn #_"PathNode" Compiler'commonPath [#_"PathNode" ___n1, #_"PathNode" ___n2]
        (let [#_"ISeq" ___xp (ß fwdPath(___n1))]
            (let [#_"ISeq" ___yp (ß fwdPath(___n2))]
                (when (ß RT'first(___xp) != RT'first(___yp))
                    (§ return nil)
                )
                (while (ß RT'second(___xp) != nil && RT'second(___xp) == RT'second(___yp))
                    (§ ass ___xp (ß ___xp.next()))
                    (§ ass ___yp (ß ___yp.next()))
                )
                (ß (PathNode) RT'first(___xp))
            )
        )
    )

    (§ defn #_"void" Compiler'addAnnotation [#_"Object" ___visitor, #_"IPersistentMap" ___meta]
        (when (ß ___meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(___visitor, ___meta))
        )
        nil
    )

    (§ defn #_"void" Compiler'addParameterAnnotation [#_"Object" ___visitor, #_"IPersistentMap" ___meta, #_"int" ___i]
        (when (ß ___meta != nil && ADD_ANNOTATIONS.isBound())
            (ß ADD_ANNOTATIONS.invoke(___visitor, ___meta, ___i))
        )
        nil
    )

    (§ defn- #_"Expr" Compiler'analyzeSymbol [#_"Symbol" ___sym]
        (let [#_"Symbol" ___tag (ß tagOf(___sym))]
            (cond (ß ___sym.ns == nil) ;; ns-qualified syms are always Vars
                (do
                    (let [#_"LocalBinding" ___b (ß referenceLocal(___sym))]
                        (when (some? ___b)
                            (§ return (ß new LocalBindingExpr(___b, ___tag)))
                        )
                    )
                )
                (ß namespaceFor(___sym) == nil)
                (do
                    (let [#_"Symbol" ___nsSym (ß Symbol'intern(___sym.ns))]
                        (let [#_"Class" ___c (ß HostExpr'maybeClass(___nsSym, false))]
                            (when (some? ___c)
                                (when (ß Reflector'getField(___c, ___sym.name, true) != nil)
                                    (§ return (ß new StaticFieldExpr(lineDeref(), columnDeref(), ___c, ___sym.name, ___tag)))
                                )
                                (throw (ß Util'runtimeException("Unable to find static field: " + ___sym.name + " in " + ___c)))
                            )
                        )
                    )
                )
            )
            (let [#_"Object" ___o (ß resolve(___sym))]
                (cond (ß ___o instanceof Var)
                    (do
                        (let [#_"Var" ___v (ß (Var) ___o)]
                            (when (ß isMacro(___v) != nil)
                                (throw (ß Util'runtimeException("Can't take value of a macro: " + ___v)))
                            )
                            (when (ß RT'booleanCast(RT'get(___v.meta(), RT'CONST_KEY)))
                                (§ return (ß analyze(:Context'EXPRESSION, RT'list(QUOTE, ___v.get()))))
                            )
                            (ß registerVar(___v))
                            (§ return (ß new VarExpr(___v, ___tag)))
                        )
                    )
                    (ß ___o instanceof Class)
                    (do
                        (§ return (ConstantExpr. ___o))
                    )
                    (ß ___o instanceof Symbol)
                    (do
                        (§ return (ß new UnresolvedVarExpr((Symbol) ___o)))
                    )
                )

                (throw (ß Util'runtimeException("Unable to resolve symbol: " + ___sym + " in this context")))
            )
        )
    )

    (§ defn #_"String" Compiler'destubClassName [#_"String" ___className]
        ;; skip over prefix + '.' or '/'
        (when (ß ___className.startsWith(COMPILE_STUB_PREFIX))
            (§ return (ß ___className.substring(COMPILE_STUB_PREFIX.length() + 1)))
        )
        className
    )

    (§ defn #_"Type" Compiler'getType [#_"Class" ___c]
        (let [#_"String" ___descriptor (ß Type/getType(___c).getDescriptor())]
            (when (ß ___descriptor.startsWith("L"))
                (§ ass ___descriptor (ß "L" + destubClassName(___descriptor.substring(1))))
            )
            (ß Type/getType(___descriptor))
        )
    )

    (§ defn #_"Object" Compiler'resolve [#_"Symbol" ___sym, #_"boolean" ___allowPrivate]
        (ß resolveIn(currentNS(), ___sym, ___allowPrivate))
    )

    (§ defn #_"Object" Compiler'resolve [#_"Symbol" ___sym]
        (ß resolveIn(currentNS(), ___sym, false))
    )

    (§ defn #_"Namespace" Compiler'namespaceFor [#_"Symbol" ___sym]
        (ß namespaceFor(currentNS(), ___sym))
    )

    (§ defn #_"Namespace" Compiler'namespaceFor [#_"Namespace" ___inns, #_"Symbol" ___sym]
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (let [#_"Symbol" ___nsSym (ß Symbol'intern(___sym.ns))]
            (let [#_"Namespace" ___ns (ß ___inns.lookupAlias(___nsSym))]
                (when (nil? ___ns)
                    ;; ...otherwise check the Namespaces map.
                    (§ ass ___ns (ß Namespace'find(___nsSym)))
                )
                ns
            )
        )
    )

    (§ defn #_"Object" Compiler'resolveIn [#_"Namespace" ___n, #_"Symbol" ___sym, #_"boolean" ___allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond (ß ___sym.ns != nil)
            (do
                (let [#_"Namespace" ___ns (ß namespaceFor(___n, ___sym))]
                    (when (nil? ___ns)
                        (throw (ß Util'runtimeException("No such namespace: " + ___sym.ns)))
                    )

                    (let [#_"Var" ___v (ß ___ns.findInternedVar(Symbol'intern(___sym.name)))]
                        (cond (nil? ___v)
                            (do
                                (throw (ß Util'runtimeException("No such var: " + ___sym)))
                            )
                            (ß ___v.ns != currentNS() && !___v.isPublic() && !___allowPrivate)
                            (do
                                (throw (IllegalStateException. (ß "var: " + ___sym + " is not public")))
                            )
                        )
                        v
                    )
                )
            )
            (ß ___sym.name.indexOf(\.) > 0 || ___sym.name.charAt(0) == \[)
            (do
                (ß RT'classForName(___sym.name))
            )
            (ß ___sym.equals(NS))
            (do
                (ß RT'NS_VAR)
            )
            (ß ___sym.equals(IN_NS))
            (do
                (ß RT'IN_NS_VAR)
            )
            :else
            (do
                (when (ß Util'equals(___sym, COMPILE_STUB_SYM.get()))
                    (§ return (ß COMPILE_STUB_CLASS.get()))
                )
                (let [#_"Object" ___o (ß ___n.getMapping(___sym))]
                    (when (nil? ___o)
                        (if (ß RT'booleanCast(RT'ALLOW_UNRESOLVED_VARS.deref()))
                            (do
                                (§ return ___sym)
                            )
                            (do
                                (throw (ß Util'runtimeException("Unable to resolve symbol: " + ___sym + " in this context")))
                            )
                        )
                    )
                    o
                )
            )
        )
    )

    (§ defn #_"Object" Compiler'maybeResolveIn [#_"Namespace" ___n, #_"Symbol" ___sym]
        ;; note - ns-qualified vars must already exist
        (cond (ß ___sym.ns != nil)
            (do
                (let [#_"Namespace" ___ns (ß namespaceFor(___n, ___sym))]
                    (when (nil? ___ns)
                        (§ return nil)
                    )
                    (let [#_"Var" ___v (ß ___ns.findInternedVar(Symbol'intern(___sym.name)))]
                        (when (nil? ___v)
                            (§ return nil)
                        )
                        v
                    )
                )
            )
            (ß ___sym.name.indexOf(\.) > 0 && !___sym.name.endsWith(".") || ___sym.name.charAt(0) == \[)
            (do
                (ß RT'classForName(___sym.name))
            )
            (ß ___sym.equals(NS))
            (do
                (ß RT'NS_VAR)
            )
            (ß ___sym.equals(IN_NS))
            (do
                (ß RT'IN_NS_VAR)
            )
            :else
            (do
                (let [#_"Object" ___o (ß ___n.getMapping(___sym))]
                    o
                )
            )
        )
    )

    (§ defn #_"Var" Compiler'lookupVar [#_"Symbol" ___sym, #_"boolean" ___internNew, #_"boolean" ___registerMacro]
        (let [#_"Var" ___var nil]
            ;; note - ns-qualified vars in other namespaces must already exist
            (cond (ß ___sym.ns != nil)
                (do
                    (let [#_"Namespace" ___ns (ß namespaceFor(___sym))]
                        (when (nil? ___ns)
                            (§ return nil)
                        )
                        (let [#_"Symbol" ___name (ß Symbol'intern(___sym.name))]
                            (if (ß ___internNew && ___ns == currentNS())
                                (do
                                    (§ ass ___var (ß currentNS().intern(___name)))
                                )
                                (do
                                    (§ ass ___var (ß ___ns.findInternedVar(___name)))
                                )
                            )
                        )
                    )
                )
                (ß ___sym.equals(NS))
                (do
                    (§ ass ___var (ß RT'NS_VAR))
                )
                (ß ___sym.equals(IN_NS))
                (do
                    (§ ass ___var (ß RT'IN_NS_VAR))
                )
                :else
                (do
                    ;; is it mapped?
                    (let [#_"Object" ___o (ß currentNS().getMapping(___sym))]
                        (cond (nil? ___o)
                            (do
                                ;; introduce a new var in the current ns
                                (when ___internNew
                                    (§ ass ___var (ß currentNS().intern(Symbol'intern(___sym.name))))
                                )
                            )
                            (ß ___o instanceof Var)
                            (do
                                (§ ass ___var (ß (Var) ___o))
                            )
                            :else
                            (do
                                (throw (ß Util'runtimeException("Expecting var, but " + ___sym + " is mapped to " + ___o)))
                            )
                        )
                    )
                )
            )
            (when (ß ___var != nil && (!___var.isMacro() || ___registerMacro))
                (ß registerVar(___var))
            )
            var
        )
    )

    (§ defn #_"Var" Compiler'lookupVar [#_"Symbol" ___sym, #_"boolean" ___internNew]
        (ß lookupVar(___sym, ___internNew, true))
    )

    (§ defn- #_"void" Compiler'registerVar [#_"Var" ___var]
        (when (ß !VARS.isBound())
            (§ return nil)
        )
        (let [#_"IPersistentMap" ___varsMap (ß (IPersistentMap) VARS.deref())]
            (let [#_"Object" ___id (ß RT'get(___varsMap, ___var))]
                (when (nil? ___id)
                    (ß VARS.set(RT'assoc(___varsMap, ___var, registerConstant(___var))))
                )
                nil
            )
        )
    )

    (§ defn #_"Namespace" Compiler'currentNS []
        (ß (Namespace) RT'CURRENT_NS.deref())
    )

    (§ defn #_"void" Compiler'closeOver [#_"LocalBinding" ___b, #_"ObjMethod" ___method]
        (when (ß ___b != nil && ___method != nil)
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) RT'get(___method.locals, ___b))]
                (if (nil? ___lb)
                    (do
                        (§ ass (ß ___method.objx.closes) (ß (IPersistentMap) RT'assoc(___method.objx.closes, ___b, ___b)))
                        (ß closeOver(___b, ___method.parent))
                    )
                    (do
                        (when (ß ___lb.idx == 0)
                            (§ ass (ß ___method.usesThis) true)
                        )
                        (when (ß IN_CATCH_FINALLY.deref() != nil)
                            (§ ass (ß ___method.localsUsedInCatchFinally) (ß (PersistentHashSet) ___method.localsUsedInCatchFinally.cons(___b.idx)))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"LocalBinding" Compiler'referenceLocal [#_"Symbol" ___sym]
        (when (ß !LOCAL_ENV.isBound())
            (§ return nil)
        )
        (let [#_"LocalBinding" ___b (ß (LocalBinding) RT'get(LOCAL_ENV.deref(), ___sym))]
            (when (some? ___b)
                (let [#_"ObjMethod" ___method (ß (ObjMethod) METHOD.deref())]
                    (when (ß ___b.idx == 0)
                        (§ ass (ß ___method.usesThis) true)
                    )
                    (ß closeOver(___b, ___method))
                )
            )
            b
        )
    )

    (§ defn- #_"Symbol" Compiler'tagOf [#_"Object" ___o]
        (let [#_"Object" ___tag (ß RT'get(RT'meta(___o), RT'TAG_KEY))]
            (cond (ß ___tag instanceof Symbol)
                (do
                    (§ return (ß (Symbol) ___tag))
                )
                (ß ___tag instanceof String)
                (do
                    (§ return (ß Symbol'intern(nil, (String) ___tag)))
                )
            )
            nil
        )
    )

    (§ defn #_"Object" Compiler'loadFile [#_"String" ___file] #_(§ throws IOException)
        (let [#_"FileInputStream" ___f (FileInputStream. ___file)]
            (try
                (ß load(new InputStreamReader(___f, RT'UTF8), new File(___file).getAbsolutePath(), (new File(___file)).getName()))
                (finally
                    (ß ___f.close())
                )
            )
        )
    )

    (§ defn #_"Object" Compiler'load [#_"Reader" ___rdr]
        (ß load(___rdr, nil, "NO_SOURCE_FILE"))
    )

    (§ defn #_"void" Compiler'consumeWhitespaces [#_"LineNumberingPushbackReader" ___pushbackReader]
        (let [#_"int" ___ch (ß LispReader'read1(___pushbackReader))]
            (while (ß LispReader'isWhitespace(___ch))
                (§ ass ___ch (ß LispReader'read1(___pushbackReader)))
            )
            (ß LispReader'unread(___pushbackReader, ___ch))
            nil
        )
    )

    (§ def- #_"Object" Compiler'OPTS_COND_ALLOWED (ß RT'mapUniqueKeys(LispReader'OPT_READ_COND, LispReader'COND_ALLOW)))

    (§ defn- #_"Object" Compiler'readerOpts [#_"String" ___sourceName]
        (if (ß ___sourceName != nil && ___sourceName.endsWith(".clic"))
            (do
                OPTS_COND_ALLOWED
            )
            (do
                nil
            )
        )
    )

    (§ defn #_"Object" Compiler'load [#_"Reader" ___rdr, #_"String" ___sourcePath, #_"String" ___sourceName]
        (let [#_"Object" ___EOF (Object.)]
            (let [#_"Object" ___ret nil]
                (let [#_"LineNumberingPushbackReader" ___pushbackReader (ß (___rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) ___rdr :or new LineNumberingPushbackReader(___rdr))]
                    (ß consumeWhitespaces(___pushbackReader))
                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                        (§ map
                            LOADER                    (ß RT'makeClassLoader())
                            SOURCE_PATH               ___sourcePath
                            SOURCE                    ___sourceName
                            METHOD                    nil
                            LOCAL_ENV                 nil
                            LOOP_LOCALS               nil
                            NEXT_LOCAL_NUM            0
                            (ß RT'READEVAL)           (ß RT'T)
                            (ß RT'CURRENT_NS)         (ß RT'CURRENT_NS.deref())
                            LINE_BEFORE               (ß ___pushbackReader.getLineNumber())
                            COLUMN_BEFORE             (ß ___pushbackReader.getColumnNumber())
                            LINE_AFTER                (ß ___pushbackReader.getLineNumber())
                            COLUMN_AFTER              (ß ___pushbackReader.getColumnNumber())
                            (ß RT'UNCHECKED_MATH)     (ß RT'UNCHECKED_MATH.deref())
                            (ß RT'WARN_ON_REFLECTION) (ß RT'WARN_ON_REFLECTION.deref())
                            (ß RT'DATA_READERS)       (ß RT'DATA_READERS.deref())
                        )
                    )))

                    (let [#_"Object" ___readerOpts (ß ___readerOpts(___sourceName))]
                        (try
                            (loop-when-recur [(§ var #_"Object" ___r (ß LispReader'read(___pushbackReader, false, ___EOF, false, ___readerOpts)))] (ß ___r != ___EOF) [(§ ass ___r (ß LispReader'read(___pushbackReader, false, ___EOF, false, ___readerOpts)))]
                                (ß consumeWhitespaces(___pushbackReader))
                                (ß LINE_AFTER.set(___pushbackReader.getLineNumber()))
                                (ß COLUMN_AFTER.set(___pushbackReader.getColumnNumber()))
                                (§ ass ___ret (ß eval(___r, false)))
                                (ß LINE_BEFORE.set(___pushbackReader.getLineNumber()))
                                (ß COLUMN_BEFORE.set(___pushbackReader.getColumnNumber()))
                            )
                            (catch LispReaderException ___e
                                (throw (ß new CompilerException(___sourcePath, ___e.line, ___e.column, ___e.getCause())))
                            )
                            (catch Throwable ___e
                                (if (ß !(___e instanceof CompilerException))
                                    (do
                                        (throw (ß new CompilerException(___sourcePath, (Integer) LINE_BEFORE.deref(), (Integer) COLUMN_BEFORE.deref(), ___e)))
                                    )
                                    (do
                                        (throw (ß (CompilerException) ___e))
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                        ___ret
                    )
                )
            )
        )
    )

    (§ defn #_"void" Compiler'writeClassFile [#_"String" ___internalName, #_"byte[]" ___bytecode] #_(§ throws IOException)
        (let [#_"String" ___genPath (ß (String) COMPILE_PATH.deref())]
            (when (nil? ___genPath)
                (throw (ß Util'runtimeException("*compile-path* not set")))
            )
            (let [#_"String[]" ___dirs (ß ___internalName.split("/"))]
                (let [#_"String" ___p ___genPath]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___dirs.length - 1) [(§ ass ___i (ß ___i + 1))]
                        (§ ass ___p (ß ___p + File/separator + ___dirs[___i]))
                        (ß (new File(___p)).mkdir())
                    )
                    (let [#_"String" ___path (ß ___genPath + File/separator + ___internalName + ".class")]
                        (let [#_"File" ___cf (File. ___path)]
                            (ß ___cf.createNewFile())
                            (let [#_"FileOutputStream" ___cfs (FileOutputStream. ___cf)]
                                (try
                                    (ß ___cfs.write(___bytecode))
                                    (ß ___cfs.flush())
                                    (finally
                                        (ß ___cfs.close())
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" Compiler'pushNS []
        (ß Var'pushThreadBindings(PersistentHashMap'create(Var'intern(Symbol'intern("cloiure.core"), Symbol'intern("*ns*")).setDynamic(), nil)))
        nil
    )

    (§ defn #_"void" Compiler'pushNSandLoader [#_"ClassLoader" ___loader]
        (ß Var'pushThreadBindings(RT'map(Var'intern(Symbol'intern("cloiure.core"), Symbol'intern("*ns*")).setDynamic(), nil, RT'FN_LOADER_VAR, ___loader, RT'READEVAL, RT'T)))
        nil
    )

    (§ defn #_"ILookupThunk" Compiler'getLookupThunk [#_"Object" ___target, #_"Keyword" ___k]
        nil
    )

    (§ defn #_"void" Compiler'compile1 [#_"GeneratorAdapter" ___gen, #_"ObjExpr" ___objx, #_"Object" ___form]
        (let [#_"Object" ___line (ß lineDeref())]
            (let [#_"Object" ___column (ß columnDeref())]
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                    (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                )
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                    (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                )
                (ß Var'pushThreadBindings(RT'map(
                    (§ map
                        LINE   ___line
                        COLUMN ___column
                        LOADER (ß RT'makeClassLoader())
                    )
                )))
                (try
                    (§ ass ___form (ß macroexpand(___form)))
                    (if (ß ___form instanceof ISeq && Util'equals(RT'first(___form), DO))
                        (do
                            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'next(___form)))] (some? ___s) [(§ ass ___s (ß RT'next(___s)))]
                                (ß compile1(___gen, ___objx, RT'first(___s)))
                            )
                        )
                        (do
                            (let [#_"Expr" ___expr (ß analyze(:Context'EVAL, ___form))]
                                (§ ass (ß ___objx.keywords) (ß (IPersistentMap) KEYWORDS.deref()))
                                (§ ass (ß ___objx.vars) (ß (IPersistentMap) VARS.deref()))
                                (§ ass (ß ___objx.constants) (ß (PersistentVector) CONSTANTS.deref()))
                                (ß ___expr.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (ß ___expr.eval())
                            )
                        )
                    )
                    (finally
                        (ß Var'popThreadBindings())
                    )
                )
                nil
            )
        )
    )

    (§ defn #_"Object" Compiler'compile [#_"Reader" ___rdr, #_"String" ___sourcePath, #_"String" ___sourceName] #_(§ throws IOException)
        (when (ß COMPILE_PATH.deref() == nil)
            (throw (ß Util'runtimeException("*compile-path* not set")))
        )

        (let [#_"Object" ___EOF (Object.)]
            (let [#_"Object" ___ret nil]
                (let [#_"LineNumberingPushbackReader" ___pushbackReader (ß (___rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) ___rdr :or new LineNumberingPushbackReader(___rdr))]
                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                        (§ map
                            SOURCE_PATH               ___sourcePath
                            SOURCE                    ___sourceName
                            METHOD                    nil
                            LOCAL_ENV                 nil
                            LOOP_LOCALS               nil
                            NEXT_LOCAL_NUM            0
                            (ß RT'READEVAL)           (ß RT'T)
                            (ß RT'CURRENT_NS)         (ß RT'CURRENT_NS.deref())
                            LINE_BEFORE               (ß ___pushbackReader.getLineNumber())
                            COLUMN_BEFORE             (ß ___pushbackReader.getColumnNumber())
                            LINE_AFTER                (ß ___pushbackReader.getLineNumber())
                            COLUMN_AFTER              (ß ___pushbackReader.getColumnNumber())
                            CONSTANTS                 (ß PersistentVector'EMPTY)
                            CONSTANT_IDS              (ß new IdentityHashMap())
                            KEYWORDS                  (ß PersistentHashMap'EMPTY)
                            VARS                      (ß PersistentHashMap'EMPTY)
                            (ß RT'UNCHECKED_MATH)     (ß RT'UNCHECKED_MATH.deref())
                            (ß RT'WARN_ON_REFLECTION) (ß RT'WARN_ON_REFLECTION.deref())
                            (ß RT'DATA_READERS)       (ß RT'DATA_READERS.deref())
                        )
                    )))

                    (try
                        ;; generate loader class
                        (let [#_"ObjExpr" ___objx (ObjExpr. nil)]
                            (§ ass (ß ___objx.internalName) (ß ___sourcePath.replace(File/separator, "/").substring(0, ___sourcePath.lastIndexOf(\.)) + RT'LOADER_SUFFIX))

                            (§ ass (ß ___objx.objtype) (ß Type/getObjectType(___objx.internalName)))
                            (let [#_"ClassWriter" ___cw (ClassWriter. (ß ClassWriter/COMPUTE_MAXS))]
                                (let [#_"ClassVisitor" ___cv ___cw]
                                    (ß ___cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, ___objx.internalName, nil, "java/lang/Object", nil))

                                    ;; static load method
                                    (let [#_"GeneratorAdapter" ___gen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method/getMethod("void load ()"), nil, nil, ___cv))]
                                        (ß ___gen.visitCode())

                                        (let [#_"Object" ___readerOpts (ß ___readerOpts(___sourceName))]
                                            (loop-when-recur [(§ var #_"Object" ___r (ß LispReader'read(___pushbackReader, false, ___EOF, false, ___readerOpts)))] (ß ___r != ___EOF) [(§ ass ___r (ß LispReader'read(___pushbackReader, false, ___EOF, false, ___readerOpts)))]
                                                (ß LINE_AFTER.set(___pushbackReader.getLineNumber()))
                                                (ß COLUMN_AFTER.set(___pushbackReader.getColumnNumber()))
                                                (ß compile1(___gen, ___objx, ___r))
                                                (ß LINE_BEFORE.set(___pushbackReader.getLineNumber()))
                                                (ß COLUMN_BEFORE.set(___pushbackReader.getColumnNumber()))
                                            )
                                            ;; end of load
                                            (ß ___gen.returnValue())
                                            (ß ___gen.endMethod())

                                            ;; static fields for constants
                                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___objx.constants.count()) [(§ ass ___i (ß ___i + 1))]
                                                (when (ß ___objx.usedConstants.contains(___i))
                                                    (ß ___cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, ___objx.constantName(___i), ___objx.constantType(___i).getDescriptor(), nil, nil))
                                                )
                                            )

                                            (let [#_"int" ___INITS_PER 100]
                                                (let [#_"int" ___numInits (ß ___objx.constants.count() / ___INITS_PER)]
                                                    (when (ß ___objx.constants.count() % ___INITS_PER != 0)
                                                        (§ ass ___numInits (ß ___numInits + 1))
                                                    )

                                                    (loop-when-recur [(§ var #_"int" ___n 0)] (ß ___n < ___numInits) [(§ ass ___n (ß ___n + 1))]
                                                        (let [#_"GeneratorAdapter" ___clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method/getMethod("void __init" + ___n + "()"), nil, nil, ___cv))]
                                                            (ß ___clinitgen.visitCode())
                                                            (try
                                                                (ß Var'pushThreadBindings(RT'map(RT'PRINT_DUP, RT'T)))

                                                                (loop-when-recur [(§ var #_"int" ___i (ß ___n * ___INITS_PER))] (ß ___i < ___objx.constants.count() && ___i < (___n + 1) * ___INITS_PER) [(§ ass ___i (ß ___i + 1))]
                                                                    (when (ß ___objx.usedConstants.contains(___i))
                                                                        (ß ___objx.emitValue(___objx.constants.nth(___i), ___clinitgen))
                                                                        (ß ___clinitgen.checkCast(___objx.constantType(___i)))
                                                                        (ß ___clinitgen.putStatic(___objx.objtype, ___objx.constantName(___i), ___objx.constantType(___i)))
                                                                    )
                                                                )
                                                                (finally
                                                                    (ß Var'popThreadBindings())
                                                                )
                                                            )
                                                            (ß ___clinitgen.returnValue())
                                                            (ß ___clinitgen.endMethod())
                                                        )
                                                    )

                                                    ;; static init for constants, keywords and vars
                                                    (let [#_"GeneratorAdapter" ___clinitgen (ß new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method/getMethod("void <clinit> ()"), nil, nil, ___cv))]
                                                        (ß ___clinitgen.visitCode())
                                                        (let [#_"Label" ___startTry (ß ___clinitgen.newLabel())]
                                                            (let [#_"Label" ___endTry (ß ___clinitgen.newLabel())]
                                                                (let [#_"Label" ___end (ß ___clinitgen.newLabel())]
                                                                    (let [#_"Label" ___finallyLabel (ß ___clinitgen.newLabel())]
                                                                        (loop-when-recur [(§ var #_"int" ___n 0)] (ß ___n < ___numInits) [(§ ass ___n (ß ___n + 1))]
                                                                            (ß ___clinitgen.invokeStatic(___objx.objtype, Method/getMethod("void __init" + ___n + "()")))
                                                                        )

                                                                        (ß ___clinitgen.push(___objx.internalName.replace(\/, \.)))
                                                                        (ß ___clinitgen.invokeStatic(RT_TYPE, Method/getMethod("Class classForName(String)")))
                                                                        (ß ___clinitgen.invokeVirtual(CLASS_TYPE, Method/getMethod("ClassLoader getClassLoader()")))
                                                                        (ß ___clinitgen.invokeStatic(Type/getType((§ class Compiler)), Method/getMethod("void pushNSandLoader(ClassLoader)")))
                                                                        (ß ___clinitgen.mark(___startTry))
                                                                        (ß ___clinitgen.invokeStatic(___objx.objtype, Method/getMethod("void load()")))
                                                                        (ß ___clinitgen.mark(___endTry))
                                                                        (ß ___clinitgen.invokeStatic(VAR_TYPE, Method/getMethod("void popThreadBindings()")))
                                                                        (ß ___clinitgen.goTo(___end))

                                                                        (ß ___clinitgen.mark(___finallyLabel))
                                                                        ;; exception should be on stack
                                                                        (ß ___clinitgen.invokeStatic(VAR_TYPE, Method/getMethod("void popThreadBindings()")))
                                                                        (ß ___clinitgen.throwException())
                                                                        (ß ___clinitgen.mark(___end))
                                                                        (ß ___clinitgen.visitTryCatchBlock(___startTry, ___endTry, ___finallyLabel, nil))

                                                                        ;; end of static init
                                                                        (ß ___clinitgen.returnValue())
                                                                        (ß ___clinitgen.endMethod())

                                                                        ;; end of class
                                                                        (ß ___cv.visitEnd())

                                                                        (ß writeClassFile(___objx.internalName, ___cw.toByteArray()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (catch LispReaderException ___e
                            (throw (ß new CompilerException(___sourcePath, ___e.line, ___e.column, ___e.getCause())))
                        )
                        (finally
                            (ß Var'popThreadBindings())
                        )
                    )
                    ___ret
                )
            )
        )
    )

    (§ defn #_"boolean" Compiler'inty [#_"Class" ___c]
        (ß (___c == (§ class int) || ___c == (§ class short) || ___c == (§ class byte) || ___c == (§ class char)))
    )

    (§ defn #_"Class" Compiler'retType [#_"Class" ___tc, #_"Class" ___ret]
        (when (nil? ___tc)
            (§ return ___ret)
        )
        (when (nil? ___ret)
            (§ return ___tc)
        )
        (when (ß ___ret.isPrimitive() && ___tc.isPrimitive())
            (when (ß (inty(___ret) && inty(___tc)) || (___ret == ___tc))
                (§ return ___tc)
            )
            (throw (ß new UnsupportedOperationException("Cannot coerce " + ___ret + " to " + ___tc + ", use a cast instead")))
        )
        tc
    )

    (§ defn #_"Class" Compiler'primClass [#_"Symbol" ___sym]
        (when (nil? ___sym)
            (§ return nil)
        )
        (let [#_"Class" ___c nil]
            (cond (ß ___sym.name.equals("int"))
                (do
                    (§ ass ___c (§ class int))
                )
                (ß ___sym.name.equals("long"))
                (do
                    (§ ass ___c (§ class long))
                )
                (ß ___sym.name.equals("float"))
                (do
                    (§ ass ___c (§ class float))
                )
                (ß ___sym.name.equals("double"))
                (do
                    (§ ass ___c (§ class double))
                )
                (ß ___sym.name.equals("char"))
                (do
                    (§ ass ___c (§ class char))
                )
                (ß ___sym.name.equals("short"))
                (do
                    (§ ass ___c (§ class short))
                )
                (ß ___sym.name.equals("byte"))
                (do
                    (§ ass ___c (§ class byte))
                )
                (ß ___sym.name.equals("boolean"))
                (do
                    (§ ass ___c (§ class boolean))
                )
                (ß ___sym.name.equals("void"))
                (do
                    (§ ass ___c (§ class void))
                )
            )
            c
        )
    )

    (§ defn #_"Class" Compiler'tagClass [#_"Object" ___tag]
        (when (nil? ___tag)
            (§ return (§ class Object))
        )
        (let [#_"Class" ___c nil]
            (when (ß ___tag instanceof Symbol)
                (§ ass ___c (ß primClass((Symbol) ___tag)))
            )
            (when (nil? ___c)
                (§ ass ___c (ß HostExpr'tagToClass(___tag)))
            )
            c
        )
    )

    (§ defn #_"Class" Compiler'primClass [#_"Class" ___c]
        (ß ___c.isPrimitive() ? ___c :or (§ class Object))
    )

    (§ defn #_"Class" Compiler'boxClass [#_"Class" ___p]
        (when (ß !___p.isPrimitive())
            (§ return ___p)
        )

        (let [#_"Class" ___c nil]
            (cond (ß ___p == Integer/TYPE)
                (do
                    (§ ass ___c (§ class Integer))
                )
                (ß ___p == Long/TYPE)
                (do
                    (§ ass ___c (§ class Long))
                )
                (ß ___p == Float/TYPE)
                (do
                    (§ ass ___c (§ class Float))
                )
                (ß ___p == Double/TYPE)
                (do
                    (§ ass ___c (§ class Double))
                )
                (ß ___p == Character/TYPE)
                (do
                    (§ ass ___c (§ class Character))
                )
                (ß ___p == Short/TYPE)
                (do
                    (§ ass ___c (§ class Short))
                )
                (ß ___p == Byte/TYPE)
                (do
                    (§ ass ___c (§ class Byte))
                )
                (ß ___p == Boolean/TYPE)
                (do
                    (§ ass ___c (§ class Boolean))
                )
            )

            c
        )
    )

    (§ defn #_"IPersistentCollection" Compiler'emptyVarCallSites []
        (ß PersistentHashSet'EMPTY)
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (§ init
        (§ field- #_"Object" _first nil)
        (§ field- #_"ISeq" _more nil)
    )

    (§ constructor #_"Cons" Cons [#_"Object" ___first, #_"ISeq" ____more]
        (let [this (ß super())]
            (§ ass (ß this._first) ___first)
            (§ ass (ß this._more) ____more)
            this
        )
    )

    (§ constructor #_"Cons" Cons [#_"IPersistentMap" ___meta, #_"Object" ____first, #_"ISeq" ____more]
        (let [this (ß super(___meta))]
            (§ ass (ß this._first) ____first)
            (§ ass (ß this._more) ____more)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"Cons" this]
        _first
    )

    #_method
    (§ defn #_"ISeq" next [#_"Cons" this]
        (ß more().seq())
    )

    #_method
    (§ defn #_"ISeq" more [#_"Cons" this]
        (when (nil? _more)
            (§ return (ß PersistentList'EMPTY))
        )
        _more
    )

    #_method
    (§ defn #_"int" count [#_"Cons" this]
        (ß 1 + RT'count(_more))
    )

    #_method
    (§ defn #_"Cons" withMeta [#_"Cons" this, #_"IPersistentMap" ___meta]
        (ß new Cons(___meta, _first, _more))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(defprotocol Counted
    #_abstract
    (#_"int" Counted'''count [#_"Counted" this])
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (§ init
        (§ field- #_"ISeq" all nil) ;; never nil
        (§ field- #_"ISeq" prev nil)
        #_volatile
        (§ field- #_"ISeq" _current nil) ;; lazily realized
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"Cycle" Cycle [#_"ISeq" ___all, #_"ISeq" ___prev, #_"ISeq" ___current]
        (let [this (ß super())]
            (§ ass (ß this.all) ___all)
            (§ ass (ß this.prev) ___prev)
            (§ ass (ß this._current) ___current)
            this
        )
    )

    (§ constructor- #_"Cycle" Cycle [#_"IPersistentMap" ___meta, #_"ISeq" ___all, #_"ISeq" ___prev, #_"ISeq" ___current, #_"ISeq" ___next]
        (let [this (ß super(___meta))]
            (§ ass (ß this.all) ___all)
            (§ ass (ß this.prev) ___prev)
            (§ ass (ß this._current) ___current)
            (§ ass (ß this._next) ___next)
            this
        )
    )

    (§ defn #_"ISeq" Cycle'create [#_"ISeq" ___vals]
        (when (nil? ___vals)
            (§ return (ß PersistentList'EMPTY))
        )
        (ß new Cycle(___vals, nil, ___vals))
    )

    ;; realization for use of current
    #_method
    (§ defn- #_"ISeq" current [#_"Cycle" this]
        (when (nil? _current)
            (let [#_"ISeq" ___current (ß prev.next())]
                (§ ass _current (ß (___current == nil) ? all :or ___current))
            )
        )
        _current
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Cycle" this]
        (ß (_current != nil))
    )

    #_method
    (§ defn #_"Object" first [#_"Cycle" this]
        (ß current().first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"Cycle" this]
        (when (nil? _next)
            (§ ass _next (ß new Cycle(all, current(), nil)))
        )
        _next
    )

    #_method
    (§ defn #_"Cycle" withMeta [#_"Cycle" this, #_"IPersistentMap" ___meta]
        (ß new Cycle(___meta, all, prev, _current, _next))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Cycle" this, #_"IFn" ___f]
        (let [#_"ISeq" ___s (ß current())]
            (let [#_"Object" ___ret (ß ___s.first())]
                (while true
                    (§ ass ___s (ß ___s.next()))
                    (when (nil? ___s)
                        (§ ass ___s all)
                    )
                    (§ ass ___ret (ß ___f.invoke(___ret, ___s.first())))
                    (when (ß RT'isReduced(___ret))
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Cycle" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (let [#_"ISeq" ___s (ß current())]
                (while true
                    (§ ass ___ret (ß ___f.invoke(___ret, ___s.first())))
                    (when (ß RT'isReduced(___ret))
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                    (§ ass ___s (ß ___s.next()))
                    (when (nil? ___s)
                        (§ ass ___s all)
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    (§ init
        #_volatile
        (§ field #_"Object" val nil)
        #_volatile
        (§ field #_"Throwable" exception nil)
        #_volatile
        (§ field #_"IFn" fn nil)
    )

    (§ constructor #_"Delay" Delay [#_"IFn" ___fn]
        (let [this (ß super())]
            (§ ass (ß this.fn) ___fn)
            (§ ass (ß this.val) nil)
            (§ ass (ß this.exception) nil)
            this
        )
    )

    (§ defn #_"Object" Delay'force [#_"Object" ___x]
        (ß (___x instanceof Delay) ? ((Delay) ___x).deref() :or ___x)
    )

    #_method
    (§ defn #_"Object" deref [#_"Delay" this]
        (when (some? fn)
            (§ sync this
                ;; double check
                (when (some? fn)
                    (try
                        (§ ass val (ß fn.invoke()))
                        (catch Throwable ___t
                            (§ ass exception ___t)
                        )
                    )
                    (§ ass fn nil)
                )
            )
        )
        (when (some? exception)
            (throw (ß Util'sneakyThrow(exception)))
        )
        val
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Delay" this]
        (§ sync this
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (§ def #_"ConcurrentHashMap<String, Reference<Class>>" DynamicClassLoader'classCache (ß new ConcurrentHashMap<String, Reference<Class>>()))

    (§ def #_"URL[]" DynamicClassLoader'EMPTY_URLS (ß new URL[] (§ array )))

    (§ def #_"ReferenceQueue" DynamicClassLoader'rq (ReferenceQueue.))

    (§ init
        (§ field #_"HashMap<Integer, Object[]>" constantVals (ß new HashMap<Integer, Object[]>()))
    )

    (§ constructor #_"DynamicClassLoader" DynamicClassLoader []
        (let [this (ß super())]
            ;; pseudo test in lieu of hasContextClassLoader()
            (§ super(EMPTY_URLS, (Thread/currentThread().getContextClassLoader() == nil || Thread/currentThread().getContextClassLoader() == ClassLoader/getSystemClassLoader()) ? (§ class Compiler).getClassLoader() :or Thread/currentThread().getContextClassLoader()))
            this
        )
    )

    (§ constructor #_"DynamicClassLoader" DynamicClassLoader [#_"ClassLoader" ___parent]
        (let [this (ß super(EMPTY_URLS, ___parent))]
            this
        )
    )

    #_method
    (§ defn #_"Class" defineClass [#_"DynamicClassLoader" this, #_"String" ___name, #_"byte[]" ___bytes, #_"Object" ___srcForm]
        (ß Util'clearCache(rq, classCache))
        (let [#_"Class" ___c (ß defineClass(___name, ___bytes, 0, ___bytes.length))]
            (ß classCache.put(___name, new SoftReference(___c, rq)))
            c
        )
    )

    (§ defn #_"Class<?>" DynamicClassLoader'findInMemoryClass [#_"String" ___name]
        (let [#_"Reference<Class>" ___cr (ß classCache.get(___name))]
            (when (some? ___cr)
                (let [#_"Class" ___c (ß ___cr.get())]
                    (if (some? ___c)
                        (do
                            (§ return ___c)
                        )
                        (do
                            (ß classCache.remove(___name, ___cr))
                        )
                    )
                )
            )
            nil
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" findClass [#_"DynamicClassLoader" this, #_"String" ___name] #_(§ throws ClassNotFoundException)
        (let [#_"Class" ___c (ß DynamicClassLoader'findInMemoryClass(___name))]
            (if (some? ___c)
                (do
                    ___c
                )
                (do
                    (ß super.findClass(___name))
                )
            )
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" loadClass [#_"DynamicClassLoader" this, #_"String" ___name, #_"boolean" ___resolve] #_(§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" ___c (ß findLoadedClass(___name))]
                (when (nil? ___c)
                    (§ ass ___c (ß DynamicClassLoader'findInMemoryClass(___name)))
                    (when (nil? ___c)
                        (§ ass ___c (ß super.loadClass(___name, false)))
                    )
                )
                (when ___resolve
                    (ß resolveClass(___c))
                )
                c
            )
        )
    )

    #_method
    (§ defn #_"void" registerConstants [#_"DynamicClassLoader" this, #_"int" ___id, #_"Object[]" ___val]
        (ß constantVals.put(___id, ___val))
        nil
    )

    #_method
    (§ defn #_"Object[]" getConstants [#_"DynamicClassLoader" this, #_"int" ___id]
        (ß constantVals.get(___id))
    )

    #_method
    (§ defn #_"void" addURL [#_"DynamicClassLoader" this, #_"URL" ___url]
        (ß super.addURL(___url))
        nil
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns EdnReaderException (§ extends RuntimeException)
    (§ init
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
    )

    (§ constructor #_"EdnReaderException" EdnReaderException [#_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (ß super(___cause))]
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            this
        )
    )
)

#_stateless
(class-ns EdnStringReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnStringReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [(§ var #_"int" ___ch (ß read1(___r)))] (ß ___ch != \") [(§ ass ___ch (ß read1(___r)))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (ß Util'runtimeException("EOF while reading string")))
                    )
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (ß Util'runtimeException("EOF while reading string")))
                        )
                        (§ switch ___ch
                            (§ case \t)
                            (do
                                (§ ass ___ch (ß \tab))
                                (§ break )
                            )
                            (§ case \r)
                            (do
                                (§ ass ___ch (ß \return))
                                (§ break )
                            )
                            (§ case \n)
                            (do
                                (§ ass ___ch (ß \newline))
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (§ break )
                            )
                            (§ case \") ;; oops! "
                            (do
                                (§ break )
                            )
                            (§ case \b)
                            (do
                                (§ ass ___ch (ß \backspace))
                                (§ break )
                            )
                            (§ case \f)
                            (do
                                (§ ass ___ch (ß \formfeed))
                                (§ break )
                            )
                            (§ case \u)
                            (do
                                (§ ass ___ch (ß read1(___r)))
                                (when (ß Character/digit(___ch, 16) == -1)
                                    (throw (ß Util'runtimeException("Invalid unicode escape: \\u" + (char) ___ch)))
                                )
                                (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 16, 4, true)))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (if (ß Character/isDigit(___ch))
                                    (do
                                        (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 8, 3, false)))
                                        (when (ß ___ch > 0377)
                                            (throw (ß Util'runtimeException("Octal escape sequence must be in range [0, 377].")))
                                        )
                                    )
                                    (do
                                        (throw (ß Util'runtimeException("Unsupported escape character: \\" + (char) ___ch)))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
                (ß ___sb.toString())
            )
        )
    )
)

#_stateless
(class-ns EdnCommentReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnCommentReader" this, #_"Object" ___reader, #_"Object" ___semicolon, #_"Object" ___opts]
        (let [#_"Reader" ___r (ß (Reader) ___reader)]
            (§ let [#_"int" ___ch]
                (§ loop
                    (§ ass ___ch (ß read1(___r)))
                    (§ recur-if (___ch != -1 && ___ch != \newline && ___ch != \return))
                )
                ___r
            )
        )
    )
)

#_stateless
(class-ns EdnDiscardReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnDiscardReader" this, #_"Object" ___reader, #_"Object" ___underscore, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß read(___r, true, nil, true, ___opts))
            r
        )
    )
)

#_stateless
(class-ns EdnNamespaceMapReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnNamespaceMapReader" this, #_"Object" ___reader, #_"Object" ___colon, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            ;; Read ns symbol
            (let [#_"Object" ___sym (ß read(___r, true, nil, false, ___opts))]
                (when (ß !(___sym instanceof Symbol) || ((Symbol)___sym).getNamespace() != nil)
                    (throw (RuntimeException. (ß "Namespaced map must specify a valid namespace: " + ___sym)))
                )
                (let [#_"String" ___ns (ß ((Symbol)___sym).getName())]
                    ;; Read map
                    (let [#_"int" ___nextChar (ß read1(___r))]
                        (while (ß isWhitespace(___nextChar))
                            (§ ass ___nextChar (ß read1(___r)))
                        )
                        (when (ß \{ != ___nextChar)
                            (throw (RuntimeException. "Namespaced map must specify a map"))
                        )
                        (let [#_"List" ___kvs (ß readDelimitedList(\}, ___r, true, ___opts))]
                            (when (ß (___kvs.size() & 1) == 1)
                                (throw (ß Util'runtimeException("Namespaced map literal must contain an even number of forms")))
                            )

                            ;; Construct output map
                            (let [#_"Object[]" ___a (ß new Object[___kvs.size()])]
                                (let [#_"Iterator" ___iter (ß ___kvs.iterator())]
                                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___iter.hasNext()) [(§ ass ___i (ß ___i + 2))]
                                        (let [#_"Object" ___key (ß ___iter.next())]
                                            (let [#_"Object" ___val (ß ___iter.next())]
                                                (cond (ß ___key instanceof Keyword)
                                                    (do
                                                        (let [#_"Keyword" ___kw (ß (Keyword) ___key)]
                                                            (cond (ß ___kw.getNamespace() == nil)
                                                                (do
                                                                    (§ ass ___key (ß Keyword'intern(___ns, ___kw.getName())))
                                                                )
                                                                (ß ___kw.getNamespace().equals("_"))
                                                                (do
                                                                    (§ ass ___key (ß Keyword'intern(nil, ___kw.getName())))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (ß ___key instanceof Symbol)
                                                    (do
                                                        (let [#_"Symbol" ___s (ß (Symbol) ___key)]
                                                            (cond (ß ___s.getNamespace() == nil)
                                                                (do
                                                                    (§ ass ___key (ß Symbol'intern(___ns, ___s.getName())))
                                                                )
                                                                (ß ___s.getNamespace().equals("_"))
                                                                (do
                                                                    (§ ass ___key (ß Symbol'intern(nil, ___s.getName())))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (§ ass (ß ___a[___i]) ___key)
                                                (§ ass (ß ___a[___i + 1]) ___val)
                                            )
                                        )
                                    )
                                    (ß RT'map(___a))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns EdnDispatchReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnDispatchReader" this, #_"Object" ___reader, #_"Object" ___hash, #_"Object" ___opts]
        (let [#_"int" ___ch (ß read1((Reader) ___reader))]
            (when (ß ___ch == -1)
                (throw (ß Util'runtimeException("EOF while reading character")))
            )
            (let [#_"IFn" ___fn (ß dispatchMacros[___ch])]
                (when (nil? ___fn)
                    ;; try tagged reader
                    (when (ß Character/isLetter(___ch))
                        (ß unread((PushbackReader) ___reader, ___ch))
                        (§ return (ß taggedReader.invoke(___reader, ___ch, ___opts)))
                    )

                    (throw (ß Util'runtimeException(String/format("No dispatch macro for: %c", (char) ___ch))))
                )
                (ß ___fn.invoke(___reader, ___ch, ___opts))
            )
        )
    )
)

#_stateless
(class-ns EdnMetaReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnMetaReader" this, #_"Object" ___reader, #_"Object" ___caret, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
                        (§ ass ___column (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()-1))
                    )
                    (let [#_"Object" ___meta (ß read(___r, true, nil, true, ___opts))]
                        (cond (ß ___meta instanceof Symbol || ___meta instanceof String)
                            (do
                                (§ ass ___meta (ß RT'map(RT'TAG_KEY, ___meta)))
                            )
                            (ß ___meta instanceof Keyword)
                            (do
                                (§ ass ___meta (ß RT'map(___meta, RT'T)))
                            )
                            (ß !(___meta instanceof IPersistentMap))
                            (do
                                (throw (ß new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")))
                            )
                        )

                        (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts))]
                            (if (ß ___o instanceof IMeta)
                                (do
                                    (when (ß ___line != -1 && ___o instanceof ISeq)
                                        (§ ass ___meta (ß ((IPersistentMap) ___meta).assoc(RT'LINE_KEY, ___line).assoc(RT'COLUMN_KEY, ___column)))
                                    )
                                    (when (ß ___o instanceof IReference)
                                        (ß ((IReference)___o).resetMeta((IPersistentMap) ___meta))
                                        (§ return ___o)
                                    )
                                    (let [#_"Object" ___ometa (ß RT'meta(___o))]
                                        (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___meta)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                            (let [#_"IMapEntry" ___kv (ß (IMapEntry) ___s.first())]
                                                (§ ass ___ometa (ß RT'assoc(___ometa, ___kv.getKey(), ___kv.getValue())))
                                            )
                                        )
                                        (ß ((IObj) ___o).withMeta((IPersistentMap) ___ometa))
                                    )
                                )
                                (do
                                    (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns EdnCharacterReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnCharacterReader" this, #_"Object" ___reader, #_"Object" ___backslash, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß read1(___r))]
                (when (ß ___ch == -1)
                    (throw (ß Util'runtimeException("EOF while reading character")))
                )
                (let [#_"String" ___token (ß readToken(___r, (char) ___ch, false))]
                    (cond (ß ___token.length() == 1)
                        (do
                            (§ return (ß Character/valueOf(___token.charAt(0))))
                        )
                        (ß ___token.equals("newline"))
                        (do
                            (§ return (ß \newline))
                        )
                        (ß ___token.equals("space"))
                        (do
                            (§ return (ß \space))
                        )
                        (ß ___token.equals("tab"))
                        (do
                            (§ return (ß \tab))
                        )
                        (ß ___token.equals("backspace"))
                        (do
                            (§ return (ß \backspace))
                        )
                        (ß ___token.equals("formfeed"))
                        (do
                            (§ return (ß \formfeed))
                        )
                        (ß ___token.equals("return"))
                        (do
                            (§ return (ß \return))
                        )
                        (ß ___token.startsWith("u"))
                        (do
                            (let [#_"char" ___c (ß (char) readUnicodeChar(___token, 1, 4, 16))]
                                (when (ß ___c >= (§ char "\ud800") && ___c <= (§ char "\udfff")) ;; surrogate code unit?
                                    (throw (ß Util'runtimeException("Invalid character constant: \\u" + Integer/toString(___c, 16))))
                                )
                                (§ return ___c)
                            )
                        )
                        (ß ___token.startsWith("o"))
                        (do
                            (let [#_"int" ___len (ß ___token.length() - 1)]
                                (when (ß ___len > 3)
                                    (throw (ß Util'runtimeException("Invalid octal escape sequence length: " + ___len)))
                                )
                                (let [#_"int" ___uc (ß readUnicodeChar(___token, 1, ___len, 8))]
                                    (when (ß ___uc > 0377)
                                        (throw (ß Util'runtimeException("Octal escape sequence must be in range [0, 377].")))
                                    )
                                    (§ return (ß (char) ___uc))
                                )
                            )
                        )
                    )
                    (throw (ß Util'runtimeException("Unsupported character: \\" + ___token)))
                )
            )
        )
    )
)

#_stateless
(class-ns EdnListReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnListReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
                        (§ ass ___column (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()-1))
                    )
                    (let [#_"List" ___list (ß readDelimitedList(\), ___r, true, ___opts))]
                        (when (ß ___list.isEmpty())
                            (§ return (ß PersistentList'EMPTY))
                        )
                        (let [#_"IObj" ___s (ß (IObj) PersistentList'create(___list))]
                            s
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns EdnVectorReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnVectorReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß LazilyPersistentVector'create(readDelimitedList(\], ___r, true, ___opts)))
        )
    )
)

#_stateless
(class-ns EdnMapReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnMapReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object[]" ___a (ß readDelimitedList(\}, ___r, true, ___opts).toArray())]
                (when (ß (___a.length & 1) == 1)
                    (throw (ß Util'runtimeException("Map literal must contain an even number of forms")))
                )
                (ß RT'map(___a))
            )
        )
    )
)

#_stateless
(class-ns EdnSetReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnSetReader" this, #_"Object" ___reader, #_"Object" ___leftbracket, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß PersistentHashSet'createWithCheck(readDelimitedList(\}, ___r, true, ___opts)))
        )
    )
)

#_stateless
(class-ns EdnUnmatchedDelimiterReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnUnmatchedDelimiterReader" this, #_"Object" ___reader, #_"Object" ___rightdelim, #_"Object" ___opts]
        (throw (ß Util'runtimeException("Unmatched delimiter: " + ___rightdelim)))
    )
)

#_stateless
(class-ns EdnUnreadableReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EdnUnreadableReader" this, #_"Object" ___reader, #_"Object" ___leftangle, #_"Object" ___opts]
        (throw (ß Util'runtimeException("Unreadable form")))
    )
)

#_stateless
(class-ns EdnSymbolicValueReader (§ extends AFn)
    (§ def #_"IPersistentMap" EdnSymbolicValueReader'specials (ß PersistentHashMap'create(
        (§ map
            (ß Symbol'intern("Inf"))  (ß Double/POSITIVE_INFINITY)
            (ß Symbol'intern("-Inf")) (ß Double/NEGATIVE_INFINITY)
            (ß Symbol'intern("NaN"))  (ß Double/NaN)
        )
    )))

    #_method
    (§ defn #_"Object" invoke [#_"EdnSymbolicValueReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts))]
                (when (ß !(___o instanceof Symbol))
                    (throw (ß Util'runtimeException("Invalid token: ##" + ___o)))
                )
                (when (ß !(EdnSymbolicValueReader'specials.containsKey(___o)))
                    (throw (ß Util'runtimeException("Unknown symbolic value: ##" + ___o)))
                )

                (ß EdnSymbolicValueReader'specials.valAt(___o))
            )
        )
    )
)

#_stateless
(class-ns TaggedReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"TaggedReader" this, #_"Object" ___reader, #_"Object" ___firstChar, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___name (ß read(___r, true, nil, false, ___opts))]
                (when (ß !(___name instanceof Symbol))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" ___sym (ß (Symbol)___name)]
                    (ß readTagged(___r, ___sym, (IPersistentMap) ___opts))
                )
            )
        )
    )

    (§ def #_"Keyword" TaggedReader'READERS (ß Keyword'intern(nil, "readers")))
    (§ def #_"Keyword" TaggedReader'DEFAULT (ß Keyword'intern(nil, "default")))

    #_method
    (§ defn- #_"Object" readTagged [#_"TaggedReader" this, #_"PushbackReader" ___reader, #_"Symbol" ___tag, #_"IPersistentMap" ___opts]
        (let [#_"Object" ___o (ß read(___reader, true, nil, true, ___opts))]
            (let [#_"ILookup" ___readers (ß (ILookup)RT'get(___opts, READERS))]
                (let [#_"IFn" ___dataReader (ß (IFn)RT'get(___readers, ___tag))]
                    (when (nil? ___dataReader)
                        (§ ass ___dataReader (ß (IFn)RT'get(RT'DEFAULT_DATA_READERS.deref(), ___tag)))
                    )
                    (if (nil? ___dataReader)
                        (do
                            (let [#_"IFn" ___defaultReader (ß (IFn)RT'get(___opts, TaggedReader'DEFAULT))]
                                (if (some? ___defaultReader)
                                    (do
                                        (ß ___defaultReader.invoke(___tag, ___o))
                                    )
                                    (do
                                        (throw (ß new RuntimeException("No reader function for tag " + ___tag.toString())))
                                    )
                                )
                            )
                        )
                        (do
                            (ß ___dataReader.invoke(___o))
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns EdnReader
    (§ def #_"IFn[]" EdnReader'macros (ß new IFn[256]))
    (§ def #_"IFn[]" EdnReader'dispatchMacros (ß new IFn[256]))
    (§ def #_"Pattern" EdnReader'symbolPat (ß Pattern/compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")))
    (§ def #_"Pattern" EdnReader'intPat (ß Pattern/compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")))
    (§ def #_"Pattern" EdnReader'ratioPat (ß Pattern/compile("([-+]?[0-9]+)/([0-9]+)")))
    (§ def #_"Pattern" EdnReader'floatPat (ß Pattern/compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")))

    (§ def #_"IFn" EdnReader'taggedReader (TaggedReader.))

    (§ static
        (§ ass (ß macros[\"]) (EdnStringReader.)) ;; oops! "
        (§ ass (ß macros[\;]) (EdnCommentReader.))
        (§ ass (ß macros[\^]) (EdnMetaReader.))
        (§ ass (ß macros[\(]) (EdnListReader.))
        (§ ass (ß macros[\)]) (EdnUnmatchedDelimiterReader.))
        (§ ass (ß macros[\[]) (EdnVectorReader.))
        (§ ass (ß macros[\]]) (EdnUnmatchedDelimiterReader.))
        (§ ass (ß macros[\{]) (EdnMapReader.))
        (§ ass (ß macros[\}]) (EdnUnmatchedDelimiterReader.))
        (§ ass (ß macros[\\]) (EdnCharacterReader.))
        (§ ass (ß macros[\#]) (EdnDispatchReader.))

        (§ ass (ß dispatchMacros[\#]) (EdnSymbolicValueReader.))
        (§ ass (ß dispatchMacros[\^]) (EdnMetaReader.))
        (§ ass (ß dispatchMacros[\{]) (EdnSetReader.))
        (§ ass (ß dispatchMacros[\<]) (EdnUnreadableReader.))
        (§ ass (ß dispatchMacros[\_]) (EdnDiscardReader.))
        (§ ass (ß dispatchMacros[\:]) (EdnNamespaceMapReader.))
    )

    (§ defn #_"boolean" EdnReader'nonConstituent [#_"int" ___ch]
        (ß (___ch == \@ || ___ch == \` || ___ch == \~))
    )

    (§ defn #_"Object" EdnReader'readString [#_"String" ___s, #_"IPersistentMap" ___opts]
        (let [#_"PushbackReader" ___r (ß new PushbackReader(new java.io.StringReader(___s)))]
            (ß read(___r, ___opts))
        )
    )

    (§ defn #_"boolean" EdnReader'isWhitespace [#_"int" ___ch]
        (ß (Character/isWhitespace(___ch) || ___ch == \,))
    )

    (§ defn #_"void" EdnReader'unread [#_"PushbackReader" ___r, #_"int" ___ch]
        (when (ß ___ch != -1)
            (try
                (ß ___r.unread(___ch))
                (catch IOException ___e
                    (throw (ß Util'sneakyThrow(___e)))
                )
            )
        )
        nil
    )

    (§ defn #_"int" EdnReader'read1 [#_"Reader" ___r]
        (try
            (ß ___r.read())
            (catch IOException ___e
                (throw (ß Util'sneakyThrow(___e)))
            )
        )
    )

    (§ def #_"Keyword" EdnReader'EOF (ß Keyword'intern(nil, "eof")))

    (§ defn #_"Object" EdnReader'read [#_"PushbackReader" ___r, #_"IPersistentMap" ___opts]
        (ß read(___r, !___opts.containsKey(EOF), ___opts.valAt(EOF), false, ___opts))
    )

    (§ defn #_"Object" EdnReader'read [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts]
        (try
            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (when ___eofIsError
                            (throw (ß Util'runtimeException("EOF while reading")))
                        )
                        (§ return ___eofValue)
                    )

                    (when (ß Character/isDigit(___ch))
                        (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                            (when (ß RT'suppressRead())
                                (§ return nil)
                            )
                            (§ return ___n)
                        )
                    )

                    (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                        (when (some? ___macroFn)
                            (let [#_"Object" ___ret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts))]
                                (when (ß RT'suppressRead())
                                    (§ return nil)
                                )
                                ;; no op macros return the reader
                                (when (ß ___ret == ___r)
                                    (§ continue )
                                )
                                (§ return ___ret)
                            )
                        )

                        (when (ß ___ch == \+ || ___ch == \-)
                            (let [#_"int" ___ch2 (ß read1(___r))]
                                (when (ß Character/isDigit(___ch2))
                                    (ß unread(___r, ___ch2))
                                    (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                                        (when (ß RT'suppressRead())
                                            (§ return nil)
                                        )
                                        (§ return ___n)
                                    )
                                )
                                (ß unread(___r, ___ch2))
                            )
                        )

                        (let [#_"String" ___token (ß readToken(___r, (char) ___ch, true))]
                            (when (ß RT'suppressRead())
                                (§ return nil)
                            )
                            (§ return (ß interpretToken(___token)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (when (ß ___isRecursive || !(___r instanceof LineNumberingPushbackReader))
                    (throw (ß Util'sneakyThrow(___e)))
                )
                (let [#_"LineNumberingPushbackReader" ___rdr (ß (LineNumberingPushbackReader) ___r)]
                    (throw (ß new EdnReaderException(___rdr.getLineNumber(), ___rdr.getColumnNumber(), ___e)))
                )
            )
        )
    )

    (§ defn- #_"String" EdnReader'readToken [#_"PushbackReader" ___r, #_"char" ___initch, #_"boolean" ___leadConstituent]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (when (ß ___leadConstituent && nonConstituent(___initch))
                (throw (ß Util'runtimeException("Invalid leading character: " + (char)___initch)))
            )

            (ß ___sb.append(___initch))

            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (cond (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                        (do
                            (ß unread(___r, ___ch))
                            (§ return (ß ___sb.toString()))
                        )
                        (ß nonConstituent(___ch))
                        (do
                            (throw (ß Util'runtimeException("Invalid constituent character: " + (char)___ch)))
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )
        )
    )

    (§ defn- #_"Object" EdnReader'readNumber [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (ß ___sb.append(___initch))

            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || isMacro(___ch))
                        (ß unread(___r, ___ch))
                        (§ break )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )

            (let [#_"String" ___s (ß ___sb.toString())]
                (let [#_"Object" ___n (ß matchNumber(___s))]
                    (when (nil? ___n)
                        (throw (NumberFormatException. (ß "Invalid number: " + ___s)))
                    )
                    n
                )
            )
        )
    )

    (§ defn- #_"int" EdnReader'readUnicodeChar [#_"String" ___token, #_"int" ___offset, #_"int" ___length, #_"int" ___base]
        (when (ß ___token.length() != ___offset + ___length)
            (throw (IllegalArgumentException. (ß "Invalid unicode character: \\" + ___token)))
        )
        (let [#_"int" ___uc 0]
            (loop-when-recur [(§ var #_"int" ___i ___offset)] (ß ___i < ___offset + ___length) [(§ ass ___i (ß ___i + 1))]
                (let [#_"int" ___d (ß Character/digit(___token.charAt(___i), ___base))]
                    (when (ß ___d == -1)
                        (throw (ß new IllegalArgumentException("Invalid digit: " + ___token.charAt(___i))))
                    )
                    (§ ass ___uc (ß ___uc * ___base + ___d))
                )
            )
            (ß (char) ___uc)
        )
    )

    (§ defn- #_"int" EdnReader'readUnicodeChar [#_"PushbackReader" ___r, #_"int" ___initch, #_"int" ___base, #_"int" ___length, #_"boolean" ___exact]
        (let [#_"int" ___uc (ß Character/digit(___initch, ___base))]
            (when (ß ___uc == -1)
                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ___initch)))
            )
            (let [#_"int" ___i 1]
                (loop-when-recur [(ß )] (ß ___i < ___length) [(§ ass ___i (ß ___i + 1))]
                    (let [#_"int" ___ch (ß read1(___r))]
                        (when (ß ___ch == -1 || isWhitespace(___ch) || isMacro(___ch))
                            (ß unread(___r, ___ch))
                            (§ break )
                        )
                        (let [#_"int" ___d (ß Character/digit(___ch, ___base))]
                            (when (ß ___d == -1)
                                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ___ch)))
                            )
                            (§ ass ___uc (ß ___uc * ___base + ___d))
                        )
                    )
                )
                (when (ß ___i != ___length && ___exact)
                    (throw (ß new IllegalArgumentException("Invalid character length: " + ___i + ", should be: " + ___length)))
                )
                ___uc
            )
        )
    )

    (§ defn- #_"Object" EdnReader'interpretToken [#_"String" ___s]
        (cond (ß ___s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß ___s.equals("true"))
            (do
                (§ return (ß RT'T))
            )
            (ß ___s.equals("false"))
            (do
                (§ return (ß RT'F))
            )
        )

        (let [#_"Object" ___ret nil]
            (§ ass ___ret (ß matchSymbol(___s)))
            (when (some? ___ret)
                (§ return ___ret)
            )

            (throw (ß Util'runtimeException("Invalid token: " + ___s)))
        )
    )

    (§ defn- #_"Object" EdnReader'matchSymbol [#_"String" ___s]
        (let [#_"Matcher" ___m (ß symbolPat.matcher(___s))]
            (when (ß ___m.matches())
                (let [#_"int" ___gc (ß ___m.groupCount())]
                    (let [#_"String" ___ns (ß ___m.group(1))]
                        (let [#_"String" ___name (ß ___m.group(2))]
                            (when (ß ___ns != nil && ___ns.endsWith(":/") || ___name.endsWith(":") || ___s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß ___s.startsWith("::"))
                                (§ return nil)
                            )
                            (let [#_"boolean" ___isKeyword (ß ___s.charAt(0) == \:)]
                                (let [#_"Symbol" ___sym (ß Symbol'intern(___s.substring(___isKeyword ? 1 :or 0)))]
                                    (when ___isKeyword
                                        (§ return (ß Keyword'intern(___sym)))
                                    )
                                    (§ return ___sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (§ defn- #_"Object" EdnReader'matchNumber [#_"String" ___s]
        (let [#_"Matcher" ___m (ß intPat.matcher(___s))]
            (when (ß ___m.matches())
                (when (ß ___m.group(2) != nil)
                    (when (ß ___m.group(8) != nil)
                        (§ return (ß BigInt'ZERO))
                    )
                    (§ return (ß Numbers'num(0)))
                )
                (let [#_"boolean" ___negate (ß ___m.group(1).equals("-"))]
                    (§ let [#_"String" ___n]
                        (let [#_"int" ___radix 10]
                            (cond (some? (§ ass ___n (ß ___m.group(3))))
                                (do
                                    (§ ass ___radix 10)
                                )
                                (some? (§ ass ___n (ß ___m.group(4))))
                                (do
                                    (§ ass ___radix 16)
                                )
                                (some? (§ ass ___n (ß ___m.group(5))))
                                (do
                                    (§ ass ___radix 8)
                                )
                                (some? (§ ass ___n (ß ___m.group(7))))
                                (do
                                    (§ ass ___radix (ß Integer/parseInt(___m.group(6))))
                                )
                            )
                            (when (nil? ___n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" ___bn (ß new BigInteger(___n, ___radix))]
                                (when ___negate
                                    (§ ass ___bn (ß ___bn.negate()))
                                )
                                (when (ß ___m.group(8) != nil)
                                    (§ return (ß BigInt'fromBigInteger(___bn)))
                                )
                                (§ return (ß (___bn.bitLength() < 64) ? Numbers'num(___bn.longValue()) :or BigInt'fromBigInteger(___bn)))
                            )
                        )
                    )
                )
            )
            (§ ass ___m (ß floatPat.matcher(___s)))
            (when (ß ___m.matches())
                (when (ß ___m.group(4) != nil)
                    (§ return (ß new BigDecimal(___m.group(1))))
                )
                (§ return (ß Double/parseDouble(___s)))
            )
            (§ ass ___m (ß ratioPat.matcher(___s)))
            (when (ß ___m.matches())
                (let [#_"String" ___numerator (ß ___m.group(1))]
                    (when (ß ___numerator.startsWith("+"))
                        (§ ass ___numerator (ß ___numerator.substring(1)))
                    )

                    (§ return (ß Numbers'divide(Numbers'reduceBigInt(BigInt'fromBigInteger(new BigInteger(___numerator))), Numbers'reduceBigInt(BigInt'fromBigInteger(new BigInteger(___m.group(2)))))))
                )
            )
            nil
        )
    )

    (§ defn- #_"IFn" EdnReader'getMacro [#_"int" ___ch]
        (when (ß ___ch < macros.length)
            (§ return (ß macros[___ch]))
        )
        nil
    )

    (§ defn- #_"boolean" EdnReader'isMacro [#_"int" ___ch]
        (ß (___ch < macros.length && macros[___ch] != nil))
    )

    (§ defn- #_"boolean" EdnReader'isTerminatingMacro [#_"int" ___ch]
        (ß (___ch != \# && ___ch != \' && isMacro(___ch)))
    )

    (§ defn #_"List" EdnReader'readDelimitedList [#_"char" ___delim, #_"PushbackReader" ___r, #_"boolean" ___isRecursive, #_"Object" ___opts]
        (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) ___r).getLineNumber() :or -1)]
            (let [#_"ArrayList" ___a (ArrayList.)]
                (while true
                    (let [#_"int" ___ch (ß read1(___r))]
                        (while (ß isWhitespace(___ch))
                            (§ ass ___ch (ß read1(___r)))
                        )

                        (when (ß ___ch == -1)
                            (if (ß ___firstline < 0)
                                (do
                                    (throw (ß Util'runtimeException("EOF while reading")))
                                )
                                (do
                                    (throw (ß Util'runtimeException("EOF while reading, starting at line " + ___firstline)))
                                )
                            )
                        )

                        (when (ß ___ch == ___delim)
                            (§ break )
                        )

                        (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                            (if (some? ___macroFn)
                                (do
                                    (let [#_"Object" ___mret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts))]
                                        ;; no op macros return the reader
                                        (when (ß ___mret != ___r)
                                            (ß ___a.add(___mret))
                                        )
                                    )
                                )
                                (do
                                    (ß unread(___r, ___ch))

                                    (let [#_"Object" ___o (ß read(___r, true, nil, ___isRecursive, ___opts))]
                                        (when (ß ___o != ___r)
                                            (ß ___a.add(___o))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                a
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

(class-ns EnumerationSeqState
    (§ init
        #_volatile
        (§ field #_"Object" val nil)
        #_volatile
        (§ field #_"Object" _rest nil)
    )
)

(class-ns EnumerationSeq (§ extends ASeq)
    (§ defn #_"EnumerationSeq" EnumerationSeq'create [#_"Enumeration" ___iter]
        (when (ß ___iter.hasMoreElements())
            (§ return (EnumerationSeq. ___iter))
        )
        nil
    )

    (§ init
        (§ field #_"Enumeration" iter nil)
        (§ field #_"EnumerationSeqState" state nil)
    )

    (§ constructor #_"EnumerationSeq" EnumerationSeq [#_"Enumeration" ___iter]
        (let [this (ß super())]
            (§ ass (ß this.iter) ___iter)
            (§ ass state (EnumerationSeqState.))
            (§ ass (ß this.state.val) state)
            (§ ass (ß this.state._rest) state)
            this
        )
    )

    (§ constructor #_"EnumerationSeq" EnumerationSeq [#_"IPersistentMap" ___meta, #_"Enumeration" ___iter, #_"EnumerationSeqState" ___state]
        (let [this (ß super(___meta))]
            (§ ass (ß this.iter) ___iter)
            (§ ass (ß this.state) ___state)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"EnumerationSeq" this]
        (when (ß state.val == state)
            (§ sync state
                (when (ß state.val == state)
                    (§ ass (ß state.val) (ß iter.nextElement()))
                )
            )
        )
        (ß state.val)
    )

    #_method
    (§ defn #_"ISeq" next [#_"EnumerationSeq" this]
        (when (ß state._rest == state)
            (§ sync state
                (when (ß state._rest == state)
                    (ß first())
                    (§ ass (ß state._rest) (ß EnumerationSeq'create(iter)))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    #_method
    (§ defn #_"EnumerationSeq" withMeta [#_"EnumerationSeq" this, #_"IPersistentMap" ___meta]
        (ß new EnumerationSeq(___meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (§ init
        (§ field #_"IPersistentMap" data nil)
    )

    (§ constructor #_"ExceptionInfo" ExceptionInfo [#_"String" ___s, #_"IPersistentMap" ___data]
        (let [this (ß this(___s, ___data, nil))]
            this
        )
    )

    (§ constructor #_"ExceptionInfo" ExceptionInfo [#_"String" ___s, #_"IPersistentMap" ___data, #_"Throwable" ___throwable]
        (let [this (ß super())]
            ;; nil cause is equivalent to not passing a cause
            (§ super(___s, ___throwable))
            (if (some? ___data)
                (do
                    (§ ass (ß this.data) ___data)
                )
                (do
                    (throw (IllegalArgumentException. "Additional data must be non-nil."))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" getData [#_"ExceptionInfo" this]
        data
    )

    #_method
    (§ defn #_"String" toString [#_"ExceptionInfo" this]
        (ß "cloiure.lang.ExceptionInfo: " + getMessage() + " " + data.toString())
    )
)
)

(java-ns cloiure.lang.Fn

(defprotocol Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (§ init
        (§ field #_"Var" v nil)
        (§ field #_"ClassLoader" loader nil)
        (§ field #_"String" fnClassName nil)
        (§ field #_"IFn" fn nil)
    )

    (§ constructor #_"FnLoaderThunk" FnLoaderThunk [#_"Var" ___v, #_"String" ___fnClassName]
        (let [this (ß super())]
            (§ ass (ß this.v) ___v)
            (§ ass (ß this.loader) (ß (ClassLoader) RT'FN_LOADER_VAR.get()))
            (§ ass (ß this.fnClassName) ___fnClassName)
            (§ ass fn nil)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" ___arg1]
        (ß load())
        (ß fn.invoke(___arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß load())
        (ß fn.invoke(___arg1, ___arg2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß load())
        (ß fn.invoke(___arg1, ___arg2, ___arg3))
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"FnLoaderThunk" this, #_"Object" ___args]
        (ß load())
        (ß fn.applyTo((ISeq) ___args))
    )

    #_method
    (§ defn- #_"void" load [#_"FnLoaderThunk" this]
        (when (nil? fn)
            (try
                (§ ass fn (ß (IFn) Class/forName(fnClassName, true, loader).newInstance()))
                (catch Exception ___e
                    (throw (ß Util'sneakyThrow(___e)))
                )
            )
            (§ ass (ß v.root) fn)
        )
        nil
    )

    #_method
    (§ defn #_"int" getRequiredArity [#_"FnLoaderThunk" this]
        0
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"FnLoaderThunk" this, #_"IPersistentMap" ___meta]
        this
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"FnLoaderThunk" this]
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(defprotocol IAtom
    #_abstract
    (#_"Object" IAtom'''swap2 [#_"IAtom" this, #_"IFn" ___f])
    #_abstract
    (#_"Object" IAtom'''swap3 [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___arg])
    #_abstract
    (#_"Object" IAtom'''swap4 [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"Object" IAtom'''swap5 [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args])
    #_abstract
    (#_"boolean" IAtom'''compareAndSet [#_"IAtom" this, #_"Object" ___oldv, #_"Object" ___newv])
    #_abstract
    (#_"Object" IAtom'''reset [#_"IAtom" this, #_"Object" ___newval])
)
)

(java-ns cloiure.lang.IAtom2

(defprotocol IAtom2 #_(§ extends IAtom)
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals2 [#_"IAtom2" this, #_"IFn" ___f])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals3 [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___arg])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals4 [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals5 [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args])
    #_abstract
    (#_"IPersistentVector" IAtom2'''resetVals [#_"IAtom2" this, #_"Object" ___newv])
)
)

(java-ns cloiure.lang.IBlockingDeref

(defprotocol IBlockingDeref
    #_abstract
    (#_"Object" IBlockingDeref'''deref [#_"IBlockingDeref" this, #_"long" ___ms, #_"Object" ___timeoutValue])
)
)

(java-ns cloiure.lang.IChunk

(defprotocol IChunk #_(§ extends Indexed)
    #_abstract
    (#_"IChunk" IChunk'''dropFirst [#_"IChunk" this])
    #_abstract
    (#_"Object" IChunk'''reduce [#_"IChunk" this, #_"IFn" ___f, #_"Object" ___start])
)
)

(java-ns cloiure.lang.IChunkedSeq

(defprotocol IChunkedSeq #_(§ extends ISeq, Sequential)
    #_abstract
    (#_"IChunk" IChunkedSeq'''chunkedFirst [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''chunkedNext [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''chunkedMore [#_"IChunkedSeq" this])
)
)

(java-ns cloiure.lang.IDeref

(defprotocol IDeref
    #_abstract
    (#_"Object" IDeref'''deref [#_"IDeref" this])
)
)

(java-ns cloiure.lang.IEditableCollection

(defprotocol IEditableCollection
    #_abstract
    (#_"ITransientCollection" IEditableCollection'''asTransient [#_"IEditableCollection" this])
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(defprotocol IExceptionInfo
    #_abstract
    (#_"IPersistentMap" IExceptionInfo'''getData [#_"IExceptionInfo" this])
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

(defprotocol L
    #_abstract
    (#_"long" L'''invokePrim [#_"L" this])
)

(defprotocol D
    #_abstract
    (#_"double" D'''invokePrim [#_"D" this])
)

(defprotocol OL
    #_abstract
    (#_"long" OL'''invokePrim [#_"OL" this, #_"Object" ___arg0])
)

(defprotocol OD
    #_abstract
    (#_"double" OD'''invokePrim [#_"OD" this, #_"Object" ___arg0])
)

(defprotocol LO
    #_abstract
    (#_"Object" LO'''invokePrim [#_"LO" this, #_"long" ___arg0])
)

(defprotocol LL
    #_abstract
    (#_"long" LL'''invokePrim [#_"LL" this, #_"long" ___arg0])
)

(defprotocol LD
    #_abstract
    (#_"double" LD'''invokePrim [#_"LD" this, #_"long" ___arg0])
)

(defprotocol DO
    #_abstract
    (#_"Object" DO'''invokePrim [#_"DO" this, #_"double" ___arg0])
)

(defprotocol DL
    #_abstract
    (#_"long" DL'''invokePrim [#_"DL" this, #_"double" ___arg0])
)

(defprotocol DD
    #_abstract
    (#_"double" DD'''invokePrim [#_"DD" this, #_"double" ___arg0])
)

(defprotocol OOL
    #_abstract
    (#_"long" OOL'''invokePrim [#_"OOL" this, #_"Object" ___arg0, #_"Object" ___arg1])
)

(defprotocol OOD
    #_abstract
    (#_"double" OOD'''invokePrim [#_"OOD" this, #_"Object" ___arg0, #_"Object" ___arg1])
)

(defprotocol OLO
    #_abstract
    (#_"Object" OLO'''invokePrim [#_"OLO" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(defprotocol OLL
    #_abstract
    (#_"long" OLL'''invokePrim [#_"OLL" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(defprotocol OLD
    #_abstract
    (#_"double" OLD'''invokePrim [#_"OLD" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(defprotocol ODO
    #_abstract
    (#_"Object" ODO'''invokePrim [#_"ODO" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(defprotocol ODL
    #_abstract
    (#_"long" ODL'''invokePrim [#_"ODL" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(defprotocol ODD
    #_abstract
    (#_"double" ODD'''invokePrim [#_"ODD" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(defprotocol LOO
    #_abstract
    (#_"Object" LOO'''invokePrim [#_"LOO" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(defprotocol LOL
    #_abstract
    (#_"long" LOL'''invokePrim [#_"LOL" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(defprotocol LOD
    #_abstract
    (#_"double" LOD'''invokePrim [#_"LOD" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(defprotocol LLO
    #_abstract
    (#_"Object" LLO'''invokePrim [#_"LLO" this, #_"long" ___arg0, #_"long" ___arg1])
)

(defprotocol LLL
    #_abstract
    (#_"long" LLL'''invokePrim [#_"LLL" this, #_"long" ___arg0, #_"long" ___arg1])
)

(defprotocol LLD
    #_abstract
    (#_"double" LLD'''invokePrim [#_"LLD" this, #_"long" ___arg0, #_"long" ___arg1])
)

(defprotocol LDO
    #_abstract
    (#_"Object" LDO'''invokePrim [#_"LDO" this, #_"long" ___arg0, #_"double" ___arg1])
)

(defprotocol LDL
    #_abstract
    (#_"long" LDL'''invokePrim [#_"LDL" this, #_"long" ___arg0, #_"double" ___arg1])
)

(defprotocol LDD
    #_abstract
    (#_"double" LDD'''invokePrim [#_"LDD" this, #_"long" ___arg0, #_"double" ___arg1])
)

(defprotocol DOO
    #_abstract
    (#_"Object" DOO'''invokePrim [#_"DOO" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(defprotocol DOL
    #_abstract
    (#_"long" DOL'''invokePrim [#_"DOL" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(defprotocol DOD
    #_abstract
    (#_"double" DOD'''invokePrim [#_"DOD" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(defprotocol DLO
    #_abstract
    (#_"Object" DLO'''invokePrim [#_"DLO" this, #_"double" ___arg0, #_"long" ___arg1])
)

(defprotocol DLL
    #_abstract
    (#_"long" DLL'''invokePrim [#_"DLL" this, #_"double" ___arg0, #_"long" ___arg1])
)

(defprotocol DLD
    #_abstract
    (#_"double" DLD'''invokePrim [#_"DLD" this, #_"double" ___arg0, #_"long" ___arg1])
)

(defprotocol DDO
    #_abstract
    (#_"Object" DDO'''invokePrim [#_"DDO" this, #_"double" ___arg0, #_"double" ___arg1])
)

(defprotocol DDL
    #_abstract
    (#_"long" DDL'''invokePrim [#_"DDL" this, #_"double" ___arg0, #_"double" ___arg1])
)

(defprotocol DDD
    #_abstract
    (#_"double" DDD'''invokePrim [#_"DDD" this, #_"double" ___arg0, #_"double" ___arg1])
)

(defprotocol OOOL
    #_abstract
    (#_"long" OOOL'''invokePrim [#_"OOOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol OOOD
    #_abstract
    (#_"double" OOOD'''invokePrim [#_"OOOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol OOLO
    #_abstract
    (#_"Object" OOLO'''invokePrim [#_"OOLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol OOLL
    #_abstract
    (#_"long" OOLL'''invokePrim [#_"OOLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol OOLD
    #_abstract
    (#_"double" OOLD'''invokePrim [#_"OOLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol OODO
    #_abstract
    (#_"Object" OODO'''invokePrim [#_"OODO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol OODL
    #_abstract
    (#_"long" OODL'''invokePrim [#_"OODL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol OODD
    #_abstract
    (#_"double" OODD'''invokePrim [#_"OODD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol OLOO
    #_abstract
    (#_"Object" OLOO'''invokePrim [#_"OLOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol OLOL
    #_abstract
    (#_"long" OLOL'''invokePrim [#_"OLOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol OLOD
    #_abstract
    (#_"double" OLOD'''invokePrim [#_"OLOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol OLLO
    #_abstract
    (#_"Object" OLLO'''invokePrim [#_"OLLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol OLLL
    #_abstract
    (#_"long" OLLL'''invokePrim [#_"OLLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol OLLD
    #_abstract
    (#_"double" OLLD'''invokePrim [#_"OLLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol OLDO
    #_abstract
    (#_"Object" OLDO'''invokePrim [#_"OLDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol OLDL
    #_abstract
    (#_"long" OLDL'''invokePrim [#_"OLDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol OLDD
    #_abstract
    (#_"double" OLDD'''invokePrim [#_"OLDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol ODOO
    #_abstract
    (#_"Object" ODOO'''invokePrim [#_"ODOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol ODOL
    #_abstract
    (#_"long" ODOL'''invokePrim [#_"ODOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol ODOD
    #_abstract
    (#_"double" ODOD'''invokePrim [#_"ODOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol ODLO
    #_abstract
    (#_"Object" ODLO'''invokePrim [#_"ODLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol ODLL
    #_abstract
    (#_"long" ODLL'''invokePrim [#_"ODLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol ODLD
    #_abstract
    (#_"double" ODLD'''invokePrim [#_"ODLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol ODDO
    #_abstract
    (#_"Object" ODDO'''invokePrim [#_"ODDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol ODDL
    #_abstract
    (#_"long" ODDL'''invokePrim [#_"ODDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol ODDD
    #_abstract
    (#_"double" ODDD'''invokePrim [#_"ODDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol LOOO
    #_abstract
    (#_"Object" LOOO'''invokePrim [#_"LOOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol LOOL
    #_abstract
    (#_"long" LOOL'''invokePrim [#_"LOOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol LOOD
    #_abstract
    (#_"double" LOOD'''invokePrim [#_"LOOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol LOLO
    #_abstract
    (#_"Object" LOLO'''invokePrim [#_"LOLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol LOLL
    #_abstract
    (#_"long" LOLL'''invokePrim [#_"LOLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol LOLD
    #_abstract
    (#_"double" LOLD'''invokePrim [#_"LOLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol LODO
    #_abstract
    (#_"Object" LODO'''invokePrim [#_"LODO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol LODL
    #_abstract
    (#_"long" LODL'''invokePrim [#_"LODL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol LODD
    #_abstract
    (#_"double" LODD'''invokePrim [#_"LODD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol LLOO
    #_abstract
    (#_"Object" LLOO'''invokePrim [#_"LLOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol LLOL
    #_abstract
    (#_"long" LLOL'''invokePrim [#_"LLOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol LLOD
    #_abstract
    (#_"double" LLOD'''invokePrim [#_"LLOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol LLLO
    #_abstract
    (#_"Object" LLLO'''invokePrim [#_"LLLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol LLLL
    #_abstract
    (#_"long" LLLL'''invokePrim [#_"LLLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol LLLD
    #_abstract
    (#_"double" LLLD'''invokePrim [#_"LLLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol LLDO
    #_abstract
    (#_"Object" LLDO'''invokePrim [#_"LLDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol LLDL
    #_abstract
    (#_"long" LLDL'''invokePrim [#_"LLDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol LLDD
    #_abstract
    (#_"double" LLDD'''invokePrim [#_"LLDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol LDOO
    #_abstract
    (#_"Object" LDOO'''invokePrim [#_"LDOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol LDOL
    #_abstract
    (#_"long" LDOL'''invokePrim [#_"LDOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol LDOD
    #_abstract
    (#_"double" LDOD'''invokePrim [#_"LDOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol LDLO
    #_abstract
    (#_"Object" LDLO'''invokePrim [#_"LDLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol LDLL
    #_abstract
    (#_"long" LDLL'''invokePrim [#_"LDLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol LDLD
    #_abstract
    (#_"double" LDLD'''invokePrim [#_"LDLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol LDDO
    #_abstract
    (#_"Object" LDDO'''invokePrim [#_"LDDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol LDDL
    #_abstract
    (#_"long" LDDL'''invokePrim [#_"LDDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol LDDD
    #_abstract
    (#_"double" LDDD'''invokePrim [#_"LDDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol DOOO
    #_abstract
    (#_"Object" DOOO'''invokePrim [#_"DOOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol DOOL
    #_abstract
    (#_"long" DOOL'''invokePrim [#_"DOOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol DOOD
    #_abstract
    (#_"double" DOOD'''invokePrim [#_"DOOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol DOLO
    #_abstract
    (#_"Object" DOLO'''invokePrim [#_"DOLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol DOLL
    #_abstract
    (#_"long" DOLL'''invokePrim [#_"DOLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol DOLD
    #_abstract
    (#_"double" DOLD'''invokePrim [#_"DOLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol DODO
    #_abstract
    (#_"Object" DODO'''invokePrim [#_"DODO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol DODL
    #_abstract
    (#_"long" DODL'''invokePrim [#_"DODL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol DODD
    #_abstract
    (#_"double" DODD'''invokePrim [#_"DODD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol DLOO
    #_abstract
    (#_"Object" DLOO'''invokePrim [#_"DLOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol DLOL
    #_abstract
    (#_"long" DLOL'''invokePrim [#_"DLOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol DLOD
    #_abstract
    (#_"double" DLOD'''invokePrim [#_"DLOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol DLLO
    #_abstract
    (#_"Object" DLLO'''invokePrim [#_"DLLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol DLLL
    #_abstract
    (#_"long" DLLL'''invokePrim [#_"DLLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol DLLD
    #_abstract
    (#_"double" DLLD'''invokePrim [#_"DLLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol DLDO
    #_abstract
    (#_"Object" DLDO'''invokePrim [#_"DLDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol DLDL
    #_abstract
    (#_"long" DLDL'''invokePrim [#_"DLDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol DLDD
    #_abstract
    (#_"double" DLDD'''invokePrim [#_"DLDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol DDOO
    #_abstract
    (#_"Object" DDOO'''invokePrim [#_"DDOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol DDOL
    #_abstract
    (#_"long" DDOL'''invokePrim [#_"DDOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol DDOD
    #_abstract
    (#_"double" DDOD'''invokePrim [#_"DDOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol DDLO
    #_abstract
    (#_"Object" DDLO'''invokePrim [#_"DDLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol DDLL
    #_abstract
    (#_"long" DDLL'''invokePrim [#_"DDLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol DDLD
    #_abstract
    (#_"double" DDLD'''invokePrim [#_"DDLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol DDDO
    #_abstract
    (#_"Object" DDDO'''invokePrim [#_"DDDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol DDDL
    #_abstract
    (#_"long" DDDL'''invokePrim [#_"DDDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol DDDD
    #_abstract
    (#_"double" DDDD'''invokePrim [#_"DDDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol OOOOL
    #_abstract
    (#_"long" OOOOL'''invokePrim [#_"OOOOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOOOD
    #_abstract
    (#_"double" OOOOD'''invokePrim [#_"OOOOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOOLO
    #_abstract
    (#_"Object" OOOLO'''invokePrim [#_"OOOLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OOOLL
    #_abstract
    (#_"long" OOOLL'''invokePrim [#_"OOOLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OOOLD
    #_abstract
    (#_"double" OOOLD'''invokePrim [#_"OOOLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OOODO
    #_abstract
    (#_"Object" OOODO'''invokePrim [#_"OOODO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OOODL
    #_abstract
    (#_"long" OOODL'''invokePrim [#_"OOODL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OOODD
    #_abstract
    (#_"double" OOODD'''invokePrim [#_"OOODD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OOLOO
    #_abstract
    (#_"Object" OOLOO'''invokePrim [#_"OOLOO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOLOL
    #_abstract
    (#_"long" OOLOL'''invokePrim [#_"OOLOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOLOD
    #_abstract
    (#_"double" OOLOD'''invokePrim [#_"OOLOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOLLO
    #_abstract
    (#_"Object" OOLLO'''invokePrim [#_"OOLLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OOLLL
    #_abstract
    (#_"long" OOLLL'''invokePrim [#_"OOLLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OOLLD
    #_abstract
    (#_"double" OOLLD'''invokePrim [#_"OOLLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OOLDO
    #_abstract
    (#_"Object" OOLDO'''invokePrim [#_"OOLDO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OOLDL
    #_abstract
    (#_"long" OOLDL'''invokePrim [#_"OOLDL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OOLDD
    #_abstract
    (#_"double" OOLDD'''invokePrim [#_"OOLDD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OODOO
    #_abstract
    (#_"Object" OODOO'''invokePrim [#_"OODOO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OODOL
    #_abstract
    (#_"long" OODOL'''invokePrim [#_"OODOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OODOD
    #_abstract
    (#_"double" OODOD'''invokePrim [#_"OODOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OODLO
    #_abstract
    (#_"Object" OODLO'''invokePrim [#_"OODLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OODLL
    #_abstract
    (#_"long" OODLL'''invokePrim [#_"OODLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OODLD
    #_abstract
    (#_"double" OODLD'''invokePrim [#_"OODLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OODDO
    #_abstract
    (#_"Object" OODDO'''invokePrim [#_"OODDO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OODDL
    #_abstract
    (#_"long" OODDL'''invokePrim [#_"OODDL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OODDD
    #_abstract
    (#_"double" OODDD'''invokePrim [#_"OODDD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OLOOO
    #_abstract
    (#_"Object" OLOOO'''invokePrim [#_"OLOOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLOOL
    #_abstract
    (#_"long" OLOOL'''invokePrim [#_"OLOOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLOOD
    #_abstract
    (#_"double" OLOOD'''invokePrim [#_"OLOOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLOLO
    #_abstract
    (#_"Object" OLOLO'''invokePrim [#_"OLOLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OLOLL
    #_abstract
    (#_"long" OLOLL'''invokePrim [#_"OLOLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OLOLD
    #_abstract
    (#_"double" OLOLD'''invokePrim [#_"OLOLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OLODO
    #_abstract
    (#_"Object" OLODO'''invokePrim [#_"OLODO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OLODL
    #_abstract
    (#_"long" OLODL'''invokePrim [#_"OLODL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OLODD
    #_abstract
    (#_"double" OLODD'''invokePrim [#_"OLODD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OLLOO
    #_abstract
    (#_"Object" OLLOO'''invokePrim [#_"OLLOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLLOL
    #_abstract
    (#_"long" OLLOL'''invokePrim [#_"OLLOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLLOD
    #_abstract
    (#_"double" OLLOD'''invokePrim [#_"OLLOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLLLO
    #_abstract
    (#_"Object" OLLLO'''invokePrim [#_"OLLLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OLLLL
    #_abstract
    (#_"long" OLLLL'''invokePrim [#_"OLLLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OLLLD
    #_abstract
    (#_"double" OLLLD'''invokePrim [#_"OLLLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OLLDO
    #_abstract
    (#_"Object" OLLDO'''invokePrim [#_"OLLDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OLLDL
    #_abstract
    (#_"long" OLLDL'''invokePrim [#_"OLLDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OLLDD
    #_abstract
    (#_"double" OLLDD'''invokePrim [#_"OLLDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OLDOO
    #_abstract
    (#_"Object" OLDOO'''invokePrim [#_"OLDOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLDOL
    #_abstract
    (#_"long" OLDOL'''invokePrim [#_"OLDOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLDOD
    #_abstract
    (#_"double" OLDOD'''invokePrim [#_"OLDOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLDLO
    #_abstract
    (#_"Object" OLDLO'''invokePrim [#_"OLDLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OLDLL
    #_abstract
    (#_"long" OLDLL'''invokePrim [#_"OLDLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OLDLD
    #_abstract
    (#_"double" OLDLD'''invokePrim [#_"OLDLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OLDDO
    #_abstract
    (#_"Object" OLDDO'''invokePrim [#_"OLDDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OLDDL
    #_abstract
    (#_"long" OLDDL'''invokePrim [#_"OLDDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OLDDD
    #_abstract
    (#_"double" OLDDD'''invokePrim [#_"OLDDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol ODOOO
    #_abstract
    (#_"Object" ODOOO'''invokePrim [#_"ODOOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODOOL
    #_abstract
    (#_"long" ODOOL'''invokePrim [#_"ODOOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODOOD
    #_abstract
    (#_"double" ODOOD'''invokePrim [#_"ODOOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODOLO
    #_abstract
    (#_"Object" ODOLO'''invokePrim [#_"ODOLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol ODOLL
    #_abstract
    (#_"long" ODOLL'''invokePrim [#_"ODOLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol ODOLD
    #_abstract
    (#_"double" ODOLD'''invokePrim [#_"ODOLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol ODODO
    #_abstract
    (#_"Object" ODODO'''invokePrim [#_"ODODO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol ODODL
    #_abstract
    (#_"long" ODODL'''invokePrim [#_"ODODL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol ODODD
    #_abstract
    (#_"double" ODODD'''invokePrim [#_"ODODD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol ODLOO
    #_abstract
    (#_"Object" ODLOO'''invokePrim [#_"ODLOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODLOL
    #_abstract
    (#_"long" ODLOL'''invokePrim [#_"ODLOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODLOD
    #_abstract
    (#_"double" ODLOD'''invokePrim [#_"ODLOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODLLO
    #_abstract
    (#_"Object" ODLLO'''invokePrim [#_"ODLLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol ODLLL
    #_abstract
    (#_"long" ODLLL'''invokePrim [#_"ODLLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol ODLLD
    #_abstract
    (#_"double" ODLLD'''invokePrim [#_"ODLLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol ODLDO
    #_abstract
    (#_"Object" ODLDO'''invokePrim [#_"ODLDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol ODLDL
    #_abstract
    (#_"long" ODLDL'''invokePrim [#_"ODLDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol ODLDD
    #_abstract
    (#_"double" ODLDD'''invokePrim [#_"ODLDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol ODDOO
    #_abstract
    (#_"Object" ODDOO'''invokePrim [#_"ODDOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODDOL
    #_abstract
    (#_"long" ODDOL'''invokePrim [#_"ODDOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODDOD
    #_abstract
    (#_"double" ODDOD'''invokePrim [#_"ODDOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODDLO
    #_abstract
    (#_"Object" ODDLO'''invokePrim [#_"ODDLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol ODDLL
    #_abstract
    (#_"long" ODDLL'''invokePrim [#_"ODDLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol ODDLD
    #_abstract
    (#_"double" ODDLD'''invokePrim [#_"ODDLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol ODDDO
    #_abstract
    (#_"Object" ODDDO'''invokePrim [#_"ODDDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol ODDDL
    #_abstract
    (#_"long" ODDDL'''invokePrim [#_"ODDDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol ODDDD
    #_abstract
    (#_"double" ODDDD'''invokePrim [#_"ODDDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LOOOO
    #_abstract
    (#_"Object" LOOOO'''invokePrim [#_"LOOOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOOOL
    #_abstract
    (#_"long" LOOOL'''invokePrim [#_"LOOOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOOOD
    #_abstract
    (#_"double" LOOOD'''invokePrim [#_"LOOOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOOLO
    #_abstract
    (#_"Object" LOOLO'''invokePrim [#_"LOOLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LOOLL
    #_abstract
    (#_"long" LOOLL'''invokePrim [#_"LOOLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LOOLD
    #_abstract
    (#_"double" LOOLD'''invokePrim [#_"LOOLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LOODO
    #_abstract
    (#_"Object" LOODO'''invokePrim [#_"LOODO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LOODL
    #_abstract
    (#_"long" LOODL'''invokePrim [#_"LOODL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LOODD
    #_abstract
    (#_"double" LOODD'''invokePrim [#_"LOODD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LOLOO
    #_abstract
    (#_"Object" LOLOO'''invokePrim [#_"LOLOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOLOL
    #_abstract
    (#_"long" LOLOL'''invokePrim [#_"LOLOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOLOD
    #_abstract
    (#_"double" LOLOD'''invokePrim [#_"LOLOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOLLO
    #_abstract
    (#_"Object" LOLLO'''invokePrim [#_"LOLLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LOLLL
    #_abstract
    (#_"long" LOLLL'''invokePrim [#_"LOLLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LOLLD
    #_abstract
    (#_"double" LOLLD'''invokePrim [#_"LOLLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LOLDO
    #_abstract
    (#_"Object" LOLDO'''invokePrim [#_"LOLDO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LOLDL
    #_abstract
    (#_"long" LOLDL'''invokePrim [#_"LOLDL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LOLDD
    #_abstract
    (#_"double" LOLDD'''invokePrim [#_"LOLDD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LODOO
    #_abstract
    (#_"Object" LODOO'''invokePrim [#_"LODOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LODOL
    #_abstract
    (#_"long" LODOL'''invokePrim [#_"LODOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LODOD
    #_abstract
    (#_"double" LODOD'''invokePrim [#_"LODOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LODLO
    #_abstract
    (#_"Object" LODLO'''invokePrim [#_"LODLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LODLL
    #_abstract
    (#_"long" LODLL'''invokePrim [#_"LODLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LODLD
    #_abstract
    (#_"double" LODLD'''invokePrim [#_"LODLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LODDO
    #_abstract
    (#_"Object" LODDO'''invokePrim [#_"LODDO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LODDL
    #_abstract
    (#_"long" LODDL'''invokePrim [#_"LODDL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LODDD
    #_abstract
    (#_"double" LODDD'''invokePrim [#_"LODDD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LLOOO
    #_abstract
    (#_"Object" LLOOO'''invokePrim [#_"LLOOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLOOL
    #_abstract
    (#_"long" LLOOL'''invokePrim [#_"LLOOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLOOD
    #_abstract
    (#_"double" LLOOD'''invokePrim [#_"LLOOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLOLO
    #_abstract
    (#_"Object" LLOLO'''invokePrim [#_"LLOLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LLOLL
    #_abstract
    (#_"long" LLOLL'''invokePrim [#_"LLOLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LLOLD
    #_abstract
    (#_"double" LLOLD'''invokePrim [#_"LLOLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LLODO
    #_abstract
    (#_"Object" LLODO'''invokePrim [#_"LLODO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LLODL
    #_abstract
    (#_"long" LLODL'''invokePrim [#_"LLODL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LLODD
    #_abstract
    (#_"double" LLODD'''invokePrim [#_"LLODD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LLLOO
    #_abstract
    (#_"Object" LLLOO'''invokePrim [#_"LLLOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLLOL
    #_abstract
    (#_"long" LLLOL'''invokePrim [#_"LLLOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLLOD
    #_abstract
    (#_"double" LLLOD'''invokePrim [#_"LLLOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLLLO
    #_abstract
    (#_"Object" LLLLO'''invokePrim [#_"LLLLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LLLLL
    #_abstract
    (#_"long" LLLLL'''invokePrim [#_"LLLLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LLLLD
    #_abstract
    (#_"double" LLLLD'''invokePrim [#_"LLLLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LLLDO
    #_abstract
    (#_"Object" LLLDO'''invokePrim [#_"LLLDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LLLDL
    #_abstract
    (#_"long" LLLDL'''invokePrim [#_"LLLDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LLLDD
    #_abstract
    (#_"double" LLLDD'''invokePrim [#_"LLLDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LLDOO
    #_abstract
    (#_"Object" LLDOO'''invokePrim [#_"LLDOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLDOL
    #_abstract
    (#_"long" LLDOL'''invokePrim [#_"LLDOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLDOD
    #_abstract
    (#_"double" LLDOD'''invokePrim [#_"LLDOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLDLO
    #_abstract
    (#_"Object" LLDLO'''invokePrim [#_"LLDLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LLDLL
    #_abstract
    (#_"long" LLDLL'''invokePrim [#_"LLDLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LLDLD
    #_abstract
    (#_"double" LLDLD'''invokePrim [#_"LLDLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LLDDO
    #_abstract
    (#_"Object" LLDDO'''invokePrim [#_"LLDDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LLDDL
    #_abstract
    (#_"long" LLDDL'''invokePrim [#_"LLDDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LLDDD
    #_abstract
    (#_"double" LLDDD'''invokePrim [#_"LLDDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LDOOO
    #_abstract
    (#_"Object" LDOOO'''invokePrim [#_"LDOOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDOOL
    #_abstract
    (#_"long" LDOOL'''invokePrim [#_"LDOOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDOOD
    #_abstract
    (#_"double" LDOOD'''invokePrim [#_"LDOOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDOLO
    #_abstract
    (#_"Object" LDOLO'''invokePrim [#_"LDOLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LDOLL
    #_abstract
    (#_"long" LDOLL'''invokePrim [#_"LDOLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LDOLD
    #_abstract
    (#_"double" LDOLD'''invokePrim [#_"LDOLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LDODO
    #_abstract
    (#_"Object" LDODO'''invokePrim [#_"LDODO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LDODL
    #_abstract
    (#_"long" LDODL'''invokePrim [#_"LDODL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LDODD
    #_abstract
    (#_"double" LDODD'''invokePrim [#_"LDODD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LDLOO
    #_abstract
    (#_"Object" LDLOO'''invokePrim [#_"LDLOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDLOL
    #_abstract
    (#_"long" LDLOL'''invokePrim [#_"LDLOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDLOD
    #_abstract
    (#_"double" LDLOD'''invokePrim [#_"LDLOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDLLO
    #_abstract
    (#_"Object" LDLLO'''invokePrim [#_"LDLLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LDLLL
    #_abstract
    (#_"long" LDLLL'''invokePrim [#_"LDLLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LDLLD
    #_abstract
    (#_"double" LDLLD'''invokePrim [#_"LDLLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LDLDO
    #_abstract
    (#_"Object" LDLDO'''invokePrim [#_"LDLDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LDLDL
    #_abstract
    (#_"long" LDLDL'''invokePrim [#_"LDLDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LDLDD
    #_abstract
    (#_"double" LDLDD'''invokePrim [#_"LDLDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LDDOO
    #_abstract
    (#_"Object" LDDOO'''invokePrim [#_"LDDOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDDOL
    #_abstract
    (#_"long" LDDOL'''invokePrim [#_"LDDOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDDOD
    #_abstract
    (#_"double" LDDOD'''invokePrim [#_"LDDOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDDLO
    #_abstract
    (#_"Object" LDDLO'''invokePrim [#_"LDDLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LDDLL
    #_abstract
    (#_"long" LDDLL'''invokePrim [#_"LDDLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LDDLD
    #_abstract
    (#_"double" LDDLD'''invokePrim [#_"LDDLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LDDDO
    #_abstract
    (#_"Object" LDDDO'''invokePrim [#_"LDDDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LDDDL
    #_abstract
    (#_"long" LDDDL'''invokePrim [#_"LDDDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LDDDD
    #_abstract
    (#_"double" LDDDD'''invokePrim [#_"LDDDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DOOOO
    #_abstract
    (#_"Object" DOOOO'''invokePrim [#_"DOOOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOOOL
    #_abstract
    (#_"long" DOOOL'''invokePrim [#_"DOOOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOOOD
    #_abstract
    (#_"double" DOOOD'''invokePrim [#_"DOOOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOOLO
    #_abstract
    (#_"Object" DOOLO'''invokePrim [#_"DOOLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DOOLL
    #_abstract
    (#_"long" DOOLL'''invokePrim [#_"DOOLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DOOLD
    #_abstract
    (#_"double" DOOLD'''invokePrim [#_"DOOLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DOODO
    #_abstract
    (#_"Object" DOODO'''invokePrim [#_"DOODO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DOODL
    #_abstract
    (#_"long" DOODL'''invokePrim [#_"DOODL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DOODD
    #_abstract
    (#_"double" DOODD'''invokePrim [#_"DOODD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DOLOO
    #_abstract
    (#_"Object" DOLOO'''invokePrim [#_"DOLOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOLOL
    #_abstract
    (#_"long" DOLOL'''invokePrim [#_"DOLOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOLOD
    #_abstract
    (#_"double" DOLOD'''invokePrim [#_"DOLOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOLLO
    #_abstract
    (#_"Object" DOLLO'''invokePrim [#_"DOLLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DOLLL
    #_abstract
    (#_"long" DOLLL'''invokePrim [#_"DOLLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DOLLD
    #_abstract
    (#_"double" DOLLD'''invokePrim [#_"DOLLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DOLDO
    #_abstract
    (#_"Object" DOLDO'''invokePrim [#_"DOLDO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DOLDL
    #_abstract
    (#_"long" DOLDL'''invokePrim [#_"DOLDL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DOLDD
    #_abstract
    (#_"double" DOLDD'''invokePrim [#_"DOLDD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DODOO
    #_abstract
    (#_"Object" DODOO'''invokePrim [#_"DODOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DODOL
    #_abstract
    (#_"long" DODOL'''invokePrim [#_"DODOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DODOD
    #_abstract
    (#_"double" DODOD'''invokePrim [#_"DODOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DODLO
    #_abstract
    (#_"Object" DODLO'''invokePrim [#_"DODLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DODLL
    #_abstract
    (#_"long" DODLL'''invokePrim [#_"DODLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DODLD
    #_abstract
    (#_"double" DODLD'''invokePrim [#_"DODLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DODDO
    #_abstract
    (#_"Object" DODDO'''invokePrim [#_"DODDO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DODDL
    #_abstract
    (#_"long" DODDL'''invokePrim [#_"DODDL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DODDD
    #_abstract
    (#_"double" DODDD'''invokePrim [#_"DODDD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DLOOO
    #_abstract
    (#_"Object" DLOOO'''invokePrim [#_"DLOOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLOOL
    #_abstract
    (#_"long" DLOOL'''invokePrim [#_"DLOOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLOOD
    #_abstract
    (#_"double" DLOOD'''invokePrim [#_"DLOOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLOLO
    #_abstract
    (#_"Object" DLOLO'''invokePrim [#_"DLOLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DLOLL
    #_abstract
    (#_"long" DLOLL'''invokePrim [#_"DLOLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DLOLD
    #_abstract
    (#_"double" DLOLD'''invokePrim [#_"DLOLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DLODO
    #_abstract
    (#_"Object" DLODO'''invokePrim [#_"DLODO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DLODL
    #_abstract
    (#_"long" DLODL'''invokePrim [#_"DLODL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DLODD
    #_abstract
    (#_"double" DLODD'''invokePrim [#_"DLODD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DLLOO
    #_abstract
    (#_"Object" DLLOO'''invokePrim [#_"DLLOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLLOL
    #_abstract
    (#_"long" DLLOL'''invokePrim [#_"DLLOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLLOD
    #_abstract
    (#_"double" DLLOD'''invokePrim [#_"DLLOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLLLO
    #_abstract
    (#_"Object" DLLLO'''invokePrim [#_"DLLLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DLLLL
    #_abstract
    (#_"long" DLLLL'''invokePrim [#_"DLLLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DLLLD
    #_abstract
    (#_"double" DLLLD'''invokePrim [#_"DLLLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DLLDO
    #_abstract
    (#_"Object" DLLDO'''invokePrim [#_"DLLDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DLLDL
    #_abstract
    (#_"long" DLLDL'''invokePrim [#_"DLLDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DLLDD
    #_abstract
    (#_"double" DLLDD'''invokePrim [#_"DLLDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DLDOO
    #_abstract
    (#_"Object" DLDOO'''invokePrim [#_"DLDOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLDOL
    #_abstract
    (#_"long" DLDOL'''invokePrim [#_"DLDOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLDOD
    #_abstract
    (#_"double" DLDOD'''invokePrim [#_"DLDOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLDLO
    #_abstract
    (#_"Object" DLDLO'''invokePrim [#_"DLDLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DLDLL
    #_abstract
    (#_"long" DLDLL'''invokePrim [#_"DLDLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DLDLD
    #_abstract
    (#_"double" DLDLD'''invokePrim [#_"DLDLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DLDDO
    #_abstract
    (#_"Object" DLDDO'''invokePrim [#_"DLDDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DLDDL
    #_abstract
    (#_"long" DLDDL'''invokePrim [#_"DLDDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DLDDD
    #_abstract
    (#_"double" DLDDD'''invokePrim [#_"DLDDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DDOOO
    #_abstract
    (#_"Object" DDOOO'''invokePrim [#_"DDOOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDOOL
    #_abstract
    (#_"long" DDOOL'''invokePrim [#_"DDOOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDOOD
    #_abstract
    (#_"double" DDOOD'''invokePrim [#_"DDOOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDOLO
    #_abstract
    (#_"Object" DDOLO'''invokePrim [#_"DDOLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DDOLL
    #_abstract
    (#_"long" DDOLL'''invokePrim [#_"DDOLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DDOLD
    #_abstract
    (#_"double" DDOLD'''invokePrim [#_"DDOLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DDODO
    #_abstract
    (#_"Object" DDODO'''invokePrim [#_"DDODO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DDODL
    #_abstract
    (#_"long" DDODL'''invokePrim [#_"DDODL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DDODD
    #_abstract
    (#_"double" DDODD'''invokePrim [#_"DDODD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DDLOO
    #_abstract
    (#_"Object" DDLOO'''invokePrim [#_"DDLOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDLOL
    #_abstract
    (#_"long" DDLOL'''invokePrim [#_"DDLOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDLOD
    #_abstract
    (#_"double" DDLOD'''invokePrim [#_"DDLOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDLLO
    #_abstract
    (#_"Object" DDLLO'''invokePrim [#_"DDLLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DDLLL
    #_abstract
    (#_"long" DDLLL'''invokePrim [#_"DDLLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DDLLD
    #_abstract
    (#_"double" DDLLD'''invokePrim [#_"DDLLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DDLDO
    #_abstract
    (#_"Object" DDLDO'''invokePrim [#_"DDLDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DDLDL
    #_abstract
    (#_"long" DDLDL'''invokePrim [#_"DDLDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DDLDD
    #_abstract
    (#_"double" DDLDD'''invokePrim [#_"DDLDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DDDOO
    #_abstract
    (#_"Object" DDDOO'''invokePrim [#_"DDDOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDDOL
    #_abstract
    (#_"long" DDDOL'''invokePrim [#_"DDDOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDDOD
    #_abstract
    (#_"double" DDDOD'''invokePrim [#_"DDDOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDDLO
    #_abstract
    (#_"Object" DDDLO'''invokePrim [#_"DDDLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DDDLL
    #_abstract
    (#_"long" DDDLL'''invokePrim [#_"DDDLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DDDLD
    #_abstract
    (#_"double" DDDLD'''invokePrim [#_"DDDLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DDDDO
    #_abstract
    (#_"Object" DDDDO'''invokePrim [#_"DDDDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DDDDL
    #_abstract
    (#_"long" DDDDL'''invokePrim [#_"DDDDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DDDDD
    #_abstract
    (#_"double" DDDDD'''invokePrim [#_"DDDDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(defprotocol IFn #_(§ extends Callable, Runnable)
    #_abstract
    (#_"Object" IFn'''invoke1 [#_"IFn" this])
    #_abstract
    (#_"Object" IFn'''invoke2 [#_"IFn" this, #_"Object" ___arg1])
    #_abstract
    (#_"Object" IFn'''invoke3 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"Object" IFn'''invoke4 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
    #_abstract
    (#_"Object" IFn'''invoke5 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4])
    #_abstract
    (#_"Object" IFn'''invoke6 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5])
    #_abstract
    (#_"Object" IFn'''invoke7 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6])
    #_abstract
    (#_"Object" IFn'''invoke8 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7])
    #_abstract
    (#_"Object" IFn'''invoke9 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8])

    #_abstract
    (#_"Object" IFn'''invoke10 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9])

    #_abstract
    (#_"Object" IFn'''invoke11 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10])

    #_abstract
    (#_"Object" IFn'''invoke12 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11])

    #_abstract
    (#_"Object" IFn'''invoke13 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12])

    #_abstract
    (#_"Object" IFn'''invoke14 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13])

    #_abstract
    (#_"Object" IFn'''invoke15 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14])

    #_abstract
    (#_"Object" IFn'''invoke16 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15])

    #_abstract
    (#_"Object" IFn'''invoke17 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16])

    #_abstract
    (#_"Object" IFn'''invoke18 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17])

    #_abstract
    (#_"Object" IFn'''invoke19 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18])

    #_abstract
  #_(#_"Object" IFn'''invoke20 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19])

    #_abstract
  #_(#_"Object" IFn'''invoke21 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20])

    #_abstract
    (#_"Object" IFn'''invoke22 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" #_arg19, #_"Object" #_arg20, #_"Object..." ___args])

    #_abstract
    (#_"Object" IFn'''applyTo [#_"IFn" this, #_"ISeq" ___arglist])
)
)

(java-ns cloiure.lang.IHashEq

(defprotocol IHashEq
    #_abstract
    (#_"int" IHashEq'''hasheq [#_"IHashEq" this])
)
)

(java-ns cloiure.lang.IKeywordLookup

(defprotocol IKeywordLookup
    #_abstract
    (#_"ILookupThunk" IKeywordLookup'''getLookupThunk [#_"IKeywordLookup" this, #_"Keyword" ___k])
)
)

(java-ns cloiure.lang.IKVReduce

(defprotocol IKVReduce
    #_abstract
    (#_"Object" IKVReduce'''kvreduce [#_"IKVReduce" this, #_"IFn" ___f, #_"Object" ___init])
)
)

(java-ns cloiure.lang.ILookup

(defprotocol ILookup
    #_abstract
    (#_"Object" ILookup'''valAt2 [#_"ILookup" this, #_"Object" ___key])
    #_abstract
    (#_"Object" ILookup'''valAt3 [#_"ILookup" this, #_"Object" ___key, #_"Object" ___notFound])
)
)

(java-ns cloiure.lang.ILookupSite

(defprotocol ILookupSite
    #_abstract
    (#_"ILookupThunk" ILookupSite'''fault [#_"ILookupSite" this, #_"Object" ___target])
)
)

(java-ns cloiure.lang.ILookupThunk

(defprotocol ILookupThunk
    #_abstract
    (#_"Object" ILookupThunk'''get [#_"ILookupThunk" this, #_"Object" ___target])
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(defprotocol IMapEntry #_(§ extends Map$Entry)
    #_abstract
    (#_"Object" IMapEntry'''key [#_"IMapEntry" this])
    #_abstract
    (#_"Object" IMapEntry'''val [#_"IMapEntry" this])
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(defprotocol IMapIterable
    #_abstract
    (#_"Iterator" IMapIterable'''keyIterator [#_"IMapIterable" this])
    #_abstract
    (#_"Iterator" IMapIterable'''valIterator [#_"IMapIterable" this])
)
)

(java-ns cloiure.lang.IMeta

(defprotocol IMeta
    #_abstract
    (#_"IPersistentMap" IMeta'''meta [#_"IMeta" this])
)
)

(java-ns cloiure.lang.Indexed

(defprotocol Indexed #_(§ extends Counted)
    #_abstract
    (#_"Object" Indexed'''nth2 [#_"Indexed" this, #_"int" ___i])
    #_abstract
    (#_"Object" Indexed'''nth3 [#_"Indexed" this, #_"int" ___i, #_"Object" ___notFound])
)
)

(java-ns cloiure.lang.IndexedSeq

(defprotocol IndexedSeq #_(§ extends ISeq, Sequential, Counted)
    #_abstract
    (#_"int" IndexedSeq'''index [#_"IndexedSeq" this])
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

#_stateless
(class-ns Intrinsics (§ implements Opcodes)
    (§ defn- #_"Object[]" Intrinsics'oa [#_"Object..." ___arr]
        arr
    )

    (§ def #_"IPersistentMap" Intrinsics'ops (ß RT'map(
        (§ map
            "public static double cloiure.lang.Numbers.add(double,double)"                DADD
            "public static long cloiure.lang.Numbers.and(long,long)"                      LAND
            "public static long cloiure.lang.Numbers.or(long,long)"                       LOR
            "public static long cloiure.lang.Numbers.xor(long,long)"                      LXOR
            "public static double cloiure.lang.Numbers.multiply(double,double)"           DMUL
            "public static double cloiure.lang.Numbers.divide(double,double)"             DDIV
            "public static long cloiure.lang.Numbers.remainder(long,long)"                LREM
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)"                (ß oa(L2I, LSHL))
            "public static long cloiure.lang.Numbers.shiftRight(long,long)"               (ß oa(L2I, LSHR))
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)"       (ß oa(L2I, LUSHR))
            "public static double cloiure.lang.Numbers.minus(double)"                     DNEG
            "public static double cloiure.lang.Numbers.minus(double,double)"              DSUB
            "public static double cloiure.lang.Numbers.inc(double)"                       (ß oa(DCONST_1, DADD))
            "public static double cloiure.lang.Numbers.dec(double)"                       (ß oa(DCONST_1, DSUB))
            "public static long cloiure.lang.Numbers.quotient(long,long)"                 LDIV
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)"                ISHL
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)"               ISHR
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)"       IUSHR
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)"           IADD
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)"      ISUB
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)"            INEG
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)"               (ß oa(ICONST_1, IADD))
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)"               (ß oa(ICONST_1, ISUB))
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)"      IMUL
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)"        IDIV
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)"     IREM
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)"            LADD
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)"      DADD
            "public static long cloiure.lang.Numbers.unchecked_minus(long)"               LNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double)"           DNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)"    DSUB
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)"          LSUB
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)"       LMUL
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)" DMUL
            "public static double cloiure.lang.Numbers.unchecked_inc(double)"             (ß oa(DCONST_1, DADD))
            "public static long cloiure.lang.Numbers.unchecked_inc(long)"                 (ß oa(LCONST_1, LADD))
            "public static double cloiure.lang.Numbers.unchecked_dec(double)"             (ß oa(DCONST_1, DSUB))
            "public static long cloiure.lang.Numbers.unchecked_dec(long)"                 (ß oa(LCONST_1, LSUB))

            "public static short cloiure.lang.RT.aget(short[],int)"                       SALOAD
            "public static float cloiure.lang.RT.aget(float[],int)"                       FALOAD
            "public static double cloiure.lang.RT.aget(double[],int)"                     DALOAD
            "public static int cloiure.lang.RT.aget(int[],int)"                           IALOAD
            "public static long cloiure.lang.RT.aget(long[],int)"                         LALOAD
            "public static char cloiure.lang.RT.aget(char[],int)"                         CALOAD
            "public static byte cloiure.lang.RT.aget(byte[],int)"                         BALOAD
            "public static boolean cloiure.lang.RT.aget(boolean[],int)"                   BALOAD
            "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)" AALOAD
            "public static int cloiure.lang.RT.alength(int[])"                            ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(long[])"                           ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(char[])"                           ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(java.lang.Object[])"               ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(byte[])"                           ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(float[])"                          ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(short[])"                          ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(boolean[])"                        ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(double[])"                         ARRAYLENGTH

            "public static double cloiure.lang.RT.doubleCast(long)"            L2D
            "public static double cloiure.lang.RT.doubleCast(double)"          NOP
            "public static double cloiure.lang.RT.doubleCast(float)"           F2D
            "public static double cloiure.lang.RT.doubleCast(int)"             I2D
            "public static double cloiure.lang.RT.doubleCast(short)"           I2D
            "public static double cloiure.lang.RT.doubleCast(byte)"            I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)" NOP
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)"  F2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)"   L2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)"    I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)"  I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)"   I2D
            "public static long cloiure.lang.RT.longCast(long)"                NOP
            "public static long cloiure.lang.RT.longCast(short)"               I2L
            "public static long cloiure.lang.RT.longCast(byte)"                I2L
            "public static long cloiure.lang.RT.longCast(int)"                 I2L
            "public static int cloiure.lang.RT.uncheckedIntCast(long)"         L2I
            "public static int cloiure.lang.RT.uncheckedIntCast(double)"       D2I
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)"         NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(short)"        NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(char)"         NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(int)"          NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(float)"        F2I
            "public static long cloiure.lang.RT.uncheckedLongCast(short)"      I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(float)"      F2L
            "public static long cloiure.lang.RT.uncheckedLongCast(double)"     D2
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)"       I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(long)"       NOP
            "public static long cloiure.lang.RT.uncheckedLongCast(int)"        I2L
        )
    )))

    ;; map to instructions terminated with comparator for branch to false
    (§ def #_"IPersistentMap" Intrinsics'preds (ß RT'map(
        (§ map
            "public static boolean cloiure.lang.Numbers.lt(double,double)"    (ß oa(DCMPG, IFGE))
            "public static boolean cloiure.lang.Numbers.lt(long,long)"        (ß oa(LCMP, IFGE))
            "public static boolean cloiure.lang.Numbers.equiv(double,double)" (ß oa(DCMPL, IFNE))
            "public static boolean cloiure.lang.Numbers.equiv(long,long)"     (ß oa(LCMP, IFNE))
            "public static boolean cloiure.lang.Numbers.lte(double,double)"   (ß oa(DCMPG, IFGT))
            "public static boolean cloiure.lang.Numbers.lte(long,long)"       (ß oa(LCMP, IFGT))
            "public static boolean cloiure.lang.Numbers.gt(long,long)"        (ß oa(LCMP, IFLE))
            "public static boolean cloiure.lang.Numbers.gt(double,double)"    (ß oa(DCMPL, IFLE))
            "public static boolean cloiure.lang.Numbers.gte(long,long)"       (ß oa(LCMP, IFLT))
            "public static boolean cloiure.lang.Numbers.gte(double,double)"   (ß oa(DCMPL, IFLT))
            "public static boolean cloiure.lang.Util.equiv(long,long)"        (ß oa(LCMP, IFNE))
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)"  (ß oa(IF_ICMPNE))
            "public static boolean cloiure.lang.Util.equiv(double,double)"    (ß oa(DCMPL, IFNE))

            "public static boolean cloiure.lang.Numbers.isZero(double)"       (ß oa(DCONST_0, DCMPL, IFNE))
            "public static boolean cloiure.lang.Numbers.isZero(long)"         (ß oa(LCONST_0, LCMP, IFNE))
            "public static boolean cloiure.lang.Numbers.isPos(long)"          (ß oa(LCONST_0, LCMP, IFLE))
            "public static boolean cloiure.lang.Numbers.isPos(double)"        (ß oa(DCONST_0, DCMPL, IFLE))
            "public static boolean cloiure.lang.Numbers.isNeg(long)"          (ß oa(LCONST_0, LCMP, IFGE))
            "public static boolean cloiure.lang.Numbers.isNeg(double)"        (ß oa(DCONST_0, DCMPG, IFGE))
        )
    )))
)
)

(java-ns cloiure.lang.IObj

(defprotocol IObj #_(§ extends IMeta)
    #_abstract
    (#_"IObj" IObj'''withMeta [#_"IObj" this, #_"IPersistentMap" ___meta])
)
)

(java-ns cloiure.lang.IPending

(defprotocol IPending
    #_abstract
    (#_"boolean" IPending'''isRealized [#_"IPending" this])
)
)

(java-ns cloiure.lang.IPersistentCollection

(defprotocol IPersistentCollection #_(§ extends Seqable)
    #_abstract
    (#_"int" IPersistentCollection'''count [#_"IPersistentCollection" this])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''cons [#_"IPersistentCollection" this, #_"Object" ___o])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''empty [#_"IPersistentCollection" this])
    #_abstract
    (#_"boolean" IPersistentCollection'''equiv [#_"IPersistentCollection" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.IPersistentList

(defprotocol IPersistentList #_(§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(defprotocol IPersistentMap #_(§ extends Iterable, Associative, Counted)
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''assoc [#_"IPersistentMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''assocEx [#_"IPersistentMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''without [#_"IPersistentMap" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IPersistentSet

(defprotocol IPersistentSet #_(§ extends IPersistentCollection, Counted)
    #_abstract
    (#_"IPersistentSet" IPersistentSet'''disjoin [#_"IPersistentSet" this, #_"Object" ___key])
    #_abstract
    (#_"boolean" IPersistentSet'''contains [#_"IPersistentSet" this, #_"Object" ___key])
    #_abstract
    (#_"Object" IPersistentSet'''get [#_"IPersistentSet" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IPersistentStack

(defprotocol IPersistentStack #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" IPersistentStack'''peek [#_"IPersistentStack" this])
    #_abstract
    (#_"IPersistentStack" IPersistentStack'''pop [#_"IPersistentStack" this])
)
)

(java-ns cloiure.lang.IPersistentVector

(defprotocol IPersistentVector #_(§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    #_abstract
    (#_"int" IPersistentVector'''length [#_"IPersistentVector" this])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''assocN [#_"IPersistentVector" this, #_"int" ___i, #_"Object" ___val])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''cons [#_"IPersistentVector" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.IProxy

(defprotocol IProxy
    #_abstract
    (#_"void" IProxy'''__initCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" ___m])
    #_abstract
    (#_"void" IProxy'''__updateCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" ___m])
    #_abstract
    (#_"IPersistentMap" IProxy'''__getCloiureFnMappings [#_"IProxy" this])
)
)

(java-ns cloiure.lang.IRecord

(defprotocol IRecord
)
)

(java-ns cloiure.lang.IReduce

(defprotocol IReduce #_(§ extends IReduceInit)
    #_abstract
    (#_"Object" IReduce'''reduce [#_"IReduce" this, #_"IFn" ___f])
)
)

(java-ns cloiure.lang.IReduceInit

(defprotocol IReduceInit
    #_abstract
    (#_"Object" IReduceInit'''reduce [#_"IReduceInit" this, #_"IFn" ___f, #_"Object" ___start])
)
)

(java-ns cloiure.lang.IRef

(defprotocol IRef #_(§ extends IDeref)
    #_abstract
    (#_"void" IRef'''setValidator [#_"IRef" this, #_"IFn" ___vf])
    #_abstract
    (#_"IFn" IRef'''getValidator [#_"IRef" this])
    #_abstract
    (#_"IPersistentMap" IRef'''getWatches [#_"IRef" this])
    #_abstract
    (#_"IRef" IRef'''addWatch [#_"IRef" this, #_"Object" ___key, #_"IFn" ___callback])
    #_abstract
    (#_"IRef" IRef'''removeWatch [#_"IRef" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IReference

(defprotocol IReference #_(§ extends IMeta)
    #_abstract
    (#_"IPersistentMap" IReference'''alterMeta [#_"IReference" this, #_"IFn" ___alter, #_"ISeq" ___args])
    #_abstract
    (#_"IPersistentMap" IReference'''resetMeta [#_"IReference" this, #_"IPersistentMap" ___m])
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(defprotocol ISeq #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" ISeq'''first [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''next [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''more [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''cons [#_"ISeq" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (§ def- #_"Object" Iterate'UNREALIZED_SEED (Object.))

    (§ init
        (§ field- #_"IFn" f nil) ;; never nil
        (§ field- #_"Object" prevSeed nil)
        #_volatile
        (§ field- #_"Object" _seed nil) ;; lazily realized
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"Iterate" Iterate [#_"IFn" ___f, #_"Object" ___prevSeed, #_"Object" ___seed]
        (let [this (ß super())]
            (§ ass (ß this.f) ___f)
            (§ ass (ß this.prevSeed) ___prevSeed)
            (§ ass (ß this._seed) ___seed)
            this
        )
    )

    (§ constructor- #_"Iterate" Iterate [#_"IPersistentMap" ___meta, #_"IFn" ___f, #_"Object" ___prevSeed, #_"Object" ___seed, #_"ISeq" ___next]
        (let [this (ß super(___meta))]
            (§ ass (ß this.f) ___f)
            (§ ass (ß this.prevSeed) ___prevSeed)
            (§ ass (ß this._seed) ___seed)
            (§ ass (ß this._next) ___next)
            this
        )
    )

    (§ defn #_"ISeq" Iterate'create [#_"IFn" ___f, #_"Object" ___seed]
        (ß new Iterate(___f, nil, ___seed))
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Iterate" this]
        (ß (_seed != UNREALIZED_SEED))
    )

    #_method
    (§ defn #_"Object" first [#_"Iterate" this]
        (when (ß _seed == UNREALIZED_SEED)
            (§ ass _seed (ß f.invoke(prevSeed)))
        )
        _seed
    )

    #_method
    (§ defn #_"ISeq" next [#_"Iterate" this]
        (when (nil? _next)
            (§ ass _next (ß new Iterate(f, first(), UNREALIZED_SEED)))
        )
        _next
    )

    #_method
    (§ defn #_"Iterate" withMeta [#_"Iterate" this, #_"IPersistentMap" ___meta]
        (ß new Iterate(___meta, f, prevSeed, _seed, _next))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Iterate" this, #_"IFn" ___rf]
        (let [#_"Object" ___first (ß first())]
            (let [#_"Object" ___ret ___first]
                (let [#_"Object" ___v (ß f.invoke(___first))]
                    (while true
                        (§ ass ___ret (ß ___rf.invoke(___ret, ___v)))
                        (when (ß RT'isReduced(___ret))
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                        (§ ass ___v (ß f.invoke(___v)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Iterate" this, #_"IFn" ___rf, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (let [#_"Object" ___v (ß first())]
                (while true
                    (§ ass ___ret (ß ___rf.invoke(___ret, ___v)))
                    (when (ß RT'isReduced(___ret))
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                    (§ ass ___v (ß f.invoke(___v)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeqState
    (§ init
        #_volatile
        (§ field #_"Object" val nil)
        #_volatile
        (§ field #_"Object" _rest nil)
    )
)

(class-ns IteratorSeq (§ extends ASeq)
    (§ defn #_"IteratorSeq" IteratorSeq'create [#_"Iterator" ___iter]
        (when (ß ___iter.hasNext())
            (§ return (IteratorSeq. ___iter))
        )
        nil
    )

    (§ init
        (§ field #_"Iterator" iter nil)
        (§ field #_"IteratorSeqState" state nil)
    )

    (§ constructor #_"IteratorSeq" IteratorSeq [#_"Iterator" ___iter]
        (let [this (ß super())]
            (§ ass (ß this.iter) ___iter)
            (§ ass state (IteratorSeqState.))
            (§ ass (ß this.state.val) state)
            (§ ass (ß this.state._rest) state)
            this
        )
    )

    (§ constructor #_"IteratorSeq" IteratorSeq [#_"IPersistentMap" ___meta, #_"Iterator" ___iter, #_"IteratorSeqState" ___state]
        (let [this (ß super(___meta))]
            (§ ass (ß this.iter) ___iter)
            (§ ass (ß this.state) ___state)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"IteratorSeq" this]
        (when (ß state.val == state)
            (§ sync state
                (when (ß state.val == state)
                    (§ ass (ß state.val) (ß iter.next()))
                )
            )
        )
        (ß state.val)
    )

    #_method
    (§ defn #_"ISeq" next [#_"IteratorSeq" this]
        (when (ß state._rest == state)
            (§ sync state
                (when (ß state._rest == state)
                    (ß first())
                    (§ ass (ß state._rest) (ß IteratorSeq'create(iter)))
                )
            )
        )
        (ß (ISeq) state._rest)
    )

    #_method
    (§ defn #_"IteratorSeq" withMeta [#_"IteratorSeq" this, #_"IPersistentMap" ___meta]
        (ß new IteratorSeq(___meta, iter, state))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(defprotocol ITransientAssociative #_(§ extends ITransientCollection, ILookup)
    #_abstract
    (#_"ITransientAssociative" ITransientAssociative'''assoc [#_"ITransientAssociative" this, #_"Object" ___key, #_"Object" ___val])
)
)

(java-ns cloiure.lang.ITransientAssociative2

(defprotocol ITransientAssociative2 #_(§ extends ITransientAssociative)
    #_abstract
    (#_"boolean" ITransientAssociative2'''containsKey [#_"ITransientAssociative2" this, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" ITransientAssociative2'''entryAt [#_"ITransientAssociative2" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.ITransientCollection

(defprotocol ITransientCollection
    #_abstract
    (#_"ITransientCollection" ITransientCollection'''conj [#_"ITransientCollection" this, #_"Object" ___val])
    #_abstract
    (#_"IPersistentCollection" ITransientCollection'''persistent [#_"ITransientCollection" this])
)
)

(java-ns cloiure.lang.ITransientMap

(defprotocol ITransientMap #_(§ extends ITransientAssociative, Counted)
    #_abstract
    (#_"ITransientMap" ITransientMap'''assoc [#_"ITransientMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"ITransientMap" ITransientMap'''without [#_"ITransientMap" this, #_"Object" ___key])
    #_abstract
    (#_"IPersistentMap" ITransientMap'''persistent [#_"ITransientMap" this])
)
)

(java-ns cloiure.lang.ITransientSet

(defprotocol ITransientSet #_(§ extends ITransientCollection, Counted)
    #_abstract
    (#_"ITransientSet" ITransientSet'''disjoin [#_"ITransientSet" this, #_"Object" ___key])
    #_abstract
    (#_"boolean" ITransientSet'''contains [#_"ITransientSet" this, #_"Object" ___key])
    #_abstract
    (#_"Object" ITransientSet'''get [#_"ITransientSet" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.ITransientVector

(defprotocol ITransientVector #_(§ extends ITransientAssociative, Indexed)
    #_abstract
    (#_"ITransientVector" ITransientVector'''assocN [#_"ITransientVector" this, #_"int" ___i, #_"Object" ___val])
    #_abstract
    (#_"ITransientVector" ITransientVector'''pop [#_"ITransientVector" this])
)
)

(java-ns cloiure.lang.IType

(defprotocol IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (§ def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" Keyword'table (ConcurrentHashMap.))

    (§ def #_"ReferenceQueue" Keyword'rq (ReferenceQueue.))

    (§ defn #_"Keyword" Keyword'intern [#_"Symbol" ___sym]
        (let [#_"Keyword" ___k nil]
            (let [#_"Reference<Keyword>" ___existingRef (ß table.get(___sym))]
                (when (nil? ___existingRef)
                    (ß Util'clearCache(rq, table))
                    (when (ß ___sym.meta() != nil)
                        (§ ass ___sym (ß (Symbol) ___sym.withMeta(nil)))
                    )
                    (§ ass ___k (Keyword. ___sym))
                    (§ ass ___existingRef (ß table.putIfAbsent(___sym, new WeakReference<Keyword>(___k, rq))))
                )
                (when (nil? ___existingRef)
                    (§ return ___k)
                )
                (let [#_"Keyword" ___existingk (ß ___existingRef.get())]
                    (when (some? ___existingk)
                        (§ return ___existingk)
                    )
                    ;; entry died in the interim, do over
                    (ß table.remove(___sym, ___existingRef))
                    (ß intern(___sym))
                )
            )
        )
    )

    (§ defn #_"Keyword" Keyword'intern [#_"String" ___ns, #_"String" ___name]
        (ß intern(Symbol'intern(___ns, ___name)))
    )

    (§ defn #_"Keyword" Keyword'intern [#_"String" ___nsname]
        (ß intern(Symbol'intern(___nsname)))
    )

    (§ init
        (§ field #_"Symbol" sym nil)
        (§ field #_"int" hasheq 0)
        #_transient
        (§ field #_"String" _str nil)
    )

    (§ constructor- #_"Keyword" Keyword [#_"Symbol" ___sym]
        (let [this (ß super())]
            (§ ass (ß this.sym) ___sym)
            (§ ass hasheq (ß ___sym.hasheq() + 0x9e3779b9))
            this
        )
    )

    (§ defn #_"Keyword" Keyword'find [#_"Symbol" ___sym]
        (let [#_"Reference<Keyword>" ___ref (ß table.get(___sym))]
            (if (some? ___ref)
                (do
                    (ß ___ref.get())
                )
                (do
                    nil
                )
            )
        )
    )

    (§ defn #_"Keyword" Keyword'find [#_"String" ___ns, #_"String" ___name]
        (ß Keyword'find(Symbol'intern(___ns, ___name)))
    )

    (§ defn #_"Keyword" Keyword'find [#_"String" ___nsname]
        (ß Keyword'find(Symbol'intern(___nsname)))
    )

    #_method
    (§ defn #_"int" hashCode [#_"Keyword" this]
        (ß sym.hashCode() + 0x9e3779b9)
    )

    #_method
    (§ defn #_"int" hasheq [#_"Keyword" this]
        hasheq
    )

    #_method
    (§ defn #_"String" toString [#_"Keyword" this]
        (when (nil? _str)
            (§ ass _str (ß (":" + sym)))
        )
        _str
    )

    #_method
    (§ defn #_"Object" throwArity [#_"Keyword" this]
        (throw (ß new IllegalArgumentException("Wrong number of args passed to keyword: " + toString())))
    )

    #_method
    (§ defn #_"Object" call [#_"Keyword" this]
        (ß throwArity())
    )

    #_method
    (§ defn #_"void" run [#_"Keyword" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this]
        (ß throwArity())
    )

    #_method
    (§ defn #_"int" compareTo [#_"Keyword" this, #_"Object" ___o]
        (ß sym.compareTo(((Keyword) ___o).sym))
    )

    #_method
    (§ defn #_"String" getNamespace [#_"Keyword" this]
        (ß sym.getNamespace())
    )

    #_method
    (§ defn #_"String" getName [#_"Keyword" this]
        (ß sym.getName())
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___obj]
        (when (ß ___obj instanceof ILookup)
            (§ return (ß ((ILookup)___obj).valAt(this)))
        )
        (ß RT'get(___obj, this))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___obj, #_"Object" ___notFound]
        (when (ß ___obj instanceof ILookup)
            (§ return (ß ((ILookup)___obj).valAt(this, ___notFound)))
        )
        (ß RT'get(___obj, this, ___notFound))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Keyword" this, #_"ISeq" ___arglist]
        (ß AFn'applyToHelper(this, ___arglist))
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (§ init
        (§ field #_"Keyword" k nil)
    )

    (§ constructor #_"KeywordLookupSite" KeywordLookupSite [#_"Keyword" ___k]
        (let [this (ß super())]
            (§ ass (ß this.k) ___k)
            this
        )
    )

    #_method
    (§ defn #_"ILookupThunk" fault [#_"KeywordLookupSite" this, #_"Object" ___target]
        (cond (ß ___target instanceof IKeywordLookup)
            (do
                (§ return (ß install(___target)))
            )
            (ß ___target instanceof ILookup)
            (do
                (§ return (ß ilookupThunk(___target.getClass())))
            )
        )
        this
    )

    #_method
    (§ defn #_"Object" get [#_"KeywordLookupSite" this, #_"Object" ___target]
        (when (ß ___target instanceof IKeywordLookup || ___target instanceof ILookup)
            (§ return this)
        )
        (ß RT'get(___target, k))
    )

    #_method
    (§ defn- #_"ILookupThunk" ilookupThunk [#_"KeywordLookupSite" this, #_"Class" ___c]
        (§ reify ILookupThunk()
            #_method
            (§ defn #_"Object" get [#_"ILookupThunk" this, #_"Object" ___target]
                (when (ß ___target != nil && ___target.getClass() == ___c)
                    (§ return (ß ((ILookup) ___target).valAt(k)))
                )
                this
            )
        )
    )

    #_method
    (§ defn- #_"ILookupThunk" install [#_"KeywordLookupSite" this, #_"Object" ___target]
        (let [#_"ILookupThunk" ___t (ß ((IKeywordLookup)___target).getLookupThunk(k))]
            (when (some? ___t)
                (§ return ___t)
            )
            (ß ilookupThunk(___target.getClass()))
        )
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns LazilyPersistentVector
    (§ defn #_"IPersistentVector" LazilyPersistentVector'createOwning [#_"Object..." ___items]
        (when (ß ___items.length <= 32)
            (§ return (ß new PersistentVector(___items.length, 5, PersistentVector'EMPTY_NODE, ___items)))
        )
        (ß PersistentVector'create(___items))
    )

    (§ defn #_"int" LazilyPersistentVector'fcount [#_"Object" ___c]
        (when (ß ___c instanceof Counted)
            (§ return (ß ((Counted) ___c).count()))
        )
        (ß ((Collection)___c).size())
    )

    (§ defn #_"IPersistentVector" LazilyPersistentVector'create [#_"Object" ___obj]
        (cond (ß ___obj instanceof IReduceInit)
            (do
                (ß PersistentVector'create((IReduceInit) ___obj))
            )
            (ß ___obj instanceof ISeq)
            (do
                (ß PersistentVector'create(RT'seq(___obj)))
            )
            (ß ___obj instanceof Iterable)
            (do
                (ß PersistentVector'create((Iterable)___obj))
            )
            :else
            (do
                (ß createOwning(RT'toArray(___obj)))
            )
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (§ init
        (§ field- #_"IFn" fn nil)
        (§ field- #_"Object" sv nil)
        (§ field- #_"ISeq" s nil)
    )

    (§ constructor #_"LazySeq" LazySeq [#_"IFn" ___fn]
        (let [this (ß super())]
            (§ ass (ß this.fn) ___fn)
            this
        )
    )

    (§ constructor- #_"LazySeq" LazySeq [#_"IPersistentMap" ___meta, #_"ISeq" ___s]
        (let [this (ß super(___meta))]
            (§ ass (ß this.fn) nil)
            (§ ass (ß this.s) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"LazySeq" this, #_"IPersistentMap" ___meta]
        (ß new LazySeq(___meta, seq()))
    )

    #_method
    (§ defn #_"Object" sval [#_"LazySeq" this]
        (§ sync this
            (when (some? fn)
                (§ ass sv (ß fn.invoke()))
                (§ ass fn nil)
            )
            (when (some? sv)
                (§ return sv)
            )
            s
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"LazySeq" this]
        (§ sync this
            (ß sval())
            (when (some? sv)
                (let [#_"Object" ___ls sv]
                    (§ ass sv nil)
                    (while (ß ___ls instanceof LazySeq)
                        (§ ass ___ls (ß ((LazySeq)___ls).sval()))
                    )
                    (§ ass s (ß RT'seq(___ls)))
                )
            )
            s
        )
    )

    #_method
    (§ defn #_"int" count [#_"LazySeq" this]
        (let [#_"int" ___c 0]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (§ ass ___c (ß ___c + 1))
            )
            c
        )
    )

    #_method
    (§ defn #_"Object" first [#_"LazySeq" this]
        (ß seq())
        (when (nil? s)
            (§ return nil)
        )
        (ß s.first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"LazySeq" this]
        (ß seq())
        (when (nil? s)
            (§ return nil)
        )
        (ß s.next())
    )

    #_method
    (§ defn #_"ISeq" more [#_"LazySeq" this]
        (ß seq())
        (when (nil? s)
            (§ return (ß PersistentList'EMPTY))
        )
        (ß s.more())
    )

    #_method
    (§ defn #_"ISeq" cons [#_"LazySeq" this, #_"Object" ___o]
        (ß RT'cons(___o, seq()))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"LazySeq" this]
        (ß PersistentList'EMPTY)
    )

    #_method
    (§ defn #_"boolean" equiv [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (ß seq())]
            (if (some? ___s)
                (do
                    (ß ___s.equiv(___o))
                )
                (do
                    (ß (___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"LazySeq" this]
        (let [#_"ISeq" ___s (ß seq())]
            (when (nil? ___s)
                (§ return 1)
            )
            (ß Util'hash(___s))
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"LazySeq" this]
        (ß Murmur3'hashOrdered(this))
    )

    #_method
    (§ defn #_"boolean" equals [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (ß seq())]
            (if (some? ___s)
                (do
                    (ß ___s.equals(___o))
                )
                (do
                    (ß (___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"LazySeq" this]
        (ß RT'seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"LazySeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"LazySeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"LazySeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"LazySeq" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß !contains(___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"LazySeq" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"LazySeq" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"LazySeq" this]
        (ß (seq() == nil))
    )

    #_method
    (§ defn #_"boolean" contains [#_"LazySeq" this, #_"Object" ___o]
        (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
            (when (ß Util'equiv(___s.first(), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"LazySeq" this]
        (SeqIterator. this)
    )

    #_method
    (§ defn- #_"List" reify [#_"LazySeq" this]
        (ArrayList. this)
    )

    #_method
    (§ defn #_"List" subList [#_"LazySeq" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß reify().subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"LazySeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"LazySeq" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (ß seq())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___s) [(§ ass ___s (ß ___s.next()), ___i (ß ___i + 1))]
                (when (ß Util'equiv(___s.first(), ___o))
                    (§ return ___i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"LazySeq" this, #_"Object" ___o]
        (ß reify().lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"LazySeq" this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"LazySeq" this, #_"int" ___index]
        (ß reify().listIterator(___index))
    )

    #_method
    (§ defn #_"Object" get [#_"LazySeq" this, #_"int" ___index]
        (ß RT'nth(this, ___index))
    )

    #_method
    (§ defn #_"void" add [#_"LazySeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"LazySeq" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"LazySeq" this]
        (§ sync this
            (ß (fn == nil))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.
    (§ def- #_"int" LineNumberingPushbackReader'newline (ß (int) \newline))

    (§ init
        (§ field- #_"boolean" _atLineStart true)
        (§ field- #_"boolean" _prev false)
        (§ field- #_"int" _columnNumber 1)
    )

    (§ constructor #_"LineNumberingPushbackReader" LineNumberingPushbackReader [#_"Reader" ___r]
        (let [this (ß super(new LineNumberReader(___r)))]
            this
        )
    )

    (§ constructor #_"LineNumberingPushbackReader" LineNumberingPushbackReader [#_"Reader" ___r, #_"int" ___size]
        (let [this (ß super(new LineNumberReader(___r, ___size)))]
            this
        )
    )

    #_method
    (§ defn #_"int" getLineNumber [#_"LineNumberingPushbackReader" this]
        (ß ((LineNumberReader) in).getLineNumber() + 1)
    )

    #_method
    (§ defn #_"void" setLineNumber [#_"LineNumberingPushbackReader" this, #_"int" ___line]
        (ß ((LineNumberReader) in).setLineNumber(___line - 1))
        nil
    )

    #_method
    (§ defn #_"int" getColumnNumber [#_"LineNumberingPushbackReader" this]
        _columnNumber
    )

    #_method
    (§ defn #_"int" read [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" ___c (ß super.read())]
            (§ ass _prev _atLineStart)
            (if (ß (___c == LineNumberingPushbackReader'newline) || (___c == -1))
                (do
                    (§ ass _atLineStart true)
                    (§ ass _columnNumber 1)
                )
                (do
                    (§ ass _atLineStart false)
                    (§ ass _columnNumber (ß _columnNumber + 1))
                )
            )
            c
        )
    )

    #_method
    (§ defn #_"void" unread [#_"LineNumberingPushbackReader" this, #_"int" ___c] #_(§ throws IOException)
        (ß super.unread(___c))
        (§ ass _atLineStart _prev)
        (§ ass _columnNumber (ß _columnNumber - 1))
        nil
    )

    #_method
    (§ defn #_"String" readLine [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" ___c (ß read())]
            (§ let [#_"String" ___line]
                (§ switch ___c
                    (§ case -1)
                    (do
                        (§ ass ___line nil)
                        (§ break )
                    )
                    (§ case LineNumberingPushbackReader'newline)
                    (do
                        (§ ass ___line "")
                        (§ break )
                    )
                    (§ default )
                    (do
                        (let [#_"String" ___first (ß String/valueOf((char) ___c))]
                            (let [#_"String" ___rest (ß ((LineNumberReader)in).readLine())]
                                (§ ass ___line (ß (___rest == nil) ? ___first :or ___first + ___rest))
                                (§ ass _prev false)
                                (§ ass _atLineStart true)
                                (§ ass _columnNumber 1)
                                (§ break )
                            )
                        )
                    )
                )
                line
            )
        )
    )

    #_method
    (§ defn #_"boolean" atLineStart [#_"LineNumberingPushbackReader" this]
        _atLineStart
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(defprotocol Resolver
    #_abstract
    (#_"Symbol" Resolver'''currentNS [#_"Resolver" this])
    #_abstract
    (#_"Symbol" Resolver'''resolveClass [#_"Resolver" this, #_"Symbol" ___sym])
    #_abstract
    (#_"Symbol" Resolver'''resolveAlias [#_"Resolver" this, #_"Symbol" ___sym])
    #_abstract
    (#_"Symbol" Resolver'''resolveVar [#_"Resolver" this, #_"Symbol" ___sym])
)

(class-ns LispReaderException (§ extends RuntimeException)
    (§ init
        (§ field #_"int" line 0)
        (§ field #_"int" column 0)
    )

    (§ constructor #_"LispReaderException" LispReaderException [#_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (ß super(___cause))]
            (§ ass (ß this.line) ___line)
            (§ ass (ß this.column) ___column)
            this
        )
    )
)

#_stateless
(class-ns RegexReader (§ extends AFn)
    (§ def #_"LispStringReader" RegexReader'stringrdr (LispStringReader.))

    #_method
    (§ defn #_"Object" invoke [#_"RegexReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [(§ var #_"int" ___ch (ß read1(___r)))] (ß ___ch != \") [(§ ass ___ch (ß read1(___r)))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (ß Util'runtimeException("EOF while reading regex")))
                    )
                    (ß ___sb.append((char) ___ch))
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (ß Util'runtimeException("EOF while reading regex")))
                        )
                        (ß ___sb.append((char) ___ch))
                    )
                )
                (ß Pattern/compile(___sb.toString()))
            )
        )
    )
)

#_stateless
(class-ns LispStringReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispStringReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [(§ var #_"int" ___ch (ß read1(___r)))] (ß ___ch != \") [(§ ass ___ch (ß read1(___r)))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (ß Util'runtimeException("EOF while reading string")))
                    )
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (ß Util'runtimeException("EOF while reading string")))
                        )
                        (§ switch ___ch
                            (§ case \t)
                            (do
                                (§ ass ___ch (ß \tab))
                                (§ break )
                            )
                            (§ case \r)
                            (do
                                (§ ass ___ch (ß \return))
                                (§ break )
                            )
                            (§ case \n)
                            (do
                                (§ ass ___ch (ß \newline))
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (§ break )
                            )
                            (§ case \") ;; oops! "
                            (do
                                (§ break )
                            )
                            (§ case \b)
                            (do
                                (§ ass ___ch (ß \backspace))
                                (§ break )
                            )
                            (§ case \f)
                            (do
                                (§ ass ___ch (ß \formfeed))
                                (§ break )
                            )
                            (§ case \u)
                            (do
                                (§ ass ___ch (ß read1(___r)))
                                (when (ß Character/digit(___ch, 16) == -1)
                                    (throw (ß Util'runtimeException("Invalid unicode escape: \\u" + (char) ___ch)))
                                )
                                (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 16, 4, true)))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (if (ß Character/isDigit(___ch))
                                    (do
                                        (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 8, 3, false)))
                                        (when (ß ___ch > 0377)
                                            (throw (ß Util'runtimeException("Octal escape sequence must be in range [0, 377].")))
                                        )
                                    )
                                    (do
                                        (throw (ß Util'runtimeException("Unsupported escape character: \\" + (char) ___ch)))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
                (ß ___sb.toString())
            )
        )
    )
)

#_stateless
(class-ns LispCommentReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispCommentReader" this, #_"Object" ___reader, #_"Object" ___semicolon, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"Reader" ___r (ß (Reader) ___reader)]
            (§ let [#_"int" ___ch]
                (§ loop
                    (§ ass ___ch (ß read1(___r)))
                    (§ recur-if (___ch != -1 && ___ch != \newline && ___ch != \return))
                )
                ___r
            )
        )
    )
)

#_stateless
(class-ns LispDiscardReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispDiscardReader" this, #_"Object" ___reader, #_"Object" ___underscore, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))
            r
        )
    )
)

;; :a.b{:c 1} => {:a.b/c 1}
;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
#_stateless
(class-ns LispNamespaceMapReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispNamespaceMapReader" this, #_"Object" ___reader, #_"Object" ___colon, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"boolean" ___auto false]
                (let [#_"int" ___autoChar (ß read1(___r))]
                    (if (ß ___autoChar == \:)
                        (do
                            (§ ass ___auto true)
                        )
                        (do
                            (ß unread(___r, ___autoChar))
                        )
                    )

                    (let [#_"Object" ___sym nil]
                        (let [#_"int" ___nextChar (ß read1(___r))]
                            (cond (ß isWhitespace(___nextChar)) ;; the #:: { } case or an error
                                (do
                                    (if ___auto
                                        (do
                                            (while (ß isWhitespace(___nextChar))
                                                (§ ass ___nextChar (ß read1(___r)))
                                            )
                                            (when (ß ___nextChar != \{)
                                                (ß unread(___r, ___nextChar))
                                                (throw (ß Util'runtimeException("Namespaced map must specify a namespace")))
                                            )
                                        )
                                        (do
                                            (ß unread(___r, ___nextChar))
                                            (throw (ß Util'runtimeException("Namespaced map must specify a namespace")))
                                        )
                                    )
                                )
                                (ß ___nextChar != \{) ;; #:foo { } or #::foo { }
                                (do
                                    (ß unread(___r, ___nextChar))
                                    (§ ass ___sym (ß read(___r, true, nil, false, ___opts, ___pendingForms)))
                                    (§ ass ___nextChar (ß read1(___r)))
                                    (while (ß isWhitespace(___nextChar))
                                        (§ ass ___nextChar (ß read1(___r)))
                                    )
                                )
                            )
                            (when (ß ___nextChar != \{)
                                (throw (ß Util'runtimeException("Namespaced map must specify a map")))
                            )

                            ;; Resolve autoresolved ns
                            (§ let [#_"String" ___ns]
                                (cond ___auto
                                    (do
                                        (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                                            (cond (nil? ___sym)
                                                (do
                                                    (if (some? ___resolver)
                                                        (do
                                                            (§ ass ___ns (ß ___resolver.currentNS().name))
                                                        )
                                                        (do
                                                            (§ ass ___ns (ß Compiler'currentNS().getName().getName()))
                                                        )
                                                    )
                                                )
                                                (ß !(___sym instanceof Symbol) || ((Symbol)___sym).getNamespace() != nil)
                                                (do
                                                    (throw (ß Util'runtimeException("Namespaced map must specify a valid namespace: " + ___sym)))
                                                )
                                                :else
                                                (do
                                                    (§ let [#_"Symbol" ___resolvedNS]
                                                        (if (some? ___resolver)
                                                            (do
                                                                (§ ass ___resolvedNS (ß ___resolver.resolveAlias((Symbol) ___sym)))
                                                            )
                                                            (do
                                                                (let [#_"Namespace" ___rns (ß Compiler'currentNS().lookupAlias((Symbol)___sym))]
                                                                    (§ ass ___resolvedNS (ß (___rns != nil) ? ___rns.getName() :or nil))
                                                                )
                                                            )
                                                        )

                                                        (if (nil? ___resolvedNS)
                                                            (do
                                                                (throw (ß Util'runtimeException("Unknown auto-resolved namespace alias: " + ___sym)))
                                                            )
                                                            (do
                                                                (§ ass ___ns (ß ___resolvedNS.getName()))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (ß !(___sym instanceof Symbol) || ((Symbol)___sym).getNamespace() != nil)
                                    (do
                                        (throw (ß Util'runtimeException("Namespaced map must specify a valid namespace: " + ___sym)))
                                    )
                                    :else
                                    (do
                                        (§ ass ___ns (ß ((Symbol)___sym).getName()))
                                    )
                                )

                                ;; Read map
                                (let [#_"List" ___kvs (ß readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms)))]
                                    (when (ß (___kvs.size() & 1) == 1)
                                        (throw (ß Util'runtimeException("Namespaced map literal must contain an even number of forms")))
                                    )

                                    ;; Construct output map
                                    (let [#_"Object[]" ___a (ß new Object[___kvs.size()])]
                                        (let [#_"Iterator" ___iter (ß ___kvs.iterator())]
                                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___iter.hasNext()) [(§ ass ___i (ß ___i + 2))]
                                                (let [#_"Object" ___key (ß ___iter.next())]
                                                    (let [#_"Object" ___val (ß ___iter.next())]
                                                        (cond (ß ___key instanceof Keyword)
                                                            (do
                                                                (let [#_"Keyword" ___kw (ß (Keyword) ___key)]
                                                                    (cond (ß ___kw.getNamespace() == nil)
                                                                        (do
                                                                            (§ ass ___key (ß Keyword'intern(___ns, ___kw.getName())))
                                                                        )
                                                                        (ß ___kw.getNamespace().equals("_"))
                                                                        (do
                                                                            (§ ass ___key (ß Keyword'intern(nil, ___kw.getName())))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (ß ___key instanceof Symbol)
                                                            (do
                                                                (let [#_"Symbol" ___s (ß (Symbol) ___key)]
                                                                    (cond (ß ___s.getNamespace() == nil)
                                                                        (do
                                                                            (§ ass ___key (ß Symbol'intern(___ns, ___s.getName())))
                                                                        )
                                                                        (ß ___s.getNamespace().equals("_"))
                                                                        (do
                                                                            (§ ass ___key (ß Symbol'intern(nil, ___s.getName())))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (§ ass (ß ___a[___i]) ___key)
                                                        (§ ass (ß ___a[___i + 1]) ___val)
                                                    )
                                                )
                                            )
                                            (ß RT'map(___a))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns LispSymbolicValueReader (§ extends AFn)
    (§ def #_"IPersistentMap" LispSymbolicValueReader'specials (ß PersistentHashMap'create(
        (§ map
            (ß Symbol'intern("Inf"))  (ß Double/POSITIVE_INFINITY)
            (ß Symbol'intern("-Inf")) (ß Double/NEGATIVE_INFINITY)
            (ß Symbol'intern("NaN"))  (ß Double/NaN)
        )
    )))

    #_method
    (§ defn #_"Object" invoke [#_"LispSymbolicValueReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (when (ß !(___o instanceof Symbol))
                    (throw (ß Util'runtimeException("Invalid token: ##" + ___o)))
                )
                (when (ß !(LispSymbolicValueReader'specials.containsKey(___o)))
                    (throw (ß Util'runtimeException("Unknown symbolic value: ##" + ___o)))
                )

                (ß LispSymbolicValueReader'specials.valAt(___o))
            )
        )
    )
)

(class-ns WrappingReader (§ extends AFn)
    (§ init
        (§ field #_"Symbol" sym nil)
    )

    (§ constructor #_"WrappingReader" WrappingReader [#_"Symbol" ___sym]
        (let [this (ß super())]
            (§ ass (ß this.sym) ___sym)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"WrappingReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (ß RT'list(sym, ___o))
            )
        )
    )
)

(class-ns DeprecatedWrappingReader (§ extends AFn)
    (§ init
        (§ field #_"Symbol" sym nil)
        (§ field #_"String" macro nil)
    )

    (§ constructor #_"DeprecatedWrappingReader" DeprecatedWrappingReader [#_"Symbol" ___sym, #_"String" ___macro]
        (let [this (ß super())]
            (§ ass (ß this.sym) ___sym)
            (§ ass (ß this.macro) ___macro)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"DeprecatedWrappingReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (ß System/out.println("WARNING: reader macro " + macro + " is deprecated; use " + sym.getName() + " instead"))
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (ß RT'list(sym, ___o))
            )
        )
    )
)

#_stateless
(class-ns VarReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"VarReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (ß RT'list(THE_VAR, ___o))
            )
        )
    )
)

#_stateless
(class-ns LispDispatchReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispDispatchReader" this, #_"Object" ___reader, #_"Object" ___hash, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"int" ___ch (ß read1((Reader) ___reader))]
            (when (ß ___ch == -1)
                (throw (ß Util'runtimeException("EOF while reading character")))
            )
            (let [#_"IFn" ___fn (ß dispatchMacros[___ch])]
                ;; Try the ctor reader first
                (when (nil? ___fn)
                    (ß unread((PushbackReader) ___reader, ___ch))
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                    (let [#_"Object" ___result (ß ctorReader.invoke(___reader, ___ch, ___opts, ___pendingForms))]
                        (if (some? ___result)
                            (do
                                (§ return ___result)
                            )
                            (do
                                (throw (ß Util'runtimeException(String/format("No dispatch macro for: %c", (char) ___ch))))
                            )
                        )
                    )
                )
                (ß ___fn.invoke(___reader, ___ch, ___opts, ___pendingForms))
            )
        )
    )
)

#_stateless
(class-ns FnReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"FnReader" this, #_"Object" ___reader, #_"Object" ___lparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (when (ß ARG_ENV.deref() != nil)
                (throw (ß new IllegalStateException("Nested #()s are not allowed")))
            )
            (try
                (ß Var'pushThreadBindings(RT'map(ARG_ENV, PersistentTreeMap'EMPTY)))
                (ß unread(___r, \())
                (let [#_"Object" ___form (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                    (let [#_"PersistentVector" ___args (ß PersistentVector'EMPTY)]
                        (let [#_"PersistentTreeMap" ___argsyms (ß (PersistentTreeMap) ARG_ENV.deref())]
                            (let [#_"ISeq" ___rargs (ß ___argsyms.rseq())]
                                (when (some? ___rargs)
                                    (let [#_"int" ___higharg (ß (Integer) ((Map$Entry) ___rargs.first()).getKey())]
                                        (when (ß ___higharg > 0)
                                            (loop-when-recur [(§ var #_"int" ___i 1)] (ß ___i <= ___higharg) [(§ ass ___i (ß ___i + 1))]
                                                (let [#_"Object" ___sym (ß ___argsyms.valAt(___i))]
                                                    (when (nil? ___sym)
                                                        (§ ass ___sym (ß garg(___i)))
                                                    )
                                                    (§ ass ___args (ß ___args.cons(___sym)))
                                                )
                                            )
                                        )
                                        (let [#_"Object" ___restsym (ß ___argsyms.valAt(-1))]
                                            (when (some? ___restsym)
                                                (§ ass ___args (ß ___args.cons(Compiler'_AMP_)))
                                                (§ ass ___args (ß ___args.cons(___restsym)))
                                            )
                                        )
                                    )
                                )
                                (ß RT'list(Compiler'FN, ___args, ___form))
                            )
                        )
                    )
                )
                (finally
                    (ß Var'popThreadBindings())
                )
            )
        )
    )
)

#_stateless
(class-ns ArgReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"ArgReader" this, #_"Object" ___reader, #_"Object" ___pct, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (when (ß ARG_ENV.deref() == nil)
                (§ return (ß interpretToken(readToken(___r, \%), nil)))
            )
            (let [#_"int" ___ch (ß read1(___r))]
                (ß unread(___r, ___ch))
                ;; % alone is first arg
                (when (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                    (§ return (ß registerArg(1)))
                )
                (let [#_"Object" ___n (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                    (when (ß ___n.equals(Compiler'_AMP_))
                        (§ return (ß registerArg(-1)))
                    )
                    (when (ß !(___n instanceof Number))
                        (throw (ß new IllegalStateException("arg literal must be %, %& or %integer")))
                    )
                    (ß registerArg(((Number) ___n).intValue()))
                )
            )
        )
    )
)

#_stateless
(class-ns LispMetaReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispMetaReader" this, #_"Object" ___reader, #_"Object" ___caret, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
                        (§ ass ___column (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()-1))
                    )
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                    (let [#_"Object" ___meta (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                        (cond (ß ___meta instanceof Symbol || ___meta instanceof String)
                            (do
                                (§ ass ___meta (ß RT'map(RT'TAG_KEY, ___meta)))
                            )
                            (ß ___meta instanceof Keyword)
                            (do
                                (§ ass ___meta (ß RT'map(___meta, RT'T)))
                            )
                            (ß !(___meta instanceof IPersistentMap))
                            (do
                                (throw (ß new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")))
                            )
                        )

                        (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                            (if (ß ___o instanceof IMeta)
                                (do
                                    (when (ß ___line != -1 && ___o instanceof ISeq)
                                        (§ ass ___meta (ß ((IPersistentMap) ___meta).assoc(RT'LINE_KEY, ___line).assoc(RT'COLUMN_KEY, ___column)))
                                    )
                                    (when (ß ___o instanceof IReference)
                                        (ß ((IReference)___o).resetMeta((IPersistentMap) ___meta))
                                        (§ return ___o)
                                    )
                                    (let [#_"Object" ___ometa (ß RT'meta(___o))]
                                        (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___meta)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                            (let [#_"IMapEntry" ___kv (ß (IMapEntry) ___s.first())]
                                                (§ ass ___ometa (ß RT'assoc(___ometa, ___kv.getKey(), ___kv.getValue())))
                                            )
                                        )
                                        (ß ((IObj) ___o).withMeta((IPersistentMap) ___ometa))
                                    )
                                )
                                (do
                                    (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns SyntaxQuoteReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"SyntaxQuoteReader" this, #_"Object" ___reader, #_"Object" ___backquote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (try
                (ß Var'pushThreadBindings(RT'map(GENSYM_ENV, PersistentHashMap'EMPTY)))

                (let [#_"Object" ___form (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                    (ß syntaxQuote(___form))
                )
                (finally
                    (ß Var'popThreadBindings())
                )
            )
        )
    )

    (§ defn #_"Object" SyntaxQuoteReader'syntaxQuote [#_"Object" ___form]
        (§ let [#_"Object" ___ret]
            (cond (ß Compiler'isSpecial(___form))
                (do
                    (§ ass ___ret (ß RT'list(Compiler'QUOTE, ___form)))
                )
                (ß ___form instanceof Symbol)
                (do
                    (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                        (let [#_"Symbol" ___sym (ß (Symbol) ___form)]
                            (cond (ß ___sym.ns == nil && ___sym.name.endsWith("#"))
                                (do
                                    (let [#_"IPersistentMap" ___gmap (ß (IPersistentMap) GENSYM_ENV.deref())]
                                        (when (nil? ___gmap)
                                            (throw (IllegalStateException. "Gensym literal not in syntax-quote"))
                                        )
                                        (let [#_"Symbol" ___gs (ß (Symbol) ___gmap.valAt(___sym))]
                                            (when (nil? ___gs)
                                                (ß GENSYM_ENV.set(___gmap.assoc(___sym, (§ ass ___gs (ß Symbol'intern(nil, ___sym.name.substring(0, ___sym.name.length() - 1) + "__" + RT'nextID() + "__auto__"))))))
                                            )
                                            (§ ass ___sym ___gs)
                                        )
                                    )
                                )
                                (ß ___sym.ns == nil && ___sym.name.endsWith("."))
                                (do
                                    (let [#_"Symbol" ___csym (ß Symbol'intern(nil, ___sym.name.substring(0, ___sym.name.length() - 1)))]
                                        (if (some? ___resolver)
                                            (do
                                                (let [#_"Symbol" ___rc (ß ___resolver.resolveClass(___csym))]
                                                    (when (some? ___rc)
                                                        (§ ass ___csym ___rc)
                                                    )
                                                )
                                            )
                                            (do
                                                (§ ass ___csym (ß Compiler'resolveSymbol(___csym)))
                                            )
                                        )
                                        (§ ass ___sym (ß Symbol'intern(nil, ___csym.name.concat("."))))
                                    )
                                )
                                (ß ___sym.ns == nil && ___sym.name.startsWith("."))
                                (do
                                    ;; Simply quote method names.
                                )
                                (some? ___resolver)
                                (do
                                    (let [#_"Symbol" ___nsym nil]
                                        (when (ß ___sym.ns != nil)
                                            (let [#_"Symbol" ___alias (ß Symbol'intern(nil, ___sym.ns))]
                                                (§ ass ___nsym (ß ___resolver.resolveClass(___alias)))
                                                (when (nil? ___nsym)
                                                    (§ ass ___nsym (ß ___resolver.resolveAlias(___alias)))
                                                )
                                            )
                                        )
                                        (cond (some? ___nsym)
                                            (do
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass ___sym (ß Symbol'intern(___nsym.name, ___sym.name)))
                                            )
                                            (ß ___sym.ns == nil)
                                            (do
                                                (let [#_"Symbol" ___rsym (ß ___resolver.resolveClass(___sym))]
                                                    (when (nil? ___rsym)
                                                        (§ ass ___rsym (ß ___resolver.resolveVar(___sym)))
                                                    )
                                                    (if (some? ___rsym)
                                                        (do
                                                            (§ ass ___sym ___rsym)
                                                        )
                                                        (do
                                                            (§ ass ___sym (ß Symbol'intern(___resolver.currentNS().name, ___sym.name)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        ;; leave alone if qualified
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Object" ___maybeClass nil]
                                        (when (ß ___sym.ns != nil)
                                            (§ ass ___maybeClass (ß Compiler'currentNS().getMapping(Symbol'intern(nil, ___sym.ns))))
                                        )
                                        (if (ß ___maybeClass instanceof Class)
                                            (do
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass ___sym (ß Symbol'intern(((Class)___maybeClass).getName(), ___sym.name)))
                                            )
                                            (do
                                                (§ ass ___sym (ß Compiler'resolveSymbol(___sym)))
                                            )
                                        )
                                    )
                                )
                            )
                            (§ ass ___ret (ß RT'list(Compiler'QUOTE, ___sym)))
                        )
                    )
                )
                (ß isUnquote(___form))
                (do
                    (§ return (ß RT'second(___form)))
                )
                (ß isUnquoteSplicing(___form))
                (do
                    (throw (IllegalStateException. "splice not in list"))
                )
                (ß ___form instanceof IPersistentCollection)
                (do
                    (cond (ß ___form instanceof IRecord)
                        (do
                            (§ ass ___ret ___form)
                        )
                        (ß ___form instanceof IPersistentMap)
                        (do
                            (let [#_"IPersistentVector" ___keyvals (ß SyntaxQuoteReader'flattenMap(___form))]
                                (§ ass ___ret (ß RT'list(APPLY, HASHMAP, RT'list(SEQ, RT'cons(CONCAT, sqExpandList(___keyvals.seq()))))))
                            )
                        )
                        (ß ___form instanceof IPersistentVector)
                        (do
                            (§ ass ___ret (ß RT'list(APPLY, VECTOR, RT'list(SEQ, RT'cons(CONCAT, sqExpandList(((IPersistentVector) ___form).seq()))))))
                        )
                        (ß ___form instanceof IPersistentSet)
                        (do
                            (§ ass ___ret (ß RT'list(APPLY, HASHSET, RT'list(SEQ, RT'cons(CONCAT, sqExpandList(((IPersistentSet) ___form).seq()))))))
                        )
                        (ß ___form instanceof ISeq || ___form instanceof IPersistentList)
                        (do
                            (let [#_"ISeq" ___seq (ß RT'seq(___form))]
                                (if (nil? ___seq)
                                    (do
                                        (§ ass ___ret (ß RT'cons(LIST, nil)))
                                    )
                                    (do
                                        (§ ass ___ret (ß RT'list(SEQ, RT'cons(CONCAT, sqExpandList(___seq)))))
                                    )
                                )
                            )
                        )
                        :else
                        (do
                            (throw (UnsupportedOperationException. "Unknown Collection type"))
                        )
                    )
                )
                (ß ___form instanceof Keyword || ___form instanceof Number || ___form instanceof Character || ___form instanceof String)
                (do
                    (§ ass ___ret ___form)
                )
                :else
                (do
                    (§ ass ___ret (ß RT'list(Compiler'QUOTE, ___form)))
                )
            )

            (when (ß ___form instanceof IObj && RT'meta(___form) != nil)
                ;; filter line and column numbers
                (let [#_"IPersistentMap" ___newMeta (ß ((IObj) ___form).meta().without(RT'LINE_KEY).without(RT'COLUMN_KEY))]
                    (when (ß ___newMeta.count() > 0)
                        (§ return (ß RT'list(WITH_META, ___ret, syntaxQuote(((IObj) ___form).meta()))))
                    )
                )
            )
            ret
        )
    )

    (§ defn- #_"ISeq" SyntaxQuoteReader'sqExpandList [#_"ISeq" ___seq]
        (let [#_"PersistentVector" ___ret (ß PersistentVector'EMPTY)]
            (loop-when-recur [(ß )] (some? ___seq) [(§ ass ___seq (ß ___seq.next()))]
                (let [#_"Object" ___item (ß ___seq.first())]
                    (cond (ß isUnquote(___item))
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'list(LIST, RT'second(___item)))))
                        )
                        (ß isUnquoteSplicing(___item))
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'second(___item))))
                        )
                        :else
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'list(LIST, syntaxQuote(___item)))))
                        )
                    )
                )
            )
            (ß ___ret.seq())
        )
    )

    (§ defn- #_"IPersistentVector" SyntaxQuoteReader'flattenMap [#_"Object" ___form]
        (let [#_"IPersistentVector" ___keyvals (ß PersistentVector'EMPTY)]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___form)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (let [#_"IMapEntry" ___e (ß (IMapEntry) ___s.first())]
                    (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___e.key())))
                    (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___e.val())))
                )
            )
            keyvals
        )
    )
)

#_stateless
(class-ns UnquoteReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"UnquoteReader" this, #_"Object" ___reader, #_"Object" ___comma, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß read1(___r))]
                (when (ß ___ch == -1)
                    (throw (ß Util'runtimeException("EOF while reading character")))
                )
                (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                (if (ß ___ch == \@)
                    (do
                        (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                            (ß RT'list(UNQUOTE_SPLICING, ___o))
                        )
                    )
                    (do
                        (ß unread(___r, ___ch))
                        (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                            (ß RT'list(UNQUOTE, ___o))
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns LispCharacterReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispCharacterReader" this, #_"Object" ___reader, #_"Object" ___backslash, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß read1(___r))]
                (when (ß ___ch == -1)
                    (throw (ß Util'runtimeException("EOF while reading character")))
                )
                (let [#_"String" ___token (ß readToken(___r, (char) ___ch))]
                    (cond (ß ___token.length() == 1)
                        (do
                            (§ return (ß Character/valueOf(___token.charAt(0))))
                        )
                        (ß ___token.equals("newline"))
                        (do
                            (§ return (ß \newline))
                        )
                        (ß ___token.equals("space"))
                        (do
                            (§ return (ß \space))
                        )
                        (ß ___token.equals("tab"))
                        (do
                            (§ return (ß \tab))
                        )
                        (ß ___token.equals("backspace"))
                        (do
                            (§ return (ß \backspace))
                        )
                        (ß ___token.equals("formfeed"))
                        (do
                            (§ return (ß \formfeed))
                        )
                        (ß ___token.equals("return"))
                        (do
                            (§ return (ß \return))
                        )
                        (ß ___token.startsWith("u"))
                        (do
                            (let [#_"char" ___c (ß (char) readUnicodeChar(___token, 1, 4, 16))]
                                (when (ß ___c >= (§ char "\ud800") && ___c <= (§ char "\udfff")) ;; surrogate code unit?
                                    (throw (ß Util'runtimeException("Invalid character constant: \\u" + Integer/toString(___c, 16))))
                                )
                                (§ return ___c)
                            )
                        )
                        (ß ___token.startsWith("o"))
                        (do
                            (let [#_"int" ___len (ß ___token.length() - 1)]
                                (when (ß ___len > 3)
                                    (throw (ß Util'runtimeException("Invalid octal escape sequence length: " + ___len)))
                                )
                                (let [#_"int" ___uc (ß readUnicodeChar(___token, 1, ___len, 8))]
                                    (when (ß ___uc > 0377)
                                        (throw (ß Util'runtimeException("Octal escape sequence must be in range [0, 377].")))
                                    )
                                    (§ return (ß (char) ___uc))
                                )
                            )
                        )
                    )
                    (throw (ß Util'runtimeException("Unsupported character: \\" + ___token)))
                )
            )
        )
    )
)

#_stateless
(class-ns LispListReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispListReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
                        (§ ass ___column (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()-1))
                    )
                    (let [#_"List" ___list (ß readDelimitedList(\), ___r, true, ___opts, ensurePending(___pendingForms)))]
                        (when (ß ___list.isEmpty())
                            (§ return (ß PersistentList'EMPTY))
                        )
                        (let [#_"IObj" ___s (ß (IObj) PersistentList'create(___list))]
                            (if (ß ___line != -1)
                                (do
                                    (ß ___s.withMeta(RT'map(RT'LINE_KEY, ___line, RT'COLUMN_KEY, ___column)))
                                )
                                (do
                                    ___s
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns EvalReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"EvalReader" this, #_"Object" ___reader, #_"Object" ___eq, #_"Object" ___opts, #_"Object" ___pendingForms]
        (when (ß !RT'booleanCast(RT'READEVAL.deref()))
            (throw (ß Util'runtimeException("EvalReader not allowed when *read-eval* is false.")))
        )

        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (cond (ß ___o instanceof Symbol)
                    (do
                        (ß RT'classForName(___o.toString()))
                    )
                    (ß ___o instanceof IPersistentList)
                    (do
                        (let [#_"Symbol" ___fs (ß (Symbol) RT'first(___o))]
                            (when (ß ___fs.equals(THE_VAR))
                                (let [#_"Symbol" ___vs (ß (Symbol) RT'second(___o))]
                                    (§ return (ß RT'var(___vs.ns, ___vs.name)))
                                )
                            )
                            (when (ß ___fs.name.endsWith("."))
                                (let [#_"Object[]" ___args (ß RT'toArray(RT'next(___o)))]
                                    (§ return (ß Reflector'invokeConstructor(RT'classForName(___fs.name.substring(0, ___fs.name.length() - 1)), ___args)))
                                )
                            )
                            (when (ß Compiler'namesStaticMember(___fs))
                                (let [#_"Object[]" ___args (ß RT'toArray(RT'next(___o)))]
                                    (§ return (ß Reflector'invokeStaticMethod(___fs.ns, ___fs.name, ___args)))
                                )
                            )
                            (let [#_"Object" ___v (ß Compiler'maybeResolveIn(Compiler'currentNS(), ___fs))]
                                (when (ß ___v instanceof Var)
                                    (§ return (ß ((IFn) ___v).applyTo(RT'next(___o))))
                                )
                                (throw (ß Util'runtimeException("Can't resolve " + ___fs)))
                            )
                        )
                    )
                    :else
                    (do
                        (throw (IllegalArgumentException. "Unsupported #= form"))
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns LispVectorReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispVectorReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß LazilyPersistentVector'create(readDelimitedList(\], ___r, true, ___opts, ensurePending(___pendingForms))))
        )
    )
)

#_stateless
(class-ns LispMapReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispMapReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object[]" ___a (ß readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms)).toArray())]
                (when (ß (___a.length & 1) == 1)
                    (throw (ß Util'runtimeException("Map literal must contain an even number of forms")))
                )
                (ß RT'map(___a))
            )
        )
    )
)

#_stateless
(class-ns LispSetReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispSetReader" this, #_"Object" ___reader, #_"Object" ___leftbracket, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß PersistentHashSet'createWithCheck(readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms))))
        )
    )
)

#_stateless
(class-ns LispUnmatchedDelimiterReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispUnmatchedDelimiterReader" this, #_"Object" ___reader, #_"Object" ___rightdelim, #_"Object" ___opts, #_"Object" ___pendingForms]
        (throw (ß Util'runtimeException("Unmatched delimiter: " + ___rightdelim)))
    )
)

#_stateless
(class-ns LispUnreadableReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"LispUnreadableReader" this, #_"Object" ___reader, #_"Object" ___leftangle, #_"Object" ___opts, #_"Object" ___pendingForms]
        (throw (ß Util'runtimeException("Unreadable form")))
    )
)

#_stateless
(class-ns CtorReader (§ extends AFn)
    #_method
    (§ defn #_"Object" invoke [#_"CtorReader" this, #_"Object" ___reader, #_"Object" ___firstChar, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
            (let [#_"Object" ___name (ß read(___r, true, nil, false, ___opts, ___pendingForms))]
                (when (ß !(___name instanceof Symbol))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" ___sym (ß (Symbol)___name)]
                    (let [#_"Object" ___form (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                        (if (ß isPreserveReadCond(___opts) || RT'suppressRead())
                            (do
                                (ß TaggedLiteral'create(___sym, ___form))
                            )
                            (do
                                (ß ___sym.getName().contains(".") ? readRecord(___form, ___sym, ___opts, ___pendingForms) :or readTagged(___form, ___sym, ___opts, ___pendingForms))
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" readTagged [#_"CtorReader" this, #_"Object" ___o, #_"Symbol" ___tag, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"ILookup" ___data_readers (ß (ILookup)RT'DATA_READERS.deref())]
            (let [#_"IFn" ___data_reader (ß (IFn)RT'get(___data_readers, ___tag))]
                (when (nil? ___data_reader)
                    (§ ass ___data_readers (ß (ILookup)RT'DEFAULT_DATA_READERS.deref()))
                    (§ ass ___data_reader (ß (IFn)RT'get(___data_readers, ___tag)))
                    (when (nil? ___data_reader)
                        (let [#_"IFn" ___default_reader (ß (IFn)RT'DEFAULT_DATA_READER_FN.deref())]
                            (if (some? ___default_reader)
                                (do
                                    (§ return (ß ___default_reader.invoke(___tag, ___o)))
                                )
                                (do
                                    (throw (ß new RuntimeException("No reader function for tag " + ___tag.toString())))
                                )
                            )
                        )
                    )
                )

                (ß ___data_reader.invoke(___o))
            )
        )
    )

    #_method
    (§ defn- #_"Object" readRecord [#_"CtorReader" this, #_"Object" ___form, #_"Symbol" ___recordName, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"boolean" ___readeval (ß RT'booleanCast(RT'READEVAL.deref()))]
            (when (ß !___readeval)
                (throw (ß Util'runtimeException("Record construction syntax can only be used when *read-eval* == true")))
            )

            (let [#_"Class" ___recordClass (ß RT'classForNameNonLoading(___recordName.toString()))]
                (let [#_"boolean" ___shortForm true]
                    (cond (ß ___form instanceof IPersistentMap)
                        (do
                            (§ ass ___shortForm false)
                        )
                        (ß ___form instanceof IPersistentVector)
                        (do
                            (§ ass ___shortForm true)
                        )
                        :else
                        (do
                            (throw (ß Util'runtimeException("Unreadable constructor form starting with \"#" + ___recordName + "\"")))
                        )
                    )

                    (let [#_"Object" ___ret nil]
                        (let [#_"Constructor[]" ___allctors (ß ((Class)___recordClass).getConstructors())]
                            (if ___shortForm
                                (do
                                    (let [#_"IPersistentVector" ___recordEntries (ß (IPersistentVector)___form)]
                                        (let [#_"boolean" ___ctorFound false]
                                            (doseq [#_"Constructor" ___ctor ___allctors]
                                                (when (ß ___ctor.getParameterTypes().length == ___recordEntries.count())
                                                    (§ ass ___ctorFound true)
                                                )
                                            )

                                            (when (ß !___ctorFound)
                                                (throw (ß Util'runtimeException("Unexpected number of constructor arguments to " + ___recordClass.toString() + ": got " + ___recordEntries.count())))
                                            )

                                            (§ ass ___ret (ß Reflector'invokeConstructor(___recordClass, RT'toArray(___recordEntries))))
                                        )
                                    )
                                )
                                (do
                                    (let [#_"IPersistentMap" ___vals (ß (IPersistentMap)___form)]
                                        (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'keys(___vals)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                            (when (ß !(___s.first() instanceof Keyword))
                                                (throw (ß Util'runtimeException("Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " + ___s.first().toString())))
                                            )
                                        )
                                        (§ ass ___ret (ß Reflector'invokeStaticMethod(___recordClass, "create", new Object[] (§ array ___vals ))))
                                    )
                                )
                            )

                            ___ret
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns ConditionalReader (§ extends AFn)
    (§ def- #_"Object" ConditionalReader'READ_STARTED (Object.))
    (§ def #_"Keyword" ConditionalReader'DEFAULT_FEATURE (ß Keyword'intern(nil, "default")))
    (§ def #_"IPersistentSet" ConditionalReader'RESERVED_FEATURES (ß RT'set(Keyword'intern(nil, "else"), Keyword'intern(nil, "none"))))

    (§ defn #_"boolean" ConditionalReader'hasFeature [#_"Object" ___feature, #_"Object" ___opts]
        (when (ß !(___feature instanceof Keyword))
            (throw (ß Util'runtimeException("Feature should be a keyword: " + ___feature)))
        )

        (when (ß DEFAULT_FEATURE.equals(___feature))
            (§ return true)
        )

        (let [#_"IPersistentSet" ___custom (ß (IPersistentSet) ((IPersistentMap)___opts).valAt(OPT_FEATURES))]
            (ß (___custom != nil && ___custom.contains(___feature)))
        )
    )

    (§ defn #_"Object" ConditionalReader'readCondDelimited [#_"PushbackReader" ___r, #_"boolean" ___splicing, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"Object" ___result READ_STARTED]
            (§ let [#_"Object" ___form] ;; The most recently ready form
                (let [#_"boolean" ___toplevel (ß (___pendingForms == nil))]
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))

                    (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) ___r).getLineNumber() :or -1)]
                        (while true
                            (when (ß ___result == READ_STARTED)
                                ;; Read the next feature
                                (§ ass ___form (ß read(___r, false, READ_EOF, \), READ_FINISHED, true, ___opts, ___pendingForms, nil)))

                                (cond (ß ___form == READ_EOF)
                                    (do
                                        (if (ß ___firstline < 0)
                                            (do
                                                (throw (ß Util'runtimeException("EOF while reading")))
                                            )
                                            (do
                                                (throw (ß Util'runtimeException("EOF while reading, starting at line " + ___firstline)))
                                            )
                                        )
                                    )
                                    (ß ___form == READ_FINISHED)
                                    (do
                                        (§ break ) ;; read-cond form is done
                                    )
                                )

                                (when (ß RESERVED_FEATURES.contains(___form))
                                    (throw (ß Util'runtimeException("Feature name " + ___form + " is reserved.")))
                                )

                                (when (ß hasFeature(___form, ___opts))
                                    ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                                    (§ ass ___form (ß read(___r, false, READ_EOF, \), READ_FINISHED, true, ___opts, ___pendingForms, (Resolver) RT'READER_RESOLVER.deref())))

                                    (cond (ß ___form == READ_EOF)
                                        (do
                                            (if (ß ___firstline < 0)
                                                (do
                                                    (throw (ß Util'runtimeException("EOF while reading")))
                                                )
                                                (do
                                                    (throw (ß Util'runtimeException("EOF while reading, starting at line " + ___firstline)))
                                                )
                                            )
                                        )
                                        (ß ___form == READ_FINISHED)
                                        (do
                                            (if (ß ___firstline < 0)
                                                (do
                                                    (throw (ß Util'runtimeException("read-cond requires an even number of forms.")))
                                                )
                                                (do
                                                    (throw (ß Util'runtimeException("read-cond starting on line " + ___firstline + " requires an even number of forms")))
                                                )
                                            )
                                        )
                                        :else
                                        (do
                                            (§ ass ___result ___form)
                                        )
                                    )
                                )
                            )

                            ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                            (try
                                (ß Var'pushThreadBindings(RT'map(RT'SUPPRESS_READ, RT'T)))
                                (§ ass ___form (ß read(___r, false, READ_EOF, \), READ_FINISHED, true, ___opts, ___pendingForms, (Resolver) RT'READER_RESOLVER.deref())))

                                (cond (ß ___form == READ_EOF)
                                    (do
                                        (if (ß ___firstline < 0)
                                            (do
                                                (throw (ß Util'runtimeException("EOF while reading")))
                                            )
                                            (do
                                                (throw (ß Util'runtimeException("EOF while reading, starting at line " + ___firstline)))
                                            )
                                        )
                                    )
                                    (ß ___form == READ_FINISHED)
                                    (do
                                        (§ break )
                                    )
                                )
                                (finally
                                    (ß Var'popThreadBindings())
                                )
                            )
                        )

                        (when (ß ___result == READ_STARTED) ;; no features matched
                            (§ return ___r)
                        )

                        (if ___splicing
                            (do
                                (when (ß !(___result instanceof List))
                                    (throw (ß Util'runtimeException("Spliced form list in read-cond-splicing must implement java.util.List")))
                                )

                                (when ___toplevel
                                    (throw (ß Util'runtimeException("Reader conditional splicing not allowed at the top level.")))
                                )

                                (ß ((List)___pendingForms).addAll(0, (List)___result))

                                ___r
                            )
                            (do
                                ___result
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"void" ConditionalReader'checkConditionalAllowed [#_"Object" ___opts]
        (let [#_"IPersistentMap" ___mopts (ß (IPersistentMap)___opts)]
            (when (ß !(___opts != nil && (COND_ALLOW.equals(___mopts.valAt(OPT_READ_COND)) || COND_PRESERVE.equals(___mopts.valAt(OPT_READ_COND)))))
                (throw (ß Util'runtimeException("Conditional read not allowed")))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"ConditionalReader" this, #_"Object" ___reader, #_"Object" ___mode, #_"Object" ___opts, #_"Object" ___pendingForms]
        (ß ConditionalReader'checkConditionalAllowed(___opts))

        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß read1(___r))]
                (when (ß ___ch == -1)
                    (throw (ß Util'runtimeException("EOF while reading character")))
                )

                (let [#_"boolean" ___splicing false]
                    (when (ß ___ch == \@)
                        (§ ass ___splicing true)
                        (§ ass ___ch (ß read1(___r)))
                    )

                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (throw (ß Util'runtimeException("EOF while reading character")))
                    )

                    (when (ß ___ch != \()
                        (throw (ß Util'runtimeException("read-cond body must be a list")))
                    )

                    (try
                        (ß Var'pushThreadBindings(RT'map(READ_COND_ENV, RT'T)))

                        (if (ß isPreserveReadCond(___opts))
                            (do
                                (let [#_"IFn" ___listReader (ß getMacro(___ch))] ;; should always be a list
                                    (let [#_"Object" ___form (ß ___listReader.invoke(___r, ___ch, ___opts, ensurePending(___pendingForms)))]
                                        (ß ReaderConditional'create(___form, ___splicing))
                                    )
                                )
                            )
                            (do
                                (ß readCondDelimited(___r, ___splicing, ___opts, ___pendingForms))
                            )
                        )
                        (finally
                            (ß Var'popThreadBindings())
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns LispReader
    (§ def #_"Symbol" LispReader'QUOTE (ß Symbol'intern("quote")))
    (§ def #_"Symbol" LispReader'THE_VAR (ß Symbol'intern("var")))

    (§ def #_"Symbol" LispReader'UNQUOTE (ß Symbol'intern("cloiure.core", "unquote")))
    (§ def #_"Symbol" LispReader'UNQUOTE_SPLICING (ß Symbol'intern("cloiure.core", "unquote-splicing")))
    (§ def #_"Symbol" LispReader'CONCAT (ß Symbol'intern("cloiure.core", "concat")))
    (§ def #_"Symbol" LispReader'SEQ (ß Symbol'intern("cloiure.core", "seq")))
    (§ def #_"Symbol" LispReader'LIST (ß Symbol'intern("cloiure.core", "list")))
    (§ def #_"Symbol" LispReader'APPLY (ß Symbol'intern("cloiure.core", "apply")))
    (§ def #_"Symbol" LispReader'HASHMAP (ß Symbol'intern("cloiure.core", "hash-map")))
    (§ def #_"Symbol" LispReader'HASHSET (ß Symbol'intern("cloiure.core", "hash-set")))
    (§ def #_"Symbol" LispReader'VECTOR (ß Symbol'intern("cloiure.core", "vector")))
    (§ def #_"Symbol" LispReader'WITH_META (ß Symbol'intern("cloiure.core", "with-meta")))
    (§ def #_"Symbol" LispReader'META (ß Symbol'intern("cloiure.core", "meta")))
    (§ def #_"Symbol" LispReader'DEREF (ß Symbol'intern("cloiure.core", "deref")))
    (§ def #_"Symbol" LispReader'READ_COND (ß Symbol'intern("cloiure.core", "read-cond")))
    (§ def #_"Symbol" LispReader'READ_COND_SPLICING (ß Symbol'intern("cloiure.core", "read-cond-splicing")))
    (§ def #_"Keyword" LispReader'UNKNOWN (ß Keyword'intern(nil, "unknown")))

    (§ def #_"IFn[]" LispReader'macros (ß new IFn[256]))
    (§ def #_"IFn[]" LispReader'dispatchMacros (ß new IFn[256]))

    (§ def #_"Pattern" LispReader'symbolPat (ß Pattern/compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")))
    (§ def #_"Pattern" LispReader'intPat (ß Pattern/compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")))
    (§ def #_"Pattern" LispReader'ratioPat (ß Pattern/compile("([-+]?[0-9]+)/([0-9]+)")))
    (§ def #_"Pattern" LispReader'floatPat (ß Pattern/compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")))

    ;; symbol->gensymbol
    (§ def #_"Var" LispReader'GENSYM_ENV (ß Var'create(nil).setDynamic()))
    ;; sorted-map num->gensymbol
    (§ def #_"Var" LispReader'ARG_ENV (ß Var'create(nil).setDynamic()))
    (§ def #_"IFn" LispReader'ctorReader (CtorReader.))

    ;; Dynamic var set to true in a read-cond context
    (§ def #_"Var" LispReader'READ_COND_ENV (ß Var'create(nil).setDynamic()))

    (§ static
        (§ ass (ß macros[\"]) (LispStringReader.)) ;; oops! "
        (§ ass (ß macros[\;]) (LispCommentReader.))
        (§ ass (ß macros[\']) (WrappingReader. QUOTE))
        (§ ass (ß macros[\@]) (WrappingReader. DEREF))
        (§ ass (ß macros[\^]) (LispMetaReader.))
        (§ ass (ß macros[\`]) (SyntaxQuoteReader.))
        (§ ass (ß macros[\~]) (UnquoteReader.))
        (§ ass (ß macros[\(]) (LispListReader.))
        (§ ass (ß macros[\)]) (LispUnmatchedDelimiterReader.))
        (§ ass (ß macros[\[]) (LispVectorReader.))
        (§ ass (ß macros[\]]) (LispUnmatchedDelimiterReader.))
        (§ ass (ß macros[\{]) (LispMapReader.))
        (§ ass (ß macros[\}]) (LispUnmatchedDelimiterReader.))
        (§ ass (ß macros[\\]) (LispCharacterReader.))
        (§ ass (ß macros[\%]) (ArgReader.))
        (§ ass (ß macros[\#]) (LispDispatchReader.))

        (§ ass (ß dispatchMacros[\^]) (LispMetaReader.))
        (§ ass (ß dispatchMacros[\#]) (LispSymbolicValueReader.))
        (§ ass (ß dispatchMacros[\']) (VarReader.))
        (§ ass (ß dispatchMacros[\"]) (RegexReader.)) ;; oops! "
        (§ ass (ß dispatchMacros[\(]) (FnReader.))
        (§ ass (ß dispatchMacros[\{]) (LispSetReader.))
        (§ ass (ß dispatchMacros[\=]) (EvalReader.))
        (§ ass (ß dispatchMacros[\!]) (LispCommentReader.))
        (§ ass (ß dispatchMacros[\<]) (LispUnreadableReader.))
        (§ ass (ß dispatchMacros[\_]) (LispDiscardReader.))
        (§ ass (ß dispatchMacros[\?]) (ConditionalReader.))
        (§ ass (ß dispatchMacros[\:]) (LispNamespaceMapReader.))
    )

    (§ defn #_"boolean" LispReader'isWhitespace [#_"int" ___ch]
        (ß (Character/isWhitespace(___ch) || ___ch == \,))
    )

    (§ defn #_"void" LispReader'unread [#_"PushbackReader" ___r, #_"int" ___ch]
        (when (ß ___ch != -1)
            (try
                (ß ___r.unread(___ch))
                (catch IOException ___e
                    (throw (ß Util'sneakyThrow(___e)))
                )
            )
        )
        nil
    )

    (§ defn #_"int" LispReader'read1 [#_"Reader" ___r]
        (try
            (ß ___r.read())
            (catch IOException ___e
                (throw (ß Util'sneakyThrow(___e)))
            )
        )
    )

    ;; Reader opts
    (§ def #_"Keyword" LispReader'OPT_EOF (ß Keyword'intern(nil, "eof")))
    (§ def #_"Keyword" LispReader'OPT_FEATURES (ß Keyword'intern(nil, "features")))
    (§ def #_"Keyword" LispReader'OPT_READ_COND (ß Keyword'intern(nil, "read-cond")))

    ;; EOF special value to throw on eof
    (§ def #_"Keyword" LispReader'EOFTHROW (ß Keyword'intern(nil, "eofthrow")))

    ;; Platform features - always installed
    (§ def- #_"Keyword" LispReader'PLATFORM_KEY (ß Keyword'intern(nil, "cli")))
    (§ def- #_"Object" LispReader'PLATFORM_FEATURES (ß PersistentHashSet'create(PLATFORM_KEY)))

    ;; Reader conditional options - use with :read-cond
    (§ def #_"Keyword" LispReader'COND_ALLOW (ß Keyword'intern(nil, "allow")))
    (§ def #_"Keyword" LispReader'COND_PRESERVE (ß Keyword'intern(nil, "preserve")))

    (§ defn #_"Object" LispReader'read [#_"PushbackReader" ___r, #_"Object" ___opts]
        (let [#_"boolean" ___eofIsError true]
            (let [#_"Object" ___eofValue nil]
                (when (ß ___opts != nil && ___opts instanceof IPersistentMap)
                    (let [#_"Object" ___eof (ß ((IPersistentMap)___opts).valAt(OPT_EOF, EOFTHROW))]
                        (when (ß !EOFTHROW.equals(___eof))
                            (§ ass ___eofIsError false)
                            (§ ass ___eofValue ___eof)
                        )
                    )
                )
                (ß read(___r, ___eofIsError, ___eofValue, false, ___opts))
            )
        )
    )

    (§ defn #_"Object" LispReader'read [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive]
        (ß read(___r, ___eofIsError, ___eofValue, ___isRecursive, PersistentHashMap'EMPTY))
    )

    (§ defn #_"Object" LispReader'read [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (ß read(___r, ___eofIsError, ___eofValue, nil, nil, ___isRecursive, ___opts, nil, (Resolver) RT'READER_RESOLVER.deref()))
    )

    (§ defn- #_"Object" LispReader'read [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms]
        (ß read(___r, ___eofIsError, ___eofValue, nil, nil, ___isRecursive, ___opts, ensurePending(___pendingForms), (Resolver) RT'READER_RESOLVER.deref()))
    )

    (§ defn- #_"Object" LispReader'ensurePending [#_"Object" ___pendingForms]
        (if (nil? ___pendingForms)
            (do
                (LinkedList.)
            )
            (do
                ___pendingForms
            )
        )
    )

    (§ defn- #_"Object" LispReader'installPlatformFeature [#_"Object" ___opts]
        (if (nil? ___opts)
            (do
                (ß RT'mapUniqueKeys(LispReader'OPT_FEATURES, PLATFORM_FEATURES))
            )
            (do
                (let [#_"IPersistentMap" ___mopts (ß (IPersistentMap) ___opts)]
                    (let [#_"Object" ___features (ß ___mopts.valAt(OPT_FEATURES))]
                        (if (nil? ___features)
                            (do
                                (ß ___mopts.assoc(LispReader'OPT_FEATURES, PLATFORM_FEATURES))
                            )
                            (do
                                (ß ___mopts.assoc(LispReader'OPT_FEATURES, RT'conj((IPersistentSet) ___features, PLATFORM_KEY)))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn- #_"Object" LispReader'read [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"Character" ___returnOn, #_"Object" ___returnOnValue, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms, #_"Resolver" ___resolver]
        (when (ß RT'READEVAL.deref() == UNKNOWN)
            (throw (ß Util'runtimeException("Reading disallowed - *read-eval* bound to :unknown")))
        )

        (§ ass ___opts (ß installPlatformFeature(___opts)))

        (try
            (while true
                (when (ß ___pendingForms instanceof List && !((List)___pendingForms).isEmpty())
                    (§ return (ß ((List)___pendingForms).remove(0)))
                )

                (let [#_"int" ___ch (ß read1(___r))]
                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (when ___eofIsError
                            (throw (ß Util'runtimeException("EOF while reading")))
                        )
                        (§ return ___eofValue)
                    )

                    (when (ß ___returnOn != nil && (___returnOn.charValue() == ___ch))
                        (§ return ___returnOnValue)
                    )

                    (when (ß Character/isDigit(___ch))
                        (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                            (§ return ___n)
                        )
                    )

                    (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                        (when (some? ___macroFn)
                            (let [#_"Object" ___ret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts, ___pendingForms))]
                                ;; no op macros return the reader
                                (when (ß ___ret == ___r)
                                    (§ continue )
                                )
                                (§ return ___ret)
                            )
                        )

                        (when (ß ___ch == \+ || ___ch == \-)
                            (let [#_"int" ___ch2 (ß read1(___r))]
                                (when (ß Character/isDigit(___ch2))
                                    (ß unread(___r, ___ch2))
                                    (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                                        (§ return ___n)
                                    )
                                )
                                (ß unread(___r, ___ch2))
                            )
                        )

                        (let [#_"String" ___token (ß readToken(___r, (char) ___ch))]
                            (§ return (ß interpretToken(___token, ___resolver)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (when (ß ___isRecursive || !(___r instanceof LineNumberingPushbackReader))
                    (throw (ß Util'sneakyThrow(___e)))
                )
                (let [#_"LineNumberingPushbackReader" ___rdr (ß (LineNumberingPushbackReader) ___r)]
                    (throw (ß new LispReaderException(___rdr.getLineNumber(), ___rdr.getColumnNumber(), ___e)))
                )
            )
        )
    )

    (§ defn- #_"String" LispReader'readToken [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (ß ___sb.append(___initch))

            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                        (ß unread(___r, ___ch))
                        (§ return (ß ___sb.toString()))
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )
        )
    )

    (§ defn- #_"Object" LispReader'readNumber [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (ß ___sb.append(___initch))

            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || isMacro(___ch))
                        (ß unread(___r, ___ch))
                        (§ break )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )

            (let [#_"String" ___s (ß ___sb.toString())]
                (let [#_"Object" ___n (ß matchNumber(___s))]
                    (when (nil? ___n)
                        (throw (NumberFormatException. (ß "Invalid number: " + ___s)))
                    )
                    n
                )
            )
        )
    )

    (§ defn- #_"int" LispReader'readUnicodeChar [#_"String" ___token, #_"int" ___offset, #_"int" ___length, #_"int" ___base]
        (when (ß ___token.length() != ___offset + ___length)
            (throw (IllegalArgumentException. (ß "Invalid unicode character: \\" + ___token)))
        )
        (let [#_"int" ___uc 0]
            (loop-when-recur [(§ var #_"int" ___i ___offset)] (ß ___i < ___offset + ___length) [(§ ass ___i (ß ___i + 1))]
                (let [#_"int" ___d (ß Character/digit(___token.charAt(___i), ___base))]
                    (when (ß ___d == -1)
                        (throw (ß new IllegalArgumentException("Invalid digit: " + ___token.charAt(___i))))
                    )
                    (§ ass ___uc (ß ___uc * ___base + ___d))
                )
            )
            (ß (char) ___uc)
        )
    )

    (§ defn- #_"int" LispReader'readUnicodeChar [#_"PushbackReader" ___r, #_"int" ___initch, #_"int" ___base, #_"int" ___length, #_"boolean" ___exact]
        (let [#_"int" ___uc (ß Character/digit(___initch, ___base))]
            (when (ß ___uc == -1)
                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ___initch)))
            )
            (let [#_"int" ___i 1]
                (loop-when-recur [(ß )] (ß ___i < ___length) [(§ ass ___i (ß ___i + 1))]
                    (let [#_"int" ___ch (ß read1(___r))]
                        (when (ß ___ch == -1 || isWhitespace(___ch) || isMacro(___ch))
                            (ß unread(___r, ___ch))
                            (§ break )
                        )
                        (let [#_"int" ___d (ß Character/digit(___ch, ___base))]
                            (when (ß ___d == -1)
                                (throw (ß new IllegalArgumentException("Invalid digit: " + (char) ___ch)))
                            )
                            (§ ass ___uc (ß ___uc * ___base + ___d))
                        )
                    )
                )
                (when (ß ___i != ___length && ___exact)
                    (throw (ß new IllegalArgumentException("Invalid character length: " + ___i + ", should be: " + ___length)))
                )
                ___uc
            )
        )
    )

    (§ defn- #_"Object" LispReader'interpretToken [#_"String" ___s, #_"Resolver" ___resolver]
        (cond (ß ___s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß ___s.equals("true"))
            (do
                (§ return (ß RT'T))
            )
            (ß ___s.equals("false"))
            (do
                (§ return (ß RT'F))
            )
        )
        (let [#_"Object" ___ret nil]
            (§ ass ___ret (ß matchSymbol(___s, ___resolver)))
            (when (some? ___ret)
                (§ return ___ret)
            )

            (throw (ß Util'runtimeException("Invalid token: " + ___s)))
        )
    )

    (§ defn- #_"Object" LispReader'matchSymbol [#_"String" ___s, #_"Resolver" ___resolver]
        (let [#_"Matcher" ___m (ß symbolPat.matcher(___s))]
            (when (ß ___m.matches())
                (let [#_"int" ___gc (ß ___m.groupCount())]
                    (let [#_"String" ___ns (ß ___m.group(1))]
                        (let [#_"String" ___name (ß ___m.group(2))]
                            (when (ß ___ns != nil && ___ns.endsWith(":/") || ___name.endsWith(":") || ___s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß ___s.startsWith("::"))
                                (let [#_"Symbol" ___ks (ß Symbol'intern(___s.substring(2)))]
                                    (if (some? ___resolver)
                                        (do
                                            (§ let [#_"Symbol" ___nsym]
                                                (if (ß ___ks.ns != nil)
                                                    (do
                                                        (§ ass ___nsym (ß ___resolver.resolveAlias(Symbol'intern(___ks.ns))))
                                                    )
                                                    (do
                                                        (§ ass ___nsym (ß ___resolver.currentNS()))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? ___nsym)
                                                    (do
                                                        (§ return (ß Keyword'intern(___nsym.name, ___ks.name)))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (§ let [#_"Namespace" ___kns]
                                                (if (ß ___ks.ns != nil)
                                                    (do
                                                        (§ ass ___kns (ß Compiler'currentNS().lookupAlias(Symbol'intern(___ks.ns))))
                                                    )
                                                    (do
                                                        (§ ass ___kns (ß Compiler'currentNS()))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? ___kns)
                                                    (do
                                                        (§ return (ß Keyword'intern(___kns.name.name, ___ks.name)))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (let [#_"boolean" ___isKeyword (ß (___s.charAt(0) == \:))]
                                (let [#_"Symbol" ___sym (ß Symbol'intern(___s.substring(___isKeyword ? 1 :or 0)))]
                                    (when ___isKeyword
                                        (§ return (ß Keyword'intern(___sym)))
                                    )
                                    (§ return ___sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (§ defn- #_"Object" LispReader'matchNumber [#_"String" ___s]
        (let [#_"Matcher" ___m (ß intPat.matcher(___s))]
            (when (ß ___m.matches())
                (when (ß ___m.group(2) != nil)
                    (when (ß ___m.group(8) != nil)
                        (§ return (ß BigInt'ZERO))
                    )
                    (§ return (ß Numbers'num(0)))
                )
                (let [#_"boolean" ___negate (ß ___m.group(1).equals("-"))]
                    (§ let [#_"String" ___n]
                        (let [#_"int" ___radix 10]
                            (cond (some? (§ ass ___n (ß ___m.group(3))))
                                (do
                                    (§ ass ___radix 10)
                                )
                                (some? (§ ass ___n (ß ___m.group(4))))
                                (do
                                    (§ ass ___radix 16)
                                )
                                (some? (§ ass ___n (ß ___m.group(5))))
                                (do
                                    (§ ass ___radix 8)
                                )
                                (some? (§ ass ___n (ß ___m.group(7))))
                                (do
                                    (§ ass ___radix (ß Integer/parseInt(___m.group(6))))
                                )
                            )
                            (when (nil? ___n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" ___bn (ß new BigInteger(___n, ___radix))]
                                (when ___negate
                                    (§ ass ___bn (ß ___bn.negate()))
                                )
                                (when (ß ___m.group(8) != nil)
                                    (§ return (ß BigInt'fromBigInteger(___bn)))
                                )
                                (§ return (ß (___bn.bitLength() < 64) ? Numbers'num(___bn.longValue()) :or BigInt'fromBigInteger(___bn)))
                            )
                        )
                    )
                )
            )
            (§ ass ___m (ß floatPat.matcher(___s)))
            (when (ß ___m.matches())
                (when (ß ___m.group(4) != nil)
                    (§ return (ß new BigDecimal(___m.group(1))))
                )
                (§ return (ß Double/parseDouble(___s)))
            )
            (§ ass ___m (ß ratioPat.matcher(___s)))
            (when (ß ___m.matches())
                (let [#_"String" ___numerator (ß ___m.group(1))]
                    (when (ß ___numerator.startsWith("+"))
                        (§ ass ___numerator (ß ___numerator.substring(1)))
                    )
                    (§ return (ß Numbers'divide(Numbers'reduceBigInt(BigInt'fromBigInteger(new BigInteger(___numerator))), Numbers'reduceBigInt(BigInt'fromBigInteger(new BigInteger(___m.group(2)))))))
                )
            )
            nil
        )
    )

    (§ defn- #_"IFn" LispReader'getMacro [#_"int" ___ch]
        (when (ß ___ch < macros.length)
            (§ return (ß macros[___ch]))
        )
        nil
    )

    (§ defn- #_"boolean" LispReader'isMacro [#_"int" ___ch]
        (ß (___ch < macros.length && macros[___ch] != nil))
    )

    (§ defn- #_"boolean" LispReader'isTerminatingMacro [#_"int" ___ch]
        (ß (___ch != \# && ___ch != \' && ___ch != \% && isMacro(___ch)))
    )

    (§ defn #_"Symbol" LispReader'garg [#_"int" ___n]
        (ß Symbol'intern(nil, ((___n == -1) ? "rest" :or ("p" + ___n)) + "__" + RT'nextID() + "#"))
    )

    (§ defn #_"Symbol" LispReader'registerArg [#_"int" ___n]
        (let [#_"PersistentTreeMap" ___argsyms (ß (PersistentTreeMap) ARG_ENV.deref())]
            (when (nil? ___argsyms)
                (throw (ß new IllegalStateException("arg literal not in #()")))
            )
            (let [#_"Symbol" ___ret (ß (Symbol) ___argsyms.valAt(___n))]
                (when (nil? ___ret)
                    (§ ass ___ret (ß garg(___n)))
                    (ß ARG_ENV.set(___argsyms.assoc(___n, ___ret)))
                )
                ret
            )
        )
    )

    (§ defn #_"boolean" LispReader'isUnquoteSplicing [#_"Object" ___form]
        (ß ___form instanceof ISeq && Util'equals(RT'first(___form), UNQUOTE_SPLICING))
    )

    (§ defn #_"boolean" LispReader'isUnquote [#_"Object" ___form]
        (ß ___form instanceof ISeq && Util'equals(RT'first(___form), UNQUOTE))
    )

    ;; Sentinel values for reading lists
    (§ def- #_"Object" LispReader'READ_EOF (Object.))
    (§ def- #_"Object" LispReader'READ_FINISHED (Object.))

    (§ defn #_"List" LispReader'readDelimitedList [#_"char" ___delim, #_"PushbackReader" ___r, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) ___r).getLineNumber() :or -1)]
            (let [#_"ArrayList" ___a (ArrayList.)]
                (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                    (while true
                        (let [#_"Object" ___form (ß read(___r, false, READ_EOF, ___delim, READ_FINISHED, ___isRecursive, ___opts, ___pendingForms, ___resolver))]
                            (cond (ß ___form == READ_EOF)
                                (do
                                    (if (ß ___firstline < 0)
                                        (do
                                            (throw (ß Util'runtimeException("EOF while reading")))
                                        )
                                        (do
                                            (throw (ß Util'runtimeException("EOF while reading, starting at line " + ___firstline)))
                                        )
                                    )
                                )
                                (ß ___form == READ_FINISHED)
                                (do
                                    (§ return ___a)
                                )
                            )

                            (ß ___a.add(___form))
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" LispReader'isPreserveReadCond [#_"Object" ___opts]
        (if (ß RT'booleanCast(READ_COND_ENV.deref()) && ___opts instanceof IPersistentMap)
            (do
                (let [#_"Object" ___readCond (ß ((IPersistentMap) ___opts).valAt(OPT_READ_COND))]
                    (ß COND_PRESERVE.equals(___readCond))
                )
            )
            (do
                false
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

#_stateless
(class-ns RetryEx (§ extends Error)
)

#_stateless
(class-ns AbortException (§ extends Exception)
)

(class-ns LockingTransactionInfo
    (§ init
        (§ field #_"AtomicInteger" status nil)
        (§ field #_"long" startPoint 0)
        (§ field #_"CountDownLatch" latch nil)
    )

    (§ constructor #_"LockingTransactionInfo" LockingTransactionInfo [#_"int" ___status, #_"long" ___startPoint]
        (let [this (ß super())]
            (§ ass (ß this.status) (AtomicInteger. ___status))
            (§ ass (ß this.startPoint) ___startPoint)
            (§ ass (ß this.latch) (CountDownLatch. 1))
            this
        )
    )

    #_method
    (§ defn #_"boolean" running [#_"LockingTransactionInfo" this]
        (let [#_"int" ___s (ß status.get())]
            (ß (___s == RUNNING || ___s == COMMITTING))
        )
    )
)

(class-ns CFn
    (§ init
        (§ field #_"IFn" fn nil)
        (§ field #_"ISeq" args nil)
    )

    (§ constructor #_"CFn" CFn [#_"IFn" ___fn, #_"ISeq" ___args]
        (let [this (ß super())]
            (§ ass (ß this.fn) ___fn)
            (§ ass (ß this.args) ___args)
            this
        )
    )
)

(class-ns Notify
    (§ init
        (§ field #_"Ref" ref nil)
        (§ field #_"Object" oldval nil)
        (§ field #_"Object" newval nil)
    )

    (§ constructor #_"Notify" Notify [#_"Ref" ___ref, #_"Object" ___oldval, #_"Object" ___newval]
        (let [this (ß super())]
            (§ ass (ß this.ref) ___ref)
            (§ ass (ß this.oldval) ___oldval)
            (§ ass (ß this.newval) ___newval)
            this
        )
    )
)

(class-ns LockingTransaction
    (§ def #_"int" LockingTransaction'RETRY_LIMIT 10000)
    (§ def #_"int" LockingTransaction'LOCK_WAIT_MSECS 100)
    (§ def #_"long" LockingTransaction'BARGE_WAIT_NANOS (ß 10 * 1000000))

    (§ def #_"int" LockingTransaction'RUNNING 0)
    (§ def #_"int" LockingTransaction'COMMITTING 1)
    (§ def #_"int" LockingTransaction'RETRY 2)
    (§ def #_"int" LockingTransaction'KILLED 3)
    (§ def #_"int" LockingTransaction'COMMITTED 4)

    (§ def #_"ThreadLocal<LockingTransaction>" LockingTransaction'transaction (ß new ThreadLocal<LockingTransaction>()))

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (§ def- #_"AtomicLong" LockingTransaction'lastPoint (AtomicLong.))

    (§ init
        (§ field #_"LockingTransactionInfo" info nil)
        (§ field #_"long" readPoint 0)
        (§ field #_"long" startPoint 0)
        (§ field #_"long" startTime 0)

        (§ field #_"RetryEx" retryex (RetryEx.))
        (§ field #_"ArrayList<AgentAction>" actions (ß new ArrayList<AgentAction>()))
        (§ field #_"HashMap<Ref, Object>" vals (ß new HashMap<Ref, Object>()))
        (§ field #_"HashSet<Ref>" sets (ß new HashSet<Ref>()))
        (§ field #_"TreeMap<Ref, ArrayList<CFn>>" commutes (ß new TreeMap<Ref, ArrayList<CFn>>()))

        (§ field #_"HashSet<Ref>" ensures (ß new HashSet<Ref>())) ;; all hold readLock
    )

    #_method
    (§ defn #_"void" getReadPoint [#_"LockingTransaction" this]
        (§ ass readPoint (ß lastPoint.incrementAndGet()))
        nil
    )

    #_method
    (§ defn #_"long" getCommitPoint [#_"LockingTransaction" this]
        (ß lastPoint.incrementAndGet())
    )

    #_method
    (§ defn #_"void" stop [#_"LockingTransaction" this, #_"int" ___status]
        (when (some? info)
            (§ sync info
                (ß info.status.set(___status))
                (ß info.latch.countDown())
            )
            (§ ass info nil)
            (ß vals.clear())
            (ß sets.clear())
            (ß commutes.clear())
        )
        nil
    )

    #_method
    (§ defn #_"void" tryWriteLock [#_"LockingTransaction" this, #_"Ref" ___ref]
        (try
            (when (ß !___ref.lock.writeLock().tryLock(LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS))
                (throw retryex)
            )
            (catch InterruptedException ___e
                (throw retryex)
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (§ defn #_"Object" lock [#_"LockingTransaction" this, #_"Ref" ___ref]
        ;; can't upgrade readLock, so release it
        (ß releaseIfEnsured(___ref))

        (let [#_"boolean" ___unlocked true]
            (try
                (ß tryWriteLock(___ref))
                (§ ass ___unlocked false)

                (when (ß ___ref.tvals != nil && ___ref.tvals.point > readPoint)
                    (throw retryex)
                )
                (let [#_"LockingTransactionInfo" ___refinfo (ß ___ref.tinfo)]
                    ;; write lock conflict
                    (when (ß ___refinfo != nil && ___refinfo != info && ___refinfo.running())
                        (when (ß !barge(___refinfo))
                            (ß ___ref.lock.writeLock().unlock())
                            (§ ass ___unlocked true)
                            (§ return (ß blockAndBail(___refinfo)))
                        )
                    )
                    (§ ass (ß ___ref.tinfo) info)
                    (ß (___ref.tvals == nil) ? nil :or ___ref.tvals.val)
                )
                (finally
                    (when (ß !___unlocked)
                        (ß ___ref.lock.writeLock().unlock())
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" blockAndBail [#_"LockingTransaction" this, #_"LockingTransactionInfo" ___refinfo]
        ;; stop prior to blocking
        (ß stop(RETRY))
        (try
            (ß ___refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS))
            (catch InterruptedException ___e
                ;; ignore
            )
        )
        (throw retryex)
    )

    #_method
    (§ defn- #_"void" releaseIfEnsured [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (ß ensures.contains(___ref))
            (ß ensures.remove(___ref))
            (ß ___ref.lock.readLock().unlock())
        )
        nil
    )

    #_method
    (§ defn #_"void" abort [#_"LockingTransaction" this] #_(§ throws AbortException)
        (ß stop(KILLED))
        (throw (AbortException.))
    )

    #_method
    (§ defn- #_"boolean" bargeTimeElapsed [#_"LockingTransaction" this]
        (ß (System/nanoTime() - startTime > BARGE_WAIT_NANOS))
    )

    #_method
    (§ defn- #_"boolean" barge [#_"LockingTransaction" this, #_"LockingTransactionInfo" ___refinfo]
        (let [#_"boolean" ___barged false]
            ;; if this transaction is older, try to abort the other
            (when (ß bargeTimeElapsed() && startPoint < ___refinfo.startPoint)
                (§ ass ___barged (ß ___refinfo.status.compareAndSet(RUNNING, KILLED)))
                (when ___barged
                    (ß ___refinfo.latch.countDown())
                )
            )
            barged
        )
    )

    (§ defn #_"LockingTransaction" LockingTransaction'getEx []
        (let [#_"LockingTransaction" ___t (ß transaction.get())]
            (when (ß ___t == nil || ___t.info == nil)
                (throw (IllegalStateException. "No transaction running"))
            )
            t
        )
    )

    (§ defn #_"boolean" LockingTransaction'isRunning []
        (ß (getRunning() != nil))
    )

    (§ defn #_"LockingTransaction" LockingTransaction'getRunning []
        (let [#_"LockingTransaction" ___t (ß transaction.get())]
            (when (ß ___t == nil || ___t.info == nil)
                (§ return nil)
            )
            t
        )
    )

    (§ defn #_"Object" LockingTransaction'runInTransaction [#_"Callable" ___fn] #_(§ throws Exception)
        (let [#_"LockingTransaction" ___t (ß transaction.get())]
            (§ let [#_"Object" ___ret]
                (if (nil? ___t)
                    (do
                        (ß transaction.set(§ ass ___t (LockingTransaction.)))
                        (try
                            (§ ass ___ret (ß ___t.run(___fn)))
                            (finally
                                (ß transaction.remove())
                            )
                        )
                    )
                    (do
                        (if (ß ___t.info != nil)
                            (do
                                (§ ass ___ret (ß ___fn.call()))
                            )
                            (do
                                (§ ass ___ret (ß ___t.run(___fn)))
                            )
                        )
                    )
                )

                ret
            )
        )
    )

    #_method
    (§ defn #_"Object" run [#_"LockingTransaction" this, #_"Callable" ___fn] #_(§ throws Exception)
        (let [#_"boolean" ___done false]
            (let [#_"Object" ___ret nil]
                (let [#_"ArrayList<Ref>" ___locked (ß new ArrayList<Ref>())]
                    (let [#_"ArrayList<Notify>" ___notify (ß new ArrayList<Notify>())]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß !___done && ___i < RETRY_LIMIT) [(§ ass ___i (ß ___i + 1))]
                            (try
                                (ß getReadPoint())
                                (when (ß ___i == 0)
                                    (§ ass startPoint readPoint)
                                    (§ ass startTime (ß System/nanoTime()))
                                )
                                (§ ass info (ß new LockingTransactionInfo(RUNNING, startPoint)))
                                (§ ass ___ret (ß ___fn.call()))
                                ;; make sure no one has killed us before this point, and can't from now on
                                (when (ß info.status.compareAndSet(RUNNING, COMMITTING))
                                    (doseq [#_"Map$Entry<Ref, ArrayList<CFn>>" ___e (ß commutes.entrySet())]
                                        (let [#_"Ref" ___ref (ß ___e.getKey())]
                                            (when (ß sets.contains(___ref))
                                                (§ continue )
                                            )

                                            (let [#_"boolean" ___wasEnsured (ß ensures.contains(___ref))]
                                                ;; can't upgrade readLock, so release it
                                                (ß releaseIfEnsured(___ref))
                                                (ß tryWriteLock(___ref))
                                                (ß ___locked.add(___ref))
                                                (when (ß ___wasEnsured && ___ref.tvals != nil && ___ref.tvals.point > readPoint)
                                                    (throw retryex)
                                                )

                                                (let [#_"LockingTransactionInfo" ___refinfo (ß ___ref.tinfo)]
                                                    (when (ß ___refinfo != nil && ___refinfo != info && ___refinfo.running())
                                                        (when (ß !barge(___refinfo))
                                                            (throw retryex)
                                                        )
                                                    )
                                                    (let [#_"Object" ___val (ß (___ref.tvals == nil) ? nil :or ___ref.tvals.val)]
                                                        (ß vals.put(___ref, ___val))
                                                        (doseq [#_"CFn" ___f (ß ___e.getValue())]
                                                            (ß vals.put(___ref, ___f.fn.applyTo(RT'cons(vals.get(___ref), ___f.args))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (doseq [#_"Ref" ___ref sets]
                                        (ß tryWriteLock(___ref))
                                        (ß ___locked.add(___ref))
                                    )

                                    ;; validate and enqueue notifications
                                    (doseq [#_"Map$Entry<Ref, Object>" ___e (ß vals.entrySet())]
                                        (let [#_"Ref" ___ref (ß ___e.getKey())]
                                            (ß ___ref.validate(___ref.getValidator(), ___e.getValue()))
                                        )
                                    )

                                    ;; at this point, all values calced, all refs to be written locked
                                    ;; no more client code to be called
                                    (let [#_"long" ___commitPoint (ß getCommitPoint())]
                                        (doseq [#_"Map$Entry<Ref, Object>" ___e (ß vals.entrySet())]
                                            (let [#_"Ref" ___ref (ß ___e.getKey())]
                                                (let [#_"Object" ___oldval (ß (___ref.tvals == nil) ? nil :or ___ref.tvals.val)]
                                                    (let [#_"Object" ___newval (ß ___e.getValue())]
                                                        (let [#_"int" ___hcount (ß ___ref.histCount())]
                                                            (cond (ß ___ref.tvals == nil)
                                                                (do
                                                                    (§ ass (ß ___ref.tvals) (ß new RefTVal(___newval, ___commitPoint)))
                                                                )
                                                                (ß (___ref.faults.get() > 0 && ___hcount < ___ref.maxHistory) || ___hcount < ___ref.minHistory)
                                                                (do
                                                                    (§ ass (ß ___ref.tvals) (ß new RefTVal(___newval, ___commitPoint, ___ref.tvals)))
                                                                    (ß ___ref.faults.set(0))
                                                                )
                                                                :else
                                                                (do
                                                                    (§ ass (ß ___ref.tvals) (ß ___ref.tvals.next))
                                                                    (§ ass (ß ___ref.tvals.val) ___newval)
                                                                    (§ ass (ß ___ref.tvals.point) ___commitPoint)
                                                                )
                                                            )
                                                            (when (ß ___ref.getWatches().count() > 0)
                                                                (ß ___notify.add(new Notify(___ref, ___oldval, ___newval)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        (§ ass ___done true)
                                        (ß info.status.set(COMMITTED))
                                    )
                                )
                                (catch RetryEx ___retry
                                    ;; eat this so we retry rather than fall out
                                )
                                (finally
                                    (loop-when-recur [(§ var #_"int" ___k (ß ___locked.size() - 1))] (ß ___k >= 0) [(§ ass ___k (ß ___k - 1))]
                                        (ß ___locked.get(___k).lock.writeLock().unlock())
                                    )
                                    (ß ___locked.clear())
                                    (doseq [#_"Ref" ___r ensures]
                                        (ß ___r.lock.readLock().unlock())
                                    )
                                    (ß ensures.clear())
                                    (ß stop(___done ? COMMITTED :or RETRY))
                                    (try
                                        (when ___done ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" ___n ___notify]
                                                (ß ___n.ref.notifyWatches(___n.oldval, ___n.newval))
                                            )
                                            (doseq [#_"AgentAction" ___action actions]
                                                (ß Agent'dispatchAction(___action))
                                            )
                                        )
                                        (finally
                                            (ß ___notify.clear())
                                            (ß actions.clear())
                                        )
                                    )
                                )
                            )
                        )
                        (when (ß !___done)
                            (throw (ß Util'runtimeException("Transaction failed after reaching retry limit")))
                        )
                        ___ret
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" enqueue [#_"LockingTransaction" this, #_"AgentAction" ___action]
        (ß actions.add(___action))
        nil
    )

    #_method
    (§ defn #_"Object" doGet [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß vals.containsKey(___ref))
            (§ return (ß vals.get(___ref)))
        )
        (try
            (ß ___ref.lock.readLock().lock())
            (when (ß ___ref.tvals == nil)
                (throw (ß new IllegalStateException(___ref.toString() + " is unbound.")))
            )
            (let [#_"RefTVal" ___ver (ß ___ref.tvals)]
                (§ loop
                    (when (ß ___ver.point <= readPoint)
                        (§ return (ß ___ver.val))
                    )
                    (§ recur-if ((§ ass ___ver (ß ___ver.prior)) != ___ref.tvals))
                )
            )
            (finally
                (ß ___ref.lock.readLock().unlock())
            )
        )
        ;; no version of val precedes the read point
        (ß ___ref.faults.incrementAndGet())
        (throw retryex)
    )

    #_method
    (§ defn #_"Object" doSet [#_"LockingTransaction" this, #_"Ref" ___ref, #_"Object" ___val]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß commutes.containsKey(___ref))
            (throw (IllegalStateException. "Can't set after commute"))
        )
        (when (ß !sets.contains(___ref))
            (ß sets.add(___ref))
            (ß lock(___ref))
        )
        (ß vals.put(___ref, ___val))
        val
    )

    #_method
    (§ defn #_"void" doEnsure [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß ensures.contains(___ref))
            (§ return nil)
        )
        (ß ___ref.lock.readLock().lock())

        ;; someone completed a write after our snapshot
        (when (ß ___ref.tvals != nil && ___ref.tvals.point > readPoint)
            (ß ___ref.lock.readLock().unlock())
            (throw retryex)
        )

        (let [#_"LockingTransactionInfo" ___refinfo (ß ___ref.tinfo)]
            ;; writer exists
            (if (ß ___refinfo != nil && ___refinfo.running())
                (do
                    (ß ___ref.lock.readLock().unlock())

                    (when (ß ___refinfo != info) ;; not us, ensure is doomed
                        (ß blockAndBail(___refinfo))
                    )
                )
                (do
                    (ß ensures.add(___ref))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" doCommute [#_"LockingTransaction" this, #_"Ref" ___ref, #_"IFn" ___fn, #_"ISeq" ___args]
        (when (ß !info.running())
            (throw retryex)
        )
        (when (ß !vals.containsKey(___ref))
            (let [#_"Object" ___val nil]
                (try
                    (ß ___ref.lock.readLock().lock())
                    (§ ass ___val (ß (___ref.tvals == nil) ? nil :or ___ref.tvals.val))
                    (finally
                        (ß ___ref.lock.readLock().unlock())
                    )
                )
                (ß vals.put(___ref, ___val))
            )
        )
        (let [#_"ArrayList<CFn>" ___fns (ß commutes.get(___ref))]
            (when (nil? ___fns)
                (ß commutes.put(___ref, (§ ass ___fns (ß new ArrayList<CFn>()))))
            )
            (ß ___fns.add(new CFn(___fn, ___args)))
            (let [#_"Object" ___ret (ß ___fn.applyTo(RT'cons(vals.get(___ref), ___args)))]
                (ß vals.put(___ref, ___ret))
                ret
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

#_private
(defprotocol LongRangeBoundsCheck
    #_abstract
    (#_"boolean" LongRangeBoundsCheck'''exceededBounds [#_"LongRangeBoundsCheck" this, #_"long" ___val])
)

#_non-static
(class-ns LongRangeIterator (§ implements Iterator)
    (§ init
        (§ field- #_"long" next 0)
        (§ field- #_"boolean" hasNext false)
    )

    (§ constructor #_"LongRangeIterator" LongRangeIterator []
        (let [this (ß super())]
            (§ ass (ß this.next) start)
            (§ ass (ß this.hasNext) true)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"LongRangeIterator" this]
        hasNext
    )

    #_method
    (§ defn #_"Object" next [#_"LongRangeIterator" this]
        (if hasNext
            (do
                (let [#_"long" ___ret next]
                    (try
                        (§ ass next (ß Numbers'add(next, step)))
                        (§ ass hasNext (ß !boundsCheck.exceededBounds(next)))
                        (catch ArithmeticException ___e
                            (§ ass hasNext false)
                        )
                    )
                    ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"LongRangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

#_private
(class-ns LongChunk (§ implements IChunk)
    (§ init
        (§ field #_"long" start 0)
        (§ field #_"long" step 0)
        (§ field #_"int" count 0)
    )

    (§ constructor #_"LongChunk" LongChunk [#_"long" ___start, #_"long" ___step, #_"int" ___count]
        (let [this (ß super())]
            (§ ass (ß this.start) ___start)
            (§ ass (ß this.step) ___step)
            (§ ass (ß this.count) ___count)
            this
        )
    )

    #_method
    (§ defn #_"long" first [#_"LongChunk" this]
        start
    )

    #_method
    (§ defn #_"Object" nth [#_"LongChunk" this, #_"int" ___i]
        (ß start + (___i * step))
    )

    #_method
    (§ defn #_"Object" nth [#_"LongChunk" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < count)
            (§ return (ß start + (___i * step)))
        )
        notFound
    )

    #_method
    (§ defn #_"int" count [#_"LongChunk" this]
        count
    )

    #_method
    (§ defn #_"LongChunk" dropFirst [#_"LongChunk" this]
        (when (ß count <= 1)
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß new LongChunk(start + step, step, count - 1))
    )

    #_method
    (§ defn #_"Object" reduce [#_"LongChunk" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"long" ___x start]
            (let [#_"Object" ___ret ___init]
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < count) [(§ ass ___i (ß ___i + 1))]
                    (§ ass ___ret (ß ___f.invoke(___ret, ___x)))
                    (when (ß RT'isReduced(___ret))
                        (§ return ___ret)
                    )
                    (§ ass ___x (ß ___x + step))
                )
                ret
            )
        )
    )
)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (§ def- #_"int" LongRange'CHUNK_SIZE 32)

    (§ defn- #_"LongRangeBoundsCheck" LongRange'positiveStep [#_"long" ___end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"LongRangeBoundsCheck" this, #_"long" ___val]
                (ß (___val >= ___end))
            )
        )
    )

    (§ defn- #_"LongRangeBoundsCheck" LongRange'negativeStep [#_"long" ___end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"LongRangeBoundsCheck" this, #_"long" ___val]
                (ß (___val <= ___end))
            )
        )
    )

    (§ init
        ;; Invariants guarantee this is never an empty or infinite seq
        (§ field #_"long" start 0)
        (§ field #_"long" end 0)
        (§ field #_"long" step 0)
        (§ field #_"LongRangeBoundsCheck" boundsCheck nil)

        #_volatile
        (§ field- #_"LongChunk" _chunk nil) ;; lazy
        #_volatile
        (§ field- #_"ISeq" _chunkNext nil) ;; lazy
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"LongRange" LongRange [#_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck]
        (let [this (ß super())]
            (§ ass (ß this.start) ___start)
            (§ ass (ß this.end) ___end)
            (§ ass (ß this.step) ___step)
            (§ ass (ß this.boundsCheck) ___boundsCheck)
            this
        )
    )

    (§ constructor- #_"LongRange" LongRange [#_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck, #_"LongChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (ß super())]
            (§ ass (ß this.start) ___start)
            (§ ass (ß this.end) ___end)
            (§ ass (ß this.step) ___step)
            (§ ass (ß this.boundsCheck) ___boundsCheck)
            (§ ass (ß this._chunk) ___chunk)
            (§ ass (ß this._chunkNext) ___chunkNext)
            this
        )
    )

    (§ constructor- #_"LongRange" LongRange [#_"IPersistentMap" ___meta, #_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck, #_"LongChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (ß super(___meta))]
            (§ ass (ß this.start) ___start)
            (§ ass (ß this.end) ___end)
            (§ ass (ß this.step) ___step)
            (§ ass (ß this.boundsCheck) ___boundsCheck)
            (§ ass (ß this._chunk) ___chunk)
            (§ ass (ß this._chunkNext) ___chunkNext)
            this
        )
    )

    (§ defn #_"ISeq" LongRange'create [#_"long" ___end]
        (when (ß ___end > 0)
            (§ return (ß new LongRange(0, ___end, 1, positiveStep(___end))))
        )
        (ß PersistentList'EMPTY)
    )

    (§ defn #_"ISeq" LongRange'create [#_"long" ___start, #_"long" ___end]
        (when (ß ___start >= ___end)
            (§ return (ß PersistentList'EMPTY))
        )
        (ß new LongRange(___start, ___end, 1, positiveStep(___end)))
    )

    (§ defn #_"ISeq" LongRange'create [#_"long" ___start, #_"long" ___end, #_"long" ___step]
        (cond (ß ___step > 0)
            (do
                (when (ß ___end <= ___start)
                    (§ return (ß PersistentList'EMPTY))
                )
                (ß new LongRange(___start, ___end, ___step, positiveStep(___end)))
            )
            (ß ___step < 0)
            (do
                (when (ß ___end >= ___start)
                    (§ return (ß PersistentList'EMPTY))
                )
                (ß new LongRange(___start, ___end, ___step, negativeStep(___end)))
            )
            :else
            (do
                (when (ß ___end == ___start)
                    (§ return (ß PersistentList'EMPTY))
                )
                (ß Repeat'create(___start))
            )
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"LongRange" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == _meta)
            (§ return this)
        )
        (ß new LongRange(___meta, start, end, step, boundsCheck, _chunk, _chunkNext))
    )

    #_method
    (§ defn #_"Object" first [#_"LongRange" this]
        start
    )

    #_method
    (§ defn #_"void" forceChunk [#_"LongRange" this]
        (when (some? _chunk)
            (§ return nil)
        )

        (§ let [#_"long" ___count]
            (try
                (§ ass ___count (ß rangeCount(start, end, step)))
                (catch ArithmeticException ___e
                    ;; size of total range is > Long.MAX_VALUE so must step to count
                    ;; this only happens in pathological range cases like:
                    ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                    (§ ass ___count (ß steppingCount(start, end, step)))
                )
            )

            (cond (ß ___count > CHUNK_SIZE) ;; not last chunk
                (do
                    (let [#_"long" ___nextStart (ß start + (step * CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (§ ass _chunkNext (ß new LongRange(___nextStart, end, step, boundsCheck)))
                        (§ ass _chunk (ß new LongChunk(start, step, CHUNK_SIZE)))
                    )
                )
                :else ;; last chunk
                (do
                    (§ ass _chunk (ß new LongChunk(start, step, (int) ___count))) ;; count must be <= CHUNK_SIZE
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"ISeq" next [#_"LongRange" this]
        (when (some? _next)
            (§ return _next)
        )

        (ß forceChunk())
        (when (ß _chunk.count() > 1)
            (let [#_"LongChunk" ___smallerChunk (ß _chunk.dropFirst())]
                (§ ass _next (ß new LongRange(___smallerChunk.first(), end, step, boundsCheck, ___smallerChunk, _chunkNext)))
                (§ return _next)
            )
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"LongRange" this]
        (ß forceChunk())
        _chunk
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"LongRange" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"LongRange" this]
        (ß forceChunk())
        (when (nil? _chunkNext)
            (§ return (ß PersistentList'EMPTY))
        )
        _chunkNext
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (§ defn #_"long" steppingCount [#_"LongRange" this, #_"long" ___start, #_"long" ___end, #_"long" ___step]
        (let [#_"long" ___count 1]
            (let [#_"long" ___s ___start]
                (while (ß ___count <= CHUNK_SIZE)
                    (try
                        (§ ass ___s (ß Numbers'add(___s, ___step)))
                        (if (ß boundsCheck.exceededBounds(___s))
                            (do
                                (§ break )
                            )
                            (do
                                (§ ass ___count (ß ___count + 1))
                            )
                        )
                        (catch ArithmeticException ___e
                            (§ break )
                        )
                    )
                )
                ___count
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (§ defn #_"long" rangeCount [#_"LongRange" this, #_"long" ___start, #_"long" ___end, #_"long" ___step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (ß Numbers'add(Numbers'add(Numbers'minus(___end, ___start), ___step), (this.step > 0) ? -1 :or 1) / ___step)
    )

    #_method
    (§ defn #_"int" count [#_"LongRange" this]
        (try
            (let [#_"long" ___c (ß rangeCount(start, end, step))]
                (if (ß ___c > Integer/MAX_VALUE)
                    (do
                        (ß Numbers'throwIntOverflow())
                    )
                    (do
                        (ß (int) ___c)
                    )
                )
            )
            (catch ArithmeticException ___e
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"Iterator" ___iter (ß this.iterator())]
                    (let [#_"long" ___count 0]
                        (while (ß ___iter.hasNext())
                            (ß ___iter.next())
                            (§ ass ___count (ß ___count + 1))
                        )

                        (if (ß ___count > Integer/MAX_VALUE)
                            (do
                                (ß Numbers'throwIntOverflow())
                            )
                            (do
                                (ß (int)___count)
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"LongRange" this, #_"IFn" ___f]
        (let [#_"Object" ___acc start]
            (let [#_"long" ___i (ß start + step)]
                (while (ß !boundsCheck.exceededBounds(___i))
                    (§ ass ___acc (ß ___f.invoke(___acc, ___i)))
                    (when (ß ___acc instanceof Reduced)
                        (§ return (ß ((Reduced)___acc).deref()))
                    )
                    (§ ass ___i (ß ___i + step))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"LongRange" this, #_"IFn" ___f, #_"Object" ___val]
        (let [#_"Object" ___acc ___val]
            (let [#_"long" ___i start]
                (§ loop
                    (§ ass ___acc (ß ___f.invoke(___acc, ___i)))
                    (when (ß RT'isReduced(___acc))
                        (§ return (ß ((Reduced)___acc).deref()))
                    )
                    (§ ass ___i (ß ___i + step))
                    (§ recur-if (!boundsCheck.exceededBounds(___i)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"LongRange" this]
        (LongRangeIterator.)
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (§ defn #_"MapEntry" MapEntry'create [#_"Object" ___key, #_"Object" ___val]
        (ß new MapEntry(___key, ___val))
    )

    (§ init
        (§ field #_"Object" _key nil)
        (§ field #_"Object" _val nil)
    )

    (§ constructor #_"MapEntry" MapEntry [#_"Object" ___key, #_"Object" ___val]
        (let [this (ß super())]
            (§ ass (ß this._key) ___key)
            (§ ass (ß this._val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" key [#_"MapEntry" this]
        _key
    )

    #_method
    (§ defn #_"Object" val [#_"MapEntry" this]
        _val
    )

    #_method
    (§ defn #_"Object" getKey [#_"MapEntry" this]
        (ß key())
    )

    #_method
    (§ defn #_"Object" getValue [#_"MapEntry" this]
        (ß val())
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(defprotocol MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns Entry
    (§ init
        (§ field #_"Class" c nil)
        (§ field #_"IFn" fn nil)
    )

    (§ constructor #_"Entry" Entry [#_"Class" ___c, #_"IFn" ___fn]
        (let [this (ß super())]
            (§ ass (ß this.c) ___c)
            (§ ass (ß this.fn) ___fn)
            this
        )
    )
)

(class-ns MethodImplCache
    (§ init
        (§ field #_"IPersistentMap" protocol nil)
        (§ field #_"Keyword" methodk nil)
        (§ field #_"int" shift 0)
        (§ field #_"int" mask 0)
        (§ field #_"Object[]" table nil) ;; [class, entry. class, entry ...]
        (§ field #_"Map" map nil)

        (§ field #_"Entry" mre nil)
    )

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk]
        (let [this (ß this(___protocol, ___methodk, 0, 0, RT'EMPTY_ARRAY))]
            this
        )
    )

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk, #_"int" ___shift, #_"int" ___mask, #_"Object[]" ___table]
        (let [this (ß super())]
            (§ ass (ß this.protocol) ___protocol)
            (§ ass (ß this.methodk) ___methodk)
            (§ ass (ß this.shift) ___shift)
            (§ ass (ß this.mask) ___mask)
            (§ ass (ß this.table) ___table)
            (§ ass (ß this.map) nil)
            this
        )
    )

    (§ constructor #_"MethodImplCache" MethodImplCache [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk, #_"Map" ___map]
        (let [this (ß super())]
            (§ ass (ß this.protocol) ___protocol)
            (§ ass (ß this.methodk) ___methodk)
            (§ ass (ß this.shift) 0)
            (§ ass (ß this.mask) 0)
            (§ ass (ß this.table) nil)
            (§ ass (ß this.map) ___map)
            this
        )
    )

    #_method
    (§ defn #_"IFn" fnFor [#_"MethodImplCache" this, #_"Class" ___c]
        (let [#_"Entry" ___last mre]
            (when (ß ___last != nil && ___last.c == ___c)
                (§ return (ß ___last.fn))
            )
            (ß findFnFor(___c))
        )
    )

    #_method
    (§ defn #_"IFn" findFnFor [#_"MethodImplCache" this, #_"Class" ___c]
        (if (some? map)
            (do
                (let [#_"Entry" ___e (ß (Entry) map.get(___c))]
                    (§ ass mre ___e)
                    (ß (___e != nil) ? ___e.fn :or nil)
                )
            )
            (do
                (let [#_"int" ___idx (ß ((Util'hash(___c) >> shift) & mask) << 1)]
                    (when (ß ___idx < table.length && table[___idx] == ___c)
                        (let [#_"Entry" ___e (ß ((Entry) table[___idx + 1]))]
                            (§ ass mre ___e)
                            (§ return (ß (___e != nil) ? ___e.fn :or nil))
                        )
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ def #_"Var" MultiFn'assoc (ß RT'var("cloiure.core", "assoc")))
    (§ def #_"Var" MultiFn'dissoc (ß RT'var("cloiure.core", "dissoc")))
    (§ def #_"Var" MultiFn'isa (ß RT'var("cloiure.core", "isa?")))
    (§ def #_"Var" MultiFn'parents (ß RT'var("cloiure.core", "parents")))

    (§ init
        (§ field #_"IFn" dispatchFn nil)
        (§ field #_"Object" defaultDispatchVal nil)
        (§ field #_"IRef" hierarchy nil)
        (§ field #_"String" name nil)
        (§ field #_"ReentrantReadWriteLock" rw nil)

        #_volatile
        (§ field #_"IPersistentMap" methodTable nil)
        #_volatile
        (§ field #_"IPersistentMap" preferTable nil)
        #_volatile
        (§ field #_"IPersistentMap" methodCache nil)
        #_volatile
        (§ field #_"Object" cachedHierarchy nil)
    )

    (§ constructor #_"MultiFn" MultiFn [#_"String" ___name, #_"IFn" ___dispatchFn, #_"Object" ___defaultDispatchVal, #_"IRef" ___hierarchy]
        (let [this (ß super())]
            (§ ass (ß this.rw) (ReentrantReadWriteLock.))
            (§ ass (ß this.name) ___name)
            (§ ass (ß this.dispatchFn) ___dispatchFn)
            (§ ass (ß this.defaultDispatchVal) ___defaultDispatchVal)
            (§ ass (ß this.methodTable) (ß PersistentHashMap'EMPTY))
            (§ ass (ß this.methodCache) (ß getMethodTable()))
            (§ ass (ß this.preferTable) (ß PersistentHashMap'EMPTY))
            (§ ass (ß this.hierarchy) ___hierarchy)
            (§ ass cachedHierarchy nil)
            this
        )
    )

    #_method
    (§ defn #_"MultiFn" reset [#_"MultiFn" this]
        (ß rw.writeLock().lock())
        (try
            (§ ass methodTable (§ ass methodCache (§ ass preferTable (ß PersistentHashMap'EMPTY))))
            (§ ass cachedHierarchy nil)
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" addMethod [#_"MultiFn" this, #_"Object" ___dispatchVal, #_"IFn" ___method]
        (ß rw.writeLock().lock())
        (try
            (§ ass methodTable (ß getMethodTable().assoc(___dispatchVal, ___method)))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" removeMethod [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (ß rw.writeLock().lock())
        (try
            (§ ass methodTable (ß getMethodTable().without(___dispatchVal)))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" preferMethod [#_"MultiFn" this, #_"Object" ___dispatchValX, #_"Object" ___dispatchValY]
        (ß rw.writeLock().lock())
        (try
            (when (ß prefers(___dispatchValY, ___dispatchValX))
                (throw (ß new IllegalStateException(String/format("Preference conflict in multimethod '%s': %s is already preferred to %s", name, ___dispatchValY, ___dispatchValX))))
            )
            (§ ass preferTable (ß getPreferTable().assoc(___dispatchValX, RT'conj((IPersistentCollection) RT'get(getPreferTable(), ___dispatchValX, PersistentHashSet'EMPTY), ___dispatchValY))))
            (ß resetCache())
            this
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn- #_"boolean" prefers [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (let [#_"IPersistentSet" ___xprefs (ß (IPersistentSet) getPreferTable().valAt(___x))]
            (when (ß ___xprefs != nil && ___xprefs.contains(___y))
                (§ return true)
            )
            (loop-when-recur [(§ var #_"ISeq" ___ps (ß RT'seq(MultiFn'parents.invoke(___y))))] (some? ___ps) [(§ ass ___ps (ß ___ps.next()))]
                (when (ß prefers(___x, ___ps.first()))
                    (§ return true)
                )
            )
            (loop-when-recur [(§ var #_"ISeq" ___ps (ß RT'seq(MultiFn'parents.invoke(___x))))] (some? ___ps) [(§ ass ___ps (ß ___ps.next()))]
                (when (ß prefers(___ps.first(), ___y))
                    (§ return true)
                )
            )
            false
        )
    )

    #_method
    (§ defn- #_"boolean" isA [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (ß RT'booleanCast(isa.invoke(hierarchy.deref(), ___x, ___y)))
    )

    #_method
    (§ defn- #_"boolean" dominates [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (ß prefers(___x, ___y) || isA(___x, ___y))
    )

    #_method
    (§ defn- #_"IPersistentMap" resetCache [#_"MultiFn" this]
        (ß rw.writeLock().lock())
        (try
            (§ ass methodCache (ß getMethodTable()))
            (§ ass cachedHierarchy (ß hierarchy.deref()))
            methodCache
            (finally
                (ß rw.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"IFn" getMethod [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (when (ß cachedHierarchy != hierarchy.deref())
            (ß resetCache())
        )
        (let [#_"IFn" ___targetFn (ß (IFn) methodCache.valAt(___dispatchVal))]
            (when (some? ___targetFn)
                (§ return ___targetFn)
            )
            (ß findAndCacheBestMethod(___dispatchVal))
        )
    )

    #_method
    (§ defn- #_"IFn" getFn [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (let [#_"IFn" ___targetFn (ß getMethod(___dispatchVal))]
            (when (nil? ___targetFn)
                (throw (ß new IllegalArgumentException(String/format("No method in multimethod '%s' for dispatch value: %s", name, ___dispatchVal))))
            )
            targetFn
        )
    )

    #_method
    (§ defn- #_"IFn" findAndCacheBestMethod [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (ß rw.readLock().lock())
        (§ let [#_"Object" ___bestValue]
            (let [#_"IPersistentMap" ___mt methodTable]
                (let [#_"IPersistentMap" ___pt preferTable]
                    (let [#_"Object" ___ch cachedHierarchy]
                        (try
                            (let [#_"Map$Entry" ___bestEntry nil]
                                (doseq [#_"Object" ___o (ß getMethodTable())]
                                    (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                                        (when (ß isA(___dispatchVal, ___e.getKey()))
                                            (when (ß ___bestEntry == nil || dominates(___e.getKey(), ___bestEntry.getKey()))
                                                (§ ass ___bestEntry ___e)
                                            )
                                            (when (ß !dominates(___bestEntry.getKey(), ___e.getKey()))
                                                (throw (ß new IllegalArgumentException(String/format("Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", name, ___dispatchVal, ___e.getKey(), ___bestEntry.getKey()))))
                                            )
                                        )
                                    )
                                )
                                (if (nil? ___bestEntry)
                                    (do
                                        (§ ass ___bestValue (ß methodTable.valAt(defaultDispatchVal)))
                                        (when (nil? ___bestValue)
                                            (§ return nil)
                                        )
                                    )
                                    (do
                                        (§ ass ___bestValue (ß ___bestEntry.getValue()))
                                    )
                                )
                            )
                            (finally
                                (ß rw.readLock().unlock())
                            )
                        )

                        ;; ensure basis has stayed stable throughout, else redo
                        (ß rw.writeLock().lock())
                        (try
                            (if (ß ___mt == methodTable && ___pt == preferTable && ___ch == cachedHierarchy && cachedHierarchy == hierarchy.deref())
                                (do
                                    ;; place in cache
                                    (§ ass methodCache (ß methodCache.assoc(___dispatchVal, ___bestValue)))
                                    (ß (IFn) ___bestValue)
                                )
                                (do
                                    (ß resetCache())
                                    (ß findAndCacheBestMethod(___dispatchVal))
                                )
                            )
                            (finally
                                (ß rw.writeLock().unlock())
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this]
        (ß getFn(dispatchFn.invoke()).invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1]
        (ß getFn(dispatchFn.invoke(___arg1)).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), Util'ret1(___arg2, (§ ass ___arg2 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), Util'ret1(___arg2, (§ ass ___arg2 nil)), Util'ret1(___arg3, (§ ass ___arg3 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß getFn(dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß getFn(
                dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß getFn(
                dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß getFn(
                dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß getFn(
                dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß getFn(
                dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß getFn(
                dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß getFn(
                dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19, ___arg20)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß getFn(
                dispatchFn.invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19, ___arg20, ___args)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)),
                    ___args))
    )

    #_method
    (§ defn #_"IPersistentMap" getMethodTable [#_"MultiFn" this]
        methodTable
    )

    #_method
    (§ defn #_"IPersistentMap" getPreferTable [#_"MultiFn" this]
        preferTable
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
#_stateless
(class-ns Murmur3
    (§ def- #_"int" Murmur3'seed 0)
    (§ def- #_"int" Murmur3'C1 0xcc9e2d51)
    (§ def- #_"int" Murmur3'C2 0x1b873593)

    (§ defn #_"int" Murmur3'hashInt [#_"int" ___input]
        (when (ß ___input == 0)
            (§ return 0)
        )
        (let [#_"int" ___k1 (ß mixK1(___input))]
            (let [#_"int" ___h1 (ß mixH1(seed, ___k1))]
                (ß Murmur3'fmix(___h1, 4))
            )
        )
    )

    (§ defn #_"int" Murmur3'hashLong [#_"long" ___input]
        (when (ß ___input == 0)
            (§ return 0)
        )
        (let [#_"int" ___low (ß (int) ___input)]
            (let [#_"int" ___high (ß (int) (___input >>> 32))]
                (let [#_"int" ___k1 (ß mixK1(___low))]
                    (let [#_"int" ___h1 (ß mixH1(seed, ___k1))]
                        (§ ass ___k1 (ß mixK1(___high)))
                        (§ ass ___h1 (ß mixH1(___h1, ___k1)))

                        (ß Murmur3'fmix(___h1, 8))
                    )
                )
            )
        )
    )

    (§ defn #_"int" Murmur3'hashUnencodedChars [#_"CharSequence" ___input]
        (let [#_"int" ___h1 seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [(§ var #_"int" ___i 1)] (ß ___i < ___input.length()) [(§ ass ___i (ß ___i + 2))]
                (let [#_"int" ___k1 (ß ___input.charAt(___i - 1) | (___input.charAt(___i) << 16))]
                    (§ ass ___k1 (ß mixK1(___k1)))
                    (§ ass ___h1 (ß mixH1(___h1, ___k1)))
                )
            )

            ;; deal with any remaining characters
            (when (ß (___input.length() & 1) == 1)
                (let [#_"int" ___k1 (ß ___input.charAt(___input.length() - 1))]
                    (§ ass ___k1 (ß mixK1(___k1)))
                    (§ ass ___h1 (ß ___h1 :xor ___k1))
                )
            )

            (ß Murmur3'fmix(___h1, 2 * ___input.length()))
        )
    )

    (§ defn #_"int" Murmur3'mixCollHash [#_"int" ___hash, #_"int" ___count]
        (let [#_"int" ___h1 seed]
            (let [#_"int" ___k1 (ß mixK1(___hash))]
                (§ ass ___h1 (ß mixH1(___h1, ___k1)))
                (ß Murmur3'fmix(___h1, ___count))
            )
        )
    )

    (§ defn #_"int" Murmur3'hashOrdered [#_"Iterable" ___xs]
        (let [#_"int" ___n 0]
            (let [#_"int" ___hash 1]
                (doseq [#_"Object" ___x ___xs]
                    (§ ass ___hash (ß 31 * ___hash + Util'hasheq(___x)))
                    (§ ass ___n (ß ___n + 1))
                )

                (ß mixCollHash(___hash, ___n))
            )
        )
    )

    (§ defn #_"int" Murmur3'hashUnordered [#_"Iterable" ___xs]
        (let [#_"int" ___hash 0]
            (let [#_"int" ___n 0]
                (doseq [#_"Object" ___x ___xs]
                    (§ ass ___hash (ß ___hash + Util'hasheq(___x)))
                    (§ ass ___n (ß ___n + 1))
                )

                (ß mixCollHash(___hash, ___n))
            )
        )
    )

    (§ defn- #_"int" Murmur3'mixK1 [#_"int" ___k1]
        (§ ass ___k1 (ß ___k1 * C1))
        (§ ass ___k1 (ß Integer/rotateLeft(___k1, 15)))
        (§ ass ___k1 (ß ___k1 * C2))
        k1
    )

    (§ defn- #_"int" Murmur3'mixH1 [#_"int" ___h1, #_"int" ___k1]
        (§ ass ___h1 (ß ___h1 :xor ___k1))
        (§ ass ___h1 (ß Integer/rotateLeft(___h1, 13)))
        (§ ass ___h1 (ß ___h1 * 5 + 0xe6546b64))
        h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (§ defn- #_"int" Murmur3'fmix [#_"int" ___h1, #_"int" ___length]
        (§ ass ___h1 (ß ___h1 :xor ___length))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 16)))
        (§ ass ___h1 (ß ___h1 * 0x85ebca6b))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 13)))
        (§ ass ___h1 (ß ___h1 * 0xc2b2ae35))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 16)))
        h1
    )
)
)

(java-ns cloiure.lang.Named

(defprotocol Named
    #_abstract
    (#_"String" Named'''getNamespace [#_"Named" this])
    #_abstract
    (#_"String" Named'''getName [#_"Named" this])
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (§ def #_"ConcurrentHashMap<Symbol, Namespace>" Namespace'namespaces (ß new ConcurrentHashMap<Symbol, Namespace>()))

    (§ init
        (§ field #_"Symbol" name nil)

        #_transient
        (§ field #_"AtomicReference<IPersistentMap>" mappings (ß new AtomicReference<IPersistentMap>()))
        #_transient
        (§ field #_"AtomicReference<IPersistentMap>" aliases (ß new AtomicReference<IPersistentMap>()))
    )

    (§ constructor #_"Namespace" Namespace [#_"Symbol" ___name]
        (let [this (ß super(___name.meta()))]
            (§ ass (ß this.name) ___name)
            (ß mappings.set(RT'DEFAULT_IMPORTS))
            (ß aliases.set(RT'map()))
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"Namespace" this]
        (ß name.toString())
    )

    (§ defn #_"ISeq" Namespace'all []
        (ß RT'seq(namespaces.values()))
    )

    #_method
    (§ defn #_"Symbol" getName [#_"Namespace" this]
        name
    )

    #_method
    (§ defn #_"IPersistentMap" getMappings [#_"Namespace" this]
        (ß mappings.get())
    )

    #_method
    (§ defn #_"Var" intern [#_"Namespace" this, #_"Symbol" ___sym]
        (when (ß ___sym.ns != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (ß getMappings())]
            (§ let [#_"Object" ___o]
                (let [#_"Var" ___v nil]
                    (while (nil? (§ ass ___o (ß ___map.valAt(___sym))))
                        (when (nil? ___v)
                            (§ ass ___v (ß new Var(this, ___sym)))
                        )
                        (let [#_"IPersistentMap" ___newMap (ß ___map.assoc(___sym, ___v))]
                            (ß mappings.compareAndSet(___map, ___newMap))
                            (§ ass ___map (ß getMappings()))
                        )
                    )
                    (when (ß ___o instanceof Var && ((Var) ___o).ns == this)
                        (§ return (ß (Var) ___o))
                    )

                    (when (nil? ___v)
                        (§ ass ___v (ß new Var(this, ___sym)))
                    )

                    (ß warnOrFailOnReplace(___sym, ___o, ___v))

                    (while (ß !mappings.compareAndSet(___map, ___map.assoc(___sym, ___v)))
                        (§ ass ___map (ß getMappings()))
                    )

                    v
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" warnOrFailOnReplace [#_"Namespace" this, #_"Symbol" ___sym, #_"Object" ___o, #_"Object" ___v]
        (when (ß ___o instanceof Var)
            (let [#_"Namespace" ___ns (ß ((Var)___o).ns)]
                (when (ß ___ns == this || (___v instanceof Var && ((Var)___v).ns == RT'CLOIURE_NS))
                    (§ return nil)
                )
                (when (ß ___ns != RT'CLOIURE_NS)
                    (throw (IllegalStateException. (ß ___sym + " already refers to: " + ___o + " in namespace: " + name)))
                )
            )
        )
        (ß RT'errPrintWriter().println("WARNING: " + ___sym + " already refers to: " + ___o + " in namespace: " + name + ", being replaced by: " + ___v))
        nil
    )

    #_method
    (§ defn #_"Object" reference [#_"Namespace" this, #_"Symbol" ___sym, #_"Object" ___val]
        (when (ß ___sym.ns != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (ß getMappings())]
            (§ let [#_"Object" ___o]
                (while (nil? (§ ass ___o (ß ___map.valAt(___sym))))
                    (let [#_"IPersistentMap" ___newMap (ß ___map.assoc(___sym, ___val))]
                        (ß mappings.compareAndSet(___map, ___newMap))
                        (§ ass ___map (ß getMappings()))
                    )
                )
                (when (ß ___o == ___val)
                    (§ return ___o)
                )

                (ß warnOrFailOnReplace(___sym, ___o, ___val))

                (while (ß !mappings.compareAndSet(___map, ___map.assoc(___sym, ___val)))
                    (§ ass ___map (ß getMappings()))
                )

                ___val
            )
        )
    )

    (§ defn #_"boolean" Namespace'areDifferentInstancesOfSameClassName [#_"Class" ___cls1, #_"Class" ___cls2]
        (ß (___cls1 != ___cls2) && (___cls1.getName().equals(___cls2.getName())))
    )

    #_method
    (§ defn #_"Class" referenceClass [#_"Namespace" this, #_"Symbol" ___sym, #_"Class" ___val]
        (when (ß ___sym.ns != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (ß getMappings())]
            (let [#_"Class" ___c (ß (Class) ___map.valAt(___sym))]
                (while (ß (___c == nil) || (areDifferentInstancesOfSameClassName(___c, ___val)))
                    (let [#_"IPersistentMap" ___newMap (ß ___map.assoc(___sym, ___val))]
                        (ß mappings.compareAndSet(___map, ___newMap))
                        (§ ass ___map (ß getMappings()))
                        (§ ass ___c (ß (Class) ___map.valAt(___sym)))
                    )
                )
                (when (ß ___c == ___val)
                    (§ return ___c)
                )

                (throw (IllegalStateException. (ß ___sym + " already refers to: " + ___c + " in namespace: " + name)))
            )
        )
    )

    #_method
    (§ defn #_"void" unmap [#_"Namespace" this, #_"Symbol" ___sym]
        (when (ß ___sym.ns != nil)
            (throw (IllegalArgumentException. "Can't unintern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (ß getMappings())]
            (while (ß ___map.containsKey(___sym))
                (let [#_"IPersistentMap" ___newMap (ß ___map.without(___sym))]
                    (ß mappings.compareAndSet(___map, ___newMap))
                    (§ ass ___map (ß getMappings()))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Class" importClass [#_"Namespace" this, #_"Symbol" ___sym, #_"Class" ___c]
        (ß referenceClass(___sym, ___c))
    )

    #_method
    (§ defn #_"Class" importClass [#_"Namespace" this, #_"Class" ___c]
        (let [#_"String" ___n (ß ___c.getName())]
            (ß importClass(Symbol'intern(___n.substring(___n.lastIndexOf(\.) + 1)), ___c))
        )
    )

    #_method
    (§ defn #_"Var" refer [#_"Namespace" this, #_"Symbol" ___sym, #_"Var" ___var]
        (ß (Var) reference(___sym, ___var))
    )

    (§ defn #_"Namespace" Namespace'findOrCreate [#_"Symbol" ___name]
        (let [#_"Namespace" ___ns (ß namespaces.get(___name))]
            (when (some? ___ns)
                (§ return ___ns)
            )
            (let [#_"Namespace" ___newns (Namespace. ___name)]
                (§ ass ___ns (ß namespaces.putIfAbsent(___name, ___newns)))
                (ß (___ns == nil) ? ___newns :or ___ns)
            )
        )
    )

    (§ defn #_"Namespace" Namespace'remove [#_"Symbol" ___name]
        (when (ß ___name.equals(RT'CLOIURE_NS.name))
            (throw (IllegalArgumentException. "Cannot remove cloiure namespace"))
        )
        (ß namespaces.remove(___name))
    )

    (§ defn #_"Namespace" Namespace'find [#_"Symbol" ___name]
        (ß namespaces.get(___name))
    )

    #_method
    (§ defn #_"Object" getMapping [#_"Namespace" this, #_"Symbol" ___name]
        (ß mappings.get().valAt(___name))
    )

    #_method
    (§ defn #_"Var" findInternedVar [#_"Namespace" this, #_"Symbol" ___symbol]
        (let [#_"Object" ___o (ß mappings.get().valAt(___symbol))]
            (when (ß ___o != nil && ___o instanceof Var && ((Var) ___o).ns == this)
                (§ return (ß (Var) ___o))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" getAliases [#_"Namespace" this]
        (ß aliases.get())
    )

    #_method
    (§ defn #_"Namespace" lookupAlias [#_"Namespace" this, #_"Symbol" ___alias]
        (let [#_"IPersistentMap" ___map (ß getAliases())]
            (ß (Namespace) ___map.valAt(___alias))
        )
    )

    #_method
    (§ defn #_"void" addAlias [#_"Namespace" this, #_"Symbol" ___alias, #_"Namespace" ___ns]
        (when (ß ___alias == nil || ___ns == nil)
            (throw (NullPointerException. "Expecting Symbol + Namespace"))
        )
        (let [#_"IPersistentMap" ___map (ß getAliases())]
            (while (ß !___map.containsKey(___alias))
                (let [#_"IPersistentMap" ___newMap (ß ___map.assoc(___alias, ___ns))]
                    (ß aliases.compareAndSet(___map, ___newMap))
                    (§ ass ___map (ß getAliases()))
                )
            )
            ;; you can rebind an alias, but only to the initially-aliased namespace.
            (when (ß !___map.valAt(___alias).equals(___ns))
                (throw (ß new IllegalStateException("Alias " + ___alias + " already exists in namespace " + name + ", aliasing " + ___map.valAt(___alias))))
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" removeAlias [#_"Namespace" this, #_"Symbol" ___alias]
        (let [#_"IPersistentMap" ___map (ß getAliases())]
            (while (ß ___map.containsKey(___alias))
                (let [#_"IPersistentMap" ___newMap (ß ___map.without(___alias))]
                    (ß aliases.compareAndSet(___map, ___newMap))
                    (§ ass ___map (ß getAliases()))
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(defprotocol Ops
    #_abstract
    (#_"Ops" Ops'''combine [#_"Ops" this, #_"Ops" ___y])
    #_abstract
    (#_"Ops" Ops'''opsWithLong [#_"Ops" this, #_"LongOps" ___x])
    #_abstract
    (#_"Ops" Ops'''opsWithDouble [#_"Ops" this, #_"DoubleOps" ___x])
    #_abstract
    (#_"Ops" Ops'''opsWithRatio [#_"Ops" this, #_"RatioOps" ___x])
    #_abstract
    (#_"Ops" Ops'''opsWithBigInt [#_"Ops" this, #_"BigIntOps" ___x])
    #_abstract
    (#_"Ops" Ops'''opsWithBigDecimal [#_"Ops" this, #_"BigDecimalOps" ___x])
    #_abstract
    (#_"boolean" Ops'''isZero [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"boolean" Ops'''isPos [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"boolean" Ops'''isNeg [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''add [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''addP [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''multiply [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''multiplyP [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''divide [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''quotient [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''remainder [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''equiv [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''lt [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''lte [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''gte [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''negate [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''negateP [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''inc [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''incP [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''dec [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''decP [#_"Ops" this, #_"Number" ___x])
)

#_stateless
#_abstract
(class-ns OpsP (§ implements Ops)
    #_method
    (§ defn #_"Number" addP [#_"OpsP" this, #_"Number" ___x, #_"Number" ___y]
        (ß add(___x, ___y))
    )

    #_method
    (§ defn #_"Number" multiplyP [#_"OpsP" this, #_"Number" ___x, #_"Number" ___y]
        (ß multiply(___x, ___y))
    )

    #_method
    (§ defn #_"Number" negateP [#_"OpsP" this, #_"Number" ___x]
        (ß negate(___x))
    )

    #_method
    (§ defn #_"Number" incP [#_"OpsP" this, #_"Number" ___x]
        (ß inc(___x))
    )

    #_method
    (§ defn #_"Number" decP [#_"OpsP" this, #_"Number" ___x]
        (ß dec(___x))
    )
)

#_stateless
(class-ns LongOps (§ implements Ops)
    #_method
    (§ defn #_"Ops" combine [#_"LongOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"DoubleOps" ___x]
        DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"RatioOps" ___x]
        RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"BigIntOps" ___x]
        BIGINT_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"BigDecimalOps" ___x]
        BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" isZero [#_"LongOps" this, #_"Number" ___x]
        (ß (___x.longValue() == 0))
    )

    #_method
    (§ defn #_"boolean" isPos [#_"LongOps" this, #_"Number" ___x]
        (ß (___x.longValue() > 0))
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"LongOps" this, #_"Number" ___x]
        (ß (___x.longValue() < 0))
    )

    #_method
    (§ defn #_"Number" add [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(Numbers'add(___x.longValue(), ___y.longValue())))
    )

    #_method
    (§ defn #_"Number" addP [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___lx (ß ___x.longValue()) #_"long" ___ly (ß ___y.longValue())]
            (let [#_"long" ___ret (ß ___lx + ___ly)]
                (when (ß (___ret :xor ___lx) < 0 && (___ret :xor ___ly) < 0)
                    (§ return (ß BIGINT_OPS.add(___x, ___y)))
                )
                (ß num(___ret))
            )
        )
    )

    #_method
    (§ defn #_"Number" multiply [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(Numbers'multiply(___x.longValue(), ___y.longValue())))
    )

    #_method
    (§ defn #_"Number" multiplyP [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___lx (ß ___x.longValue()) #_"long" ___ly (ß ___y.longValue())]
            (when (ß ___lx == Long/MIN_VALUE && ___ly < 0)
                (§ return (ß BIGINT_OPS.multiply(___x, ___y)))
            )
            (let [#_"long" ___ret (ß ___lx * ___ly)]
                (when (ß ___ly != 0 && ___ret / ___ly != ___lx)
                    (§ return (ß BIGINT_OPS.multiply(___x, ___y)))
                )
                (ß num(___ret))
            )
        )
    )

    (§ defn #_"long" LongOps'gcd [#_"long" ___u, #_"long" ___v]
        (while (ß ___v != 0)
            (let [#_"long" ___r (ß ___u % ___v)]
                (§ ass ___u ___v)
                (§ ass ___v ___r)
            )
        )
        u
    )

    #_method
    (§ defn #_"Number" divide [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___n (ß ___x.longValue())]
            (let [#_"long" ___val (ß ___y.longValue())]
                (let [#_"long" ___gcd (ß LongOps'gcd(___n, ___val))]
                    (when (ß ___gcd == 0)
                        (§ return (ß num(0)))
                    )

                    (§ ass ___n (ß ___n / ___gcd))
                    (let [#_"long" ___d (ß ___val / ___gcd)]
                        (when (ß ___d == 1)
                            (§ return (ß num(___n)))
                        )
                        (when (ß ___d < 0)
                            (§ ass ___n (ß -n))
                            (§ ass ___d (ß -d))
                        )
                        (ß new Ratio(BigInteger/valueOf(___n), BigInteger/valueOf(___d)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" quotient [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(___x.longValue() / ___y.longValue()))
    )

    #_method
    (§ defn #_"Number" remainder [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(___x.longValue() % ___y.longValue()))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.longValue() == ___y.longValue()))
    )

    #_method
    (§ defn #_"boolean" lt [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.longValue() < ___y.longValue()))
    )

    #_method
    (§ defn #_"boolean" lte [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.longValue() <= ___y.longValue()))
    )

    #_method
    (§ defn #_"boolean" gte [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.longValue() >= ___y.longValue()))
    )

    #_method
    (§ defn #_"Number" negate [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (ß num(Numbers'minus(___val)))
        )
    )

    #_method
    (§ defn #_"Number" negateP [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (when (ß ___val > Long/MIN_VALUE)
                (§ return (ß num(-val)))
            )
            (ß BigInt'fromBigInteger(BigInteger/valueOf(___val).negate()))
        )
    )

    #_method
    (§ defn #_"Number" inc [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (ß num(Numbers'inc(___val)))
        )
    )

    #_method
    (§ defn #_"Number" incP [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (when (ß ___val < Long/MAX_VALUE)
                (§ return (ß num(___val + 1)))
            )
            (ß BIGINT_OPS.inc(___x))
        )
    )

    #_method
    (§ defn #_"Number" dec [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (ß num(Numbers'dec(___val)))
        )
    )

    #_method
    (§ defn #_"Number" decP [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (when (ß ___val > Long/MIN_VALUE)
                (§ return (ß num(___val - 1)))
            )
            (ß BIGINT_OPS.dec(___x))
        )
    )
)

#_stateless
(class-ns DoubleOps (§ extends OpsP)
    #_method
    (§ defn #_"Ops" combine [#_"DoubleOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"DoubleOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"BigDecimalOps" ___x]
        this
    )

    #_method
    (§ defn #_"boolean" isZero [#_"DoubleOps" this, #_"Number" ___x]
        (ß (___x.doubleValue() == 0))
    )

    #_method
    (§ defn #_"boolean" isPos [#_"DoubleOps" this, #_"Number" ___x]
        (ß (___x.doubleValue() > 0))
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"DoubleOps" this, #_"Number" ___x]
        (ß (___x.doubleValue() < 0))
    )

    #_method
    (§ defn #_"Number" add [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf(___x.doubleValue() + ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" multiply [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf(___x.doubleValue() * ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" divide [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf(___x.doubleValue() / ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" quotient [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'quotient(___x.doubleValue(), ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" remainder [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'remainder(___x.doubleValue(), ___y.doubleValue()))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.doubleValue() == ___y.doubleValue()))
    )

    #_method
    (§ defn #_"boolean" lt [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.doubleValue() < ___y.doubleValue()))
    )

    #_method
    (§ defn #_"boolean" lte [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.doubleValue() <= ___y.doubleValue()))
    )

    #_method
    (§ defn #_"boolean" gte [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.doubleValue() >= ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" negate [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf(-x.doubleValue()))
    )

    #_method
    (§ defn #_"Number" inc [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf(___x.doubleValue() + 1))
    )

    #_method
    (§ defn #_"Number" dec [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf(___x.doubleValue() - 1))
    )
)

#_stateless
(class-ns RatioOps (§ extends OpsP)
    #_method
    (§ defn #_"Ops" combine [#_"RatioOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"DoubleOps" ___x]
        DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"BigDecimalOps" ___x]
        BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" isZero [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß (___r.numerator.signum() == 0))
        )
    )

    #_method
    (§ defn #_"boolean" isPos [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß (___r.numerator.signum() > 0))
        )
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß (___r.numerator.signum() < 0))
        )
    )

    (§ defn #_"Number" RatioOps'normalizeRet [#_"Number" ___ret, #_"Number" ___x, #_"Number" ___y]
        ret
    )

    #_method
    (§ defn #_"Number" add [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß divide(___ry.numerator.multiply(___rx.denominator).add(___rx.numerator.multiply(___ry.denominator)), ___ry.denominator.multiply(___rx.denominator)))]
                    (ß RatioOps'normalizeRet(___ret, ___x, ___y))
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" multiply [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß Numbers'divide(___ry.numerator.multiply(___rx.numerator), ___ry.denominator.multiply(___rx.denominator)))]
                    (ß RatioOps'normalizeRet(___ret, ___x, ___y))
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" divide [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß Numbers'divide(___ry.denominator.multiply(___rx.numerator), ___ry.numerator.multiply(___rx.denominator)))]
                    (ß RatioOps'normalizeRet(___ret, ___x, ___y))
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" quotient [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"BigInteger" ___q (ß ___rx.numerator.multiply(___ry.denominator).divide(___rx.denominator.multiply(___ry.numerator)))]
                    (ß RatioOps'normalizeRet(BigInt'fromBigInteger(___q), ___x, ___y))
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" remainder [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"BigInteger" ___q (ß ___rx.numerator.multiply(___ry.denominator).divide(___rx.denominator.multiply(___ry.numerator)))]
                    (let [#_"Number" ___ret (ß Numbers'minus(___x, Numbers'multiply(___q, ___y)))]
                        (ß RatioOps'normalizeRet(___ret, ___x, ___y))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß (___rx.numerator.equals(___ry.numerator) && ___rx.denominator.equals(___ry.denominator)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" lt [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'lt(___rx.numerator.multiply(___ry.denominator), ___ry.numerator.multiply(___rx.denominator)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" lte [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'lte(___rx.numerator.multiply(___ry.denominator), ___ry.numerator.multiply(___rx.denominator)))
            )
        )
    )

    #_method
    (§ defn #_"boolean" gte [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'gte(___rx.numerator.multiply(___ry.denominator), ___ry.numerator.multiply(___rx.denominator)))
            )
        )
    )

    #_method
    (§ defn #_"Number" negate [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß new Ratio(___r.numerator.negate(), ___r.denominator))
        )
    )

    #_method
    (§ defn #_"Number" inc [#_"RatioOps" this, #_"Number" ___x]
        (ß Numbers'add(___x, 1))
    )

    #_method
    (§ defn #_"Number" dec [#_"RatioOps" this, #_"Number" ___x]
        (ß Numbers'add(___x, -1))
    )
)

#_stateless
(class-ns BigIntOps (§ extends OpsP)
    #_method
    (§ defn #_"Ops" combine [#_"BigIntOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"DoubleOps" ___x]
        DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"RatioOps" ___x]
        RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"BigDecimalOps" ___x]
        BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" isZero [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß ___bx.bipart == nil)
                (§ return (ß (___bx.lpart == 0)))
            )
            (ß (___bx.bipart.signum() == 0))
        )
    )

    #_method
    (§ defn #_"boolean" isPos [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß ___bx.bipart == nil)
                (§ return (ß (___bx.lpart > 0)))
            )
            (ß (___bx.bipart.signum() > 0))
        )
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß ___bx.bipart == nil)
                (§ return (ß (___bx.lpart < 0)))
            )
            (ß (___bx.bipart.signum() < 0))
        )
    )

    #_method
    (§ defn #_"Number" add [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).add(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" multiply [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).multiply(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" divide [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'divide(toBigInteger(___x), toBigInteger(___y)))
    )

    #_method
    (§ defn #_"Number" quotient [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).quotient(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" remainder [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).remainder(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).equals(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" lt [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).lt(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" lte [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigInteger(___x).compareTo(toBigInteger(___y)) <= 0))
    )

    #_method
    (§ defn #_"boolean" gte [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigInteger(___x).compareTo(toBigInteger(___y)) >= 0))
    )

    #_method
    (§ defn #_"Number" negate [#_"BigIntOps" this, #_"Number" ___x]
        (ß BigInt'fromBigInteger(toBigInteger(___x).negate()))
    )

    #_method
    (§ defn #_"Number" inc [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInteger" ___bx (ß toBigInteger(___x))]
            (ß BigInt'fromBigInteger(___bx.add(BigInteger/ONE)))
        )
    )

    #_method
    (§ defn #_"Number" dec [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInteger" ___bx (ß toBigInteger(___x))]
            (ß BigInt'fromBigInteger(___bx.subtract(BigInteger/ONE)))
        )
    )
)

#_stateless
(class-ns BigDecimalOps (§ extends OpsP)
    (§ def #_"Var" BigDecimalOps'MATH_CONTEXT (ß RT'MATH_CONTEXT))

    #_method
    (§ defn #_"Ops" combine [#_"BigDecimalOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"DoubleOps" ___x]
        DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"BigDecimalOps" ___x]
        this
    )

    #_method
    (§ defn #_"boolean" isZero [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß (___bx.signum() == 0))
        )
    )

    #_method
    (§ defn #_"boolean" isPos [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß (___bx.signum() > 0))
        )
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß (___bx.signum() < 0))
        )
    )

    #_method
    (§ defn #_"Number" add [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).add(toBigDecimal(___y)) :or toBigDecimal(___x).add(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" multiply [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).multiply(toBigDecimal(___y)) :or toBigDecimal(___x).multiply(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" divide [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).divide(toBigDecimal(___y)) :or toBigDecimal(___x).divide(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" quotient [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).divideToIntegralValue(toBigDecimal(___y)) :or toBigDecimal(___x).divideToIntegralValue(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" remainder [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).remainder(toBigDecimal(___y)) :or toBigDecimal(___x).remainder(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigDecimal(___x).compareTo(toBigDecimal(___y)) == 0))
    )

    #_method
    (§ defn #_"boolean" lt [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigDecimal(___x).compareTo(toBigDecimal(___y)) < 0))
    )

    #_method
    (§ defn #_"boolean" lte [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigDecimal(___x).compareTo(toBigDecimal(___y)) <= 0))
    )

    #_method
    (§ defn #_"boolean" gte [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigDecimal(___x).compareTo(toBigDecimal(___y)) >= 0))
    )

    #_method
    (§ defn #_"Number" negate [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? ((BigDecimal) ___x).negate() :or ((BigDecimal) ___x).negate(___mc))
        )
    )

    #_method
    (§ defn #_"Number" inc [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                (ß (___mc == nil) ? ___bx.add(BigDecimal/ONE) :or ___bx.add(BigDecimal/ONE, ___mc))
            )
        )
    )

    #_method
    (§ defn #_"Number" dec [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                (ß (___mc == nil) ? ___bx.subtract(BigDecimal/ONE) :or ___bx.subtract(BigDecimal/ONE, ___mc))
            )
        )
    )
)

(def Category'enum-set
    (hash-set
        :Category'INTEGER
        :Category'FLOATING
        :Category'DECIMAL
        :Category'RATIO
    )
)

#_stateless
(class-ns Numbers
    (§ defn #_"boolean" Numbers'isZero [#_"Object" ___x]
        (ß ops(___x).isZero((Number)___x))
    )

    (§ defn #_"boolean" Numbers'isPos [#_"Object" ___x]
        (ß ops(___x).isPos((Number)___x))
    )

    (§ defn #_"boolean" Numbers'isNeg [#_"Object" ___x]
        (ß ops(___x).isNeg((Number)___x))
    )

    (§ defn #_"Number" Numbers'minus [#_"Object" ___x]
        (ß ops(___x).negate((Number)___x))
    )

    (§ defn #_"Number" Numbers'minusP [#_"Object" ___x]
        (ß ops(___x).negateP((Number)___x))
    )

    (§ defn #_"Number" Numbers'inc [#_"Object" ___x]
        (ß ops(___x).inc((Number)___x))
    )

    (§ defn #_"Number" Numbers'incP [#_"Object" ___x]
        (ß ops(___x).incP((Number)___x))
    )

    (§ defn #_"Number" Numbers'dec [#_"Object" ___x]
        (ß ops(___x).dec((Number)___x))
    )

    (§ defn #_"Number" Numbers'decP [#_"Object" ___x]
        (ß ops(___x).decP((Number)___x))
    )

    (§ defn #_"Number" Numbers'add [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).add((Number)___x, (Number)___y))
    )

    (§ defn #_"Number" Numbers'addP [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).addP((Number)___x, (Number)___y))
    )

    (§ defn #_"Number" Numbers'minus [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (ß ops(___x).combine(___yops).add((Number)___x, ___yops.negate((Number)___y)))
        )
    )

    (§ defn #_"Number" Numbers'minusP [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (let [#_"Number" ___negativeY (ß ___yops.negateP((Number) ___y))]
                (let [#_"Ops" ___negativeYOps (ß ops(___negativeY))]
                    (ß ops(___x).combine(___negativeYOps).addP((Number)___x, ___negativeY))
                )
            )
        )
    )

    (§ defn #_"Number" Numbers'multiply [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).multiply((Number)___x, (Number)___y))
    )

    (§ defn #_"Number" Numbers'multiplyP [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).multiplyP((Number)___x, (Number)___y))
    )

    (§ defn #_"Number" Numbers'divide [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return (ß (Number)___x))
            )
            (ß isNaN(___y))
            (do
                (§ return (ß (Number)___y))
            )
        )
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((Number)___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).divide((Number)___x, (Number)___y))
        )
    )

    (§ defn #_"Number" Numbers'quotient [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((Number) ___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).quotient((Number)___x, (Number)___y))
        )
    )

    (§ defn #_"Number" Numbers'remainder [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((Number) ___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).remainder((Number)___x, (Number)___y))
        )
    )

    (§ defn #_"double" Numbers'quotient [#_"double" ___n, #_"double" ___d]
        (when (ß ___d == 0)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" ___q (ß ___n / ___d)]
            (cond (ß ___q <= Long/MAX_VALUE && ___q >= Long/MIN_VALUE)
                (do
                    (ß (double)(long) ___q)
                )
                :else ;; bigint quotient
                (do
                    (ß new BigDecimal(___q).toBigInteger().doubleValue())
                )
            )
        )
    )

    (§ defn #_"double" Numbers'remainder [#_"double" ___n, #_"double" ___d]
        (when (ß ___d == 0)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" ___q (ß ___n / ___d)]
            (cond (ß ___q <= Long/MAX_VALUE && ___q >= Long/MIN_VALUE)
                (do
                    (ß (___n - ((long) ___q) * ___d))
                )
                :else ;; bigint quotient
                (do
                    (let [#_"Number" ___bq (ß new BigDecimal(___q).toBigInteger())]
                        (ß (___n - ___bq.doubleValue() * ___d))
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" Numbers'equiv [#_"Object" ___x, #_"Object" ___y]
        (ß equiv((Number) ___x, (Number) ___y))
    )

    (§ defn #_"boolean" Numbers'equiv [#_"Number" ___x, #_"Number" ___y]
        (ß ops(___x).combine(ops(___y)).equiv(___x, ___y))
    )

    (§ defn #_"boolean" Numbers'equal [#_"Number" ___x, #_"Number" ___y]
        (ß (category(___x) == category(___y) && ops(___x).combine(ops(___y)).equiv(___x, ___y)))
    )

    (§ defn #_"boolean" Numbers'lt [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lt((Number)___x, (Number)___y))
    )

    (§ defn #_"boolean" Numbers'lte [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lte((Number)___x, (Number)___y))
    )

    (§ defn #_"boolean" Numbers'gt [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lt((Number)___y, (Number)___x))
    )

    (§ defn #_"boolean" Numbers'gte [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).gte((Number)___x, (Number)___y))
    )

    (§ defn #_"int" Numbers'compare [#_"Number" ___x, #_"Number" ___y]
        (let [#_"Ops" ___ops (ß ops(___x).combine(ops(___y)))]
            (cond (ß ___ops.lt(___x, ___y))
                (do
                    (§ return -1)
                )
                (ß ___ops.lt(___y, ___x))
                (do
                    (§ return 1)
                )
            )
            0
        )
    )

    (§ defn #_"BigInt" Numbers'toBigInt [#_"Object" ___x]
        (when (ß ___x instanceof BigInt)
            (§ return (ß (BigInt) ___x))
        )
        (if (ß ___x instanceof BigInteger)
            (do
                (ß BigInt'fromBigInteger((BigInteger) ___x))
            )
            (do
                (ß BigInt'fromLong(((Number) ___x).longValue()))
            )
        )
    )

    (§ defn #_"BigInteger" Numbers'toBigInteger [#_"Object" ___x]
        (cond (ß ___x instanceof BigInteger)
            (do
                (ß (BigInteger) ___x)
            )
            (ß ___x instanceof BigInt)
            (do
                (ß ((BigInt) ___x).toBigInteger())
            )
            :else
            (do
                (ß BigInteger/valueOf(((Number) ___x).longValue()))
            )
        )
    )

    (§ defn #_"BigDecimal" Numbers'toBigDecimal [#_"Object" ___x]
        (cond (ß ___x instanceof BigDecimal)
            (do
                (ß (BigDecimal) ___x)
            )
            (ß ___x instanceof BigInt)
            (do
                (let [#_"BigInt" ___bi (ß (BigInt) ___x)]
                    (if (ß ___bi.bipart == nil)
                        (do
                            (ß BigDecimal/valueOf(___bi.lpart))
                        )
                        (do
                            (BigDecimal. (ß ___bi.bipart))
                        )
                    )
                )
            )
            (ß ___x instanceof BigInteger)
            (do
                (ß new BigDecimal((BigInteger) ___x))
            )
            (ß ___x instanceof Double)
            (do
                (ß new BigDecimal(((Number) ___x).doubleValue()))
            )
            (ß ___x instanceof Float)
            (do
                (ß new BigDecimal(((Number) ___x).doubleValue()))
            )
            (ß ___x instanceof Ratio)
            (do
                (let [#_"Ratio" ___r (ß (Ratio)___x)]
                    (ß (BigDecimal)divide(new BigDecimal(___r.numerator), ___r.denominator))
                )
            )
            :else
            (do
                (ß BigDecimal/valueOf(((Number) ___x).longValue()))
            )
        )
    )

    (§ defn #_"Ratio" Numbers'toRatio [#_"Object" ___x]
        (cond (ß ___x instanceof Ratio)
            (do
                (§ return (ß (Ratio) ___x))
            )
            (ß ___x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                    (let [#_"BigInteger" ___bv (ß ___bx.unscaledValue())]
                        (let [#_"int" ___scale (ß ___bx.scale())]
                            (if (ß ___scale < 0)
                                (do
                                    (§ return (ß new Ratio(___bv.multiply(BigInteger/TEN.pow(-scale)), BigInteger/ONE)))
                                )
                                (do
                                    (§ return (ß new Ratio(___bv, BigInteger/TEN.pow(___scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        (ß new Ratio(toBigInteger(___x), BigInteger/ONE))
    )

    (§ defn #_"Number" Numbers'rationalize [#_"Number" ___x]
        (cond (ß ___x instanceof Float || ___x instanceof Double)
            (do
                (§ return (ß rationalize(BigDecimal/valueOf(___x.doubleValue()))))
            )
            (ß ___x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                    (let [#_"BigInteger" ___bv (ß ___bx.unscaledValue())]
                        (let [#_"int" ___scale (ß ___bx.scale())]
                            (if (ß ___scale < 0)
                                (do
                                    (§ return (ß BigInt'fromBigInteger(___bv.multiply(BigInteger/TEN.pow(-scale)))))
                                )
                                (do
                                    (§ return (ß divide(___bv, BigInteger/TEN.pow(___scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        x
    )

    (§ defn #_"Number" Numbers'reduceBigInt [#_"BigInt" ___val]
        (if (ß ___val.bipart == nil)
            (do
                (ß num(___val.lpart))
            )
            (do
                (ß ___val.bipart)
            )
        )
    )

    (§ defn #_"Number" Numbers'divide [#_"BigInteger" ___n, #_"BigInteger" ___d]
        (when (ß ___d.equals(BigInteger/ZERO))
            (throw (ArithmeticException. "Divide by zero"))
        )
        (let [#_"BigInteger" ___gcd (ß ___n.gcd(___d))]
            (when (ß ___gcd.equals(BigInteger/ZERO))
                (§ return (ß BigInt'ZERO))
            )
            (§ ass ___n (ß ___n.divide(___gcd)))
            (§ ass ___d (ß ___d.divide(___gcd)))
            (cond (ß ___d.equals(BigInteger/ONE))
                (do
                    (§ return (ß BigInt'fromBigInteger(___n)))
                )
                (ß ___d.equals(BigInteger/ONE.negate()))
                (do
                    (§ return (ß BigInt'fromBigInteger(___n.negate())))
                )
            )
            (ß new Ratio(((___d.signum() < 0) ? ___n.negate() :or ___n), ((___d.signum() < 0) ? ___d.negate() :or ___d)))
        )
    )

    (§ defn #_"int" Numbers'shiftLeftInt [#_"int" ___x, #_"int" ___n]
        (ß ___x << ___n)
    )

    (§ defn #_"long" Numbers'shiftLeft [#_"Object" ___x, #_"Object" ___y]
        (ß shiftLeft(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (§ defn #_"long" Numbers'shiftLeft [#_"Object" ___x, #_"long" ___y]
        (ß shiftLeft(bitOpsCast(___x), ___y))
    )
    (§ defn #_"long" Numbers'shiftLeft [#_"long" ___x, #_"Object" ___y]
        (ß shiftLeft(___x, bitOpsCast(___y)))
    )
    (§ defn #_"long" Numbers'shiftLeft [#_"long" ___x, #_"long" ___n]
        (ß ___x << ___n)
    )

    (§ defn #_"int" Numbers'shiftRightInt [#_"int" ___x, #_"int" ___n]
        (ß ___x >> ___n)
    )

    (§ defn #_"long" Numbers'shiftRight [#_"Object" ___x, #_"Object" ___y]
        (ß shiftRight(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (§ defn #_"long" Numbers'shiftRight [#_"Object" ___x, #_"long" ___y]
        (ß shiftRight(bitOpsCast(___x), ___y))
    )
    (§ defn #_"long" Numbers'shiftRight [#_"long" ___x, #_"Object" ___y]
        (ß shiftRight(___x, bitOpsCast(___y)))
    )
    (§ defn #_"long" Numbers'shiftRight [#_"long" ___x, #_"long" ___n]
        (ß ___x >> ___n)
    )

    (§ defn #_"int" Numbers'unsignedShiftRightInt [#_"int" ___x, #_"int" ___n]
        (ß ___x >>> ___n)
    )

    (§ defn #_"long" Numbers'unsignedShiftRight [#_"Object" ___x, #_"Object" ___y]
        (ß unsignedShiftRight(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (§ defn #_"long" Numbers'unsignedShiftRight [#_"Object" ___x, #_"long" ___y]
        (ß unsignedShiftRight(bitOpsCast(___x), ___y))
    )
    (§ defn #_"long" Numbers'unsignedShiftRight [#_"long" ___x, #_"Object" ___y]
        (ß unsignedShiftRight(___x, bitOpsCast(___y)))
    )
    (§ defn #_"long" Numbers'unsignedShiftRight [#_"long" ___x, #_"long" ___n]
        (ß ___x >>> ___n)
    )

    (§ def #_"LongOps" Numbers'LONG_OPS (LongOps.))
    (§ def #_"DoubleOps" Numbers'DOUBLE_OPS (DoubleOps.))
    (§ def #_"RatioOps" Numbers'RATIO_OPS (RatioOps.))
    (§ def #_"BigIntOps" Numbers'BIGINT_OPS (BigIntOps.))
    (§ def #_"BigDecimalOps" Numbers'BIGDECIMAL_OPS (BigDecimalOps.))

    (§ defn #_"Ops" Numbers'ops [#_"Object" ___x]
        (let [#_"Class" ___xc (ß ___x.getClass())]
            (cond (ß ___xc == (§ class Long))
                (do
                    LONG_OPS
                )
                (ß ___xc == (§ class Double))
                (do
                    DOUBLE_OPS
                )
                (ß ___xc == (§ class Integer))
                (do
                    LONG_OPS
                )
                (ß ___xc == (§ class Float))
                (do
                    DOUBLE_OPS
                )
                (ß ___xc == (§ class BigInt))
                (do
                    BIGINT_OPS
                )
                (ß ___xc == (§ class BigInteger))
                (do
                    BIGINT_OPS
                )
                (ß ___xc == (§ class Ratio))
                (do
                    RATIO_OPS
                )
                (ß ___xc == (§ class BigDecimal))
                (do
                    BIGDECIMAL_OPS
                )
                :else
                (do
                    LONG_OPS
                )
            )
        )
    )

    (§ defn #_"int" Numbers'hasheqFrom [#_"Number" ___x, #_"Class" ___xc]
        (when (ß ___xc == (§ class Integer) || ___xc == (§ class Short) || ___xc == (§ class Byte) || (___xc == (§ class BigInteger) && lte(___x, Long/MAX_VALUE) && gte(___x, Long/MIN_VALUE)))
            (let [#_"long" ___lpart (ß ___x.longValue())]
                (§ return (ß Murmur3'hashLong(___lpart)))
            )
        )
        (when (ß ___xc == (§ class BigDecimal))
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode. Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (if (ß isZero(___x))
                (do
                    (§ return (ß BigDecimal/ZERO.hashCode()))
                )
                (do
                    (§ return (ß ((BigDecimal) ___x).stripTrailingZeros().hashCode()))
                )
            )
        )
        (when (ß ___xc == (§ class Float) && ___x.equals((float) -0.0))
            (§ return 0) ;; match 0.0f
        )
        (ß ___x.hashCode())
    )

    (§ defn #_"int" Numbers'hasheq [#_"Number" ___x]
        (let [#_"Class" ___xc (ß ___x.getClass())]
            (when (ß ___xc == (§ class Long))
                (let [#_"long" ___lpart (ß ___x.longValue())]
                    (§ return (ß Murmur3'hashLong(___lpart)))
                )
            )
            (when (ß ___xc == (§ class Double))
                (when (ß ___x.equals(-0.0))
                    (§ return 0) ;; match 0.0
                )
                (§ return (ß ___x.hashCode()))
            )
            (ß hasheqFrom(___x, ___xc))
        )
    )

    (§ defn #_"Category" Numbers'category [#_"Object" ___x]
        (let [#_"Class" ___xc (ß ___x.getClass())]
            (cond (ß ___xc == (§ class Integer))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Double))
                (do
                    (ß :Category'FLOATING)
                )
                (ß ___xc == (§ class Long))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Float))
                (do
                    (ß :Category'FLOATING)
                )
                (ß ___xc == (§ class BigInt))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Ratio))
                (do
                    (ß :Category'RATIO)
                )
                (ß ___xc == (§ class BigDecimal))
                (do
                    (ß :Category'DECIMAL)
                )
                :else
                (do
                    (ß :Category'INTEGER)
                )
            )
        )
    )

    (§ defn #_"long" Numbers'bitOpsCast [#_"Object" ___x]
        (let [#_"Class" ___xc (ß ___x.getClass())]
            (when (ß ___xc == (§ class Long) || ___xc == (§ class Integer) || ___xc == (§ class Short) || ___xc == (§ class Byte))
                (§ return (ß RT'longCast(___x)))
            )
            ;; no bignums, no decimals
            (throw (IllegalArgumentException. (ß "bit operation not supported for: " + ___xc)))
        )
    )

    (§ defn #_"float[]" Numbers'float_array [#_"int" ___size, #_"Object" ___init]
        (let [#_"float[]" ___ret (ß new float[___size])]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"float" ___f (ß ((Number) ___init).floatValue())]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (ß RT'seq(___init))]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).floatValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"float[]" Numbers'float_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new float[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"float[]" ___ret (ß new float[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).floatValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"double[]" Numbers'double_array [#_"int" ___size, #_"Object" ___init]
        (let [#_"double[]" ___ret (ß new double[___size])]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"double" ___f (ß ((Number) ___init).doubleValue())]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (ß RT'seq(___init))]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).doubleValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"double[]" Numbers'double_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new double[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"double[]" ___ret (ß new double[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).doubleValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"int[]" Numbers'int_array [#_"int" ___size, #_"Object" ___init]
        (let [#_"int[]" ___ret (ß new int[___size])]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"int" ___f (ß ((Number) ___init).intValue())]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (ß RT'seq(___init))]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).intValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"int[]" Numbers'int_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new int[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"int[]" ___ret (ß new int[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).intValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"long[]" Numbers'long_array [#_"int" ___size, #_"Object" ___init]
        (let [#_"long[]" ___ret (ß new long[___size])]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"long" ___f (ß ((Number) ___init).longValue())]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (ß RT'seq(___init))]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).longValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"long[]" Numbers'long_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new long[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"long[]" ___ret (ß new long[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).longValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"short[]" Numbers'short_array [#_"int" ___size, #_"Object" ___init]
        (let [#_"short[]" ___ret (ß new short[___size])]
            (if (ß ___init instanceof Short)
                (do
                    (let [#_"short" ___s (ß (Short) ___init)]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) ___s)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (ß RT'seq(___init))]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).shortValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"short[]" Numbers'short_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new short[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"short[]" ___ret (ß new short[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).shortValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"char[]" Numbers'char_array [#_"int" ___size, #_"Object" ___init]
        (let [#_"char[]" ___ret (ß new char[___size])]
            (if (ß ___init instanceof Character)
                (do
                    (let [#_"char" ___c (ß (Character) ___init)]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) ___c)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (ß RT'seq(___init))]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß (Character) ___s.first()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"char[]" Numbers'char_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new char[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"char[]" ___ret (ß new char[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß (Character) ___s.first()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"byte[]" Numbers'byte_array [#_"int" ___size, #_"Object" ___init]
        (let [#_"byte[]" ___ret (ß new byte[___size])]
            (if (ß ___init instanceof Byte)
                (do
                    (let [#_"byte" ___b (ß (Byte) ___init)]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) ___b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (ß RT'seq(___init))]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).byteValue()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"byte[]" Numbers'byte_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new byte[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"byte[]" ___ret (ß new byte[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).byteValue()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean[]" Numbers'boolean_array [#_"int" ___size, #_"Object" ___init]
        (let [#_"boolean[]" ___ret (ß new boolean[___size])]
            (if (ß ___init instanceof Boolean)
                (do
                    (let [#_"boolean" ___b (ß (Boolean) ___init)]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) ___b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (ß RT'seq(___init))]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß (Boolean)___s.first()))
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"boolean[]" Numbers'boolean_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new boolean[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"boolean[]" ___ret (ß new boolean[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß (Boolean)___s.first()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"boolean[]" Numbers'booleans [#_"Object" ___array]
        (ß (boolean[]) ___array)
    )

    (§ defn #_"byte[]" Numbers'bytes [#_"Object" ___array]
        (ß (byte[]) ___array)
    )

    (§ defn #_"char[]" Numbers'chars [#_"Object" ___array]
        (ß (char[]) ___array)
    )

    (§ defn #_"short[]" Numbers'shorts [#_"Object" ___array]
        (ß (short[]) ___array)
    )

    (§ defn #_"float[]" Numbers'floats [#_"Object" ___array]
        (ß (float[]) ___array)
    )

    (§ defn #_"double[]" Numbers'doubles [#_"Object" ___array]
        (ß (double[]) ___array)
    )

    (§ defn #_"int[]" Numbers'ints [#_"Object" ___array]
        (ß (int[]) ___array)
    )

    (§ defn #_"long[]" Numbers'longs [#_"Object" ___array]
        (ß (long[]) ___array)
    )

    (§ defn #_"Number" Numbers'num [#_"Object" ___x]
        (ß (Number) ___x)
    )

    (§ defn #_"Number" Numbers'num [#_"float" ___x]
        (ß Float/valueOf(___x))
    )

    (§ defn #_"Number" Numbers'num [#_"double" ___x]
        (ß Double/valueOf(___x))
    )

    (§ defn #_"double" Numbers'add [#_"double" ___x, #_"double" ___y]
        (ß ___x + ___y)
    )

    (§ defn #_"double" Numbers'addP [#_"double" ___x, #_"double" ___y]
        (ß ___x + ___y)
    )

    (§ defn #_"double" Numbers'minus [#_"double" ___x, #_"double" ___y]
        (ß ___x - ___y)
    )

    (§ defn #_"double" Numbers'minusP [#_"double" ___x, #_"double" ___y]
        (ß ___x - ___y)
    )

    (§ defn #_"double" Numbers'minus [#_"double" ___x]
        (ß -x)
    )

    (§ defn #_"double" Numbers'minusP [#_"double" ___x]
        (ß -x)
    )

    (§ defn #_"double" Numbers'inc [#_"double" ___x]
        (ß ___x + 1)
    )

    (§ defn #_"double" Numbers'incP [#_"double" ___x]
        (ß ___x + 1)
    )

    (§ defn #_"double" Numbers'dec [#_"double" ___x]
        (ß ___x - 1)
    )

    (§ defn #_"double" Numbers'decP [#_"double" ___x]
        (ß ___x - 1)
    )

    (§ defn #_"double" Numbers'multiply [#_"double" ___x, #_"double" ___y]
        (ß ___x * ___y)
    )

    (§ defn #_"double" Numbers'multiplyP [#_"double" ___x, #_"double" ___y]
        (ß ___x * ___y)
    )

    (§ defn #_"double" Numbers'divide [#_"double" ___x, #_"double" ___y]
        (ß ___x / ___y)
    )

    (§ defn #_"boolean" Numbers'equiv [#_"double" ___x, #_"double" ___y]
        (ß (___x == ___y))
    )

    (§ defn #_"boolean" Numbers'lt [#_"double" ___x, #_"double" ___y]
        (ß (___x < ___y))
    )

    (§ defn #_"boolean" Numbers'lte [#_"double" ___x, #_"double" ___y]
        (ß (___x <= ___y))
    )

    (§ defn #_"boolean" Numbers'gt [#_"double" ___x, #_"double" ___y]
        (ß (___x > ___y))
    )

    (§ defn #_"boolean" Numbers'gte [#_"double" ___x, #_"double" ___y]
        (ß (___x >= ___y))
    )

    (§ defn #_"boolean" Numbers'isPos [#_"double" ___x]
        (ß (___x > 0))
    )

    (§ defn #_"boolean" Numbers'isNeg [#_"double" ___x]
        (ß (___x < 0))
    )

    (§ defn #_"boolean" Numbers'isZero [#_"double" ___x]
        (ß (___x == 0))
    )

    (§ defn #_"int" Numbers'throwIntOverflow []
        (throw (ArithmeticException. "integer overflow"))
    )

    (§ defn #_"int" Numbers'unchecked_int_add [#_"int" ___x, #_"int" ___y]
        (ß ___x + ___y)
    )

    (§ defn #_"int" Numbers'unchecked_int_subtract [#_"int" ___x, #_"int" ___y]
        (ß ___x - ___y)
    )

    (§ defn #_"int" Numbers'unchecked_int_negate [#_"int" ___x]
        (ß -x)
    )

    (§ defn #_"int" Numbers'unchecked_int_inc [#_"int" ___x]
        (ß ___x + 1)
    )

    (§ defn #_"int" Numbers'unchecked_int_dec [#_"int" ___x]
        (ß ___x - 1)
    )

    (§ defn #_"int" Numbers'unchecked_int_multiply [#_"int" ___x, #_"int" ___y]
        (ß ___x * ___y)
    )

    (§ defn #_"long" Numbers'not [#_"Object" ___x]
        (ß not(bitOpsCast(___x)))
    )

    (§ defn #_"long" Numbers'not [#_"long" ___x]
        (ß ~___x)
    )

    (§ defn #_"long" Numbers'and [#_"Object" ___x, #_"Object" ___y]
        (ß and(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'and [#_"Object" ___x, #_"long" ___y]
        (ß and(bitOpsCast(___x), ___y))
    )

    (§ defn #_"long" Numbers'and [#_"long" ___x, #_"Object" ___y]
        (ß and(___x, bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'and [#_"long" ___x, #_"long" ___y]
        (ß ___x & ___y)
    )

    (§ defn #_"long" Numbers'or [#_"Object" ___x, #_"Object" ___y]
        (ß or(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'or [#_"Object" ___x, #_"long" ___y]
        (ß or(bitOpsCast(___x), ___y))
    )

    (§ defn #_"long" Numbers'or [#_"long" ___x, #_"Object" ___y]
        (ß or(___x, bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'or [#_"long" ___x, #_"long" ___y]
        (ß ___x | ___y)
    )

    (§ defn #_"long" Numbers'xor [#_"Object" ___x, #_"Object" ___y]
        (ß xor(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'xor [#_"Object" ___x, #_"long" ___y]
        (ß xor(bitOpsCast(___x), ___y))
    )

    (§ defn #_"long" Numbers'xor [#_"long" ___x, #_"Object" ___y]
        (ß xor(___x, bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'xor [#_"long" ___x, #_"long" ___y]
        (ß ___x :xor ___y)
    )

    (§ defn #_"long" Numbers'andNot [#_"Object" ___x, #_"Object" ___y]
        (ß andNot(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'andNot [#_"Object" ___x, #_"long" ___y]
        (ß andNot(bitOpsCast(___x), ___y))
    )

    (§ defn #_"long" Numbers'andNot [#_"long" ___x, #_"Object" ___y]
        (ß andNot(___x, bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'andNot [#_"long" ___x, #_"long" ___y]
        (ß ___x & ~___y)
    )

    (§ defn #_"long" Numbers'clearBit [#_"Object" ___x, #_"Object" ___y]
        (ß clearBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'clearBit [#_"Object" ___x, #_"long" ___y]
        (ß clearBit(bitOpsCast(___x), ___y))
    )

    (§ defn #_"long" Numbers'clearBit [#_"long" ___x, #_"Object" ___y]
        (ß clearBit(___x, bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'clearBit [#_"long" ___x, #_"long" ___n]
        (ß ___x & ~(1 << ___n))
    )

    (§ defn #_"long" Numbers'setBit [#_"Object" ___x, #_"Object" ___y]
        (ß setBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'setBit [#_"Object" ___x, #_"long" ___y]
        (ß setBit(bitOpsCast(___x), ___y))
    )

    (§ defn #_"long" Numbers'setBit [#_"long" ___x, #_"Object" ___y]
        (ß setBit(___x, bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'setBit [#_"long" ___x, #_"long" ___n]
        (ß ___x | (1 << ___n))
    )

    (§ defn #_"long" Numbers'flipBit [#_"Object" ___x, #_"Object" ___y]
        (ß flipBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'flipBit [#_"Object" ___x, #_"long" ___y]
        (ß flipBit(bitOpsCast(___x), ___y))
    )

    (§ defn #_"long" Numbers'flipBit [#_"long" ___x, #_"Object" ___y]
        (ß flipBit(___x, bitOpsCast(___y)))
    )

    (§ defn #_"long" Numbers'flipBit [#_"long" ___x, #_"long" ___n]
        (ß ___x :xor (1 << ___n))
    )

    (§ defn #_"boolean" Numbers'testBit [#_"Object" ___x, #_"Object" ___y]
        (ß testBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (§ defn #_"boolean" Numbers'testBit [#_"Object" ___x, #_"long" ___y]
        (ß testBit(bitOpsCast(___x), ___y))
    )

    (§ defn #_"boolean" Numbers'testBit [#_"long" ___x, #_"Object" ___y]
        (ß testBit(___x, bitOpsCast(___y)))
    )

    (§ defn #_"boolean" Numbers'testBit [#_"long" ___x, #_"long" ___n]
        (ß ((___x & (1 << ___n)) != 0))
    )

    (§ defn #_"int" Numbers'unchecked_int_divide [#_"int" ___x, #_"int" ___y]
        (ß ___x / ___y)
    )

    (§ defn #_"int" Numbers'unchecked_int_remainder [#_"int" ___x, #_"int" ___y]
        (ß ___x % ___y)
    )

    (§ defn #_"Number" Numbers'num [#_"long" ___x]
        (ß Long/valueOf(___x))
    )

    (§ defn #_"long" Numbers'unchecked_add [#_"long" ___x, #_"long" ___y]
        (ß ___x + ___y)
    )

    (§ defn #_"long" Numbers'unchecked_minus [#_"long" ___x, #_"long" ___y]
        (ß ___x - ___y)
    )

    (§ defn #_"long" Numbers'unchecked_multiply [#_"long" ___x, #_"long" ___y]
        (ß ___x * ___y)
    )

    (§ defn #_"long" Numbers'unchecked_minus [#_"long" ___x]
        (ß -x)
    )

    (§ defn #_"long" Numbers'unchecked_inc [#_"long" ___x]
        (ß ___x + 1)
    )

    (§ defn #_"long" Numbers'unchecked_dec [#_"long" ___x]
        (ß ___x - 1)
    )

    (§ defn #_"Number" Numbers'unchecked_add [#_"Object" ___x, #_"Object" ___y]
        (ß add(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_minus [#_"Object" ___x, #_"Object" ___y]
        (ß minus(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_multiply [#_"Object" ___x, #_"Object" ___y]
        (ß multiply(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_minus [#_"Object" ___x]
        (ß minus(___x))
    )

    (§ defn #_"Number" Numbers'unchecked_inc [#_"Object" ___x]
        (ß inc(___x))
    )

    (§ defn #_"Number" Numbers'unchecked_dec [#_"Object" ___x]
        (ß dec(___x))
    )

    (§ defn #_"double" Numbers'unchecked_add [#_"double" ___x, #_"double" ___y]
        (ß add(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_minus [#_"double" ___x, #_"double" ___y]
        (ß minus(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_multiply [#_"double" ___x, #_"double" ___y]
        (ß multiply(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_minus [#_"double" ___x]
        (ß minus(___x))
    )

    (§ defn #_"double" Numbers'unchecked_inc [#_"double" ___x]
        (ß inc(___x))
    )

    (§ defn #_"double" Numbers'unchecked_dec [#_"double" ___x]
        (ß dec(___x))
    )

    (§ defn #_"double" Numbers'unchecked_add [#_"double" ___x, #_"Object" ___y]
        (ß add(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_minus [#_"double" ___x, #_"Object" ___y]
        (ß minus(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_multiply [#_"double" ___x, #_"Object" ___y]
        (ß multiply(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_add [#_"Object" ___x, #_"double" ___y]
        (ß add(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_minus [#_"Object" ___x, #_"double" ___y]
        (ß minus(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_multiply [#_"Object" ___x, #_"double" ___y]
        (ß multiply(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_add [#_"double" ___x, #_"long" ___y]
        (ß add(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_minus [#_"double" ___x, #_"long" ___y]
        (ß minus(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_multiply [#_"double" ___x, #_"long" ___y]
        (ß multiply(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_add [#_"long" ___x, #_"double" ___y]
        (ß add(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_minus [#_"long" ___x, #_"double" ___y]
        (ß minus(___x, ___y))
    )

    (§ defn #_"double" Numbers'unchecked_multiply [#_"long" ___x, #_"double" ___y]
        (ß multiply(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_add [#_"long" ___x, #_"Object" ___y]
        (ß add(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_minus [#_"long" ___x, #_"Object" ___y]
        (ß minus(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_multiply [#_"long" ___x, #_"Object" ___y]
        (ß multiply(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_add [#_"Object" ___x, #_"long" ___y]
        (ß add(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_minus [#_"Object" ___x, #_"long" ___y]
        (ß minus(___x, ___y))
    )

    (§ defn #_"Number" Numbers'unchecked_multiply [#_"Object" ___x, #_"long" ___y]
        (ß multiply(___x, ___y))
    )

    (§ defn #_"Number" Numbers'quotient [#_"double" ___x, #_"Object" ___y]
        (ß quotient((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'quotient [#_"Object" ___x, #_"double" ___y]
        (ß quotient(___x, (Object)___y))
    )

    (§ defn #_"Number" Numbers'quotient [#_"long" ___x, #_"Object" ___y]
        (ß quotient((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'quotient [#_"Object" ___x, #_"long" ___y]
        (ß quotient(___x, (Object)___y))
    )

    (§ defn #_"double" Numbers'quotient [#_"double" ___x, #_"long" ___y]
        (ß quotient(___x, (double)___y))
    )

    (§ defn #_"double" Numbers'quotient [#_"long" ___x, #_"double" ___y]
        (ß quotient((double)___x, ___y))
    )

    (§ defn #_"Number" Numbers'remainder [#_"double" ___x, #_"Object" ___y]
        (ß remainder((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'remainder [#_"Object" ___x, #_"double" ___y]
        (ß remainder(___x, (Object)___y))
    )

    (§ defn #_"Number" Numbers'remainder [#_"long" ___x, #_"Object" ___y]
        (ß remainder((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'remainder [#_"Object" ___x, #_"long" ___y]
        (ß remainder(___x, (Object)___y))
    )

    (§ defn #_"double" Numbers'remainder [#_"double" ___x, #_"long" ___y]
        (ß remainder(___x, (double)___y))
    )

    (§ defn #_"double" Numbers'remainder [#_"long" ___x, #_"double" ___y]
        (ß remainder((double)___x, ___y))
    )

    (§ defn #_"long" Numbers'add [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (ß ___x + ___y)]
            (when (ß (___ret :xor ___x) < 0 && (___ret :xor ___y) < 0)
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" Numbers'addP [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (ß ___x + ___y)]
            (when (ß (___ret :xor ___x) < 0 && (___ret :xor ___y) < 0)
                (§ return (ß addP((Number)___x, (Number)___y)))
            )
            (ß num(___ret))
        )
    )

    (§ defn #_"long" Numbers'minus [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (ß ___x - ___y)]
            (when (ß ((___ret :xor ___x) < 0 && (___ret :xor ~___y) < 0))
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" Numbers'minusP [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (ß ___x - ___y)]
            (when (ß ((___ret :xor ___x) < 0 && (___ret :xor ~___y) < 0))
                (§ return (ß minusP((Number)___x, (Number)___y)))
            )
            (ß num(___ret))
        )
    )

    (§ defn #_"long" Numbers'minus [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß -x)
    )

    (§ defn #_"Number" Numbers'minusP [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß BigInt'fromBigInteger(BigInteger/valueOf(___x).negate())))
        )
        (ß num(-x))
    )

    (§ defn #_"long" Numbers'inc [#_"long" ___x]
        (when (ß ___x == Long/MAX_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß ___x + 1)
    )

    (§ defn #_"Number" Numbers'incP [#_"long" ___x]
        (when (ß ___x == Long/MAX_VALUE)
            (§ return (ß BIGINT_OPS.inc(___x)))
        )
        (ß num(___x + 1))
    )

    (§ defn #_"long" Numbers'dec [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (ß ___x - 1)
    )

    (§ defn #_"Number" Numbers'decP [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß BIGINT_OPS.dec(___x)))
        )
        (ß num(___x - 1))
    )

    (§ defn #_"long" Numbers'multiply [#_"long" ___x, #_"long" ___y]
        (when (ß ___x == Long/MIN_VALUE && ___y < 0)
            (§ return (ß throwIntOverflow()))
        )
        (let [#_"long" ___ret (ß ___x * ___y)]
            (when (ß ___y != 0 && ___ret / ___y != ___x)
                (§ return (ß throwIntOverflow()))
            )
            ret
        )
    )

    (§ defn #_"Number" Numbers'multiplyP [#_"long" ___x, #_"long" ___y]
        (when (ß ___x == Long/MIN_VALUE && ___y < 0)
            (§ return (ß multiplyP((Number)___x, (Number)___y)))
        )
        (let [#_"long" ___ret (ß ___x * ___y)]
            (when (ß ___y != 0 && ___ret / ___y != ___x)
                (§ return (ß multiplyP((Number)___x, (Number)___y)))
            )
            (ß num(___ret))
        )
    )

    (§ defn #_"long" Numbers'quotient [#_"long" ___x, #_"long" ___y]
        (ß ___x / ___y)
    )

    (§ defn #_"long" Numbers'remainder [#_"long" ___x, #_"long" ___y]
        (ß ___x % ___y)
    )

    (§ defn #_"boolean" Numbers'equiv [#_"long" ___x, #_"long" ___y]
        (ß (___x == ___y))
    )

    (§ defn #_"boolean" Numbers'lt [#_"long" ___x, #_"long" ___y]
        (ß (___x < ___y))
    )

    (§ defn #_"boolean" Numbers'lte [#_"long" ___x, #_"long" ___y]
        (ß (___x <= ___y))
    )

    (§ defn #_"boolean" Numbers'gt [#_"long" ___x, #_"long" ___y]
        (ß (___x > ___y))
    )

    (§ defn #_"boolean" Numbers'gte [#_"long" ___x, #_"long" ___y]
        (ß (___x >= ___y))
    )

    (§ defn #_"boolean" Numbers'isPos [#_"long" ___x]
        (ß (___x > 0))
    )

    (§ defn #_"boolean" Numbers'isNeg [#_"long" ___x]
        (ß (___x < 0))
    )

    (§ defn #_"boolean" Numbers'isZero [#_"long" ___x]
        (ß (___x == 0))
    )

    ;; overload resolution

    (§ defn #_"Number" Numbers'add [#_"long" ___x, #_"Object" ___y]
        (ß add((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'add [#_"Object" ___x, #_"long" ___y]
        (ß add(___x, (Object)___y))
    )

    (§ defn #_"Number" Numbers'addP [#_"long" ___x, #_"Object" ___y]
        (ß addP((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'addP [#_"Object" ___x, #_"long" ___y]
        (ß addP(___x, (Object)___y))
    )

    (§ defn #_"double" Numbers'add [#_"double" ___x, #_"Object" ___y]
        (ß add(___x, ((Number)___y).doubleValue()))
    )

    (§ defn #_"double" Numbers'add [#_"Object" ___x, #_"double" ___y]
        (ß add(((Number)___x).doubleValue(), ___y))
    )

    (§ defn #_"double" Numbers'add [#_"double" ___x, #_"long" ___y]
        (ß ___x + ___y)
    )

    (§ defn #_"double" Numbers'add [#_"long" ___x, #_"double" ___y]
        (ß ___x + ___y)
    )

    (§ defn #_"double" Numbers'addP [#_"double" ___x, #_"Object" ___y]
        (ß addP(___x, ((Number)___y).doubleValue()))
    )

    (§ defn #_"double" Numbers'addP [#_"Object" ___x, #_"double" ___y]
        (ß addP(((Number)___x).doubleValue(), ___y))
    )

    (§ defn #_"double" Numbers'addP [#_"double" ___x, #_"long" ___y]
        (ß ___x + ___y)
    )

    (§ defn #_"double" Numbers'addP [#_"long" ___x, #_"double" ___y]
        (ß ___x + ___y)
    )

    (§ defn #_"Number" Numbers'minus [#_"long" ___x, #_"Object" ___y]
        (ß minus((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'minus [#_"Object" ___x, #_"long" ___y]
        (ß minus(___x, (Object)___y))
    )

    (§ defn #_"Number" Numbers'minusP [#_"long" ___x, #_"Object" ___y]
        (ß minusP((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'minusP [#_"Object" ___x, #_"long" ___y]
        (ß minusP(___x, (Object)___y))
    )

    (§ defn #_"double" Numbers'minus [#_"double" ___x, #_"Object" ___y]
        (ß minus(___x, ((Number)___y).doubleValue()))
    )

    (§ defn #_"double" Numbers'minus [#_"Object" ___x, #_"double" ___y]
        (ß minus(((Number)___x).doubleValue(), ___y))
    )

    (§ defn #_"double" Numbers'minus [#_"double" ___x, #_"long" ___y]
        (ß ___x - ___y)
    )

    (§ defn #_"double" Numbers'minus [#_"long" ___x, #_"double" ___y]
        (ß ___x - ___y)
    )

    (§ defn #_"double" Numbers'minusP [#_"double" ___x, #_"Object" ___y]
        (ß minus(___x, ((Number)___y).doubleValue()))
    )

    (§ defn #_"double" Numbers'minusP [#_"Object" ___x, #_"double" ___y]
        (ß minus(((Number)___x).doubleValue(), ___y))
    )

    (§ defn #_"double" Numbers'minusP [#_"double" ___x, #_"long" ___y]
        (ß ___x - ___y)
    )

    (§ defn #_"double" Numbers'minusP [#_"long" ___x, #_"double" ___y]
        (ß ___x - ___y)
    )

    (§ defn #_"Number" Numbers'multiply [#_"long" ___x, #_"Object" ___y]
        (ß multiply((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'multiply [#_"Object" ___x, #_"long" ___y]
        (ß multiply(___x, (Object)___y))
    )

    (§ defn #_"Number" Numbers'multiplyP [#_"long" ___x, #_"Object" ___y]
        (ß multiplyP((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'multiplyP [#_"Object" ___x, #_"long" ___y]
        (ß multiplyP(___x, (Object)___y))
    )

    (§ defn #_"double" Numbers'multiply [#_"double" ___x, #_"Object" ___y]
        (ß multiply(___x, ((Number)___y).doubleValue()))
    )

    (§ defn #_"double" Numbers'multiply [#_"Object" ___x, #_"double" ___y]
        (ß multiply(((Number)___x).doubleValue(), ___y))
    )

    (§ defn #_"double" Numbers'multiply [#_"double" ___x, #_"long" ___y]
        (ß ___x * ___y)
    )

    (§ defn #_"double" Numbers'multiply [#_"long" ___x, #_"double" ___y]
        (ß ___x * ___y)
    )

    (§ defn #_"double" Numbers'multiplyP [#_"double" ___x, #_"Object" ___y]
        (ß multiplyP(___x, ((Number)___y).doubleValue()))
    )

    (§ defn #_"double" Numbers'multiplyP [#_"Object" ___x, #_"double" ___y]
        (ß multiplyP(((Number)___x).doubleValue(), ___y))
    )

    (§ defn #_"double" Numbers'multiplyP [#_"double" ___x, #_"long" ___y]
        (ß ___x * ___y)
    )

    (§ defn #_"double" Numbers'multiplyP [#_"long" ___x, #_"double" ___y]
        (ß ___x * ___y)
    )

    (§ defn #_"Number" Numbers'divide [#_"long" ___x, #_"Object" ___y]
        (ß divide((Object)___x, ___y))
    )

    (§ defn #_"Number" Numbers'divide [#_"Object" ___x, #_"long" ___y]
        (ß divide(___x, (Object)___y))
    )

    (§ defn #_"double" Numbers'divide [#_"double" ___x, #_"Object" ___y]
        (ß ___x / ((Number)___y).doubleValue())
    )

    (§ defn #_"double" Numbers'divide [#_"Object" ___x, #_"double" ___y]
        (ß ((Number)___x).doubleValue() / ___y)
    )

    (§ defn #_"double" Numbers'divide [#_"double" ___x, #_"long" ___y]
        (ß ___x / ___y)
    )

    (§ defn #_"double" Numbers'divide [#_"long" ___x, #_"double" ___y]
        (ß ___x / ___y)
    )

    (§ defn #_"Number" Numbers'divide [#_"long" ___x, #_"long" ___y]
        (ß divide((Number)___x, (Number)___y))
    )

    (§ defn #_"boolean" Numbers'lt [#_"long" ___x, #_"Object" ___y]
        (ß lt((Object)___x, ___y))
    )

    (§ defn #_"boolean" Numbers'lt [#_"Object" ___x, #_"long" ___y]
        (ß lt(___x, (Object)___y))
    )

    (§ defn #_"boolean" Numbers'lt [#_"double" ___x, #_"Object" ___y]
        (ß (___x < ((Number)___y).doubleValue()))
    )

    (§ defn #_"boolean" Numbers'lt [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() < ___y))
    )

    (§ defn #_"boolean" Numbers'lt [#_"double" ___x, #_"long" ___y]
        (ß (___x < ___y))
    )

    (§ defn #_"boolean" Numbers'lt [#_"long" ___x, #_"double" ___y]
        (ß (___x < ___y))
    )

    (§ defn #_"boolean" Numbers'lte [#_"long" ___x, #_"Object" ___y]
        (ß lte((Object)___x, ___y))
    )

    (§ defn #_"boolean" Numbers'lte [#_"Object" ___x, #_"long" ___y]
        (ß lte(___x, (Object)___y))
    )

    (§ defn #_"boolean" Numbers'lte [#_"double" ___x, #_"Object" ___y]
        (ß (___x <= ((Number)___y).doubleValue()))
    )

    (§ defn #_"boolean" Numbers'lte [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() <= ___y))
    )

    (§ defn #_"boolean" Numbers'lte [#_"double" ___x, #_"long" ___y]
        (ß (___x <= ___y))
    )

    (§ defn #_"boolean" Numbers'lte [#_"long" ___x, #_"double" ___y]
        (ß (___x <= ___y))
    )

    (§ defn #_"boolean" Numbers'gt [#_"long" ___x, #_"Object" ___y]
        (ß gt((Object)___x, ___y))
    )

    (§ defn #_"boolean" Numbers'gt [#_"Object" ___x, #_"long" ___y]
        (ß gt(___x, (Object)___y))
    )

    (§ defn #_"boolean" Numbers'gt [#_"double" ___x, #_"Object" ___y]
        (ß (___x > ((Number)___y).doubleValue()))
    )

    (§ defn #_"boolean" Numbers'gt [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() > ___y))
    )

    (§ defn #_"boolean" Numbers'gt [#_"double" ___x, #_"long" ___y]
        (ß (___x > ___y))
    )

    (§ defn #_"boolean" Numbers'gt [#_"long" ___x, #_"double" ___y]
        (ß (___x > ___y))
    )

    (§ defn #_"boolean" Numbers'gte [#_"long" ___x, #_"Object" ___y]
        (ß gte((Object)___x, ___y))
    )

    (§ defn #_"boolean" Numbers'gte [#_"Object" ___x, #_"long" ___y]
        (ß gte(___x, (Object)___y))
    )

    (§ defn #_"boolean" Numbers'gte [#_"double" ___x, #_"Object" ___y]
        (ß (___x >= ((Number)___y).doubleValue()))
    )

    (§ defn #_"boolean" Numbers'gte [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() >= ___y))
    )

    (§ defn #_"boolean" Numbers'gte [#_"double" ___x, #_"long" ___y]
        (ß (___x >= ___y))
    )

    (§ defn #_"boolean" Numbers'gte [#_"long" ___x, #_"double" ___y]
        (ß (___x >= ___y))
    )

    (§ defn #_"boolean" Numbers'equiv [#_"long" ___x, #_"Object" ___y]
        (ß equiv((Object)___x, ___y))
    )

    (§ defn #_"boolean" Numbers'equiv [#_"Object" ___x, #_"long" ___y]
        (ß equiv(___x, (Object)___y))
    )

    (§ defn #_"boolean" Numbers'equiv [#_"double" ___x, #_"Object" ___y]
        (ß (___x == ((Number)___y).doubleValue()))
    )

    (§ defn #_"boolean" Numbers'equiv [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() == ___y))
    )

    (§ defn #_"boolean" Numbers'equiv [#_"double" ___x, #_"long" ___y]
        (ß (___x == ___y))
    )

    (§ defn #_"boolean" Numbers'equiv [#_"long" ___x, #_"double" ___y]
        (ß (___x == ___y))
    )

    (§ defn #_"boolean" Numbers'isNaN [#_"Object" ___x]
        (ß (___x instanceof Double) && ((Double)___x).isNaN() || (___x instanceof Float) && ((Float)___x).isNaN())
    )

    (§ defn #_"double" Numbers'max [#_"double" ___x, #_"double" ___y]
        (ß Math/max(___x, ___y))
    )

    (§ defn #_"Object" Numbers'max [#_"double" ___x, #_"long" ___y]
        (when (ß Double/isNaN(___x))
            (§ return ___x)
        )
        (if (ß ___x > ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'max [#_"double" ___x, #_"Object" ___y]
        (cond (ß Double/isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß ___x > ((Number)___y).doubleValue())
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'max [#_"long" ___x, #_"double" ___y]
        (when (ß Double/isNaN(___y))
            (§ return ___y)
        )
        (if (ß ___x > ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"long" Numbers'max [#_"long" ___x, #_"long" ___y]
        (if (ß ___x > ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'max [#_"long" ___x, #_"Object" ___y]
        (when (ß isNaN(___y))
            (§ return ___y)
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'max [#_"Object" ___x, #_"long" ___y]
        (when (ß isNaN(___x))
            (§ return ___x)
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'max [#_"Object" ___x, #_"double" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß Double/isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß ((Number)___x).doubleValue() > ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'max [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"double" Numbers'min [#_"double" ___x, #_"double" ___y]
        (ß Math/min(___x, ___y))
    )

    (§ defn #_"Object" Numbers'min [#_"double" ___x, #_"long" ___y]
        (when (ß Double/isNaN(___x))
            (§ return ___x)
        )
        (if (ß ___x < ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'min [#_"double" ___x, #_"Object" ___y]
        (cond (ß Double/isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß ___x < ((Number)___y).doubleValue())
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'min [#_"long" ___x, #_"double" ___y]
        (when (ß Double/isNaN(___y))
            (§ return ___y)
        )
        (if (ß ___x < ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"long" Numbers'min [#_"long" ___x, #_"long" ___y]
        (if (ß ___x < ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'min [#_"long" ___x, #_"Object" ___y]
        (when (ß isNaN(___y))
            (§ return ___y)
        )
        (if (ß lt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'min [#_"Object" ___x, #_"long" ___y]
        (when (ß isNaN(___x))
            (§ return ___x)
        )
        (if (ß lt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'min [#_"Object" ___x, #_"double" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß Double/isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß ((Number)___x).doubleValue() < ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (§ defn #_"Object" Numbers'min [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß lt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (§ init
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"Obj" Obj [#_"IPersistentMap" ___meta]
        (let [this (ß super())]
            (§ ass (ß this._meta) ___meta)
            this
        )
    )

    (§ constructor #_"Obj" Obj []
        (let [this (ß super())]
            (§ ass _meta nil)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"Obj" this]
        _meta
    )

    #_abstract
    (§ defn #_"Obj" withMeta [#_"Obj" this, #_"IPersistentMap" ___meta])
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

(class-ns MSeq (§ extends ASeq) (§ implements Counted)
    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"MSeq" MSeq [#_"Object[]" ___array, #_"int" ___i]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    (§ constructor #_"MSeq" MSeq [#_"IPersistentMap" ___meta, #_"Object[]" ___array, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"MSeq" this]
        (ß MapEntry'create(array[i], array[i + 1]))
    )

    #_method
    (§ defn #_"ISeq" next [#_"MSeq" this]
        (when (ß i + 2 < array.length)
            (§ return (ß new MSeq(array, i + 2)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"MSeq" this]
        (ß (array.length - i) / 2)
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"MSeq" this, #_"IPersistentMap" ___meta]
        (ß new MSeq(___meta, array, i))
    )
)

(class-ns MIter (§ implements Iterator)
    (§ init
        (§ field #_"IFn" f nil)
        (§ field #_"Object[]" array nil)
        (§ field #_"int" i 0)
    )

    ;; for iterator
    (§ constructor #_"MIter" MIter [#_"Object[]" ___array, #_"IFn" ___f]
        (let [this (ß this(___array, -2, ___f))]
            this
        )
    )

    ;; for entryAt
    (§ constructor #_"MIter" MIter [#_"Object[]" ___array, #_"int" ___i, #_"IFn" ___f]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.f) ___f)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"MIter" this]
        (ß (i < array.length - 2))
    )

    #_method
    (§ defn #_"Object" next [#_"MIter" this]
        (try
            (§ ass i (ß i + 2))
            (ß f.invoke(array[i], array[i + 1]))
            (catch IndexOutOfBoundsException ___e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"MIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransientArrayMap (§ extends ATransientMap)
    (§ init
        #_volatile
        (§ field #_"int" len 0)
        (§ field #_"Object[]" array nil)
        #_volatile
        (§ field #_"Thread" owner nil)
    )

    (§ constructor #_"TransientArrayMap" TransientArrayMap [#_"Object[]" ___array]
        (let [this (ß super())]
            (§ ass (ß this.owner) (ß Thread/currentThread()))
            (§ ass (ß this.array) (ß new Object[Math/max(HASHTABLE_THRESHOLD, ___array.length)]))
            (ß System/arraycopy(___array, 0, this.array, 0, ___array.length))
            (§ ass (ß this.len) (ß ___array.length))
            this
        )
    )

    #_method
    (§ defn- #_"int" indexOf [#_"TransientArrayMap" this, #_"Object" ___key]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < len) [(§ ass ___i (ß ___i + 2))]
            (when (ß equalKey(array[___i], ___key))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ITransientMap" doAssoc [#_"TransientArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (ß indexOf(___key))]
            (cond (ß ___i >= 0) ;; already have key,
                (do
                    (when (ß array[___i + 1] != ___val) ;; no change, no op
                        (§ ass (ß array[___i + 1]) ___val)
                    )
                )
                :else ;; didn't have key, grow
                (do
                    (when (ß len >= array.length)
                        (§ return (ß PersistentHashMap'create(array).asTransient().assoc(___key, ___val)))
                    )
                    (§ ass (ß array[len]) ___key)
                    (§ ass len (ß len + 1))
                    (§ ass (ß array[len]) ___val)
                    (§ ass len (ß len + 1))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" doWithout [#_"TransientArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0) ;; have key, will remove
                (when (ß len >= 2)
                    (§ ass (ß array[___i]) (ß array[len - 2]))
                    (§ ass (ß array[___i + 1]) (ß array[len - 1]))
                )
                (§ ass len (ß len - 2))
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" doValAt [#_"TransientArrayMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0)
                (§ return (ß array[___i + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"int" doCount [#_"TransientArrayMap" this]
        (ß len / 2)
    )

    #_method
    (§ defn #_"IPersistentMap" doPersistent [#_"TransientArrayMap" this]
        (ß ensureEditable())
        (§ ass owner nil)
        (let [#_"Object[]" ___a (ß new Object[len])]
            (ß System/arraycopy(array, 0, ___a, 0, len))
            (PersistentArrayMap. ___a)
        )
    )

    #_method
    (§ defn #_"void" ensureEditable [#_"TransientArrayMap" this]
        (when (nil? owner)
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ def #_"PersistentArrayMap" PersistentArrayMap'EMPTY (PersistentArrayMap.))
    (§ def #_"int" PersistentArrayMap'HASHTABLE_THRESHOLD 16)

    (§ defn #_"IPersistentMap" PersistentArrayMap'create [#_"Map" ___other]
        (let [#_"ITransientMap" ___ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" ___o (ß ___other.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            (ß ___ret.persistent())
        )
    )

    (§ init
        (§ field #_"Object[]" array nil)
        (§ field- #_"IPersistentMap" _meta nil)
    )

    #_protected
    (§ constructor #_"PersistentArrayMap" PersistentArrayMap []
        (let [this (ß super())]
            (§ ass (ß this.array) (ß new Object[] (§ array )))
            (§ ass (ß this._meta) nil)
            this
        )
    )

    #_method
    (§ defn #_"PersistentArrayMap" withMeta [#_"PersistentArrayMap" this, #_"IPersistentMap" ___meta]
        (ß new PersistentArrayMap(___meta, array))
    )

    #_method
    (§ defn #_"PersistentArrayMap" create [#_"PersistentArrayMap" this, #_"Object..." ___init]
        (ß new PersistentArrayMap(meta(), ___init))
    )

    #_method
    (§ defn #_"IPersistentMap" createHT [#_"PersistentArrayMap" this, #_"Object[]" ___init]
        (ß PersistentHashMap'create(meta(), ___init))
    )

    (§ defn #_"PersistentArrayMap" PersistentArrayMap'createWithCheck [#_"Object[]" ___init]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___init.length) [(§ ass ___i (ß ___i + 2))]
            (loop-when-recur [(§ var #_"int" ___j (ß ___i + 2))] (ß ___j < ___init.length) [(§ ass ___j (ß ___j + 2))]
                (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                    (throw (IllegalArgumentException. (ß "Duplicate key: " + ___init[___i])))
                )
            )
        )
        (PersistentArrayMap. ___init)
    )

    (§ defn #_"PersistentArrayMap" PersistentArrayMap'createAsIfByAssoc [#_"Object[]" ___init]
        (when (ß (___init.length & 1) == 1)
            (throw (ß new IllegalArgumentException(String/format("No value supplied for key: %s", ___init[___init.length - 1]))))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (let [#_"int" ___n 0]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___init.length) [(§ ass ___i (ß ___i + 2))]
                (let [#_"boolean" ___duplicateKey false]
                    (loop-when-recur [(§ var #_"int" ___j 0)] (ß ___j < ___i) [(§ ass ___j (ß ___j + 2))]
                        (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                            (§ ass ___duplicateKey true)
                            (§ break )
                        )
                    )
                    (when (ß !___duplicateKey)
                        (§ ass ___n (ß ___n + 2))
                    )
                )
            )
            (when (ß ___n < ___init.length)
                ;; Create a new shorter array with unique keys, and
                ;; the last value associated with each key. To behave
                ;; like assoc, the first occurrence of each key must
                ;; be used, since its metadata may be different than
                ;; later equal keys.
                (let [#_"Object[]" ___nodups (ß new Object[___n])]
                    (let [#_"int" ___m 0]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___init.length) [(§ ass ___i (ß ___i + 2))]
                            (let [#_"boolean" ___duplicateKey false]
                                (loop-when-recur [(§ var #_"int" ___j 0)] (ß ___j < ___m) [(§ ass ___j (ß ___j + 2))]
                                    (when (ß PersistentArrayMap'equalKey(___init[___i], ___nodups[___j]))
                                        (§ ass ___duplicateKey true)
                                        (§ break )
                                    )
                                )
                                (when (ß !___duplicateKey)
                                    (§ let [#_"int" ___j]
                                        (loop-when-recur [(§ ass ___j (ß ___init.length - 2))] (ß ___j >= ___i) [(§ ass ___j (ß ___j - 2))]
                                            (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                                                (§ break )
                                            )
                                        )
                                        (§ ass (ß ___nodups[___m]) (ß ___init[___i]))
                                        (§ ass (ß ___nodups[___m + 1]) (ß ___init[___j + 1]))
                                        (§ ass ___m (ß ___m + 2))
                                    )
                                )
                            )
                        )
                        (when (ß ___m != ___n)
                            (throw (IllegalArgumentException. (ß "Internal error: m=" + ___m)))
                        )
                        (§ ass ___init ___nodups)
                    )
                )
            )
            (PersistentArrayMap. ___init)
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ constructor #_"PersistentArrayMap" PersistentArrayMap [#_"Object[]" ___init]
        (let [this (ß super())]
            (§ ass (ß this.array) ___init)
            (§ ass (ß this._meta) nil)
            this
        )
    )

    (§ constructor #_"PersistentArrayMap" PersistentArrayMap [#_"IPersistentMap" ___meta, #_"Object[]" ___init]
        (let [this (ß super())]
            (§ ass (ß this._meta) ___meta)
            (§ ass (ß this.array) ___init)
            this
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentArrayMap" this]
        (ß array.length / 2)
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentArrayMap" this, #_"Object" ___key]
        (ß (indexOf(___key) >= 0))
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0)
                (§ return (ß (IMapEntry) MapEntry'create(array[___i], array[___i + 1])))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" assocEx [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (ß indexOf(___key))]
            (§ let [#_"Object[]" ___newArray]
                (cond (ß ___i >= 0)
                    (do
                        (throw (ß Util'runtimeException("Key already present")))
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß array.length > HASHTABLE_THRESHOLD)
                            (§ return (ß createHT(array).assocEx(___key, ___val)))
                        )
                        (§ ass ___newArray (ß new Object[array.length + 2]))
                        (when (ß array.length > 0)
                            (ß System/arraycopy(array, 0, ___newArray, 2, array.length))
                        )
                        (§ ass (ß ___newArray[0]) ___key)
                        (§ ass (ß ___newArray[1]) ___val)
                    )
                )
                (ß create(___newArray))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" assoc [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (ß indexOf(___key))]
            (§ let [#_"Object[]" ___newArray]
                (cond (ß ___i >= 0) ;; already have key, same-sized replacement
                    (do
                        (when (ß array[___i + 1] == ___val) ;; no change, no op
                            (§ return this)
                        )
                        (§ ass ___newArray (ß array.clone()))
                        (§ ass (ß ___newArray[___i + 1]) ___val)
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß array.length > HASHTABLE_THRESHOLD)
                            (§ return (ß createHT(array).assoc(___key, ___val)))
                        )
                        (§ ass ___newArray (ß new Object[array.length + 2]))
                        (when (ß array.length > 0)
                            (ß System/arraycopy(array, 0, ___newArray, 0, array.length))
                        )
                        (§ ass (ß ___newArray[___newArray.length - 2]) ___key)
                        (§ ass (ß ___newArray[___newArray.length - 1]) ___val)
                    )
                )
                (ß create(___newArray))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" without [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0) ;; have key, will remove
                (let [#_"int" ___newlen (ß array.length - 2)]
                    (when (ß ___newlen == 0)
                        (§ return (ß empty()))
                    )
                    (let [#_"Object[]" ___newArray (ß new Object[___newlen])]
                        (ß System/arraycopy(array, 0, ___newArray, 0, ___i))
                        (ß System/arraycopy(array, ___i + 2, ___newArray, ___i, ___newlen - ___i))
                        (§ return (ß create(___newArray)))
                    )
                )
            )
            ;; don't have key, no op
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" empty [#_"PersistentArrayMap" this]
        (ß (IPersistentMap) EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0)
                (§ return (ß array[___i + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentArrayMap" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"int" capacity [#_"PersistentArrayMap" this]
        (ß count())
    )

    #_method
    (§ defn- #_"int" indexOfObject [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"EquivPred" ___ep (ß Util'equivPred(___key))]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < array.length) [(§ ass ___i (ß ___i + 2))]
                (when (ß ___ep.equiv(___key, array[___i]))
                    (§ return ___i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn- #_"int" indexOf [#_"PersistentArrayMap" this, #_"Object" ___key]
        (if (ß ___key instanceof Keyword)
            (do
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < array.length) [(§ ass ___i (ß ___i + 2))]
                    (when (ß ___key == array[___i])
                        (§ return ___i)
                    )
                )
                -1
            )
            (do
                (ß indexOfObject(___key))
            )
        )
    )

    (§ defn #_"boolean" PersistentArrayMap'equalKey [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 instanceof Keyword)
            (§ return (ß (___k1 == ___k2)))
        )
        (ß Util'equiv(___k1, ___k2))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentArrayMap" this]
        (ß new MIter(array, APersistentMap'MAKE_ENTRY))
    )

    #_method
    (§ defn #_"Iterator" keyIterator [#_"PersistentArrayMap" this]
        (ß new MIter(array, APersistentMap'MAKE_KEY))
    )

    #_method
    (§ defn #_"Iterator" valIterator [#_"PersistentArrayMap" this]
        (ß new MIter(array, APersistentMap'MAKE_VAL))
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentArrayMap" this]
        (when (ß array.length > 0)
            (§ return (ß new MSeq(array, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentArrayMap" this]
        _meta
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentArrayMap" this, #_"IFn" ___f, #_"Object" ___init]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < array.length) [(§ ass ___i (ß ___i + 2))]
            (§ ass ___init (ß ___f.invoke(___init, array[___i], array[___i + 1])))
            (when (ß RT'isReduced(___init))
                (§ return (ß ((IDeref)___init).deref()))
            )
        )
        init
    )

    #_method
    (§ defn #_"ITransientMap" asTransient [#_"PersistentArrayMap" this]
        (TransientArrayMap. array)
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns TransientHashMap (§ extends ATransientMap)
    (§ init
        (§ field #_"AtomicReference<Thread>" edit nil)
        #_volatile
        (§ field #_"INode" root nil)
        #_volatile
        (§ field #_"int" count 0)
        #_volatile
        (§ field #_"boolean" hasNull false)
        #_volatile
        (§ field #_"Object" nullValue nil)
        (§ field #_"Box" leafFlag (Box. nil))
    )

    (§ constructor #_"TransientHashMap" TransientHashMap [#_"PersistentHashMap" ___m]
        (let [this (ß this(new AtomicReference<Thread>(Thread/currentThread()), ___m.root, ___m.count, ___m.hasNull, ___m.nullValue))]
            this
        )
    )

    (§ constructor #_"TransientHashMap" TransientHashMap [#_"AtomicReference<Thread>" ___edit, #_"INode" ___root, #_"int" ___count, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (ß super())]
            (§ ass (ß this.edit) ___edit)
            (§ ass (ß this.root) ___root)
            (§ ass (ß this.count) ___count)
            (§ ass (ß this.hasNull) ___hasNull)
            (§ ass (ß this.nullValue) ___nullValue)
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" doAssoc [#_"TransientHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___key)
            (when (ß this.nullValue != ___val)
                (§ ass (ß this.nullValue) ___val)
            )
            (when (ß !hasNull)
                (§ ass (ß this.count) (ß this.count + 1))
                (§ ass (ß this.hasNull) true)
            )
            (§ return this)
        )
        (§ ass (ß leafFlag.val) nil)
        (let [#_"INode" ___n (ß ((root == nil) ? BitmapIndexedNode'EMPTY :or root).assoc(edit, 0, hash(___key), ___key, ___val, leafFlag))]
            (when (ß ___n != this.root)
                (§ ass (ß this.root) ___n)
            )
            (when (ß leafFlag.val != nil)
                (§ ass (ß this.count) (ß this.count + 1))
            )
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" doWithout [#_"TransientHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (when (ß !hasNull)
                (§ return this)
            )
            (§ ass hasNull false)
            (§ ass nullValue nil)
            (§ ass (ß this.count) (ß this.count - 1))
            (§ return this)
        )
        (when (nil? root)
            (§ return this)
        )
        (§ ass (ß leafFlag.val) nil)
        (let [#_"INode" ___n (ß root.without(edit, 0, hash(___key), ___key, leafFlag))]
            (when (ß ___n != root)
                (§ ass (ß this.root) ___n)
            )
            (when (ß leafFlag.val != nil)
                (§ ass (ß this.count) (ß this.count - 1))
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" doPersistent [#_"TransientHashMap" this]
        (ß edit.set(nil))
        (ß new PersistentHashMap(count, root, hasNull, nullValue))
    )

    #_method
    (§ defn #_"Object" doValAt [#_"TransientHashMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (nil? ___key)
            (if hasNull
                (do
                    (§ return nullValue)
                )
                (do
                    (§ return ___notFound)
                )
            )
        )
        (when (nil? root)
            (§ return ___notFound)
        )
        (ß root.find(0, hash(___key), ___key, ___notFound))
    )

    #_method
    (§ defn #_"int" doCount [#_"TransientHashMap" this]
        count
    )

    #_method
    (§ defn #_"void" ensureEditable [#_"TransientHashMap" this]
        (when (ß edit.get() == nil)
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

(defprotocol INode
    #_abstract
    (#_"INode" INode'''assoc6 [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf])
    #_abstract
    (#_"INode" INode'''without4 [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" INode'''find4 [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key])
    #_abstract
    (#_"Object" INode'''find5 [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound])
    #_abstract
    (#_"ISeq" INode'''nodeSeq [#_"INode" this])
    #_abstract
    (#_"INode" INode'''assoc7 [#_"INode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf])
    #_abstract
    (#_"INode" INode'''without6 [#_"INode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf])
    #_abstract
    (#_"Object" INode'''kvreduce [#_"INode" this, #_"IFn" ___f, #_"Object" ___init])
    #_abstract
    (#_"Object" INode'''fold [#_"INode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin])
    ;; returns the result of (f [k v]) for each iterated element
    #_abstract
    (#_"Iterator" INode'''iterator [#_"INode" this, #_"IFn" ___f])
)

(class-ns HSeq (§ extends ASeq)
    (§ defn #_"ISeq" HSeq'create [#_"INode[]" ___nodes]
        (ß HSeq'create(nil, ___nodes, 0, nil))
    )

    (§ defn- #_"ISeq" HSeq'create [#_"IPersistentMap" ___meta, #_"INode[]" ___nodes, #_"int" ___i, #_"ISeq" ___s]
        (when (some? ___s)
            (§ return (ß new HSeq(___meta, ___nodes, ___i, ___s)))
        )
        (loop-when-recur [(§ var #_"int" ___j ___i)] (ß ___j < ___nodes.length) [(§ ass ___j (ß ___j + 1))]
            (when (ß ___nodes[___j] != nil)
                (let [#_"ISeq" ___ns (ß ___nodes[___j].nodeSeq())]
                    (when (some? ___ns)
                        (§ return (ß new HSeq(___meta, ___nodes, ___j + 1, ___ns)))
                    )
                )
            )
        )
        nil
    )

    (§ init
        (§ field #_"INode[]" nodes nil)
        (§ field #_"int" i 0)
        (§ field #_"ISeq" s nil)
    )

    (§ constructor- #_"HSeq" HSeq [#_"IPersistentMap" ___meta, #_"INode[]" ___nodes, #_"int" ___i, #_"ISeq" ___s]
        (let [this (ß super(___meta))]
            (§ ass (ß this.nodes) ___nodes)
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.s) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"HSeq" this, #_"IPersistentMap" ___meta]
        (ß new HSeq(___meta, nodes, i, s))
    )

    #_method
    (§ defn #_"Object" first [#_"HSeq" this]
        (ß s.first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"HSeq" this]
        (ß HSeq'create(nil, nodes, i, s.next()))
    )
)

(class-ns HIter (§ implements Iterator)
    (§ init
        (§ field- #_"INode[]" array nil)
        (§ field- #_"IFn" f nil)
        (§ field- #_"int" i 0)
        (§ field- #_"Iterator" nestedIter nil)
    )

    (§ constructor- #_"HIter" HIter [#_"INode[]" ___array, #_"IFn" ___f]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.f) ___f)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"HIter" this]
        (while true
            (when (some? nestedIter)
                (if (ß nestedIter.hasNext())
                    (do
                        (§ return true)
                    )
                    (do
                        (§ ass nestedIter nil)
                    )
                )
            )

            (if (ß i < array.length)
                (do
                    (let [#_"INode" ___node (ß array[i])]
                        (§ ass i (ß i + 1))
                        (when (some? ___node)
                            (§ ass nestedIter (ß ___node.iterator(f)))
                        )
                    )
                )
                (do
                    (§ return false)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" next [#_"HIter" this]
        (if (ß hasNext())
            (do
                (ß nestedIter.next())
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"HIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ArrayNode (§ implements INode)
    (§ init
        (§ field #_"int" count 0)
        (§ field #_"INode[]" array nil)
        (§ field #_"AtomicReference<Thread>" edit nil)
    )

    (§ constructor #_"ArrayNode" ArrayNode [#_"AtomicReference<Thread>" ___edit, #_"int" ___count, #_"INode[]" ___array]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.edit) ___edit)
            (§ ass (ß this.count) ___count)
            this
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß array[___idx])]
                (when (nil? ___node)
                    (§ return (ß new ArrayNode(nil, count + 1, cloneAndSet(array, ___idx, BitmapIndexedNode'EMPTY.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))))
                )
                (let [#_"INode" ___n (ß ___node.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (ß new ArrayNode(nil, count, cloneAndSet(array, ___idx, ___n)))
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" without [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß array[___idx])]
                (when (nil? ___node)
                    (§ return this)
                )
                (let [#_"INode" ___n (ß ___node.without(___shift + 5, ___hash, ___key))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (if (nil? ___n)
                        (do
                            (when (ß count <= 8) ;; shrink
                                (§ return (ß pack(nil, ___idx)))
                            )
                            (ß new ArrayNode(nil, count - 1, cloneAndSet(array, ___idx, ___n)))
                        )
                        (do
                            (ß new ArrayNode(nil, count, cloneAndSet(array, ___idx, ___n)))
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" find [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß array[___idx])]
                (when (nil? ___node)
                    (§ return nil)
                )
                (ß ___node.find(___shift + 5, ___hash, ___key))
            )
        )
    )

    #_method
    (§ defn #_"Object" find [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß array[___idx])]
                (when (nil? ___node)
                    (§ return ___notFound)
                )
                (ß ___node.find(___shift + 5, ___hash, ___key, ___notFound))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" nodeSeq [#_"ArrayNode" this]
        (ß HSeq'create(array))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"ArrayNode" this, #_"IFn" ___f]
        (ß new HIter(array, ___f))
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"ArrayNode" this, #_"IFn" ___f, #_"Object" ___init]
        (doseq [#_"INode" ___node array]
            (when (some? ___node)
                (§ ass ___init (ß ___node.kvreduce(___f, ___init)))
                (when (ß RT'isReduced(___init))
                    (§ return ___init)
                )
            )
        )
        init
    )

    #_method
    (§ defn #_"Object" fold [#_"ArrayNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (let [#_"List<Callable>" ___tasks (ArrayList.)]
            (doseq [#_"INode" ___node array]
                (when (some? ___node)
                    (ß ___tasks.add(
                            (§ reify Callable()
                                #_method
                                (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                                    (ß ___node.fold(___combinef, ___reducef, ___fjtask, ___fjfork, ___fjjoin))
                                )
                            )
                        )
                    )
                )
            )

            (ß ArrayNode'foldTasks(___tasks, ___combinef, ___fjtask, ___fjfork, ___fjjoin))
        )
    )

    (§ defn #_"Object" ArrayNode'foldTasks [#_"List<Callable>" ___tasks, #_"IFn" ___combinef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (when (ß ___tasks.isEmpty())
            (§ return (ß ___combinef.invoke()))
        )

        (when (ß ___tasks.size() == 1)
            (let [#_"Object" ___ret nil]
                (try
                    (§ return (ß ___tasks.get(0).call()))
                    (catch Exception ___e
                        (throw (ß Util'sneakyThrow(___e)))
                    )
                )
            )
        )

        (let [#_"List<Callable>" ___t1 (ß ___tasks.subList(0, ___tasks.size() / 2))]
            (let [#_"List<Callable>" ___t2 (ß ___tasks.subList(___tasks.size() / 2, ___tasks.size()))]
                (let [#_"Object" ___forked
                        (ß ___fjfork.invoke(___fjtask.invoke(
                                (§ reify Callable()
                                    #_method
                                    (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                                        (ß ArrayNode'foldTasks(___t2, ___combinef, ___fjtask, ___fjfork, ___fjjoin))
                                    )
                                )
                            ))
                        )]
                    (ß ___combinef.invoke(ArrayNode'foldTasks(___t1, ___combinef, ___fjtask, ___fjfork, ___fjjoin), ___fjjoin.invoke(___forked)))
                )
            )
        )
    )

    #_method
    (§ defn- #_"ArrayNode" ensureEditable [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß this.edit == ___edit)
            (§ return this)
        )
        (ß new ArrayNode(___edit, count, this.array.clone()))
    )

    #_method
    (§ defn- #_"ArrayNode" editAndSet [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"INode" ___n]
        (let [#_"ArrayNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß ___editable.array[___i]) ___n)
            editable
        )
    )

    #_method
    (§ defn- #_"INode" pack [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___idx]
        (let [#_"Object[]" ___newArray (ß new Object[2 * (count - 1)])]
            (let [#_"int" ___j 1]
                (let [#_"int" ___bitmap 0]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___idx) [(§ ass ___i (ß ___i + 1))]
                        (when (ß array[___i] != nil)
                            (§ ass (ß ___newArray[___j]) (ß array[___i]))
                            (§ ass ___bitmap (ß ___bitmap | (1 << ___i)))
                            (§ ass ___j (ß ___j + 2))
                        )
                    )
                    (loop-when-recur [(§ var #_"int" ___i (ß ___idx + 1))] (ß ___i < array.length) [(§ ass ___i (ß ___i + 1))]
                        (when (ß array[___i] != nil)
                            (§ ass (ß ___newArray[___j]) (ß array[___i]))
                            (§ ass ___bitmap (ß ___bitmap | (1 << ___i)))
                            (§ ass ___j (ß ___j + 2))
                        )
                    )
                    (ß new BitmapIndexedNode(___edit, ___bitmap, ___newArray))
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß array[___idx])]
                (when (nil? ___node)
                    (let [#_"ArrayNode" ___editable (ß editAndSet(___edit, ___idx, BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))]
                        (§ ass (ß ___editable.count) (ß ___editable.count + 1))
                        (§ return ___editable)
                    )
                )
                (let [#_"INode" ___n (ß ___node.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (ß editAndSet(___edit, ___idx, ___n))
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" without [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß array[___idx])]
                (when (nil? ___node)
                    (§ return this)
                )
                (let [#_"INode" ___n (ß ___node.without(___edit, ___shift + 5, ___hash, ___key, ___removedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (when (nil? ___n)
                        (when (ß count <= 8) ;; shrink
                            (§ return (ß pack(___edit, ___idx)))
                        )
                        (let [#_"ArrayNode" ___editable (ß editAndSet(___edit, ___idx, ___n))]
                            (§ ass (ß ___editable.count) (ß ___editable.count - 1))
                            (§ return ___editable)
                        )
                    )
                    (ß editAndSet(___edit, ___idx, ___n))
                )
            )
        )
    )
)

(class-ns BitmapIndexedNode (§ implements INode)
    (§ def #_"BitmapIndexedNode" BitmapIndexedNode'EMPTY (ß new BitmapIndexedNode(nil, 0, new Object[0])))

    (§ init
        (§ field #_"int" bitmap 0)
        (§ field #_"Object[]" array nil)
        (§ field #_"AtomicReference<Thread>" edit nil)
    )

    (§ constructor #_"BitmapIndexedNode" BitmapIndexedNode [#_"AtomicReference<Thread>" ___edit, #_"int" ___bitmap, #_"Object[]" ___array]
        (let [this (ß super())]
            (§ ass (ß this.bitmap) ___bitmap)
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.edit) ___edit)
            this
        )
    )

    #_method
    (§ defn #_"int" index [#_"BitmapIndexedNode" this, #_"int" ___bit]
        (ß Integer/bitCount(bitmap & (___bit - 1)))
    )

    #_method
    (§ defn #_"INode" assoc [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (let [#_"int" ___idx (ß index(___bit))]
                (if (ß (bitmap & ___bit) != 0)
                    (do
                        (let [#_"Object" ___keyOrNull (ß array[2 * ___idx])]
                            (let [#_"Object" ___valOrNode (ß array[2 * ___idx + 1])]
                                (when (nil? ___keyOrNull)
                                    (let [#_"INode" ___n (ß ((INode) ___valOrNode).assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                                        (when (ß ___n == ___valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * ___idx + 1, ___n))))
                                    )
                                )
                                (when (ß Util'equiv(___key, ___keyOrNull))
                                    (when (ß ___val == ___valOrNode)
                                        (§ return this)
                                    )
                                    (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * ___idx + 1, ___val))))
                                )
                                (§ ass (ß ___addedLeaf.val) ___addedLeaf)
                                (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * ___idx, nil, 2 * ___idx + 1, createNode(___shift + 5, ___keyOrNull, ___valOrNode, ___hash, ___key, ___val))))
                            )
                        )
                    )
                    (do
                        (let [#_"int" ___n (ß Integer/bitCount(bitmap))]
                            (if (ß ___n >= 16)
                                (do
                                    (let [#_"INode[]" ___nodes (ß new INode[32])]
                                        (let [#_"int" ___jdx (ß mask(___hash, ___shift))]
                                            (§ ass (ß ___nodes[___jdx]) (ß BitmapIndexedNode'EMPTY.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))
                                            (let [#_"int" ___j 0]
                                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < 32) [(§ ass ___i (ß ___i + 1))]
                                                    (when (ß ((bitmap >>> ___i) & 1) != 0)
                                                        (if (ß array[___j] == nil)
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß (INode) array[___j + 1]))
                                                            )
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß BitmapIndexedNode'EMPTY.assoc(___shift + 5, hash(array[___j]), array[___j], array[___j + 1], ___addedLeaf)))
                                                            )
                                                        )
                                                        (§ ass ___j (ß ___j + 2))
                                                    )
                                                )
                                                (ß new ArrayNode(nil, ___n + 1, ___nodes))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Object[]" ___newArray (ß new Object[2 * (___n + 1)])]
                                        (ß System/arraycopy(array, 0, ___newArray, 0, 2 * ___idx))
                                        (§ ass (ß ___newArray[2 * ___idx]) ___key)
                                        (§ ass (ß ___addedLeaf.val) ___addedLeaf)
                                        (§ ass (ß ___newArray[2 * ___idx + 1]) ___val)
                                        (ß System/arraycopy(array, 2 * ___idx, ___newArray, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                        (ß new BitmapIndexedNode(nil, bitmap | ___bit, ___newArray))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" without [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß (bitmap & ___bit) == 0)
                (§ return this)
            )
            (let [#_"int" ___idx (ß index(___bit))]
                (let [#_"Object" ___keyOrNull (ß array[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß array[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (let [#_"INode" ___n (ß ((INode) ___valOrNode).without(___shift + 5, ___hash, ___key))]
                                (when (ß ___n == ___valOrNode)
                                    (§ return this)
                                )
                                (when (some? ___n)
                                    (§ return (ß new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * ___idx + 1, ___n))))
                                )
                                (when (ß bitmap == ___bit)
                                    (§ return nil)
                                )
                                (§ return (ß new BitmapIndexedNode(nil, bitmap :xor ___bit, removePair(array, ___idx))))
                            )
                        )
                        (when (ß Util'equiv(___key, ___keyOrNull))
                            ;; TODO: collapse
                            (§ return (ß new BitmapIndexedNode(nil, bitmap :xor ___bit, removePair(array, ___idx))))
                        )
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" find [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß (bitmap & ___bit) == 0)
                (§ return nil)
            )
            (let [#_"int" ___idx (ß index(___bit))]
                (let [#_"Object" ___keyOrNull (ß array[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß array[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (§ return (ß ((INode) ___valOrNode).find(___shift + 5, ___hash, ___key)))
                        )
                        (when (ß Util'equiv(___key, ___keyOrNull))
                            (§ return (ß (IMapEntry) MapEntry'create(___keyOrNull, ___valOrNode)))
                        )
                        nil
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" find [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß (bitmap & ___bit) == 0)
                (§ return ___notFound)
            )
            (let [#_"int" ___idx (ß index(___bit))]
                (let [#_"Object" ___keyOrNull (ß array[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß array[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (§ return (ß ((INode) ___valOrNode).find(___shift + 5, ___hash, ___key, ___notFound)))
                        )
                        (when (ß Util'equiv(___key, ___keyOrNull))
                            (§ return ___valOrNode)
                        )
                        ___notFound
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" nodeSeq [#_"BitmapIndexedNode" this]
        (ß NodeSeq'create(array))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"BitmapIndexedNode" this, #_"IFn" ___f]
        (ß new NodeIter(array, ___f))
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"BitmapIndexedNode" this, #_"IFn" ___f, #_"Object" ___init]
        (ß NodeSeq'kvreduce(array, ___f, ___init))
    )

    #_method
    (§ defn #_"Object" fold [#_"BitmapIndexedNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (ß NodeSeq'kvreduce(array, ___reducef, ___combinef.invoke()))
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" ensureEditable [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß this.edit == ___edit)
            (§ return this)
        )
        (let [#_"int" ___n (ß Integer/bitCount(bitmap))]
            (let [#_"Object[]" ___newArray (ß new Object[(___n >= 0) ? 2 * (___n + 1) :or 4])] ;; make room for next assoc
                (ß System/arraycopy(array, 0, ___newArray, 0, 2 * ___n))
                (ß new BitmapIndexedNode(___edit, bitmap, ___newArray))
            )
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" editAndSet [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a]
        (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß ___editable.array[___i]) ___a)
            editable
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" editAndSet [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß ___editable.array[___i]) ___a)
            (§ ass (ß ___editable.array[___j]) ___b)
            editable
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" editAndRemovePair [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___bit, #_"int" ___i]
        (when (ß bitmap == ___bit)
            (§ return nil)
        )
        (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß ___editable.bitmap) (ß ___editable.bitmap :xor ___bit))
            (ß System/arraycopy(___editable.array, 2 * (___i + 1), ___editable.array, 2 * ___i, ___editable.array.length - 2 * (___i + 1)))
            (§ ass (ß ___editable.array[___editable.array.length - 2]) nil)
            (§ ass (ß ___editable.array[___editable.array.length - 1]) nil)
            editable
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (let [#_"int" ___idx (ß index(___bit))]
                (if (ß (bitmap & ___bit) != 0)
                    (do
                        (let [#_"Object" ___keyOrNull (ß array[2 * ___idx])]
                            (let [#_"Object" ___valOrNode (ß array[2 * ___idx + 1])]
                                (when (nil? ___keyOrNull)
                                    (let [#_"INode" ___n (ß ((INode) ___valOrNode).assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                                        (when (ß ___n == ___valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß editAndSet(___edit, 2 * ___idx + 1, ___n)))
                                    )
                                )
                                (when (ß Util'equiv(___key, ___keyOrNull))
                                    (when (ß ___val == ___valOrNode)
                                        (§ return this)
                                    )
                                    (§ return (ß editAndSet(___edit, 2 * ___idx + 1, ___val)))
                                )
                                (§ ass (ß ___addedLeaf.val) ___addedLeaf)
                                (ß editAndSet(___edit, 2 * ___idx, nil, 2 * ___idx + 1, createNode(___edit, ___shift + 5, ___keyOrNull, ___valOrNode, ___hash, ___key, ___val)))
                            )
                        )
                    )
                    (do
                        (let [#_"int" ___n (ß Integer/bitCount(bitmap))]
                            (when (ß ___n * 2 < array.length)
                                (§ ass (ß ___addedLeaf.val) ___addedLeaf)
                                (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
                                    (ß System/arraycopy(___editable.array, 2 * ___idx, ___editable.array, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                    (§ ass (ß ___editable.array[2 * ___idx]) ___key)
                                    (§ ass (ß ___editable.array[2 * ___idx + 1]) ___val)
                                    (§ ass (ß ___editable.bitmap) (ß ___editable.bitmap | ___bit))
                                    (§ return ___editable)
                                )
                            )
                            (if (ß ___n >= 16)
                                (do
                                    (let [#_"INode[]" ___nodes (ß new INode[32])]
                                        (let [#_"int" ___jdx (ß mask(___hash, ___shift))]
                                            (§ ass (ß ___nodes[___jdx]) (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))
                                            (let [#_"int" ___j 0]
                                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < 32) [(§ ass ___i (ß ___i + 1))]
                                                    (when (ß ((bitmap >>> ___i) & 1) != 0)
                                                        (if (ß array[___j] == nil)
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß (INode) array[___j + 1]))
                                                            )
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, hash(array[___j]), array[___j], array[___j + 1], ___addedLeaf)))
                                                            )
                                                        )
                                                        (§ ass ___j (ß ___j + 2))
                                                    )
                                                )
                                                (ß new ArrayNode(___edit, ___n + 1, ___nodes))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Object[]" ___newArray (ß new Object[2 * (___n + 4)])]
                                        (ß System/arraycopy(array, 0, ___newArray, 0, 2 * ___idx))
                                        (§ ass (ß ___newArray[2 * ___idx]) ___key)
                                        (§ ass (ß ___addedLeaf.val) ___addedLeaf)
                                        (§ ass (ß ___newArray[2 * ___idx + 1]) ___val)
                                        (ß System/arraycopy(array, 2 * ___idx, ___newArray, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                        (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
                                            (§ ass (ß ___editable.array) ___newArray)
                                            (§ ass (ß ___editable.bitmap) (ß ___editable.bitmap | ___bit))
                                            editable
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" without [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß (bitmap & ___bit) == 0)
                (§ return this)
            )
            (let [#_"int" ___idx (ß index(___bit))]
                (let [#_"Object" ___keyOrNull (ß array[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß array[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (let [#_"INode" ___n (ß ((INode) ___valOrNode).without(___edit, ___shift + 5, ___hash, ___key, ___removedLeaf))]
                                (when (ß ___n == ___valOrNode)
                                    (§ return this)
                                )
                                (when (some? ___n)
                                    (§ return (ß editAndSet(___edit, 2 * ___idx + 1, ___n)))
                                )
                                (when (ß bitmap == ___bit)
                                    (§ return nil)
                                )
                                (§ return (ß editAndRemovePair(___edit, ___bit, ___idx)))
                            )
                        )
                        (when (ß Util'equiv(___key, ___keyOrNull))
                            (§ ass (ß ___removedLeaf.val) ___removedLeaf)
                            ;; TODO: collapse
                            (§ return (ß editAndRemovePair(___edit, ___bit, ___idx)))
                        )
                        this
                    )
                )
            )
        )
    )
)

(class-ns HashCollisionNode (§ implements INode)
    (§ init
        (§ field #_"int" hash 0)
        (§ field #_"int" count 0)
        (§ field #_"Object[]" array nil)
        (§ field #_"AtomicReference<Thread>" edit nil)
    )

    (§ constructor #_"HashCollisionNode" HashCollisionNode [#_"AtomicReference<Thread>" ___edit, #_"int" ___hash, #_"int" ___count, #_"Object..." ___array]
        (let [this (ß super())]
            (§ ass (ß this.edit) ___edit)
            (§ ass (ß this.hash) ___hash)
            (§ ass (ß this.count) ___count)
            (§ ass (ß this.array) ___array)
            this
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (when (ß ___hash == this.hash)
            (let [#_"int" ___idx (ß findIndex(___key))]
                (when (ß ___idx != -1)
                    (when (ß array[___idx + 1] == ___val)
                        (§ return this)
                    )
                    (§ return (ß new HashCollisionNode(nil, ___hash, count, cloneAndSet(array, ___idx + 1, ___val))))
                )
                (let [#_"Object[]" ___newArray (ß new Object[2 * (count + 1)])]
                    (ß System/arraycopy(array, 0, ___newArray, 0, 2 * count))
                    (§ ass (ß ___newArray[2 * count]) ___key)
                    (§ ass (ß ___newArray[2 * count + 1]) ___val)
                    (§ ass (ß ___addedLeaf.val) ___addedLeaf)
                    (§ return (ß new HashCollisionNode(edit, ___hash, count + 1, ___newArray)))
                )
            )
        )
        ;; nest it in a bitmap node
        (ß new BitmapIndexedNode(nil, bitpos(this.hash, ___shift), new Object[] (§ array nil, this )).assoc(___shift, ___hash, ___key, ___val, ___addedLeaf))
    )

    #_method
    (§ defn #_"INode" without [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß findIndex(___key))]
            (when (ß ___idx == -1)
                (§ return this)
            )
            (when (ß count == 1)
                (§ return nil)
            )
            (ß new HashCollisionNode(nil, ___hash, count - 1, removePair(array, ___idx / 2)))
        )
    )

    #_method
    (§ defn #_"IMapEntry" find [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß findIndex(___key))]
            (when (ß ___idx < 0)
                (§ return nil)
            )
            (when (ß Util'equiv(___key, array[___idx]))
                (§ return (ß (IMapEntry) MapEntry'create(array[___idx], array[___idx + 1])))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" find [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___idx (ß findIndex(___key))]
            (when (ß ___idx < 0)
                (§ return ___notFound)
            )
            (when (ß Util'equiv(___key, array[___idx]))
                (§ return (ß array[___idx + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"ISeq" nodeSeq [#_"HashCollisionNode" this]
        (ß NodeSeq'create(array))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"HashCollisionNode" this, #_"IFn" ___f]
        (ß new NodeIter(array, ___f))
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"HashCollisionNode" this, #_"IFn" ___f, #_"Object" ___init]
        (ß NodeSeq'kvreduce(array, ___f, ___init))
    )

    #_method
    (§ defn #_"Object" fold [#_"HashCollisionNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (ß NodeSeq'kvreduce(array, ___reducef, ___combinef.invoke()))
    )

    #_method
    (§ defn #_"int" findIndex [#_"HashCollisionNode" this, #_"Object" ___key]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < 2 * count) [(§ ass ___i (ß ___i + 2))]
            (when (ß Util'equiv(___key, array[___i]))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn- #_"HashCollisionNode" ensureEditable [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß this.edit == ___edit)
            (§ return this)
        )
        (let [#_"Object[]" ___newArray (ß new Object[2 * (count + 1)])] ;; make room for next assoc
            (ß System/arraycopy(array, 0, ___newArray, 0, 2 * count))
            (ß new HashCollisionNode(___edit, hash, count, ___newArray))
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" ensureEditable [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___count, #_"Object[]" ___array]
        (when (ß this.edit == ___edit)
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.count) ___count)
            (§ return this)
        )
        (ß new HashCollisionNode(___edit, hash, ___count, ___array))
    )

    #_method
    (§ defn- #_"HashCollisionNode" editAndSet [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a]
        (let [#_"HashCollisionNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß ___editable.array[___i]) ___a)
            editable
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" editAndSet [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"HashCollisionNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß ___editable.array[___i]) ___a)
            (§ ass (ß ___editable.array[___j]) ___b)
            editable
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (when (ß ___hash == this.hash)
            (let [#_"int" ___idx (ß findIndex(___key))]
                (when (ß ___idx != -1)
                    (when (ß array[___idx + 1] == ___val)
                        (§ return this)
                    )
                    (§ return (ß editAndSet(___edit, ___idx + 1, ___val)))
                )
                (when (ß array.length > 2 * count)
                    (§ ass (ß ___addedLeaf.val) ___addedLeaf)
                    (let [#_"HashCollisionNode" ___editable (ß editAndSet(___edit, 2 * count, ___key, 2 * count + 1, ___val))]
                        (§ ass (ß ___editable.count) (ß ___editable.count + 1))
                        (§ return ___editable)
                    )
                )
                (let [#_"Object[]" ___newArray (ß new Object[array.length + 2])]
                    (ß System/arraycopy(array, 0, ___newArray, 0, array.length))
                    (§ ass (ß ___newArray[array.length]) ___key)
                    (§ ass (ß ___newArray[array.length + 1]) ___val)
                    (§ ass (ß ___addedLeaf.val) ___addedLeaf)
                    (§ return (ß ensureEditable(___edit, count + 1, ___newArray)))
                )
            )
        )
        ;; nest it in a bitmap node
        (ß new BitmapIndexedNode(___edit, bitpos(this.hash, ___shift), new Object[] (§ array nil, this, nil, nil )).assoc(___edit, ___shift, ___hash, ___key, ___val, ___addedLeaf))
    )

    #_method
    (§ defn #_"INode" without [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___idx (ß findIndex(___key))]
            (when (ß ___idx == -1)
                (§ return this)
            )
            (§ ass (ß ___removedLeaf.val) ___removedLeaf)
            (when (ß count == 1)
                (§ return nil)
            )
            (let [#_"HashCollisionNode" ___editable (ß ensureEditable(___edit))]
                (§ ass (ß ___editable.array[___idx]) (ß ___editable.array[2 * count - 2]))
                (§ ass (ß ___editable.array[___idx + 1]) (ß ___editable.array[2 * count - 1]))
                (§ ass (ß ___editable.array[2 * count - 2]) (§ ass (ß ___editable.array[2 * count - 1]) nil))
                (§ ass (ß ___editable.count) (ß ___editable.count - 1))
                editable
            )
        )
    )
)

(class-ns NodeIter (§ implements Iterator)
    (§ def- #_"Object" NodeIter'NULL (Object.))

    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"IFn" f nil)
        (§ field- #_"int" i 0)
        (§ field- #_"Object" nextEntry NodeIter'NULL)
        (§ field- #_"Iterator" nextIter nil)
    )

    (§ constructor #_"NodeIter" NodeIter [#_"Object[]" ___array, #_"IFn" ___f]
        (let [this (ß super())]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.f) ___f)
            this
        )
    )

    #_method
    (§ defn- #_"boolean" advance [#_"NodeIter" this]
        (while (ß i < array.length)
            (let [#_"Object" ___key (ß array[i])]
                (let [#_"Object" ___nodeOrVal (ß array[i + 1])]
                    (§ ass i (ß i + 2))
                    (cond (some? ___key)
                        (do
                            (§ ass nextEntry (ß f.invoke(___key, ___nodeOrVal)))
                            (§ return true)
                        )
                        (some? ___nodeOrVal)
                        (do
                            (let [#_"Iterator" ___iter (ß ((INode) ___nodeOrVal).iterator(f))]
                                (when (ß ___iter != nil && ___iter.hasNext())
                                    (§ ass nextIter ___iter)
                                    (§ return true)
                                )
                            )
                        )
                    )
                )
            )
        )
        false
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"NodeIter" this]
        (when (ß nextEntry != NodeIter'NULL || nextIter != nil)
            (§ return true)
        )
        (ß advance())
    )

    #_method
    (§ defn #_"Object" next [#_"NodeIter" this]
        (let [#_"Object" ___ret nextEntry]
            (cond (ß ___ret != NodeIter'NULL)
                (do
                    (§ ass nextEntry NodeIter'NULL)
                    (§ return ___ret)
                )
                (some? nextIter)
                (do
                    (§ ass ___ret (ß nextIter.next()))
                    (when (ß !nextIter.hasNext())
                        (§ ass nextIter nil)
                    )
                    (§ return ___ret)
                )
                (ß advance())
                (do
                    (§ return (ß next()))
                )
            )
            (throw (NoSuchElementException.))
        )
    )

    #_method
    (§ defn #_"void" remove [#_"NodeIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns NodeSeq (§ extends ASeq)
    (§ init
        (§ field #_"Object[]" array nil)
        (§ field #_"int" i 0)
        (§ field #_"ISeq" s nil)
    )

    (§ constructor #_"NodeSeq" NodeSeq [#_"Object[]" ___array, #_"int" ___i]
        (let [this (ß this(nil, ___array, ___i, nil))]
            this
        )
    )

    (§ defn #_"ISeq" NodeSeq'create [#_"Object[]" ___array]
        (ß NodeSeq'create(___array, 0, nil))
    )

    (§ defn #_"Object" NodeSeq'kvreduce [#_"Object[]" ___array, #_"IFn" ___f, #_"Object" ___init]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___array.length) [(§ ass ___i (ß ___i + 2))]
            (if (ß ___array[___i] != nil)
                (do
                    (§ ass ___init (ß ___f.invoke(___init, ___array[___i], ___array[___i + 1])))
                )
                (do
                    (let [#_"INode" ___node (ß (INode) ___array[___i + 1])]
                        (when (some? ___node)
                            (§ ass ___init (ß ___node.kvreduce(___f, ___init)))
                        )
                    )
                )
            )
            (when (ß RT'isReduced(___init))
                (§ return ___init)
            )
        )
        init
    )

    (§ defn- #_"ISeq" NodeSeq'create [#_"Object[]" ___array, #_"int" ___i, #_"ISeq" ___s]
        (when (some? ___s)
            (§ return (ß new NodeSeq(nil, ___array, ___i, ___s)))
        )
        (loop-when-recur [(§ var #_"int" ___j ___i)] (ß ___j < ___array.length) [(ß ___j += 2)]
            (when (ß ___array[___j] != nil)
                (§ return (ß new NodeSeq(nil, ___array, ___j, nil)))
            )
            (let [#_"INode" ___node (ß (INode) ___array[___j + 1])]
                (when (some? ___node)
                    (let [#_"ISeq" ___nodeSeq (ß ___node.nodeSeq())]
                        (when (some? ___nodeSeq)
                            (§ return (ß new NodeSeq(nil, ___array, ___j + 2, ___nodeSeq)))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ constructor #_"NodeSeq" NodeSeq [#_"IPersistentMap" ___meta, #_"Object[]" ___array, #_"int" ___i, #_"ISeq" ___s]
        (let [this (ß super(___meta))]
            (§ ass (ß this.array) ___array)
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.s) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"NodeSeq" this, #_"IPersistentMap" ___meta]
        (ß new NodeSeq(___meta, array, i, s))
    )

    #_method
    (§ defn #_"Object" first [#_"NodeSeq" this]
        (when (some? s)
            (§ return (ß s.first()))
        )
        (ß MapEntry'create(array[i], array[i + 1]))
    )

    #_method
    (§ defn #_"ISeq" next [#_"NodeSeq" this]
        (when (some? s)
            (§ return (ß NodeSeq'create(array, i, s.next())))
        )
        (ß NodeSeq'create(array, i + 2, nil))
    )
)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ def #_"PersistentHashMap" PersistentHashMap'EMPTY (ß new PersistentHashMap(0, nil, false, nil)))
    (§ def- #_"Object" PersistentHashMap'NOT_FOUND (Object.))

    (§ defn #_"IPersistentMap" PersistentHashMap'create [#_"Map" ___other]
        (let [#_"ITransientMap" ___ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" ___o (ß ___other.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            (ß ___ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn #_"PersistentHashMap" PersistentHashMap'create [#_"Object..." ___init]
        (let [#_"ITransientMap" ___ret (ß EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___init.length) [(§ ass ___i (ß ___i + 2))]
                (§ ass ___ret (ß ___ret.assoc(___init[___i], ___init[___i + 1])))
            )
            (ß (PersistentHashMap) ___ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" PersistentHashMap'createWithCheck [#_"Object..." ___init]
        (let [#_"ITransientMap" ___ret (ß EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___init.length) [(§ ass ___i (ß ___i + 2))]
                (§ ass ___ret (ß ___ret.assoc(___init[___i], ___init[___i + 1])))
                (when (ß ___ret.count() != ___i / 2 + 1)
                    (throw (IllegalArgumentException. (ß "Duplicate key: " + ___init[___i])))
                )
            )
            (ß (PersistentHashMap) ___ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" PersistentHashMap'create [#_"ISeq" ___items]
        (let [#_"ITransientMap" ___ret (ß EMPTY.asTransient())]
            (loop-when-recur [(ß )] (some? ___items) [(§ ass ___items (ß ___items.next().next()))]
                (when (ß ___items.next() == nil)
                    (throw (ß new IllegalArgumentException(String/format("No value supplied for key: %s", ___items.first()))))
                )
                (§ ass ___ret (ß ___ret.assoc(___items.first(), RT'second(___items))))
            )
            (ß (PersistentHashMap) ___ret.persistent())
        )
    )

    (§ defn #_"PersistentHashMap" PersistentHashMap'createWithCheck [#_"ISeq" ___items]
        (let [#_"ITransientMap" ___ret (ß EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___items) [(§ ass ___items (ß ___items.next().next()), ___i (ß ___i + 1))]
                (when (ß ___items.next() == nil)
                    (throw (ß new IllegalArgumentException(String/format("No value supplied for key: %s", ___items.first()))))
                )
                (§ ass ___ret (ß ___ret.assoc(___items.first(), RT'second(___items))))
                (when (ß ___ret.count() != ___i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + ___items.first())))
                )
            )
            (ß (PersistentHashMap) ___ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (§ defn #_"PersistentHashMap" PersistentHashMap'create [#_"IPersistentMap" ___meta, #_"Object..." ___init]
        (ß create(___init).withMeta(___meta))
    )

    (§ init
        (§ field #_"int" count 0)
        (§ field #_"INode" root nil)
        (§ field #_"boolean" hasNull false)
        (§ field #_"Object" nullValue nil)
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentHashMap" PersistentHashMap [#_"int" ___count, #_"INode" ___root, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (ß super())]
            (§ ass (ß this.count) ___count)
            (§ ass (ß this.root) ___root)
            (§ ass (ß this.hasNull) ___hasNull)
            (§ ass (ß this.nullValue) ___nullValue)
            (§ ass (ß this._meta) nil)
            this
        )
    )

    (§ constructor #_"PersistentHashMap" PersistentHashMap [#_"IPersistentMap" ___meta, #_"int" ___count, #_"INode" ___root, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (ß super())]
            (§ ass (ß this._meta) ___meta)
            (§ ass (ß this.count) ___count)
            (§ ass (ß this.root) ___root)
            (§ ass (ß this.hasNull) ___hasNull)
            (§ ass (ß this.nullValue) ___nullValue)
            this
        )
    )

    (§ defn #_"int" PersistentHashMap'hash [#_"Object" ___k]
        (ß Util'hasheq(___k))
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return hasNull)
        )
        (ß (root != nil) ? (root.find(0, hash(___key), ___key, NOT_FOUND) != NOT_FOUND) :or false)
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (ß hasNull ? (IMapEntry) MapEntry'create(nil, nullValue) :or nil))
        )
        (ß (root != nil) ? root.find(0, hash(___key), ___key) :or nil)
    )

    #_method
    (§ defn #_"IPersistentMap" assoc [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___key)
            (when (ß hasNull && ___val == nullValue)
                (§ return this)
            )
            (§ return (ß new PersistentHashMap(meta(), hasNull ? count :or count + 1, root, true, ___val)))
        )
        (let [#_"Box" ___addedLeaf (Box. nil)]
            (let [#_"INode" ___newroot (ß ((root == nil) ? BitmapIndexedNode'EMPTY :or root).assoc(0, hash(___key), ___key, ___val, ___addedLeaf))]
                (when (ß ___newroot == root)
                    (§ return this)
                )
                (ß new PersistentHashMap(meta(), (___addedLeaf.val == nil) ? count :or count + 1, ___newroot, hasNull, nullValue))
            )
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (nil? ___key)
            (§ return (ß hasNull ? nullValue :or ___notFound))
        )
        (ß (root != nil) ? root.find(0, hash(___key), ___key, ___notFound) :or ___notFound)
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentHashMap" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"IPersistentMap" assocEx [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (ß containsKey(___key))
            (throw (ß Util'runtimeException("Key already present")))
        )
        (ß assoc(___key, ___val))
    )

    #_method
    (§ defn #_"IPersistentMap" without [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (ß hasNull ? new PersistentHashMap(meta(), count - 1, root, false, nil) :or this))
        )
        (when (nil? root)
            (§ return this)
        )
        (let [#_"INode" ___newroot (ß root.without(0, hash(___key), ___key))]
            (when (ß ___newroot == root)
                (§ return this)
            )
            (ß new PersistentHashMap(meta(), count - 1, ___newroot, hasNull, nullValue))
        )
    )

    (§ def #_"Iterator" PersistentHashMap'EMPTY_ITER
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn- #_"Iterator" iterator [#_"PersistentHashMap" this, #_"IFn" ___f]
        (let [#_"Iterator" ___rootIter (ß (root == nil) ? EMPTY_ITER :or root.iterator(___f))]
            (if hasNull
                (do
                    (§ reify Iterator()
                        (§ init
                            (§ field- #_"boolean" seen false)
                        )

                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (if (ß !seen)
                                (do
                                    true
                                )
                                (do
                                    (ß ___rootIter.hasNext())
                                )
                            )
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (if (ß !seen)
                                (do
                                    (§ ass seen true)
                                    (ß ___f.invoke(nil, nullValue))
                                )
                                (do
                                    (ß ___rootIter.next())
                                )
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
                (do
                    ___rootIter
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap'MAKE_ENTRY))
    )

    #_method
    (§ defn #_"Iterator" keyIterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap'MAKE_KEY))
    )

    #_method
    (§ defn #_"Iterator" valIterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap'MAKE_VAL))
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentHashMap" this, #_"IFn" ___f, #_"Object" ___init]
        (§ ass ___init (ß hasNull ? ___f.invoke(___init, nil, nullValue) :or ___init))
        (when (ß RT'isReduced(___init))
            (§ return (ß ((IDeref)___init).deref()))
        )
        (when (some? root)
            (§ ass ___init (ß root.kvreduce(___f, ___init)))
            (if (ß RT'isReduced(___init))
                (do
                    (§ return (ß ((IDeref)___init).deref()))
                )
                (do
                    (§ return ___init)
                )
            )
        )
        init
    )

    #_method
    (§ defn #_"Object" fold [#_"PersistentHashMap" this, #_"long" ___n, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjinvoke, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        ;; we are ignoring n for now
        (let [#_"Callable" ___top
                (§ reify Callable()
                    #_method
                    (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                        (let [#_"Object" ___ret (ß ___combinef.invoke())]
                            (when (some? root)
                                (§ ass ___ret (ß ___combinef.invoke(___ret, root.fold(___combinef, ___reducef, ___fjtask, ___fjfork, ___fjjoin))))
                            )
                            (ß hasNull ? ___combinef.invoke(___ret, ___reducef.invoke(___combinef.invoke(), nil, nullValue)) :or ___ret)
                        )
                    )
                )]
            (ß ___fjinvoke.invoke(___top))
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentHashMap" this]
        count
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentHashMap" this]
        (let [#_"ISeq" ___s (ß (root != nil) ? root.nodeSeq() :or nil)]
            (ß hasNull ? new Cons(MapEntry'create(nil, nullValue), ___s) :or ___s)
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentHashMap" this]
        (ß EMPTY.withMeta(meta()))
    )

    (§ defn #_"int" PersistentHashMap'mask [#_"int" ___hash, #_"int" ___shift]
        (ß (___hash >>> ___shift) & 0x01f)
    )

    #_method
    (§ defn #_"PersistentHashMap" withMeta [#_"PersistentHashMap" this, #_"IPersistentMap" ___meta]
        (ß new PersistentHashMap(___meta, count, root, hasNull, nullValue))
    )

    #_method
    (§ defn #_"TransientHashMap" asTransient [#_"PersistentHashMap" this]
        (TransientHashMap. this)
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentHashMap" this]
        _meta
    )

    (§ defn- #_"INode[]" PersistentHashMap'cloneAndSet [#_"INode[]" ___array, #_"int" ___i, #_"INode" ___a]
        (let [#_"INode[]" ___clone (ß ___array.clone())]
            (§ ass (ß ___clone[___i]) ___a)
            clone
        )
    )

    (§ defn- #_"Object[]" PersistentHashMap'cloneAndSet [#_"Object[]" ___array, #_"int" ___i, #_"Object" ___a]
        (let [#_"Object[]" ___clone (ß ___array.clone())]
            (§ ass (ß ___clone[___i]) ___a)
            clone
        )
    )

    (§ defn- #_"Object[]" PersistentHashMap'cloneAndSet [#_"Object[]" ___array, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"Object[]" ___clone (ß ___array.clone())]
            (§ ass (ß ___clone[___i]) ___a)
            (§ ass (ß ___clone[___j]) ___b)
            clone
        )
    )

    (§ defn- #_"Object[]" PersistentHashMap'removePair [#_"Object[]" ___array, #_"int" ___i]
        (let [#_"Object[]" ___newArray (ß new Object[___array.length - 2])]
            (ß System/arraycopy(___array, 0, ___newArray, 0, 2 * ___i))
            (ß System/arraycopy(___array, 2 * (___i + 1), ___newArray, 2 * ___i, ___newArray.length - 2 * ___i))
            newArray
        )
    )

    (§ defn- #_"INode" PersistentHashMap'createNode [#_"int" ___shift, #_"Object" ___key1, #_"Object" ___val1, #_"int" ___key2hash, #_"Object" ___key2, #_"Object" ___val2]
        (let [#_"int" ___key1hash (ß hash(___key1))]
            (when (ß ___key1hash == ___key2hash)
                (§ return (ß new HashCollisionNode(nil, ___key1hash, 2, new Object[] (§ array ___key1, ___val1, ___key2, ___val2 ))))
            )
            (let [#_"Box" ___addedLeaf (Box. nil)]
                (let [#_"AtomicReference<Thread>" ___edit (ß new AtomicReference<Thread>())]
                    (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift, ___key1hash, ___key1, ___val1, ___addedLeaf).assoc(___edit, ___shift, ___key2hash, ___key2, ___val2, ___addedLeaf))
                )
            )
        )
    )

    (§ defn- #_"INode" PersistentHashMap'createNode [#_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"Object" ___key1, #_"Object" ___val1, #_"int" ___key2hash, #_"Object" ___key2, #_"Object" ___val2]
        (let [#_"int" ___key1hash (ß hash(___key1))]
            (when (ß ___key1hash == ___key2hash)
                (§ return (ß new HashCollisionNode(nil, ___key1hash, 2, new Object[] (§ array ___key1, ___val1, ___key2, ___val2 ))))
            )
            (let [#_"Box" ___addedLeaf (Box. nil)]
                (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift, ___key1hash, ___key1, ___val1, ___addedLeaf).assoc(___edit, ___shift, ___key2hash, ___key2, ___val2, ___addedLeaf))
            )
        )
    )

    (§ defn- #_"int" PersistentHashMap'bitpos [#_"int" ___hash, #_"int" ___shift]
        (ß 1 << mask(___hash, ___shift))
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

#_stateless
(class-ns TransientHashSet (§ extends ATransientSet)
    (§ constructor #_"TransientHashSet" TransientHashSet [#_"ITransientMap" ___impl]
        (let [this (ß super(___impl))]
            this
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" persistent [#_"TransientHashSet" this]
        (ß new PersistentHashSet(nil, impl.persistent()))
    )
)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def #_"PersistentHashSet" PersistentHashSet'EMPTY (ß new PersistentHashSet(nil, PersistentHashMap'EMPTY)))

    (§ defn #_"PersistentHashSet" PersistentHashSet'create [#_"Object..." ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___init.length) [(§ ass ___i (ß ___i + 1))]
                (§ ass ___ret (ß (ITransientSet)___ret.conj(___init[___i])))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" PersistentHashSet'create [#_"List" ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)EMPTY.asTransient())]
            (doseq [#_"Object" ___key ___init]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___key)))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" PersistentHashSet'create [#_"ISeq" ___items]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(ß )] (some? ___items) [(§ ass ___items (ß ___items.next()))]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___items.first())))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" PersistentHashSet'createWithCheck [#_"Object..." ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___init.length) [(§ ass ___i (ß ___i + 1))]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___init[___i])))
                (when (ß ___ret.count() != ___i + 1)
                    (throw (IllegalArgumentException. (ß "Duplicate key: " + ___init[___i])))
                )
            )
            (ß (PersistentHashSet) ___ret.persistent())
        )
    )

    (§ defn #_"PersistentHashSet" PersistentHashSet'createWithCheck [#_"List" ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)EMPTY.asTransient())]
            (let [#_"int" ___i 0]
                (doseq [#_"Object" ___key ___init]
                    (§ ass ___ret (ß (ITransientSet) ___ret.conj(___key)))
                    (when (ß ___ret.count() != ___i + 1)
                        (throw (IllegalArgumentException. (ß "Duplicate key: " + ___key)))
                    )
                    (§ ass ___i (ß ___i + 1))
                )
                (ß (PersistentHashSet) ___ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentHashSet" PersistentHashSet'createWithCheck [#_"ISeq" ___items]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)EMPTY.asTransient())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___items) [(§ ass ___items (ß ___items.next()), ___i (ß ___i + 1))]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___items.first())))
                (when (ß ___ret.count() != ___i + 1)
                    (throw (ß new IllegalArgumentException("Duplicate key: " + ___items.first())))
                )
            )
            (ß (PersistentHashSet) ___ret.persistent())
        )
    )

    (§ init
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentHashSet" PersistentHashSet [#_"IPersistentMap" ___meta, #_"IPersistentMap" ___impl]
        (let [this (ß super(___impl))]
            (§ ass (ß this._meta) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentSet" disjoin [#_"PersistentHashSet" this, #_"Object" ___key]
        (when (ß contains(___key))
            (§ return (ß new PersistentHashSet(meta(), impl.without(___key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" cons [#_"PersistentHashSet" this, #_"Object" ___o]
        (when (ß contains(___o))
            (§ return this)
        )
        (ß new PersistentHashSet(meta(), impl.assoc(___o, ___o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentHashSet" this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentHashSet" withMeta [#_"PersistentHashSet" this, #_"IPersistentMap" ___meta]
        (ß new PersistentHashSet(___meta, impl))
    )

    #_method
    (§ defn #_"ITransientCollection" asTransient [#_"PersistentHashSet" this]
        (ß new TransientHashSet(((PersistentHashMap) impl).asTransient()))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentHashSet" this]
        _meta
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

#_stateless
(class-ns Primordial (§ extends RestFn)
    #_method
    (§ defn #_"int" getRequiredArity [#_"Primordial" this]
        0
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"Primordial" this, #_"Object" ___args]
        (when (ß ___args instanceof ArraySeq)
            (let [#_"Object[]" ___argsarray (ß ((ArraySeq) ___args).array)]
                (let [#_"IPersistentList" ___ret EMPTY]
                    (loop-when-recur [(§ var #_"int" ___i (ß ___argsarray.length - 1))] (ß ___i >= ((ArraySeq)___args).i) [(§ ass ___i (ß ___i - 1))]
                        (§ ass ___ret (ß (IPersistentList) ___ret.cons(___argsarray[___i])))
                    )
                    (§ return ___ret)
                )
            )
        )
        (let [#_"LinkedList" ___list (LinkedList.)]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___args)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (ß ___list.add(___s.first()))
            )
            (ß create(___list))
        )
    )

    (§ defn #_"Object" Primordial'invokeStatic [#_"ISeq" ___args]
        (when (ß ___args instanceof ArraySeq)
            (let [#_"Object[]" ___argsarray (ß ((ArraySeq) ___args).array)]
                (let [#_"IPersistentList" ___ret EMPTY]
                    (loop-when-recur [(§ var #_"int" ___i (ß ___argsarray.length - 1))] (ß ___i >= 0) [(§ ass ___i (ß ___i - 1))]
                        (§ ass ___ret (ß (IPersistentList) ___ret.cons(___argsarray[___i])))
                    )
                    (§ return ___ret)
                )
            )
        )
        (let [#_"LinkedList" ___list (LinkedList.)]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß RT'seq(___args)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (ß ___list.add(___s.first()))
            )
            (ß create(___list))
        )
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"Primordial" this, #_"IPersistentMap" ___meta]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"Primordial" this]
        nil
    )
)

#_stateless
(class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
    (§ def #_"int" EmptyList'hasheq (ß Murmur3'hashOrdered(Collections/EMPTY_LIST)))

    (§ constructor #_"EmptyList" EmptyList [#_"IPersistentMap" ___meta]
        (let [this (ß super(___meta))]
            this
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"EmptyList" this]
        1
    )

    #_method
    (§ defn #_"int" EmptyList'hasheq [#_"EmptyList" this]
        EmptyList'hasheq
    )

    #_method
    (§ defn #_"String" toString [#_"EmptyList" this]
        "()"
    )

    #_method
    (§ defn #_"boolean" equals [#_"EmptyList" this, #_"Object" ___o]
        (ß ((___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"EmptyList" this, #_"Object" ___o]
        (ß equals(___o))
    )

    #_method
    (§ defn #_"Object" first [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" next [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" more [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"PersistentList" cons [#_"EmptyList" this, #_"Object" ___o]
        (ß new PersistentList(meta(), ___o, nil, 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"EmptyList" withMeta [#_"EmptyList" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != meta())
            (§ return (EmptyList. ___meta))
        )
        this
    )

    #_method
    (§ defn #_"Object" peek [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentList" pop [#_"EmptyList" this]
        (throw (IllegalStateException. "Can't pop empty list"))
    )

    #_method
    (§ defn #_"int" count [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"ISeq" seq [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"int" size [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"EmptyList" this]
        true
    )

    #_method
    (§ defn #_"boolean" contains [#_"EmptyList" this, #_"Object" ___o]
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"EmptyList" this]
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"EmptyList" this]
        (ß RT'EMPTY_ARRAY)
    )

    #_method
    (§ defn #_"boolean" add [#_"EmptyList" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"EmptyList" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"EmptyList" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"EmptyList" this, #_"Collection" ___collection]
        (ß ___collection.isEmpty())
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"EmptyList" this, #_"Object[]" ___objects]
        (when (ß ___objects.length > 0)
            (§ ass (ß ___objects[0]) nil)
        )
        objects
    )

    #_method
    (§ defn- #_"List" reify [#_"EmptyList" this]
        (ß Collections/unmodifiableList(new ArrayList(this)))
    )

    #_method
    (§ defn #_"List" subList [#_"EmptyList" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß reify().subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"EmptyList" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"EmptyList" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"EmptyList" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (ß seq())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___s) [(§ ass ___s (ß ___s.next()), ___i (ß ___i + 1))]
                (when (ß Util'equiv(___s.first(), ___o))
                    (§ return ___i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"EmptyList" this, #_"Object" ___o]
        (ß reify().lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"EmptyList" this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"EmptyList" this, #_"int" ___index]
        (ß reify().listIterator(___index))
    )

    #_method
    (§ defn #_"Object" get [#_"EmptyList" this, #_"int" ___index]
        (ß RT'nth(this, ___index))
    )

    #_method
    (§ defn #_"void" add [#_"EmptyList" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"EmptyList" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ def #_"IFn" PersistentList'creator (Primordial.))

    (§ def #_"EmptyList" PersistentList'EMPTY (EmptyList. nil))

    (§ init
        (§ field- #_"Object" _first nil)
        (§ field- #_"IPersistentList" _rest nil)
        (§ field- #_"int" _count 0)
    )

    (§ constructor #_"PersistentList" PersistentList [#_"Object" ___first]
        (let [this (ß super())]
            (§ ass (ß this._first) ___first)
            (§ ass (ß this._rest) nil)

            (§ ass (ß this._count) 1)
            this
        )
    )

    (§ constructor #_"PersistentList" PersistentList [#_"IPersistentMap" ___meta, #_"Object" ____first, #_"IPersistentList" ____rest, #_"int" ____count]
        (let [this (ß super(___meta))]
            (§ ass (ß this._first) ____first)
            (§ ass (ß this._rest) ____rest)
            (§ ass (ß this._count) ____count)
            this
        )
    )

    (§ defn #_"IPersistentList" PersistentList'create [#_"List" ___init]
        (let [#_"IPersistentList" ___ret EMPTY]
            (loop-when-recur [(§ var #_"ListIterator" ___i (ß ___init.listIterator(___init.size())))] (ß ___i.hasPrevious()) [(ß )]
                (§ ass ___ret (ß (IPersistentList) ___ret.cons(___i.previous())))
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" first [#_"PersistentList" this]
        _first
    )

    #_method
    (§ defn #_"ISeq" next [#_"PersistentList" this]
        (when (ß _count == 1)
            (§ return nil)
        )
        (ß (ISeq) _rest)
    )

    #_method
    (§ defn #_"Object" peek [#_"PersistentList" this]
        (ß first())
    )

    #_method
    (§ defn #_"IPersistentList" pop [#_"PersistentList" this]
        (when (nil? _rest)
            (§ return (ß EMPTY.withMeta(_meta)))
        )
        _rest
    )

    #_method
    (§ defn #_"int" count [#_"PersistentList" this]
        _count
    )

    #_method
    (§ defn #_"PersistentList" cons [#_"PersistentList" this, #_"Object" ___o]
        (ß new PersistentList(meta(), ___o, this, _count + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentList" this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentList" withMeta [#_"PersistentList" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != _meta)
            (§ return (ß new PersistentList(___meta, _first, _rest, _count)))
        )
        this
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentList" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß first())]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß next()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (§ ass ___ret (ß ___f.invoke(___ret, ___s.first())))
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentList" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, first()))]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß next()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                (when (ß RT'isReduced(___ret))
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, ___s.first())))
            )
            (when (ß RT'isReduced(___ret))
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ret
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns QSeq (§ extends ASeq)
    (§ init
        (§ field #_"ISeq" f nil)
        (§ field #_"ISeq" rseq nil)
    )

    (§ constructor #_"QSeq" QSeq [#_"ISeq" ___f, #_"ISeq" ___rseq]
        (let [this (ß super())]
            (§ ass (ß this.f) ___f)
            (§ ass (ß this.rseq) ___rseq)
            this
        )
    )

    (§ constructor #_"QSeq" QSeq [#_"IPersistentMap" ___meta, #_"ISeq" ___f, #_"ISeq" ___rseq]
        (let [this (ß super(___meta))]
            (§ ass (ß this.f) ___f)
            (§ ass (ß this.rseq) ___rseq)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"QSeq" this]
        (ß f.first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"QSeq" this]
        (let [#_"ISeq" ___f1 (ß f.next())]
            (let [#_"ISeq" ___r1 rseq]
                (when (nil? ___f1)
                    (when (nil? rseq)
                        (§ return nil)
                    )
                    (§ ass ___f1 rseq)
                    (§ ass ___r1 nil)
                )
                (ß new QSeq(___f1, ___r1))
            )
        )
    )

    #_method
    (§ defn #_"int" count [#_"QSeq" this]
        (ß RT'count(f) + RT'count(rseq))
    )

    #_method
    (§ defn #_"QSeq" withMeta [#_"QSeq" this, #_"IPersistentMap" ___meta]
        (ß new QSeq(___meta, f, rseq))
    )
)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def #_"PersistentQueue" PersistentQueue'EMPTY (ß new PersistentQueue(nil, 0, nil, nil)))

    (§ init
        (§ field #_"int" cnt 0)
        (§ field #_"ISeq" f nil)
        (§ field #_"PersistentVector" r nil)
        (§ field #_"int" _hash 0)
        (§ field #_"int" _hasheq 0)
    )

    (§ constructor #_"PersistentQueue" PersistentQueue [#_"IPersistentMap" ___meta, #_"int" ___cnt, #_"ISeq" ___f, #_"PersistentVector" ___r]
        (let [this (ß super(___meta))]
            (§ ass (ß this.cnt) ___cnt)
            (§ ass (ß this.f) ___f)
            (§ ass (ß this.r) ___r)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentQueue" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (ß RT'seq(___obj))]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()), ___ms (ß ___ms.next()))]
                (when (ß ___ms == nil || !Util'equiv(___s.first(), ___ms.first()))
                    (§ return false)
                )
            )
            (ß (___ms == nil))
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentQueue" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (ß RT'seq(___obj))]
            (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()), ___ms (ß ___ms.next()))]
                (when (ß ___ms == nil || !Util'equals(___s.first(), ___ms.first()))
                    (§ return false)
                )
            )
            (ß (___ms == nil))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"PersistentQueue" this]
        (let [#_"int" ___hash (ß this._hash)]
            (when (ß ___hash == 0)
                (§ ass ___hash 1)
                (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                    (§ ass ___hash (ß 31 * ___hash + ((___s.first() == nil) ? 0 :or ___s.first().hashCode())))
                )
                (§ ass (ß this._hash) ___hash)
            )
            hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"PersistentQueue" this]
        (let [#_"int" ___cached (ß this._hasheq)]
            (when (ß ___cached == 0)
                (§ ass (ß this._hasheq) (§ ass ___cached (ß Murmur3'hashOrdered(this))))
            )
            cached
        )
    )

    #_method
    (§ defn #_"Object" peek [#_"PersistentQueue" this]
        (ß RT'first(f))
    )

    #_method
    (§ defn #_"PersistentQueue" pop [#_"PersistentQueue" this]
        (when (nil? f) ;; hmmm... pop of empty queue -> empty queue?
            (§ return this)
        )
        (let [#_"ISeq" ___f1 (ß f.next())]
            (let [#_"PersistentVector" ___r1 r]
                (when (nil? ___f1)
                    (§ ass ___f1 (ß RT'seq(r)))
                    (§ ass ___r1 nil)
                )
                (ß new PersistentQueue(meta(), cnt - 1, ___f1, ___r1))
            )
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentQueue" this]
        cnt
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentQueue" this]
        (when (nil? f)
            (§ return nil)
        )
        (ß new QSeq(f, RT'seq(r)))
    )

    #_method
    (§ defn #_"PersistentQueue" cons [#_"PersistentQueue" this, #_"Object" ___o]
        (if (nil? f) ;; empty
            (do
                (ß new PersistentQueue(meta(), cnt + 1, RT'list(___o), nil))
            )
            (do
                (ß new PersistentQueue(meta(), cnt + 1, f, ((r != nil) ? r :or PersistentVector'EMPTY).cons(___o)))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentQueue" this]
        (ß PersistentQueue'EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentQueue" withMeta [#_"PersistentQueue" this, #_"IPersistentMap" ___meta]
        (ß new PersistentQueue(___meta, cnt, f, r))
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"PersistentQueue" this]
        (ß RT'seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"PersistentQueue" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"PersistentQueue" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"PersistentQueue" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"PersistentQueue" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß contains(___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"PersistentQueue" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"PersistentQueue" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"PersistentQueue" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"boolean" contains [#_"PersistentQueue" this, #_"Object" ___o]
        (loop-when-recur [(§ var #_"ISeq" ___s (ß seq()))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
            (when (ß Util'equiv(___s.first(), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentQueue" this]
        (§ reify Iterator()
            (§ init
                (§ field- #_"ISeq" fseq f)
                (§ field- #_"Iterator" riter (ß (r != nil) ? r.iterator() :or nil))
            )

            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (ß ((fseq != nil && fseq.seq() != nil) || (riter != nil && riter.hasNext())))
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (cond (some? fseq)
                    (do
                        (let [#_"Object" ___ret (ß fseq.first())]
                            (§ ass fseq (ß fseq.next()))
                            ret
                        )
                    )
                    (ß riter != nil && riter.hasNext())
                    (do
                        (ß riter.next())
                    )
                    :else
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

#_abstract
(class-ns TNode (§ extends AMapEntry)
    (§ init
        (§ field #_"Object" key nil)
    )

    (§ constructor #_"TNode" TNode [#_"Object" ___key]
        (let [this (ß super())]
            (§ ass (ß this.key) ___key)
            this
        )
    )

    #_method
    (§ defn #_"Object" key [#_"TNode" this]
        key
    )

    #_method
    (§ defn #_"Object" val [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"Object" getKey [#_"TNode" this]
        (ß key())
    )

    #_method
    (§ defn #_"Object" getValue [#_"TNode" this]
        (ß val())
    )

    #_method
    (§ defn #_"TNode" left [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"TNode" right [#_"TNode" this]
        nil
    )

    #_abstract
    (§ defn #_"TNode" addLeft [#_"TNode" this, #_"TNode" ___ins])
    #_abstract
    (§ defn #_"TNode" addRight [#_"TNode" this, #_"TNode" ___ins])
    #_abstract
    (§ defn #_"TNode" removeLeft [#_"TNode" this, #_"TNode" ___del])
    #_abstract
    (§ defn #_"TNode" removeRight [#_"TNode" this, #_"TNode" ___del])
    #_abstract
    (§ defn #_"TNode" blacken [#_"TNode" this])
    #_abstract
    (§ defn #_"TNode" redden [#_"TNode" this])

    #_method
    (§ defn #_"TNode" balanceLeft [#_"TNode" this, #_"TNode" ___parent]
        (ß black(___parent.key, ___parent.val(), this, ___parent.right()))
    )

    #_method
    (§ defn #_"TNode" balanceRight [#_"TNode" this, #_"TNode" ___parent]
        (ß black(___parent.key, ___parent.val(), ___parent.left(), this))
    )

    #_abstract
    (§ defn #_"TNode" replace [#_"TNode" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right])

    #_method
    (§ defn #_"Object" kvreduce [#_"TNode" this, #_"IFn" ___f, #_"Object" ___init]
        (when (ß left() != nil)
            (§ ass ___init (ß left().kvreduce(___f, ___init)))
            (when (ß RT'isReduced(___init))
                (§ return ___init)
            )
        )
        (§ ass ___init (ß ___f.invoke(___init, key(), val())))
        (when (ß RT'isReduced(___init))
            (§ return ___init)
        )

        (when (ß right() != nil)
            (§ ass ___init (ß right().kvreduce(___f, ___init)))
        )
        init
    )
)

#_stateless
(class-ns Black (§ extends TNode)
    (§ constructor #_"Black" Black [#_"Object" ___key]
        (let [this (ß super(___key))]
            this
        )
    )

    #_method
    (§ defn #_"TNode" addLeft [#_"Black" this, #_"TNode" ___ins]
        (ß ___ins.balanceLeft(this))
    )

    #_method
    (§ defn #_"TNode" addRight [#_"Black" this, #_"TNode" ___ins]
        (ß ___ins.balanceRight(this))
    )

    #_method
    (§ defn #_"TNode" removeLeft [#_"Black" this, #_"TNode" ___del]
        (ß balanceLeftDel(key, val(), ___del, right()))
    )

    #_method
    (§ defn #_"TNode" removeRight [#_"Black" this, #_"TNode" ___del]
        (ß balanceRightDel(key, val(), left(), ___del))
    )

    #_method
    (§ defn #_"TNode" blacken [#_"Black" this]
        this
    )

    #_method
    (§ defn #_"TNode" redden [#_"Black" this]
        (Red. key)
    )

    #_method
    (§ defn #_"TNode" replace [#_"Black" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (ß black(___key, ___val, ___left, ___right))
    )
)

(class-ns BlackVal (§ extends Black)
    (§ init
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"BlackVal" BlackVal [#_"Object" ___key, #_"Object" ___val]
        (let [this (ß super(___key))]
            (§ ass (ß this.val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"BlackVal" this]
        val
    )

    #_method
    (§ defn #_"TNode" redden [#_"BlackVal" this]
        (ß new RedVal(key, val))
    )
)

(class-ns BlackBranch (§ extends Black)
    (§ init
        (§ field #_"TNode" left nil)
        (§ field #_"TNode" right nil)
    )

    (§ constructor #_"BlackBranch" BlackBranch [#_"Object" ___key, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (ß super(___key))]
            (§ ass (ß this.left) ___left)
            (§ ass (ß this.right) ___right)
            this
        )
    )

    #_method
    (§ defn #_"TNode" left [#_"BlackBranch" this]
        left
    )

    #_method
    (§ defn #_"TNode" right [#_"BlackBranch" this]
        right
    )

    #_method
    (§ defn #_"TNode" redden [#_"BlackBranch" this]
        (ß new RedBranch(key, left, right))
    )
)

(class-ns BlackBranchVal (§ extends BlackBranch)
    (§ init
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"BlackBranchVal" BlackBranchVal [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (ß super(___key, ___left, ___right))]
            (§ ass (ß this.val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"BlackBranchVal" this]
        val
    )

    #_method
    (§ defn #_"TNode" redden [#_"BlackBranchVal" this]
        (ß new RedBranchVal(key, val, left, right))
    )
)

#_stateless
(class-ns Red (§ extends TNode)
    (§ constructor #_"Red" Red [#_"Object" ___key]
        (let [this (ß super(___key))]
            this
        )
    )

    #_method
    (§ defn #_"TNode" addLeft [#_"Red" this, #_"TNode" ___ins]
        (ß red(key, val(), ___ins, right()))
    )

    #_method
    (§ defn #_"TNode" addRight [#_"Red" this, #_"TNode" ___ins]
        (ß red(key, val(), left(), ___ins))
    )

    #_method
    (§ defn #_"TNode" removeLeft [#_"Red" this, #_"TNode" ___del]
        (ß red(key, val(), ___del, right()))
    )

    #_method
    (§ defn #_"TNode" removeRight [#_"Red" this, #_"TNode" ___del]
        (ß red(key, val(), left(), ___del))
    )

    #_method
    (§ defn #_"TNode" blacken [#_"Red" this]
        (Black. key)
    )

    #_method
    (§ defn #_"TNode" redden [#_"Red" this]
        (throw (UnsupportedOperationException. "Invariant violation"))
    )

    #_method
    (§ defn #_"TNode" replace [#_"Red" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (ß red(___key, ___val, ___left, ___right))
    )
)

(class-ns RedVal (§ extends Red)
    (§ init
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"RedVal" RedVal [#_"Object" ___key, #_"Object" ___val]
        (let [this (ß super(___key))]
            (§ ass (ß this.val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"RedVal" this]
        val
    )

    #_method
    (§ defn #_"TNode" blacken [#_"RedVal" this]
        (ß new BlackVal(key, val))
    )
)

(class-ns RedBranch (§ extends Red)
    (§ init
        (§ field #_"TNode" left nil)
        (§ field #_"TNode" right nil)
    )

    (§ constructor #_"RedBranch" RedBranch [#_"Object" ___key, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (ß super(___key))]
            (§ ass (ß this.left) ___left)
            (§ ass (ß this.right) ___right)
            this
        )
    )

    #_method
    (§ defn #_"TNode" left [#_"RedBranch" this]
        left
    )

    #_method
    (§ defn #_"TNode" right [#_"RedBranch" this]
        right
    )

    #_method
    (§ defn #_"TNode" balanceLeft [#_"RedBranch" this, #_"TNode" ___parent]
        (cond (ß left instanceof Red)
            (do
                (ß red(key, val(), left.blacken(), black(___parent.key, ___parent.val(), right, ___parent.right())))
            )
            (ß right instanceof Red)
            (do
                (ß red(right.key, right.val(), black(key, val(), left, right.left()), black(___parent.key, ___parent.val(), right.right(), ___parent.right())))
            )
            :else
            (do
                (ß super.balanceLeft(___parent))
            )
        )
    )

    #_method
    (§ defn #_"TNode" balanceRight [#_"RedBranch" this, #_"TNode" ___parent]
        (cond (ß right instanceof Red)
            (do
                (ß red(key, val(), black(___parent.key, ___parent.val(), ___parent.left(), left), right.blacken()))
            )
            (ß left instanceof Red)
            (do
                (ß red(left.key, left.val(), black(___parent.key, ___parent.val(), ___parent.left(), left.left()), black(key, val(), left.right(), right)))
            )
            :else
            (do
                (ß super.balanceRight(___parent))
            )
        )
    )

    #_method
    (§ defn #_"TNode" blacken [#_"RedBranch" this]
        (ß new BlackBranch(key, left, right))
    )
)

(class-ns RedBranchVal (§ extends RedBranch)
    (§ init
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"RedBranchVal" RedBranchVal [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (ß super(___key, ___left, ___right))]
            (§ ass (ß this.val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"RedBranchVal" this]
        val
    )

    #_method
    (§ defn #_"TNode" blacken [#_"RedBranchVal" this]
        (ß new BlackBranchVal(key, val, left, right))
    )
)

(class-ns TSeq (§ extends ASeq)
    (§ init
        (§ field #_"ISeq" stack nil)
        (§ field #_"boolean" asc false)
        (§ field #_"int" cnt 0)
    )

    (§ constructor #_"TSeq" TSeq [#_"ISeq" ___stack, #_"boolean" ___asc]
        (let [this (ß super())]
            (§ ass (ß this.stack) ___stack)
            (§ ass (ß this.asc) ___asc)
            (§ ass (ß this.cnt) -1)
            this
        )
    )

    (§ constructor #_"TSeq" TSeq [#_"ISeq" ___stack, #_"boolean" ___asc, #_"int" ___cnt]
        (let [this (ß super())]
            (§ ass (ß this.stack) ___stack)
            (§ ass (ß this.asc) ___asc)
            (§ ass (ß this.cnt) ___cnt)
            this
        )
    )

    (§ constructor #_"TSeq" TSeq [#_"IPersistentMap" ___meta, #_"ISeq" ___stack, #_"boolean" ___asc, #_"int" ___cnt]
        (let [this (ß super(___meta))]
            (§ ass (ß this.stack) ___stack)
            (§ ass (ß this.asc) ___asc)
            (§ ass (ß this.cnt) ___cnt)
            this
        )
    )

    (§ defn #_"TSeq" TSeq'create [#_"TNode" ___t, #_"boolean" ___asc, #_"int" ___cnt]
        (ß new TSeq(TSeq'push(___t, nil, ___asc), ___asc, ___cnt))
    )

    (§ defn #_"ISeq" TSeq'push [#_"TNode" ___t, #_"ISeq" ___stack, #_"boolean" ___asc]
        (while (some? ___t)
            (§ ass ___stack (ß RT'cons(___t, ___stack)))
            (§ ass ___t (ß ___asc ? ___t.left() :or ___t.right()))
        )
        stack
    )

    #_method
    (§ defn #_"Object" first [#_"TSeq" this]
        (ß stack.first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"TSeq" this]
        (let [#_"TNode" ___t (ß (TNode) stack.first())]
            (let [#_"ISeq" ___nextstack (ß TSeq'push(asc ? ___t.right() :or ___t.left(), stack.next(), asc))]
                (when (some? ___nextstack)
                    (§ return (ß new TSeq(___nextstack, asc, cnt - 1)))
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" count [#_"TSeq" this]
        (when (ß cnt < 0)
            (§ return (ß super.count()))
        )
        cnt
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"TSeq" this, #_"IPersistentMap" ___meta]
        (ß new TSeq(___meta, stack, asc, cnt))
    )
)

(class-ns NodeIterator (§ implements Iterator)
    (§ init
        (§ field #_"Stack" stack (Stack.))
        (§ field #_"boolean" asc false)
    )

    (§ constructor #_"NodeIterator" NodeIterator [#_"TNode" ___t, #_"boolean" ___asc]
        (let [this (ß super())]
            (§ ass (ß this.asc) ___asc)
            (ß push(___t))
            this
        )
    )

    #_method
    (§ defn #_"void" push [#_"NodeIterator" this, #_"TNode" ___t]
        (while (some? ___t)
            (ß stack.push(___t))
            (§ ass ___t (ß asc ? ___t.left() :or ___t.right()))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"NodeIterator" this]
        (ß !stack.isEmpty())
    )

    #_method
    (§ defn #_"Object" next [#_"NodeIterator" this]
        (try
            (let [#_"TNode" ___t (ß (TNode) stack.pop())]
                (ß push(asc ? ___t.right() :or ___t.left()))
                t
            )
            (catch EmptyStackException ___e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"NodeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns KeyIterator (§ implements Iterator)
    (§ init
        (§ field #_"NodeIterator" it nil)
    )

    (§ constructor #_"KeyIterator" KeyIterator [#_"NodeIterator" ___it]
        (let [this (ß super())]
            (§ ass (ß this.it) ___it)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"KeyIterator" this]
        (ß it.hasNext())
    )

    #_method
    (§ defn #_"Object" next [#_"KeyIterator" this]
        (ß ((TNode) it.next()).key)
    )

    #_method
    (§ defn #_"void" remove [#_"KeyIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ValIterator (§ implements Iterator)
    (§ init
        (§ field #_"NodeIterator" it nil)
    )

    (§ constructor #_"ValIterator" ValIterator [#_"NodeIterator" ___it]
        (let [this (ß super())]
            (§ ass (ß this.it) ___it)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ValIterator" this]
        (ß it.hasNext())
    )

    #_method
    (§ defn #_"Object" next [#_"ValIterator" this]
        (ß ((TNode) it.next()).val())
    )

    #_method
    (§ defn #_"void" remove [#_"ValIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ def #_"PersistentTreeMap" PersistentTreeMap'EMPTY (PersistentTreeMap.))

    (§ defn #_"IPersistentMap" PersistentTreeMap'create [#_"Map" ___other]
        (let [#_"IPersistentMap" ___ret EMPTY]
            (doseq [#_"Object" ___o (ß ___other.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            ret
        )
    )

    (§ init
        (§ field #_"Comparator" comp nil)
        (§ field #_"TNode" tree nil)
        (§ field #_"int" _count 0)
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap []
        (let [this (ß this(RT'DEFAULT_COMPARATOR))]
            this
        )
    )

    (§ constructor- #_"PersistentTreeMap" PersistentTreeMap [#_"Comparator" ___comp]
        (let [this (ß this(nil, ___comp))]
            this
        )
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"IPersistentMap" ___meta, #_"Comparator" ___comp]
        (let [this (ß super())]
            (§ ass (ß this.comp) ___comp)
            (§ ass (ß this._meta) ___meta)
            (§ ass tree nil)
            (§ ass _count 0)
            this
        )
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"IPersistentMap" ___meta, #_"Comparator" ___comp, #_"TNode" ___tree, #_"int" ____count]
        (let [this (ß super())]
            (§ ass (ß this._meta) ___meta)
            (§ ass (ß this.comp) ___comp)
            (§ ass (ß this.tree) ___tree)
            (§ ass (ß this._count) ____count)
            this
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" withMeta [#_"PersistentTreeMap" this, #_"IPersistentMap" ___meta]
        (ß new PersistentTreeMap(___meta, comp, tree, _count))
    )

    (§ defn #_"PersistentTreeMap" PersistentTreeMap'create [#_"ISeq" ___items]
        (let [#_"IPersistentMap" ___ret EMPTY]
            (loop-when-recur [(ß )] (some? ___items) [(§ ass ___items (ß ___items.next().next()))]
                (when (ß ___items.next() == nil)
                    (throw (ß new IllegalArgumentException(String/format("No value supplied for key: %s", ___items.first()))))
                )
                (§ ass ___ret (ß ___ret.assoc(___items.first(), RT'second(___items))))
            )
            (ß (PersistentTreeMap) ___ret)
        )
    )

    (§ defn #_"PersistentTreeMap" PersistentTreeMap'create [#_"Comparator" ___comp, #_"ISeq" ___items]
        (let [#_"IPersistentMap" ___ret (PersistentTreeMap. ___comp)]
            (loop-when-recur [(ß )] (some? ___items) [(§ ass ___items (ß ___items.next().next()))]
                (when (ß ___items.next() == nil)
                    (throw (ß new IllegalArgumentException(String/format("No value supplied for key: %s", ___items.first()))))
                )
                (§ ass ___ret (ß ___ret.assoc(___items.first(), RT'second(___items))))
            )
            (ß (PersistentTreeMap) ___ret)
        )
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentTreeMap" this, #_"Object" ___key]
        (ß (entryAt(___key) != nil))
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentTreeMap" this, #_"Object" ___obj]
        (try
            (ß super.equals(___obj))
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentTreeMap" this, #_"Object" ___obj]
        (try
            (ß super.equiv(___obj))
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" assocEx [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"Box" ___found (Box. nil)]
            (let [#_"TNode" ___t (ß add(tree, ___key, ___val, ___found))]
                (when (nil? ___t) ;; nil == already contains key
                    (throw (ß Util'runtimeException("Key already present")))
                )
                (ß new PersistentTreeMap(comp, ___t.blacken(), _count + 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" assoc [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"Box" ___found (Box. nil)]
            (let [#_"TNode" ___t (ß add(tree, ___key, ___val, ___found))]
                (when (nil? ___t) ;; nil == already contains key
                    (let [#_"TNode" ___foundNode (ß (TNode) ___found.val)]
                        (when (ß ___foundNode.val() == ___val) ;; note only get same collection on identity of val, not equals()
                            (§ return this)
                        )
                        (§ return (ß new PersistentTreeMap(comp, replace(tree, ___key, ___val), _count, meta())))
                    )
                )
                (ß new PersistentTreeMap(comp, ___t.blacken(), _count + 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" without [#_"PersistentTreeMap" this, #_"Object" ___key]
        (let [#_"Box" ___found (Box. nil)]
            (let [#_"TNode" ___t (ß remove(tree, ___key, ___found))]
                (when (nil? ___t)
                    (when (ß ___found.val == nil) ;; nil == doesn't contain key
                        (§ return this)
                    )
                    ;; empty
                    (§ return (ß new PersistentTreeMap(meta(), comp)))
                )
                (ß new PersistentTreeMap(comp, ___t.blacken(), _count - 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeMap" this]
        (when (ß _count > 0)
            (§ return (ß TSeq'create(tree, true, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentTreeMap" this]
        (ß new PersistentTreeMap(meta(), comp))
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"PersistentTreeMap" this]
        (when (ß _count > 0)
            (§ return (ß TSeq'create(tree, false, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"Comparator" comparator [#_"PersistentTreeMap" this]
        comp
    )

    #_method
    (§ defn #_"Object" entryKey [#_"PersistentTreeMap" this, #_"Object" ___entry]
        (ß ((IMapEntry) ___entry).key())
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeMap" this, #_"boolean" ___ascending]
        (when (ß _count > 0)
            (§ return (ß TSeq'create(tree, ___ascending, _count)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" seqFrom [#_"PersistentTreeMap" this, #_"Object" ___key, #_"boolean" ___ascending]
        (when (ß _count > 0)
            (let [#_"ISeq" ___stack nil]
                (let [#_"TNode" ___t tree]
                    (while (some? ___t)
                        (let [#_"int" ___c (ß doCompare(___key, ___t.key))]
                            (cond (ß ___c == 0)
                                (do
                                    (§ ass ___stack (ß RT'cons(___t, ___stack)))
                                    (§ return (ß new TSeq(___stack, ___ascending)))
                                )
                                ___ascending
                                (do
                                    (if (ß ___c < 0)
                                        (do
                                            (§ ass ___stack (ß RT'cons(___t, ___stack)))
                                            (§ ass ___t (ß ___t.left()))
                                        )
                                        (do
                                            (§ ass ___t (ß ___t.right()))
                                        )
                                    )
                                )
                                :else
                                (do
                                    (if (ß ___c > 0)
                                        (do
                                            (§ ass ___stack (ß RT'cons(___t, ___stack)))
                                            (§ ass ___t (ß ___t.right()))
                                        )
                                        (do
                                            (§ ass ___t (ß ___t.left()))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when (some? ___stack)
                        (§ return (ß new TSeq(___stack, ___ascending)))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"NodeIterator" iterator [#_"PersistentTreeMap" this]
        (ß new NodeIterator(tree, true))
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentTreeMap" this, #_"IFn" ___f, #_"Object" ___init]
        (when (some? tree)
            (§ ass ___init (ß tree.kvreduce(___f, ___init)))
        )
        (when (ß RT'isReduced(___init))
            (§ ass ___init (ß ((IDeref)___init).deref()))
        )
        init
    )

    #_method
    (§ defn #_"NodeIterator" reverseIterator [#_"PersistentTreeMap" this]
        (ß new NodeIterator(tree, false))
    )

    #_method
    (§ defn #_"Iterator" keys [#_"PersistentTreeMap" this]
        (ß keys(iterator()))
    )

    #_method
    (§ defn #_"Iterator" vals [#_"PersistentTreeMap" this]
        (ß vals(iterator()))
    )

    #_method
    (§ defn #_"Iterator" keys [#_"PersistentTreeMap" this, #_"NodeIterator" ___it]
        (KeyIterator. ___it)
    )

    #_method
    (§ defn #_"Iterator" vals [#_"PersistentTreeMap" this, #_"NodeIterator" ___it]
        (ValIterator. ___it)
    )

    #_method
    (§ defn #_"Object" minKey [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (ß min())]
            (ß (___t != nil) ? ___t.key :or nil)
        )
    )

    #_method
    (§ defn #_"TNode" min [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t tree]
            (when (some? ___t)
                (while (ß ___t.left() != nil)
                    (§ ass ___t (ß ___t.left()))
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"Object" maxKey [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (ß max())]
            (ß (___t != nil) ? ___t.key :or nil)
        )
    )

    #_method
    (§ defn #_"TNode" max [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t tree]
            (when (some? ___t)
                (while (ß ___t.right() != nil)
                    (§ ass ___t (ß ___t.right()))
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"int" depth [#_"PersistentTreeMap" this]
        (ß depth(tree))
    )

    #_method
    (§ defn #_"int" depth [#_"PersistentTreeMap" this, #_"TNode" ___t]
        (when (nil? ___t)
            (§ return 0)
        )
        (ß 1 + Math/max(depth(___t.left()), depth(___t.right())))
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"TNode" ___n (ß entryAt(___key))]
            (ß (___n != nil) ? ___n.val() :or ___notFound)
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentTreeMap" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"int" capacity [#_"PersistentTreeMap" this]
        _count
    )

    #_method
    (§ defn #_"int" count [#_"PersistentTreeMap" this]
        _count
    )

    #_method
    (§ defn #_"TNode" entryAt [#_"PersistentTreeMap" this, #_"Object" ___key]
        (let [#_"TNode" ___t tree]
            (while (some? ___t)
                (let [#_"int" ___c (ß doCompare(___key, ___t.key))]
                    (cond (ß ___c == 0)
                        (do
                            (§ return ___t)
                        )
                        (ß ___c < 0)
                        (do
                            (§ ass ___t (ß ___t.left()))
                        )
                        :else
                        (do
                            (§ ass ___t (ß ___t.right()))
                        )
                    )
                )
            )
            t
        )
    )

    #_method
    (§ defn #_"int" doCompare [#_"PersistentTreeMap" this, #_"Object" ___k1, #_"Object" ___k2]
        (ß comp.compare(___k1, ___k2))
    )

    #_method
    (§ defn #_"TNode" add [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Object" ___val, #_"Box" ___found]
        (when (nil? ___t)
            (when (nil? ___val)
                (§ return (Red. ___key))
            )
            (§ return (ß new RedVal(___key, ___val)))
        )
        (let [#_"int" ___c (ß doCompare(___key, ___t.key))]
            (when (ß ___c == 0)
                (§ ass (ß ___found.val) ___t)
                (§ return nil)
            )
            (let [#_"TNode" ___ins (ß (___c < 0) ? add(___t.left(), ___key, ___val, ___found) :or add(___t.right(), ___key, ___val, ___found))]
                (when (nil? ___ins) ;; found below
                    (§ return nil)
                )
                (when (ß ___c < 0)
                    (§ return (ß ___t.addLeft(___ins)))
                )
                (ß ___t.addRight(___ins))
            )
        )
    )

    #_method
    (§ defn #_"TNode" remove [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Box" ___found]
        (when (nil? ___t)
            (§ return nil) ;; not found indicator
        )
        (let [#_"int" ___c (ß doCompare(___key, ___t.key))]
            (when (ß ___c == 0)
                (§ ass (ß ___found.val) ___t)
                (§ return (ß append(___t.left(), ___t.right())))
            )
            (let [#_"TNode" ___del (ß (___c < 0) ? remove(___t.left(), ___key, ___found) :or remove(___t.right(), ___key, ___found))]
                (when (ß ___del == nil && ___found.val == nil) ;; not found below
                    (§ return nil)
                )
                (when (ß ___c < 0)
                    (if (ß ___t.left() instanceof Black)
                        (do
                            (§ return (ß balanceLeftDel(___t.key, ___t.val(), ___del, ___t.right())))
                        )
                        (do
                            (§ return (ß red(___t.key, ___t.val(), ___del, ___t.right())))
                        )
                    )
                )
                (when (ß ___t.right() instanceof Black)
                    (§ return (ß balanceRightDel(___t.key, ___t.val(), ___t.left(), ___del)))
                )
                (ß red(___t.key, ___t.val(), ___t.left(), ___del))
            )
        )
    )

    (§ defn #_"TNode" PersistentTreeMap'append [#_"TNode" ___left, #_"TNode" ___right]
        (cond (nil? ___left)
            (do
                ___right
            )
            (nil? ___right)
            (do
                ___left
            )
            (ß ___left instanceof Red)
            (do
                (if (ß ___right instanceof Red)
                    (do
                        (let [#_"TNode" ___app (ß append(___left.right(), ___right.left()))]
                            (if (ß ___app instanceof Red)
                                (do
                                    (ß red(___app.key, ___app.val(), red(___left.key, ___left.val(), ___left.left(), ___app.left()), red(___right.key, ___right.val(), ___app.right(), ___right.right())))
                                )
                                (do
                                    (ß red(___left.key, ___left.val(), ___left.left(), red(___right.key, ___right.val(), ___app, ___right.right())))
                                )
                            )
                        )
                    )
                    (do
                        (ß red(___left.key, ___left.val(), ___left.left(), append(___left.right(), ___right)))
                    )
                )
            )
            (ß ___right instanceof Red)
            (do
                (ß red(___right.key, ___right.val(), append(___left, ___right.left()), ___right.right()))
            )
            :else ;; black/black
            (do
                (let [#_"TNode" ___app (ß append(___left.right(), ___right.left()))]
                    (if (ß ___app instanceof Red)
                        (do
                            (ß red(___app.key, ___app.val(), PersistentTreeMap'black(___left.key, ___left.val(), ___left.left(), ___app.left()), PersistentTreeMap'black(___right.key, ___right.val(), ___app.right(), ___right.right())))
                        )
                        (do
                            (ß balanceLeftDel(___left.key, ___left.val(), ___left.left(), PersistentTreeMap'black(___right.key, ___right.val(), ___app, ___right.right())))
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"TNode" PersistentTreeMap'balanceLeftDel [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___del, #_"TNode" ___right]
        (cond (ß ___del instanceof Red)
            (do
                (ß red(___key, ___val, ___del.blacken(), ___right))
            )
            (ß ___right instanceof Black)
            (do
                (ß rightBalance(___key, ___val, ___del, ___right.redden()))
            )
            (ß ___right instanceof Red && ___right.left() instanceof Black)
            (do
                (ß red(___right.left().key, ___right.left().val(), PersistentTreeMap'black(___key, ___val, ___del, ___right.left().left()), rightBalance(___right.key, ___right.val(), ___right.left().right(), ___right.right().redden())))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (§ defn #_"TNode" PersistentTreeMap'balanceRightDel [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___del]
        (cond (ß ___del instanceof Red)
            (do
                (ß red(___key, ___val, ___left, ___del.blacken()))
            )
            (ß ___left instanceof Black)
            (do
                (ß leftBalance(___key, ___val, ___left.redden(), ___del))
            )
            (ß ___left instanceof Red && ___left.right() instanceof Black)
            (do
                (ß red(___left.right().key, ___left.right().val(), leftBalance(___left.key, ___left.val(), ___left.left().redden(), ___left.right().left()), PersistentTreeMap'black(___key, ___val, ___left.right().right(), ___del)))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (§ defn #_"TNode" PersistentTreeMap'leftBalance [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___ins, #_"TNode" ___right]
        (cond (ß ___ins instanceof Red && ___ins.left() instanceof Red)
            (do
                (ß red(___ins.key, ___ins.val(), ___ins.left().blacken(), PersistentTreeMap'black(___key, ___val, ___ins.right(), ___right)))
            )
            (ß ___ins instanceof Red && ___ins.right() instanceof Red)
            (do
                (ß red(___ins.right().key, ___ins.right().val(), PersistentTreeMap'black(___ins.key, ___ins.val(), ___ins.left(), ___ins.right().left()), PersistentTreeMap'black(___key, ___val, ___ins.right().right(), ___right)))
            )
            :else
            (do
                (ß PersistentTreeMap'black(___key, ___val, ___ins, ___right))
            )
        )
    )

    (§ defn #_"TNode" PersistentTreeMap'rightBalance [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___ins]
        (cond (ß ___ins instanceof Red && ___ins.right() instanceof Red)
            (do
                (ß red(___ins.key, ___ins.val(), PersistentTreeMap'black(___key, ___val, ___left, ___ins.left()), ___ins.right().blacken()))
            )
            (ß ___ins instanceof Red && ___ins.left() instanceof Red)
            (do
                (ß red(___ins.left().key, ___ins.left().val(), PersistentTreeMap'black(___key, ___val, ___left, ___ins.left().left()), PersistentTreeMap'black(___ins.key, ___ins.val(), ___ins.left().right(), ___ins.right())))
            )
            :else
            (do
                (ß PersistentTreeMap'black(___key, ___val, ___left, ___ins))
            )
        )
    )

    #_method
    (§ defn #_"TNode" replace [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___c (ß doCompare(___key, ___t.key))]
            (ß ___t.replace(___t.key, (___c == 0) ? ___val :or ___t.val(), (___c < 0) ? replace(___t.left(), ___key, ___val) :or ___t.left(), (___c > 0) ? replace(___t.right(), ___key, ___val) :or ___t.right()))
        )
    )

    (§ constructor #_"PersistentTreeMap" PersistentTreeMap [#_"Comparator" ___comp, #_"TNode" ___tree, #_"int" ___count, #_"IPersistentMap" ___meta]
        (let [this (ß super())]
            (§ ass (ß this._meta) ___meta)
            (§ ass (ß this.comp) ___comp)
            (§ ass (ß this.tree) ___tree)
            (§ ass (ß this._count) ___count)
            this
        )
    )

    (§ defn #_"Red" PersistentTreeMap'red [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (when (ß ___left == nil && ___right == nil)
            (when (nil? ___val)
                (§ return (Red. ___key))
            )
            (§ return (ß new RedVal(___key, ___val)))
        )
        (when (nil? ___val)
            (§ return (ß new RedBranch(___key, ___left, ___right)))
        )
        (ß new RedBranchVal(___key, ___val, ___left, ___right))
    )

    (§ defn #_"Black" PersistentTreeMap'black [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (when (ß ___left == nil && ___right == nil)
            (when (nil? ___val)
                (§ return (Black. ___key))
            )
            (§ return (ß new BlackVal(___key, ___val)))
        )
        (when (nil? ___val)
            (§ return (ß new BlackBranch(___key, ___left, ___right)))
        )
        (ß new BlackBranchVal(___key, ___val, ___left, ___right))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentTreeMap" this]
        _meta
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def #_"PersistentTreeSet" PersistentTreeSet'EMPTY (ß new PersistentTreeSet(nil, PersistentTreeMap'EMPTY)))

    (§ defn #_"PersistentTreeSet" PersistentTreeSet'create [#_"ISeq" ___items]
        (let [#_"PersistentTreeSet" ___ret EMPTY]
            (loop-when-recur [(ß )] (some? ___items) [(§ ass ___items (ß ___items.next()))]
                (§ ass ___ret (ß (PersistentTreeSet) ___ret.cons(___items.first())))
            )
            ret
        )
    )

    (§ defn #_"PersistentTreeSet" PersistentTreeSet'create [#_"Comparator" ___comp, #_"ISeq" ___items]
        (let [#_"PersistentTreeSet" ___ret (ß new PersistentTreeSet(nil, new PersistentTreeMap(nil, ___comp)))]
            (loop-when-recur [(ß )] (some? ___items) [(§ ass ___items (ß ___items.next()))]
                (§ ass ___ret (ß (PersistentTreeSet) ___ret.cons(___items.first())))
            )
            ret
        )
    )

    (§ init
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentTreeSet" PersistentTreeSet [#_"IPersistentMap" ___meta, #_"IPersistentMap" ___impl]
        (let [this (ß super(___impl))]
            (§ ass (ß this._meta) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentTreeSet" this, #_"Object" ___obj]
        (try
            (ß super.equals(___obj))
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentTreeSet" this, #_"Object" ___obj]
        (try
            (ß super.equiv(___obj))
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"IPersistentSet" disjoin [#_"PersistentTreeSet" this, #_"Object" ___key]
        (when (ß contains(___key))
            (§ return (ß new PersistentTreeSet(meta(), impl.without(___key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" cons [#_"PersistentTreeSet" this, #_"Object" ___o]
        (when (ß contains(___o))
            (§ return this)
        )
        (ß new PersistentTreeSet(meta(), impl.assoc(___o, ___o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentTreeSet" this]
        (ß new PersistentTreeSet(meta(), (PersistentTreeMap)impl.empty()))
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"PersistentTreeSet" this]
        (ß KeySeq'create(((Reversible) impl).rseq()))
    )

    #_method
    (§ defn #_"PersistentTreeSet" withMeta [#_"PersistentTreeSet" this, #_"IPersistentMap" ___meta]
        (ß new PersistentTreeSet(___meta, impl))
    )

    #_method
    (§ defn #_"Comparator" comparator [#_"PersistentTreeSet" this]
        (ß ((Sorted)impl).comparator())
    )

    #_method
    (§ defn #_"Object" entryKey [#_"PersistentTreeSet" this, #_"Object" ___entry]
        entry
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeSet" this, #_"boolean" ___ascending]
        (let [#_"PersistentTreeMap" ___m (ß (PersistentTreeMap) impl)]
            (ß RT'keys(___m.seq(___ascending)))
        )
    )

    #_method
    (§ defn #_"ISeq" seqFrom [#_"PersistentTreeSet" this, #_"Object" ___key, #_"boolean" ___ascending]
        (let [#_"PersistentTreeMap" ___m (ß (PersistentTreeMap) impl)]
            (ß RT'keys(___m.seqFrom(___key, ___ascending)))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentTreeSet" this]
        _meta
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns VNode
    (§ init
        #_transient
        (§ field #_"AtomicReference<Thread>" edit nil)
        (§ field #_"Object[]" array nil)
    )

    (§ constructor #_"VNode" VNode [#_"AtomicReference<Thread>" ___edit, #_"Object[]" ___array]
        (let [this (ß super())]
            (§ ass (ß this.edit) ___edit)
            (§ ass (ß this.array) ___array)
            this
        )
    )

    (§ constructor #_"VNode" VNode [#_"AtomicReference<Thread>" ___edit]
        (let [this (ß super())]
            (§ ass (ß this.edit) ___edit)
            (§ ass (ß this.array) (ß new Object[32]))
            this
        )
    )
)

(class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
    (§ init
        (§ field #_"PersistentVector" vec nil)
        (§ field #_"Object[]" node nil)
        (§ field #_"int" i 0)
        (§ field #_"int" offset 0)
    )

    (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"PersistentVector" ___vec, #_"int" ___i, #_"int" ___offset]
        (let [this (ß super())]
            (§ ass (ß this.vec) ___vec)
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.offset) ___offset)
            (§ ass (ß this.node) (ß ___vec.arrayFor(___i)))
            this
        )
    )

    (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"IPersistentMap" ___meta, #_"PersistentVector" ___vec, #_"Object[]" ___node, #_"int" ___i, #_"int" ___offset]
        (let [this (ß super(___meta))]
            (§ ass (ß this.vec) ___vec)
            (§ ass (ß this.node) ___node)
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.offset) ___offset)
            this
        )
    )

    (§ constructor #_"ChunkedSeq" ChunkedSeq [#_"PersistentVector" ___vec, #_"Object[]" ___node, #_"int" ___i, #_"int" ___offset]
        (let [this (ß super())]
            (§ ass (ß this.vec) ___vec)
            (§ ass (ß this.node) ___node)
            (§ ass (ß this.i) ___i)
            (§ ass (ß this.offset) ___offset)
            this
        )
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"ChunkedSeq" this]
        (ß new ArrayChunk(node, offset))
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"ChunkedSeq" this]
        (when (ß i + node.length < vec.cnt)
            (§ return (ß new ChunkedSeq(vec, i + node.length, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"ChunkedSeq" this]
        (let [#_"ISeq" ___s (ß chunkedNext())]
            (when (nil? ___s)
                (§ return (ß PersistentList'EMPTY))
            )
            s
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"ChunkedSeq" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == this._meta)
            (§ return this)
        )
        (ß new ChunkedSeq(___meta, vec, node, i, offset))
    )

    #_method
    (§ defn #_"Object" first [#_"ChunkedSeq" this]
        (ß node[offset])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ChunkedSeq" this]
        (when (ß offset + 1 < node.length)
            (§ return (ß new ChunkedSeq(vec, node, i, offset + 1)))
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"int" count [#_"ChunkedSeq" this]
        (ß vec.cnt - (i + offset))
    )
)

(class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
    (§ init
        #_volatile
        (§ field #_"int" cnt 0)
        #_volatile
        (§ field #_"int" shift 0)
        #_volatile
        (§ field #_"VNode" root nil)
        #_volatile
        (§ field #_"Object[]" tail nil)
    )

    (§ constructor #_"TransientVector" TransientVector [#_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (ß super())]
            (§ ass (ß this.cnt) ___cnt)
            (§ ass (ß this.shift) ___shift)
            (§ ass (ß this.root) ___root)
            (§ ass (ß this.tail) ___tail)
            this
        )
    )

    (§ constructor #_"TransientVector" TransientVector [#_"PersistentVector" ___v]
        (let [this (ß this(___v.cnt, ___v.shift, editableRoot(___v.root), editableTail(___v.tail)))]
            this
        )
    )

    #_method
    (§ defn #_"int" count [#_"TransientVector" this]
        (ß ensureEditable())
        cnt
    )

    #_method
    (§ defn #_"VNode" ensureEditable [#_"TransientVector" this, #_"VNode" ___node]
        (when (ß ___node.edit == root.edit)
            (§ return ___node)
        )
        (ß new VNode(root.edit, ___node.array.clone()))
    )

    #_method
    (§ defn #_"void" ensureEditable [#_"TransientVector" this]
        (when (ß root.edit.get() == nil)
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )

    (§ defn #_"VNode" TransientVector'editableRoot [#_"VNode" ___node]
        (ß new VNode(new AtomicReference<Thread>(Thread/currentThread()), ___node.array.clone()))
    )

    #_method
    (§ defn #_"PersistentVector" persistent [#_"TransientVector" this]
        (ß ensureEditable())
        (ß root.edit.set(nil))
        (let [#_"Object[]" ___trimmedTail (ß new Object[cnt - tailoff()])]
            (ß System/arraycopy(tail, 0, ___trimmedTail, 0, ___trimmedTail.length))
            (ß new PersistentVector(cnt, shift, root, ___trimmedTail))
        )
    )

    (§ defn #_"Object[]" TransientVector'editableTail [#_"Object[]" ___tl]
        (let [#_"Object[]" ___ret (ß new Object[32])]
            (ß System/arraycopy(___tl, 0, ___ret, 0, ___tl.length))
            ret
        )
    )

    #_method
    (§ defn #_"TransientVector" conj [#_"TransientVector" this, #_"Object" ___val]
        (ß ensureEditable())
        (let [#_"int" ___i cnt]
            ;; room in tail?
            (when (ß ___i - tailoff() < 32)
                (§ ass (ß tail[___i & 0x01f]) ___val)
                (§ ass cnt (ß cnt + 1))
                (§ return this)
            )
            ;; full tail, push into tree
            (§ let [#_"VNode" ___newroot]
                (let [#_"VNode" ___tailnode (ß new VNode(root.edit, tail))]
                    (§ ass tail (ß new Object[32]))
                    (§ ass (ß tail[0]) ___val)
                    (let [#_"int" ___newshift shift]
                        ;; overflow root?
                        (if (ß (cnt >>> 5) > (1 << shift))
                            (do
                                (§ ass ___newroot (VNode. (ß root.edit)))
                                (§ ass (ß ___newroot.array[0]) root)
                                (§ ass (ß ___newroot.array[1]) (ß newPath(root.edit, shift, ___tailnode)))
                                (§ ass ___newshift (ß ___newshift + 5))
                            )
                            (do
                                (§ ass ___newroot (ß pushTail(shift, root, ___tailnode)))
                            )
                        )
                        (§ ass root ___newroot)
                        (§ ass shift ___newshift)
                        (§ ass cnt (ß cnt + 1))
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" pushTail [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___parent, #_"VNode" ___tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in parent
        (§ ass ___parent (ß ensureEditable(___parent)))
        (let [#_"int" ___subidx (ß ((cnt - 1) >>> ___level) & 0x01f)]
            (let [#_"VNode" ___ret ___parent]
                (§ let [#_"VNode" ___nodeToInsert]
                    (if (ß ___level == 5)
                        (do
                            (§ ass ___nodeToInsert ___tailnode)
                        )
                        (do
                            (let [#_"VNode" ___child (ß (VNode) ___parent.array[___subidx])]
                                (§ ass ___nodeToInsert (ß (___child != nil) ? pushTail(___level - 5, ___child, ___tailnode) :or newPath(root.edit, ___level - 5, ___tailnode)))
                            )
                        )
                    )
                    (§ ass (ß ___ret.array[___subidx]) ___nodeToInsert)
                    ___ret
                )
            )
        )
    )

    #_method
    (§ defn- #_"int" tailoff [#_"TransientVector" this]
        (when (ß cnt < 32)
            (§ return 0)
        )
        (ß ((cnt - 1) >>> 5) << 5)
    )

    #_method
    (§ defn- #_"Object[]" arrayFor [#_"TransientVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < cnt)
            (when (ß ___i >= tailoff())
                (§ return tail)
            )
            (let [#_"VNode" ___node root]
                (loop-when-recur [(§ var #_"int" ___level shift)] (ß ___level > 0) [(§ ass ___level (ß ___level - 5))]
                    (§ ass ___node (ß (VNode) ___node.array[(___i >>> ___level) & 0x01f]))
                )
                (§ return (ß ___node.array))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn- #_"Object[]" editableArrayFor [#_"TransientVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < cnt)
            (when (ß ___i >= tailoff())
                (§ return tail)
            )
            (let [#_"VNode" ___node root]
                (loop-when-recur [(§ var #_"int" ___level shift)] (ß ___level > 0) [(§ ass ___level (ß ___level - 5))]
                    (§ ass ___node (ß ensureEditable((VNode) ___node.array[(___i >>> ___level) & 0x01f])))
                )
                (§ return (ß ___node.array))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" valAt [#_"TransientVector" this, #_"Object" ___key]
        ;; note - relies on ensureEditable in 2-arg valAt
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [#_"TransientVector" this, #_"Object" ___key, #_"Object" ___notFound]
        (ß ensureEditable())
        (when (ß Util'isInteger(___key))
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (when (ß ___i >= 0 && ___i < cnt)
                    (§ return (ß nth(___i)))
                )
            )
        )
        notFound
    )

    (§ def- #_"Object" TransientVector'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" containsKey [#_"TransientVector" this, #_"Object" ___key]
        (ß (valAt(___key, TransientVector'NOT_FOUND) != TransientVector'NOT_FOUND))
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"TransientVector" this, #_"Object" ___key]
        (let [#_"Object" ___v (ß valAt(___key, TransientVector'NOT_FOUND))]
            (when (ß ___v != TransientVector'NOT_FOUND)
                (§ return (ß MapEntry'create(___key, ___v)))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"TransientVector" this, #_"Object" ___arg1]
        ;; note - relies on ensureEditable in nth
        (when (ß Util'isInteger(___arg1))
            (§ return (ß nth(((Number) ___arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" nth [#_"TransientVector" this, #_"int" ___i]
        (ß ensureEditable())
        (let [#_"Object[]" ___node (ß arrayFor(___i))]
            (ß ___node[___i & 0x01f])
        )
    )

    #_method
    (§ defn #_"Object" nth [#_"TransientVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < count())
            (§ return (ß nth(___i)))
        )
        notFound
    )

    #_method
    (§ defn #_"TransientVector" assocN [#_"TransientVector" this, #_"int" ___i, #_"Object" ___val]
        (ß ensureEditable())
        (when (ß ___i >= 0 && ___i < cnt)
            (when (ß ___i >= tailoff())
                (§ ass (ß tail[___i & 0x01f]) ___val)
                (§ return this)
            )

            (§ ass root (ß doAssoc(shift, root, ___i, ___val)))
            (§ return this)
        )
        (when (ß ___i == cnt)
            (§ return (ß conj(___val)))
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"TransientVector" assoc [#_"TransientVector" this, #_"Object" ___key, #_"Object" ___val]
        ;; note - relies on ensureEditable in assocN
        (when (ß Util'isInteger(___key))
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (§ return (ß assocN(___i, ___val)))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn- #_"VNode" doAssoc [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___node, #_"int" ___i, #_"Object" ___val]
        (§ ass ___node (ß ensureEditable(___node)))
        (let [#_"VNode" ___ret ___node]
            (if (ß ___level == 0)
                (do
                    (§ ass (ß ___ret.array[___i & 0x01f]) ___val)
                )
                (do
                    (let [#_"int" ___subidx (ß (___i >>> ___level) & 0x01f)]
                        (§ ass (ß ___ret.array[___subidx]) (ß doAssoc(___level - 5, (VNode) ___node.array[___subidx], ___i, ___val)))
                    )
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"TransientVector" pop [#_"TransientVector" this]
        (ß ensureEditable())
        (when (ß cnt == 0)
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß cnt == 1)
            (§ ass cnt 0)
            (§ return this)
        )
        (let [#_"int" ___i (ß cnt - 1)]
            ;; pop in tail?
            (when (ß (___i & 0x01f) > 0)
                (§ ass cnt (ß cnt - 1))
                (§ return this)
            )

            (let [#_"Object[]" ___newtail (ß editableArrayFor(cnt - 2))]
                (let [#_"VNode" ___newroot (ß popTail(shift, root))]
                    (let [#_"int" ___newshift shift]
                        (when (nil? ___newroot)
                            (§ ass ___newroot (VNode. (ß root.edit)))
                        )
                        (when (ß shift > 5 && ___newroot.array[1] == nil)
                            (§ ass ___newroot (ß ensureEditable((VNode) ___newroot.array[0])))
                            (§ ass ___newshift (ß ___newshift - 5))
                        )
                        (§ ass root ___newroot)
                        (§ ass shift ___newshift)
                        (§ ass cnt (ß cnt - 1))
                        (§ ass tail ___newtail)
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" popTail [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___node]
        (§ ass ___node (ß ensureEditable(___node)))
        (let [#_"int" ___subidx (ß ((cnt - 2) >>> ___level) & 0x01f)]
            (cond (ß ___level > 5)
                (do
                    (let [#_"VNode" ___newchild (ß popTail(___level - 5, (VNode) ___node.array[___subidx]))]
                        (if (ß ___newchild == nil && ___subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"VNode" ___ret ___node]
                                    (§ ass (ß ___ret.array[___subidx]) ___newchild)
                                    ret
                                )
                            )
                        )
                    )
                )
                (ß ___subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"VNode" ___ret ___node]
                        (§ ass (ß ___ret.array[___subidx]) nil)
                        ret
                    )
                )
            )
        )
    )
)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (§ def #_"AtomicReference<Thread>" PersistentVector'NOEDIT (ß new AtomicReference<Thread>(nil)))
    (§ def #_"VNode" PersistentVector'EMPTY_NODE (ß new VNode(NOEDIT, new Object[32])))

    (§ def #_"PersistentVector" PersistentVector'EMPTY (ß new PersistentVector(0, 5, EMPTY_NODE, new Object[] (§ array ))))

    (§ def- #_"IFn" PersistentVector'TRANSIENT_VECTOR_CONJ
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___coll, #_"Object" ___val]
                (ß ((ITransientVector)___coll).conj(___val))
            )
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___coll]
                coll
            )
        )
    )

    (§ defn #_"PersistentVector" PersistentVector'adopt [#_"Object[]" ___items]
        (ß new PersistentVector(___items.length, 5, EMPTY_NODE, ___items))
    )

    (§ defn #_"PersistentVector" PersistentVector'create [#_"IReduceInit" ___items]
        (let [#_"TransientVector" ___ret (ß EMPTY.asTransient())]
            (ß ___items.reduce(TRANSIENT_VECTOR_CONJ, ___ret))
            (ß ___ret.persistent())
        )
    )

    (§ defn #_"PersistentVector" PersistentVector'create [#_"ISeq" ___items]
        (let [#_"Object[]" ___arr (ß new Object[32])]
            (let [#_"int" ___i 0]
                (loop-when-recur [(ß )] (ß ___items != nil && ___i < 32) [(§ ass ___items (ß ___items.next()))]
                    (§ ass (ß ___arr[___i]) (ß ___items.first()))
                    (§ ass ___i (ß ___i + 1))
                )

                (cond (some? ___items) ;; >32, construct with array directly
                    (do
                        (let [#_"PersistentVector" ___start (ß new PersistentVector(32, 5, EMPTY_NODE, ___arr))]
                            (let [#_"TransientVector" ___ret (ß ___start.asTransient())]
                                (loop-when-recur [(ß )] (some? ___items) [(§ ass ___items (ß ___items.next()))]
                                    (§ ass ___ret (ß ___ret.conj(___items.first())))
                                )
                                (ß ___ret.persistent())
                            )
                        )
                    )
                    (ß ___i == 32) ;; exactly 32, skip copy
                    (do
                        (ß new PersistentVector(32, 5, EMPTY_NODE, ___arr))
                    )
                    :else ;; <32, copy to minimum array and construct
                    (do
                        (let [#_"Object[]" ___arr2 (ß new Object[___i])]
                            (ß System/arraycopy(___arr, 0, ___arr2, 0, ___i))
                            (ß new PersistentVector(___i, 5, EMPTY_NODE, ___arr2))
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"PersistentVector" PersistentVector'create [#_"List" ___list]
        (let [#_"int" ___size (ß ___list.size())]
            (when (ß ___size <= 32)
                (§ return (ß new PersistentVector(___size, 5, PersistentVector'EMPTY_NODE, ___list.toArray())))
            )

            (let [#_"TransientVector" ___ret (ß EMPTY.asTransient())]
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size) [(§ ass ___i (ß ___i + 1))]
                    (§ ass ___ret (ß ___ret.conj(___list.get(___i))))
                )
                (ß ___ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentVector" PersistentVector'create [#_"Iterable" ___items]
        ;; optimize common case
        (when (ß ___items instanceof ArrayList)
            (§ return (ß create((ArrayList)___items)))
        )

        (let [#_"Iterator" ___iter (ß ___items.iterator())]
            (let [#_"TransientVector" ___ret (ß EMPTY.asTransient())]
                (while (ß ___iter.hasNext())
                    (§ ass ___ret (ß ___ret.conj(___iter.next())))
                )
                (ß ___ret.persistent())
            )
        )
    )

    (§ defn #_"PersistentVector" PersistentVector'create [#_"Object..." ___items]
        (let [#_"TransientVector" ___ret (ß EMPTY.asTransient())]
            (doseq [#_"Object" ___item ___items]
                (§ ass ___ret (ß ___ret.conj(___item)))
            )
            (ß ___ret.persistent())
        )
    )

    (§ init
        (§ field #_"int" cnt 0)
        (§ field #_"int" shift 0)
        (§ field #_"VNode" root nil)
        (§ field #_"Object[]" tail nil)
        (§ field #_"IPersistentMap" _meta nil)
    )

    (§ constructor #_"PersistentVector" PersistentVector [#_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (ß super())]
            (§ ass (ß this._meta) nil)
            (§ ass (ß this.cnt) ___cnt)
            (§ ass (ß this.shift) ___shift)
            (§ ass (ß this.root) ___root)
            (§ ass (ß this.tail) ___tail)
            this
        )
    )

    (§ constructor #_"PersistentVector" PersistentVector [#_"IPersistentMap" ___meta, #_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (ß super())]
            (§ ass (ß this._meta) ___meta)
            (§ ass (ß this.cnt) ___cnt)
            (§ ass (ß this.shift) ___shift)
            (§ ass (ß this.root) ___root)
            (§ ass (ß this.tail) ___tail)
            this
        )
    )

    #_method
    (§ defn #_"TransientVector" asTransient [#_"PersistentVector" this]
        (TransientVector. this)
    )

    #_method
    (§ defn #_"int" tailoff [#_"PersistentVector" this]
        (when (ß cnt < 32)
            (§ return 0)
        )
        (ß ((cnt - 1) >>> 5) << 5)
    )

    #_method
    (§ defn #_"Object[]" arrayFor [#_"PersistentVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < cnt)
            (when (ß ___i >= tailoff())
                (§ return tail)
            )
            (let [#_"VNode" ___node root]
                (loop-when-recur [(§ var #_"int" ___level shift)] (ß ___level > 0) [(§ ass ___level (ß ___level - 5))]
                    (§ ass ___node (ß (VNode) ___node.array[(___i >>> ___level) & 0x01f]))
                )
                (§ return (ß ___node.array))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" nth [#_"PersistentVector" this, #_"int" ___i]
        (let [#_"Object[]" ___node (ß arrayFor(___i))]
            (ß ___node[___i & 0x01f])
        )
    )

    #_method
    (§ defn #_"Object" nth [#_"PersistentVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < cnt)
            (§ return (ß nth(___i)))
        )
        notFound
    )

    #_method
    (§ defn #_"PersistentVector" assocN [#_"PersistentVector" this, #_"int" ___i, #_"Object" ___val]
        (when (ß ___i >= 0 && ___i < cnt)
            (when (ß ___i >= tailoff())
                (let [#_"Object[]" ___newTail (ß new Object[tail.length])]
                    (ß System/arraycopy(tail, 0, ___newTail, 0, tail.length))
                    (§ ass (ß ___newTail[___i & 0x01f]) ___val)

                    (§ return (ß new PersistentVector(meta(), cnt, shift, root, ___newTail)))
                )
            )

            (§ return (ß new PersistentVector(meta(), cnt, shift, doAssoc(shift, root, ___i, ___val), tail)))
        )
        (when (ß ___i == cnt)
            (§ return (ß cons(___val)))
        )
        (throw (IndexOutOfBoundsException.))
    )

    (§ defn- #_"VNode" PersistentVector'doAssoc [#_"int" ___level, #_"VNode" ___node, #_"int" ___i, #_"Object" ___val]
        (let [#_"VNode" ___ret (ß new VNode(___node.edit, ___node.array.clone()))]
            (if (ß ___level == 0)
                (do
                    (§ ass (ß ___ret.array[___i & 0x01f]) ___val)
                )
                (do
                    (let [#_"int" ___subidx (ß (___i >>> ___level) & 0x01f)]
                        (§ ass (ß ___ret.array[___subidx]) (ß doAssoc(___level - 5, (VNode) ___node.array[___subidx], ___i, ___val)))
                    )
                )
            )
            ret
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentVector" this]
        cnt
    )

    #_method
    (§ defn #_"PersistentVector" withMeta [#_"PersistentVector" this, #_"IPersistentMap" ___meta]
        (ß new PersistentVector(___meta, cnt, shift, root, tail))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentVector" this]
        _meta
    )

    #_method
    (§ defn #_"PersistentVector" cons [#_"PersistentVector" this, #_"Object" ___val]
        ;; room in tail?
        (when (ß cnt - tailoff() < 32)
            (let [#_"Object[]" ___newTail (ß new Object[tail.length + 1])]
                (ß System/arraycopy(tail, 0, ___newTail, 0, tail.length))
                (§ ass (ß ___newTail[tail.length]) ___val)
                (§ return (ß new PersistentVector(meta(), cnt + 1, shift, root, ___newTail)))
            )
        )
        ;; full tail, push into tree
        (§ let [#_"VNode" ___newroot]
            (let [#_"VNode" ___tailnode (ß new VNode(root.edit, tail))]
                (let [#_"int" ___newshift shift]
                    ;; overflow root?
                    (if (ß (cnt >>> 5) > (1 << shift))
                        (do
                            (§ ass ___newroot (VNode. (ß root.edit)))
                            (§ ass (ß ___newroot.array[0]) root)
                            (§ ass (ß ___newroot.array[1]) (ß PersistentVector'newPath(root.edit, shift, ___tailnode)))
                            (§ ass ___newshift (ß ___newshift + 5))
                        )
                        (do
                            (§ ass ___newroot (ß pushTail(shift, root, ___tailnode)))
                        )
                    )
                    (ß new PersistentVector(meta(), cnt + 1, ___newshift, ___newroot, new Object[] (§ array ___val )))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" pushTail [#_"PersistentVector" this, #_"int" ___level, #_"VNode" ___parent, #_"VNode" ___tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" ___subidx (ß ((cnt - 1) >>> ___level) & 0x01f)]
            (let [#_"VNode" ___ret (ß new VNode(___parent.edit, ___parent.array.clone()))]
                (§ let [#_"VNode" ___nodeToInsert]
                    (if (ß ___level == 5)
                        (do
                            (§ ass ___nodeToInsert ___tailnode)
                        )
                        (do
                            (let [#_"VNode" ___child (ß (VNode) ___parent.array[___subidx])]
                                (§ ass ___nodeToInsert (ß (___child != nil) ? pushTail(___level - 5, ___child, ___tailnode) :or PersistentVector'newPath(root.edit, ___level - 5, ___tailnode)))
                            )
                        )
                    )
                    (§ ass (ß ___ret.array[___subidx]) ___nodeToInsert)
                    ___ret
                )
            )
        )
    )

    (§ defn- #_"VNode" PersistentVector'newPath [#_"AtomicReference<Thread>" ___edit, #_"int" ___level, #_"VNode" ___node]
        (when (ß ___level == 0)
            (§ return ___node)
        )
        (let [#_"VNode" ___ret (VNode. ___edit)]
            (§ ass (ß ___ret.array[0]) (ß PersistentVector'newPath(___edit, ___level - 5, ___node)))
            ret
        )
    )

    #_method
    (§ defn #_"IChunkedSeq" chunkedSeq [#_"PersistentVector" this]
        (when (ß count() == 0)
            (§ return nil)
        )
        (ß new ChunkedSeq(this, 0, 0))
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentVector" this]
        (ß chunkedSeq())
    )

    #_override
    #_method
    (§ defn #_"Iterator" rangedIterator [#_"PersistentVector" this, #_"int" ___start, #_"int" ___end]
        (§ reify Iterator()
            (§ init
                (§ field #_"int" i ___start)
                (§ field #_"int" base (ß i - (i%32)))
                (§ field #_"Object[]" array (ß (___start < count()) ? arrayFor(i) :or nil))
            )

            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (ß (i < ___end))
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (if (ß i < ___end)
                    (do
                        (when (ß i - base == 32)
                            (§ ass array (ß arrayFor(i)))
                            (§ ass base (ß base + 32))
                        )
                        (let [_ (ß array[i & 0x01f])]
                            (§ ass i (ß i + 1))
                            _
                        )
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentVector" this]
        (ß rangedIterator(0, count()))
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentVector" this, #_"IFn" ___f]
        (§ let [#_"Object" ___init]
            (if (ß cnt > 0)
                (do
                    (§ ass ___init (ß arrayFor(0)[0]))
                )
                (do
                    (§ return (ß ___f.invoke()))
                )
            )
            (let [#_"int" ___step 0]
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < cnt) [(§ ass ___i (ß ___i + ___step))]
                    (let [#_"Object[]" ___array (ß arrayFor(___i))]
                        (loop-when-recur [(§ var #_"int" ___j (ß (___i == 0) ? 1 :or 0))] (ß ___j < ___array.length) [(§ ass ___j (ß ___j + 1))]
                            (§ ass ___init (ß ___f.invoke(___init, ___array[___j])))
                            (when (ß RT'isReduced(___init))
                                (§ return (ß ((IDeref)___init).deref()))
                            )
                        )
                        (§ ass ___step (ß ___array.length))
                    )
                )
                ___init
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentVector" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"int" ___step 0]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < cnt) [(§ ass ___i (ß ___i + ___step))]
                (let [#_"Object[]" ___array (ß arrayFor(___i))]
                    (loop-when-recur [(§ var #_"int" ___j 0)] (ß ___j < ___array.length) [(§ ass ___j (ß ___j + 1))]
                        (§ ass ___init (ß ___f.invoke(___init, ___array[___j])))
                        (when (ß RT'isReduced(___init))
                            (§ return (ß ((IDeref)___init).deref()))
                        )
                    )
                    (§ ass ___step (ß ___array.length))
                )
            )
            ___init
        )
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentVector" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"int" ___step 0]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < cnt) [(§ ass ___i (ß ___i + ___step))]
                (let [#_"Object[]" ___array (ß arrayFor(___i))]
                    (loop-when-recur [(§ var #_"int" ___j 0)] (ß ___j < ___array.length) [(§ ass ___j (ß ___j + 1))]
                        (§ ass ___init (ß ___f.invoke(___init, ___j + ___i, ___array[___j])))
                        (when (ß RT'isReduced(___init))
                            (§ return (ß ((IDeref)___init).deref()))
                        )
                    )
                    (§ ass ___step (ß ___array.length))
                )
            )
            ___init
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentVector" this]
        (ß EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentVector" pop [#_"PersistentVector" this]
        (when (ß cnt == 0)
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß cnt == 1)
            (§ return (ß EMPTY.withMeta(meta())))
        )
        (when (ß cnt - tailoff() > 1)
            (let [#_"Object[]" ___newTail (ß new Object[tail.length - 1])]
                (ß System/arraycopy(tail, 0, ___newTail, 0, ___newTail.length))
                (§ return (ß new PersistentVector(meta(), cnt - 1, shift, root, ___newTail)))
            )
        )
        (let [#_"Object[]" ___newtail (ß arrayFor(cnt - 2))]
            (let [#_"VNode" ___newroot (ß popTail(shift, root))]
                (let [#_"int" ___newshift shift]
                    (when (nil? ___newroot)
                        (§ ass ___newroot EMPTY_NODE)
                    )
                    (when (ß shift > 5 && ___newroot.array[1] == nil)
                        (§ ass ___newroot (ß (VNode) ___newroot.array[0]))
                        (§ ass ___newshift (ß ___newshift - 5))
                    )
                    (ß new PersistentVector(meta(), cnt - 1, ___newshift, ___newroot, ___newtail))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" popTail [#_"PersistentVector" this, #_"int" ___level, #_"VNode" ___node]
        (let [#_"int" ___subidx (ß ((cnt - 2) >>> ___level) & 0x01f)]
            (cond (ß ___level > 5)
                (do
                    (let [#_"VNode" ___newchild (ß popTail(___level - 5, (VNode) ___node.array[___subidx]))]
                        (if (ß ___newchild == nil && ___subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"VNode" ___ret (ß new VNode(root.edit, ___node.array.clone()))]
                                    (§ ass (ß ___ret.array[___subidx]) ___newchild)
                                    ret
                                )
                            )
                        )
                    )
                )
                (ß ___subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"VNode" ___ret (ß new VNode(root.edit, ___node.array.clone()))]
                        (§ ass (ß ___ret.array[___subidx]) nil)
                        ret
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    (§ init
        ;; method-name-string->fn
        (§ field #_"IPersistentMap" fns nil)
    )

    (§ constructor #_"ProxyHandler" ProxyHandler [#_"IPersistentMap" ___fns]
        (let [this (ß super())]
            (§ ass (ß this.fns) ___fns)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"ProxyHandler" this, #_"Object" ___proxy, #_"Method" ___method, #_"Object[]" ___args] #_(§ throws Throwable)
        (let [#_"Class" ___rt (ß ___method.getReturnType())]
            (let [#_"IFn" ___fn (ß (IFn) fns.valAt(___method.getName()))]
                (when (nil? ___fn)
                    (cond (ß ___rt == Void/TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß ___method.getName().equals("equals"))
                        (do
                            (§ return (ß (___proxy == ___args[0])))
                        )
                        (ß ___method.getName().equals("hashCode"))
                        (do
                            (§ return (ß System/identityHashCode(___proxy)))
                        )
                        (ß ___method.getName().equals("toString"))
                        (do
                            (§ return (ß "Proxy: " + System/identityHashCode(___proxy)))
                        )
                    )
                    (throw (UnsupportedOperationException.))
                )
                (let [#_"Object" ___ret (ß ___fn.applyTo(ArraySeq'create(___args)))]
                    (cond (ß ___rt == Void/TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß ___rt.isPrimitive())
                        (do
                            (cond (ß ___rt == Character/TYPE)
                                (do
                                    (§ return ___ret)
                                )
                                (ß ___rt == Integer/TYPE)
                                (do
                                    (§ return (ß ((Number) ___ret).intValue()))
                                )
                                (ß ___rt == Long/TYPE)
                                (do
                                    (§ return (ß ((Number) ___ret).longValue()))
                                )
                                (ß ___rt == Float/TYPE)
                                (do
                                    (§ return (ß ((Number) ___ret).floatValue()))
                                )
                                (ß ___rt == Double/TYPE)
                                (do
                                    (§ return (ß ((Number) ___ret).doubleValue()))
                                )
                                (ß ___rt == Boolean/TYPE && !(___ret instanceof Boolean))
                                (do
                                    (§ return (ß (___ret == nil) ? Boolean/FALSE :or Boolean/TRUE))
                                )
                                (ß ___rt == Byte/TYPE)
                                (do
                                    (§ return (ß (byte) ((Number) ___ret).intValue()))
                                )
                                (ß ___rt == Short/TYPE)
                                (do
                                    (§ return (ß (short) ((Number) ___ret).intValue()))
                                )
                            )
                        )
                    )
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

#_private
(defprotocol RangeBoundsCheck
    #_abstract
    (#_"boolean" RangeBoundsCheck'''exceededBounds [#_"RangeBoundsCheck" this, #_"Object" ___val])
)

#_private
#_non-static
(class-ns RangeIterator (§ implements Iterator)
    (§ init
        (§ field- #_"Object" next nil)
    )

    (§ constructor #_"RangeIterator" RangeIterator []
        (let [this (ß super())]
            (§ ass (ß this.next) start)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"RangeIterator" this]
        (ß (!boundsCheck.exceededBounds(next)))
    )

    #_method
    (§ defn #_"Object" next [#_"RangeIterator" this]
        (if (ß hasNext())
            (do
                (let [#_"Object" ___ret next]
                    (§ ass next (ß Numbers'addP(next, step)))
                    ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"RangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (§ def- #_"int" Range'CHUNK_SIZE 32)

    (§ defn- #_"RangeBoundsCheck" Range'positiveStep [#_"Object" ___end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"RangeBoundsCheck" this, #_"Object" ___val]
                (ß Numbers'gte(___val, ___end))
            )
        )
    )

    (§ defn- #_"RangeBoundsCheck" Range'negativeStep [#_"Object" ___end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"RangeBoundsCheck" this, #_"Object" ___val]
                (ß Numbers'lte(___val, ___end))
            )
        )
    )

    (§ init
        ;; Invariants guarantee this is never an "empty" seq
        (§ field #_"Object" end nil)
        (§ field #_"Object" start nil)
        (§ field #_"Object" step nil)
        (§ field #_"RangeBoundsCheck" boundsCheck nil)

        #_volatile
        (§ field- #_"IChunk" _chunk nil) ;; lazy
        #_volatile
        (§ field- #_"ISeq" _chunkNext nil) ;; lazy
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"Range" Range [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck]
        (let [this (ß super())]
            (§ ass (ß this.end) ___end)
            (§ ass (ß this.start) ___start)
            (§ ass (ß this.step) ___step)
            (§ ass (ß this.boundsCheck) ___boundsCheck)
            this
        )
    )

    (§ constructor- #_"Range" Range [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck, #_"IChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (ß super())]
            (§ ass (ß this.end) ___end)
            (§ ass (ß this.start) ___start)
            (§ ass (ß this.step) ___step)
            (§ ass (ß this.boundsCheck) ___boundsCheck)
            (§ ass (ß this._chunk) ___chunk)
            (§ ass (ß this._chunkNext) ___chunkNext)
            this
        )
    )

    (§ constructor- #_"Range" Range [#_"IPersistentMap" ___meta, #_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck, #_"IChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (ß super(___meta))]
            (§ ass (ß this.end) ___end)
            (§ ass (ß this.start) ___start)
            (§ ass (ß this.step) ___step)
            (§ ass (ß this.boundsCheck) ___boundsCheck)
            (§ ass (ß this._chunk) ___chunk)
            (§ ass (ß this._chunkNext) ___chunkNext)
            this
        )
    )

    (§ defn #_"ISeq" Range'create [#_"Object" ___end]
        (when (ß Numbers'isPos(___end))
            (§ return (ß new Range(0, ___end, 1, positiveStep(___end))))
        )
        (ß PersistentList'EMPTY)
    )

    (§ defn #_"ISeq" Range'create [#_"Object" ___start, #_"Object" ___end]
        (ß Range'create(___start, ___end, 1))
    )

    (§ defn #_"ISeq" Range'create [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step]
        (when (ß (Numbers'isPos(___step) && Numbers'gt(___start, ___end)) || (Numbers'isNeg(___step) && Numbers'gt(___end, ___start)) || Numbers'equiv(___start, ___end))
            (§ return (ß PersistentList'EMPTY))
        )
        (when (ß Numbers'isZero(___step))
            (§ return (ß Repeat'create(___start)))
        )
        (ß new Range(___start, ___end, ___step, Numbers'isPos(___step) ? positiveStep(___end) :or negativeStep(___end)))
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"Range" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == _meta)
            (§ return this)
        )
        (ß new Range(___meta, end, start, step, boundsCheck, _chunk, _chunkNext))
    )

    #_method
    (§ defn #_"Object" first [#_"Range" this]
        start
    )

    #_method
    (§ defn #_"void" forceChunk [#_"Range" this]
        (when (some? _chunk)
            (§ return nil)
        )

        (let [#_"Object[]" ___arr (ß new Object[CHUNK_SIZE])]
            (let [#_"int" ___n 0]
                (let [#_"Object" ___val start]
                    (while (ß ___n < CHUNK_SIZE)
                        (§ ass (ß ___arr[___n]) ___val)
                        (§ ass ___n (ß ___n + 1))
                        (§ ass ___val (ß Numbers'addP(___val, step)))
                        (when (ß boundsCheck.exceededBounds(___val))
                            ;; partial last chunk
                            (§ ass _chunk (ß new ArrayChunk(___arr, 0, ___n)))
                            (§ return nil)
                        )
                    )

                    ;; full last chunk
                    (when (ß boundsCheck.exceededBounds(___val))
                        (§ ass _chunk (ß new ArrayChunk(___arr, 0, CHUNK_SIZE)))
                        (§ return nil)
                    )

                    ;; full intermediate chunk
                    (§ ass _chunk (ß new ArrayChunk(___arr, 0, CHUNK_SIZE)))
                    (§ ass _chunkNext (ß new Range(___val, end, step, boundsCheck)))
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" next [#_"Range" this]
        (when (some? _next)
            (§ return _next)
        )

        (ß forceChunk())
        (when (ß _chunk.count() > 1)
            (let [#_"IChunk" ___smallerChunk (ß _chunk.dropFirst())]
                (§ ass _next (ß new Range(___smallerChunk.nth(0), end, step, boundsCheck, ___smallerChunk, _chunkNext)))
                (§ return _next)
            )
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"Range" this]
        (ß forceChunk())
        _chunk
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"Range" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"Range" this]
        (ß forceChunk())
        (when (nil? _chunkNext)
            (§ return (ß PersistentList'EMPTY))
        )
        _chunkNext
    )

    #_method
    (§ defn #_"Object" reduce [#_"Range" this, #_"IFn" ___f]
        (let [#_"Object" ___acc start]
            (let [#_"Number" ___i (ß Numbers'addP(start, step))]
                (while (ß !boundsCheck.exceededBounds(___i))
                    (§ ass ___acc (ß ___f.invoke(___acc, ___i)))
                    (when (ß RT'isReduced(___acc))
                        (§ return (ß ((Reduced)___acc).deref()))
                    )
                    (§ ass ___i (ß Numbers'addP(___i, step)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Range" this, #_"IFn" ___f, #_"Object" ___val]
        (let [#_"Object" ___acc ___val]
            (let [#_"Object" ___i start]
                (while (ß !boundsCheck.exceededBounds(___i))
                    (§ ass ___acc (ß ___f.invoke(___acc, ___i)))
                    (when (ß RT'isReduced(___acc))
                        (§ return (ß ((Reduced)___acc).deref()))
                    )
                    (§ ass ___i (ß Numbers'addP(___i, step)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"Range" this]
        (RangeIterator.)
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (§ init
        (§ field #_"BigInteger" numerator nil)
        (§ field #_"BigInteger" denominator nil)
    )

    (§ constructor #_"Ratio" Ratio [#_"BigInteger" ___numerator, #_"BigInteger" ___denominator]
        (let [this (ß super())]
            (§ ass (ß this.numerator) ___numerator)
            (§ ass (ß this.denominator) ___denominator)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"Ratio" this, #_"Object" ___arg0]
        (ß (___arg0 != nil && ___arg0 instanceof Ratio && ((Ratio) ___arg0).numerator.equals(numerator) && ((Ratio) ___arg0).denominator.equals(denominator)))
    )

    #_method
    (§ defn #_"int" hashCode [#_"Ratio" this]
        (ß numerator.hashCode() :xor denominator.hashCode())
    )

    #_method
    (§ defn #_"String" toString [#_"Ratio" this]
        (ß numerator.toString() + "/" + denominator.toString())
    )

    #_method
    (§ defn #_"int" intValue [#_"Ratio" this]
        (ß (int) doubleValue())
    )

    #_method
    (§ defn #_"long" longValue [#_"Ratio" this]
        (ß bigIntegerValue().longValue())
    )

    #_method
    (§ defn #_"float" floatValue [#_"Ratio" this]
        (ß (float)doubleValue())
    )

    #_method
    (§ defn #_"double" doubleValue [#_"Ratio" this]
        (ß decimalValue(MathContext/DECIMAL64).doubleValue())
    )

    #_method
    (§ defn #_"BigDecimal" decimalValue [#_"Ratio" this]
        (ß decimalValue(MathContext/UNLIMITED))
    )

    #_method
    (§ defn #_"BigDecimal" decimalValue [#_"Ratio" this, #_"MathContext" ___mc]
        (let [#_"BigDecimal" ___numerator (BigDecimal. (ß this.numerator))]
            (let [#_"BigDecimal" ___denominator (BigDecimal. (ß this.denominator))]
                (ß ___numerator.divide(___denominator, ___mc))
            )
        )
    )

    #_method
    (§ defn #_"BigInteger" bigIntegerValue [#_"Ratio" this]
        (ß numerator.divide(denominator))
    )

    #_method
    (§ defn #_"int" compareTo [#_"Ratio" this, #_"Object" ___o]
        (let [#_"Number" ___other (ß (Number)___o)]
            (ß Numbers'compare(this, ___other))
        )
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(class-ns ReaderConditional (§ implements ILookup)
    (§ def #_"Keyword" ReaderConditional'FORM_KW (ß Keyword'intern("form")))
    (§ def #_"Keyword" ReaderConditional'SPLICING_KW (ß Keyword'intern("splicing?")))

    (§ defn #_"ReaderConditional" ReaderConditional'create [#_"Object" ___form, #_"boolean" ___splicing]
        (ß new ReaderConditional(___form, ___splicing))
    )

    (§ init
        (§ field #_"Object" form nil)
        (§ field #_"Boolean" splicing nil)
    )

    (§ constructor- #_"ReaderConditional" ReaderConditional [#_"Object" ___form, #_"boolean" ___splicing]
        (let [this (ß super())]
            (§ ass (ß this.form) ___form)
            (§ ass (ß this.splicing) ___splicing)
            this
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"ReaderConditional" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [#_"ReaderConditional" this, #_"Object" ___key, #_"Object" ___notFound]
        (cond (ß FORM_KW.equals(___key))
            (do
                (ß this.form)
            )
            (ß SPLICING_KW.equals(___key))
            (do
                (ß this.splicing)
            )
            :else
            (do
                ___notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" equals [#_"ReaderConditional" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (ß ___o == nil || getClass() != ___o.getClass())
            (§ return false)
        )

        (let [#_"ReaderConditional" ___that (ß (ReaderConditional) ___o)]
            (when (ß (form != nil) ? !form.equals(___that.form) :or ___that.form != nil)
                (§ return false)
            )
            (when (ß (splicing != nil) ? !splicing.equals(___that.splicing) :or ___that.splicing != nil)
                (§ return false)
            )
            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" hashCode [#_"ReaderConditional" this]
        (let [#_"int" ___result (ß Util'hash(form))]
            (§ ass ___result (ß 31 * ___result + Util'hash(splicing)))
            result
        )
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (§ init
        (§ field #_"int" i 0)
        (§ field #_"int" basecnt 0)
        (§ field #_"ILookup" rec nil)
        (§ field #_"IPersistentVector" basefields nil)
        (§ field #_"Iterator" extmap nil)
    )

    (§ constructor #_"RecordIterator" RecordIterator [#_"ILookup" ___rec, #_"IPersistentVector" ___basefields, #_"Iterator" ___extmap]
        (let [this (ß super())]
            (§ ass (ß this.rec) ___rec)
            (§ ass (ß this.basefields) ___basefields)
            (§ ass (ß this.basecnt) (ß ___basefields.count()))
            (§ ass (ß this.extmap) ___extmap)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"RecordIterator" this]
        (if (ß i < basecnt)
            (do
                true
            )
            (do
                (ß extmap.hasNext())
            )
        )
    )

    #_method
    (§ defn #_"Object" next [#_"RecordIterator" this]
        (if (ß i < basecnt)
            (do
                (let [#_"Object" ___k (ß basefields.nth(i))]
                    (§ ass i (ß i + 1))
                    (ß MapEntry'create(___k, rec.valAt(___k)))
                )
            )
            (do
                (ß extmap.next())
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"RecordIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (§ init
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"Reduced" Reduced [#_"Object" ___val]
        (let [this (ß super())]
            (§ ass (ß this.val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Reduced" this]
        val
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns RefTVal
    (§ init
        (§ field #_"Object" val nil)
        (§ field #_"long" point 0)
        (§ field #_"RefTVal" prior nil)
        (§ field #_"RefTVal" next nil)
    )

    (§ constructor #_"RefTVal" RefTVal [#_"Object" ___val, #_"long" ___point, #_"RefTVal" ___prior]
        (let [this (ß super())]
            (§ ass (ß this.val) ___val)
            (§ ass (ß this.point) ___point)
            (§ ass (ß this.prior) ___prior)
            (§ ass (ß this.next) (ß ___prior.next))
            (§ ass (ß this.prior.next) this)
            (§ ass (ß this.next.prior) this)
            this
        )
    )

    (§ constructor #_"RefTVal" RefTVal [#_"Object" ___val, #_"long" ___point]
        (let [this (ß super())]
            (§ ass (ß this.val) ___val)
            (§ ass (ß this.point) ___point)
            (§ ass (ß this.next) this)
            (§ ass (ß this.prior) this)
            this
        )
    )
)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (§ def #_"AtomicLong" Ref'ids (AtomicLong.))

    (§ init
        (§ field #_"RefTVal" tvals nil)
        (§ field #_"AtomicInteger" faults nil)
        (§ field #_"ReentrantReadWriteLock" lock nil)
        (§ field #_"LockingTransactionInfo" tinfo nil)
        (§ field #_"long" id 0)

        #_volatile
        (§ field #_"int" minHistory 0)
        #_volatile
        (§ field #_"int" maxHistory 10)
    )

    (§ constructor #_"Ref" Ref [#_"Object" ___initVal]
        (let [this (ß this(___initVal, nil))]
            this
        )
    )

    (§ constructor #_"Ref" Ref [#_"Object" ___initVal, #_"IPersistentMap" ___meta]
        (let [this (ß super(___meta))]
            (§ ass (ß this.id) (ß Ref'ids.getAndIncrement()))
            (§ ass (ß this.faults) (AtomicInteger.))
            (§ ass (ß this.lock) (ReentrantReadWriteLock.))
            (§ ass tvals (ß new RefTVal(___initVal, 0)))
            this
        )
    )

    #_method
    (§ defn #_"int" compareTo [#_"Ref" this, #_"Ref" ___ref]
        (cond (ß this.id == ___ref.id)
            (do
                0
            )
            (ß this.id < ___ref.id)
            (do
                -1
            )
            :else
            (do
                1
            )
        )
    )

    #_method
    (§ defn #_"int" getMinHistory [#_"Ref" this]
        minHistory
    )

    #_method
    (§ defn #_"Ref" setMinHistory [#_"Ref" this, #_"int" ___minHistory]
        (§ ass (ß this.minHistory) ___minHistory)
        this
    )

    #_method
    (§ defn #_"int" getMaxHistory [#_"Ref" this]
        maxHistory
    )

    #_method
    (§ defn #_"Ref" setMaxHistory [#_"Ref" this, #_"int" ___maxHistory]
        (§ ass (ß this.maxHistory) ___maxHistory)
        this
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (§ defn #_"Object" currentVal [#_"Ref" this]
        (try
            (ß lock.readLock().lock())
            (when (some? tvals)
                (§ return (ß tvals.val))
            )
            (throw (ß new IllegalStateException(this.toString() + " is unbound.")))
            (finally
                (ß lock.readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Ref" this]
        (let [#_"LockingTransaction" ___t (ß LockingTransaction'getRunning())]
            (when (nil? ___t)
                (§ return (ß currentVal()))
            )
            (ß ___t.doGet(this))
        )
    )

    #_method
    (§ defn #_"Object" set [#_"Ref" this, #_"Object" ___val]
        (ß LockingTransaction'getEx().doSet(this, ___val))
    )

    #_method
    (§ defn #_"Object" commute [#_"Ref" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (ß LockingTransaction'getEx().doCommute(this, ___fn, ___args))
    )

    #_method
    (§ defn #_"Object" alter [#_"Ref" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (let [#_"LockingTransaction" ___t (ß LockingTransaction'getEx())]
            (ß ___t.doSet(this, ___fn.applyTo(RT'cons(___t.doGet(this), ___args))))
        )
    )

    #_method
    (§ defn #_"void" touch [#_"Ref" this]
        (ß LockingTransaction'getEx().doEnsure(this))
        nil
    )

    #_method
    (§ defn #_"boolean" isBound [#_"Ref" this]
        (try
            (ß lock.readLock().lock())
            (ß (tvals != nil))
            (finally
                (ß lock.readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"void" trimHistory [#_"Ref" this]
        (try
            (ß lock.writeLock().lock())
            (when (some? tvals)
                (§ ass (ß tvals.next) tvals)
                (§ ass (ß tvals.prior) tvals)
            )
            (finally
                (ß lock.writeLock().unlock())
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" getHistoryCount [#_"Ref" this]
        (try
            (ß lock.writeLock().lock())
            (ß histCount())
            (finally
                (ß lock.writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"int" histCount [#_"Ref" this]
        (if (nil? tvals)
            (do
                0
            )
            (do
                (let [#_"int" ___count 0]
                    (loop-when-recur [(§ var #_"RefTVal" ___tv (ß tvals.next))] (ß ___tv != tvals) [(§ ass ___tv (ß ___tv.next))]
                        (§ ass ___count (ß ___count + 1))
                    )
                    count
                )
            )
        )
    )

    #_method
    (§ defn #_"IFn" fn [#_"Ref" this]
        (ß (IFn) deref())
    )

    #_method
    (§ defn #_"Object" call [#_"Ref" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"Ref" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this]
        (ß fn().invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1]
        (ß fn().invoke(___arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß fn().invoke(___arg1, ___arg2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß fn().invoke(___arg1, ___arg2, ___arg3))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19, ___arg20))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19, ___arg20, ___args))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Ref" this, #_"ISeq" ___arglist]
        (ß AFn'applyToHelper(this, ___arglist))
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

#_stateless
(class-ns Reflector
    (§ defn #_"Object" Reflector'invokeInstanceMethod [#_"Object" ___target, #_"String" ___methodName, #_"Object[]" ___args]
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"List" ___methods (ß getMethods(___c, ___args.length, ___methodName, false))]
                (ß invokeMatchingMethod(___methodName, ___methods, ___target, ___args))
            )
        )
    )

    (§ defn- #_"Throwable" Reflector'getCauseOrElse [#_"Exception" ___e]
        (when (ß ___e.getCause() != nil)
            (§ return (ß ___e.getCause()))
        )
        e
    )

    (§ defn- #_"RuntimeException" Reflector'throwCauseOrElseException [#_"Exception" ___e]
        (when (ß ___e.getCause() != nil)
            (throw (ß Util'sneakyThrow(___e.getCause())))
        )
        (throw (ß Util'sneakyThrow(___e)))
    )

    (§ defn- #_"String" Reflector'noMethodReport [#_"String" ___methodName, #_"Object" ___target]
        (ß "No matching method found: " + ___methodName + ((___target == nil) ? "" :or " for " + ___target.getClass()))
    )

    (§ defn #_"Object" Reflector'invokeMatchingMethod [#_"String" ___methodName, #_"List" ___methods, #_"Object" ___target, #_"Object[]" ___args]
        (let [#_"Method" ___m nil]
            (let [#_"Object[]" ___boxedArgs nil]
                (cond (ß ___methods.isEmpty())
                    (do
                        (throw (ß new IllegalArgumentException(noMethodReport(___methodName, ___target))))
                    )
                    (ß ___methods.size() == 1)
                    (do
                        (§ ass ___m (ß (Method) ___methods.get(0)))
                        (§ ass ___boxedArgs (ß boxArgs(___m.getParameterTypes(), ___args)))
                    )
                    :else ;; overloaded w/same arity
                    (do
                        (let [#_"Method" ___foundm nil]
                            (loop-when-recur [(§ var #_"Iterator" ___i (ß ___methods.iterator()))] (ß ___i.hasNext()) [(ß )]
                                (§ ass ___m (ß (Method) ___i.next()))

                                (let [#_"Class[]" ___params (ß ___m.getParameterTypes())]
                                    (when (ß isCongruent(___params, ___args))
                                        (when (ß ___foundm == nil || Compiler'subsumes(___params, ___foundm.getParameterTypes()))
                                            (§ ass ___foundm ___m)
                                            (§ ass ___boxedArgs (ß boxArgs(___params, ___args)))
                                        )
                                    )
                                )
                            )
                            (§ ass ___m ___foundm)
                        )
                    )
                )
                (when (nil? ___m)
                    (throw (ß new IllegalArgumentException(noMethodReport(___methodName, ___target))))
                )

                (when (ß !Modifier/isPublic(___m.getDeclaringClass().getModifiers()))
                    ;; public method of non-public class, try to find it in hierarchy
                    (let [#_"Method" ___oldm ___m]
                        (§ ass ___m (ß getAsMethodOfPublicBase(___target.getClass(), ___m)))
                        (when (nil? ___m)
                            (throw (ß new IllegalArgumentException("Can't call public method of non-public class: " + ___oldm.toString())))
                        )
                    )
                )
                (try
                    (ß Reflector'prepRet(___m.getReturnType(), ___m.invoke(___target, ___boxedArgs)))
                    (catch Exception ___e
                        (throw (ß Util'sneakyThrow(getCauseOrElse(___e))))
                    )
                )
            )
        )
    )

    (§ defn #_"Method" Reflector'getAsMethodOfPublicBase [#_"Class" ___c, #_"Method" ___m]
        (doseq [#_"Class" ___iface (ß ___c.getInterfaces())]
            (doseq [#_"Method" ___im (ß ___iface.getMethods())]
                (when (ß isMatch(___im, ___m))
                    (§ return ___im)
                )
            )
        )
        (let [#_"Class" ___sc (ß ___c.getSuperclass())]
            (when (nil? ___sc)
                (§ return nil)
            )
            (doseq [#_"Method" ___scm (ß ___sc.getMethods())]
                (when (ß isMatch(___scm, ___m))
                    (§ return ___scm)
                )
            )
            (ß getAsMethodOfPublicBase(___sc, ___m))
        )
    )

    (§ defn #_"boolean" Reflector'isMatch [#_"Method" ___lhs, #_"Method" ___rhs]
        (when (ß !___lhs.getName().equals(___rhs.getName()) || !Modifier/isPublic(___lhs.getDeclaringClass().getModifiers()))
            (§ return false)
        )

        (let [#_"Class[]" ___types1 (ß ___lhs.getParameterTypes())]
            (let [#_"Class[]" ___types2 (ß ___rhs.getParameterTypes())]
                (when (ß ___types1.length != ___types2.length)
                    (§ return false)
                )

                (let [#_"boolean" ___match true]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___types1.length) [(§ ass ___i (ß ___i + 1))]
                        (when (ß !___types1[___i].isAssignableFrom(___types2[___i]))
                            (§ ass ___match false)
                            (§ break )
                        )
                    )
                    match
                )
            )
        )
    )

    (§ defn #_"Object" Reflector'invokeConstructor [#_"Class" ___c, #_"Object[]" ___args]
        (try
            (let [#_"Constructor[]" ___allctors (ß ___c.getConstructors())]
                (let [#_"ArrayList" ___ctors (ArrayList.)]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___allctors.length) [(§ ass ___i (ß ___i + 1))]
                        (let [#_"Constructor" ___ctor (ß ___allctors[___i])]
                            (when (ß ___ctor.getParameterTypes().length == ___args.length)
                                (ß ___ctors.add(___ctor))
                            )
                        )
                    )
                    (cond (ß ___ctors.isEmpty())
                        (do
                            (throw (IllegalArgumentException. (ß "No matching ctor found for " + ___c)))
                        )
                        (ß ___ctors.size() == 1)
                        (do
                            (let [#_"Constructor" ___ctor (ß (Constructor) ___ctors.get(0))]
                                (ß ___ctor.newInstance(boxArgs(___ctor.getParameterTypes(), ___args)))
                            )
                        )
                        :else ;; overloaded w/same arity
                        (do
                            (loop-when-recur [(§ var #_"Iterator" ___iterator (ß ___ctors.iterator()))] (ß ___iterator.hasNext()) [(ß )]
                                (let [#_"Constructor" ___ctor (ß (Constructor) ___iterator.next())]
                                    (let [#_"Class[]" ___params (ß ___ctor.getParameterTypes())]
                                        (when (ß isCongruent(___params, ___args))
                                            (let [#_"Object[]" ___boxedArgs (ß boxArgs(___params, ___args))]
                                                (§ return (ß ___ctor.newInstance(___boxedArgs)))
                                            )
                                        )
                                    )
                                )
                            )
                            (throw (IllegalArgumentException. (ß "No matching ctor found for " + ___c)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (throw (ß Util'sneakyThrow(getCauseOrElse(___e))))
            )
        )
    )

    (§ defn #_"Object" Reflector'invokeStaticMethodVariadic [#_"String" ___className, #_"String" ___methodName, #_"Object..." ___args]
        (ß invokeStaticMethod(___className, ___methodName, ___args))
    )

    (§ defn #_"Object" Reflector'invokeStaticMethod [#_"String" ___className, #_"String" ___methodName, #_"Object[]" ___args]
        (let [#_"Class" ___c (ß RT'classForName(___className))]
            (ß invokeStaticMethod(___c, ___methodName, ___args))
        )
    )

    (§ defn #_"Object" Reflector'invokeStaticMethod [#_"Class" ___c, #_"String" ___methodName, #_"Object[]" ___args]
        (when (ß ___methodName.equals("new"))
            (§ return (ß invokeConstructor(___c, ___args)))
        )
        (let [#_"List" ___methods (ß getMethods(___c, ___args.length, ___methodName, true))]
            (ß invokeMatchingMethod(___methodName, ___methods, nil, ___args))
        )
    )

    (§ defn #_"Object" Reflector'getStaticField [#_"String" ___className, #_"String" ___fieldName]
        (let [#_"Class" ___c (ß RT'classForName(___className))]
            (ß getStaticField(___c, ___fieldName))
        )
    )

    (§ defn #_"Object" Reflector'getStaticField [#_"Class" ___c, #_"String" ___fieldName]
        (let [#_"Field" ___f (ß getField(___c, ___fieldName, true))]
            (when (some? ___f)
                (try
                    (§ return (ß Reflector'prepRet(___f.getType(), ___f.get(nil))))
                    (catch IllegalAccessException ___e
                        (throw (ß Util'sneakyThrow(___e)))
                    )
                )
            )
            (throw (IllegalArgumentException. (ß "No matching field found: " + ___fieldName + " for " + ___c)))
        )
    )

    (§ defn #_"Object" Reflector'setStaticField [#_"String" ___className, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Class" ___c (ß RT'classForName(___className))]
            (ß setStaticField(___c, ___fieldName, ___val))
        )
    )

    (§ defn #_"Object" Reflector'setStaticField [#_"Class" ___c, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Field" ___f (ß getField(___c, ___fieldName, true))]
            (when (some? ___f)
                (try
                    (ß ___f.set(nil, boxArg(___f.getType(), ___val)))
                    (catch IllegalAccessException ___e
                        (throw (ß Util'sneakyThrow(___e)))
                    )
                )
                (§ return ___val)
            )
            (throw (IllegalArgumentException. (ß "No matching field found: " + ___fieldName + " for " + ___c)))
        )
    )

    (§ defn #_"Object" Reflector'getInstanceField [#_"Object" ___target, #_"String" ___fieldName]
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"Field" ___f (ß getField(___c, ___fieldName, false))]
                (when (some? ___f)
                    (try
                        (§ return (ß Reflector'prepRet(___f.getType(), ___f.get(___target))))
                        (catch IllegalAccessException ___e
                            (throw (ß Util'sneakyThrow(___e)))
                        )
                    )
                )
                (throw (ß new IllegalArgumentException("No matching field found: " + ___fieldName + " for " + ___target.getClass())))
            )
        )
    )

    (§ defn #_"Object" Reflector'setInstanceField [#_"Object" ___target, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"Field" ___f (ß getField(___c, ___fieldName, false))]
                (when (some? ___f)
                    (try
                        (ß ___f.set(___target, boxArg(___f.getType(), ___val)))
                        (catch IllegalAccessException ___e
                            (throw (ß Util'sneakyThrow(___e)))
                        )
                    )
                    (§ return ___val)
                )
                (throw (ß new IllegalArgumentException("No matching field found: " + ___fieldName + " for " + ___target.getClass())))
            )
        )
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    (§ defn #_"Object" Reflector'invokeNoArgInstanceMember [#_"Object" ___target, #_"String" ___name]
        (ß invokeNoArgInstanceMember(___target, ___name, false))
    )

    (§ defn #_"Object" Reflector'invokeNoArgInstanceMember [#_"Object" ___target, #_"String" ___name, #_"boolean" ___requireField]
        (let [#_"Class" ___c (ß ___target.getClass())]
            (if ___requireField
                (do
                    (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                        (if (some? ___f)
                            (do
                                (ß getInstanceField(___target, ___name))
                            )
                            (do
                                (throw (ß new IllegalArgumentException("No matching field found: " + ___name + " for " + ___target.getClass())))
                            )
                        )
                    )
                )
                (do
                    (let [#_"List" ___meths (ß getMethods(___c, 0, ___name, false))]
                        (if (ß ___meths.size() > 0)
                            (do
                                (ß invokeMatchingMethod(___name, ___meths, ___target, RT'EMPTY_ARRAY))
                            )
                            (do
                                (ß getInstanceField(___target, ___name))
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"Object" Reflector'invokeInstanceMember [#_"Object" ___target, #_"String" ___name]
        ;; check for field first
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                (when (some? ___f) ;; field get
                    (try
                        (§ return (ß Reflector'prepRet(___f.getType(), ___f.get(___target))))
                        (catch IllegalAccessException ___e
                            (throw (ß Util'sneakyThrow(___e)))
                        )
                    )
                )
                (ß invokeInstanceMethod(___target, ___name, RT'EMPTY_ARRAY))
            )
        )
    )

    (§ defn #_"Object" Reflector'invokeInstanceMember [#_"String" ___name, #_"Object" ___target, #_"Object" ___arg1]
        ;; check for field first
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                (when (some? ___f) ;; field set
                    (try
                        (ß ___f.set(___target, boxArg(___f.getType(), ___arg1)))
                        (catch IllegalAccessException ___e
                            (throw (ß Util'sneakyThrow(___e)))
                        )
                    )
                    (§ return ___arg1)
                )
                (ß invokeInstanceMethod(___target, ___name, new Object[] (§ array ___arg1 )))
            )
        )
    )

    (§ defn #_"Object" Reflector'invokeInstanceMember [#_"String" ___name, #_"Object" ___target, #_"Object..." ___args]
        (ß invokeInstanceMethod(___target, ___name, ___args))
    )

    (§ defn #_"Field" Reflector'getField [#_"Class" ___c, #_"String" ___name, #_"boolean" ___getStatics]
        (let [#_"Field[]" ___allfields (ß ___c.getFields())]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___allfields.length) [(§ ass ___i (ß ___i + 1))]
                (when (ß ___name.equals(___allfields[___i].getName()) && Modifier/isStatic(___allfields[___i].getModifiers()) == ___getStatics)
                    (§ return (ß ___allfields[___i]))
                )
            )
            nil
        )
    )

    (§ defn #_"List" Reflector'getMethods [#_"Class" ___c, #_"int" ___arity, #_"String" ___name, #_"boolean" ___getStatics]
        (let [#_"Method[]" ___allmethods (ß ___c.getMethods())]
            (let [#_"ArrayList" ___methods (ArrayList.)]
                (let [#_"ArrayList" ___bridgeMethods (ArrayList.)]
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___allmethods.length) [(§ ass ___i (ß ___i + 1))]
                        (let [#_"Method" ___method (ß ___allmethods[___i])]
                            (when (ß ___name.equals(___method.getName()) && Modifier/isStatic(___method.getModifiers()) == ___getStatics && ___method.getParameterTypes().length == ___arity)
                                (try
                                    (if (ß ___method.isBridge() && ___c.getMethod(___method.getName(), ___method.getParameterTypes()).equals(___method))
                                        (do
                                            (ß ___bridgeMethods.add(___method))
                                        )
                                        (do
                                            (ß ___methods.add(___method))
                                        )
                                    )
                                    (catch NoSuchMethodException ___e
                                    )
                                )
                            )
                        )
                    )

                    (when (ß ___methods.isEmpty())
                        (ß ___methods.addAll(___bridgeMethods))
                    )
                    (when (ß !___getStatics && ___c.isInterface())
                        (§ ass ___allmethods (ß (§ class Object).getMethods()))
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___allmethods.length) [(§ ass ___i (ß ___i + 1))]
                            (when (ß ___name.equals(___allmethods[___i].getName()) && Modifier/isStatic(___allmethods[___i].getModifiers()) == ___getStatics && ___allmethods[___i].getParameterTypes().length == ___arity)
                                (ß ___methods.add(___allmethods[___i]))
                            )
                        )
                    )
                    ___methods
                )
            )
        )
    )

    (§ defn #_"Object" Reflector'boxArg [#_"Class" ___paramType, #_"Object" ___arg]
        (cond (ß !___paramType.isPrimitive())
            (do
                (§ return (ß ___paramType.cast(___arg)))
            )
            (ß ___paramType == (§ class boolean))
            (do
                (§ return (ß (§ class Boolean).cast(___arg)))
            )
            (ß ___paramType == (§ class char))
            (do
                (§ return (ß (§ class Character).cast(___arg)))
            )
            (ß ___arg instanceof Number)
            (do
                (let [#_"Number" ___n (ß (Number) ___arg)]
                    (cond (ß ___paramType == (§ class int))
                        (do
                            (§ return (ß ___n.intValue()))
                        )
                        (ß ___paramType == (§ class float))
                        (do
                            (§ return (ß ___n.floatValue()))
                        )
                        (ß ___paramType == (§ class double))
                        (do
                            (§ return (ß ___n.doubleValue()))
                        )
                        (ß ___paramType == (§ class long))
                        (do
                            (§ return (ß ___n.longValue()))
                        )
                        (ß ___paramType == (§ class short))
                        (do
                            (§ return (ß ___n.shortValue()))
                        )
                        (ß ___paramType == (§ class byte))
                        (do
                            (§ return (ß ___n.byteValue()))
                        )
                    )
                )
            )
        )
        (throw (ß new IllegalArgumentException("Unexpected param type, expected: " + ___paramType + ", given: " + ___arg.getClass().getName())))
    )

    (§ defn #_"Object[]" Reflector'boxArgs [#_"Class[]" ___params, #_"Object[]" ___args]
        (when (ß ___params.length == 0)
            (§ return nil)
        )
        (let [#_"Object[]" ___ret (ß new Object[___params.length])]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___params.length) [(§ ass ___i (ß ___i + 1))]
                (let [#_"Object" ___arg (ß ___args[___i])]
                    (let [#_"Class" ___paramType (ß ___params[___i])]
                        (§ ass (ß ___ret[___i]) (ß boxArg(___paramType, ___arg)))
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"boolean" Reflector'paramArgTypeMatch [#_"Class" ___paramType, #_"Class" ___argType]
        (when (nil? ___argType)
            (§ return (ß !___paramType.isPrimitive()))
        )
        (when (ß ___paramType == ___argType || ___paramType.isAssignableFrom(___argType))
            (§ return true)
        )
        (cond (ß ___paramType == (§ class int))
            (do
                (§ return (ß ___argType == (§ class Integer)
                    || ___argType == (§ class long)
                    || ___argType == (§ class Long)
                    || ___argType == (§ class short)
                    || ___argType == (§ class byte)))
            )
            (ß ___paramType == (§ class float))
            (do
                (§ return (ß ___argType == (§ class Float)
                    || ___argType == (§ class double)))
            )
            (ß ___paramType == (§ class double))
            (do
                (§ return (ß ___argType == (§ class Double)
                    || ___argType == (§ class float)))
            )
            (ß ___paramType == (§ class long))
            (do
                (§ return (ß ___argType == (§ class Long)
                    || ___argType == (§ class int)
                    || ___argType == (§ class short)
                    || ___argType == (§ class byte)))
            )
            (ß ___paramType == (§ class char))
            (do
                (§ return (ß ___argType == (§ class Character)))
            )
            (ß ___paramType == (§ class short))
            (do
                (§ return (ß ___argType == (§ class Short)))
            )
            (ß ___paramType == (§ class byte))
            (do
                (§ return (ß ___argType == (§ class Byte)))
            )
            (ß ___paramType == (§ class boolean))
            (do
                (§ return (ß ___argType == (§ class Boolean)))
            )
        )
        false
    )

    (§ defn #_"boolean" Reflector'isCongruent [#_"Class[]" ___params, #_"Object[]" ___args]
        (let [#_"boolean" ___ret false]
            (when (nil? ___args)
                (§ return (ß (___params.length == 0)))
            )
            (when (ß ___params.length == ___args.length)
                (§ ass ___ret true)
                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___ret && ___i < ___params.length) [(§ ass ___i (ß ___i + 1))]
                    (let [#_"Object" ___arg (ß ___args[___i])]
                        (let [#_"Class" ___argType (ß (___arg == nil) ? nil :or ___arg.getClass())]
                            (let [#_"Class" ___paramType (ß ___params[___i])]
                                (§ ass ___ret (ß paramArgTypeMatch(___paramType, ___argType)))
                            )
                        )
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"Object" Reflector'prepRet [#_"Class" ___c, #_"Object" ___x]
        (when (ß !(___c.isPrimitive() || ___c == (§ class Boolean)))
            (§ return ___x)
        )
        (when (ß ___x instanceof Boolean)
            (§ return (ß ((Boolean) ___x) ? Boolean/TRUE :or Boolean/FALSE))
        )
        x
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (§ def- #_"long" Repeat'INFINITE -1)

    (§ init
        (§ field- #_"long" count 0) ;; always INFINITE or >0
        (§ field- #_"Object" val nil)
        #_volatile
        (§ field- #_"ISeq" _next nil) ;; cached
    )

    (§ constructor- #_"Repeat" Repeat [#_"long" ___count, #_"Object" ___val]
        (let [this (ß super())]
            (§ ass (ß this.count) ___count)
            (§ ass (ß this.val) ___val)
            this
        )
    )

    (§ constructor- #_"Repeat" Repeat [#_"IPersistentMap" ___meta, #_"long" ___count, #_"Object" ___val]
        (let [this (ß super(___meta))]
            (§ ass (ß this.count) ___count)
            (§ ass (ß this.val) ___val)
            this
        )
    )

    (§ defn #_"Repeat" Repeat'create [#_"Object" ___val]
        (ß new Repeat(INFINITE, ___val))
    )

    (§ defn #_"ISeq" Repeat'create [#_"long" ___count, #_"Object" ___val]
        (when (ß ___count <= 0)
            (§ return (ß PersistentList'EMPTY))
        )
        (ß new Repeat(___count, ___val))
    )

    #_method
    (§ defn #_"Object" first [#_"Repeat" this]
        val
    )

    #_method
    (§ defn #_"ISeq" next [#_"Repeat" this]
        (when (nil? _next)
            (cond (ß count > 1)
                (do
                    (§ ass _next (ß new Repeat(count - 1, val)))
                )
                (ß count == INFINITE)
                (do
                    (§ ass _next this)
                )
            )
        )
        _next
    )

    #_method
    (§ defn #_"Repeat" withMeta [#_"Repeat" this, #_"IPersistentMap" ___meta]
        (ß new Repeat(___meta, count, val))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Repeat" this, #_"IFn" ___f]
        (let [#_"Object" ___ret val]
            (if (ß count == INFINITE)
                (do
                    (while true
                        (§ ass ___ret (ß ___f.invoke(___ret, val)))
                        (when (ß RT'isReduced(___ret))
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [(§ var #_"long" ___i 1)] (ß ___i < count) [(§ ass ___i (ß ___i + 1))]
                        (§ ass ___ret (ß ___f.invoke(___ret, val)))
                        (when (ß RT'isReduced(___ret))
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                    )
                    ___ret
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Repeat" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (if (ß count == INFINITE)
                (do
                    (while true
                        (§ ass ___ret (ß ___f.invoke(___ret, val)))
                        (when (ß RT'isReduced(___ret))
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [(§ var #_"long" ___i 0)] (ß ___i < count) [(§ ass ___i (ß ___i + 1))]
                        (§ ass ___ret (ß ___f.invoke(___ret, val)))
                        (when (ß RT'isReduced(___ret))
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                    )
                    ___ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_stateless
#_abstract
(class-ns RestFn (§ extends AFunction)
    #_abstract
    (§ defn #_"int" getRequiredArity [#_"RestFn" this])

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object" ___args]
        nil
    )

    #_method
    (§ defn #_"Object" applyTo [#_"RestFn" this, #_"ISeq" ___args]
        (when (ß RT'boundedLength(___args, getRequiredArity()) <= getRequiredArity())
            (§ return (ß AFn'applyToHelper(this, Util'ret1(___args, (§ ass ___args nil)))))
        )
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (§ return (ß doInvoke(Util'ret1(___args, (§ ass ___args nil)))))
            )
            (§ case 1)
            (do
                (§ return (ß doInvoke(___args.first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 2)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 3)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 4)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 5)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 6)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 7)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 8)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 9)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 10)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 11)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 12)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 13)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 14)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 15)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 16)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 17)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 18)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 19)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 20)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
        )
        (ß throwArity(-1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(nil))
            )
            (§ default )
            (do
                (ß throwArity(0))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(ArraySeq'create(Util'ret1(___arg1, (§ ass ___arg1 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(1))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(2))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(3))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(4))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(5))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(6))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(7))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(8))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(9))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(10))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(11))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(12))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(13))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(14))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(15))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(16))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(17))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(18))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(19))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        ArraySeq'create(
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(20))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ontoArrayPrepend(___args,
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)),
                        ArraySeq'create(___args)))
            )
            (§ default )
            (do
                (ß throwArity(21))
            )
        )
    )

    #_protected
    (§ defn #_"ISeq" RestFn'ontoArrayPrepend [#_"Object[]" ___array, #_"Object..." ___args]
        (let [#_"ISeq" ___ret (ß ArraySeq'create(___array))]
            (loop-when-recur [(§ var #_"int" ___i (ß ___args.length - 1))] (ß ___i >= 0) [(§ ass ___i (ß ___i - 1))]
                (§ ass ___ret (ß RT'cons(___args[___i], ___ret)))
            )
            ret
        )
    )

    #_protected
    (§ defn #_"ISeq" RestFn'findKey [#_"Object" ___key, #_"ISeq" ___args]
        (while (some? ___args)
            (when (ß ___key == ___args.first())
                (§ return (ß ___args.next()))
            )
            (§ ass ___args (ß RT'next(___args)))
            (§ ass ___args (ß RT'next(___args)))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Reversible

(defprotocol Reversible
    #_abstract
    (#_"ISeq" Reversible'''rseq [#_"Reversible" this])
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

#_private
#_stateless
(class-ns DefaultComparator (§ implements Comparator)
    #_method
    (§ defn #_"int" compare [#_"DefaultComparator" this, #_"Object" ___o1, #_"Object" ___o2]
        (ß Util'compare(___o1, ___o2))
    )
)

#_stateless
(class-ns RT
    (§ def #_"Boolean" RT'T (ß Boolean/TRUE))
    (§ def #_"Boolean" RT'F (ß Boolean/FALSE))
    (§ def #_"String" RT'LOADER_SUFFIX "__init")

    ;; simple-symbol->class
    (§ def #_"IPersistentMap" RT'DEFAULT_IMPORTS (ß map(
        (§ map
            (ß Symbol'intern("Boolean"))                         (§ class Boolean)
            (ß Symbol'intern("Byte"))                            (§ class Byte)
            (ß Symbol'intern("Character"))                       (§ class Character)
            (ß Symbol'intern("Class"))                           (§ class Class)
            (ß Symbol'intern("ClassLoader"))                     (§ class ClassLoader)
            (ß Symbol'intern("Compiler"))                        (§ class Compiler)
            (ß Symbol'intern("Double"))                          (§ class Double)
            (ß Symbol'intern("Enum"))                            (§ class Enum)
            (ß Symbol'intern("Float"))                           (§ class Float)
            (ß Symbol'intern("InheritableThreadLocal"))          (§ class InheritableThreadLocal)
            (ß Symbol'intern("Integer"))                         (§ class Integer)
            (ß Symbol'intern("Long"))                            (§ class Long)
            (ß Symbol'intern("Math"))                            (§ class Math)
            (ß Symbol'intern("Number"))                          (§ class Number)
            (ß Symbol'intern("Object"))                          (§ class Object)
            (ß Symbol'intern("Package"))                         (§ class Package)
            (ß Symbol'intern("Process"))                         (§ class Process)
            (ß Symbol'intern("ProcessBuilder"))                  (§ class ProcessBuilder)
            (ß Symbol'intern("Runtime"))                         (§ class Runtime)
            (ß Symbol'intern("RuntimePermission"))               (§ class RuntimePermission)
            (ß Symbol'intern("SecurityManager"))                 (§ class SecurityManager)
            (ß Symbol'intern("Short"))                           (§ class Short)
            (ß Symbol'intern("StackTraceElement"))               (§ class StackTraceElement)
            (ß Symbol'intern("StrictMath"))                      (§ class StrictMath)
            (ß Symbol'intern("String"))                          (§ class String)
            (ß Symbol'intern("StringBuffer"))                    (§ class StringBuffer)
            (ß Symbol'intern("StringBuilder"))                   (§ class StringBuilder)
            (ß Symbol'intern("System"))                          (§ class System)
            (ß Symbol'intern("Thread"))                          (§ class Thread)
            (ß Symbol'intern("ThreadGroup"))                     (§ class ThreadGroup)
            (ß Symbol'intern("ThreadLocal"))                     (§ class ThreadLocal)
            (ß Symbol'intern("Throwable"))                       (§ class Throwable)
            (ß Symbol'intern("Void"))                            (§ class Void)
            (ß Symbol'intern("Appendable"))                      (§ class Appendable)
            (ß Symbol'intern("CharSequence"))                    (§ class CharSequence)
            (ß Symbol'intern("Cloneable"))                       (§ class Cloneable)
            (ß Symbol'intern("Comparable"))                      (§ class Comparable)
            (ß Symbol'intern("Iterable"))                        (§ class Iterable)
            (ß Symbol'intern("Readable"))                        (§ class Readable)
            (ß Symbol'intern("Runnable"))                        (§ class Runnable)
            (ß Symbol'intern("Callable"))                        (§ class Callable)
            (ß Symbol'intern("BigInteger"))                      (§ class BigInteger)
            (ß Symbol'intern("BigDecimal"))                      (§ class BigDecimal)
            (ß Symbol'intern("ArithmeticException"))             (§ class ArithmeticException)
            (ß Symbol'intern("ArrayIndexOutOfBoundsException"))  (§ class ArrayIndexOutOfBoundsException)
            (ß Symbol'intern("ArrayStoreException"))             (§ class ArrayStoreException)
            (ß Symbol'intern("ClassCastException"))              (§ class ClassCastException)
            (ß Symbol'intern("ClassNotFoundException"))          (§ class ClassNotFoundException)
            (ß Symbol'intern("CloneNotSupportedException"))      (§ class CloneNotSupportedException)
            (ß Symbol'intern("EnumConstantNotPresentException")) (§ class EnumConstantNotPresentException)
            (ß Symbol'intern("Exception"))                       (§ class Exception)
            (ß Symbol'intern("IllegalAccessException"))          (§ class IllegalAccessException)
            (ß Symbol'intern("IllegalArgumentException"))        (§ class IllegalArgumentException)
            (ß Symbol'intern("IllegalMonitorStateException"))    (§ class IllegalMonitorStateException)
            (ß Symbol'intern("IllegalStateException"))           (§ class IllegalStateException)
            (ß Symbol'intern("IllegalThreadStateException"))     (§ class IllegalThreadStateException)
            (ß Symbol'intern("IndexOutOfBoundsException"))       (§ class IndexOutOfBoundsException)
            (ß Symbol'intern("InstantiationException"))          (§ class InstantiationException)
            (ß Symbol'intern("InterruptedException"))            (§ class InterruptedException)
            (ß Symbol'intern("NegativeArraySizeException"))      (§ class NegativeArraySizeException)
            (ß Symbol'intern("NoSuchFieldException"))            (§ class NoSuchFieldException)
            (ß Symbol'intern("NoSuchMethodException"))           (§ class NoSuchMethodException)
            (ß Symbol'intern("NullPointerException"))            (§ class NullPointerException)
            (ß Symbol'intern("NumberFormatException"))           (§ class NumberFormatException)
            (ß Symbol'intern("RuntimeException"))                (§ class RuntimeException)
            (ß Symbol'intern("SecurityException"))               (§ class SecurityException)
            (ß Symbol'intern("StringIndexOutOfBoundsException")) (§ class StringIndexOutOfBoundsException)
            (ß Symbol'intern("TypeNotPresentException"))         (§ class TypeNotPresentException)
            (ß Symbol'intern("UnsupportedOperationException"))   (§ class UnsupportedOperationException)
            (ß Symbol'intern("AbstractMethodError"))             (§ class AbstractMethodError)
            (ß Symbol'intern("AssertionError"))                  (§ class AssertionError)
            (ß Symbol'intern("ClassCircularityError"))           (§ class ClassCircularityError)
            (ß Symbol'intern("ClassFormatError"))                (§ class ClassFormatError)
            (ß Symbol'intern("Error"))                           (§ class Error)
            (ß Symbol'intern("ExceptionInInitializerError"))     (§ class ExceptionInInitializerError)
            (ß Symbol'intern("IllegalAccessError"))              (§ class IllegalAccessError)
            (ß Symbol'intern("IncompatibleClassChangeError"))    (§ class IncompatibleClassChangeError)
            (ß Symbol'intern("InstantiationError"))              (§ class InstantiationError)
            (ß Symbol'intern("InternalError"))                   (§ class InternalError)
            (ß Symbol'intern("LinkageError"))                    (§ class LinkageError)
            (ß Symbol'intern("NoClassDefFoundError"))            (§ class NoClassDefFoundError)
            (ß Symbol'intern("NoSuchFieldError"))                (§ class NoSuchFieldError)
            (ß Symbol'intern("NoSuchMethodError"))               (§ class NoSuchMethodError)
            (ß Symbol'intern("OutOfMemoryError"))                (§ class OutOfMemoryError)
            (ß Symbol'intern("StackOverflowError"))              (§ class StackOverflowError)
            (ß Symbol'intern("ThreadDeath"))                     (§ class ThreadDeath)
            (ß Symbol'intern("UnknownError"))                    (§ class UnknownError)
            (ß Symbol'intern("UnsatisfiedLinkError"))            (§ class UnsatisfiedLinkError)
            (ß Symbol'intern("UnsupportedClassVersionError"))    (§ class UnsupportedClassVersionError)
            (ß Symbol'intern("VerifyError"))                     (§ class VerifyError)
            (ß Symbol'intern("VirtualMachineError"))             (§ class VirtualMachineError)
            (ß Symbol'intern("Thread$UncaughtExceptionHandler")) (§ class Thread$UncaughtExceptionHandler)
            (ß Symbol'intern("Thread$State"))                    (§ class Thread$State)
            (ß Symbol'intern("Deprecated"))                      (§ class Deprecated)
            (ß Symbol'intern("Override"))                        (§ class Override)
            (ß Symbol'intern("SuppressWarnings"))                (§ class SuppressWarnings)
        )
    )))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (§ def #_"Charset" RT'UTF8 (ß Charset/forName("UTF-8")))

    (§ defn #_"Object" RT'readTrueFalseUnknown [#_"String" ___s]
        (cond (ß ___s.equals("true"))
            (do
                (§ return (ß Boolean/TRUE))
            )
            (ß ___s.equals("false"))
            (do
                (§ return (ß Boolean/FALSE))
            )
        )
        (ß Keyword'intern(nil, "unknown"))
    )

    (§ def #_"Namespace" RT'CLOIURE_NS (ß Namespace'findOrCreate(Symbol'intern("cloiure.core"))))
    (§ def #_"Var" RT'OUT (ß Var'intern(CLOIURE_NS, Symbol'intern("*out*"), new OutputStreamWriter(System/out)).setDynamic()))
    (§ def #_"Var" RT'IN (ß Var'intern(CLOIURE_NS, Symbol'intern("*in*"), new LineNumberingPushbackReader(new InputStreamReader(System/in))).setDynamic()))
    (§ def #_"Var" RT'ERR (ß Var'intern(CLOIURE_NS, Symbol'intern("*err*"), new PrintWriter(new OutputStreamWriter(System/err), true)).setDynamic()))
    (§ def #_"Keyword" RT'TAG_KEY (ß Keyword'intern(nil, "tag")))
    (§ def #_"Keyword" RT'CONST_KEY (ß Keyword'intern(nil, "const")))
    (§ def #_"Var" RT'AGENT (ß Var'intern(CLOIURE_NS, Symbol'intern("*agent*"), nil).setDynamic()))
    (§ def #_"Object" RT'readeval (ß readTrueFalseUnknown(System/getProperty("cloiure.read.eval", "true"))))
    (§ def #_"Var" RT'READEVAL (ß Var'intern(CLOIURE_NS, Symbol'intern("*read-eval*"), readeval).setDynamic()))
    (§ def #_"Var" RT'DATA_READERS (ß Var'intern(CLOIURE_NS, Symbol'intern("*data-readers*"), RT'map()).setDynamic()))
    (§ def #_"Var" RT'DEFAULT_DATA_READER_FN (ß Var'intern(CLOIURE_NS, Symbol'intern("*default-data-reader-fn*"), RT'map()).setDynamic()))
    (§ def #_"Var" RT'DEFAULT_DATA_READERS (ß Var'intern(CLOIURE_NS, Symbol'intern("default-data-readers"), RT'map())))
    (§ def #_"Var" RT'SUPPRESS_READ (ß Var'intern(CLOIURE_NS, Symbol'intern("*suppress-read*"), nil).setDynamic()))
    (§ def #_"Var" RT'ASSERT (ß Var'intern(CLOIURE_NS, Symbol'intern("*assert*"), T).setDynamic()))
    (§ def #_"Var" RT'MATH_CONTEXT (ß Var'intern(CLOIURE_NS, Symbol'intern("*math-context*"), nil).setDynamic()))
    (§ def #_"Keyword" RT'LINE_KEY (ß Keyword'intern(nil, "line")))
    (§ def #_"Keyword" RT'COLUMN_KEY (ß Keyword'intern(nil, "column")))
    (§ def #_"Keyword" RT'FILE_KEY (ß Keyword'intern(nil, "file")))
    (§ def #_"Keyword" RT'DECLARED_KEY (ß Keyword'intern(nil, "declared")))
    (§ def #_"Keyword" RT'DOC_KEY (ß Keyword'intern(nil, "doc")))
    (§ def #_"Var" RT'USE_CONTEXT_CLASSLOADER (ß Var'intern(CLOIURE_NS, Symbol'intern("*use-context-classloader*"), T).setDynamic()))
    ;; boolean
    (§ def #_"Var" RT'UNCHECKED_MATH (ß Var'intern(Namespace'findOrCreate(Symbol'intern("cloiure.core")), Symbol'intern("*unchecked-math*"), Boolean/FALSE).setDynamic()))

    (§ def #_"Symbol" RT'LOAD_FILE (ß Symbol'intern("load-file")))
    (§ def #_"Symbol" RT'IN_NAMESPACE (ß Symbol'intern("in-ns")))
    (§ def #_"Symbol" RT'NAMESPACE (ß Symbol'intern("ns")))
    (§ def #_"Symbol" RT'IDENTICAL (ß Symbol'intern("identical?")))
    (§ def #_"Var" RT'CMD_LINE_ARGS (ß Var'intern(CLOIURE_NS, Symbol'intern("*command-line-args*"), nil).setDynamic()))
    ;; symbol
    (§ def #_"Var" RT'CURRENT_NS (ß Var'intern(CLOIURE_NS, Symbol'intern("*ns*"), CLOIURE_NS).setDynamic()))

    (§ def #_"Var" RT'FLUSH_ON_NEWLINE (ß Var'intern(CLOIURE_NS, Symbol'intern("*flush-on-newline*"), T).setDynamic()))
    (§ def #_"Var" RT'PRINT_META (ß Var'intern(CLOIURE_NS, Symbol'intern("*print-meta*"), F).setDynamic()))
    (§ def #_"Var" RT'PRINT_READABLY (ß Var'intern(CLOIURE_NS, Symbol'intern("*print-readably*"), T).setDynamic()))
    (§ def #_"Var" RT'PRINT_DUP (ß Var'intern(CLOIURE_NS, Symbol'intern("*print-dup*"), F).setDynamic()))
    (§ def #_"Var" RT'WARN_ON_REFLECTION (ß Var'intern(CLOIURE_NS, Symbol'intern("*warn-on-reflection*"), F).setDynamic()))
    (§ def #_"Var" RT'ALLOW_UNRESOLVED_VARS (ß Var'intern(CLOIURE_NS, Symbol'intern("*allow-unresolved-vars*"), F).setDynamic()))
    (§ def #_"Var" RT'READER_RESOLVER (ß Var'intern(CLOIURE_NS, Symbol'intern("*reader-resolver*"), nil).setDynamic()))

    (§ def #_"Var" RT'IN_NS_VAR (ß Var'intern(CLOIURE_NS, Symbol'intern("in-ns"), F)))
    (§ def #_"Var" RT'NS_VAR (ß Var'intern(CLOIURE_NS, Symbol'intern("ns"), F)))
    (§ def #_"Var" RT'FN_LOADER_VAR (ß Var'intern(CLOIURE_NS, Symbol'intern("*fn-loader*"), nil).setDynamic()))
    (§ def #_"Var" RT'PRINT_INITIALIZED (ß Var'intern(CLOIURE_NS, Symbol'intern("print-initialized"))))
    (§ def #_"Var" RT'PR_ON (ß Var'intern(CLOIURE_NS, Symbol'intern("pr-on"))))

    (§ def #_"IFn" RT'inNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1]
                (let [#_"Symbol" ___nsname (ß (Symbol) ___arg1)]
                    (let [#_"Namespace" ___ns (ß Namespace'findOrCreate(___nsname))]
                        (ß CURRENT_NS.set(___ns))
                        ns
                    )
                )
            )
        )
    )

    (§ def #_"IFn" RT'bootNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" _____form, #_"Object" _____env, #_"Object" ___arg1]
                (let [#_"Symbol" ___nsname (ß (Symbol) ___arg1)]
                    (let [#_"Namespace" ___ns (ß Namespace'findOrCreate(___nsname))]
                        (ß CURRENT_NS.set(___ns))
                        ns
                    )
                )
            )
        )
    )

    (§ defn #_"List<String>" RT'processCommandLine [#_"String[]" ___args]
        (let [#_"List<String>" ___arglist (ß Arrays/asList(___args))]
            (let [#_"int" ___split (ß ___arglist.indexOf("--"))]
                (when (ß ___split >= 0)
                    (ß CMD_LINE_ARGS.bindRoot(RT'seq(___arglist.subList(___split + 1, ___args.length))))
                    (§ return (ß ___arglist.subList(0, ___split)))
                )
                ___arglist
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (§ defn #_"PrintWriter" RT'errPrintWriter []
        (let [#_"Writer" ___w (ß (Writer) ERR.deref())]
            (if (ß ___w instanceof PrintWriter)
                (do
                    (ß (PrintWriter) ___w)
                )
                (do
                    (PrintWriter. ___w)
                )
            )
        )
    )

    (§ def #_"Object[]" RT'EMPTY_ARRAY (ß new Object[] (§ array )))
    (§ def #_"Comparator" RT'DEFAULT_COMPARATOR (DefaultComparator.))

    (§ def #_"AtomicInteger" RT'id (AtomicInteger. 1))

    (§ defn #_"void" RT'addURL [#_"Object" ___url] #_(§ throws MalformedURLException)
        (let [#_"URL" ___u (ß (___url instanceof String) ? (new URL((String) ___url)) :or (URL) ___url)]
            (let [#_"ClassLoader" ___ccl (ß Thread/currentThread().getContextClassLoader())]
                (if (ß ___ccl instanceof DynamicClassLoader)
                    (do
                        (ß ((DynamicClassLoader)___ccl).addURL(___u))
                    )
                    (do
                        (throw (IllegalAccessError. "Context classloader is not a DynamicClassLoader"))
                    )
                )
                nil
            )
        )
    )

    (§ def #_"boolean" RT'checkSpecAsserts (ß Boolean/getBoolean("cloiure.spec.check-asserts")))
    (§ def #_"boolean" RT'instrumentMacros (ß ! Boolean/getBoolean("cloiure.spec.skip-macros")))
    #_volatile
    (§ def #_"boolean" RT'CHECK_SPECS false)

    (§ static
        (let [#_"Keyword" ___arglistskw (ß Keyword'intern(nil, "arglists"))]
            (let [#_"Symbol" ___namesym (ß Symbol'intern("name"))]
                (ß OUT.setTag(Symbol'intern("java.io.Writer")))
                (ß CURRENT_NS.setTag(Symbol'intern("cloiure.lang.Namespace")))
                (ß AGENT.setMeta(map(DOC_KEY, "The agent currently running an action on this thread, else nil")))
                (ß AGENT.setTag(Symbol'intern("cloiure.lang.Agent")))
                (ß MATH_CONTEXT.setTag(Symbol'intern("java.math.MathContext")))
                (let [#_"Var" ___nv (ß Var'intern(CLOIURE_NS, NAMESPACE, bootNamespace))]
                    (ß ___nv.setMacro())
                    (§ let [#_"Var" ___v]
                        (§ ass ___v (ß Var'intern(CLOIURE_NS, IN_NAMESPACE, inNamespace)))
                        (ß ___v.setMeta(map(DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", ___arglistskw, list(vector(___namesym)))))
                        (§ ass ___v (ß Var'intern(CLOIURE_NS, LOAD_FILE,
                                (§ reify AFn()
                                    #_method
                                    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1]
                                        (try
                                            (ß Compiler'loadFile((String) ___arg1))
                                            (catch IOException ___e
                                                (throw (ß Util'sneakyThrow(___e)))
                                            )
                                        )
                                    )
                                )
                            ))
                        )
                        (ß ___v.setMeta(map(DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", ___arglistskw, list(vector(___namesym)))))
                        (try
                            (ß doInit())
                            (catch Exception ___e
                                (throw (ß Util'sneakyThrow(___e)))
                            )
                        )

                        (§ ass CHECK_SPECS (ß RT'instrumentMacros))
                    )
                )
            )
        )
    )

    (§ defn #_"Keyword" RT'keyword [#_"String" ___ns, #_"String" ___name]
        (ß Keyword'intern((Symbol'intern(___ns, ___name))))
    )

    (§ defn #_"Var" RT'var [#_"String" ___ns, #_"String" ___name]
        (ß Var'intern(Namespace'findOrCreate(Symbol'intern(nil, ___ns)), Symbol'intern(nil, ___name)))
    )

    (§ defn #_"Var" RT'var [#_"String" ___ns, #_"String" ___name, #_"Object" ___init]
        (ß Var'intern(Namespace'findOrCreate(Symbol'intern(nil, ___ns)), Symbol'intern(nil, ___name), ___init))
    )

    (§ defn #_"void" RT'loadResourceScript [#_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___name, true))
        nil
    )

    (§ defn #_"void" RT'maybeLoadResourceScript [#_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___name, false))
        nil
    )

    (§ defn #_"void" RT'loadResourceScript [#_"String" ___name, #_"boolean" ___failIfNotFound] #_(§ throws IOException)
        (ß loadResourceScript((§ class RT), ___name, ___failIfNotFound))
        nil
    )

    (§ defn #_"void" RT'loadResourceScript [#_"Class" ___c, #_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___c, ___name, true))
        nil
    )

    (§ defn #_"void" RT'loadResourceScript [#_"Class" ___c, #_"String" ___name, #_"boolean" ___failIfNotFound] #_(§ throws IOException)
        (let [#_"int" ___slash (ß ___name.lastIndexOf(\/))]
            (let [#_"String" ___file (ß (___slash >= 0) ? ___name.substring(___slash + 1) :or ___name)]
                (let [#_"InputStream" ___ins (ß resourceAsStream(baseLoader(), ___name))]
                    (cond (some? ___ins)
                        (do
                            (try
                                (ß Compiler'load(new InputStreamReader(___ins, UTF8), ___name, ___file))
                                (finally
                                    (ß ___ins.close())
                                )
                            )
                        )
                        ___failIfNotFound
                        (do
                            (throw (FileNotFoundException. (ß "Could not locate Cloiure resource on classpath: " + ___name)))
                        )
                    )
                    nil
                )
            )
        )
    )

    (§ defn #_"long" RT'lastModified [#_"URL" ___url, #_"String" ___libfile] #_(§ throws IOException)
        (let [#_"URLConnection" ___connection (ß ___url.openConnection())]
            (try
                (if (ß ___url.getProtocol().equals("jar"))
                    (do
                        (ß ((JarURLConnection) ___connection).getJarFile().getEntry(___libfile).getTime())
                    )
                    (do
                        (ß ___connection.getLastModified())
                    )
                )
                (finally
                    (let [#_"InputStream" ___ins (ß ___connection.getInputStream())]
                        (when (some? ___ins)
                            (ß ___ins.close())
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" RT'compile [#_"String" ___cljfile] #_(§ throws IOException)
        (let [#_"InputStream" ___ins (ß resourceAsStream(baseLoader(), ___cljfile))]
            (if (some? ___ins)
                (do
                    (try
                        (ß Compiler'compile(new InputStreamReader(___ins, UTF8), ___cljfile, ___cljfile.substring(1 + ___cljfile.lastIndexOf("/"))))
                        (finally
                            (ß ___ins.close())
                        )
                    )
                )
                (do
                    (throw (FileNotFoundException. (ß "Could not locate Cloiure resource on classpath: " + ___cljfile)))
                )
            )
            nil
        )
    )

    (§ defn #_"void" RT'load [#_"String" ___scriptbase] #_(§ throws IOException, ClassNotFoundException)
        (ß load(___scriptbase, true))
        nil
    )

    (§ defn #_"void" RT'load [#_"String" ___scriptbase, #_"boolean" ___failIfNotFound] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"String" ___classfile (ß ___scriptbase + LOADER_SUFFIX + ".class")]
            (let [#_"String" ___cljfile (ß ___scriptbase + ".cli")]
                (let [#_"String" ___scriptfile ___cljfile]
                    (let [#_"URL" ___classURL (ß getResource(baseLoader(), ___classfile))]
                        (let [#_"URL" ___cljURL (ß getResource(baseLoader(), ___scriptfile))]
                            (when (nil? ___cljURL)
                                (§ ass ___scriptfile (ß ___scriptbase + ".clic"))
                                (§ ass ___cljURL (ß getResource(baseLoader(), ___scriptfile)))
                            )
                            (let [#_"boolean" ___loaded false]
                                (when (ß (___classURL != nil && (___cljURL == nil || lastModified(___classURL, ___classfile) > lastModified(___cljURL, ___scriptfile))) || ___classURL == nil)
                                    (try
                                        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                            (§ map
                                                CURRENT_NS            (ß CURRENT_NS.deref())
                                                WARN_ON_REFLECTION    (ß WARN_ON_REFLECTION.deref())
                                                (ß RT'UNCHECKED_MATH) (ß RT'UNCHECKED_MATH.deref())
                                            )
                                        )))
                                        (§ ass ___loaded (ß (loadClassForName(___scriptbase.replace(\/, \.) + LOADER_SUFFIX) != nil)))
                                        (finally
                                            (ß Var'popThreadBindings())
                                        )
                                    )
                                )
                                (cond (ß !___loaded && ___cljURL != nil)
                                    (do
                                        (if (ß booleanCast(Compiler'COMPILE_FILES.deref()))
                                            (do
                                                (ß compile(___scriptfile))
                                            )
                                            (do
                                                (ß loadResourceScript((§ class RT), ___scriptfile))
                                            )
                                        )
                                    )
                                    (ß !___loaded && ___failIfNotFound)
                                    (do
                                        (throw (ß new FileNotFoundException(String/format("Could not locate %s or %s on classpath.%s", ___classfile, ___cljfile, ___scriptbase.contains("_") ? " Please check that namespaces with dashes use underscores in the Cloiure file name." :or ""))))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"void" RT'doInit [] #_(§ throws ClassNotFoundException, IOException)
        (ß load("cloiure/core"))

        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
            (§ map
                CURRENT_NS            (ß CURRENT_NS.deref())
                WARN_ON_REFLECTION    (ß WARN_ON_REFLECTION.deref())
                (ß RT'UNCHECKED_MATH) (ß RT'UNCHECKED_MATH.deref())
            )
        )))
        (try
            (let [#_"Symbol" ___USER (ß Symbol'intern("user"))]
                (let [#_"Symbol" ___CLOIURE (ß Symbol'intern("cloiure.core"))]
                    (let [#_"Var" ___in_ns (ß var("cloiure.core", "in-ns"))]
                        (let [#_"Var" ___refer (ß var("cloiure.core", "refer"))]
                            (ß ___in_ns.invoke(___USER))
                            (ß ___refer.invoke(___CLOIURE))
                            (ß maybeLoadResourceScript("user.cli"))

                            ;; start socket servers
                            (let [#_"Var" ___require (ß var("cloiure.core", "require"))]
                                (let [#_"Symbol" ___SERVER (ß Symbol'intern("cloiure.core.server"))]
                                    (ß ___require.invoke(___SERVER))
                                    (let [#_"Var" ___start_servers (ß var("cloiure.core.server", "start-servers"))]
                                        (ß ___start_servers.invoke(System/getProperties()))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (ß Var'popThreadBindings())
            )
        )
        nil
    )

    (§ defn #_"int" RT'nextID []
        (ß id.getAndIncrement())
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    (§ defn #_"void" RT'loadLibrary [#_"String" ___libname]
        (ß System/loadLibrary(___libname))
        nil
    )

    (§ def- #_"int" RT'CHUNK_SIZE 32)

    (§ defn #_"ISeq" RT'chunkIteratorSeq [#_"Iterator" ___iter]
        (when (ß ___iter.hasNext())
            (§ return (ß new LazySeq(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this]
                            (let [#_"Object[]" ___arr (ß new Object[CHUNK_SIZE])]
                                (let [#_"int" ___n 0]
                                    (while (ß ___iter.hasNext() && ___n < CHUNK_SIZE)
                                        (§ ass (ß ___arr[___n]) (ß ___iter.next()))
                                        (§ ass ___n (ß ___n + 1))
                                    )
                                    (ß new ChunkedCons(new ArrayChunk(___arr, 0, ___n), chunkIteratorSeq(___iter)))
                                )
                            )
                        )
                    )
                ))
            )
        )
        nil
    )

    (§ defn #_"ISeq" RT'seq [#_"Object" ___coll]
        (cond (ß ___coll instanceof ASeq)
            (do
                (ß (ASeq) ___coll)
            )
            (ß ___coll instanceof LazySeq)
            (do
                (ß ((LazySeq) ___coll).seq())
            )
            :else
            (do
                (ß seqFrom(___coll))
            )
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (§ defn #_"ISeq" RT'seqFrom [#_"Object" ___coll]
        (cond (ß ___coll instanceof Seqable)
            (do
                (ß ((Seqable) ___coll).seq())
            )
            (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof Iterable)
            (do
                (ß chunkIteratorSeq(((Iterable) ___coll).iterator()))
            )
            (ß ___coll.getClass().isArray())
            (do
                (ß ArraySeq'createFromObject(___coll))
            )
            (ß ___coll instanceof CharSequence)
            (do
                (ß StringSeq'create((CharSequence) ___coll))
            )
            (ß ___coll instanceof Map)
            (do
                (ß seq(((Map) ___coll).entrySet()))
            )
            :else
            (do
                (let [#_"Class" ___c (ß ___coll.getClass())]
                    (let [#_"Class" ___sc (ß ___c.getSuperclass())]
                        (throw (ß new IllegalArgumentException("Don't know how to create ISeq from: " + ___c.getName())))
                    )
                )
            )
        )
    )

    (§ defn #_"boolean" RT'canSeq [#_"Object" ___coll]
        (ß ___coll instanceof ISeq
            || ___coll instanceof Seqable
            || ___coll == nil
            || ___coll instanceof Iterable
            || ___coll.getClass().isArray()
            || ___coll instanceof CharSequence
            || ___coll instanceof Map)
    )

    (§ defn #_"Iterator" RT'iter [#_"Object" ___coll]
        (cond (ß ___coll instanceof Iterable)
            (do
                (ß ((Iterable)___coll).iterator())
            )
            (nil? ___coll)
            (do
                (§ reify Iterator()
                    #_method
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        false
                    )

                    #_method
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (throw (NoSuchElementException.))
                    )

                    #_method
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
            (ß ___coll instanceof Map)
            (do
                (ß ((Map)___coll).entrySet().iterator())
            )
            (ß ___coll instanceof String)
            (do
                (let [#_"String" ___s (ß (String) ___coll)]
                    (§ reify Iterator()
                        (let [#_"int" ___i 0]
                            #_method
                            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                                (ß (___i < ___s.length()))
                            )

                            #_method
                            (§ defn #_"Object" next [#_"Iterator" this]
                                (let [_ (ß ___s.charAt(___i))]
                                    (§ ass ___i (ß ___i + 1))
                                    _
                                )
                            )

                            #_method
                            (§ defn #_"void" remove [#_"Iterator" this]
                                (throw (UnsupportedOperationException.))
                            )
                        )
                    )
                )
            )
            (ß ___coll.getClass().isArray())
            (do
                (ß ArrayIter'createFromObject(___coll))
            )
            :else
            (do
                (ß iter(seq(___coll)))
            )
        )
    )

    (§ defn #_"Object" RT'seqOrElse [#_"Object" ___o]
        (ß (seq(___o) == nil) ? nil :or ___o)
    )

    (§ defn #_"ISeq" RT'keys [#_"Object" ___coll]
        (if (ß ___coll instanceof IPersistentMap)
            (do
                (ß KeySeq'createFromMap((IPersistentMap)___coll))
            )
            (do
                (ß KeySeq'create(seq(___coll)))
            )
        )
    )

    (§ defn #_"ISeq" RT'vals [#_"Object" ___coll]
        (if (ß ___coll instanceof IPersistentMap)
            (do
                (ß ValSeq'createFromMap((IPersistentMap)___coll))
            )
            (do
                (ß ValSeq'create(seq(___coll)))
            )
        )
    )

    (§ defn #_"IPersistentMap" RT'meta [#_"Object" ___x]
        (when (ß ___x instanceof IMeta)
            (§ return (ß ((IMeta) ___x).meta()))
        )
        nil
    )

    (§ defn #_"int" RT'count [#_"Object" ___o]
        (when (ß ___o instanceof Counted)
            (§ return (ß ((Counted) ___o).count()))
        )
        (ß countFrom(Util'ret1(___o, (§ ass ___o nil))))
    )

    (§ defn #_"int" RT'countFrom [#_"Object" ___o]
        (cond (nil? ___o)
            (do
                (§ return 0)
            )
            (ß ___o instanceof IPersistentCollection)
            (do
                (let [#_"ISeq" ___s (ß seq(___o))]
                    (§ ass ___o nil)
                    (let [#_"int" ___i 0]
                        (loop-when-recur [(ß )] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                            (when (ß ___s instanceof Counted)
                                (§ return (ß ___i + ___s.count()))
                            )
                            (§ ass ___i (ß ___i + 1))
                        )
                        (§ return ___i)
                    )
                )
            )
            (ß ___o instanceof CharSequence)
            (do
                (§ return (ß ((CharSequence) ___o).length()))
            )
            (ß ___o instanceof Collection)
            (do
                (§ return (ß ((Collection) ___o).size()))
            )
            (ß ___o instanceof Map)
            (do
                (§ return (ß ((Map) ___o).size()))
            )
            (ß ___o instanceof Map$Entry)
            (do
                (§ return 2)
            )
            (ß ___o.getClass().isArray())
            (do
                (§ return (ß Array/getLength(___o)))
            )
        )

        (throw (ß new UnsupportedOperationException("count not supported on this type: " + ___o.getClass().getSimpleName())))
    )

    (§ defn #_"IPersistentCollection" RT'conj [#_"IPersistentCollection" ___coll, #_"Object" ___x]
        (when (nil? ___coll)
            (§ return (PersistentList. ___x))
        )
        (ß ___coll.cons(___x))
    )

    (§ defn #_"ISeq" RT'cons [#_"Object" ___x, #_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                (PersistentList. ___x)
            )
            (ß ___coll instanceof ISeq)
            (do
                (ß new Cons(___x, (ISeq) ___coll))
            )
            :else
            (do
                (ß new Cons(___x, seq(___coll)))
            )
        )
    )

    (§ defn #_"Object" RT'first [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß ((ISeq) ___x).first()))
        )
        (let [#_"ISeq" ___seq (ß seq(___x))]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ß ___seq.first())
        )
    )

    (§ defn #_"Object" RT'second [#_"Object" ___x]
        (ß first(next(___x)))
    )

    (§ defn #_"Object" RT'third [#_"Object" ___x]
        (ß first(next(next(___x))))
    )

    (§ defn #_"Object" RT'fourth [#_"Object" ___x]
        (ß first(next(next(next(___x)))))
    )

    (§ defn #_"ISeq" RT'next [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß ((ISeq) ___x).next()))
        )
        (let [#_"ISeq" ___seq (ß seq(___x))]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ß ___seq.next())
        )
    )

    (§ defn #_"ISeq" RT'more [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß ((ISeq) ___x).more()))
        )
        (let [#_"ISeq" ___seq (ß seq(___x))]
            (when (nil? ___seq)
                (§ return (ß PersistentList'EMPTY))
            )
            (ß ___seq.more())
        )
    )

    (§ defn #_"Object" RT'peek [#_"Object" ___x]
        (when (nil? ___x)
            (§ return nil)
        )
        (ß ((IPersistentStack) ___x).peek())
    )

    (§ defn #_"Object" RT'pop [#_"Object" ___x]
        (when (nil? ___x)
            (§ return nil)
        )
        (ß ((IPersistentStack) ___x).pop())
    )

    (§ defn #_"Object" RT'get [#_"Object" ___coll, #_"Object" ___key]
        (when (ß ___coll instanceof ILookup)
            (§ return (ß ((ILookup) ___coll).valAt(___key)))
        )
        (ß getFrom(___coll, ___key))
    )

    (§ defn #_"Object" RT'getFrom [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return nil)
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (§ return (ß ___m.get(___key)))
                )
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" ___set (ß (IPersistentSet) ___coll)]
                    (§ return (ß ___set.get(___key)))
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || ___coll.getClass().isArray()))
            (do
                (let [#_"int" ___n (ß ((Number) ___key).intValue())]
                    (when (ß ___n >= 0 && ___n < count(___coll))
                        (§ return (ß nth(___coll, ___n)))
                    )
                    (§ return nil)
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" ___set (ß (ITransientSet) ___coll)]
                    (§ return (ß ___set.get(___key)))
                )
            )
        )

        nil
    )

    (§ defn #_"Object" RT'get [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___notFound]
        (when (ß ___coll instanceof ILookup)
            (§ return (ß ((ILookup) ___coll).valAt(___key, ___notFound)))
        )
        (ß getFrom(___coll, ___key, ___notFound))
    )

    (§ defn #_"Object" RT'getFrom [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___notFound]
        (cond (nil? ___coll)
            (do
                (§ return ___notFound)
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (when (ß ___m.containsKey(___key))
                        (§ return (ß ___m.get(___key)))
                    )
                    (§ return ___notFound)
                )
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" ___set (ß (IPersistentSet) ___coll)]
                    (when (ß ___set.contains(___key))
                        (§ return (ß ___set.get(___key)))
                    )
                    (§ return ___notFound)
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || ___coll.getClass().isArray()))
            (do
                (let [#_"int" ___n (ß ((Number) ___key).intValue())]
                    (§ return (ß (___n >= 0 && ___n < count(___coll)) ? nth(___coll, ___n) :or ___notFound))
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" ___set (ß (ITransientSet) ___coll)]
                    (when (ß ___set.contains(___key))
                        (§ return (ß ___set.get(___key)))
                    )
                    (§ return ___notFound)
                )
            )
        )
        notFound
    )

    (§ defn #_"Associative" RT'assoc [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___coll)
            (§ return (ß new PersistentArrayMap(new Object[] (§ array ___key, ___val ))))
        )
        (ß ((Associative) ___coll).assoc(___key, ___val))
    )

    (§ defn #_"Object" RT'contains [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return F)
            )
            (ß ___coll instanceof Associative)
            (do
                (§ return (ß ((Associative) ___coll).containsKey(___key) ? T :or F))
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (§ return (ß ((IPersistentSet) ___coll).contains(___key) ? T :or F))
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (§ return (ß ___m.containsKey(___key) ? T :or F))
                )
            )
            (ß ___coll instanceof Set)
            (do
                (let [#_"Set" ___s (ß (Set) ___coll)]
                    (§ return (ß ___s.contains(___key) ? T :or F))
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || ___coll.getClass().isArray()))
            (do
                (let [#_"int" ___n (ß ((Number) ___key).intValue())]
                    (§ return (ß (___n >= 0 && ___n < count(___coll)) ? T :or F))
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (§ return (ß ((ITransientSet)___coll).contains(___key) ? T :or F))
            )
            (ß ___coll instanceof ITransientAssociative2)
            (do
                (§ return (ß (((ITransientAssociative2)___coll).containsKey(___key)) ? T :or F))
            )
        )
        (throw (ß new IllegalArgumentException("contains? not supported on type: " + ___coll.getClass().getName())))
    )

    (§ defn #_"Object" RT'find [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return nil)
            )
            (ß ___coll instanceof Associative)
            (do
                (§ return (ß ((Associative) ___coll).entryAt(___key)))
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (when (ß ___m.containsKey(___key))
                        (§ return (ß MapEntry'create(___key, ___m.get(___key))))
                    )
                    (§ return nil)
                )
            )
            (ß ___coll instanceof ITransientAssociative2)
            (do
                (§ return (ß ((ITransientAssociative2) ___coll).entryAt(___key)))
            )
        )
        (throw (ß new IllegalArgumentException("find not supported on type: " + ___coll.getClass().getName())))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    (§ defn #_"ISeq" RT'findKey [#_"Keyword" ___key, #_"ISeq" ___keyvals]
        (while (some? ___keyvals)
            (let [#_"ISeq" ___r (ß ___keyvals.next())]
                (when (nil? ___r)
                    (throw (ß Util'runtimeException("Malformed keyword argslist")))
                )
                (when (ß ___keyvals.first() == ___key)
                    (§ return ___r)
                )
                (§ ass ___keyvals (ß ___r.next()))
            )
        )
        nil
    )

    (§ defn #_"Object" RT'dissoc [#_"Object" ___coll, #_"Object" ___key]
        (when (nil? ___coll)
            (§ return nil)
        )
        (ß ((IPersistentMap) ___coll).without(___key))
    )

    (§ defn #_"Object" RT'nth [#_"Object" ___coll, #_"int" ___n]
        (when (ß ___coll instanceof Indexed)
            (§ return (ß ((Indexed) ___coll).nth(___n)))
        )
        (ß nthFrom(Util'ret1(___coll, (§ ass ___coll nil)), ___n))
    )

    (§ defn #_"Object" RT'nthFrom [#_"Object" ___coll, #_"int" ___n]
        (cond (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof CharSequence)
            (do
                (ß Character/valueOf(((CharSequence) ___coll).charAt(___n)))
            )
            (ß ___coll.getClass().isArray())
            (do
                (ß Reflector'prepRet(___coll.getClass().getComponentType(), Array/get(___coll, ___n)))
            )
            (ß ___coll instanceof RandomAccess)
            (do
                (ß ((List) ___coll).get(___n))
            )
            (ß ___coll instanceof Matcher)
            (do
                (ß ((Matcher) ___coll).group(___n))
            )
            (ß ___coll instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___coll)]
                    (cond (ß ___n == 0)
                        (do
                            (§ return (ß ___e.getKey()))
                        )
                        (ß ___n == 1)
                        (do
                            (§ return (ß ___e.getValue()))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            (ß ___coll instanceof Sequential)
            (do
                (let [#_"ISeq" ___seq (ß RT'seq(___coll))]
                    (§ ass ___coll nil)
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i <= ___n && ___seq != nil) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                        (when (ß ___i == ___n)
                            (§ return (ß ___seq.first()))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("nth not supported on this type: " + ___coll.getClass().getSimpleName())))
            )
        )
    )

    (§ defn #_"Object" RT'nth [#_"Object" ___coll, #_"int" ___n, #_"Object" ___notFound]
        (when (ß ___coll instanceof Indexed)
            (let [#_"Indexed" ___v (ß (Indexed) ___coll)]
                (§ return (ß ___v.nth(___n, ___notFound)))
            )
        )
        (ß nthFrom(___coll, ___n, ___notFound))
    )

    (§ defn #_"Object" RT'nthFrom [#_"Object" ___coll, #_"int" ___n, #_"Object" ___notFound]
        (cond (nil? ___coll)
            (do
                ___notFound
            )
            (ß ___n < 0)
            (do
                ___notFound
            )
            (ß ___coll instanceof CharSequence)
            (do
                (let [#_"CharSequence" ___s (ß (CharSequence) ___coll)]
                    (when (ß ___n < ___s.length())
                        (§ return (ß Character/valueOf(___s.charAt(___n))))
                    )
                    ___notFound
                )
            )
            (ß ___coll.getClass().isArray())
            (do
                (when (ß ___n < Array/getLength(___coll))
                    (§ return (ß Reflector'prepRet(___coll.getClass().getComponentType(), Array/get(___coll, ___n))))
                )
                ___notFound
            )
            (ß ___coll instanceof RandomAccess)
            (do
                (let [#_"List" ___list (ß (List) ___coll)]
                    (when (ß ___n < ___list.size())
                        (§ return (ß ___list.get(___n)))
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Matcher)
            (do
                (let [#_"Matcher" ___m (ß (Matcher) ___coll)]
                    (when (ß ___n < ___m.groupCount())
                        (§ return (ß ___m.group(___n)))
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___coll)]
                    (cond (ß ___n == 0)
                        (do
                            (§ return (ß ___e.getKey()))
                        )
                        (ß ___n == 1)
                        (do
                            (§ return (ß ___e.getValue()))
                        )
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Sequential)
            (do
                (let [#_"ISeq" ___seq (ß RT'seq(___coll))]
                    (§ ass ___coll nil)
                    (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i <= ___n && ___seq != nil) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                        (when (ß ___i == ___n)
                            (§ return (ß ___seq.first()))
                        )
                    )
                    ___notFound
                )
            )
            :else
            (do
                (throw (ß new UnsupportedOperationException("nth not supported on this type: " + ___coll.getClass().getSimpleName())))
            )
        )
    )

    (§ defn #_"Object" RT'assocN [#_"int" ___n, #_"Object" ___val, #_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof IPersistentVector)
            (do
                (ß ((IPersistentVector) ___coll).assocN(___n, ___val))
            )
            (ß ___coll instanceof Object[])
            (do
                ;; hmm... this is not persistent
                (let [#_"Object[]" ___array (ß ((Object[]) ___coll))]
                    (§ ass (ß ___array[___n]) ___val)
                    array
                )
            )
            :else
            (do
                nil
            )
        )
    )

    (§ defn #_"boolean" RT'hasTag [#_"Object" ___o, #_"Object" ___tag]
        (ß Util'equals(___tag, RT'get(RT'meta(___o), TAG_KEY)))
    )

    (§ defn #_"Object" RT'box [#_"Object" ___x]
        x
    )

    (§ defn #_"Character" RT'box [#_"char" ___x]
        (ß Character/valueOf(___x))
    )

    (§ defn #_"Object" RT'box [#_"boolean" ___x]
        (ß ___x ? T :or F)
    )

    (§ defn #_"Object" RT'box [#_"Boolean" ___x]
        x
    )

    (§ defn #_"Number" RT'box [#_"byte" ___x]
        x
    )

    (§ defn #_"Number" RT'box [#_"short" ___x]
        x
    )

    (§ defn #_"Number" RT'box [#_"int" ___x]
        x
    )

    (§ defn #_"Number" RT'box [#_"long" ___x]
        x
    )

    (§ defn #_"Number" RT'box [#_"float" ___x]
        x
    )

    (§ defn #_"Number" RT'box [#_"double" ___x]
        x
    )

    (§ defn #_"char" RT'charCast [#_"Object" ___x]
        (when (ß ___x instanceof Character)
            (§ return (ß ((Character) ___x).charValue()))
        )
        (let [#_"long" ___n (ß ((Number) ___x).longValue())]
            (when (ß ___n < Character/MIN_VALUE || ___n > Character/MAX_VALUE)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + ___x)))
            )
            (ß (char) ___n)
        )
    )

    (§ defn #_"char" RT'charCast [#_"byte" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"char" RT'charCast [#_"short" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"char" RT'charCast [#_"char" ___x]
        x
    )

    (§ defn #_"char" RT'charCast [#_"int" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"char" RT'charCast [#_"long" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for char: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"char" RT'charCast [#_"float" ___x]
        (when (ß ___x >= Character/MIN_VALUE && ___x <= Character/MAX_VALUE)
            (§ return (ß (char) ___x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for char: " + ___x)))
    )

    (§ defn #_"char" RT'charCast [#_"double" ___x]
        (when (ß ___x >= Character/MIN_VALUE && ___x <= Character/MAX_VALUE)
            (§ return (ß (char) ___x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for char: " + ___x)))
    )

    (§ defn #_"boolean" RT'booleanCast [#_"Object" ___x]
        (when (ß ___x instanceof Boolean)
            (§ return (ß ((Boolean) ___x).booleanValue()))
        )
        (ß (___x != nil))
    )

    (§ defn #_"boolean" RT'booleanCast [#_"boolean" ___x]
        x
    )

    (§ defn #_"byte" RT'byteCast [#_"Object" ___x]
        (when (ß ___x instanceof Byte)
            (§ return (ß ((Byte) ___x).byteValue()))
        )
        (let [#_"long" ___n (ß longCast(___x))]
            (when (ß ___n < Byte/MIN_VALUE || ___n > Byte/MAX_VALUE)
                (throw (IllegalArgumentException. (ß "Value out of range for byte: " + ___x)))
            )
            (ß (byte) ___n)
        )
    )

    (§ defn #_"byte" RT'byteCast [#_"byte" ___x]
        x
    )

    (§ defn #_"byte" RT'byteCast [#_"short" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for byte: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"byte" RT'byteCast [#_"int" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for byte: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"byte" RT'byteCast [#_"long" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for byte: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"byte" RT'byteCast [#_"float" ___x]
        (when (ß ___x >= Byte/MIN_VALUE && ___x <= Byte/MAX_VALUE)
            (§ return (ß (byte) ___x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for byte: " + ___x)))
    )

    (§ defn #_"byte" RT'byteCast [#_"double" ___x]
        (when (ß ___x >= Byte/MIN_VALUE && ___x <= Byte/MAX_VALUE)
            (§ return (ß (byte) ___x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for byte: " + ___x)))
    )

    (§ defn #_"short" RT'shortCast [#_"Object" ___x]
        (when (ß ___x instanceof Short)
            (§ return (ß ((Short) ___x).shortValue()))
        )
        (let [#_"long" ___n (ß longCast(___x))]
            (when (ß ___n < Short/MIN_VALUE || ___n > Short/MAX_VALUE)
                (throw (IllegalArgumentException. (ß "Value out of range for short: " + ___x)))
            )
            (ß (short) ___n)
        )
    )

    (§ defn #_"short" RT'shortCast [#_"byte" ___x]
        x
    )

    (§ defn #_"short" RT'shortCast [#_"short" ___x]
        x
    )

    (§ defn #_"short" RT'shortCast [#_"int" ___x]
        (let [#_"short" ___i (ß (short) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for short: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"short" RT'shortCast [#_"long" ___x]
        (let [#_"short" ___i (ß (short) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for short: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"short" RT'shortCast [#_"float" ___x]
        (when (ß ___x >= Short/MIN_VALUE && ___x <= Short/MAX_VALUE)
            (§ return (ß (short) ___x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for short: " + ___x)))
    )

    (§ defn #_"short" RT'shortCast [#_"double" ___x]
        (when (ß ___x >= Short/MIN_VALUE && ___x <= Short/MAX_VALUE)
            (§ return (ß (short) ___x))
        )
        (throw (IllegalArgumentException. (ß "Value out of range for short: " + ___x)))
    )

    (§ defn #_"int" RT'intCast [#_"Object" ___x]
        (when (ß ___x instanceof Integer)
            (§ return (ß ((Integer)___x).intValue()))
        )
        (when (ß ___x instanceof Number)
            (let [#_"long" ___n (ß longCast(___x))]
                (§ return (ß intCast(___n)))
            )
        )
        (ß ((Character) ___x).charValue())
    )

    (§ defn #_"int" RT'intCast [#_"char" ___x]
        x
    )

    (§ defn #_"int" RT'intCast [#_"byte" ___x]
        x
    )

    (§ defn #_"int" RT'intCast [#_"short" ___x]
        x
    )

    (§ defn #_"int" RT'intCast [#_"int" ___x]
        x
    )

    (§ defn #_"int" RT'intCast [#_"float" ___x]
        (when (ß ___x < Integer/MIN_VALUE || ___x > Integer/MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for int: " + ___x)))
        )
        (ß (int) ___x)
    )

    (§ defn #_"int" RT'intCast [#_"long" ___x]
        (let [#_"int" ___i (ß (int) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (ß "Value out of range for int: " + ___x)))
            )
            i
        )
    )

    (§ defn #_"int" RT'intCast [#_"double" ___x]
        (when (ß ___x < Integer/MIN_VALUE || ___x > Integer/MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for int: " + ___x)))
        )
        (ß (int) ___x)
    )

    (§ defn #_"long" RT'longCast [#_"Object" ___x]
        (cond (ß ___x instanceof Integer || ___x instanceof Long)
            (do
                (ß ((Number) ___x).longValue())
            )
            (ß ___x instanceof BigInt)
            (do
                (let [#_"BigInt" ___bi (ß (BigInt) ___x)]
                    (if (ß ___bi.bipart == nil)
                        (do
                            (ß ___bi.lpart)
                        )
                        (do
                            (throw (IllegalArgumentException. (ß "Value out of range for long: " + ___x)))
                        )
                    )
                )
            )
            (ß ___x instanceof BigInteger)
            (do
                (let [#_"BigInteger" ___bi (ß (BigInteger) ___x)]
                    (if (ß ___bi.bitLength() < 64)
                        (do
                            (ß ___bi.longValue())
                        )
                        (do
                            (throw (IllegalArgumentException. (ß "Value out of range for long: " + ___x)))
                        )
                    )
                )
            )
            (ß ___x instanceof Byte || ___x instanceof Short)
            (do
                (ß ((Number) ___x).longValue())
            )
            (ß ___x instanceof Ratio)
            (do
                (ß longCast(((Ratio)___x).bigIntegerValue()))
            )
            (ß ___x instanceof Character)
            (do
                (ß longCast(((Character) ___x).charValue()))
            )
            :else
            (do
                (ß longCast(((Number)___x).doubleValue()))
            )
        )
    )

    (§ defn #_"long" RT'longCast [#_"byte" ___x]
        x
    )

    (§ defn #_"long" RT'longCast [#_"short" ___x]
        x
    )

    (§ defn #_"long" RT'longCast [#_"int" ___x]
        x
    )

    (§ defn #_"long" RT'longCast [#_"float" ___x]
        (when (ß ___x < Long/MIN_VALUE || ___x > Long/MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for long: " + ___x)))
        )
        (ß (long) ___x)
    )

    (§ defn #_"long" RT'longCast [#_"long" ___x]
        x
    )

    (§ defn #_"long" RT'longCast [#_"double" ___x]
        (when (ß ___x < Long/MIN_VALUE || ___x > Long/MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for long: " + ___x)))
        )
        (ß (long) ___x)
    )

    (§ defn #_"float" RT'floatCast [#_"Object" ___x]
        (when (ß ___x instanceof Float)
            (§ return (ß ((Float) ___x).floatValue()))
        )
        (let [#_"double" ___n (ß ((Number) ___x).doubleValue())]
            (when (ß ___n < -Float/MAX_VALUE || ___n > Float/MAX_VALUE)
                (throw (IllegalArgumentException. (ß "Value out of range for float: " + ___x)))
            )
            (ß (float) ___n)
        )
    )

    (§ defn #_"float" RT'floatCast [#_"byte" ___x]
        x
    )

    (§ defn #_"float" RT'floatCast [#_"short" ___x]
        x
    )

    (§ defn #_"float" RT'floatCast [#_"int" ___x]
        x
    )

    (§ defn #_"float" RT'floatCast [#_"float" ___x]
        x
    )

    (§ defn #_"float" RT'floatCast [#_"long" ___x]
        x
    )

    (§ defn #_"float" RT'floatCast [#_"double" ___x]
        (when (ß ___x < -Float/MAX_VALUE || ___x > Float/MAX_VALUE)
            (throw (IllegalArgumentException. (ß "Value out of range for float: " + ___x)))
        )
        (ß (float) ___x)
    )

    (§ defn #_"double" RT'doubleCast [#_"Object" ___x]
        (ß ((Number) ___x).doubleValue())
    )

    (§ defn #_"double" RT'doubleCast [#_"byte" ___x]
        x
    )

    (§ defn #_"double" RT'doubleCast [#_"short" ___x]
        x
    )

    (§ defn #_"double" RT'doubleCast [#_"int" ___x]
        x
    )

    (§ defn #_"double" RT'doubleCast [#_"float" ___x]
        x
    )

    (§ defn #_"double" RT'doubleCast [#_"long" ___x]
        x
    )

    (§ defn #_"double" RT'doubleCast [#_"double" ___x]
        x
    )

    (§ defn #_"byte" RT'uncheckedByteCast [#_"Object" ___x]
        (ß ((Number) ___x).byteValue())
    )

    (§ defn #_"byte" RT'uncheckedByteCast [#_"byte" ___x]
        x
    )

    (§ defn #_"byte" RT'uncheckedByteCast [#_"short" ___x]
        (ß (byte) ___x)
    )

    (§ defn #_"byte" RT'uncheckedByteCast [#_"int" ___x]
        (ß (byte) ___x)
    )

    (§ defn #_"byte" RT'uncheckedByteCast [#_"long" ___x]
        (ß (byte) ___x)
    )

    (§ defn #_"byte" RT'uncheckedByteCast [#_"float" ___x]
        (ß (byte) ___x)
    )

    (§ defn #_"byte" RT'uncheckedByteCast [#_"double" ___x]
        (ß (byte) ___x)
    )

    (§ defn #_"short" RT'uncheckedShortCast [#_"Object" ___x]
        (ß ((Number) ___x).shortValue())
    )

    (§ defn #_"short" RT'uncheckedShortCast [#_"byte" ___x]
        x
    )

    (§ defn #_"short" RT'uncheckedShortCast [#_"short" ___x]
        x
    )

    (§ defn #_"short" RT'uncheckedShortCast [#_"int" ___x]
        (ß (short) ___x)
    )

    (§ defn #_"short" RT'uncheckedShortCast [#_"long" ___x]
        (ß (short) ___x)
    )

    (§ defn #_"short" RT'uncheckedShortCast [#_"float" ___x]
        (ß (short) ___x)
    )

    (§ defn #_"short" RT'uncheckedShortCast [#_"double" ___x]
        (ß (short) ___x)
    )

    (§ defn #_"char" RT'uncheckedCharCast [#_"Object" ___x]
        (when (ß ___x instanceof Character)
            (§ return (ß ((Character) ___x).charValue()))
        )
        (ß (char) ((Number) ___x).longValue())
    )

    (§ defn #_"char" RT'uncheckedCharCast [#_"byte" ___x]
        (ß (char) ___x)
    )

    (§ defn #_"char" RT'uncheckedCharCast [#_"short" ___x]
        (ß (char) ___x)
    )

    (§ defn #_"char" RT'uncheckedCharCast [#_"char" ___x]
        x
    )

    (§ defn #_"char" RT'uncheckedCharCast [#_"int" ___x]
        (ß (char) ___x)
    )

    (§ defn #_"char" RT'uncheckedCharCast [#_"long" ___x]
        (ß (char) ___x)
    )

    (§ defn #_"char" RT'uncheckedCharCast [#_"float" ___x]
        (ß (char) ___x)
    )

    (§ defn #_"char" RT'uncheckedCharCast [#_"double" ___x]
        (ß (char) ___x)
    )

    (§ defn #_"int" RT'uncheckedIntCast [#_"Object" ___x]
        (when (ß ___x instanceof Number)
            (§ return (ß ((Number)___x).intValue()))
        )
        (ß ((Character) ___x).charValue())
    )

    (§ defn #_"int" RT'uncheckedIntCast [#_"byte" ___x]
        x
    )

    (§ defn #_"int" RT'uncheckedIntCast [#_"short" ___x]
        x
    )

    (§ defn #_"int" RT'uncheckedIntCast [#_"char" ___x]
        x
    )

    (§ defn #_"int" RT'uncheckedIntCast [#_"int" ___x]
        x
    )

    (§ defn #_"int" RT'uncheckedIntCast [#_"long" ___x]
        (ß (int) ___x)
    )

    (§ defn #_"int" RT'uncheckedIntCast [#_"float" ___x]
        (ß (int) ___x)
    )

    (§ defn #_"int" RT'uncheckedIntCast [#_"double" ___x]
        (ß (int) ___x)
    )

    (§ defn #_"long" RT'uncheckedLongCast [#_"Object" ___x]
        (ß ((Number) ___x).longValue())
    )

    (§ defn #_"long" RT'uncheckedLongCast [#_"byte" ___x]
        x
    )

    (§ defn #_"long" RT'uncheckedLongCast [#_"short" ___x]
        x
    )

    (§ defn #_"long" RT'uncheckedLongCast [#_"int" ___x]
        x
    )

    (§ defn #_"long" RT'uncheckedLongCast [#_"long" ___x]
        x
    )

    (§ defn #_"long" RT'uncheckedLongCast [#_"float" ___x]
        (ß (long) ___x)
    )

    (§ defn #_"long" RT'uncheckedLongCast [#_"double" ___x]
        (ß (long) ___x)
    )

    (§ defn #_"float" RT'uncheckedFloatCast [#_"Object" ___x]
        (ß ((Number) ___x).floatValue())
    )

    (§ defn #_"float" RT'uncheckedFloatCast [#_"byte" ___x]
        x
    )

    (§ defn #_"float" RT'uncheckedFloatCast [#_"short" ___x]
        x
    )

    (§ defn #_"float" RT'uncheckedFloatCast [#_"int" ___x]
        x
    )

    (§ defn #_"float" RT'uncheckedFloatCast [#_"long" ___x]
        x
    )

    (§ defn #_"float" RT'uncheckedFloatCast [#_"float" ___x]
        x
    )

    (§ defn #_"float" RT'uncheckedFloatCast [#_"double" ___x]
        (ß (float) ___x)
    )

    (§ defn #_"double" RT'uncheckedDoubleCast [#_"Object" ___x]
        (ß ((Number) ___x).doubleValue())
    )

    (§ defn #_"double" RT'uncheckedDoubleCast [#_"byte" ___x]
        x
    )

    (§ defn #_"double" RT'uncheckedDoubleCast [#_"short" ___x]
        x
    )

    (§ defn #_"double" RT'uncheckedDoubleCast [#_"int" ___x]
        x
    )

    (§ defn #_"double" RT'uncheckedDoubleCast [#_"long" ___x]
        x
    )

    (§ defn #_"double" RT'uncheckedDoubleCast [#_"float" ___x]
        x
    )

    (§ defn #_"double" RT'uncheckedDoubleCast [#_"double" ___x]
        x
    )

    (§ defn #_"IPersistentMap" RT'map [#_"Object..." ___init]
        (cond (nil? ___init)
            (do
                (§ return (ß PersistentArrayMap'EMPTY))
            )
            (ß ___init.length <= PersistentArrayMap'HASHTABLE_THRESHOLD)
            (do
                (§ return (ß PersistentArrayMap'createWithCheck(___init)))
            )
        )
        (ß PersistentHashMap'createWithCheck(___init))
    )

    (§ defn #_"IPersistentMap" RT'mapUniqueKeys [#_"Object..." ___init]
        (cond (nil? ___init)
            (do
                (§ return (ß PersistentArrayMap'EMPTY))
            )
            (ß ___init.length <= PersistentArrayMap'HASHTABLE_THRESHOLD)
            (do
                (§ return (PersistentArrayMap. ___init))
            )
        )
        (ß PersistentHashMap'create(___init))
    )

    (§ defn #_"IPersistentSet" RT'set [#_"Object..." ___init]
        (ß PersistentHashSet'createWithCheck(___init))
    )

    (§ defn #_"IPersistentVector" RT'vector [#_"Object..." ___init]
        (ß LazilyPersistentVector'createOwning(___init))
    )

    (§ defn #_"IPersistentVector" RT'subvec [#_"IPersistentVector" ___v, #_"int" ___start, #_"int" ___end]
        (when (ß ___end < ___start || ___start < 0 || ___end > ___v.count())
            (throw (IndexOutOfBoundsException.))
        )
        (when (ß ___start == ___end)
            (§ return (ß PersistentVector'EMPTY))
        )
        (ß new SubVector(nil, ___v, ___start, ___end))
    )

    (§ defn #_"ISeq" RT'list []
        nil
    )

    (§ defn #_"ISeq" RT'list [#_"Object" ___arg1]
        (PersistentList. ___arg1)
    )

    (§ defn #_"ISeq" RT'list [#_"Object" ___arg1, #_"Object" ___arg2]
        (ß listStar(___arg1, ___arg2, nil))
    )

    (§ defn #_"ISeq" RT'list [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß listStar(___arg1, ___arg2, ___arg3, nil))
    )

    (§ defn #_"ISeq" RT'list [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß listStar(___arg1, ___arg2, ___arg3, ___arg4, nil))
    )

    (§ defn #_"ISeq" RT'list [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß listStar(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, nil))
    )

    (§ defn #_"ISeq" RT'listStar [#_"Object" ___arg1, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, ___rest))
    )

    (§ defn #_"ISeq" RT'listStar [#_"Object" ___arg1, #_"Object" ___arg2, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, cons(___arg2, ___rest)))
    )

    (§ defn #_"ISeq" RT'listStar [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, cons(___arg2, cons(___arg3, ___rest))))
    )

    (§ defn #_"ISeq" RT'listStar [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, cons(___arg2, cons(___arg3, cons(___arg4, ___rest)))))
    )

    (§ defn #_"ISeq" RT'listStar [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, cons(___arg2, cons(___arg3, cons(___arg4, cons(___arg5, ___rest))))))
    )

    (§ defn #_"ISeq" RT'arrayToList [#_"Object[]" ___a]
        (let [#_"ISeq" ___ret nil]
            (loop-when-recur [(§ var #_"int" ___i (ß ___a.length - 1))] (ß ___i >= 0) [(§ ass ___i (ß ___i - 1))]
                (§ ass ___ret (ß (ISeq) cons(___a[___i], ___ret)))
            )
            ret
        )
    )

    (§ defn #_"Object[]" RT'object_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (ß new Object[((Number) ___sizeOrSeq).intValue()])
            )
            (do
                (let [#_"ISeq" ___s (ß RT'seq(___sizeOrSeq))]
                    (let [#_"int" ___size (ß RT'count(___s))]
                        (let [#_"Object[]" ___ret (ß new Object[___size])]
                            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___size && ___s != nil) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                                (§ ass (ß ___ret[___i]) (ß ___s.first()))
                            )
                            ret
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"Object[]" RT'toArray [#_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                EMPTY_ARRAY
            )
            (ß ___coll instanceof Object[])
            (do
                (ß (Object[]) ___coll)
            )
            (ß ___coll instanceof Collection)
            (do
                (ß ((Collection) ___coll).toArray())
            )
            (ß ___coll instanceof Iterable)
            (do
                (let [#_"ArrayList" ___ret (ArrayList.)]
                    (doseq [#_"Object" ___o (ß (Iterable)___coll)]
                        (ß ___ret.add(___o))
                    )
                    (ß ___ret.toArray())
                )
            )
            (ß ___coll instanceof Map)
            (do
                (ß ((Map) ___coll).entrySet().toArray())
            )
            (ß ___coll instanceof String)
            (do
                (let [#_"char[]" ___chars (ß ((String) ___coll).toCharArray())]
                    (let [#_"Object[]" ___ret (ß new Object[___chars.length])]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___chars.length) [(§ ass ___i (ß ___i + 1))]
                            (§ ass (ß ___ret[___i]) (ß ___chars[___i]))
                        )
                        ret
                    )
                )
            )
            (ß ___coll.getClass().isArray())
            (do
                (let [#_"ISeq" ___s (ß (seq(___coll)))]
                    (let [#_"Object[]" ___ret (ß new Object[count(___s)])]
                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___ret.length) [(§ ass ___i (ß ___i + 1), ___s (ß ___s.next()))]
                            (§ ass (ß ___ret[___i]) (ß ___s.first()))
                        )
                        ret
                    )
                )
            )
            :else
            (do
                (throw (ß Util'runtimeException("Unable to convert: " + ___coll.getClass() + " to Object[]")))
            )
        )
    )

    (§ defn #_"Object[]" RT'seqToArray [#_"ISeq" ___seq]
        (let [#_"int" ___len (ß length(___seq))]
            (let [#_"Object[]" ___ret (ß new Object[___len])]
                (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___seq) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                    (§ ass (ß ___ret[___i]) (ß ___seq.first()))
                )
                ret
            )
        )
    )

    ;; supports java Collection.toArray(T[])
    (§ defn #_"Object[]" RT'seqToPassedArray [#_"ISeq" ___seq, #_"Object[]" ___passed]
        (let [#_"Object[]" ___dest ___passed]
            (let [#_"int" ___len (ß count(___seq))]
                (when (ß ___len > ___dest.length)
                    (§ ass ___dest (ß (Object[]) Array/newInstance(___passed.getClass().getComponentType(), ___len)))
                )
                (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___seq) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                    (§ ass (ß ___dest[___i]) (ß ___seq.first()))
                )
                (when (ß ___len < ___passed.length)
                    (§ ass (ß ___dest[___len]) nil)
                )
                ___dest
            )
        )
    )

    (§ defn #_"Object" RT'seqToTypedArray [#_"ISeq" ___seq]
        (let [#_"Class" ___type (ß (___seq != nil && ___seq.first() != nil) ? ___seq.first().getClass() :or (§ class Object))]
            (ß seqToTypedArray(___type, ___seq))
        )
    )

    (§ defn #_"Object" RT'seqToTypedArray [#_"Class" ___type, #_"ISeq" ___seq]
        (let [#_"Object" ___ret (ß Array/newInstance(___type, length(___seq)))]
            (cond (ß ___type == Integer/TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___seq) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                        (ß Array/set(___ret, ___i, intCast(___seq.first())))
                    )
                )
                (ß ___type == Byte/TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___seq) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                        (ß Array/set(___ret, ___i, byteCast(___seq.first())))
                    )
                )
                (ß ___type == Float/TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___seq) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                        (ß Array/set(___ret, ___i, floatCast(___seq.first())))
                    )
                )
                (ß ___type == Short/TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___seq) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                        (ß Array/set(___ret, ___i, shortCast(___seq.first())))
                    )
                )
                (ß ___type == Character/TYPE)
                (do
                    (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___seq) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                        (ß Array/set(___ret, ___i, charCast(___seq.first())))
                    )
                )
                :else
                (do
                    (loop-when-recur [(§ var #_"int" ___i 0)] (some? ___seq) [(§ ass ___i (ß ___i + 1), ___seq (ß ___seq.next()))]
                        (ß Array/set(___ret, ___i, ___seq.first()))
                    )
                )
            )
            ret
        )
    )

    (§ defn #_"int" RT'length [#_"ISeq" ___list]
        (let [#_"int" ___i 0]
            (loop-when-recur [(§ var #_"ISeq" ___c ___list)] (some? ___c) [(§ ass ___c (ß ___c.next()))]
                (§ ass ___i (ß ___i + 1))
            )
            i
        )
    )

    (§ defn #_"int" RT'boundedLength [#_"ISeq" ___list, #_"int" ___limit]
        (let [#_"int" ___i 0]
            (loop-when-recur [(§ var #_"ISeq" ___c ___list)] (ß ___c != nil && ___i <= ___limit) [(§ ass ___c (ß ___c.next()))]
                (§ ass ___i (ß ___i + 1))
            )
            i
        )
    )

    (§ defn #_"Character" RT'readRet [#_"int" ___ret]
        (when (ß ___ret == -1)
            (§ return nil)
        )
        (ß box((char) ___ret))
    )

    (§ defn #_"Character" RT'readChar [#_"Reader" ___r] #_(§ throws IOException)
        (let [#_"int" ___ret (ß ___r.read())]
            (ß readRet(___ret))
        )
    )

    (§ defn #_"Character" RT'peekChar [#_"Reader" ___r] #_(§ throws IOException)
        (§ let [#_"int" ___ret]
            (if (ß ___r instanceof PushbackReader)
                (do
                    (§ ass ___ret (ß ___r.read()))
                    (ß ((PushbackReader) ___r).unread(___ret))
                )
                (do
                    (ß ___r.mark(1))
                    (§ ass ___ret (ß ___r.read()))
                    (ß ___r.reset())
                )
            )

            (ß readRet(___ret))
        )
    )

    (§ defn #_"int" RT'getLineNumber [#_"Reader" ___r]
        (when (ß ___r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
        )
        0
    )

    (§ defn #_"int" RT'getColumnNumber [#_"Reader" ___r]
        (when (ß ___r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()))
        )
        0
    )

    (§ defn #_"LineNumberingPushbackReader" RT'getLineNumberingReader [#_"Reader" ___r]
        (when (ß isLineNumberingReader(___r))
            (§ return (ß (LineNumberingPushbackReader) ___r))
        )
        (LineNumberingPushbackReader. ___r)
    )

    (§ defn #_"boolean" RT'isLineNumberingReader [#_"Reader" ___r]
        (ß (___r instanceof LineNumberingPushbackReader))
    )

    (§ defn #_"boolean" RT'isReduced [#_"Object" ___r]
        (ß (___r instanceof Reduced))
    )

    (§ defn #_"String" RT'resolveClassNameInContext [#_"String" ___className]
        ;; todo - look up in context var
        className
    )

    (§ defn #_"boolean" RT'suppressRead []
        (ß booleanCast(SUPPRESS_READ.deref()))
    )

    (§ defn #_"String" RT'printString [#_"Object" ___x]
        (try
            (let [#_"StringWriter" ___sw (StringWriter.)]
                (ß print(___x, ___sw))
                (ß ___sw.toString())
            )
            (catch Exception ___e
                (throw (ß Util'sneakyThrow(___e)))
            )
        )
    )

    (§ defn #_"Object" RT'readString [#_"String" ___s]
        (ß readString(___s, nil))
    )

    (§ defn #_"Object" RT'readString [#_"String" ___s, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß new PushbackReader(new StringReader(___s)))]
            (ß LispReader'read(___r, ___opts))
        )
    )

    (§ defn #_"void" RT'print [#_"Object" ___x, #_"Writer" ___w] #_(§ throws IOException)
        ;; call multimethod
        (if (ß PRINT_INITIALIZED.isBound() && RT'booleanCast(PRINT_INITIALIZED.deref()))
            (do
                (ß PR_ON.invoke(___x, ___w))
            )
            (do
                (let [#_"boolean" ___readably (ß booleanCast(PRINT_READABLY.deref()))]
                    (when (ß ___x instanceof Obj)
                        (let [#_"Obj" ___o (ß (Obj) ___x)]
                            (when (ß RT'count(___o.meta()) > 0 && ((___readably && booleanCast(PRINT_META.deref())) || booleanCast(PRINT_DUP.deref())))
                                (let [#_"IPersistentMap" ___meta (ß ___o.meta())]
                                    (ß ___w.write("#^"))
                                    (if (ß ___meta.count() == 1 && ___meta.containsKey(TAG_KEY))
                                        (do
                                            (ß print(___meta.valAt(TAG_KEY), ___w))
                                        )
                                        (do
                                            (ß print(___meta, ___w))
                                        )
                                    )
                                    (ß ___w.write(\space))
                                )
                            )
                        )
                    )
                    (cond (nil? ___x)
                        (do
                            (ß ___w.write("nil"))
                        )
                        (ß ___x instanceof ISeq || ___x instanceof IPersistentList)
                        (do
                            (ß ___w.write(\())
                            (ß printInnerSeq(seq(___x), ___w))
                            (ß ___w.write(\)))
                        )
                        (ß ___x instanceof String)
                        (do
                            (let [#_"String" ___s (ß (String) ___x)]
                                (if (ß !___readably)
                                    (do
                                        (ß ___w.write(___s))
                                    )
                                    (do
                                        (ß ___w.write(\")) ;; oops! "
                                        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___s.length()) [(§ ass ___i (ß ___i + 1))]
                                            (let [#_"char" ___c (ß ___s.charAt(___i))]
                                                (§ switch ___c
                                                    (§ case \newline)
                                                    (do
                                                        (ß ___w.write("\\n"))
                                                        (§ break )
                                                    )
                                                    (§ case \tab)
                                                    (do
                                                        (ß ___w.write("\\t"))
                                                        (§ break )
                                                    )
                                                    (§ case \return)
                                                    (do
                                                        (ß ___w.write("\\r"))
                                                        (§ break )
                                                    )
                                                    (§ case \")
                                                    (do
                                                        (ß ___w.write("\\\""))
                                                        (§ break )
                                                    )
                                                    (§ case \\)
                                                    (do
                                                        (ß ___w.write("\\\\"))
                                                        (§ break )
                                                    )
                                                    (§ case \formfeed)
                                                    (do
                                                        (ß ___w.write("\\f"))
                                                        (§ break )
                                                    )
                                                    (§ case \backspace)
                                                    (do
                                                        (ß ___w.write("\\b"))
                                                        (§ break )
                                                    )
                                                    (§ default )
                                                    (do
                                                        (ß ___w.write(___c))
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                        (ß ___w.write(\")) ;; oops! "
                                    )
                                )
                            )
                        )
                        (ß ___x instanceof IPersistentMap)
                        (do
                            (ß ___w.write(\{))
                            (loop-when-recur [(§ var #_"ISeq" ___s (ß seq(___x)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                (let [#_"IMapEntry" ___e (ß (IMapEntry) ___s.first())]
                                    (ß print(___e.key(), ___w))
                                    (ß ___w.write(\space))
                                    (ß print(___e.val(), ___w))
                                    (when (ß ___s.next() != nil)
                                        (ß ___w.write(", "))
                                    )
                                )
                            )
                            (ß ___w.write(\}))
                        )
                        (ß ___x instanceof IPersistentVector)
                        (do
                            (let [#_"IPersistentVector" ___a (ß (IPersistentVector) ___x)]
                                (ß ___w.write(\[))
                                (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___a.count()) [(§ ass ___i (ß ___i + 1))]
                                    (ß print(___a.nth(___i), ___w))
                                    (when (ß ___i < ___a.count() - 1)
                                        (ß ___w.write(\space))
                                    )
                                )
                                (ß ___w.write(\]))
                            )
                        )
                        (ß ___x instanceof IPersistentSet)
                        (do
                            (ß ___w.write("#{"))
                            (loop-when-recur [(§ var #_"ISeq" ___s (ß seq(___x)))] (some? ___s) [(§ ass ___s (ß ___s.next()))]
                                (ß print(___s.first(), ___w))
                                (when (ß ___s.next() != nil)
                                    (ß ___w.write(" "))
                                )
                            )
                            (ß ___w.write(\}))
                        )
                        (ß ___x instanceof Character)
                        (do
                            (let [#_"char" ___c (ß ((Character) ___x).charValue())]
                                (if (ß !___readably)
                                    (do
                                        (ß ___w.write(___c))
                                    )
                                    (do
                                        (ß ___w.write(\\))
                                        (§ switch ___c
                                            (§ case \newline)
                                            (do
                                                (ß ___w.write("newline"))
                                                (§ break )
                                            )
                                            (§ case \tab)
                                            (do
                                                (ß ___w.write("tab"))
                                                (§ break )
                                            )
                                            (§ case \space)
                                            (do
                                                (ß ___w.write("space"))
                                                (§ break )
                                            )
                                            (§ case \backspace)
                                            (do
                                                (ß ___w.write("backspace"))
                                                (§ break )
                                            )
                                            (§ case \formfeed)
                                            (do
                                                (ß ___w.write("formfeed"))
                                                (§ break )
                                            )
                                            (§ case \return)
                                            (do
                                                (ß ___w.write("return"))
                                                (§ break )
                                            )
                                            (§ default )
                                            (do
                                                (ß ___w.write(___c))
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß ___x instanceof Class)
                        (do
                            (ß ___w.write("#="))
                            (ß ___w.write(((Class) ___x).getName()))
                        )
                        (ß ___x instanceof BigDecimal && ___readably)
                        (do
                            (ß ___w.write(___x.toString()))
                            (ß ___w.write(\M))
                        )
                        (ß ___x instanceof BigInt && ___readably)
                        (do
                            (ß ___w.write(___x.toString()))
                            (ß ___w.write(\N))
                        )
                        (ß ___x instanceof BigInteger && ___readably)
                        (do
                            (ß ___w.write(___x.toString()))
                            (ß ___w.write("BIGINT"))
                        )
                        (ß ___x instanceof Var)
                        (do
                            (let [#_"Var" ___v (ß (Var) ___x)]
                                (ß ___w.write("#=(var " + ___v.ns.name + "/" + ___v.sym + ")"))
                            )
                        )
                        (ß ___x instanceof Pattern)
                        (do
                            (let [#_"Pattern" ___p (ß (Pattern) ___x)]
                                (ß ___w.write("#\"" + ___p.pattern() + "\""))
                            )
                        )
                        :else
                        (do
                            (ß ___w.write(___x.toString()))
                        )
                    )
                )
            )
        )
        nil
    )

    (§ defn- #_"void" RT'printInnerSeq [#_"ISeq" ___x, #_"Writer" ___w] #_(§ throws IOException)
        (loop-when-recur [(§ var #_"ISeq" ___s ___x)] (some? ___s) [(§ ass ___s (ß ___s.next()))]
            (ß print(___s.first(), ___w))
            (when (ß ___s.next() != nil)
                (ß ___w.write(\space))
            )
        )
        nil
    )

    (§ defn #_"void" RT'formatAesthetic [#_"Writer" ___w, #_"Object" ___obj] #_(§ throws IOException)
        (if (nil? ___obj)
            (do
                (ß ___w.write("nil"))
            )
            (do
                (ß ___w.write(___obj.toString()))
            )
        )
        nil
    )

    (§ defn #_"void" RT'formatStandard [#_"Writer" ___w, #_"Object" ___obj] #_(§ throws IOException)
        (cond (nil? ___obj)
            (do
                (ß ___w.write("nil"))
            )
            (ß ___obj instanceof String)
            (do
                (ß ___w.write(\")) ;; oops! "
                (ß ___w.write((String) ___obj))
                (ß ___w.write(\")) ;; oops! "
            )
            (ß ___obj instanceof Character)
            (do
                (ß ___w.write(\\))
                (let [#_"char" ___c (ß ((Character) ___obj).charValue())]
                    (§ switch ___c
                        (§ case \newline)
                        (do
                            (ß ___w.write("newline"))
                            (§ break )
                        )
                        (§ case \tab)
                        (do
                            (ß ___w.write("tab"))
                            (§ break )
                        )
                        (§ case \space)
                        (do
                            (ß ___w.write("space"))
                            (§ break )
                        )
                        (§ case \backspace)
                        (do
                            (ß ___w.write("backspace"))
                            (§ break )
                        )
                        (§ case \formfeed)
                        (do
                            (ß ___w.write("formfeed"))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (ß ___w.write(___c))
                            (§ break )
                        )
                    )
                )
            )
            :else
            (do
                (ß ___w.write(___obj.toString()))
            )
        )
        nil
    )

    (§ defn #_"Object" RT'format [#_"Object" ___o, #_"String" ___s, #_"Object..." ___args] #_(§ throws IOException)
        (§ let [#_"Writer" ___w]
            (cond (nil? ___o)
                (do
                    (§ ass ___w (StringWriter.))
                )
                (ß Util'equals(___o, T))
                (do
                    (§ ass ___w (ß (Writer) OUT.deref()))
                )
                :else
                (do
                    (§ ass ___w (ß (Writer) ___o))
                )
            )
            (ß doFormat(___w, ___s, ArraySeq'create(___args)))
            (when (nil? ___o)
                (§ return (ß ___w.toString()))
            )
            nil
        )
    )

    (§ defn #_"ISeq" RT'doFormat [#_"Writer" ___w, #_"String" ___s, #_"ISeq" ___args] #_(§ throws IOException)
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___s.length()) [(ß )]
            (let [#_"char" ___c (ß ___s.charAt(___i))]
                (§ ass ___i (ß ___i + 1))
                (§ switch (ß Character/toLowerCase(___c))
                    (§ case \~)
                    (do
                        (let [#_"char" ___d (ß ___s.charAt(___i))]
                            (§ ass ___i (ß ___i + 1))
                            (§ switch (ß Character/toLowerCase(___d))
                                (§ case \%)
                                (do
                                    (ß ___w.write(\newline))
                                    (§ break )
                                )
                                (§ case \t)
                                (do
                                    (ß ___w.write(\tab))
                                    (§ break )
                                )
                                (§ case \a)
                                (do
                                    (when (nil? ___args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT'formatAesthetic(___w, RT'first(___args)))
                                    (§ ass ___args (ß RT'next(___args)))
                                    (§ break )
                                )
                                (§ case \s)
                                (do
                                    (when (nil? ___args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT'formatStandard(___w, RT'first(___args)))
                                    (§ ass ___args (ß RT'next(___args)))
                                    (§ break )
                                )
                                (§ case \{)
                                (do
                                    (let [#_"int" ___j (ß ___s.indexOf("~}", ___i))] ;; note - does not nest
                                        (when (ß ___j == -1)
                                            (throw (IllegalArgumentException. "Missing ~}"))
                                        )
                                        (let [#_"String" ___subs (ß ___s.substring(___i, ___j))]
                                            (loop-when-recur [(§ var #_"ISeq" ___sargs (ß RT'seq(RT'first(___args))))] (some? ___sargs) [(ß )]
                                                (§ ass ___sargs (ß doFormat(___w, ___subs, ___sargs)))
                                            )
                                            (§ ass ___args (ß RT'next(___args)))
                                            (§ ass ___i (ß ___j + 2)) ;; skip "~}"
                                            (§ break )
                                        )
                                    )
                                )
                                (§ case \^)
                                (do
                                    (when (nil? ___args)
                                        (§ return nil)
                                    )
                                    (§ break )
                                )
                                (§ case \~)
                                (do
                                    (ß ___w.write(\~))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (throw (IllegalArgumentException. (ß "Unsupported ~ directive: " + ___d)))
                                )
                            )
                            (§ break )
                        )
                    )
                    (§ default )
                    (do
                        (ß ___w.write(___c))
                        (§ break )
                    )
                )
            )
        )
        args
    )

    (§ defn #_"Object[]" RT'setValues [#_"Object..." ___vals]
        (when (ß ___vals.length > 0)
            (§ return ___vals)
        )
        nil
    )

    (§ defn #_"ClassLoader" RT'makeClassLoader []
        (ß (ClassLoader) AccessController/doPrivileged(
                (§ reify PrivilegedAction()
                    #_method
                    (§ defn #_"Object" run [#_"PrivilegedAction" this]
                        (try
                            (ß Var'pushThreadBindings(RT'map(USE_CONTEXT_CLASSLOADER, RT'T)))
                            (ß new DynamicClassLoader(baseLoader()))
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                    )
                )
            )
        )
    )

    (§ defn #_"ClassLoader" RT'baseLoader []
        (cond (ß Compiler'LOADER.isBound())
            (do
                (§ return (ß (ClassLoader) Compiler'LOADER.deref()))
            )
            (ß booleanCast(USE_CONTEXT_CLASSLOADER.deref()))
            (do
                (§ return (ß Thread/currentThread().getContextClassLoader()))
            )
        )
        (ß (§ class Compiler).getClassLoader())
    )

    (§ defn #_"InputStream" RT'resourceAsStream [#_"ClassLoader" ___loader, #_"String" ___name]
        (if (nil? ___loader)
            (do
                (ß ClassLoader/getSystemResourceAsStream(___name))
            )
            (do
                (ß ___loader.getResourceAsStream(___name))
            )
        )
    )

    (§ defn #_"URL" RT'getResource [#_"ClassLoader" ___loader, #_"String" ___name]
        (if (nil? ___loader)
            (do
                (ß ClassLoader/getSystemResource(___name))
            )
            (do
                (ß ___loader.getResource(___name))
            )
        )
    )

    (§ defn #_"Class" RT'classForName [#_"String" ___name, #_"boolean" ___load, #_"ClassLoader" ___loader]
        (try
            (let [#_"Class" ___c nil]
                (when (ß !(___loader instanceof DynamicClassLoader))
                    (§ ass ___c (ß DynamicClassLoader'findInMemoryClass(___name)))
                )
                (when (some? ___c)
                    (§ return ___c)
                )
                (ß Class/forName(___name, ___load, ___loader))
            )
            (catch ClassNotFoundException ___e
                (throw (ß Util'sneakyThrow(___e)))
            )
        )
    )

    (§ defn #_"Class" RT'classForName [#_"String" ___name]
        (ß classForName(___name, true, baseLoader()))
    )

    (§ defn #_"Class" RT'classForNameNonLoading [#_"String" ___name]
        (ß classForName(___name, false, baseLoader()))
    )

    (§ defn #_"Class" RT'loadClassForName [#_"String" ___name]
        (try
            (ß classForNameNonLoading(___name))
            (catch Exception ___e
                (if (ß ___e instanceof ClassNotFoundException)
                    (do
                        (§ return nil)
                    )
                    (do
                        (throw (ß Util'sneakyThrow(___e)))
                    )
                )
            )
        )
        (ß classForName(___name))
    )

    (§ defn #_"float" RT'aget [#_"float[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"float" RT'aset [#_"float[]" ___xs, #_"int" ___i, #_"float" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"float[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"float[]" RT'aclone [#_"float[]" ___xs]
        (ß ___xs.clone())
    )

    (§ defn #_"double" RT'aget [#_"double[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"double" RT'aset [#_"double[]" ___xs, #_"int" ___i, #_"double" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"double[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"double[]" RT'aclone [#_"double[]" ___xs]
        (ß ___xs.clone())
    )

    (§ defn #_"int" RT'aget [#_"int[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"int" RT'aset [#_"int[]" ___xs, #_"int" ___i, #_"int" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"int[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"int[]" RT'aclone [#_"int[]" ___xs]
        (ß ___xs.clone())
    )

    (§ defn #_"long" RT'aget [#_"long[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"long" RT'aset [#_"long[]" ___xs, #_"int" ___i, #_"long" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"long[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"long[]" RT'aclone [#_"long[]" ___xs]
        (ß ___xs.clone())
    )

    (§ defn #_"char" RT'aget [#_"char[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"char" RT'aset [#_"char[]" ___xs, #_"int" ___i, #_"char" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"char[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"char[]" RT'aclone [#_"char[]" ___xs]
        (ß ___xs.clone())
    )

    (§ defn #_"byte" RT'aget [#_"byte[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"byte" RT'aset [#_"byte[]" ___xs, #_"int" ___i, #_"byte" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"byte[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"byte[]" RT'aclone [#_"byte[]" ___xs]
        (ß ___xs.clone())
    )

    (§ defn #_"short" RT'aget [#_"short[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"short" RT'aset [#_"short[]" ___xs, #_"int" ___i, #_"short" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"short[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"short[]" RT'aclone [#_"short[]" ___xs]
        (ß ___xs.clone())
    )

    (§ defn #_"boolean" RT'aget [#_"boolean[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"boolean" RT'aset [#_"boolean[]" ___xs, #_"int" ___i, #_"boolean" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"boolean[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"boolean[]" RT'aclone [#_"boolean[]" ___xs]
        (ß ___xs.clone())
    )

    (§ defn #_"Object" RT'aget [#_"Object[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (§ defn #_"Object" RT'aset [#_"Object[]" ___xs, #_"int" ___i, #_"Object" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        v
    )

    (§ defn #_"int" RT'alength [#_"Object[]" ___xs]
        (ß ___xs.length)
    )

    (§ defn #_"Object[]" RT'aclone [#_"Object[]" ___xs]
        (ß ___xs.clone())
    )
)
)

(java-ns cloiure.lang.Seqable

(defprotocol Seqable
    #_abstract
    (#_"ISeq" Seqable'''seq [#_"Seqable" this])
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(class-ns SeqEnumeration (§ implements Enumeration)
    (§ init
        (§ field #_"ISeq" seq nil)
    )

    (§ constructor #_"SeqEnumeration" SeqEnumeration [#_"ISeq" ___seq]
        (let [this (ß super())]
            (§ ass (ß this.seq) ___seq)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasMoreElements [#_"SeqEnumeration" this]
        (ß (seq != nil))
    )

    #_method
    (§ defn #_"Object" nextElement [#_"SeqEnumeration" this]
        (let [#_"Object" ___ret (ß RT'first(seq))]
            (§ ass seq (ß RT'next(seq)))
            ret
        )
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (§ def #_"Object" SeqIterator'START (Object.))

    (§ init
        (§ field #_"Object" seq nil)
        (§ field #_"Object" next nil)
    )

    (§ constructor #_"SeqIterator" SeqIterator [#_"Object" ___o]
        (let [this (ß super())]
            (§ ass seq SeqIterator'START)
            (§ ass next ___o)
            this
        )
    )

    ;; preserved for binary compatibility
    (§ constructor #_"SeqIterator" SeqIterator [#_"ISeq" ___o]
        (let [this (ß super())]
            (§ ass seq SeqIterator'START)
            (§ ass next ___o)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"SeqIterator" this]
        (cond (ß seq == SeqIterator'START)
            (do
                (§ ass seq nil)
                (§ ass next (ß RT'seq(next)))
            )
            (ß seq == next)
            (do
                (§ ass next (ß RT'next(seq)))
            )
        )
        (ß (next != nil))
    )

    #_method
    (§ defn #_"Object" next [#_"SeqIterator" this] #_(§ throws NoSuchElementException)
        (when (ß !hasNext())
            (throw (NoSuchElementException.))
        )
        (§ ass seq next)
        (ß RT'first(next))
    )

    #_method
    (§ defn #_"void" remove [#_"SeqIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Sequential

(defprotocol Sequential
)
)

(java-ns cloiure.lang.Settable

(defprotocol Settable
    #_abstract
    (#_"Object" Settable'''doSet [#_"Settable" this, #_"Object" ___val])
    #_abstract
    (#_"Object" Settable'''doReset [#_"Settable" this, #_"Object" ___val])
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(defprotocol Sorted
    #_abstract
    (#_"Comparator" Sorted'''comparator [#_"Sorted" this])
    #_abstract
    (#_"Object" Sorted'''entryKey [#_"Sorted" this, #_"Object" ___entry])
    #_abstract
    (#_"ISeq" Sorted'''seq [#_"Sorted" this, #_"boolean" ___ascending])
    #_abstract
    (#_"ISeq" Sorted'''seqFrom [#_"Sorted" this, #_"Object" ___key, #_"boolean" ___ascending])
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (§ defn #_"StringSeq" StringSeq'create [#_"CharSequence" ___s]
        (when (ß ___s.length() == 0)
            (§ return nil)
        )
        (ß new StringSeq(nil, ___s, 0))
    )

    (§ init
        (§ field #_"CharSequence" s nil)
        (§ field #_"int" i 0)
    )

    (§ constructor #_"StringSeq" StringSeq [#_"IPersistentMap" ___meta, #_"CharSequence" ___s, #_"int" ___i]
        (let [this (ß super(___meta))]
            (§ ass (ß this.s) ___s)
            (§ ass (ß this.i) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"StringSeq" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == meta())
            (§ return this)
        )
        (ß new StringSeq(___meta, s, i))
    )

    #_method
    (§ defn #_"Object" first [#_"StringSeq" this]
        (ß Character/valueOf(s.charAt(i)))
    )

    #_method
    (§ defn #_"ISeq" next [#_"StringSeq" this]
        (when (ß i + 1 < s.length())
            (§ return (ß new StringSeq(_meta, s, i + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" index [#_"StringSeq" this]
        i
    )

    #_method
    (§ defn #_"int" count [#_"StringSeq" this]
        (ß s.length() - i)
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (§ defn #_"Symbol" Symbol'create [#_"String" ___ns, #_"String" ___name]
        (ß Symbol'intern(___ns, ___name))
    )

    (§ defn #_"Symbol" Symbol'create [#_"String" ___nsname]
        (ß Symbol'intern(___nsname))
    )

    (§ defn #_"Symbol" Symbol'intern [#_"String" ___ns, #_"String" ___name]
        (ß new Symbol(___ns, ___name))
    )

    (§ defn #_"Symbol" Symbol'intern [#_"String" ___nsname]
        (let [#_"int" ___i (ß ___nsname.indexOf(\/))]
            (if (ß ___i == -1 || ___nsname.equals("/"))
                (do
                    (ß new Symbol(nil, ___nsname))
                )
                (do
                    (ß new Symbol(___nsname.substring(0, ___i), ___nsname.substring(___i + 1)))
                )
            )
        )
    )

    (§ init
        (§ field #_"String" ns nil)
        (§ field #_"String" name nil)
        (§ field- #_"int" _hasheq 0)
        (§ field #_"IPersistentMap" _meta nil)
        #_transient
        (§ field #_"String" _str nil)
    )

    (§ constructor- #_"Symbol" Symbol [#_"String" ___ns_interned, #_"String" ___name_interned]
        (let [this (ß super())]
            (§ ass (ß this.name) ___name_interned)
            (§ ass (ß this.ns) ___ns_interned)
            (§ ass (ß this._meta) nil)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"Symbol" this]
        (when (nil? _str)
            (if (some? ns)
                (do
                    (§ ass _str (ß (ns + "/" + name)))
                )
                (do
                    (§ ass _str name)
                )
            )
        )
        _str
    )

    #_method
    (§ defn #_"String" getNamespace [#_"Symbol" this]
        ns
    )

    #_method
    (§ defn #_"String" getName [#_"Symbol" this]
        name
    )

    #_method
    (§ defn #_"boolean" equals [#_"Symbol" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (ß !(___o instanceof Symbol))
            (§ return false)
        )

        (let [#_"Symbol" ___symbol (ß (Symbol) ___o)]
            (ß Util'equals(ns, ___symbol.ns) && name.equals(___symbol.name))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"Symbol" this]
        (ß Util'hashCombine(name.hashCode(), Util'hash(ns)))
    )

    #_method
    (§ defn #_"int" hasheq [#_"Symbol" this]
        (when (ß _hasheq == 0)
            (§ ass _hasheq (ß Util'hashCombine(Murmur3'hashUnencodedChars(name), Util'hash(ns))))
        )
        _hasheq
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"Symbol" this, #_"IPersistentMap" ___meta]
        (ß new Symbol(___meta, ns, name))
    )

    (§ constructor- #_"Symbol" Symbol [#_"IPersistentMap" ___meta, #_"String" ___ns, #_"String" ___name]
        (let [this (ß super())]
            (§ ass (ß this.name) ___name)
            (§ ass (ß this.ns) ___ns)
            (§ ass (ß this._meta) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"int" compareTo [#_"Symbol" this, #_"Object" ___o]
        (let [#_"Symbol" ___s (ß (Symbol) ___o)]
            (when (ß this.equals(___o))
                (§ return 0)
            )
            (when (ß this.ns == nil && ___s.ns != nil)
                (§ return -1)
            )
            (when (ß this.ns != nil)
                (when (ß ___s.ns == nil)
                    (§ return 1)
                )
                (let [#_"int" ___nsc (ß this.ns.compareTo(___s.ns))]
                    (when (ß ___nsc != 0)
                        (§ return ___nsc)
                    )
                )
            )
            (ß this.name.compareTo(___s.name))
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"Symbol" this, #_"Object" ___obj]
        (ß RT'get(___obj, this))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Symbol" this, #_"Object" ___obj, #_"Object" ___notFound]
        (ß RT'get(___obj, this, ___notFound))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"Symbol" this]
        _meta
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(class-ns TaggedLiteral (§ implements ILookup)
    (§ def #_"Keyword" TaggedLiteral'TAG_KW (ß Keyword'intern("tag")))
    (§ def #_"Keyword" TaggedLiteral'FORM_KW (ß Keyword'intern("form")))

    (§ defn #_"TaggedLiteral" TaggedLiteral'create [#_"Symbol" ___tag, #_"Object" ___form]
        (ß new TaggedLiteral(___tag, ___form))
    )

    (§ init
        (§ field #_"Symbol" tag nil)
        (§ field #_"Object" form nil)
    )

    (§ constructor- #_"TaggedLiteral" TaggedLiteral [#_"Symbol" ___tag, #_"Object" ___form]
        (let [this (ß super())]
            (§ ass (ß this.tag) ___tag)
            (§ ass (ß this.form) ___form)
            this
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"TaggedLiteral" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [#_"TaggedLiteral" this, #_"Object" ___key, #_"Object" ___notFound]
        (cond (ß FORM_KW.equals(___key))
            (do
                (ß this.form)
            )
            (ß TAG_KW.equals(___key))
            (do
                (ß this.tag)
            )
            :else
            (do
                ___notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" equals [#_"TaggedLiteral" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (ß ___o == nil || getClass() != ___o.getClass())
            (§ return false)
        )

        (let [#_"TaggedLiteral" ___that (ß (TaggedLiteral) ___o)]
            (when (ß (form != nil) ? !form.equals(___that.form) :or ___that.form != nil)
                (§ return false)
            )
            (when (ß (tag != nil) ? !tag.equals(___that.tag) :or ___that.tag != nil)
                (§ return false)
            )

            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" hashCode [#_"TaggedLiteral" this]
        (let [#_"int" ___result (ß Util'hash(tag))]
            (§ ass ___result (ß 31 * ___result + Util'hash(form)))
            result
        )
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (§ init
        (§ field #_"Ref[]" bins nil)
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap []
        (let [this (ß this(421))]
            this
        )
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap [#_"int" ___nBins]
        (let [this (ß super())]
            (§ ass bins (ß new Ref[___nBins]))
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___nBins) [(§ ass ___i (ß ___i + 1))]
                (§ ass (ß bins[___i]) (Ref. (ß PersistentHashMap'EMPTY)))
            )
            this
        )
    )

    (§ constructor #_"TransactionalHashMap" TransactionalHashMap [#_"Map<? extends K, ? extends V>" ___m]
        (let [this (ß this(___m.size()))]
            (ß putAll(___m))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" mapAt [#_"TransactionalHashMap" this, #_"int" ___bin]
        (ß (IPersistentMap) bins[___bin].deref())
    )

    #_method
    (§ defn #_"int" binFor [#_"TransactionalHashMap" this, #_"Object" ___k]
        ;; spread hashes, a la Cliff Click
        (let [#_"int" ___h (ß ___k.hashCode())]
            (§ ass ___h (ß ___h :xor ((___h >>> 20) :xor (___h >>> 12))))
            (§ ass ___h (ß ___h :xor ((___h >>> 7) :xor (___h >>> 4))))
            (ß ___h % bins.length)
        )
    )

    #_method
    (§ defn #_"Entry" entryAt [#_"TransactionalHashMap" this, #_"Object" ___k]
        (ß mapAt(binFor(___k)).entryAt(___k))
    )

    #_method
    (§ defn #_"int" size [#_"TransactionalHashMap" this]
        (let [#_"int" ___n 0]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < bins.length) [(§ ass ___i (ß ___i + 1))]
                (§ ass ___n (ß ___n + mapAt(___i).count()))
            )
            n
        )
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"TransactionalHashMap" this]
        (ß (size() == 0))
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"TransactionalHashMap" this, #_"Object" ___k]
        (ß (entryAt(___k) != nil))
    )

    #_method
    (§ defn #_"V" get [#_"TransactionalHashMap" this, #_"Object" ___k]
        (let [#_"Entry" ___e (ß entryAt(___k))]
            (when (some? ___e)
                (§ return (ß (V) ___e.getValue()))
            )
            nil
        )
    )

    #_method
    (§ defn #_"V" put [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß bins[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Object" ___ret (ß ___map.valAt(___k))]
                    (ß ___r.set(___map.assoc(___k, ___v)))
                    (ß (V) ___ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" remove [#_"TransactionalHashMap" this, #_"Object" ___k]
        (let [#_"Ref" ___r (ß bins[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Object" ___ret (ß ___map.valAt(___k))]
                    (ß ___r.set(___map.without(___k)))
                    (ß (V) ___ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"void" putAll [#_"TransactionalHashMap" this, #_"Map<? extends K, ? extends V>" ___map]
        (loop-when-recur [(§ var #_"Iterator" ___i (ß ___map.entrySet().iterator()))] (ß ___i.hasNext()) [(ß )]
            (let [#_"Entry<K, V>" ___e (ß (Entry) ___i.next())]
                (ß put(___e.getKey(), ___e.getValue()))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" clear [#_"TransactionalHashMap" this]
        (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < bins.length) [(§ ass ___i (ß ___i + 1))]
            (let [#_"Ref" ___r (ß bins[___i])]
                (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                    (when (ß ___map.count() > 0)
                        (ß ___r.set(PersistentHashMap'EMPTY))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Set<Entry<K, V>>" entrySet [#_"TransactionalHashMap" this]
        (let [#_"ArrayList<Map$Entry<K, V>>" ___entries (ArrayList. (ß bins.length))]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < bins.length) [(§ ass ___i (ß ___i + 1))]
                (let [#_"IPersistentMap" ___map (ß mapAt(___i))]
                    (when (ß ___map.count() > 0)
                        (ß ___entries.addAll((Collection) RT'seq(___map)))
                    )
                )
            )
            (§ reify AbstractSet<Entry<K, V>>()
                #_method
                (§ defn #_"Iterator" iterator [#_"AbstractSet<Entry<K, V>>" this]
                    (ß Collections/unmodifiableList(___entries).iterator())
                )

                #_method
                (§ defn #_"int" size [#_"AbstractSet<Entry<K, V>>" this]
                    (ß ___entries.size())
                )
            )
        )
    )

    #_method
    (§ defn #_"V" putIfAbsent [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß bins[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Entry" ___e (ß ___map.entryAt(___k))]
                    (if (nil? ___e)
                        (do
                            (ß ___r.set(___map.assoc(___k, ___v)))
                            nil
                        )
                        (do
                            (ß (V) ___e.getValue())
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" remove [#_"TransactionalHashMap" this, #_"Object" ___k, #_"Object" ___v]
        (let [#_"Ref" ___r (ß bins[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Entry" ___e (ß ___map.entryAt(___k))]
                    (when (ß ___e != nil && ___e.getValue().equals(___v))
                        (ß ___r.set(___map.without(___k)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" replace [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___oldv, #_"V" ___newv]
        (let [#_"Ref" ___r (ß bins[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Entry" ___e (ß ___map.entryAt(___k))]
                    (when (ß ___e != nil && ___e.getValue().equals(___oldv))
                        (ß ___r.set(___map.assoc(___k, ___newv)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"V" replace [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß bins[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Entry" ___e (ß ___map.entryAt(___k))]
                    (when (some? ___e)
                        (ß ___r.set(___map.assoc(___k, ___v)))
                        (§ return (ß (V) ___e.getValue()))
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

#_private
(defprotocol Buffer
    #_abstract
    (#_"Buffer" Buffer'''add [#_"Buffer" this, #_"Object" ___o])
    #_abstract
    (#_"Object" Buffer'''remove [#_"Buffer" this])
    #_abstract
    (#_"boolean" Buffer'''isEmpty [#_"Buffer" this])
)

#_private
#_stateless
(class-ns Empty (§ implements Buffer)
    #_method
    (§ defn #_"Buffer" add [#_"Empty" this, #_"Object" ___o]
        (Single. ___o)
    )

    #_method
    (§ defn #_"Object" remove [#_"Empty" this]
        (throw (IllegalStateException. "Removing object from empty buffer"))
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"Empty" this]
        true
    )

    #_method
    (§ defn #_"String" toString [#_"Empty" this]
        "Empty"
    )
)

#_private
(class-ns Single (§ implements Buffer)
    (§ init
        #_volatile
        (§ field- #_"Object" val nil)
    )

    (§ constructor #_"Single" Single [#_"Object" ___o]
        (let [this (ß super())]
            (§ ass (ß this.val) ___o)
            this
        )
    )

    #_method
    (§ defn #_"Buffer" add [#_"Single" this, #_"Object" ___o]
        (if (ß val == NONE)
            (do
                (§ ass val ___o)
                this
            )
            (do
                (ß new Many(val, ___o))
            )
        )
    )

    #_method
    (§ defn #_"Object" remove [#_"Single" this]
        (when (ß val == NONE)
            (throw (IllegalStateException. "Removing object from empty buffer"))
        )
        (let [#_"Object" ___ret val]
            (§ ass val NONE)
            ret
        )
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"Single" this]
        (ß (val == NONE))
    )

    #_method
    (§ defn #_"String" toString [#_"Single" this]
        (ß "Single: " + val)
    )
)

#_private
(class-ns Many (§ implements Buffer)
    (§ init
        (§ field- #_"Queue" vals (LinkedList.))
    )

    (§ constructor #_"Many" Many [#_"Object" ___o1, #_"Object" ___o2]
        (let [this (ß super())]
            (ß vals.add(___o1))
            (ß vals.add(___o2))
            this
        )
    )

    #_method
    (§ defn #_"Buffer" add [#_"Many" this, #_"Object" ___o]
        (ß vals.add(___o))
        this
    )

    #_method
    (§ defn #_"Object" remove [#_"Many" this]
        (ß vals.remove())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"Many" this]
        (ß vals.isEmpty())
    )

    #_method
    (§ defn #_"String" toString [#_"Many" this]
        (ß "Many: " + vals.toString())
    )
)

#_private
(class-ns MultiIterator (§ implements Iterator)
    (§ init
        (§ field- #_"Iterator[]" iters nil)
    )

    (§ constructor #_"MultiIterator" MultiIterator [#_"Iterator[]" ___iters]
        (let [this (ß super())]
            (§ ass (ß this.iters) ___iters)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"MultiIterator" this]
        (doseq [#_"Iterator" ___iter iters]
            (when (ß !___iter.hasNext())
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object" next [#_"MultiIterator" this]
        (let [#_"Object[]" ___nexts (ß new Object[iters.length])]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < iters.length) [(§ ass ___i (ß ___i + 1))]
                (§ ass (ß ___nexts[___i]) (ß iters[___i].next()))
            )
            (ß new ArraySeq(___nexts, 0))
        )
    )

    #_method
    (§ defn #_"void" remove [#_"MultiIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransformerIterator (§ implements Iterator)
    (§ def- #_"Buffer" TransformerIterator'EMPTY (Empty.))
    (§ def- #_"Object" TransformerIterator'NONE (Object.))

    (§ init
        ;; Source
        (§ field- #_"Iterator" sourceIter nil)
        (§ field- #_"IFn" xf nil)
        (§ field- #_"boolean" multi false)

        ;; Iteration state
        #_volatile
        (§ field- #_"Buffer" buffer EMPTY)
        #_volatile
        (§ field- #_"Object" next NONE)
        #_volatile
        (§ field- #_"boolean" completed false)
    )

    (§ constructor- #_"TransformerIterator" TransformerIterator [#_"IFn" ___xform, #_"Iterator" ___sourceIter, #_"boolean" ___multi]
        (let [this (ß super())]
            (§ ass (ß this.sourceIter) ___sourceIter)
            (§ ass (ß this.xf) (ß (IFn) ___xform.invoke(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this]
                            nil
                        )

                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___acc]
                            acc
                        )

                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___acc, #_"Object" ___o]
                            (§ ass buffer (ß buffer.add(___o)))
                            acc
                        )
                    )
                )
            ))
            (§ ass (ß this.multi) ___multi)
            this
        )
    )

    (§ defn #_"Iterator" TransformerIterator'create [#_"IFn" ___xform, #_"Iterator" ___source]
        (ß new TransformerIterator(___xform, ___source, false))
    )

    (§ defn #_"Iterator" TransformerIterator'createMulti [#_"IFn" ___xform, #_"List" ___sources]
        (let [#_"Iterator[]" ___iters (ß new Iterator[___sources.size()])]
            (loop-when-recur [(§ var #_"int" ___i 0)] (ß ___i < ___sources.size()) [(§ ass ___i (ß ___i + 1))]
                (§ ass (ß ___iters[___i]) (ß (Iterator)___sources.get(___i)))
            )
            (ß new TransformerIterator(___xform, new MultiIterator(___iters), true))
        )
    )

    #_method
    (§ defn- #_"boolean" step [#_"TransformerIterator" this]
        (when (ß next != NONE)
            (§ return true)
        )

        (while (ß next == NONE)
            (if (ß buffer.isEmpty())
                (do
                    (cond completed
                        (do
                            (§ return false)
                        )
                        (ß sourceIter.hasNext())
                        (do
                            (let [#_"Object" ___iter nil]
                                (if multi
                                    (do
                                        (§ ass ___iter (ß xf.applyTo(RT'cons(nil, sourceIter.next()))))
                                    )
                                    (do
                                        (§ ass ___iter (ß xf.invoke(nil, sourceIter.next())))
                                    )
                                )

                                (when (ß RT'isReduced(___iter))
                                    (ß xf.invoke(nil))
                                    (§ ass completed true)
                                )
                            )
                        )
                        :else
                        (do
                            (ß xf.invoke(nil))
                            (§ ass completed true)
                        )
                    )
                )
                (do
                    (§ ass next (ß buffer.remove()))
                )
            )
        )
        true
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"TransformerIterator" this]
        (ß step())
    )

    #_method
    (§ defn #_"Object" next [#_"TransformerIterator" this]
        (when (ß hasNext())
            (let [#_"Object" ___ret next]
                (§ ass next NONE)
                (§ return ___ret)
            )
        )
        (throw (NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"TransformerIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns Tuple
    (§ def #_"int" Tuple'MAX_SIZE 6)

    (§ defn #_"IPersistentVector" Tuple'create []
        (ß PersistentVector'EMPTY)
    )

    (§ defn #_"IPersistentVector" Tuple'create [#_"Object" ___v0]
        (ß RT'vector(___v0))
    )

    (§ defn #_"IPersistentVector" Tuple'create [#_"Object" ___v0, #_"Object" ___v1]
        (ß RT'vector(___v0, ___v1))
    )

    (§ defn #_"IPersistentVector" Tuple'create [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2]
        (ß RT'vector(___v0, ___v1, ___v2))
    )

    (§ defn #_"IPersistentVector" Tuple'create [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3]
        (ß RT'vector(___v0, ___v1, ___v2, ___v3))
    )

    (§ defn #_"IPersistentVector" Tuple'create [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3, #_"Object" ___v4]
        (ß RT'vector(___v0, ___v1, ___v2, ___v3, ___v4))
    )

    (§ defn #_"IPersistentVector" Tuple'create [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3, #_"Object" ___v4, #_"Object" ___v5]
        (ß RT'vector(___v0, ___v1, ___v2, ___v3, ___v4, ___v5))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(defprotocol EquivPred
    #_abstract
    (#_"boolean" EquivPred'''equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2])
)

#_stateless
(class-ns Util
    (§ defn #_"boolean" Util'equiv [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return true)
        )
        (when (some? ___k1)
            (cond (ß ___k1 instanceof Number && ___k2 instanceof Number)
                (do
                    (§ return (ß Numbers'equal((Number)___k1, (Number)___k2)))
                )
                (ß ___k1 instanceof IPersistentCollection || ___k2 instanceof IPersistentCollection)
                (do
                    (§ return (ß pcequiv(___k1, ___k2)))
                )
            )
            (§ return (ß ___k1.equals(___k2)))
        )
        false
    )

    (§ def #_"EquivPred" Util'equivNull
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (ß (___k2 == nil))
            )
        )
    )

    (§ def #_"EquivPred" Util'equivEquals
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (ß ___k1.equals(___k2))
            )
        )
    )

    (§ def #_"EquivPred" Util'equivNumber
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (when (ß ___k2 instanceof Number)
                    (§ return (ß Numbers'equal((Number) ___k1, (Number) ___k2)))
                )
                false
            )
        )
    )

    (§ def #_"EquivPred" Util'equivColl
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (when (ß ___k1 instanceof IPersistentCollection || ___k2 instanceof IPersistentCollection)
                    (§ return (ß pcequiv(___k1, ___k2)))
                )
                (ß ___k1.equals(___k2))
            )
        )
    )

    (§ defn #_"EquivPred" Util'equivPred [#_"Object" ___k1]
        (cond (nil? ___k1)
            (do
                (§ return equivNull)
            )
            (ß ___k1 instanceof Number)
            (do
                (§ return equivNumber)
            )
            (ß ___k1 instanceof String || ___k1 instanceof Symbol)
            (do
                (§ return equivEquals)
            )
            (ß ___k1 instanceof Collection || ___k1 instanceof Map)
            (do
                (§ return equivColl)
            )
        )
        equivEquals
    )

    (§ defn #_"boolean" Util'equiv [#_"long" ___k1, #_"long" ___k2]
        (ß (___k1 == ___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"Object" ___k1, #_"long" ___k2]
        (ß equiv(___k1, (Object)___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"long" ___k1, #_"Object" ___k2]
        (ß equiv((Object)___k1, ___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"double" ___k1, #_"double" ___k2]
        (ß (___k1 == ___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"Object" ___k1, #_"double" ___k2]
        (ß equiv(___k1, (Object)___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"double" ___k1, #_"Object" ___k2]
        (ß equiv((Object)___k1, ___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"boolean" ___k1, #_"boolean" ___k2]
        (ß (___k1 == ___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"Object" ___k1, #_"boolean" ___k2]
        (ß equiv(___k1, (Object)___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"boolean" ___k1, #_"Object" ___k2]
        (ß equiv((Object)___k1, ___k2))
    )

    (§ defn #_"boolean" Util'equiv [#_"char" ___c1, #_"char" ___c2]
        (ß (___c1 == ___c2))
    )

    (§ defn #_"boolean" Util'pcequiv [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 instanceof IPersistentCollection)
            (§ return (ß ((IPersistentCollection)___k1).equiv(___k2)))
        )
        (ß ((IPersistentCollection)___k2).equiv(___k1))
    )

    (§ defn #_"boolean" Util'equals [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return true)
        )
        (ß (___k1 != nil && ___k1.equals(___k2)))
    )

    (§ defn #_"boolean" Util'identical [#_"Object" ___k1, #_"Object" ___k2]
        (ß (___k1 == ___k2))
    )

    (§ defn #_"Class" Util'classOf [#_"Object" ___x]
        (when (some? ___x)
            (§ return (ß ___x.getClass()))
        )
        nil
    )

    (§ defn #_"int" Util'compare [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return 0)
        )
        (when (some? ___k1)
            (when (nil? ___k2)
                (§ return 1)
            )
            (when (ß ___k1 instanceof Number)
                (§ return (ß Numbers'compare((Number) ___k1, (Number) ___k2)))
            )
            (§ return (ß ((Comparable) ___k1).compareTo(___k2)))
        )
        -1
    )

    (§ defn #_"int" Util'hash [#_"Object" ___o]
        (when (nil? ___o)
            (§ return 0)
        )
        (ß ___o.hashCode())
    )

    (§ defn #_"int" Util'hasheq [#_"Object" ___o]
        (when (nil? ___o)
            (§ return 0)
        )
        (when (ß ___o instanceof IHashEq)
            (§ return (ß dohasheq((IHashEq) ___o)))
        )
        (when (ß ___o instanceof Number)
            (§ return (ß Numbers'hasheq((Number)___o)))
        )
        (when (ß ___o instanceof String)
            (§ return (ß Murmur3'hashInt(___o.hashCode())))
        )
        (ß ___o.hashCode())
    )

    (§ defn- #_"int" Util'dohasheq [#_"IHashEq" ___o]
        (ß ___o.hasheq())
    )

    (§ defn #_"int" Util'hashCombine [#_"int" ___seed, #_"int" ___hash]
        ;; a la boost
        (§ ass ___seed (ß ___seed :xor (___hash + 0x9e3779b9 + (___seed << 6) + (___seed >> 2))))
        seed
    )

    (§ defn #_"boolean" Util'isPrimitive [#_"Class" ___c]
        (ß (___c != nil && ___c.isPrimitive() && !(___c == Void/TYPE)))
    )

    (§ defn #_"boolean" Util'isInteger [#_"Object" ___x]
        (ß (___x instanceof Integer || ___x instanceof Long || ___x instanceof BigInt || ___x instanceof BigInteger))
    )

    (§ defn #_"Object" Util'ret1 [#_"Object" ___ret, #_"Object" ___nil]
        ret
    )

    (§ defn #_"ISeq" Util'ret1 [#_"ISeq" ___ret, #_"Object" ___nil]
        ret
    )

    (§ defn #_"<K, V> void" Util'clearCache [#_"ReferenceQueue" ___rq, #_"ConcurrentHashMap<K, Reference<V>>" ___cache]
        ;; cleanup any dead entries
        (when (ß ___rq.poll() != nil)
            (while (ß ___rq.poll() != nil)
            )
            (doseq [#_"Map$Entry<K, Reference<V>>" ___e (ß ___cache.entrySet())]
                (let [#_"Reference<V>" ___val (ß ___e.getValue())]
                    (when (ß ___val != nil && ___val.get() == nil)
                        (ß ___cache.remove(___e.getKey(), ___val))
                    )
                )
            )
        )
        nil
    )

    (§ defn #_"RuntimeException" Util'runtimeException [#_"String" ___s]
        (RuntimeException. ___s)
    )

    (§ defn #_"RuntimeException" Util'runtimeException [#_"String" ___s, #_"Throwable" ___e]
        (ß new RuntimeException(___s, ___e))
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (§ defn #_"RuntimeException" Util'sneakyThrow [#_"Throwable" ___t]
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (nil? ___t)
            (throw (NullPointerException.))
        )
        (ß Util'<RuntimeException>sneakyThrow0(___t))
        nil
    )

    (§ defn- #_"<T extends Throwable> void" Util'sneakyThrow0 [#_"Throwable" ___t] #_(§ throws T)
        (throw (ß (T) ___t))
    )

    (§ defn #_"Object" Util'loadWithClass [#_"String" ___scriptbase, #_"Class<?>" ___loadFrom] #_(§ throws IOException, ClassNotFoundException)
        (ß Var'pushThreadBindings(RT'map(new Object[] (§ array (ß Compiler'LOADER), (ß ___loadFrom.getClassLoader()) ))))
        (try
            (ß RT'var("cloiure.core", "load").invoke(___scriptbase))
            (finally
                (ß Var'popThreadBindings())
            )
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns TBox
    (§ init
        #_volatile
        (§ field #_"Object" val nil)
        (§ field #_"Thread" thread nil)
    )

    (§ constructor #_"TBox" TBox [#_"Thread" ___t, #_"Object" ___val]
        (let [this (ß super())]
            (§ ass (ß this.thread) ___t)
            (§ ass (ß this.val) ___val)
            this
        )
    )
)

(class-ns Unbound (§ extends AFn)
    (§ init
        (§ field #_"Var" v nil)
    )

    (§ constructor #_"Unbound" Unbound [#_"Var" ___v]
        (let [this (ß super())]
            (§ ass (ß this.v) ___v)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"Unbound" this]
        (ß "Unbound: " + v)
    )

    #_method
    (§ defn #_"Object" throwArity [#_"Unbound" this, #_"int" ___n]
        (throw (IllegalStateException. (ß "Attempting to call unbound fn: " + v)))
    )
)

(class-ns Frame
    (§ def #_"Frame" Frame'TOP (ß new Frame(PersistentHashMap'EMPTY, nil)))

    (§ init
        ;; Var->TBox
        (§ field #_"Associative" bindings nil)
        ;; Var->val
        (§ field #_"Frame" prev nil)
    )

    (§ constructor #_"Frame" Frame [#_"Associative" ___bindings, #_"Frame" ___prev]
        (let [this (ß super())]
            (§ ass (ß this.bindings) ___bindings)
            (§ ass (ß this.prev) ___prev)
            this
        )
    )

    #_protected
    #_method
    (§ defn #_"Object" clone [#_"Frame" this]
        (ß new Frame(this.bindings, nil))
    )
)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (§ def #_"ThreadLocal<Frame>" Var'dvals
        (§ reify ThreadLocal<Frame>()
            #_protected
            #_method
            (§ defn #_"Frame" initialValue [#_"ThreadLocal<Frame>" this]
                (ß Frame'TOP)
            )
        )
    )

    #_volatile
    (§ def #_"int" Var'rev 0)

    (§ def #_"Keyword" Var'privateKey (ß Keyword'intern(nil, "private")))
    (§ def #_"IPersistentMap" Var'privateMeta (ß new PersistentArrayMap(new Object[] (§ array privateKey, (ß Boolean/TRUE) ))))
    (§ def #_"Keyword" Var'macroKey (ß Keyword'intern(nil, "macro")))
    (§ def #_"Keyword" Var'nameKey (ß Keyword'intern(nil, "name")))
    (§ def #_"Keyword" Var'nsKey (ß Keyword'intern(nil, "ns")))

    (§ defn #_"Object" Var'getThreadBindingFrame []
        (ß dvals.get())
    )

    (§ defn #_"Object" Var'cloneThreadBindingFrame []
        (ß dvals.get().clone())
    )

    (§ defn #_"void" Var'resetThreadBindingFrame [#_"Object" ___frame]
        (ß dvals.set((Frame) ___frame))
        nil
    )

    (§ defn #_"Var" Var'intern [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root]
        (ß intern(___ns, ___sym, ___root, true))
    )

    (§ defn #_"Var" Var'intern [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root, #_"boolean" ___replaceRoot]
        (let [#_"Var" ___dvout (ß ___ns.intern(___sym))]
            (when (ß !___dvout.hasRoot() || ___replaceRoot)
                (ß ___dvout.bindRoot(___root))
            )
            dvout
        )
    )

    (§ defn #_"Var" Var'find [#_"Symbol" ___nsQualifiedSym]
        (when (ß ___nsQualifiedSym.ns == nil)
            (throw (IllegalArgumentException. "Symbol must be namespace-qualified"))
        )
        (let [#_"Namespace" ___ns (ß Namespace'find(Symbol'intern(___nsQualifiedSym.ns)))]
            (when (nil? ___ns)
                (throw (IllegalArgumentException. (ß "No such namespace: " + ___nsQualifiedSym.ns)))
            )
            (ß ___ns.findInternedVar(Symbol'intern(___nsQualifiedSym.name)))
        )
    )

    (§ defn #_"Var" Var'intern [#_"Symbol" ___nsName, #_"Symbol" ___sym]
        (let [#_"Namespace" ___ns (ß Namespace'findOrCreate(___nsName))]
            (ß intern(___ns, ___sym))
        )
    )

    (§ defn #_"Var" Var'internPrivate [#_"String" ___nsName, #_"String" ___sym]
        (let [#_"Namespace" ___ns (ß Namespace'findOrCreate(Symbol'intern(___nsName)))]
            (let [#_"Var" ___ret (ß intern(___ns, Symbol'intern(___sym)))]
                (ß ___ret.setMeta(privateMeta))
                ret
            )
        )
    )

    (§ defn #_"Var" Var'intern [#_"Namespace" ___ns, #_"Symbol" ___sym]
        (ß ___ns.intern(___sym))
    )

    (§ defn #_"Var" Var'create []
        (ß new Var(nil, nil))
    )

    (§ defn #_"Var" Var'create [#_"Object" ___root]
        (ß new Var(nil, nil, ___root))
    )

    (§ init
        #_volatile
        (§ field #_"Object" root nil)

        #_volatile
        (§ field #_"boolean" dynamic false)
        #_transient
        (§ field #_"AtomicBoolean" threadBound nil)
        (§ field #_"Symbol" sym nil)
        (§ field #_"Namespace" ns nil)
    )

    (§ constructor #_"Var" Var [#_"Namespace" ___ns, #_"Symbol" ___sym]
        (let [this (ß super())]
            (§ ass (ß this.ns) ___ns)
            (§ ass (ß this.sym) ___sym)
            (§ ass (ß this.threadBound) (AtomicBoolean. false))
            (§ ass (ß this.root) (Unbound. this))
            (ß setMeta(PersistentHashMap'EMPTY))
            this
        )
    )

    (§ constructor #_"Var" Var [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root]
        (let [this (ß this(___ns, ___sym))]
            (§ ass (ß this.root) ___root)
            (§ ass rev (ß rev + 1))
            this
        )
    )

    #_method
    (§ defn #_"Var" setDynamic [#_"Var" this]
        (§ ass (ß this.dynamic) true)
        this
    )

    #_method
    (§ defn #_"Var" setDynamic [#_"Var" this, #_"boolean" ___b]
        (§ ass (ß this.dynamic) ___b)
        this
    )

    #_method
    (§ defn #_"boolean" isDynamic [#_"Var" this]
        dynamic
    )

    #_method
    (§ defn #_"String" toString [#_"Var" this]
        (when (some? ns)
            (§ return (ß "#'" + ns.name + "/" + sym))
        )
        (ß "#<Var: " + ((sym != nil) ? sym.toString() :or "--unnamed--") + ">")
    )

    #_method
    (§ defn #_"boolean" isBound [#_"Var" this]
        (ß (hasRoot() || (threadBound.get() && dvals.get().bindings.containsKey(this))))
    )

    #_method
    (§ defn #_"Object" get [#_"Var" this]
        (when (ß !threadBound.get())
            (§ return root)
        )
        (ß deref())
    )

    #_method
    (§ defn #_"Object" deref [#_"Var" this]
        (let [#_"TBox" ___b (ß getThreadBinding())]
            (when (some? ___b)
                (§ return (ß ___b.val))
            )
            root
        )
    )

    #_method
    (§ defn #_"void" setValidator [#_"Var" this, #_"IFn" ___vf]
        (when (ß hasRoot())
            (ß validate(___vf, root))
        )
        (§ ass validator ___vf)
        nil
    )

    #_method
    (§ defn #_"Object" alter [#_"Var" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (ß set(___fn.applyTo(RT'cons(deref(), ___args))))
        this
    )

    #_method
    (§ defn #_"Object" set [#_"Var" this, #_"Object" ___val]
        (ß validate(getValidator(), ___val))
        (let [#_"TBox" ___b (ß getThreadBinding())]
            (when (some? ___b)
                (when (ß Thread/currentThread() != ___b.thread)
                    (throw (ß new IllegalStateException(String/format("Can't set!: %s from non-binding thread", sym))))
                )
                (§ ass (ß ___b.val) ___val)
                (§ return ___val)
            )
            (throw (ß new IllegalStateException(String/format("Can't change/establish root binding of: %s with set", sym))))
        )
    )

    #_method
    (§ defn #_"Object" doSet [#_"Var" this, #_"Object" ___val]
        (ß set(___val))
    )

    #_method
    (§ defn #_"Object" doReset [#_"Var" this, #_"Object" ___val]
        (ß bindRoot(___val))
        val
    )

    #_method
    (§ defn #_"void" setMeta [#_"Var" this, #_"IPersistentMap" ___m]
        ;; ensure these basis keys
        (ß resetMeta(___m.assoc(nameKey, sym).assoc(nsKey, ns)))
        nil
    )

    #_method
    (§ defn #_"void" setMacro [#_"Var" this]
        (ß alterMeta(assoc, RT'list(macroKey, RT'T)))
        nil
    )

    #_method
    (§ defn #_"boolean" isMacro [#_"Var" this]
        (ß RT'booleanCast(meta().valAt(macroKey)))
    )

    #_method
    (§ defn #_"boolean" isPublic [#_"Var" this]
        (ß !RT'booleanCast(meta().valAt(privateKey)))
    )

    #_method
    (§ defn #_"Object" getRawRoot [#_"Var" this]
        root
    )

    #_method
    (§ defn #_"Object" getTag [#_"Var" this]
        (ß meta().valAt(RT'TAG_KEY))
    )

    #_method
    (§ defn #_"void" setTag [#_"Var" this, #_"Symbol" ___tag]
        (ß alterMeta(assoc, RT'list(RT'TAG_KEY, ___tag)))
        nil
    )

    #_method
    (§ defn #_"boolean" hasRoot [#_"Var" this]
        (ß !(root instanceof Unbound))
    )

    ;; binding root always clears macro flag
    #_method
    (§ defn #_"void" bindRoot [#_"Var" this, #_"Object" ___root]
        (§ sync this
            (ß validate(getValidator(), ___root))
            (let [#_"Object" ___oldroot (ß this.root)]
                (§ ass (ß this.root) ___root)
                (§ ass rev (ß rev + 1))
                (ß alterMeta(Var'dissoc, RT'list(macroKey)))
                (ß notifyWatches(___oldroot, this.root))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" swapRoot [#_"Var" this, #_"Object" ___root]
        (§ sync this
            (ß validate(getValidator(), ___root))
            (let [#_"Object" ___oldroot (ß this.root)]
                (§ ass (ß this.root) ___root)
                (§ ass rev (ß rev + 1))
                (ß notifyWatches(___oldroot, ___root))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" unbindRoot [#_"Var" this]
        (§ sync this
            (§ ass (ß this.root) (Unbound. this))
            (§ ass rev (ß rev + 1))
        )
        nil
    )

    #_method
    (§ defn #_"void" commuteRoot [#_"Var" this, #_"IFn" ___fn]
        (§ sync this
            (let [#_"Object" ___newRoot (ß ___fn.invoke(root))]
                (ß validate(getValidator(), ___newRoot))
                (let [#_"Object" ___oldroot root]
                    (§ ass (ß this.root) ___newRoot)
                    (§ ass rev (ß rev + 1))
                    (ß notifyWatches(___oldroot, ___newRoot))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" alterRoot [#_"Var" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (§ sync this
            (let [#_"Object" ___newRoot (ß ___fn.applyTo(RT'cons(root, ___args)))]
                (ß validate(getValidator(), ___newRoot))
                (let [#_"Object" ___oldroot root]
                    (§ ass (ß this.root) ___newRoot)
                    (§ ass rev (ß rev + 1))
                    (ß notifyWatches(___oldroot, ___newRoot))
                    ___newRoot
                )
            )
        )
    )

    (§ defn #_"void" Var'pushThreadBindings [#_"Associative" ___bindings]
        (let [#_"Frame" ___f (ß dvals.get())]
            (let [#_"Associative" ___bmap (ß ___f.bindings)]
                (loop-when-recur [(§ var #_"ISeq" ___bs (ß ___bindings.seq()))] (some? ___bs) [(§ ass ___bs (ß ___bs.next()))]
                    (let [#_"IMapEntry" ___e (ß (IMapEntry) ___bs.first())]
                        (let [#_"Var" ___v (ß (Var) ___e.key())]
                            (when (ß !___v.dynamic)
                                (throw (ß new IllegalStateException(String/format("Can't dynamically bind non-dynamic var: %s/%s", ___v.ns, ___v.sym))))
                            )
                            (ß ___v.validate(___v.getValidator(), ___e.val()))
                            (ß ___v.threadBound.set(true))
                            (§ ass ___bmap (ß ___bmap.assoc(___v, new TBox(Thread/currentThread(), ___e.val()))))
                        )
                    )
                )
                (ß dvals.set(new Frame(___bmap, ___f)))
                nil
            )
        )
    )

    (§ defn #_"void" Var'popThreadBindings []
        (let [#_"Frame" ___f (ß dvals.get().prev)]
            (cond (nil? ___f)
                (do
                    (throw (IllegalStateException. "Pop without matching push"))
                )
                (ß ___f == Frame'TOP)
                (do
                    (ß dvals.remove())
                )
                :else
                (do
                    (ß dvals.set(___f))
                )
            )
            nil
        )
    )

    (§ defn #_"Associative" Var'getThreadBindings []
        (let [#_"Frame" ___f (ß dvals.get())]
            (let [#_"IPersistentMap" ___ret (ß PersistentHashMap'EMPTY)]
                (loop-when-recur [(§ var #_"ISeq" ___bs (ß ___f.bindings.seq()))] (some? ___bs) [(§ ass ___bs (ß ___bs.next()))]
                    (let [#_"IMapEntry" ___e (ß (IMapEntry) ___bs.first())]
                        (let [#_"Var" ___v (ß (Var) ___e.key())]
                            (let [#_"TBox" ___b (ß (TBox) ___e.val())]
                                (§ ass ___ret (ß ___ret.assoc(___v, ___b.val)))
                            )
                        )
                    )
                )
                ret
            )
        )
    )

    #_method
    (§ defn #_"TBox" getThreadBinding [#_"Var" this]
        (when (ß threadBound.get())
            (let [#_"IMapEntry" ___e (ß dvals.get().bindings.entryAt(this))]
                (when (some? ___e)
                    (§ return (ß (TBox) ___e.val()))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IFn" fn [#_"Var" this]
        (ß (IFn) deref())
    )

    #_method
    (§ defn #_"Object" call [#_"Var" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"Var" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this]
        (ß fn().invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil)),
                Util'ret1(___arg20, (§ ass ___arg20 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil)),
                Util'ret1(___arg20, (§ ass ___arg20 nil)),
                (Object[])Util'ret1(___args, (§ ass ___args nil))))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Var" this, #_"ISeq" ___arglist]
        (ß fn().applyTo(___arglist))
    )

    (§ def #_"IFn" Var'assoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___m, #_"Object" ___k, #_"Object" ___v]
                (ß RT'assoc(___m, ___k, ___v))
            )
        )
    )

    (§ def #_"IFn" Var'dissoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___c, #_"Object" ___k]
                (ß RT'dissoc(___c, ___k))
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    (§ init
        #_volatile
        (§ field #_"Object" val nil)
    )

    (§ constructor #_"Volatile" Volatile [#_"Object" ___val]
        (let [this (ß super())]
            (§ ass (ß this.val) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Volatile" this]
        val
    )

    #_method
    (§ defn #_"Object" reset [#_"Volatile" this, #_"Object" ___newval]
        (§ ass (ß this.val) ___newval)
    )
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

#_stateless
(class-ns main
    (§ def- #_"Symbol" main'CLOIURE_MAIN (ß Symbol'intern("cloiure.main")))
    (§ def- #_"Var" main'REQUIRE (ß RT'var("cloiure.core", "require")))
    (§ def- #_"Var" main'MAIN (ß RT'var("cloiure.main", "main")))

    (§ defn #_"void" main'main [#_"String[]" ___args]
        (ß REQUIRE.invoke(CLOIURE_MAIN))
        (ß MAIN.applyTo(RT'seq(___args)))
        nil
    )
)
)
