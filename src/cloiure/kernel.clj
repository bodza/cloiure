(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(java-ns cloiure.lang.AFn

(§ class public abstract class AFn implements IFn)
(§
    public Object call()
    (§
        (§ return (§ expr invoke()))
    )

    public void run()
    (§
        invoke()
    )

    public Object invoke()
    (§
        (§ return (§ expr throwArity(0)))
    )

    public Object invoke(Object arg1)
    (§
        (§ return (§ expr throwArity(1)))
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        (§ return (§ expr throwArity(2)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        (§ return (§ expr throwArity(3)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        (§ return (§ expr throwArity(4)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        (§ return (§ expr throwArity(5)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        (§ return (§ expr throwArity(6)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        (§ return (§ expr throwArity(7)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        (§ return (§ expr throwArity(8)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        (§ return (§ expr throwArity(9)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        (§ return (§ expr throwArity(10)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        (§ return (§ expr throwArity(11)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        (§ return (§ expr throwArity(12)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        (§ return (§ expr throwArity(13)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        (§ return (§ expr throwArity(14)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        (§ return (§ expr throwArity(15)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        (§ return (§ expr throwArity(16)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        (§ return (§ expr throwArity(17)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        (§ return (§ expr throwArity(18)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        (§ return (§ expr throwArity(19)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        (§ return (§ expr throwArity(20)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
    (§
        (§ return (§ expr throwArity(21)))
    )

    public Object applyTo(ISeq arglist)
    (§
        (§ return (§ expr applyToHelper(this, Util.ret1(arglist, arglist = nil))))
    )

    static public Object applyToHelper(IFn ifn, ISeq arglist)
    (§
        switch (RT.boundedLength(arglist, 20))
        (§
            (§ case 0)
                arglist = nil
                (§ return (§ expr ifn.invoke()))
            (§ case 1)
                (§ return (§ expr ifn.invoke(Util.ret1(arglist.first(), arglist = nil))))
            (§ case 2)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 3)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 4)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 5)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 6)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 7)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 8)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 9)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 10)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 11)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 12)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 13)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 14)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 15)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 16)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 17)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 18)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 19)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ case 20)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        Util.ret1((arglist = arglist.next()).first(), arglist = nil))))
            (§ default)
                (§ return (§ expr ifn.invoke(arglist.first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        (arglist = arglist.next()).first(),
                        RT.seqToArray(Util.ret1(arglist.next(), arglist = nil)))))
        )
    )

    public Object throwArity(int n)
    (§
        String name = getClass().getSimpleName()
        throw new ArityException(n, Compiler.demunge(name))
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.io.Serializable)
(§ import java.util.Comparator)

(§ class public abstract class AFunction extends AFn implements IObj, Comparator, Fn, Serializable)
(§
    public volatile MethodImplCache __methodImplCache

    public IPersistentMap meta()
    (§
        (§ return (§ expr nil))
    )

    public IObj withMeta(final IPersistentMap meta)
    (§
        (§ return (§ expr new RestFn()
        (§
            protected Object doInvoke(Object args)
            (§
                (§ return (§ expr AFunction.this.applyTo((ISeq) args)))
            )

            public IPersistentMap meta()
            (§
                (§ return (§ expr meta))
            )

            public IObj withMeta(IPersistentMap meta)
            (§
                (§ return (§ expr AFunction.this.withMeta(meta)))
            )

            public int getRequiredArity()
            (§
                (§ return (§ expr 0))
            )
        )))
    )

    public int compare(Object o1, Object o2)
    (§
        Object o = invoke(o1, o2)

        if (o instanceof Boolean)
        (§
            if (RT.booleanCast(o))
            (§
                (§ return (§ expr -1))
            )
            (§ return (§ expr RT.booleanCast(invoke(o2, o1)) ? 1 :or 0))
        )

        Number n = (Number) o
        (§ return (§ expr n.intValue()))
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(§ class public class Agent extends ARef)
(§
    static class ActionQueue
    (§
        public final IPersistentStack q
        public final Throwable error ;; non-null indicates fail state
        static final ActionQueue EMPTY = new ActionQueue(PersistentQueue.EMPTY, nil)

        public ActionQueue(IPersistentStack q, Throwable error)
        (§
            this.q = q
            this.error = error
        )
    )

    static final Keyword CONTINUE = Keyword.intern(nil, "continue")
    static final Keyword FAIL = Keyword.intern(nil, "fail")

    volatile Object state
    AtomicReference<ActionQueue> aq = new AtomicReference<ActionQueue>(ActionQueue.EMPTY)

    volatile Keyword errorMode = CONTINUE
    volatile IFn errorHandler = nil

    final private static AtomicLong sendThreadPoolCounter = new AtomicLong(0)

    final private static AtomicLong sendOffThreadPoolCounter = new AtomicLong(0)

    volatile public static ExecutorService pooledExecutor = Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter))

    volatile public static ExecutorService soloExecutor = Executors.newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter))

    final static ThreadLocal<IPersistentVector> nested = new ThreadLocal<IPersistentVector>()

    private static ThreadFactory createThreadFactory(final String format, final AtomicLong threadPoolCounter)
    (§
        (§ return (§ expr new ThreadFactory()
        (§
            public Thread newThread(Runnable runnable)
            (§
                Thread thread = new Thread(runnable)
                thread.setName(String.format(format, threadPoolCounter.getAndIncrement()))
                (§ return (§ expr thread))
            )
        )))
    )

    public static void shutdown()
    (§
        soloExecutor.shutdown()
        pooledExecutor.shutdown()
    )

    static class Action implements Runnable
    (§
        final Agent agent
        final IFn fn
        final ISeq args
        final Executor exec

        public Action(Agent agent, IFn fn, ISeq args, Executor exec)
        (§
            this.agent = agent
            this.args = args
            this.fn = fn
            this.exec = exec
        )

        void execute()
        (§
            try
            (§
                exec.execute(this)
            )
            catch (Throwable error)
            (§
                if (agent.errorHandler != nil)
                (§
                    try
                    (§
                        agent.errorHandler.invoke(agent, error)
                    )
                    catch (Throwable e) ;; ignore errorHandler errors
                    (§
                    )
                )
            )
        )

        static void doRun(Action action)
        (§
            try
            (§
                nested.set(PersistentVector.EMPTY)

                Throwable error = nil
                try
                (§
                    Object oldval = action.agent.state
                    Object newval =  action.fn.applyTo(RT.cons(action.agent.state, action.args))
                    action.agent.setState(newval)
                    action.agent.notifyWatches(oldval, newval)
                )
                catch (Throwable e)
                (§
                    error = e
                )

                if (error == nil)
                (§
                    releasePendingSends()
                )
                else
                (§
                    nested.set(nil) ;; allow errorHandler to send
                    if (action.agent.errorHandler != nil)
                    (§
                        try
                        (§
                            action.agent.errorHandler.invoke(action.agent, error)
                        )
                        catch (Throwable e) ;; ignore errorHandler errors
                        (§
                        )
                    )
                    if (action.agent.errorMode == CONTINUE)
                    (§
                        error = nil
                    )
                )

                boolean popped = false
                ActionQueue next = nil
                while (!popped)
                (§
                    ActionQueue prior = action.agent.aq.get()
                    next = new ActionQueue(prior.q.pop(), error)
                    popped = action.agent.aq.compareAndSet(prior, next)
                )

                if (error == nil && next.q.count() > 0)
                (§
                    ((Action) next.q.peek()).execute()
                )
            )
            finally
            (§
                nested.set(nil)
            )
        )

        public void run()
        (§
            doRun(this)
        )
    )

    public Agent(Object state)
    (§
        this(state, nil)
    )

    public Agent(Object state, IPersistentMap meta)
    (§
        super(meta)
        setState(state)
    )

    boolean setState(Object newState)
    (§
        validate(newState)
        boolean ret = (state != newState)
        state = newState
        (§ return (§ expr ret))
    )

    public Object deref()
    (§
        (§ return (§ expr state))
    )

    public Throwable getError()
    (§
        (§ return (§ expr aq.get().error))
    )

    public void setErrorMode(Keyword k)
    (§
        errorMode = k
    )

    public Keyword getErrorMode()
    (§
        (§ return (§ expr errorMode))
    )

    public void setErrorHandler(IFn f)
    (§
        errorHandler = f
    )

    public IFn getErrorHandler()
    (§
        (§ return (§ expr errorHandler))
    )

    synchronized public Object restart(Object newState, boolean clearActions)
    (§
        if (getError() == nil)
        (§
            throw Util.runtimeException("Agent does not need a restart")
        )
        validate(newState)
        state = newState

        if (clearActions)
        (§
            aq.set(ActionQueue.EMPTY)
        )
        else
        (§
            boolean restarted = false
            ActionQueue prior = nil
            while (!restarted)
            (§
                prior = aq.get()
                restarted = aq.compareAndSet(prior, new ActionQueue(prior.q, nil))
            )

            if (prior.q.count() > 0)
            (§
                ((Action) prior.q.peek()).execute()
            )
        )

        (§ return (§ expr newState))
    )

    public Object dispatch(IFn fn, ISeq args, Executor exec)
    (§
        Throwable error = getError()
        if (error != nil)
        (§
            throw Util.runtimeException("Agent is failed, needs restart", error)
        )
        Action action = new Action(this, fn, args, exec)
        dispatchAction(action)

        (§ return (§ expr this))
    )

    static void dispatchAction(Action action)
    (§
        LockingTransaction trans = LockingTransaction.getRunning()
        if (trans != nil)
        (§
            trans.enqueue(action)
        )
        else if (nested.get() != nil)
        (§
            nested.set(nested.get().cons(action))
        )
        else
        (§
            action.agent.enqueue(action)
        )
    )

    void enqueue(Action action)
    (§
        boolean queued = false
        ActionQueue prior = nil
        while (!queued)
        (§
            prior = aq.get()
            queued = aq.compareAndSet(prior, new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error))
        )

        if (prior.q.count() == 0 && prior.error == nil)
        (§
            action.execute()
        )
    )

    public int getQueueCount()
    (§
        (§ return (§ expr aq.get().q.count()))
    )

    static public int releasePendingSends()
    (§
        IPersistentVector sends = nested.get()
        if (sends == nil)
        (§
            (§ return (§ expr 0))
        )
        for (int i = 0 i < sends.count() i++)
        (§
            Action a = (Action) sends.valAt(i)
            a.agent.enqueue(a)
        )
        nested.set(PersistentVector.EMPTY)
        (§ return (§ expr sends.count()))
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

(§ class public abstract class AMapEntry extends APersistentVector implements IMapEntry)
(§
    public Object nth(int i)
    (§
        if (i == 0)
        (§
            (§ return (§ expr key()))
        )
        else if (i == 1)
        (§
            (§ return (§ expr val()))
        )
        else
        (§
            throw new IndexOutOfBoundsException()
        )
    )

    private IPersistentVector asVector()
    (§
        (§ return (§ expr LazilyPersistentVector.createOwning(key(), val())))
    )

    public IPersistentVector assocN(int i, Object val)
    (§
        (§ return (§ expr asVector().assocN(i, val)))
    )

    public int count()
    (§
        (§ return (§ expr 2))
    )

    public ISeq seq()
    (§
        (§ return (§ expr asVector().seq()))
    )

    public IPersistentVector cons(Object o)
    (§
        (§ return (§ expr asVector().cons(o)))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr nil))
    )

    public IPersistentStack pop()
    (§
        (§ return (§ expr LazilyPersistentVector.createOwning(key())))
    )

    public Object setValue(Object value)
    (§
        throw new UnsupportedOperationException()
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.io.Serializable)
(§ import java.util.*)

(§ class public abstract class APersistentMap extends AFn implements IPersistentMap, Map, Iterable, Serializable, MapEquivalence, IHashEq)
(§
    int _hash
    int _hasheq

    public String toString()
    (§
        (§ return (§ expr RT.printString(this)))
    )

    public IPersistentCollection cons(Object o)
    (§
        if (o instanceof Map.Entry)
        (§
            Map.Entry e = (Map.Entry) o

            (§ return (§ expr assoc(e.getKey(), e.getValue())))
        )
        else if (o instanceof IPersistentVector)
        (§
            IPersistentVector v = (IPersistentVector) o
            if (v.count() != 2)
            (§
                throw new IllegalArgumentException("Vector arg to map conj must be a pair")
            )
            (§ return (§ expr assoc(v.nth(0), v.nth(1))))
        )

        IPersistentMap ret = this
        for (ISeq es = RT.seq(o) es != nil es = es.next())
        (§
            Map.Entry e = (Map.Entry) es.first()
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        (§ return (§ expr ret))
    )

    public boolean equals(Object obj)
    (§
        (§ return (§ expr mapEquals(this, obj)))
    )

    static public boolean mapEquals(IPersistentMap m1, Object obj)
    (§
        if (m1 == obj)
        (§
            (§ return (§ expr true))
        )
        if (!(obj instanceof Map))
        (§
            (§ return (§ expr false))
        )
        Map m = (Map) obj

        if (m.size() != m1.count())
        (§
            (§ return (§ expr false))
        )

        for (ISeq s = m1.seq() s != nil s = s.next())
        (§
            Map.Entry e = (Map.Entry) s.first()
            boolean found = m.containsKey(e.getKey())

            if (!found || !Util.equals(e.getValue(), m.get(e.getKey())))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    public boolean equiv(Object obj)
    (§
        if (!(obj instanceof Map))
        (§
            (§ return (§ expr false))
        )
        if (obj instanceof IPersistentMap && !(obj instanceof MapEquivalence))
        (§
            (§ return (§ expr false))
        )

        Map m = (Map) obj

        if (m.size() != size())
        (§
            (§ return (§ expr false))
        )

        for (ISeq s = seq() s != nil s = s.next())
        (§
            Map.Entry e = (Map.Entry) s.first()
            boolean found = m.containsKey(e.getKey())

            if (!found || !Util.equiv(e.getValue(), m.get(e.getKey())))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    public int hashCode()
    (§
        int cached = this._hash
        if (cached == 0)
        (§
            this._hash = cached = mapHash(this)
        )
        (§ return (§ expr cached))
    )

    static public int mapHash(IPersistentMap m)
    (§
        int hash = 0
        for (ISeq s = m.seq() s != nil s = s.next())
        (§
            Map.Entry e = (Map.Entry) s.first()
            hash += ((e.getKey() == nil) ? 0 :or e.getKey().hashCode()) :xor ((e.getValue() == nil) ? 0 :or e.getValue().hashCode())
        )
        (§ return (§ expr hash))
    )

    public int hasheq()
    (§
        int cached = this._hasheq
        if (cached == 0)
        (§
            this._hasheq = cached = Murmur3.hashUnordered(this)
        )
        (§ return (§ expr cached))
    )

    static public int mapHasheq(IPersistentMap m)
    (§
        (§ return (§ expr Murmur3.hashUnordered(m)))
    )

    static public class KeySeq extends ASeq
    (§
        final ISeq seq
        final Iterable iterable

        static public KeySeq create(ISeq seq)
        (§
            if (seq == nil)
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new KeySeq(seq, nil)))
        )

        static public KeySeq createFromMap(IPersistentMap map)
        (§
            if (map == nil)
            (§
                (§ return (§ expr nil))
            )
            ISeq seq = map.seq()
            if (seq == nil)
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new KeySeq(seq, map)))
        )

        private KeySeq(ISeq seq, Iterable iterable)
        (§
            this.seq = seq
            this.iterable = iterable
        )

        private KeySeq(IPersistentMap meta, ISeq seq, Iterable iterable)
        (§
            super(meta)
            this.seq = seq
            this.iterable = iterable
        )

        public Object first()
        (§
            (§ return (§ expr ((Map.Entry) seq.first()).getKey()))
        )

        public ISeq next()
        (§
            (§ return (§ expr create(seq.next())))
        )

        public KeySeq withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new KeySeq(meta, seq, iterable)))
        )

        public Iterator iterator()
        (§
            if (iterable == nil)
            (§
                (§ return (§ expr super.iterator()))
            )

            if (iterable instanceof IMapIterable)
            (§
                (§ return (§ expr ((IMapIterable)iterable).keyIterator()))
            )

            final Iterator mapIter = iterable.iterator()
            (§ return (§ expr new Iterator()
            (§
                public boolean hasNext()
                (§
                    (§ return (§ expr mapIter.hasNext()))
                )

                public Object next()
                (§
                    (§ return (§ expr ((Map.Entry)mapIter.next()).getKey()))
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )))
        )
    )

    static public class ValSeq extends ASeq
    (§
        final ISeq seq
        final Iterable iterable

        static public ValSeq create(ISeq seq)
        (§
            if (seq == nil)
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new ValSeq(seq, nil)))
        )

        static public ValSeq createFromMap(IPersistentMap map)
        (§
            if (map == nil)
            (§
                (§ return (§ expr nil))
            )
            ISeq seq = map.seq()
            if (seq == nil)
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new ValSeq(seq, map)))
        )

        private ValSeq(ISeq seq, Iterable iterable)
        (§
            this.seq = seq
            this.iterable = iterable
        )

        private ValSeq(IPersistentMap meta, ISeq seq, Iterable iterable)
        (§
            super(meta)
            this.seq = seq
            this.iterable = iterable
        )

        public Object first()
        (§
            (§ return (§ expr ((Map.Entry) seq.first()).getValue()))
        )

        public ISeq next()
        (§
            (§ return (§ expr create(seq.next())))
        )

        public ValSeq withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ValSeq(meta, seq, iterable)))
        )

        public Iterator iterator()
        (§
            if (iterable == nil)
            (§
                (§ return (§ expr super.iterator()))
            )

            if (iterable instanceof IMapIterable)
            (§
                (§ return (§ expr ((IMapIterable)iterable).valIterator()))
            )

            final Iterator mapIter = iterable.iterator()
            (§ return (§ expr new Iterator()
            (§
                public boolean hasNext()
                (§
                    (§ return (§ expr mapIter.hasNext()))
                )

                public Object next()
                (§
                    (§ return (§ expr ((Map.Entry)mapIter.next()).getValue()))
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )))
        )
    )

    static final IFn MAKE_ENTRY = new AFn()
    (§
        public Object invoke(Object key, Object val)
        (§
            (§ return (§ expr MapEntry.create(key, val)))
        )
    )

    static final IFn MAKE_KEY = new AFn()
    (§
        public Object invoke(Object key, Object val)
        (§
            (§ return (§ expr key))
        )
    )

    static final IFn MAKE_VAL = new AFn()
    (§
        public Object invoke(Object key, Object val)
        (§
            (§ return (§ expr val))
        )
    )

    public Object invoke(Object arg1)
    (§
        (§ return (§ expr valAt(arg1)))
    )

    public Object invoke(Object arg1, Object notFound)
    (§
        (§ return (§ expr valAt(arg1, notFound)))
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsValue(Object value)
    (§
        (§ return (§ expr values().contains(value)))
    )

    public Set entrySet()
    (§
        (§ return (§ expr new AbstractSet()
        (§
            public Iterator iterator()
            (§
                (§ return (§ expr APersistentMap.this.iterator()))
            )

            public int size()
            (§
                (§ return (§ expr count()))
            )

            public int hashCode()
            (§
                (§ return (§ expr APersistentMap.this.hashCode()))
            )

            public boolean contains(Object o)
            (§
                if (o instanceof Entry)
                (§
                    Entry e = (Entry) o
                    Entry found = entryAt(e.getKey())
                    if (found != nil && Util.equals(found.getValue(), e.getValue()))
                    (§
                        (§ return (§ expr true))
                    )
                )
                (§ return (§ expr false))
            )
        )))
    )

    public Object get(Object key)
    (§
        (§ return (§ expr valAt(key)))
    )

    public boolean isEmpty()
    (§
        (§ return (§ expr (count() == 0)))
    )

    public Set keySet()
    (§
        (§ return (§ expr new AbstractSet()
        (§
            public Iterator iterator()
            (§
                final Iterator mi = APersistentMap.this.iterator()

                (§ return (§ expr new Iterator()
                (§
                    public boolean hasNext()
                    (§
                        (§ return (§ expr mi.hasNext()))
                    )

                    public Object next()
                    (§
                        Entry e = (Entry) mi.next()
                        (§ return (§ expr e.getKey()))
                    )

                    public void remove()
                    (§
                        throw new UnsupportedOperationException()
                    )
                )))
            )

            public int size()
            (§
                (§ return (§ expr count()))
            )

            public boolean contains(Object o)
            (§
                (§ return (§ expr APersistentMap.this.containsKey(o)))
            )
        )))
    )

    public Object put(Object key, Object value)
    (§
        throw new UnsupportedOperationException()
    )

    public void putAll(Map t)
    (§
        throw new UnsupportedOperationException()
    )

    public Object remove(Object key)
    (§
        throw new UnsupportedOperationException()
    )

    public int size()
    (§
        (§ return (§ expr count()))
    )

    public Collection values()
    (§
        (§ return (§ expr new AbstractCollection()
        (§
            public Iterator iterator()
            (§
                final Iterator mi = APersistentMap.this.iterator()

                (§ return (§ expr new Iterator()
                (§
                    public boolean hasNext()
                    (§
                        (§ return (§ expr mi.hasNext()))
                    )

                    public Object next()
                    (§
                        Entry e = (Entry) mi.next()
                        (§ return (§ expr e.getValue()))
                    )

                    public void remove()
                    (§
                        throw new UnsupportedOperationException()
                    )
                )))
            )

            public int size()
            (§
                (§ return (§ expr count()))
            )
        )))
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.io.Serializable)
(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

(§ class public abstract class APersistentSet extends AFn implements IPersistentSet, Collection, Set, Serializable, IHashEq)
(§
    int _hash
    int _hasheq
    final IPersistentMap impl

    protected APersistentSet(IPersistentMap impl)
    (§
        this.impl = impl
    )

    public String toString()
    (§
        (§ return (§ expr RT.printString(this)))
    )

    public boolean contains(Object key)
    (§
        (§ return (§ expr impl.containsKey(key)))
    )

    public Object get(Object key)
    (§
        (§ return (§ expr impl.valAt(key)))
    )

    public int count()
    (§
        (§ return (§ expr impl.count()))
    )

    public ISeq seq()
    (§
        (§ return (§ expr RT.keys(impl)))
    )

    public Object invoke(Object arg1)
    (§
        (§ return (§ expr get(arg1)))
    )

    public boolean equals(Object obj)
    (§
        (§ return (§ expr setEquals(this, obj)))
    )

    static public boolean setEquals(IPersistentSet s1, Object obj)
    (§
        if (s1 == obj)
        (§
            (§ return (§ expr true))
        )
        if (!(obj instanceof Set))
        (§
            (§ return (§ expr false))
        )
        Set m = (Set) obj

        if (m.size() != s1.count())
        (§
            (§ return (§ expr false))
        )

        for (Object aM :in m)
        (§
            if (!s1.contains(aM))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    public boolean equiv(Object obj)
    (§
        if (!(obj instanceof Set))
        (§
            (§ return (§ expr false))
        )

        Set m = (Set) obj

        if (m.size() != size())
        (§
            (§ return (§ expr false))
        )

        for (Object aM :in m)
        (§
            if (!contains(aM))
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    public int hashCode()
    (§
        int hash = this._hash
        if (hash == 0)
        (§
            for (ISeq s = seq() s != nil s = s.next())
            (§
                Object e = s.first()
                hash +=  Util.hash(e)
            )
            this._hash = hash
        )
        (§ return (§ expr hash))
    )

    public int hasheq()
    (§
        int cached = this._hasheq
        if (cached == 0)
        (§
            this._hasheq = cached = Murmur3.hashUnordered(this)
        )
        (§ return (§ expr cached))
    )

    public Object[] toArray()
    (§
        (§ return (§ expr RT.seqToArray(seq())))
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (!contains(o))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr true))
    )

    public Object[] toArray(Object[] a)
    (§
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    public int size()
    (§
        (§ return (§ expr count()))
    )

    public boolean isEmpty()
    (§
        (§ return (§ expr (count() == 0)))
    )

    public Iterator iterator()
    (§
        if (impl instanceof IMapIterable)
        (§
            (§ return (§ expr ((IMapIterable)impl).keyIterator()))
        )
        else
        (§
            (§ return (§ expr new Iterator()
            (§
                private final Iterator iter = impl.iterator()

                public boolean hasNext()
                (§
                    (§ return (§ expr iter.hasNext()))
                )

                public Object next()
                (§
                    (§ return (§ expr ((IMapEntry)iter.next()).key()))
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )))
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.io.Serializable)
(§ import java.util.*)

(§ class public abstract class APersistentVector extends AFn implements IPersistentVector, Iterable, List, RandomAccess, Comparable, Serializable, IHashEq)
(§
    int _hash
    int _hasheq

    public String toString()
    (§
        (§ return (§ expr RT.printString(this)))
    )

    public ISeq seq()
    (§
        if (count() > 0)
        (§
            (§ return (§ expr new Seq(this, 0)))
        )
        (§ return (§ expr nil))
    )

    public ISeq rseq()
    (§
        if (count() > 0)
        (§
            (§ return (§ expr new RSeq(this, count() - 1)))
        )
        (§ return (§ expr nil))
    )

    static boolean doEquals(IPersistentVector v, Object obj)
    (§
        if (obj instanceof IPersistentVector)
        (§
            IPersistentVector ov = (IPersistentVector) obj
            if (ov.count() != v.count())
            (§
                (§ return (§ expr false))
            )
            for (int i = 0 i < v.count() i++)
            (§
                if (!Util.equals(v.nth(i), ov.nth(i)))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )
        else if (obj instanceof List)
        (§
            Collection ma = (Collection) obj
            if (ma.size() != v.count() || ma.hashCode() != v.hashCode())
            (§
                (§ return (§ expr false))
            )
            for (Iterator i1 = ((List) v).iterator(), i2 = ma.iterator() i1.hasNext() )
            (§
                if (!Util.equals(i1.next(), i2.next()))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )
        else
        (§
            if (!(obj instanceof Sequential))
            (§
                (§ return (§ expr false))
            )
            ISeq ms = RT.seq(obj)
            for (int i = 0 i < v.count() i++, ms = ms.next())
            (§
                if (ms == nil || !Util.equals(v.nth(i), ms.first()))
                (§
                    (§ return (§ expr false))
                )
            )
            if (ms != nil)
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    static boolean doEquiv(IPersistentVector v, Object obj)
    (§
        if (obj instanceof IPersistentVector)
        (§
            IPersistentVector ov = (IPersistentVector) obj
            if (ov.count() != v.count())
            (§
                (§ return (§ expr false))
            )
            for (int i = 0 i < v.count() i++)
            (§
                if (!Util.equiv(v.nth(i), ov.nth(i)))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )
        else if (obj instanceof List)
        (§
            Collection ma = (Collection) obj
            if (ma.size() != v.count())
            (§
                (§ return (§ expr false))
            )
            for (Iterator i1 = ((List) v).iterator(), i2 = ma.iterator() i1.hasNext() )
            (§
                if (!Util.equiv(i1.next(), i2.next()))
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )
        else
        (§
            if (!(obj instanceof Sequential))
            (§
                (§ return (§ expr false))
            )
            ISeq ms = RT.seq(obj)
            for (int i = 0 i < v.count() i++, ms = ms.next())
            (§
                if (ms == nil || !Util.equiv(v.nth(i), ms.first()))
                (§
                    (§ return (§ expr false))
                )
            )
            if (ms != nil)
            (§
                (§ return (§ expr false))
            )
        )

        (§ return (§ expr true))
    )

    public boolean equals(Object obj)
    (§
        if (obj == this)
        (§
            (§ return (§ expr true))
        )
        (§ return (§ expr doEquals(this, obj)))
    )

    public boolean equiv(Object obj)
    (§
        if (obj == this)
        (§
            (§ return (§ expr true))
        )
        (§ return (§ expr doEquiv(this, obj)))
    )

    public int hashCode()
    (§
        int hash = this._hash
        if (hash == 0)
        (§
            hash = 1
            for (int i = 0 i < count() i++)
            (§
                Object obj = nth(i)
                hash = 31 * hash + ((obj == nil) ? 0 :or obj.hashCode())
            )
            this._hash = hash
        )
        (§ return (§ expr hash))
    )

    public int hasheq()
    (§
        int hash = this._hasheq
        if (hash == 0)
        (§
            int n
            hash = 1

            for (n = 0 n < count() ++n)
            (§
                hash = 31 * hash + Util.hasheq(nth(n))
            )

            this._hasheq = hash = Murmur3.mixCollHash(hash, n)
        )
        (§ return (§ expr hash))
    )

    public Object get(int index)
    (§
        (§ return (§ expr nth(index)))
    )

    public Object nth(int i, Object notFound)
    (§
        if (i >= 0 && i < count())
        (§
            (§ return (§ expr nth(i)))
        )
        (§ return (§ expr notFound))
    )

    public Object remove(int i)
    (§
        throw new UnsupportedOperationException()
    )

    public int indexOf(Object o)
    (§
        for (int i = 0 i < count() i++)
        (§
            if (Util.equiv(nth(i), o))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    public int lastIndexOf(Object o)
    (§
        for (int i = count() - 1 i >= 0 i--)
        (§
            if (Util.equiv(nth(i), o))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    public ListIterator listIterator()
    (§
        (§ return (§ expr listIterator(0)))
    )

    public ListIterator listIterator(final int index)
    (§
        (§ return (§ expr new ListIterator()
        (§
            int nexti = index

            public boolean hasNext()
            (§
                (§ return (§ expr (nexti < count())))
            )

            public Object next()
            (§
                if (nexti < count())
                (§
                    (§ return (§ expr nth(nexti++)))
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public boolean hasPrevious()
            (§
                (§ return (§ expr (nexti > 0)))
            )

            public Object previous()
            (§
                if (nexti > 0)
                (§
                    (§ return (§ expr nth(--nexti)))
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public int nextIndex()
            (§
                (§ return (§ expr nexti))
            )

            public int previousIndex()
            (§
                (§ return (§ expr nexti - 1))
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )

            public void set(Object o)
            (§
                throw new UnsupportedOperationException()
            )

            public void add(Object o)
            (§
                throw new UnsupportedOperationException()
            )
        )))
    )

    Iterator rangedIterator(final int start, final int end)
    (§
        (§ return (§ expr new Iterator()
        (§
            int i = start

            public boolean hasNext()
            (§
                (§ return (§ expr (i < end)))
            )

            public Object next()
            (§
                if (i < end)
                (§
                    (§ return (§ expr nth(i++)))
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )))
    )

    public List subList(int fromIndex, int toIndex)
    (§
        (§ return (§ expr (List) RT.subvec(this, fromIndex, toIndex)))
    )

    public Object set(int i, Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public void add(int i, Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(int i, Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public Object invoke(Object arg1)
    (§
        if (Util.isInteger(arg1))
        (§
            (§ return (§ expr nth(((Number) arg1).intValue())))
        )
        throw new IllegalArgumentException("Key must be integer")
    )

    public Iterator iterator()
    (§
        ;; todo - something more efficient
        (§ return (§ expr new Iterator()
        (§
            int i = 0

            public boolean hasNext()
            (§
                (§ return (§ expr (i < count())))
            )

            public Object next()
            (§
                if (i < count())
                (§
                    (§ return (§ expr nth(i++)))
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )))
    )

    public Object peek()
    (§
        if (count() > 0)
        (§
            (§ return (§ expr nth(count() - 1)))
        )
        (§ return (§ expr nil))
    )

    public boolean containsKey(Object key)
    (§
        if (!(Util.isInteger(key)))
        (§
            (§ return (§ expr false))
        )
        int i = ((Number) key).intValue()
        (§ return (§ expr (i >= 0 && i < count())))
    )

    public IMapEntry entryAt(Object key)
    (§
        if (Util.isInteger(key))
        (§
            int i = ((Number) key).intValue()
            if (i >= 0 && i < count())
            (§
                (§ return (§ expr (IMapEntry) MapEntry.create(key, nth(i))))
            )
        )
        (§ return (§ expr nil))
    )

    public IPersistentVector assoc(Object key, Object val)
    (§
        if (Util.isInteger(key))
        (§
            int i = ((Number) key).intValue()
            (§ return (§ expr assocN(i, val)))
        )
        throw new IllegalArgumentException("Key must be integer")
    )

    public Object valAt(Object key, Object notFound)
    (§
        if (Util.isInteger(key))
        (§
            int i = ((Number) key).intValue()
            if (i >= 0 && i < count())
            (§
                (§ return (§ expr nth(i)))
            )
        )
        (§ return (§ expr notFound))
    )

    public Object valAt(Object key)
    (§
        (§ return (§ expr valAt(key, nil)))
    )

    public Object[] toArray()
    (§
        Object[] ret = new Object[count()]
        for (int i = 0 i < count() i++)
        (§
            ret[i] = nth(i)
        )
        (§ return (§ expr ret))
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (!contains(o))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr true))
    )

    public Object[] toArray(Object[] a)
    (§
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    public int size()
    (§
        (§ return (§ expr count()))
    )

    public boolean isEmpty()
    (§
        (§ return (§ expr (count() == 0)))
    )

    public boolean contains(Object o)
    (§
        for (ISeq s = seq() s != nil s = s.next())
        (§
            if (Util.equiv(s.first(), o))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    public int length()
    (§
        (§ return (§ expr count()))
    )

    public int compareTo(Object o)
    (§
        IPersistentVector v = (IPersistentVector) o
        if (count() < v.count())
        (§
            (§ return (§ expr -1))
        )
        else if (count() > v.count())
        (§
            (§ return (§ expr 1))
        )
        for (int i = 0 i < count() i++)
        (§
            int c = Util.compare(nth(i), v.nth(i))
            if (c != 0)
            (§
                (§ return (§ expr c))
            )
        )
        (§ return (§ expr 0))
    )

    static class Seq extends ASeq implements IndexedSeq, IReduce
    (§
        ;; todo - something more efficient
        final IPersistentVector v
        final int i

        public Seq(IPersistentVector v, int i)
        (§
            this.v = v
            this.i = i
        )

        Seq(IPersistentMap meta, IPersistentVector v, int i)
        (§
            super(meta)
            this.v = v
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr v.nth(i)))
        )

        public ISeq next()
        (§
            if (i + 1 < v.count())
            (§
                (§ return (§ expr new APersistentVector.Seq(v, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public int count()
        (§
            (§ return (§ expr v.count() - i))
        )

        public APersistentVector.Seq withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new APersistentVector.Seq(meta, v, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = v.nth(i)
            for (int x = i + 1 x < v.count() x++)
            (§
                ret = f.invoke(ret, v.nth(x))
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, v.nth(i))
            for (int x = i + 1 x < v.count() x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, v.nth(x))
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )
    )

    public static class RSeq extends ASeq implements IndexedSeq, Counted
    (§
        final IPersistentVector v
        final int i

        public RSeq(IPersistentVector vector, int i)
        (§
            this.v = vector
            this.i = i
        )

        RSeq(IPersistentMap meta, IPersistentVector v, int i)
        (§
            super(meta)
            this.v = v
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr v.nth(i)))
        )

        public ISeq next()
        (§
            if (i > 0)
            (§
                (§ return (§ expr new APersistentVector.RSeq(v, i - 1)))
            )
            (§ return (§ expr nil))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public int count()
        (§
            (§ return (§ expr i + 1))
        )

        public APersistentVector.RSeq withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new APersistentVector.RSeq(meta, v, i)))
        )
    )

    public static class SubVector extends APersistentVector implements IObj
    (§
        public final IPersistentVector v
        public final int start
        public final int end
        final IPersistentMap _meta

        public SubVector(IPersistentMap meta, IPersistentVector v, int start, int end)
        (§
            this._meta = meta

            if (v instanceof APersistentVector.SubVector)
            (§
                APersistentVector.SubVector sv = (APersistentVector.SubVector) v
                start += sv.start
                end += sv.start
                v = sv.v
            )
            this.v = v
            this.start = start
            this.end = end
        )

        public Iterator iterator()
        (§
            if (v instanceof APersistentVector)
            (§
                (§ return (§ expr ((APersistentVector)v).rangedIterator(start, end)))
            )
            (§ return (§ expr super.iterator()))
        )

        public Object nth(int i)
        (§
            if ((start + i >= end) || (i < 0))
            (§
                throw new IndexOutOfBoundsException()
            )
            (§ return (§ expr v.nth(start + i)))
        )

        public IPersistentVector assocN(int i, Object val)
        (§
            if (start + i > end)
            (§
                throw new IndexOutOfBoundsException()
            )
            else if (start + i == end)
            (§
                (§ return (§ expr cons(val)))
            )
            (§ return (§ expr new SubVector(_meta, v.assocN(start + i, val), start, end)))
        )

        public int count()
        (§
            (§ return (§ expr end - start))
        )

        public IPersistentVector cons(Object o)
        (§
            (§ return (§ expr new SubVector(_meta, v.assocN(end, o), start, end + 1)))
        )

        public IPersistentCollection empty()
        (§
            (§ return (§ expr PersistentVector.EMPTY.withMeta(meta())))
        )

        public IPersistentStack pop()
        (§
            if (end - 1 == start)
            (§
                (§ return (§ expr PersistentVector.EMPTY))
            )
            (§ return (§ expr new SubVector(_meta, v, start, end - 1)))
        )

        public SubVector withMeta(IPersistentMap meta)
        (§
            if (meta == _meta)
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new SubVector(meta, v, start, end)))
        )

        public IPersistentMap meta()
        (§
            (§ return (§ expr _meta))
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

(§ class public abstract class ARef extends AReference implements IRef)
(§
    protected volatile IFn validator = nil
    private volatile IPersistentMap watches = PersistentHashMap.EMPTY

    public ARef()
    (§
        super()
    )

    public ARef(IPersistentMap meta)
    (§
        super(meta)
    )

    void validate(IFn vf, Object val)
    (§
        try
        (§
            if (vf != nil && !RT.booleanCast(vf.invoke(val)))
            (§
                throw new IllegalStateException("Invalid reference state")
            )
        )
        catch (RuntimeException re)
        (§
            throw re
        )
        catch (Exception e)
        (§
            throw new IllegalStateException("Invalid reference state", e)
        )
    )

    void validate(Object val)
    (§
        validate(validator, val)
    )

    public void setValidator(IFn vf)
    (§
        validate(vf, deref())
        validator = vf
    )

    public IFn getValidator()
    (§
        (§ return (§ expr validator))
    )

    public IPersistentMap getWatches()
    (§
        (§ return (§ expr watches))
    )

    synchronized public IRef addWatch(Object key, IFn callback)
    (§
        watches = watches.assoc(key, callback)
        (§ return (§ expr this))
    )

    synchronized public IRef removeWatch(Object key)
    (§
        watches = watches.without(key)
        (§ return (§ expr this))
    )

    public void notifyWatches(Object oldval, Object newval)
    (§
        IPersistentMap ws = watches
        if (ws.count() > 0)
        (§
            for (ISeq s = ws.seq() s != nil s = s.next())
            (§
                Map.Entry e = (Map.Entry) s.first()
                IFn fn = (IFn) e.getValue()
                if (fn != nil)
                (§
                    fn.invoke(e.getKey(), this, oldval, newval)
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.AReference

(§ class public class AReference implements IReference)
(§
    private IPersistentMap _meta

    public AReference()
    (§
        this(nil)
    )

    public AReference(IPersistentMap meta)
    (§
        _meta = meta
    )

    synchronized public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )

    synchronized public IPersistentMap alterMeta(IFn alter, ISeq args)
    (§
        _meta = (IPersistentMap) alter.applyTo(new Cons(_meta, args))
        (§ return (§ expr _meta))
    )

    synchronized public IPersistentMap resetMeta(IPersistentMap m)
    (§
        _meta = m
        (§ return (§ expr m))
    )
)
)

(java-ns cloiure.lang.ArityException

(§ class public class ArityException extends IllegalArgumentException)
(§
    final public int actual

    final public String name

    public ArityException(int actual, String name)
    (§
        this(actual, name, nil)
    )

    public ArityException(int actual, String name, Throwable cause)
    (§
        super("Wrong number of args (" + actual + ") passed to: " + name, cause)
        this.actual = actual
        this.name = name
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(§ import java.io.Serializable)

(§ class public final class ArrayChunk implements IChunk, Serializable)
(§
    final Object[] array
    final int off
    final int end

    public ArrayChunk(Object[] array)
    (§
        this(array, 0, array.length)
    )

    public ArrayChunk(Object[] array, int off)
    (§
        this(array, off, array.length)
    )

    public ArrayChunk(Object[] array, int off, int end)
    (§
        this.array = array
        this.off = off
        this.end = end
    )

    public Object nth(int i)
    (§
        (§ return (§ expr array[off + i]))
    )

    public Object nth(int i, Object notFound)
    (§
        if (i >= 0 && i < count())
        (§
            (§ return (§ expr nth(i)))
        )
        (§ return (§ expr notFound))
    )

    public int count()
    (§
        (§ return (§ expr end - off))
    )

    public IChunk dropFirst()
    (§
        if (off == end)
        (§
            throw new IllegalStateException("dropFirst of empty chunk")
        )
        (§ return (§ expr new ArrayChunk(array, off + 1, end)))
    )

    public Object reduce(IFn f, Object start)
    (§
        Object ret = f.invoke(start, array[off])
        if (RT.isReduced(ret))
        (§
            (§ return (§ expr ret))
        )
        for (int x = off + 1 x < end x++)
        (§
            ret = f.invoke(ret, array[x])
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ret))
            )
        )
        (§ return (§ expr ret))
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(§ class public class ArrayIter implements Iterator)
(§
    final Object[] array
    int i

    static public Iterator EMPTY_ITERATOR = new Iterator()
    (§
        public boolean hasNext() (§ return (§ expr false ))
        public Object next() (§ throw new java.util.NoSuchElementException() )
        public void remove() (§ throw new UnsupportedOperationException("remove() not supported") )
    )

    static public Iterator create()
    (§
        (§ return (§ expr EMPTY_ITERATOR))
    )

    static public Iterator create(Object... array)
    (§
        if (array == nil || array.length == 0)
        (§
            (§ return (§ expr EMPTY_ITERATOR))
        )
        (§ return (§ expr new ArrayIter(array, 0)))
    )

    static public Iterator createFromObject(Object array)
    (§
        if (array == nil || Array.getLength(array) == 0)
        (§
            (§ return (§ expr EMPTY_ITERATOR))
        )
        Class aclass = array.getClass()
        if (aclass == int[].class)
        (§
            (§ return (§ expr new ArrayIter_int((int[]) array, 0)))
        )
        if (aclass == float[].class)
        (§
            (§ return (§ expr new ArrayIter_float((float[]) array, 0)))
        )
        if (aclass == double[].class)
        (§
            (§ return (§ expr new ArrayIter_double((double[]) array, 0)))
        )
        if (aclass == long[].class)
        (§
            (§ return (§ expr new ArrayIter_long((long[]) array, 0)))
        )
        if (aclass == byte[].class)
        (§
            (§ return (§ expr new ArrayIter_byte((byte[]) array, 0)))
        )
        if (aclass == char[].class)
        (§
            (§ return (§ expr new ArrayIter_char((char[]) array, 0)))
        )
        if (aclass == short[].class)
        (§
            (§ return (§ expr new ArrayIter_short((short[]) array, 0)))
        )
        if (aclass == boolean[].class)
        (§
            (§ return (§ expr new ArrayIter_boolean((boolean[]) array, 0)))
        )
        (§ return (§ expr new ArrayIter(array, 0)))
    )

    ArrayIter(Object array, int i)
    (§
        this.i = i
        this.array = (Object[]) array
    )

    public boolean hasNext()
    (§
        (§ return (§ expr (array != nil && i < array.length)))
    )

    public Object next()
    (§
        if (array != nil && i < array.length)
        (§
            (§ return (§ expr array[i++]))
        )
        throw new java.util.NoSuchElementException()
    )

    public void remove()
    (§
        throw new UnsupportedOperationException("remove() not supported")
    )

    static public class ArrayIter_int implements Iterator<Long>
    (§
        final int[] array
        int i

        ArrayIter_int(int[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (array != nil && i < array.length)))
        )

        public Long next()
        (§
            if (array != nil && i < array.length)
            (§
                (§ return (§ expr Long.valueOf(array[i++])))
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_float implements Iterator<Double>
    (§
        final float[] array
        int i

        ArrayIter_float(float[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (array != nil && i < array.length)))
        )

        public Double next()
        (§
            if (array != nil && i < array.length)
            (§
                (§ return (§ expr Double.valueOf(array[i++])))
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_double implements Iterator<Double>
    (§
        final double[] array
        int i

        ArrayIter_double(double[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (array != nil && i < array.length)))
        )

        public Double next()
        (§
            if (array != nil && i < array.length)
            (§
                (§ return (§ expr array[i++]))
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_long implements Iterator<Long>
    (§
        final long[] array
        int i

        ArrayIter_long(long[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (array != nil && i < array.length)))
        )

        public Long next()
        (§
            if (array != nil && i < array.length)
            (§
                (§ return (§ expr Long.valueOf(array[i++])))
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_byte implements Iterator<Byte>
    (§
        final byte[] array
        int i

        ArrayIter_byte(byte[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (array != nil && i < array.length)))
        )

        public Byte next()
        (§
            if (array != nil && i < array.length)
            (§
                (§ return (§ expr array[i++]))
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_char implements Iterator<Character>
    (§
        final char[] array
        int i

        ArrayIter_char(char[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (array != nil && i < array.length)))
        )

        public Character next()
        (§
            if (array != nil && i < array.length)
            (§
                (§ return (§ expr array[i++]))
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_short implements Iterator<Long>
    (§
        final short[] array
        int i

        ArrayIter_short(short[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (array != nil && i < array.length)))
        )

        public Long next()
        (§
            if (array != nil && i < array.length)
            (§
                (§ return (§ expr Long.valueOf(array[i++])))
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )

    static public class ArrayIter_boolean implements Iterator<Boolean>
    (§
        final boolean[] array
        int i

        ArrayIter_boolean(boolean[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (array != nil && i < array.length)))
        )

        public Boolean next()
        (§
            if (array != nil && i < array.length)
            (§
                (§ return (§ expr Boolean.valueOf(array[i++])))
            )
            throw new java.util.NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException("remove() not supported")
        )
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(§ class public class ArraySeq extends ASeq implements IndexedSeq, IReduce)
(§
    public final Object[] array
    final int i

    static public ArraySeq create()
    (§
        (§ return (§ expr nil))
    )

    static public ArraySeq create(Object... array)
    (§
        if (array == nil || array.length == 0)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr new ArraySeq(array, 0)))
    )

    static ISeq createFromObject(Object array)
    (§
        if (array == nil || Array.getLength(array) == 0)
        (§
            (§ return (§ expr nil))
        )
        Class aclass = array.getClass()
        if (aclass == int[].class)
        (§
            (§ return (§ expr new ArraySeq_int(nil, (int[]) array, 0)))
        )
        if (aclass == float[].class)
        (§
            (§ return (§ expr new ArraySeq_float(nil, (float[]) array, 0)))
        )
        if (aclass == double[].class)
        (§
            (§ return (§ expr new ArraySeq_double(nil, (double[]) array, 0)))
        )
        if (aclass == long[].class)
        (§
            (§ return (§ expr new ArraySeq_long(nil, (long[]) array, 0)))
        )
        if (aclass == byte[].class)
        (§
            (§ return (§ expr new ArraySeq_byte(nil, (byte[]) array, 0)))
        )
        if (aclass == char[].class)
        (§
            (§ return (§ expr new ArraySeq_char(nil, (char[]) array, 0)))
        )
        if (aclass == short[].class)
        (§
            (§ return (§ expr new ArraySeq_short(nil, (short[]) array, 0)))
        )
        if (aclass == boolean[].class)
        (§
            (§ return (§ expr new ArraySeq_boolean(nil, (boolean[]) array, 0)))
        )
        (§ return (§ expr new ArraySeq(array, 0)))
    )

    ArraySeq(Object array, int i)
    (§
        this.i = i
        this.array = (Object[]) array
    )

    ArraySeq(IPersistentMap meta, Object array, int i)
    (§
        super(meta)
        this.i = i
        this.array = (Object[]) array
    )

    public Object first()
    (§
        if (array != nil)
        (§
            (§ return (§ expr array[i]))
        )
        (§ return (§ expr nil))
    )

    public ISeq next()
    (§
        if (array != nil && i + 1 < array.length)
        (§
            (§ return (§ expr new ArraySeq(array, i + 1)))
        )
        (§ return (§ expr nil))
    )

    public int count()
    (§
        if (array != nil)
        (§
            (§ return (§ expr array.length - i))
        )
        (§ return (§ expr 0))
    )

    public int index()
    (§
        (§ return (§ expr i))
    )

    public ArraySeq withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new ArraySeq(meta, array, i)))
    )

    public Object reduce(IFn f)
    (§
        if (array != nil)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )
        (§ return (§ expr nil))
    )

    public Object reduce(IFn f, Object start)
    (§
        if (array != nil)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )
        (§ return (§ expr nil))
    )

    public int indexOf(Object o)
    (§
        if (array != nil)
        (§
            for (int j = i j < array.length j++)
            (§
                if (Util.equals(o, array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
        )
        (§ return (§ expr -1))
    )

    public int lastIndexOf(Object o)
    (§
        if (array != nil)
        (§
            if (o == nil)
            (§
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (array[j] == nil)
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            else
            (§
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (o.equals(array[j]))
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
        )
        (§ return (§ expr -1))
    )

    static public class ArraySeq_int extends ASeq implements IndexedSeq, IReduce
    (§
        public final int[] array
        final int i

        ArraySeq_int(IPersistentMap meta, int[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr array[i]))
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                (§ return (§ expr new ArraySeq_int(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr array.length - i))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public ArraySeq_int withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ArraySeq_int(meta, array, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                int k = ((Number) o).intValue()
                for (int j = i j < array.length j++)
                (§
                    if (k == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                int k = ((Number) o).intValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (k == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )
    )

    static public class ArraySeq_float extends ASeq implements IndexedSeq, IReduce
    (§
        public final float[] array
        final int i

        ArraySeq_float(IPersistentMap meta, float[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr Numbers.num(array[i])))
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                (§ return (§ expr new ArraySeq_float(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr array.length - i))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public ArraySeq_float withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ArraySeq_float(meta, array, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = Numbers.num(array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, Numbers.num(array[x]))
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, Numbers.num(array[i]))
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, Numbers.num(array[x]))
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                float f = ((Number) o).floatValue()
                for (int j = i j < array.length j++)
                (§
                    if (f == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                float f = ((Number) o).floatValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (f == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            (§ return (§ expr -1))
        )
    )

    static public class ArraySeq_double extends ASeq implements IndexedSeq, IReduce
    (§
        public final double[] array
        final int i

        ArraySeq_double(IPersistentMap meta, double[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr array[i]))
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                (§ return (§ expr new ArraySeq_double(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr array.length - i))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public ArraySeq_double withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ArraySeq_double(meta, array, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                double d = ((Number) o).doubleValue()
                for (int j = i j < array.length j++)
                (§
                    if (d == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                double d = ((Number) o).doubleValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (d == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )
    )

    static public class ArraySeq_long extends ASeq implements IndexedSeq, IReduce
    (§
        public final long[] array
        final int i

        ArraySeq_long(IPersistentMap meta, long[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr Numbers.num(array[i])))
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                (§ return (§ expr new ArraySeq_long(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr array.length - i))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public ArraySeq_long withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ArraySeq_long(meta, array, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = Numbers.num(array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, Numbers.num(array[x]))
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, Numbers.num(array[i]))
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, Numbers.num(array[x]))
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                long l = ((Number) o).longValue()
                for (int j = i j < array.length j++)
                (§
                    if (l == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Number)
            (§
                long l = ((Number) o).longValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (l == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )

            (§ return (§ expr -1))
        )
    )

    static public class ArraySeq_byte extends ASeq implements IndexedSeq, IReduce
    (§
        public final byte[] array
        final int i

        ArraySeq_byte(IPersistentMap meta, byte[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr array[i]))
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                (§ return (§ expr new ArraySeq_byte(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr array.length - i))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public ArraySeq_byte withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ArraySeq_byte(meta, array, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Byte)
            (§
                byte b = ((Byte) o).byteValue()
                for (int j = i j < array.length j++)
                (§
                    if (b == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            if (o == nil)
            (§
                (§ return (§ expr -1))
            )
            for (int j = i j < array.length j++)
            (§
                if (o.equals(array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Byte)
            (§
                byte b = ((Byte) o).byteValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (b == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            if (o == nil)
            (§
                (§ return (§ expr -1))
            )
            for (int j = array.length - 1 j >= i j--)
            (§
                if (o.equals(array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )
    )

    static public class ArraySeq_char extends ASeq implements IndexedSeq, IReduce
    (§
        public final char[] array
        final int i

        ArraySeq_char(IPersistentMap meta, char[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr array[i]))
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                (§ return (§ expr new ArraySeq_char(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr array.length - i))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public ArraySeq_char withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ArraySeq_char(meta, array, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Character)
            (§
                char c = ((Character) o).charValue()
                for (int j = i j < array.length j++)
                (§
                    if (c == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            if (o == nil)
            (§
                (§ return (§ expr -1))
            )
            for (int j = i j < array.length j++)
            (§
                if (o.equals(array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Character)
            (§
                char c = ((Character) o).charValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (c == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            if (o == nil)
            (§
                (§ return (§ expr -1))
            )
            for (int j = array.length - 1 j >= i j--)
            (§
                if (o.equals(array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )
    )

    static public class ArraySeq_short extends ASeq implements IndexedSeq, IReduce
    (§
        public final short[] array
        final int i

        ArraySeq_short(IPersistentMap meta, short[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr array[i]))
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                (§ return (§ expr new ArraySeq_short(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr array.length - i))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public ArraySeq_short withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ArraySeq_short(meta, array, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Short)
            (§
                short s = ((Short) o).shortValue()
                for (int j = i j < array.length j++)
                (§
                    if (s == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            if (o == nil)
            (§
                (§ return (§ expr -1))
            )
            for (int j = i j < array.length j++)
            (§
                if (o.equals(array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Short)
            (§
                short s = ((Short) o).shortValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (s == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            if (o == nil)
            (§
                (§ return (§ expr -1))
            )
            for (int j = array.length - 1 j >= i j--)
            (§
                if (o.equals(array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )
    )

    static public class ArraySeq_boolean extends ASeq implements IndexedSeq, IReduce
    (§
        public final boolean[] array
        final int i

        ArraySeq_boolean(IPersistentMap meta, boolean[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr array[i]))
        )

        public ISeq next()
        (§
            if (i + 1 < array.length)
            (§
                (§ return (§ expr new ArraySeq_boolean(meta(), array, i + 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr array.length - i))
        )

        public int index()
        (§
            (§ return (§ expr i))
        )

        public ArraySeq_boolean withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new ArraySeq_boolean(meta, array, i)))
        )

        public Object reduce(IFn f)
        (§
            Object ret = array[i]
            for (int x = i + 1 x < array.length x++)
            (§
                ret = f.invoke(ret, array[x])
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )

        public Object reduce(IFn f, Object start)
        (§
            Object ret = f.invoke(start, array[i])
            for (int x = i + 1 x < array.length x++)
            (§
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
                ret = f.invoke(ret, array[x])
            )
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            (§ return (§ expr ret))
        )

        public int indexOf(Object o)
        (§
            if (o instanceof Boolean)
            (§
                boolean b = ((Boolean) o).booleanValue()
                for (int j = i j < array.length j++)
                (§
                    if (b == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            if (o == nil)
            (§
                (§ return (§ expr -1))
            )
            for (int j = i j < array.length j++)
            (§
                if (o.equals(array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            if (o instanceof Boolean)
            (§
                boolean b = ((Boolean) o).booleanValue()
                for (int j = array.length - 1 j >= i j--)
                (§
                    if (b == array[j])
                    (§
                        (§ return (§ expr j - i))
                    )
                )
            )
            if (o == nil)
            (§
                (§ return (§ expr -1))
            )
            for (int j = array.length - 1 j >= i j--)
            (§
                if (o.equals(array[j]))
                (§
                    (§ return (§ expr j - i))
                )
            )
            (§ return (§ expr -1))
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.io.Serializable)
(§ import java.util.*)

(§ class public abstract class ASeq extends Obj implements ISeq, Sequential, List, Serializable, IHashEq)
(§
    transient int _hash
    transient int _hasheq

    public String toString()
    (§
        (§ return (§ expr RT.printString(this)))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr PersistentList.EMPTY))
    )

    protected ASeq(IPersistentMap meta)
    (§
        super(meta)
    )

    protected ASeq()
    (§
    )

    public boolean equiv(Object obj)
    (§
        if (!(obj instanceof Sequential || obj instanceof List))
        (§
            (§ return (§ expr false))
        )
        ISeq ms = RT.seq(obj)
        for (ISeq s = seq() s != nil s = s.next(), ms = ms.next())
        (§
            if (ms == nil || !Util.equiv(s.first(), ms.first()))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr (ms == nil)))
    )

    public boolean equals(Object obj)
    (§
        if (this == obj)
        (§
            (§ return (§ expr true))
        )
        if (!(obj instanceof Sequential || obj instanceof List))
        (§
            (§ return (§ expr false))
        )
        ISeq ms = RT.seq(obj)
        for (ISeq s = seq() s != nil s = s.next(), ms = ms.next())
        (§
            if (ms == nil || !Util.equals(s.first(), ms.first()))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr (ms == nil)))
    )

    public int hashCode()
    (§
        if (_hash == 0)
        (§
            int hash = 1
            for (ISeq s = seq() s != nil s = s.next())
            (§
                hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode())
            )
            this._hash = hash
        )
        (§ return (§ expr _hash))
    )

    public int hasheq()
    (§
        if (_hasheq == 0)
        (§
            _hasheq  = Murmur3.hashOrdered(this)
        )
        (§ return (§ expr _hasheq))
    )

    public int count()
    (§
        int i = 1
        for (ISeq s = next() s != nil s = s.next(), i++)
        (§
            if (s instanceof Counted)
            (§
                (§ return (§ expr i + s.count()))
            )
        )
        (§ return (§ expr i))
    )

    final public ISeq seq()
    (§
        (§ return (§ expr this))
    )

    public ISeq cons(Object o)
    (§
        (§ return (§ expr new Cons(o, this)))
    )

    public ISeq more()
    (§
        ISeq s = next()
        if (s == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr s))
    )

    public Object[] toArray()
    (§
        (§ return (§ expr RT.seqToArray(seq())))
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (!contains(o))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr true))
    )

    public Object[] toArray(Object[] a)
    (§
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    public int size()
    (§
        (§ return (§ expr count()))
    )

    public boolean isEmpty()
    (§
        (§ return (§ expr (seq() == nil)))
    )

    public boolean contains(Object o)
    (§
        for (ISeq s = seq() s != nil s = s.next())
        (§
            if (Util.equiv(s.first(), o))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    public Iterator iterator()
    (§
        (§ return (§ expr new SeqIterator(this)))
    )

    private List reify()
    (§
        (§ return (§ expr Collections.unmodifiableList(new ArrayList(this))))
    )

    public List subList(int fromIndex, int toIndex)
    (§
        (§ return (§ expr reify().subList(fromIndex, toIndex)))
    )

    public Object set(int index, Object element)
    (§
        throw new UnsupportedOperationException()
    )

    public Object remove(int index)
    (§
        throw new UnsupportedOperationException()
    )

    public int indexOf(Object o)
    (§
        ISeq s = seq()
        for (int i = 0 s != nil s = s.next(), i++)
        (§
            if (Util.equiv(s.first(), o))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    public int lastIndexOf(Object o)
    (§
        (§ return (§ expr reify().lastIndexOf(o)))
    )

    public ListIterator listIterator()
    (§
        (§ return (§ expr reify().listIterator()))
    )

    public ListIterator listIterator(int index)
    (§
        (§ return (§ expr reify().listIterator(index)))
    )

    public Object get(int index)
    (§
        (§ return (§ expr RT.nth(this, index)))
    )

    public void add(int index, Object element)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(int index, Collection c)
    (§
        throw new UnsupportedOperationException()
    )
)
)

(java-ns cloiure.lang.Associative

(§ interface public interface Associative extends IPersistentCollection, ILookup)
(§
    boolean containsKey(Object key)

    IMapEntry entryAt(Object key)

    Associative assoc(Object key, Object val)
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(§ class final public class Atom extends ARef implements IAtom2)
(§
    final AtomicReference state

    public Atom(Object state)
    (§
        this.state = new AtomicReference(state)
    )

    public Atom(Object state, IPersistentMap meta)
    (§
        super(meta)
        this.state = new AtomicReference(state)
    )

    public Object deref()
    (§
        (§ return (§ expr state.get()))
    )

    public Object swap(IFn f)
    (§
        while (true)
        (§
            Object v = deref()
            Object newv = f.invoke(v)
            validate(newv)
            if (state.compareAndSet(v, newv))
            (§
                notifyWatches(v, newv)
                (§ return (§ expr newv))
            )
        )
    )

    public Object swap(IFn f, Object arg)
    (§
        while (true)
        (§
            Object v = deref()
            Object newv = f.invoke(v, arg)
            validate(newv)
            if (state.compareAndSet(v, newv))
            (§
                notifyWatches(v, newv)
                (§ return (§ expr newv))
            )
        )
    )

    public Object swap(IFn f, Object arg1, Object arg2)
    (§
        while (true)
        (§
            Object v = deref()
            Object newv = f.invoke(v, arg1, arg2)
            validate(newv)
            if (state.compareAndSet(v, newv))
            (§
                notifyWatches(v, newv)
                (§ return (§ expr newv))
            )
        )
    )

    public Object swap(IFn f, Object x, Object y, ISeq args)
    (§
        while (true)
        (§
            Object v = deref()
            Object newv = f.applyTo(RT.listStar(v, x, y, args))
            validate(newv)
            if (state.compareAndSet(v, newv))
            (§
                notifyWatches(v, newv)
                (§ return (§ expr newv))
            )
        )
    )

    public IPersistentVector swapVals(IFn f)
    (§
        while (true)
        (§
            Object oldv = deref()
            Object newv = f.invoke(oldv)
            validate(newv)
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    public IPersistentVector swapVals(IFn f, Object arg)
    (§
        while (true)
        (§
            Object oldv = deref()
            Object newv = f.invoke(oldv, arg)
            validate(newv)
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    public IPersistentVector swapVals(IFn f, Object arg1, Object arg2)
    (§
        while (true)
        (§
            Object oldv = deref()
            Object newv = f.invoke(oldv, arg1, arg2)
            validate(newv)
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    public IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args)
    (§
        while (true)
        (§
            Object oldv = deref()
            Object newv = f.applyTo(RT.listStar(oldv, x, y, args))
            validate(newv)
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )

    public boolean compareAndSet(Object oldv, Object newv)
    (§
        validate(newv)
        boolean ret = state.compareAndSet(oldv, newv)
        if (ret)
        (§
            notifyWatches(oldv, newv)
        )
        (§ return (§ expr ret))
    )

    public Object reset(Object newval)
    (§
        Object oldval = state.get()
        validate(newval)
        state.set(newval)
        notifyWatches(oldval, newval)
        (§ return (§ expr newval))
    )

    public IPersistentVector resetVals(Object newv)
    (§
        validate(newv)
        while (true)
        (§
            Object oldv = deref()
            if (state.compareAndSet(oldv, newv))
            (§
                notifyWatches(oldv, newv)
                (§ return (§ expr LazilyPersistentVector.createOwning(oldv, newv)))
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

(§ import cloiure.lang.PersistentHashMap.INode)

(§ class public abstract class ATransientMap extends AFn implements ITransientMap, ITransientAssociative2)
(§
    abstract void ensureEditable()
    abstract ITransientMap doAssoc(Object key, Object val)
    abstract ITransientMap doWithout(Object key)
    abstract Object doValAt(Object key, Object notFound)
    abstract int doCount()
    abstract IPersistentMap doPersistent()

    public ITransientMap conj(Object o)
    (§
        ensureEditable()
        if (o instanceof Map.Entry)
        (§
            Map.Entry e = (Map.Entry) o

            (§ return (§ expr assoc(e.getKey(), e.getValue())))
        )
        else if (o instanceof IPersistentVector)
        (§
            IPersistentVector v = (IPersistentVector) o
            if (v.count() != 2)
            (§
                throw new IllegalArgumentException("Vector arg to map conj must be a pair")
            )
            (§ return (§ expr assoc(v.nth(0), v.nth(1))))
        )

        ITransientMap ret = this
        for (ISeq es = RT.seq(o) es != nil es = es.next())
        (§
            Map.Entry e = (Map.Entry) es.first()
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        (§ return (§ expr ret))
    )

    public final Object invoke(Object arg1)
    (§
        (§ return (§ expr valAt(arg1)))
    )

    public final Object invoke(Object arg1, Object notFound)
    (§
        (§ return (§ expr valAt(arg1, notFound)))
    )

    public final Object valAt(Object key)
    (§
        (§ return (§ expr valAt(key, nil)))
    )

    public final ITransientMap assoc(Object key, Object val)
    (§
        ensureEditable()
        (§ return (§ expr doAssoc(key, val)))
    )

    public final ITransientMap without(Object key)
    (§
        ensureEditable()
        (§ return (§ expr doWithout(key)))
    )

    public final IPersistentMap persistent()
    (§
        ensureEditable()
        (§ return (§ expr doPersistent()))
    )

    public final Object valAt(Object key, Object notFound)
    (§
        ensureEditable()
        (§ return (§ expr doValAt(key, notFound)))
    )

    private static final Object NOT_FOUND = new Object()
    public final boolean containsKey(Object key)
    (§
        (§ return (§ expr (valAt(key, NOT_FOUND) != NOT_FOUND)))
    )
    public final IMapEntry entryAt(Object key)
    (§
        Object v = valAt(key, NOT_FOUND)
        if (v != NOT_FOUND)
        (§
            (§ return (§ expr MapEntry.create(key, v)))
        )
        (§ return (§ expr nil))
    )

    public final int count()
    (§
        ensureEditable()
        (§ return (§ expr doCount()))
    )
)
)

(java-ns cloiure.lang.ATransientSet

(§ class public abstract class ATransientSet extends AFn implements ITransientSet)
(§
    volatile ITransientMap impl

    ATransientSet(ITransientMap impl)
    (§
        this.impl = impl
    )

    public int count()
    (§
        (§ return (§ expr impl.count()))
    )

    public ITransientSet conj(Object val)
    (§
        ITransientMap m = impl.assoc(val, val)
        if (m != impl)
        (§
            this.impl = m
        )
        (§ return (§ expr this))
    )

    public boolean contains(Object key)
    (§
        (§ return (§ expr (this != impl.valAt(key, this))))
    )

    public ITransientSet disjoin(Object key)
    (§
        ITransientMap m = impl.without(key)
        if (m != impl)
        (§
            this.impl = m
        )
        (§ return (§ expr this))
    )

    public Object get(Object key)
    (§
        (§ return (§ expr impl.valAt(key)))
    )

    public Object invoke(Object key, Object notFound)
    (§
        (§ return (§ expr impl.valAt(key, notFound)))
    )

    public Object invoke(Object key)
    (§
        (§ return (§ expr impl.valAt(key)))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(§ class public final class BigInt extends Number implements IHashEq)
(§
    final public long lpart
    final public BigInteger bipart

    final public static BigInt ZERO = new BigInt(0, nil)
    final public static BigInt ONE = new BigInt(1, nil)

    ;; must follow Long
    public int hashCode()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr (int) (this.lpart :xor (this.lpart >>> 32))))
        )
        (§ return (§ expr bipart.hashCode()))
    )

    public int hasheq()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr Murmur3.hashLong(lpart)))
        )
        (§ return (§ expr bipart.hashCode()))
    )

    public boolean equals(Object obj)
    (§
        if (this == obj)
        (§
            (§ return (§ expr true))
        )
        if (obj instanceof BigInt)
        (§
            BigInt o = (BigInt) obj
            if (bipart == nil)
            (§
                (§ return (§ expr (o.bipart == nil && this.lpart == o.lpart)))
            )
            (§ return (§ expr (o.bipart != nil && this.bipart.equals(o.bipart))))
        )
        (§ return (§ expr false))
    )

    private BigInt(long lpart, BigInteger bipart)
    (§
        this.lpart = lpart
        this.bipart = bipart
    )

    public static BigInt fromBigInteger(BigInteger val)
    (§
        if (val.bitLength() < 64)
        (§
            (§ return (§ expr new BigInt(val.longValue(), nil)))
        )
        else
        (§
            (§ return (§ expr new BigInt(0, val)))
        )
    )

    public static BigInt fromLong(long val)
    (§
        (§ return (§ expr new BigInt(val, nil)))
    )

    public BigInteger toBigInteger()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr BigInteger.valueOf(lpart)))
        )
        else
        (§
            (§ return (§ expr bipart))
        )
    )

    public BigDecimal toBigDecimal()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr BigDecimal.valueOf(lpart)))
        )
        else
        (§
            (§ return (§ expr new BigDecimal(bipart)))
        )
    )

    public int intValue()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr (int) lpart))
        )
        else
        (§
            (§ return (§ expr bipart.intValue()))
        )
    )

    public long longValue()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr lpart))
        )
        else
        (§
            (§ return (§ expr bipart.longValue()))
        )
    )

    public float floatValue()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr lpart))
        )
        else
        (§
            (§ return (§ expr bipart.floatValue()))
        )
    )

    public double doubleValue()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr lpart))
        )
        else
        (§
            (§ return (§ expr bipart.doubleValue()))
        )
    )

    public byte byteValue()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr (byte) lpart))
        )
        else
        (§
            (§ return (§ expr bipart.byteValue()))
        )
    )

    public short shortValue()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr (short) lpart))
        )
        else
        (§
            (§ return (§ expr bipart.shortValue()))
        )
    )

    public static BigInt valueOf(long val)
    (§
        (§ return (§ expr new BigInt(val, nil)))
    )

    public String toString()
    (§
        if (bipart == nil)
        (§
            (§ return (§ expr String.valueOf(lpart)))
        )
        (§ return (§ expr bipart.toString()))
    )

    public int bitLength()
    (§
        (§ return (§ expr toBigInteger().bitLength()))
    )

    public BigInt add(BigInt y)
    (§
        if ((bipart == nil) && (y.bipart == nil))
        (§
            long ret = lpart + y.lpart
            if ((ret :xor lpart) >= 0 || (ret :xor y.lpart) >= 0)
            (§
                (§ return (§ expr BigInt.valueOf(ret)))
            )
        )
        (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().add(y.toBigInteger()))))
    )

    public BigInt multiply(BigInt y)
    (§
        if ((bipart == nil) && (y.bipart == nil))
        (§
            long ret = lpart * y.lpart
            if (y.lpart == 0 || (ret / y.lpart == lpart && lpart != Long.MIN_VALUE))
            (§
                (§ return (§ expr BigInt.valueOf(ret)))
            )
        )
        (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().multiply(y.toBigInteger()))))
    )

    public BigInt quotient(BigInt y)
    (§
        if ((bipart == nil) && (y.bipart == nil))
        (§
            if (lpart == Long.MIN_VALUE && y.lpart == -1)
            (§
                (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().negate())))
            )
            (§ return (§ expr BigInt.valueOf(lpart / y.lpart)))
        )
        (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().divide(y.toBigInteger()))))
    )

    public BigInt remainder(BigInt y)
    (§
        if ((bipart == nil) && (y.bipart == nil))
        (§
            (§ return (§ expr BigInt.valueOf(lpart % y.lpart)))
        )
        (§ return (§ expr BigInt.fromBigInteger(this.toBigInteger().remainder(y.toBigInteger()))))
    )

    public boolean lt(BigInt y)
    (§
        if ((bipart == nil) && (y.bipart == nil))
        (§
            (§ return (§ expr (lpart < y.lpart)))
        )
        (§ return (§ expr (this.toBigInteger().compareTo(y.toBigInteger()) < 0)))
    )
)
)

(java-ns cloiure.lang.Binding

(§ class public class Binding<T>)
(§
    public T val
    public final Binding rest

    public Binding(T val)
    (§
        this.val = val
        this.rest = nil
    )

    public Binding(T val, Binding rest)
    (§
        this.val = val
        this.rest = rest
    )
)
)

(java-ns cloiure.lang.Box

(§ class public class Box)
(§
    public Object val

    public Box(Object val)
    (§
        this.val = val
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(§ class final public class ChunkBuffer implements Counted)
(§
    Object[] buffer
    int end

    public ChunkBuffer(int capacity)
    (§
        buffer = new Object[capacity]
        end = 0
    )

    public void add(Object o)
    (§
        buffer[end++] = o
    )

    public IChunk chunk()
    (§
        ArrayChunk ret = new ArrayChunk(buffer, 0, end)
        buffer = nil
        (§ return (§ expr ret))
    )

    public int count()
    (§
        (§ return (§ expr end))
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(§ class final public class ChunkedCons extends ASeq implements IChunkedSeq)
(§
    final IChunk chunk
    final ISeq _more

    ChunkedCons(IPersistentMap meta, IChunk chunk, ISeq more)
    (§
        super(meta)
        this.chunk = chunk
        this._more = more
    )

    public ChunkedCons(IChunk chunk, ISeq more)
    (§
        this(nil, chunk, more)
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        if (meta != _meta)
        (§
            (§ return (§ expr new ChunkedCons(meta, chunk, _more)))
        )
        (§ return (§ expr this))
    )

    public Object first()
    (§
        (§ return (§ expr chunk.nth(0)))
    )

    public ISeq next()
    (§
        if (chunk.count() > 1)
        (§
            (§ return (§ expr new ChunkedCons(chunk.dropFirst(), _more)))
        )
        (§ return (§ expr chunkedNext()))
    )

    public ISeq more()
    (§
        if (chunk.count() > 1)
        (§
            (§ return (§ expr new ChunkedCons(chunk.dropFirst(), _more)))
        )
        if (_more == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _more))
    )

    public IChunk chunkedFirst()
    (§
        (§ return (§ expr chunk))
    )

    public ISeq chunkedNext()
    (§
        (§ return (§ expr chunkedMore().seq()))
    )

    public ISeq chunkedMore()
    (§
        if (_more == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _more))
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

(§ class public class Compile)
(§
    private static final String PATH_PROP = "cloiure.compile.path"
    private static final String REFLECTION_WARNING_PROP = "cloiure.compile.warn-on-reflection"
    private static final String UNCHECKED_MATH_PROP = "cloiure.compile.unchecked-math"

    private static final Var compile_path = RT.var("cloiure.core", "*compile-path*")
    private static final Var compile = RT.var("cloiure.core", "compile")
    private static final Var warn_on_reflection = RT.var("cloiure.core", "*warn-on-reflection*")
    private static final Var unchecked_math = RT.var("cloiure.core", "*unchecked-math*")

    public static void main(String[] args) throws IOException, ClassNotFoundException
    (§
        OutputStreamWriter out = (OutputStreamWriter) RT.OUT.deref()
        PrintWriter err = RT.errPrintWriter()
        String path = System.getProperty(PATH_PROP)
        int count = args.length

        if (path == nil)
        (§
            err.println("ERROR: Must set system property " + PATH_PROP +
                    "\nto the location for compiled .class files." +
                    "\nThis directory must also be on your CLASSPATH.")
            System.exit(1)
        )

        boolean warnOnReflection = System.getProperty(REFLECTION_WARNING_PROP, "false").equals("true")
        String uncheckedMathProp = System.getProperty(UNCHECKED_MATH_PROP)
        Object uncheckedMath = Boolean.FALSE
        if ("true".equals(uncheckedMathProp))
        (§
            uncheckedMath = Boolean.TRUE
        )
        else if ("warn-on-boxed".equals(uncheckedMathProp))
        (§
            uncheckedMath = Keyword.intern("warn-on-boxed")
        )

        ;; force load to avoid transitive compilation during lazy load
        RT.load("cloiure/core/specs/alpha")

        try
        (§
            Var.pushThreadBindings(RT.map(compile_path, path, warn_on_reflection, warnOnReflection, unchecked_math, uncheckedMath))

            for (String lib :in args)
            (§
                out.write("Compiling " + lib + " to " + path + "\n")
                out.flush()
                compile.invoke(Symbol.intern(lib))
            )
        )
        finally
        (§
            Var.popThreadBindings()
            try
            (§
                out.flush()
            )
            catch (IOException e)
            (§
                e.printStackTrace(err)
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(§ class public class Compiler implements Opcodes)
(§
    static final Symbol DEF = Symbol.intern("def")
    static final Symbol LOOP = Symbol.intern("loop*")
    static final Symbol RECUR = Symbol.intern("recur")
    static final Symbol IF = Symbol.intern("if")
    static final Symbol LET = Symbol.intern("let*")
    static final Symbol LETFN = Symbol.intern("letfn*")
    static final Symbol DO = Symbol.intern("do")
    static final Symbol FN = Symbol.intern("fn*")
    static final Symbol FNONCE = (Symbol) Symbol.intern("fn*").withMeta(RT.map(Keyword.intern(nil, "once"), RT.T))
    static final Symbol QUOTE = Symbol.intern("quote")
    static final Symbol THE_VAR = Symbol.intern("var")
    static final Symbol DOT = Symbol.intern(".")
    static final Symbol ASSIGN = Symbol.intern("set!")
    static final Symbol TRY = Symbol.intern("try")
    static final Symbol CATCH = Symbol.intern("catch")
    static final Symbol FINALLY = Symbol.intern("finally")
    static final Symbol THROW = Symbol.intern("throw")
    static final Symbol MONITOR_ENTER = Symbol.intern("monitor-enter")
    static final Symbol MONITOR_EXIT = Symbol.intern("monitor-exit")
    static final Symbol IMPORT = Symbol.intern("cloiure.core", "import*")
    static final Symbol DEFTYPE = Symbol.intern("deftype*")
    static final Symbol CASE = Symbol.intern("case*")

    static final Symbol CLASS = Symbol.intern("Class")
    static final Symbol NEW = Symbol.intern("new")
    static final Symbol THIS = Symbol.intern("this")
    static final Symbol REIFY = Symbol.intern("reify*")
    static final Symbol LIST = Symbol.intern("cloiure.core", "list")
    static final Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map")
    static final Symbol VECTOR = Symbol.intern("cloiure.core", "vector")
    static final Symbol IDENTITY = Symbol.intern("cloiure.core", "identity")

    static final Symbol _AMP_ = Symbol.intern("&")
    static final Symbol ISEQ = Symbol.intern("cloiure.lang.ISeq")

    static final Keyword loadNs = Keyword.intern(nil, "load-ns")
    static final Keyword inlineKey = Keyword.intern(nil, "inline")
    static final Keyword inlineAritiesKey = Keyword.intern(nil, "inline-arities")
    static final Keyword staticKey = Keyword.intern(nil, "static")
    static final Keyword arglistsKey = Keyword.intern(nil, "arglists")
    static final Symbol INVOKE_STATIC = Symbol.intern("invokeStatic")

    static final Keyword volatileKey = Keyword.intern(nil, "volatile")
    static final Keyword implementsKey = Keyword.intern(nil, "implements")
    static final String COMPILE_STUB_PREFIX = "compile__stub"

    static final Keyword protocolKey = Keyword.intern(nil, "protocol")
    static final Keyword onKey = Keyword.intern(nil, "on")
    static Keyword dynamicKey = Keyword.intern("dynamic")
    static final Keyword redefKey = Keyword.intern(nil, "redef")

    static final Symbol NS = Symbol.intern("ns")
    static final Symbol IN_NS = Symbol.intern("in-ns")

    static final public IPersistentMap specials = PersistentHashMap.create(
        DEF, new DefExpr.Parser(),
        LOOP, new LetExpr.Parser(),
        RECUR, new RecurExpr.Parser(),
        IF, new IfExpr.Parser(),
        CASE, new CaseExpr.Parser(),
        LET, new LetExpr.Parser(),
        LETFN, new LetFnExpr.Parser(),
        DO, new BodyExpr.Parser(),
        FN, nil,
        QUOTE, new ConstantExpr.Parser(),
        THE_VAR, new TheVarExpr.Parser(),
        IMPORT, new ImportExpr.Parser(),
        DOT, new HostExpr.Parser(),
        ASSIGN, new AssignExpr.Parser(),
        DEFTYPE, new NewInstanceExpr.DeftypeParser(),
        REIFY, new NewInstanceExpr.ReifyParser(),
        TRY, new TryExpr.Parser(),
        THROW, new ThrowExpr.Parser(),
        MONITOR_ENTER, new MonitorEnterExpr.Parser(),
        MONITOR_EXIT, new MonitorExitExpr.Parser(),
        CATCH, nil,
        FINALLY, nil,
        NEW, new NewExpr.Parser(),
        _AMP_, nil
    )

    private static final int MAX_POSITIONAL_ARITY = 20
    private static final Type OBJECT_TYPE
    private static final Type KEYWORD_TYPE = Type.getType(Keyword.class)
    private static final Type VAR_TYPE = Type.getType(Var.class)
    private static final Type SYMBOL_TYPE = Type.getType(Symbol.class)
    private static final Type IFN_TYPE = Type.getType(IFn.class)
    private static final Type AFUNCTION_TYPE = Type.getType(AFunction.class)
    private static final Type RT_TYPE = Type.getType(RT.class)
    private static final Type NUMBERS_TYPE = Type.getType(Numbers.class)

    final static Type CLASS_TYPE = Type.getType(Class.class)
    final static Type NS_TYPE = Type.getType(Namespace.class)
    final static Type UTIL_TYPE = Type.getType(Util.class)
    final static Type REFLECTOR_TYPE = Type.getType(Reflector.class)
    final static Type THROWABLE_TYPE = Type.getType(Throwable.class)
    final static Type BOOLEAN_OBJECT_TYPE = Type.getType(Boolean.class)
    final static Type IPERSISTENTMAP_TYPE = Type.getType(IPersistentMap.class)
    final static Type IOBJ_TYPE = Type.getType(IObj.class)
    final static Type TUPLE_TYPE = Type.getType(Tuple.class)

    final static Method createTupleMethods[] =
    (§
        Method.getMethod("cloiure.lang.IPersistentVector create()"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)"),
        Method.getMethod("cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)")
    )

    private static final Type[][] ARG_TYPES
    private static final Type[] EXCEPTION_TYPES = (§)

    static
    (§
        OBJECT_TYPE = Type.getType(Object.class)
        ARG_TYPES = new Type[MAX_POSITIONAL_ARITY + 2][]
        for (int i = 0 i <= MAX_POSITIONAL_ARITY ++i)
        (§
            Type[] a = new Type[i]
            for (int j = 0 j < i j++)
            (§
                a[j] = OBJECT_TYPE
            )
            ARG_TYPES[i] = a
        )
        Type[] a = new Type[MAX_POSITIONAL_ARITY + 1]
        for (int j = 0 j < MAX_POSITIONAL_ARITY j++)
        (§
            a[j] = OBJECT_TYPE
        )
        a[MAX_POSITIONAL_ARITY] = Type.getType("[Ljava/lang/Object;")
        ARG_TYPES[MAX_POSITIONAL_ARITY + 1] = a
    )

    ;; symbol->localbinding
    static final public Var LOCAL_ENV = Var.create(nil).setDynamic()

    ;; vector<localbinding>
    static final public Var LOOP_LOCALS = Var.create().setDynamic()

    ;; Label
    static final public Var LOOP_LABEL = Var.create().setDynamic()

    ;; vector<object>
    static final public Var CONSTANTS = Var.create().setDynamic()

    ;; IdentityHashMap
    static final public Var CONSTANT_IDS = Var.create().setDynamic()

    ;; vector<keyword>
    static final public Var KEYWORD_CALLSITES = Var.create().setDynamic()

    ;; vector<var>
    static final public Var PROTOCOL_CALLSITES = Var.create().setDynamic()

    ;; set<var>
    static final public Var VAR_CALLSITES = Var.create().setDynamic()

    ;; keyword->constid
    static final public Var KEYWORDS = Var.create().setDynamic()

    ;; var->constid
    static final public Var VARS = Var.create().setDynamic()

    ;; FnFrame
    static final public Var METHOD = Var.create(nil).setDynamic()

    ;; nil or not
    static final public Var IN_CATCH_FINALLY = Var.create(nil).setDynamic()

    static final public Var METHOD_RETURN_CONTEXT = Var.create(nil).setDynamic()

    static final public Var NO_RECUR = Var.create(nil).setDynamic()

    ;; DynamicClassLoader
    static final public Var LOADER = Var.create().setDynamic()

    ;; String
    static final public Var SOURCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*source-path*"), "NO_SOURCE_FILE").setDynamic()

    ;; String
    static final public Var SOURCE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynamic()

    ;; String
    static final public Var COMPILE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-path*"), nil).setDynamic()
    ;; boolean
    static final public Var COMPILE_FILES = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compile-files*"), Boolean.FALSE).setDynamic()

    static final public Var INSTANCE = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("instance?"))

    static final public Var ADD_ANNOTATIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("add-annotations"))

    static final public Keyword disableLocalsClearingKey = Keyword.intern("disable-locals-clearing")
    static final public Keyword directLinkingKey = Keyword.intern("direct-linking")
    static final public Keyword elideMetaKey = Keyword.intern("elide-meta")

    static final public Var COMPILER_OPTIONS

    static public Object getCompilerOption(Keyword k)
    (§
        (§ return (§ expr RT.get(COMPILER_OPTIONS.deref(), k)))
    )

    static
    (§
        Object compilerOptions = nil

        for (Map.Entry e :in System.getProperties().entrySet())
        (§
            String name = (String) e.getKey()
            String v = (String) e.getValue()
            if (name.startsWith("cloiure.compiler."))
            (§
                compilerOptions = RT.assoc(compilerOptions, RT.keyword(nil, name.substring(1 + name.lastIndexOf(\.))), RT.readString(v))
            )
        )

        COMPILER_OPTIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*compiler-options*"), compilerOptions).setDynamic()
    )

    static Object elideMeta(Object m)
    (§
        Collection<Object> elides = (Collection<Object>) getCompilerOption(elideMetaKey)
        if (elides != nil)
        (§
            for (Object k :in elides)
            (§
                m = RT.dissoc(m, k)
            )
        )
        (§ return (§ expr m))
    )

    ;; Integer
    static final public Var LINE = Var.create(0).setDynamic()
    static final public Var COLUMN = Var.create(0).setDynamic()

    static int lineDeref()
    (§
        (§ return (§ expr ((Number)LINE.deref()).intValue()))
    )

    static int columnDeref()
    (§
        (§ return (§ expr ((Number)COLUMN.deref()).intValue()))
    )

    ;; Integer
    static final public Var LINE_BEFORE = Var.create(0).setDynamic()
    static final public Var COLUMN_BEFORE = Var.create(0).setDynamic()
    static final public Var LINE_AFTER = Var.create(0).setDynamic()
    static final public Var COLUMN_AFTER = Var.create(0).setDynamic()

    ;; Integer
    static final public Var NEXT_LOCAL_NUM = Var.create(0).setDynamic()

    ;; Integer
    static final public Var RET_LOCAL_NUM = Var.create().setDynamic()

    static final public Var COMPILE_STUB_SYM = Var.create(nil).setDynamic()
    static final public Var COMPILE_STUB_CLASS = Var.create(nil).setDynamic()

    ;; PathNode chain
    static final public Var CLEAR_PATH = Var.create(nil).setDynamic()

    ;; tail of PathNode chain
    static final public Var CLEAR_ROOT = Var.create(nil).setDynamic()

    ;; LocalBinding -> Set<LocalBindingExpr>
    static final public Var CLEAR_SITES = Var.create(nil).setDynamic()

    public enum C
    (§
        STATEMENT, ;; value ignored
        EXPRESSION, ;; value required
        RETURN, ;; tail position relative to enclosing recur frame
        EVAL
    )

    private class Recur (§)
    static final public Class RECUR_CLASS = Recur.class

    interface Expr
    (§
        Object eval()

        void emit(C context, ObjExpr objx, GeneratorAdapter gen)

        boolean hasJavaClass()

        Class getJavaClass()
    )

    public static abstract class UntypedExpr implements Expr
    (§
        public Class getJavaClass()
        (§
            throw new IllegalArgumentException("Has no Java class")
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr false))
        )
    )

    interface IParser
    (§
        Expr parse(C context, Object form)
    )

    static boolean isSpecial(Object sym)
    (§
        (§ return (§ expr specials.containsKey(sym)))
    )

    static boolean inTailCall(C context)
    (§
        (§ return (§ expr (context == C.RETURN) && (METHOD_RETURN_CONTEXT.deref() != nil) && (IN_CATCH_FINALLY.deref() == nil)))
    )

    static Symbol resolveSymbol(Symbol sym)
    (§
        ;; already qualified or classname?
        if (sym.name.indexOf(\.) > 0)
        (§
            (§ return (§ expr sym))
        )
        if (sym.ns != nil)
        (§
            Namespace ns = namespaceFor(sym)
            if (ns == nil || ((ns.name.name == nil) ? (sym.ns == nil) :or ns.name.name.equals(sym.ns)))
            (§
                (§ return (§ expr sym))
            )
            (§ return (§ expr Symbol.intern(ns.name.name, sym.name)))
        )
        Object o = currentNS().getMapping(sym)
        if (o == nil)
        (§
            (§ return (§ expr Symbol.intern(currentNS().name.name, sym.name)))
        )
        else if (o instanceof Class)
        (§
            (§ return (§ expr Symbol.intern(nil, ((Class) o).getName())))
        )
        else if (o instanceof Var)
        (§
            Var v = (Var) o
            (§ return (§ expr Symbol.intern(v.ns.name.name, v.sym.name)))
        )
        (§ return (§ expr nil))
    )

    static class DefExpr implements Expr
    (§
        public final Var var
        public final Expr init
        public final Expr meta
        public final boolean initProvided
        public final boolean isDynamic
        public final boolean shadowsCoreMapping
        public final String source
        public final int line
        public final int column

        final static Method bindRootMethod = Method.getMethod("void bindRoot(Object)")
        final static Method setTagMethod = Method.getMethod("void setTag(cloiure.lang.Symbol)")
        final static Method setMetaMethod = Method.getMethod("void setMeta(cloiure.lang.IPersistentMap)")
        final static Method setDynamicMethod = Method.getMethod("cloiure.lang.Var setDynamic(boolean)")
        final static Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String, String)")
        final static Method internVar = Method.getMethod("cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)")

        public DefExpr(String source, int line, int column, Var var, Expr init, Expr meta, boolean initProvided, boolean isDynamic, boolean shadowsCoreMapping)
        (§
            this.source = source
            this.line = line
            this.column = column
            this.var = var
            this.init = init
            this.meta = meta
            this.isDynamic = isDynamic
            this.shadowsCoreMapping = shadowsCoreMapping
            this.initProvided = initProvided
        )

        private boolean includesExplicitMetadata(MapExpr expr)
        (§
            for (int i = 0 i < expr.keyvals.count() i += 2)
            (§
                Keyword k  = ((KeywordExpr) expr.keyvals.nth(i)).k
                if ((k != RT.FILE_KEY) && (k != RT.DECLARED_KEY) && (k != RT.LINE_KEY) && (k != RT.COLUMN_KEY))
                (§
                    (§ return (§ expr true))
                )
            )
            (§ return (§ expr false))
        )

        public Object eval()
        (§
            try
            (§
                if (initProvided)
                (§
                    var.bindRoot(init.eval())
                )
                if (meta != nil)
                (§
                    IPersistentMap metaMap = (IPersistentMap) meta.eval()
                    if (initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                    (§
                        var.setMeta(metaMap)
                    )
                )
                (§ return (§ expr var.setDynamic(isDynamic)))
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitVar(gen, var)

            if (shadowsCoreMapping)
            (§
                gen.dup()
                gen.getField(VAR_TYPE, "ns", NS_TYPE)
                gen.swap()
                gen.dup()
                gen.getField(VAR_TYPE, "sym", SYMBOL_TYPE)
                gen.swap()
                gen.invokeVirtual(NS_TYPE, internVar)
            )

            if (isDynamic)
            (§
                gen.push(isDynamic)
                gen.invokeVirtual(VAR_TYPE, setDynamicMethod)
            )
            if (meta != nil)
            (§
                if (initProvided || true) ;; includesExplicitMetadata((MapExpr) meta)
                (§
                    gen.dup()
                    meta.emit(C.EXPRESSION, objx, gen)
                    gen.checkCast(IPERSISTENTMAP_TYPE)
                    gen.invokeVirtual(VAR_TYPE, setMetaMethod)
                )
            )
            if (initProvided)
            (§
                gen.dup()
                if (init instanceof FnExpr)
                (§
                    ((FnExpr)init).emitForDefn(objx, gen)
                )
                else
                (§
                    init.emit(C.EXPRESSION, objx, gen)
                )
                gen.invokeVirtual(VAR_TYPE, bindRootMethod)
            )

            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr Var.class))
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
                String docstring = nil
                if (RT.count(form) == 4 && (RT.third(form) instanceof String))
                (§
                    docstring = (String) RT.third(form)
                    form = RT.list(RT.first(form), RT.second(form), RT.fourth(form))
                )
                if (RT.count(form) > 3)
                (§
                    throw Util.runtimeException("Too many arguments to def")
                )
                else if (RT.count(form) < 2)
                (§
                    throw Util.runtimeException("Too few arguments to def")
                )
                else if (!(RT.second(form) instanceof Symbol))
                (§
                    throw Util.runtimeException("First argument to def must be a Symbol")
                )
                Symbol sym = (Symbol) RT.second(form)
                Var v = lookupVar(sym, true)
                if (v == nil)
                (§
                    throw Util.runtimeException("Can't refer to qualified var that doesn't exist")
                )
                boolean shadowsCoreMapping = false
                if (!v.ns.equals(currentNS()))
                (§
                    if (sym.ns == nil)
                    (§
                        v = currentNS().intern(sym)
                        shadowsCoreMapping = true
                        registerVar(v)
                    )
                    else
                    (§
                        throw Util.runtimeException("Can't create defs outside of current ns")
                    )
                )
                IPersistentMap mm = sym.meta()
                boolean isDynamic = RT.booleanCast(RT.get(mm, dynamicKey))
                if (isDynamic)
                (§
                    v.setDynamic()
                )
                if (!isDynamic && sym.name.startsWith("*") && sym.name.endsWith("*") && sym.name.length() > 2)
                (§
                    RT.errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, " + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", sym, SOURCE_PATH.get(), LINE.get())
                )
                if (RT.booleanCast(RT.get(mm, arglistsKey)))
                (§
                    IPersistentMap vm = v.meta()
                    ;; drop quote
                    vm = (IPersistentMap) RT.assoc(vm, arglistsKey, RT.second(mm.valAt(arglistsKey)))
                    v.setMeta(vm)
                )
                Object source_path = SOURCE_PATH.get()
                source_path = (source_path == nil) ? "NO_SOURCE_FILE" :or source_path
                mm = (IPersistentMap) RT.assoc(mm, RT.LINE_KEY, LINE.get()).assoc(RT.COLUMN_KEY, COLUMN.get()).assoc(RT.FILE_KEY, source_path)
                if (docstring != nil)
                (§
                    mm = (IPersistentMap) RT.assoc(mm, RT.DOC_KEY, docstring)
                )
                mm = (IPersistentMap) elideMeta(mm)
                Expr meta = (mm.count() == 0) ? nil :or analyze((context == C.EVAL) ? context :or C.EXPRESSION, mm)
                (§ return (§ expr new DefExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), v, analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.third(form), v.sym.name), meta, (RT.count(form) == 3), isDynamic, shadowsCoreMapping)))
            )
        )
    )

    public static class AssignExpr implements Expr
    (§
        public final AssignableExpr target
        public final Expr val

        public AssignExpr(AssignableExpr target, Expr val)
        (§
            this.target = target
            this.val = val
        )

        public Object eval()
        (§
            (§ return (§ expr target.evalAssign(val)))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            target.emitAssign(context, objx, gen, val)
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr val.hasJavaClass()))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr val.getJavaClass()))
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                if (RT.length(form) != 3)
                (§
                    throw new IllegalArgumentException("Malformed assignment, expecting (set! target val)")
                )
                Expr target = analyze(C.EXPRESSION, RT.second(form))
                if (!(target instanceof AssignableExpr))
                (§
                    throw new IllegalArgumentException("Invalid assignment target")
                )
                (§ return (§ expr new AssignExpr((AssignableExpr) target, analyze(C.EXPRESSION, RT.third(form)))))
            )
        )
    )

    public static class VarExpr implements Expr, AssignableExpr
    (§
        public final Var var
        public final Object tag
        final static Method getMethod = Method.getMethod("Object get()")
        final static Method setMethod = Method.getMethod("Object set(Object)")

        Class jc

        public VarExpr(Var var, Symbol tag)
        (§
            this.var = var
            this.tag = (tag != nil) ? tag :or var.getTag()
        )

        public Object eval()
        (§
            (§ return (§ expr var.deref()))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitVarValue(gen, var)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (tag != nil)))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = HostExpr.tagToClass(tag)
            )
            (§ return (§ expr jc))
        )

        public Object evalAssign(Expr val)
        (§
            (§ return (§ expr var.set(val.eval())))
        )

        public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
        (§
            objx.emitVar(gen, var)
            val.emit(C.EXPRESSION, objx, gen)
            gen.invokeVirtual(VAR_TYPE, setMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )
    )

    public static class TheVarExpr implements Expr
    (§
        public final Var var

        public TheVarExpr(Var var)
        (§
            this.var = var
        )

        public Object eval()
        (§
            (§ return (§ expr var))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitVar(gen, var)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr Var.class))
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                Symbol sym = (Symbol) RT.second(form)
                Var v = lookupVar(sym, false)
                if (v != nil)
                (§
                    (§ return (§ expr new TheVarExpr(v)))
                )
                throw Util.runtimeException("Unable to resolve var: " + sym + " in this context")
            )
        )
    )

    public static class KeywordExpr extends LiteralExpr
    (§
        public final Keyword k

        public KeywordExpr(Keyword k)
        (§
            this.k = k
        )

        Object val()
        (§
            (§ return (§ expr k))
        )

        public Object eval()
        (§
            (§ return (§ expr k))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitKeyword(gen, k)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr Keyword.class))
        )
    )

    public static class ImportExpr implements Expr
    (§
        public final String c

        final static Method forNameMethod = Method.getMethod("Class classForNameNonLoading(String)")
        final static Method importClassMethod = Method.getMethod("Class importClass(Class)")
        final static Method derefMethod = Method.getMethod("Object deref()")

        public ImportExpr(String c)
        (§
            this.c = c
        )

        public Object eval()
        (§
            Namespace ns = (Namespace) RT.CURRENT_NS.deref()
            ns.importClass(RT.classForNameNonLoading(c))
            (§ return (§ expr nil))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.getStatic(RT_TYPE, "CURRENT_NS", VAR_TYPE)
            gen.invokeVirtual(VAR_TYPE, derefMethod)
            gen.checkCast(NS_TYPE)
            gen.push(c)
            gen.invokeStatic(RT_TYPE, forNameMethod)
            gen.invokeVirtual(NS_TYPE, importClassMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr false))
        )

        public Class getJavaClass()
        (§
            throw new IllegalArgumentException("ImportExpr has no Java class")
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                (§ return (§ expr new ImportExpr((String) RT.second(form))))
            )
        )
    )

    public static abstract class LiteralExpr implements Expr
    (§
        abstract Object val()

        public Object eval()
        (§
            (§ return (§ expr val()))
        )
    )

    static interface AssignableExpr
    (§
        Object evalAssign(Expr val)

        void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
    )

    static public interface MaybePrimitiveExpr extends Expr
    (§
        public boolean canEmitPrimitive()
        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
    )

    static public abstract class HostExpr implements Expr, MaybePrimitiveExpr
    (§
        final static Type BOOLEAN_TYPE = Type.getType(Boolean.class)
        final static Type CHAR_TYPE = Type.getType(Character.class)
        final static Type INTEGER_TYPE = Type.getType(Integer.class)
        final static Type LONG_TYPE = Type.getType(Long.class)
        final static Type FLOAT_TYPE = Type.getType(Float.class)
        final static Type DOUBLE_TYPE = Type.getType(Double.class)
        final static Type SHORT_TYPE = Type.getType(Short.class)
        final static Type BYTE_TYPE = Type.getType(Byte.class)
        final static Type NUMBER_TYPE = Type.getType(Number.class)

        final static Method charValueMethod = Method.getMethod("char charValue()")
        final static Method booleanValueMethod = Method.getMethod("boolean booleanValue()")

        final static Method charValueOfMethod = Method.getMethod("Character valueOf(char)")
        final static Method intValueOfMethod = Method.getMethod("Integer valueOf(int)")
        final static Method longValueOfMethod = Method.getMethod("Long valueOf(long)")
        final static Method floatValueOfMethod = Method.getMethod("Float valueOf(float)")
        final static Method doubleValueOfMethod = Method.getMethod("Double valueOf(double)")
        final static Method shortValueOfMethod = Method.getMethod("Short valueOf(short)")
        final static Method byteValueOfMethod = Method.getMethod("Byte valueOf(byte)")

        final static Method intValueMethod = Method.getMethod("int intValue()")
        final static Method longValueMethod = Method.getMethod("long longValue()")
        final static Method floatValueMethod = Method.getMethod("float floatValue()")
        final static Method doubleValueMethod = Method.getMethod("double doubleValue()")
        final static Method byteValueMethod = Method.getMethod("byte byteValue()")
        final static Method shortValueMethod = Method.getMethod("short shortValue()")

        final static Method fromIntMethod = Method.getMethod("cloiure.lang.Num from(int)")
        final static Method fromLongMethod = Method.getMethod("cloiure.lang.Num from(long)")
        final static Method fromDoubleMethod = Method.getMethod("cloiure.lang.Num from(double)")

        public static void emitBoxReturn(ObjExpr objx, GeneratorAdapter gen, Class returnType)
        (§
            if (returnType.isPrimitive())
            (§
                if (returnType == boolean.class)
                (§
                    Label falseLabel = gen.newLabel()
                    Label endLabel = gen.newLabel()
                    gen.ifZCmp(GeneratorAdapter.EQ, falseLabel)
                    gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE)
                    gen.goTo(endLabel)
                    gen.mark(falseLabel)
                    gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE)
                    gen.mark(endLabel)
                )
                else if (returnType == void.class)
                (§
                    NIL_EXPR.emit(C.EXPRESSION, objx, gen)
                )
                else if (returnType == char.class)
                (§
                    gen.invokeStatic(CHAR_TYPE, charValueOfMethod)
                )
                else
                (§
                    if (returnType == int.class)
                    (§
                        gen.invokeStatic(INTEGER_TYPE, intValueOfMethod)
                    )
                    else if (returnType == float.class)
                    (§
                        gen.invokeStatic(FLOAT_TYPE, floatValueOfMethod)
                    )
                    else if (returnType == double.class)
                    (§
                        gen.invokeStatic(DOUBLE_TYPE, doubleValueOfMethod)
                    )
                    else if (returnType == long.class)
                    (§
                        gen.invokeStatic(NUMBERS_TYPE, Method.getMethod("Number num(long)"))
                    )
                    else if (returnType == byte.class)
                    (§
                        gen.invokeStatic(BYTE_TYPE, byteValueOfMethod)
                    )
                    else if (returnType == short.class)
                    (§
                        gen.invokeStatic(SHORT_TYPE, shortValueOfMethod)
                    )
                )
            )
        )

        public static void emitUnboxArg(ObjExpr objx, GeneratorAdapter gen, Class paramType)
        (§
            if (paramType.isPrimitive())
            (§
                if (paramType == boolean.class)
                (§
                    gen.checkCast(BOOLEAN_TYPE)
                    gen.invokeVirtual(BOOLEAN_TYPE, booleanValueMethod)
                )
                else if (paramType == char.class)
                (§
                    gen.checkCast(CHAR_TYPE)
                    gen.invokeVirtual(CHAR_TYPE, charValueMethod)
                )
                else
                (§
                    Method m = nil
                    gen.checkCast(NUMBER_TYPE)
                    if (RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                    (§
                        if (paramType == int.class)
                        (§
                            m = Method.getMethod("int uncheckedIntCast(Object)")
                        )
                        else if (paramType == float.class)
                        (§
                            m = Method.getMethod("float uncheckedFloatCast(Object)")
                        )
                        else if (paramType == double.class)
                        (§
                            m = Method.getMethod("double uncheckedDoubleCast(Object)")
                        )
                        else if (paramType == long.class)
                        (§
                            m = Method.getMethod("long uncheckedLongCast(Object)")
                        )
                        else if (paramType == byte.class)
                        (§
                            m = Method.getMethod("byte uncheckedByteCast(Object)")
                        )
                        else if (paramType == short.class)
                        (§
                            m = Method.getMethod("short uncheckedShortCast(Object)")
                        )
                    )
                    else
                    (§
                        if (paramType == int.class)
                        (§
                            m = Method.getMethod("int intCast(Object)")
                        )
                        else if (paramType == float.class)
                        (§
                            m = Method.getMethod("float floatCast(Object)")
                        )
                        else if (paramType == double.class)
                        (§
                            m = Method.getMethod("double doubleCast(Object)")
                        )
                        else if (paramType == long.class)
                        (§
                            m = Method.getMethod("long longCast(Object)")
                        )
                        else if (paramType == byte.class)
                        (§
                            m = Method.getMethod("byte byteCast(Object)")
                        )
                        else if (paramType == short.class)
                        (§
                            m = Method.getMethod("short shortCast(Object)")
                        )
                    )
                    gen.invokeStatic(RT_TYPE, m)
                )
            )
            else
            (§
                gen.checkCast(Type.getType(paramType))
            )
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                ;; (. x fieldname-sym) or
                ;; (. x 0-ary-method)
                ;; (. x methodname-sym args+)
                ;; (. x (methodname-sym args?))
                if (RT.length(form) < 3)
                (§
                    throw new IllegalArgumentException("Malformed member expression, expecting (. target member ...)")
                )
                ;; determine static or instance
                ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                int line = lineDeref()
                int column = columnDeref()
                String source = (String) SOURCE.deref()
                Class c = maybeClass(RT.second(form), false)
                ;; at this point c will be non-null if static
                Expr instance = nil
                if (c == nil)
                (§
                    instance = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form))
                )

                boolean maybeField = (RT.length(form) == 3) && (RT.third(form) instanceof Symbol)

                if (maybeField && !(((Symbol)RT.third(form)).name.charAt(0) == \-))
                (§
                    Symbol sym = (Symbol) RT.third(form)
                    if (c != nil)
                    (§
                        maybeField = Reflector.getMethods(c, 0, munge(sym.name), true).size() == 0
                    )
                    else if (instance != nil && instance.hasJavaClass() && instance.getJavaClass() != nil)
                    (§
                        maybeField = Reflector.getMethods(instance.getJavaClass(), 0, munge(sym.name), false).size() == 0
                    )
                )

                if (maybeField) ;; field
                (§
                    Symbol sym = (((Symbol)RT.third(form)).name.charAt(0) == \-) ? Symbol.intern(((Symbol)RT.third(form)).name.substring(1)) :or (Symbol) RT.third(form)
                    Symbol tag = tagOf(form)
                    if (c != nil)
                    (§
                        (§ return (§ expr new StaticFieldExpr(line, column, c, munge(sym.name), tag)))
                    )
                    else
                    (§
                        (§ return (§ expr new InstanceFieldExpr(line, column, instance, munge(sym.name), tag, (((Symbol)RT.third(form)).name.charAt(0) == \-))))
                    )
                )
                else
                (§
                    ISeq call = (ISeq) ((RT.third(form) instanceof ISeq) ? RT.third(form) :or RT.next(RT.next(form)))
                    if (!(RT.first(call) instanceof Symbol))
                    (§
                        throw new IllegalArgumentException("Malformed member expression")
                    )
                    Symbol sym = (Symbol) RT.first(call)
                    Symbol tag = tagOf(form)
                    PersistentVector args = PersistentVector.EMPTY
                    boolean tailPosition = inTailCall(context)
                    for (ISeq s = RT.next(call) s != nil s = s.next())
                    (§
                        args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first()))
                    )
                    if (c != nil)
                    (§
                        (§ return (§ expr new StaticMethodExpr(source, line, column, tag, c, munge(sym.name), args, tailPosition)))
                    )
                    else
                    (§
                        (§ return (§ expr new InstanceMethodExpr(source, line, column, tag, instance, munge(sym.name), args, tailPosition)))
                    )
                )
            )
        )

        public static Class maybeClass(Object form, boolean stringOk)
        (§
            if (form instanceof Class)
            (§
                (§ return (§ expr (Class) form))
            )
            Class c = nil
            if (form instanceof Symbol)
            (§
                Symbol sym = (Symbol) form
                if (sym.ns == nil) ;; if ns-qualified can't be classname
                (§
                    if (Util.equals(sym, COMPILE_STUB_SYM.get()))
                    (§
                        (§ return (§ expr (Class) COMPILE_STUB_CLASS.get()))
                    )
                    if (sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
                    (§
                        c = RT.classForNameNonLoading(sym.name)
                    )
                    else
                    (§
                        Object o = currentNS().getMapping(sym)
                        if (o instanceof Class)
                        (§
                            c = (Class) o
                        )
                        else if (LOCAL_ENV.deref() != nil && ((java.util.Map)LOCAL_ENV.deref()).containsKey(form))
                        (§
                            (§ return (§ expr nil))
                        )
                        else
                        (§
                            try
                            (§
                                c = RT.classForNameNonLoading(sym.name)
                            )
                            catch (Exception e)
                            (§
                                ;; aargh
                                ;; leave c set to nil -> return nil
                            )
                        )
                    )
                )
            )
            else if (stringOk && form instanceof String)
            (§
                c = RT.classForNameNonLoading((String) form)
            )
            (§ return (§ expr c))
        )

        public static Class maybeSpecialTag(Symbol sym)
        (§
            Class c = primClass(sym)
            if (c != nil)
            (§
                (§ return (§ expr c))
            )
            else if (sym.name.equals("objects"))
            (§
                c = Object[].class
            )
            else if (sym.name.equals("ints"))
            (§
                c = int[].class
            )
            else if (sym.name.equals("longs"))
            (§
                c = long[].class
            )
            else if (sym.name.equals("floats"))
            (§
                c = float[].class
            )
            else if (sym.name.equals("doubles"))
            (§
                c = double[].class
            )
            else if (sym.name.equals("chars"))
            (§
                c = char[].class
            )
            else if (sym.name.equals("shorts"))
            (§
                c = short[].class
            )
            else if (sym.name.equals("bytes"))
            (§
                c = byte[].class
            )
            else if (sym.name.equals("booleans"))
            (§
                c = boolean[].class
            )
            (§ return (§ expr c))
        )

        static Class tagToClass(Object tag)
        (§
            Class c = nil
            if (tag instanceof Symbol)
            (§
                Symbol sym = (Symbol) tag
                if (sym.ns == nil) ;; if ns-qualified can't be classname
                (§
                    c = maybeSpecialTag(sym)
                )
            )
            if (c == nil)
            (§
                c = maybeClass(tag, true)
            )
            if (c != nil)
            (§
                (§ return (§ expr c))
            )
            throw new IllegalArgumentException("Unable to resolve classname: " + tag)
        )
    )

    static abstract class FieldExpr extends HostExpr
    (§
    )

    static class InstanceFieldExpr extends FieldExpr implements AssignableExpr
    (§
        public final Expr target
        public final Class targetClass
        public final java.lang.reflect.Field field
        public final String fieldName
        public final int line
        public final int column
        public final Symbol tag
        public final boolean requireField

        final static Method invokeNoArgInstanceMember = Method.getMethod("Object invokeNoArgInstanceMember(Object,String,boolean)")
        final static Method setInstanceFieldMethod = Method.getMethod("Object setInstanceField(Object,String,Object)")

        Class jc

        public InstanceFieldExpr(int line, int column, Expr target, String fieldName, Symbol tag, boolean requireField)
        (§
            this.target = target
            this.targetClass = target.hasJavaClass() ? target.getJavaClass() :or nil
            this.field = (targetClass != nil) ? Reflector.getField(targetClass, fieldName, false) :or nil
            this.fieldName = fieldName
            this.line = line
            this.column = column
            this.tag = tag
            this.requireField = requireField

            if (field == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
            (§
                if (targetClass == nil)
                (§
                    RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName)
                )
                else
                (§
                    RT.errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", SOURCE_PATH.deref(), line, column, fieldName, targetClass.getName())
                )
            )
        )

        public Object eval()
        (§
            (§ return (§ expr Reflector.invokeNoArgInstanceMember(target.eval(), fieldName, requireField)))
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr (targetClass != nil && field != nil && Util.isPrimitive(field.getType()))))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (targetClass != nil && field != nil)
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.checkCast(getType(targetClass))
                gen.getField(getType(targetClass), fieldName, Type.getType(field.getType()))
            )
            else
            (§
                throw new UnsupportedOperationException("Unboxed emit of unknown member")
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (targetClass != nil && field != nil)
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.checkCast(getType(targetClass))
                gen.getField(getType(targetClass), fieldName, Type.getType(field.getType()))
                HostExpr.emitBoxReturn(objx, gen, field.getType())
                if (context == C.STATEMENT)
                (§
                    gen.pop()
                )
            )
            else
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.push(fieldName)
                gen.push(requireField)
                gen.invokeStatic(REFLECTOR_TYPE, invokeNoArgInstanceMember)
                if (context == C.STATEMENT)
                (§
                    gen.pop()
                )
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (field != nil || tag != nil)))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType()
            )
            (§ return (§ expr jc))
        )

        public Object evalAssign(Expr val)
        (§
            (§ return (§ expr Reflector.setInstanceField(target.eval(), fieldName, val.eval())))
        )

        public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
        (§
            if (targetClass != nil && field != nil)
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.checkCast(getType(targetClass))
                val.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.dupX1()
                HostExpr.emitUnboxArg(objx, gen, field.getType())
                gen.putField(getType(targetClass), fieldName, Type.getType(field.getType()))
            )
            else
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.push(fieldName)
                val.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.invokeStatic(REFLECTOR_TYPE, setInstanceFieldMethod)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )
    )

    static class StaticFieldExpr extends FieldExpr implements AssignableExpr
    (§
        public final String fieldName
        public final Class c
        public final java.lang.reflect.Field field
        public final Symbol tag

        final int line
        final int column

        Class jc

        public StaticFieldExpr(int line, int column, Class c, String fieldName, Symbol tag)
        (§
            this.fieldName = fieldName
            this.line = line
            this.column = column
            this.c = c
            try
            (§
                field = c.getField(fieldName)
            )
            catch (NoSuchFieldException e)
            (§
                throw Util.sneakyThrow(e)
            )
            this.tag = tag
        )

        public Object eval()
        (§
            (§ return (§ expr Reflector.getStaticField(c, fieldName)))
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr Util.isPrimitive(field.getType())))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.visitLineNumber(line, gen.mark())
            gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType()))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.visitLineNumber(line, gen.mark())

            gen.getStatic(Type.getType(c), fieldName, Type.getType(field.getType()))
            HostExpr.emitBoxReturn(objx, gen, field.getType())
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = (tag != nil) ? HostExpr.tagToClass(tag) :or field.getType()
            )
            (§ return (§ expr jc))
        )

        public Object evalAssign(Expr val)
        (§
            (§ return (§ expr Reflector.setStaticField(c, fieldName, val.eval())))
        )

        public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
        (§
            val.emit(C.EXPRESSION, objx, gen)
            gen.visitLineNumber(line, gen.mark())
            gen.dup()
            HostExpr.emitUnboxArg(objx, gen, field.getType())
            gen.putStatic(Type.getType(c), fieldName, Type.getType(field.getType()))
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )
    )

    static Class maybePrimitiveType(Expr e)
    (§
        if (e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive())
        (§
            Class c = e.getJavaClass()
            if (Util.isPrimitive(c))
            (§
                (§ return (§ expr c))
            )
        )
        (§ return (§ expr nil))
    )

    static Class maybeJavaClass(Collection<Expr> exprs)
    (§
        Class match = nil
        try
        (§
            for (Expr e :in exprs)
            (§
                if (e instanceof ThrowExpr)
                (§
                    continue
                )
                if (!e.hasJavaClass())
                (§
                    (§ return (§ expr nil))
                )
                Class c = e.getJavaClass()
                if (match == nil)
                (§
                    match = c
                )
                else if (match != c)
                (§
                    (§ return (§ expr nil))
                )
            )
        )
        catch (Exception e)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr match))
    )

    static abstract class MethodExpr extends HostExpr
    (§
        static void emitArgsAsArray(IPersistentVector args, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.push(args.count())
            gen.newArray(OBJECT_TYPE)
            for (int i = 0 i < args.count() i++)
            (§
                gen.dup()
                gen.push(i)
                ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen)
                gen.arrayStore(OBJECT_TYPE)
            )
        )

        public static void emitTypedArgs(ObjExpr objx, GeneratorAdapter gen, Class[] parameterTypes, IPersistentVector args)
        (§
            for (int i = 0 i < parameterTypes.length i++)
            (§
                Expr e = (Expr) args.nth(i)
                try
                (§
                    final Class primc = maybePrimitiveType(e)
                    if (primc == parameterTypes[i])
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                    )
                    else if (primc == int.class && parameterTypes[i] == long.class)
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(I2L)
                    )
                    else if (primc == long.class && parameterTypes[i] == int.class)
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                        if (RT.booleanCast(RT.UNCHECKED_MATH.deref()))
                        (§
                            gen.invokeStatic(RT_TYPE, Method.getMethod("int uncheckedIntCast(long)"))
                        )
                        else
                        (§
                            gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)"))
                        )
                    )
                    else if (primc == float.class && parameterTypes[i] == double.class)
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(F2D)
                    )
                    else if (primc == double.class && parameterTypes[i] == float.class)
                    (§
                        final MaybePrimitiveExpr pe = (MaybePrimitiveExpr) e
                        pe.emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(D2F)
                    )
                    else
                    (§
                        e.emit(C.EXPRESSION, objx, gen)
                        HostExpr.emitUnboxArg(objx, gen, parameterTypes[i])
                    )
                )
                catch (Exception e1)
                (§
                    throw Util.sneakyThrow(e1)
                )
            )
        )
    )

    static class InstanceMethodExpr extends MethodExpr
    (§
        public final Expr target
        public final String methodName
        public final IPersistentVector args
        public final String source
        public final int line
        public final int column
        public final Symbol tag
        public final boolean tailPosition
        public final java.lang.reflect.Method method

        Class jc

        final static Method invokeInstanceMethodMethod = Method.getMethod("Object invokeInstanceMethod(Object,String,Object[])")

        public InstanceMethodExpr(String source, int line, int column, Symbol tag, Expr target, String methodName, IPersistentVector args, boolean tailPosition)
        (§
            this.source = source
            this.line = line
            this.column = column
            this.args = args
            this.methodName = methodName
            this.target = target
            this.tag = tag
            this.tailPosition = tailPosition
            if (target.hasJavaClass() && target.getJavaClass() != nil)
            (§
                List methods = Reflector.getMethods(target.getJavaClass(), args.count(), methodName, false)
                if (methods.isEmpty())
                (§
                    method = nil
                    if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (§
                        RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName())
                    )
                )
                else
                (§
                    int methodidx = 0
                    if (methods.size() > 1)
                    (§
                        ArrayList<Class[]> params = new ArrayList()
                        ArrayList<Class> rets = new ArrayList()
                        for (int i = 0 i < methods.size() i++)
                        (§
                            java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i)
                            params.add(m.getParameterTypes())
                            rets.add(m.getReturnType())
                        )
                        methodidx = getMatchingParams(methodName, params, args, rets)
                    )
                    java.lang.reflect.Method m = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil)
                    if (m != nil && !Modifier.isPublic(m.getDeclaringClass().getModifiers()))
                    (§
                        ;; public method of non-public class, try to find it in hierarchy
                        m = Reflector.getAsMethodOfPublicBase(m.getDeclaringClass(), m)
                    )
                    method = m
                    if (method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                    (§
                        RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, target.getJavaClass().getName(), getTypeStringForArgs(args))
                    )
                )
            )
            else
            (§
                method = nil
                if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (§
                    RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", SOURCE_PATH.deref(), line, column, methodName)
                )
            )
        )

        public Object eval()
        (§
            try
            (§
                Object targetval = target.eval()
                Object[] argvals = new Object[args.count()]
                for (int i = 0 i < args.count() i++)
                (§
                    argvals[i] = ((Expr) args.nth(i)).eval()
                )
                if (method != nil)
                (§
                    LinkedList ms = new LinkedList()
                    ms.add(method)
                    (§ return (§ expr Reflector.invokeMatchingMethod(methodName, ms, targetval, argvals)))
                )
                (§ return (§ expr Reflector.invokeInstanceMethod(targetval, methodName, argvals)))
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr (method != nil && Util.isPrimitive(method.getReturnType()))))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (method != nil)
            (§
                Type type = Type.getType(method.getDeclaringClass())
                target.emit(C.EXPRESSION, objx, gen)
                gen.checkCast(type)
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                gen.visitLineNumber(line, gen.mark())
                if (tailPosition && !objx.canBeDirect)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearThis(gen)
                )
                Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method))
                if (method.getDeclaringClass().isInterface())
                (§
                    gen.invokeInterface(type, m)
                )
                else
                (§
                    gen.invokeVirtual(type, m)
                )
            )
            else
            (§
                throw new UnsupportedOperationException("Unboxed emit of unknown member")
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (method != nil)
            (§
                Type type = Type.getType(method.getDeclaringClass())
                target.emit(C.EXPRESSION, objx, gen)
                gen.checkCast(type)
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                gen.visitLineNumber(line, gen.mark())
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method))
                if (method.getDeclaringClass().isInterface())
                (§
                    gen.invokeInterface(type, m)
                )
                else
                (§
                    gen.invokeVirtual(type, m)
                )
                HostExpr.emitBoxReturn(objx, gen, method.getReturnType())
            )
            else
            (§
                target.emit(C.EXPRESSION, objx, gen)
                gen.push(methodName)
                emitArgsAsArray(args, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                gen.invokeStatic(REFLECTOR_TYPE, invokeInstanceMethodMethod)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (method != nil || tag != nil)))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil)
            )
            (§ return (§ expr jc))
        )
    )

    static class StaticMethodExpr extends MethodExpr
    (§
        public final Class c
        public final String methodName
        public final IPersistentVector args
        public final String source
        public final int line
        public final int column
        public final java.lang.reflect.Method method
        public final Symbol tag
        public final boolean tailPosition

        final static Method forNameMethod = Method.getMethod("Class classForName(String)")
        final static Method invokeStaticMethodMethod = Method.getMethod("Object invokeStaticMethod(Class,String,Object[])")
        final static Keyword warnOnBoxedKeyword = Keyword.intern("warn-on-boxed")

        Class jc

        public StaticMethodExpr(String source, int line, int column, Symbol tag, Class c, String methodName, IPersistentVector args, boolean tailPosition)
        (§
            this.c = c
            this.methodName = methodName
            this.args = args
            this.source = source
            this.line = line
            this.column = column
            this.tag = tag
            this.tailPosition = tailPosition

            List methods = Reflector.getMethods(c, args.count(), methodName, true)
            if (methods.isEmpty())
            (§
                throw new IllegalArgumentException("No matching method: " + methodName)
            )

            int methodidx = 0
            if (methods.size() > 1)
            (§
                ArrayList<Class[]> params = new ArrayList()
                ArrayList<Class> rets = new ArrayList()
                for (int i = 0 i < methods.size() i++)
                (§
                    java.lang.reflect.Method m = (java.lang.reflect.Method) methods.get(i)
                    params.add(m.getParameterTypes())
                    rets.add(m.getReturnType())
                )
                methodidx = getMatchingParams(methodName, params, args, rets)
            )
            method = (java.lang.reflect.Method) ((methodidx >= 0) ? methods.get(methodidx) :or nil)
            if (method == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
            (§
                RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", SOURCE_PATH.deref(), line, column, methodName, c.getName(), getTypeStringForArgs(args))
            )
            if (method != nil && warnOnBoxedKeyword.equals(RT.UNCHECKED_MATH.deref()) && isBoxedMath(method))
            (§
                RT.errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", SOURCE_PATH.deref(), line, column, method.toString())
            )
        )

        public static boolean isBoxedMath(java.lang.reflect.Method m)
        (§
            Class c = m.getDeclaringClass()
            if (c.equals(Numbers.class))
            (§
                WarnBoxedMath boxedMath = m.getAnnotation(WarnBoxedMath.class)
                if (boxedMath != nil)
                (§
                    (§ return (§ expr boxedMath.value()))
                )

                Class[] argTypes = m.getParameterTypes()
                for (Class argType :in argTypes)
                (§
                    if (argType.equals(Object.class) || argType.equals(Number.class))
                    (§
                        (§ return (§ expr true))
                    )
                )
            )
            (§ return (§ expr false))
        )

        public Object eval()
        (§
            try
            (§
                Object[] argvals = new Object[args.count()]
                for (int i = 0 i < args.count() i++)
                (§
                    argvals[i] = ((Expr) args.nth(i)).eval()
                )
                if (method != nil)
                (§
                    LinkedList ms = new LinkedList()
                    ms.add(method)
                    (§ return (§ expr Reflector.invokeMatchingMethod(methodName, ms, nil, argvals)))
                )
                (§ return (§ expr Reflector.invokeStaticMethod(c, methodName, argvals)))
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr (method != nil && Util.isPrimitive(method.getReturnType()))))
        )

        public boolean canEmitIntrinsicPredicate()
        (§
            (§ return (§ expr (method != nil && RT.get(Intrinsics.preds, method.toString()) != nil)))
        )

        public void emitIntrinsicPredicate(C context, ObjExpr objx, GeneratorAdapter gen, Label falseLabel)
        (§
            gen.visitLineNumber(line, gen.mark())
            if (method != nil)
            (§
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                Object[] predOps = (Object[]) RT.get(Intrinsics.preds, method.toString())
                for (int i = 0 i < predOps.length - 1 i++)
                (§
                    gen.visitInsn((Integer)predOps[i])
                )
                gen.visitJumpInsn((Integer)predOps[predOps.length - 1], falseLabel)
            )
            else
            (§
                throw new UnsupportedOperationException("Unboxed emit of unknown member")
            )
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (method != nil)
            (§
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                gen.visitLineNumber(line, gen.mark())
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                Object ops = RT.get(Intrinsics.ops, method.toString())
                if (ops != nil)
                (§
                    if (ops instanceof Object[])
                    (§
                        for (Object op :in (Object[])ops)
                        (§
                            gen.visitInsn((Integer) op)
                        )
                    )
                    else
                    (§
                        gen.visitInsn((Integer) ops)
                    )
                )
                else
                (§
                    Type type = Type.getType(c)
                    Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method))
                    gen.invokeStatic(type, m)
                )
            )
            else
            (§
                throw new UnsupportedOperationException("Unboxed emit of unknown member")
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (method != nil)
            (§
                MethodExpr.emitTypedArgs(objx, gen, method.getParameterTypes(), args)
                gen.visitLineNumber(line, gen.mark())
                if (tailPosition && !objx.canBeDirect)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearThis(gen)
                )
                Type type = Type.getType(c)
                Method m = new Method(methodName, Type.getReturnType(method), Type.getArgumentTypes(method))
                gen.invokeStatic(type, m)
                Class retClass = method.getReturnType()
                if (context == C.STATEMENT)
                (§
                    if (retClass == long.class || retClass == double.class)
                    (§
                        gen.pop2()
                    )
                    else if (retClass != void.class)
                    (§
                        gen.pop()
                    )
                )
                else
                (§
                    HostExpr.emitBoxReturn(objx, gen, method.getReturnType())
                )
            )
            else
            (§
                gen.visitLineNumber(line, gen.mark())
                gen.push(c.getName())
                gen.invokeStatic(RT_TYPE, forNameMethod)
                gen.push(methodName)
                emitArgsAsArray(args, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                gen.invokeStatic(REFLECTOR_TYPE, invokeStaticMethodMethod)
                if (context == C.STATEMENT)
                (§
                    gen.pop()
                )
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (method != nil || tag != nil)))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, (method != nil) ? method.getReturnType() :or nil)
            )
            (§ return (§ expr jc))
        )
    )

    static class UnresolvedVarExpr implements Expr
    (§
        public final Symbol symbol

        public UnresolvedVarExpr(Symbol symbol)
        (§
            this.symbol = symbol
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr false))
        )

        public Class getJavaClass()
        (§
            throw new IllegalArgumentException("UnresolvedVarExpr has no Java class")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
        )

        public Object eval()
        (§
            throw new IllegalArgumentException("UnresolvedVarExpr cannot be evalled")
        )
    )

    static class NumberExpr extends LiteralExpr implements MaybePrimitiveExpr
    (§
        final Number n
        public final int id

        public NumberExpr(Number n)
        (§
            this.n = n
            this.id = registerConstant(n)
        )

        Object val()
        (§
            (§ return (§ expr n))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (context != C.STATEMENT)
            (§
                objx.emitConstant(gen, id)
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            if (n instanceof Integer)
            (§
                (§ return (§ expr long.class))
            )
            else if (n instanceof Double)
            (§
                (§ return (§ expr double.class))
            )
            else if (n instanceof Long)
            (§
                (§ return (§ expr long.class))
            )
            else
            (§
                throw new IllegalStateException("Unsupported Number type: " + n.getClass().getName())
            )
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr true))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (n instanceof Integer)
            (§
                gen.push(n.longValue())
            )
            else if (n instanceof Double)
            (§
                gen.push(n.doubleValue())
            )
            else if (n instanceof Long)
            (§
                gen.push(n.longValue())
            )
        )

        static public Expr parse(Number form)
        (§
            if (form instanceof Integer || form instanceof Double || form instanceof Long)
            (§
                (§ return (§ expr new NumberExpr(form)))
            )
            else
            (§
                (§ return (§ expr new ConstantExpr(form)))
            )
        )
    )

    static class ConstantExpr extends LiteralExpr
    (§
        ;; stuff quoted vals in classloader at compile time, pull out at runtime
        ;; this won't work for static compilation...
        public final Object v
        public final int id

        public ConstantExpr(Object v)
        (§
            this.v = v
            this.id = registerConstant(v)
        )

        Object val()
        (§
            (§ return (§ expr v))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitConstant(gen, id)

            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr Modifier.isPublic(v.getClass().getModifiers())))
        )

        public Class getJavaClass()
        (§
            if (v instanceof APersistentMap)
            (§
                (§ return (§ expr APersistentMap.class))
            )
            else if (v instanceof APersistentSet)
            (§
                (§ return (§ expr APersistentSet.class))
            )
            else if (v instanceof APersistentVector)
            (§
                (§ return (§ expr APersistentVector.class))
            )
            else
            (§
                (§ return (§ expr v.getClass()))
            )
        )

        static class Parser implements IParser
        (§
            static Keyword formKey = Keyword.intern("form")

            public Expr parse(C context, Object form)
            (§
                int argCount = RT.count(form) - 1
                if (argCount != 1)
                (§
                    IPersistentMap exData = new PersistentArrayMap(new Object[] (§ formKey, form ))
                    throw new ExceptionInfo("Wrong number of args (" + argCount + ") passed to quote", exData)
                )
                Object v = RT.second(form)

                if (v == nil)
                (§
                    (§ return (§ expr NIL_EXPR))
                )
                else if (v == Boolean.TRUE)
                (§
                    (§ return (§ expr TRUE_EXPR))
                )
                else if (v == Boolean.FALSE)
                (§
                    (§ return (§ expr FALSE_EXPR))
                )
                if (v instanceof Number)
                (§
                    (§ return (§ expr NumberExpr.parse((Number)v)))
                )
                else if (v instanceof String)
                (§
                    (§ return (§ expr new StringExpr((String) v)))
                )
                else if (v instanceof IPersistentCollection && ((IPersistentCollection) v).count() == 0)
                (§
                    (§ return (§ expr new EmptyExpr(v)))
                )
                else
                (§
                    (§ return (§ expr new ConstantExpr(v)))
                )
            )
        )
    )

    static class NilExpr extends LiteralExpr
    (§
        Object val()
        (§
            (§ return (§ expr nil))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            gen.visitInsn(Opcodes.ACONST_NULL)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr nil))
        )
    )

    final static NilExpr NIL_EXPR = new NilExpr()

    static class BooleanExpr extends LiteralExpr
    (§
        public final boolean val

        public BooleanExpr(boolean val)
        (§
            this.val = val
        )

        Object val()
        (§
            (§ return (§ expr val ? RT.T :or RT.F))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (val)
            (§
                gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE)
            )
            else
            (§
                gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr Boolean.class))
        )
    )

    final static BooleanExpr TRUE_EXPR = new BooleanExpr(true)
    final static BooleanExpr FALSE_EXPR = new BooleanExpr(false)

    static class StringExpr extends LiteralExpr
    (§
        public final String str

        public StringExpr(String str)
        (§
            this.str = str
        )

        Object val()
        (§
            (§ return (§ expr str))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (context != C.STATEMENT)
            (§
                gen.push(str)
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr String.class))
        )
    )

    static class MonitorEnterExpr extends UntypedExpr
    (§
        final Expr target

        public MonitorEnterExpr(Expr target)
        (§
            this.target = target
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval monitor-enter")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            target.emit(C.EXPRESSION, objx, gen)
            gen.monitorEnter()
            NIL_EXPR.emit(context, objx, gen)
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                (§ return (§ expr new MonitorEnterExpr(analyze(C.EXPRESSION, RT.second(form)))))
            )
        )
    )

    static class MonitorExitExpr extends UntypedExpr
    (§
        final Expr target

        public MonitorExitExpr(Expr target)
        (§
            this.target = target
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval monitor-exit")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            target.emit(C.EXPRESSION, objx, gen)
            gen.monitorExit()
            NIL_EXPR.emit(context, objx, gen)
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                (§ return (§ expr new MonitorExitExpr(analyze(C.EXPRESSION, RT.second(form)))))
            )
        )
    )

    public static class TryExpr implements Expr
    (§
        public final Expr tryExpr
        public final Expr finallyExpr
        public final PersistentVector catchExprs
        public final int retLocal
        public final int finallyLocal

        public static class CatchClause
        (§
            public final Class c
            public final LocalBinding lb
            public final Expr handler
            Label label
            Label endLabel

            public CatchClause(Class c, LocalBinding lb, Expr handler)
            (§
                this.c = c
                this.lb = lb
                this.handler = handler
            )
        )

        public TryExpr(Expr tryExpr, PersistentVector catchExprs, Expr finallyExpr, int retLocal, int finallyLocal)
        (§
            this.tryExpr = tryExpr
            this.catchExprs = catchExprs
            this.finallyExpr = finallyExpr
            this.retLocal = retLocal
            this.finallyLocal = finallyLocal
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval try")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Label startTry = gen.newLabel()
            Label endTry = gen.newLabel()
            Label end = gen.newLabel()
            Label ret = gen.newLabel()
            Label finallyLabel = gen.newLabel()
            for (int i = 0 i < catchExprs.count() i++)
            (§
                CatchClause clause = (CatchClause) catchExprs.nth(i)
                clause.label = gen.newLabel()
                clause.endLabel = gen.newLabel()
            )

            gen.mark(startTry)
            tryExpr.emit(context, objx, gen)
            if (context != C.STATEMENT)
            (§
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal)
            )
            gen.mark(endTry)
            if (finallyExpr != nil)
            (§
                finallyExpr.emit(C.STATEMENT, objx, gen)
            )
            gen.goTo(ret)

            for (int i = 0 i < catchExprs.count() i++)
            (§
                CatchClause clause = (CatchClause) catchExprs.nth(i)
                gen.mark(clause.label)
                ;; exception should be on stack
                ;; put in clause local
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), clause.lb.idx)
                clause.handler.emit(context, objx, gen)
                if (context != C.STATEMENT)
                (§
                    gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), retLocal)
                )
                gen.mark(clause.endLabel)

                if (finallyExpr != nil)
                (§
                    finallyExpr.emit(C.STATEMENT, objx, gen)
                )
                gen.goTo(ret)
            )
            if (finallyExpr != nil)
            (§
                gen.mark(finallyLabel)
                ;; exception should be on stack
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), finallyLocal)
                finallyExpr.emit(C.STATEMENT, objx, gen)
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), finallyLocal)
                gen.throwException()
            )
            gen.mark(ret)
            if (context != C.STATEMENT)
            (§
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), retLocal)
            )
            gen.mark(end)
            for (int i = 0 i < catchExprs.count() i++)
            (§
                CatchClause clause = (CatchClause) catchExprs.nth(i)
                gen.visitTryCatchBlock(startTry, endTry, clause.label, clause.c.getName().replace(\., \/))
            )
            if (finallyExpr != nil)
            (§
                gen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil)
                for (int i = 0 i < catchExprs.count() i++)
                (§
                    CatchClause clause = (CatchClause) catchExprs.nth(i)
                    gen.visitTryCatchBlock(clause.label, clause.endLabel, finallyLabel, nil)
                )
            )
            for (int i = 0 i < catchExprs.count() i++)
            (§
                CatchClause clause = (CatchClause) catchExprs.nth(i)
                gen.visitLocalVariable(clause.lb.name, "Ljava/lang/Object;", nil, clause.label, clause.endLabel, clause.lb.idx)
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr tryExpr.hasJavaClass()))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr tryExpr.getJavaClass()))
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                if (context != C.RETURN)
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                ;; (try try-expr* catch-expr* finally-expr?)
                ;; catch-expr: (catch class sym expr*)
                ;; finally-expr: (finally expr*)

                PersistentVector body = PersistentVector.EMPTY
                PersistentVector catches = PersistentVector.EMPTY
                Expr bodyExpr = nil
                Expr finallyExpr = nil
                boolean caught = false

                int retLocal = getAndIncLocalNum()
                int finallyLocal = getAndIncLocalNum()
                for (ISeq fs = form.next() fs != nil fs = fs.next())
                (§
                    Object f = fs.first()
                    Object op = (f instanceof ISeq) ? ((ISeq) f).first() :or nil
                    if (!Util.equals(op, CATCH) && !Util.equals(op, FINALLY))
                    (§
                        if (caught)
                        (§
                            throw Util.runtimeException("Only catch or finally clause can follow catch in try expression")
                        )
                        body = body.cons(f)
                    )
                    else
                    (§
                        if (bodyExpr == nil)
                        (§
                            try
                            (§
                                Var.pushThreadBindings(RT.map(NO_RECUR, true, METHOD_RETURN_CONTEXT, nil))
                                bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body))
                            )
                            finally
                            (§
                                Var.popThreadBindings()
                            )
                        )

                        if (Util.equals(op, CATCH))
                        (§
                            Class c = HostExpr.maybeClass(RT.second(f), false)
                            if (c == nil)
                            (§
                                throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(f))
                            )
                            if (!(RT.third(f) instanceof Symbol))
                            (§
                                throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + RT.third(f))
                            )
                            Symbol sym = (Symbol) RT.third(f)
                            if (sym.getNamespace() != nil)
                            (§
                                throw Util.runtimeException("Can't bind qualified name:" + sym)
                            )

                            IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref(), IN_CATCH_FINALLY, RT.T)
                            try
                            (§
                                Var.pushThreadBindings(dynamicBindings)
                                LocalBinding lb = registerLocal(sym, (Symbol) ((RT.second(f) instanceof Symbol) ? RT.second(f) :or nil), nil, false)
                                Expr handler = (new BodyExpr.Parser()).parse(C.EXPRESSION, RT.next(RT.next(RT.next(f))))
                                catches = catches.cons(new CatchClause(c, lb, handler))
                            )
                            finally
                            (§
                                Var.popThreadBindings()
                            )
                            caught = true
                        )
                        else ;; finally
                        (§
                            if (fs.next() != nil)
                            (§
                                throw Util.runtimeException("finally clause must be last in try expression")
                            )
                            try
                            (§
                                Var.pushThreadBindings(RT.map(IN_CATCH_FINALLY, RT.T))
                                finallyExpr = (new BodyExpr.Parser()).parse(C.STATEMENT, RT.next(f))
                            )
                            finally
                            (§
                                Var.popThreadBindings()
                            )
                        )
                    )
                )
                if (bodyExpr == nil)
                (§
                    ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                    ;; return a body expr directly
                    try
                    (§
                        Var.pushThreadBindings(RT.map(NO_RECUR, true))
                        bodyExpr = (new BodyExpr.Parser()).parse(context, RT.seq(body))
                    )
                    finally
                    (§
                        Var.popThreadBindings()
                    )
                    (§ return (§ expr bodyExpr))
                )

                (§ return (§ expr new TryExpr(bodyExpr, catches, finallyExpr, retLocal, finallyLocal)))
            )
        )
    )

    static class ThrowExpr extends UntypedExpr
    (§
        public final Expr excExpr

        public ThrowExpr(Expr excExpr)
        (§
            this.excExpr = excExpr
        )

        public Object eval()
        (§
            throw Util.runtimeException("Can't eval throw")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            excExpr.emit(C.EXPRESSION, objx, gen)
            gen.checkCast(THROWABLE_TYPE)
            gen.throwException()
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object form)
            (§
                if (context == C.EVAL)
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )
                else if (RT.count(form) == 1)
                (§
                    throw Util.runtimeException("Too few arguments to throw, throw expects a single Throwable instance")
                )
                else if (RT.count(form) > 2)
                (§
                    throw Util.runtimeException("Too many arguments to throw, throw expects a single Throwable instance")
                )
                (§ return (§ expr new ThrowExpr(analyze(C.EXPRESSION, RT.second(form)))))
            )
        )
    )

    static public boolean subsumes(Class[] c1, Class[] c2)
    (§
        ;; presumes matching lengths
        Boolean better = false
        for (int i = 0 i < c1.length i++)
        (§
            if (c1[i] != c2[i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
            (§
                if (!c1[i].isPrimitive() && c2[i].isPrimitive() || c2[i].isAssignableFrom(c1[i]))
                (§
                    better = true
                )
                else
                (§
                    (§ return (§ expr false))
                )
            )
        )
        (§ return (§ expr better))
    )

    static String getTypeStringForArgs(IPersistentVector args)
    (§
        StringBuilder sb = new StringBuilder()
        for (int i = 0 i < args.count() i++)
        (§
            Expr arg = (Expr) args.nth(i)
            if (i > 0)
            (§
                sb.append(", ")
            )
            sb.append((arg.hasJavaClass() && arg.getJavaClass() != nil) ? arg.getJavaClass().getName() :or "unknown")
        )
        (§ return (§ expr sb.toString()))
    )

    static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, IPersistentVector argexprs, List<Class> rets)
    (§
        ;; presumes matching lengths
        int matchIdx = -1
        boolean tied = false
        boolean foundExact = false
        for (int i = 0 i < paramlists.size() i++)
        (§
            boolean match = true
            ISeq aseq = argexprs.seq()
            int exact = 0
            for (int p = 0 match && p < argexprs.count() && aseq != nil ++p, aseq = aseq.next())
            (§
                Expr arg = (Expr) aseq.first()
                Class aclass = arg.hasJavaClass() ? arg.getJavaClass() :or Object.class
                Class pclass = paramlists.get(i)[p]
                if (arg.hasJavaClass() && aclass == pclass)
                (§
                    exact++
                )
                else
                (§
                    match = Reflector.paramArgTypeMatch(pclass, aclass)
                )
            )
            if (exact == argexprs.count())
            (§
                if (!foundExact || matchIdx == -1 || rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                (§
                    matchIdx = i
                )
                tied = false
                foundExact = true
            )
            else if (match && !foundExact)
            (§
                if (matchIdx == -1)
                (§
                    matchIdx = i
                )
                else
                (§
                    if (subsumes(paramlists.get(i), paramlists.get(matchIdx)))
                    (§
                        matchIdx = i
                        tied = false
                    )
                    else if (Arrays.equals(paramlists.get(matchIdx), paramlists.get(i)))
                    (§
                        if (rets.get(matchIdx).isAssignableFrom(rets.get(i)))
                        (§
                            matchIdx = i
                        )
                    )
                    else if (!(subsumes(paramlists.get(matchIdx), paramlists.get(i))))
                    (§
                        tied = true
                    )
                )
            )
        )
        if (tied)
        (§
            throw new IllegalArgumentException("More than one matching method found: " + methodName)
        )

        (§ return (§ expr matchIdx))
    )

    public static class NewExpr implements Expr
    (§
        public final IPersistentVector args
        public final Constructor ctor
        public final Class c

        final static Method invokeConstructorMethod = Method.getMethod("Object invokeConstructor(Class,Object[])")
        final static Method forNameMethod = Method.getMethod("Class classForName(String)")

        public NewExpr(Class c, IPersistentVector args, int line, int column)
        (§
            this.args = args
            this.c = c
            Constructor[] allctors = c.getConstructors()
            ArrayList ctors = new ArrayList()
            ArrayList<Class[]> params = new ArrayList()
            ArrayList<Class> rets = new ArrayList()
            for (int i = 0 i < allctors.length i++)
            (§
                Constructor ctor = allctors[i]
                if (ctor.getParameterTypes().length == args.count())
                (§
                    ctors.add(ctor)
                    params.add(ctor.getParameterTypes())
                    rets.add(c)
                )
            )
            if (ctors.isEmpty())
            (§
                throw new IllegalArgumentException("No matching ctor found for " + c)
            )

            int ctoridx = 0
            if (ctors.size() > 1)
            (§
                ctoridx = getMatchingParams(c.getName(), params, args, rets)
            )

            this.ctor = (ctoridx >= 0) ? (Constructor) ctors.get(ctoridx) :or nil
            if (ctor == nil && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
            (§
                RT.errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", SOURCE_PATH.deref(), line, column, c.getName())
            )
        )

        public Object eval()
        (§
            Object[] argvals = new Object[args.count()]
            for (int i = 0 i < args.count() i++)
            (§
                argvals[i] = ((Expr) args.nth(i)).eval()
            )
            if (this.ctor != nil)
            (§
                try
                (§
                    (§ return (§ expr ctor.newInstance(Reflector.boxArgs(ctor.getParameterTypes(), argvals))))
                )
                catch (Exception e)
                (§
                    throw Util.sneakyThrow(e)
                )
            )
            (§ return (§ expr Reflector.invokeConstructor(c, argvals)))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (this.ctor != nil)
            (§
                Type type = getType(c)
                gen.newInstance(type)
                gen.dup()
                MethodExpr.emitTypedArgs(objx, gen, ctor.getParameterTypes(), args)
                gen.invokeConstructor(type, new Method("<init>", Type.getConstructorDescriptor(ctor)))
            )
            else
            (§
                gen.push(destubClassName(c.getName()))
                gen.invokeStatic(RT_TYPE, forNameMethod)
                MethodExpr.emitArgsAsArray(args, objx, gen)
                gen.invokeStatic(REFLECTOR_TYPE, invokeConstructorMethod)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr c))
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                int line = lineDeref()
                int column = columnDeref()
                ISeq form = (ISeq) frm
                ;; (new Classname args...)
                if (form.count() < 2)
                (§
                    throw Util.runtimeException("wrong number of arguments, expecting: (new Classname args...)")
                )
                Class c = HostExpr.maybeClass(RT.second(form), false)
                if (c == nil)
                (§
                    throw new IllegalArgumentException("Unable to resolve classname: " + RT.second(form))
                )
                PersistentVector args = PersistentVector.EMPTY
                for (ISeq s = RT.next(RT.next(form)) s != nil s = s.next())
                (§
                    args = args.cons(analyze((context == C.EVAL) ? context :or C.EXPRESSION, s.first()))
                )
                (§ return (§ expr new NewExpr(c, args, line, column)))
            )
        )
    )

    public static class MetaExpr implements Expr
    (§
        public final Expr expr
        public final Expr meta

        final static Type IOBJ_TYPE = Type.getType(IObj.class)
        final static Method withMetaMethod = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")

        public MetaExpr(Expr expr, Expr meta)
        (§
            this.expr = expr
            this.meta = meta
        )

        public Object eval()
        (§
            (§ return (§ expr ((IObj) expr.eval()).withMeta((IPersistentMap) meta.eval())))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            expr.emit(C.EXPRESSION, objx, gen)
            gen.checkCast(IOBJ_TYPE)
            meta.emit(C.EXPRESSION, objx, gen)
            gen.checkCast(IPERSISTENTMAP_TYPE)
            gen.invokeInterface(IOBJ_TYPE, withMetaMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr expr.hasJavaClass()))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr expr.getJavaClass()))
        )
    )

    public static class IfExpr implements Expr, MaybePrimitiveExpr
    (§
        public final Expr testExpr
        public final Expr thenExpr
        public final Expr elseExpr
        public final int line
        public final int column

        public IfExpr(int line, int column, Expr testExpr, Expr thenExpr, Expr elseExpr)
        (§
            this.testExpr = testExpr
            this.thenExpr = thenExpr
            this.elseExpr = elseExpr
            this.line = line
            this.column = column
        )

        public Object eval()
        (§
            Object t = testExpr.eval()
            if (t != nil && t != Boolean.FALSE)
            (§
                (§ return (§ expr thenExpr.eval()))
            )
            (§ return (§ expr elseExpr.eval()))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, false)
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, true)
        )

        public void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
        (§
            Label nullLabel = gen.newLabel()
            Label falseLabel = gen.newLabel()
            Label endLabel = gen.newLabel()

            gen.visitLineNumber(line, gen.mark())

            if (testExpr instanceof StaticMethodExpr && ((StaticMethodExpr)testExpr).canEmitIntrinsicPredicate())
            (§
                ((StaticMethodExpr) testExpr).emitIntrinsicPredicate(C.EXPRESSION, objx, gen, falseLabel)
            )
            else if (maybePrimitiveType(testExpr) == boolean.class)
            (§
                ((MaybePrimitiveExpr) testExpr).emitUnboxed(C.EXPRESSION, objx, gen)
                gen.ifZCmp(gen.EQ, falseLabel)
            )
            else
            (§
                testExpr.emit(C.EXPRESSION, objx, gen)
                gen.dup()
                gen.ifNull(nullLabel)
                gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE)
                gen.visitJumpInsn(IF_ACMPEQ, falseLabel)
            )
            if (emitUnboxed)
            (§
                ((MaybePrimitiveExpr)thenExpr).emitUnboxed(context, objx, gen)
            )
            else
            (§
                thenExpr.emit(context, objx, gen)
            )
            gen.goTo(endLabel)
            gen.mark(nullLabel)
            gen.pop()
            gen.mark(falseLabel)
            if (emitUnboxed)
            (§
                ((MaybePrimitiveExpr)elseExpr).emitUnboxed(context, objx, gen)
            )
            else
            (§
                elseExpr.emit(context, objx, gen)
            )
            gen.mark(endLabel)
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr thenExpr.hasJavaClass()
                && elseExpr.hasJavaClass()
                && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                    || thenExpr.getJavaClass() == RECUR_CLASS
                    || elseExpr.getJavaClass() == RECUR_CLASS
                    || (thenExpr.getJavaClass() == nil && !elseExpr.getJavaClass().isPrimitive())
                    || (elseExpr.getJavaClass() == nil && !thenExpr.getJavaClass().isPrimitive()))))
        )

        public boolean canEmitPrimitive()
        (§
            try
            (§
                (§ return (§ expr thenExpr instanceof MaybePrimitiveExpr
                    && elseExpr instanceof MaybePrimitiveExpr
                    && (thenExpr.getJavaClass() == elseExpr.getJavaClass()
                            || thenExpr.getJavaClass() == RECUR_CLASS
                            || elseExpr.getJavaClass() == RECUR_CLASS)
                    && ((MaybePrimitiveExpr)thenExpr).canEmitPrimitive()
                    && ((MaybePrimitiveExpr)elseExpr).canEmitPrimitive()))
            )
            catch (Exception e)
            (§
                (§ return (§ expr false))
            )
        )

        public Class getJavaClass()
        (§
            Class thenClass = thenExpr.getJavaClass()
            if (thenClass != nil && thenClass != RECUR_CLASS)
            (§
                (§ return (§ expr thenClass))
            )
            (§ return (§ expr elseExpr.getJavaClass()))
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                ;; (if test then) or (if test then else)
                if (form.count() > 4)
                (§
                    throw Util.runtimeException("Too many arguments to if")
                )
                else if (form.count() < 3)
                (§
                    throw Util.runtimeException("Too few arguments to if")
                )
                PathNode branch = new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get())
                Expr testexpr = analyze((context == C.EVAL) ? context :or C.EXPRESSION, RT.second(form))
                Expr thenexpr, elseexpr
                try
                (§
                    Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch)))
                    thenexpr = analyze(context, RT.third(form))
                )
                finally
                (§
                    Var.popThreadBindings()
                )
                try
                (§
                    Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch)))
                    elseexpr = analyze(context, RT.fourth(form))
                )
                finally
                (§
                    Var.popThreadBindings()
                )
                (§ return (§ expr new IfExpr(lineDeref(), columnDeref(), testexpr, thenexpr, elseexpr)))
            )
        )
    )

    static final public IPersistentMap CHAR_MAP =
        PersistentHashMap.create(
            \-, "_",
            \:, "_COLON_",
            \+, "_PLUS_",
            \>, "_GT_",
            \<, "_LT_",
            \=, "_EQ_",
            \~, "_TILDE_",
            \!, "_BANG_",
            \@, "_CIRCA_",
            \#, "_SHARP_",
            \', "_SINGLEQUOTE_",
            \", "_DOUBLEQUOTE_", ;; oops! "
            \%, "_PERCENT_",
            \^, "_CARET_",
            \&, "_AMPERSAND_",
            \*, "_STAR_",
            \|, "_BAR_",
            \{, "_LBRACE_",
            \}, "_RBRACE_",
            \[, "_LBRACK_",
            \], "_RBRACK_",
            \/, "_SLASH_",
            \\, "_BSLASH_",
            \?, "_QMARK_"
        )

    static final public IPersistentMap DEMUNGE_MAP
    static final public Pattern DEMUNGE_PATTERN

    static
    (§
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        IPersistentMap m = RT.map("$", \/)
        for (ISeq s = RT.seq(CHAR_MAP) s != nil s = s.next())
        (§
            IMapEntry e = (IMapEntry) s.first()
            Character origCh = (Character) e.key()
            String escapeStr = (String) e.val()
            m = m.assoc(escapeStr, origCh)
        )
        DEMUNGE_MAP = m

        ;; DEMUNGE_PATTERN searches for the first of any occurrence of
        ;; the strings that are keys of DEMUNGE_MAP.
        ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
        ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
        ;; as desired.  Sorting string keys of DEMUNGE_MAP from longest to
        ;; shortest ensures correct matching behavior, even if some strings are
        ;; prefixes of others.
        Object[] mungeStrs = RT.toArray(RT.keys(m))
        Arrays.sort(mungeStrs, new Comparator()
        (§
            public int compare(Object s1, Object s2)
            (§
                (§ return (§ expr ((String) s2).length() - ((String) s1).length()))
            )
        ))
        StringBuilder sb = new StringBuilder()
        boolean first = true
        for (Object s :in mungeStrs)
        (§
            String escapeStr = (String) s
            if (!first)
            (§
                sb.append("|")
            )
            first = false
            sb.append("\\Q")
            sb.append(escapeStr)
            sb.append("\\E")
        )
        DEMUNGE_PATTERN = Pattern.compile(sb.toString())
    )

    static public String munge(String name)
    (§
        StringBuilder sb = new StringBuilder()
        for (char c :in name.toCharArray())
        (§
            String sub = (String) CHAR_MAP.valAt(c)
            if (sub != nil)
            (§
                sb.append(sub)
            )
            else
            (§
                sb.append(c)
            )
        )
        (§ return (§ expr sb.toString()))
    )

    static public String demunge(String mungedName)
    (§
        StringBuilder sb = new StringBuilder()
        Matcher m = DEMUNGE_PATTERN.matcher(mungedName)
        int lastMatchEnd = 0
        while (m.find())
        (§
            int start = m.start()
            int end = m.end()
            ;; Keep everything before the match
            sb.append(mungedName.substring(lastMatchEnd, start))
            lastMatchEnd = end
            ;; Replace the match with DEMUNGE_MAP result
            Character origCh = (Character) DEMUNGE_MAP.valAt(m.group())
            sb.append(origCh)
        )
        ;; Keep everything after the last match
        sb.append(mungedName.substring(lastMatchEnd))
        (§ return (§ expr sb.toString()))
    )

    public static class EmptyExpr implements Expr
    (§
        public final Object coll

        final static Type HASHMAP_TYPE = Type.getType(PersistentArrayMap.class)
        final static Type HASHSET_TYPE = Type.getType(PersistentHashSet.class)
        final static Type VECTOR_TYPE = Type.getType(PersistentVector.class)
        final static Type IVECTOR_TYPE = Type.getType(IPersistentVector.class)
        final static Type TUPLE_TYPE = Type.getType(Tuple.class)
        final static Type LIST_TYPE = Type.getType(PersistentList.class)
        final static Type EMPTY_LIST_TYPE = Type.getType(PersistentList.EmptyList.class)

        public EmptyExpr(Object coll)
        (§
            this.coll = coll
        )

        public Object eval()
        (§
            (§ return (§ expr coll))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (coll instanceof IPersistentList)
            (§
                gen.getStatic(LIST_TYPE, "EMPTY", EMPTY_LIST_TYPE)
            )
            else if (coll instanceof IPersistentVector)
            (§
                gen.getStatic(VECTOR_TYPE, "EMPTY", VECTOR_TYPE)
            )
            else if (coll instanceof IPersistentMap)
            (§
                gen.getStatic(HASHMAP_TYPE, "EMPTY", HASHMAP_TYPE)
            )
            else if (coll instanceof IPersistentSet)
            (§
                gen.getStatic(HASHSET_TYPE, "EMPTY", HASHSET_TYPE)
            )
            else
            (§
                throw new UnsupportedOperationException("Unknown Collection type")
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            if (coll instanceof IPersistentList)
            (§
                (§ return (§ expr IPersistentList.class))
            )
            else if (coll instanceof IPersistentVector)
            (§
                (§ return (§ expr IPersistentVector.class))
            )
            else if (coll instanceof IPersistentMap)
            (§
                (§ return (§ expr IPersistentMap.class))
            )
            else if (coll instanceof IPersistentSet)
            (§
                (§ return (§ expr IPersistentSet.class))
            )
            else
            (§
                throw new UnsupportedOperationException("Unknown Collection type")
            )
        )
    )

    public static class ListExpr implements Expr
    (§
        public final IPersistentVector args

        final static Method arrayToListMethod = Method.getMethod("cloiure.lang.ISeq arrayToList(Object[])")

        public ListExpr(IPersistentVector args)
        (§
            this.args = args
        )

        public Object eval()
        (§
            IPersistentVector ret = PersistentVector.EMPTY
            for (int i = 0 i < args.count() i++)
            (§
                ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval())
            )
            (§ return (§ expr ret.seq()))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            MethodExpr.emitArgsAsArray(args, objx, gen)
            gen.invokeStatic(RT_TYPE, arrayToListMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr IPersistentList.class))
        )
    )

    public static class MapExpr implements Expr
    (§
        public final IPersistentVector keyvals

        final static Method mapMethod = Method.getMethod("cloiure.lang.IPersistentMap map(Object[])")
        final static Method mapUniqueKeysMethod = Method.getMethod("cloiure.lang.IPersistentMap mapUniqueKeys(Object[])")

        public MapExpr(IPersistentVector keyvals)
        (§
            this.keyvals = keyvals
        )

        public Object eval()
        (§
            Object[] ret = new Object[keyvals.count()]
            for (int i = 0 i < keyvals.count() i++)
            (§
                ret[i] = ((Expr) keyvals.nth(i)).eval()
            )
            (§ return (§ expr RT.map(ret)))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            boolean allKeysConstant = true
            boolean allConstantKeysUnique = true
            IPersistentSet constantKeys = PersistentHashSet.EMPTY
            for (int i = 0 i < keyvals.count() i+=2)
            (§
                Expr k = (Expr) keyvals.nth(i)
                if (k instanceof LiteralExpr)
                (§
                    Object kval = k.eval()
                    if (constantKeys.contains(kval))
                    (§
                        allConstantKeysUnique = false
                    )
                    else
                    (§
                        constantKeys = (IPersistentSet)constantKeys.cons(kval)
                    )
                )
                else
                (§
                    allKeysConstant = false
                )
            )
            MethodExpr.emitArgsAsArray(keyvals, objx, gen)
            if ((allKeysConstant && allConstantKeysUnique) || (keyvals.count() <= 2))
            (§
                gen.invokeStatic(RT_TYPE, mapUniqueKeysMethod)
            )
            else
            (§
                gen.invokeStatic(RT_TYPE, mapMethod)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr IPersistentMap.class))
        )

        static public Expr parse(C context, IPersistentMap form)
        (§
            IPersistentVector keyvals = PersistentVector.EMPTY
            boolean keysConstant = true
            boolean valsConstant = true
            boolean allConstantKeysUnique = true
            IPersistentSet constantKeys = PersistentHashSet.EMPTY
            for (ISeq s = RT.seq(form) s != nil s = s.next())
            (§
                IMapEntry e = (IMapEntry) s.first()
                Expr k = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.key())
                Expr v = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e.val())
                keyvals = (IPersistentVector) keyvals.cons(k)
                keyvals = (IPersistentVector) keyvals.cons(v)
                if (k instanceof LiteralExpr)
                (§
                    Object kval = k.eval()
                    if (constantKeys.contains(kval))
                    (§
                        allConstantKeysUnique = false
                    )
                    else
                    (§
                        constantKeys = (IPersistentSet)constantKeys.cons(kval)
                    )
                )
                else
                (§
                    keysConstant = false
                )
                if (!(v instanceof LiteralExpr))
                (§
                    valsConstant = false
                )
            )

            Expr ret = new MapExpr(keyvals)
            if (form instanceof IObj && ((IObj) form).meta() != nil)
            (§
                (§ return (§ expr new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))))
            )
            else if (keysConstant)
            (§
                ;; TBD: Add more detail to exception thrown below.
                if (!allConstantKeysUnique)
                (§
                    throw new IllegalArgumentException("Duplicate constant keys in map")
                )
                if (valsConstant)
                (§
                    IPersistentMap m = PersistentArrayMap.EMPTY
                    for (int i = 0 i < keyvals.length() i += 2)
                    (§
                        m = m.assoc(((LiteralExpr)keyvals.nth(i)).val(), ((LiteralExpr)keyvals.nth(i + 1)).val())
                    )
                    (§ return (§ expr new ConstantExpr(m)))
                )
                else
                (§
                    (§ return (§ expr ret))
                )
            )
            else
            (§
                (§ return (§ expr ret))
            )
        )
    )

    public static class SetExpr implements Expr
    (§
        public final IPersistentVector keys

        final static Method setMethod = Method.getMethod("cloiure.lang.IPersistentSet set(Object[])")

        public SetExpr(IPersistentVector keys)
        (§
            this.keys = keys
        )

        public Object eval()
        (§
            Object[] ret = new Object[keys.count()]
            for (int i = 0 i < keys.count() i++)
            (§
                ret[i] = ((Expr) keys.nth(i)).eval()
            )
            (§ return (§ expr RT.set(ret)))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            MethodExpr.emitArgsAsArray(keys, objx, gen)
            gen.invokeStatic(RT_TYPE, setMethod)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr IPersistentSet.class))
        )

        static public Expr parse(C context, IPersistentSet form)
        (§
            IPersistentVector keys = PersistentVector.EMPTY
            boolean constant = true

            for (ISeq s = RT.seq(form) s != nil s = s.next())
            (§
                Object e = s.first()
                Expr expr = analyze((context == C.EVAL) ? context :or C.EXPRESSION, e)
                keys = (IPersistentVector) keys.cons(expr)
                if (!(expr instanceof LiteralExpr))
                (§
                    constant = false
                )
            )
            Expr ret = new SetExpr(keys)
            if (form instanceof IObj && ((IObj) form).meta() != nil)
            (§
                (§ return (§ expr new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))))
            )
            else if (constant)
            (§
                IPersistentSet set = PersistentHashSet.EMPTY
                for (int i = 0 i < keys.count() i++)
                (§
                    LiteralExpr ve = (LiteralExpr)keys.nth(i)
                    set = (IPersistentSet)set.cons(ve.val())
                )
                (§ return (§ expr new ConstantExpr(set)))
            )
            else
            (§
                (§ return (§ expr ret))
            )
        )
    )

    public static class VectorExpr implements Expr
    (§
        public final IPersistentVector args

        final static Method vectorMethod = Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])")

        public VectorExpr(IPersistentVector args)
        (§
            this.args = args
        )

        public Object eval()
        (§
            IPersistentVector ret = PersistentVector.EMPTY
            for (int i = 0 i < args.count() i++)
            (§
                ret = (IPersistentVector) ret.cons(((Expr) args.nth(i)).eval())
            )
            (§ return (§ expr ret))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (args.count() <= Tuple.MAX_SIZE)
            (§
                for (int i = 0 i < args.count() i++)
                (§
                    ((Expr) args.nth(i)).emit(C.EXPRESSION, objx, gen)
                )
                gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()])
            )
            else
            (§
                MethodExpr.emitArgsAsArray(args, objx, gen)
                gen.invokeStatic(RT_TYPE, vectorMethod)
            )

            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr IPersistentVector.class))
        )

        static public Expr parse(C context, IPersistentVector form)
        (§
            boolean constant = true

            IPersistentVector args = PersistentVector.EMPTY
            for (int i = 0 i < form.count() i++)
            (§
                Expr v = analyze((context == C.EVAL) ? context :or C.EXPRESSION, form.nth(i))
                args = (IPersistentVector) args.cons(v)
                if (!(v instanceof LiteralExpr))
                (§
                    constant = false
                )
            )
            Expr ret = new VectorExpr(args)
            if (form instanceof IObj && ((IObj) form).meta() != nil)
            (§
                (§ return (§ expr new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))))
            )
            else if (constant)
            (§
                IPersistentVector rv = PersistentVector.EMPTY
                for (int i = 0 i < args.count() i++)
                (§
                    LiteralExpr ve = (LiteralExpr)args.nth(i)
                    rv = rv.cons(ve.val())
                )
                (§ return (§ expr new ConstantExpr(rv)))
            )
            else
            (§
                (§ return (§ expr ret))
            )
        )
    )

    static class KeywordInvokeExpr implements Expr
    (§
        public final KeywordExpr kw
        public final Object tag
        public final Expr target
        public final int line
        public final int column
        public final int siteIndex
        public final String source

        static Type ILOOKUP_TYPE = Type.getType(ILookup.class)

        Class jc

        public KeywordInvokeExpr(String source, int line, int column, Symbol tag, KeywordExpr kw, Expr target)
        (§
            this.source = source
            this.kw = kw
            this.target = target
            this.line = line
            this.column = column
            this.tag = tag
            this.siteIndex = registerKeywordCallsite(kw.k)
        )

        public Object eval()
        (§
            try
            (§
                (§ return (§ expr kw.k.invoke(target.eval())))
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Label endLabel = gen.newLabel()
            Label faultLabel = gen.newLabel()

            gen.visitLineNumber(line, gen.mark())
            gen.getStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE)
            gen.dup() ;; thunk, thunk
            target.emit(C.EXPRESSION, objx, gen) ;; thunk, thunk, target
            gen.visitLineNumber(line, gen.mark())
            gen.dupX2() ;; target, thunk, thunk, target
            gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)")) ;; target, thunk, result
            gen.dupX2() ;; result, target, thunk, result
            gen.visitJumpInsn(IF_ACMPEQ, faultLabel) ;; result, target
            gen.pop() ;; result
            gen.goTo(endLabel)

            gen.mark(faultLabel) ;; result, target
            gen.swap() ;; target, result
            gen.pop() ;; target
            gen.dup() ;; target, target
            gen.getStatic(objx.objtype, objx.siteNameStatic(siteIndex), ObjExpr.KEYWORD_LOOKUPSITE_TYPE) ;; target, target, site
            gen.swap() ;; target, site, target
            gen.invokeInterface(ObjExpr.ILOOKUP_SITE_TYPE, Method.getMethod("cloiure.lang.ILookupThunk fault(Object)")) ;; target, new-thunk
            gen.dup() ;; target, new-thunk, new-thunk
            gen.putStatic(objx.objtype, objx.thunkNameStatic(siteIndex), ObjExpr.ILOOKUP_THUNK_TYPE) ;; target, new-thunk
            gen.swap() ;; new-thunk, target
            gen.invokeInterface(ObjExpr.ILOOKUP_THUNK_TYPE, Method.getMethod("Object get(Object)")) ;; result

            gen.mark(endLabel)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (tag != nil)))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = HostExpr.tagToClass(tag)
            )
            (§ return (§ expr jc))
        )
    )

    public static class InstanceOfExpr implements Expr, MaybePrimitiveExpr
    (§
        Expr expr
        Class c

        public InstanceOfExpr(Class c, Expr expr)
        (§
            this.expr = expr
            this.c = c
        )

        public Object eval()
        (§
            if (c.isInstance(expr.eval()))
            (§
                (§ return (§ expr RT.T))
            )
            (§ return (§ expr RT.F))
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr true))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            expr.emit(C.EXPRESSION, objx, gen)
            gen.instanceOf(getType(c))
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            emitUnboxed(context, objx, gen)
            HostExpr.emitBoxReturn(objx, gen, Boolean.TYPE)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr Boolean.TYPE))
        )
    )

    static class StaticInvokeExpr implements Expr, MaybePrimitiveExpr
    (§
        public final Type target
        public final Class retClass
        public final Class[] paramclasses
        public final Type[] paramtypes
        public final IPersistentVector args
        public final boolean variadic
        public final boolean tailPosition
        public final Object tag

        Class jc

        StaticInvokeExpr(Type target, Class retClass, Class[] paramclasses, Type[] paramtypes, boolean variadic, IPersistentVector args, Object tag, boolean tailPosition)
        (§
            this.target = target
            this.retClass = retClass
            this.paramclasses = paramclasses
            this.paramtypes = paramtypes
            this.args = args
            this.variadic = variadic
            this.tailPosition = tailPosition
            this.tag = tag
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval StaticInvokeExpr")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            emitUnboxed(context, objx, gen)
            if (context != C.STATEMENT)
            (§
                HostExpr.emitBoxReturn(objx, gen, retClass)
            )
            if (context == C.STATEMENT)
            (§
                if (retClass == long.class || retClass == double.class)
                (§
                    gen.pop2()
                )
                else
                (§
                    gen.pop()
                )
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = retType((tag != nil) ? HostExpr.tagToClass(tag) :or nil, retClass)
            )
            (§ return (§ expr jc))
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr retClass.isPrimitive()))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Method ms = new Method("invokeStatic", getReturnType(), paramtypes)
            if (variadic)
            (§
                for (int i = 0 i < paramclasses.length - 1 i++)
                (§
                    Expr e = (Expr) args.nth(i)
                    if (maybePrimitiveType(e) == paramclasses[i])
                    (§
                        ((MaybePrimitiveExpr) e).emitUnboxed(C.EXPRESSION, objx, gen)
                    )
                    else
                    (§
                        e.emit(C.EXPRESSION, objx, gen)
                        HostExpr.emitUnboxArg(objx, gen, paramclasses[i])
                    )
                )
                IPersistentVector restArgs = RT.subvec(args, paramclasses.length - 1, args.count())
                MethodExpr.emitArgsAsArray(restArgs, objx, gen)
                gen.invokeStatic(Type.getType(ArraySeq.class), Method.getMethod("cloiure.lang.ArraySeq create(Object[])"))
            )
            else
            (§
                MethodExpr.emitTypedArgs(objx, gen, paramclasses, args)
            )

            if (tailPosition && !objx.canBeDirect)
            (§
                ObjMethod method = (ObjMethod) METHOD.deref()
                method.emitClearThis(gen)
            )

            gen.invokeStatic(target, ms)
        )

        private Type getReturnType()
        (§
            (§ return (§ expr Type.getType(retClass)))
        )

        public static Expr parse(Var v, ISeq args, Object tag, boolean tailPosition)
        (§
            if (!v.isBound() || v.get() == nil)
            (§
                (§ return (§ expr nil))
            )
            Class c = v.get().getClass()
            String cname = c.getName()

            java.lang.reflect.Method[] allmethods = c.getMethods()

            boolean variadic = false
            int argcount = RT.count(args)
            java.lang.reflect.Method method = nil
            for (java.lang.reflect.Method m :in allmethods)
            (§
                if (Modifier.isStatic(m.getModifiers()) && m.getName().equals("invokeStatic"))
                (§
                    Class[] params = m.getParameterTypes()
                    if (argcount == params.length)
                    (§
                        method = m
                        variadic = (argcount > 0 && params[params.length - 1] == ISeq.class)
                        break
                    )
                    else if (argcount > params.length && params.length > 0 && params[params.length - 1] == ISeq.class)
                    (§
                        method = m
                        variadic = true
                        break
                    )
                )
            )
            if (method == nil)
            (§
                (§ return (§ expr nil))
            )

            Class retClass = method.getReturnType()

            Class[] paramClasses = method.getParameterTypes()
            Type[] paramTypes = new Type[paramClasses.length]

            for (int i = 0 i < paramClasses.length i++)
            (§
                paramTypes[i] = Type.getType(paramClasses[i])
            )

            Type target = Type.getType(c)

            PersistentVector argv = PersistentVector.EMPTY
            for (ISeq s = RT.seq(args) s != nil s = s.next())
            (§
                argv = argv.cons(analyze(C.EXPRESSION, s.first()))
            )

            (§ return (§ expr new StaticInvokeExpr(target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition)))
        )
    )

    static class InvokeExpr implements Expr
    (§
        public final Expr fexpr
        public final Object tag
        public final IPersistentVector args
        public final int line
        public final int column
        public final boolean tailPosition
        public final String source

        public boolean isProtocol = false
        public boolean isDirect = false
        public int siteIndex = -1
        public Class protocolOn
        public java.lang.reflect.Method onMethod

        static Keyword onKey = Keyword.intern("on")
        static Keyword methodMapKey = Keyword.intern("method-map")

        Class jc

        static Object sigTag(int argcount, Var v)
        (§
            Object arglists = RT.get(RT.meta(v), arglistsKey)
            Object sigTag = nil
            for (ISeq s = RT.seq(arglists) s != nil s = s.next())
            (§
                APersistentVector sig = (APersistentVector) s.first()
                int restOffset = sig.indexOf(_AMP_)
                if (argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))
                (§
                    (§ return (§ expr tagOf(sig)))
                )
            )
            (§ return (§ expr nil))
        )

        public InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition)
        (§
            this.source = source
            this.fexpr = fexpr
            this.args = args
            this.line = line
            this.column = column
            this.tailPosition = tailPosition

            if (fexpr instanceof VarExpr)
            (§
                Var fvar = ((VarExpr)fexpr).var
                Var pvar =  (Var)RT.get(fvar.meta(), protocolKey)
                if (pvar != nil && PROTOCOL_CALLSITES.isBound())
                (§
                    this.isProtocol = true
                    this.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var)
                    Object pon = RT.get(pvar.get(), onKey)
                    this.protocolOn = HostExpr.maybeClass(pon, false)
                    if (this.protocolOn != nil)
                    (§
                        IPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey)
                        Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym))
                        if (mmapVal == nil)
                        (§
                            throw new IllegalArgumentException("No method of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym + " (The protocol method may have been defined before and removed.)")
                        )
                        String mname = munge(mmapVal.sym.toString())
                        List methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false)
                        if (methods.size() != 1)
                        (§
                            throw new IllegalArgumentException("No single method: " + mname + " of interface: " + protocolOn.getName() + " found for function: " + fvar.sym + " of protocol: " + pvar.sym)
                        )
                        this.onMethod = (java.lang.reflect.Method) methods.get(0)
                    )
                )
            )

            if (tag != nil)
            (§
                this.tag = tag
            )
            else if (fexpr instanceof VarExpr)
            (§
                Var v = ((VarExpr) fexpr).var
                Object arglists = RT.get(RT.meta(v), arglistsKey)
                Object sigTag = sigTag(args.count(), v)
                this.tag = (sigTag == nil) ? ((VarExpr) fexpr).tag :or sigTag
            )
            else
            (§
                this.tag = nil
            )
        )

        public Object eval()
        (§
            try
            (§
                IFn fn = (IFn) fexpr.eval()
                PersistentVector argvs = PersistentVector.EMPTY
                for (int i = 0 i < args.count() i++)
                (§
                    argvs = argvs.cons(((Expr) args.nth(i)).eval())
                )
                (§ return (§ expr fn.applyTo(RT.seq(Util.ret1(argvs, argvs = nil)))))
            )
            catch (Throwable e)
            (§
                if (!(e instanceof CompilerException))
                (§
                    throw new CompilerException(source, line, column, e)
                )
                else
                (§
                    throw (CompilerException) e
                )
            )
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (isProtocol)
            (§
                gen.visitLineNumber(line, gen.mark())
                emitProto(context, objx, gen)
            )

            else
            (§
                fexpr.emit(C.EXPRESSION, objx, gen)
                gen.visitLineNumber(line, gen.mark())
                gen.checkCast(IFN_TYPE)
                emitArgsAndCall(0, context, objx, gen)
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public void emitProto(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Label onLabel = gen.newLabel()
            Label callLabel = gen.newLabel()
            Label endLabel = gen.newLabel()

            Var v = ((VarExpr)fexpr).var

            Expr e = (Expr) args.nth(0)
            e.emit(C.EXPRESSION, objx, gen)
            gen.dup() ;; target, target
            gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)")) ;; target, class
            gen.getStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE) ;; target, class, cached-class
            gen.visitJumpInsn(IF_ACMPEQ, callLabel) ;; target
            if (protocolOn != nil)
            (§
                gen.dup() ;; target, target
                gen.instanceOf(Type.getType(protocolOn))
                gen.ifZCmp(GeneratorAdapter.NE, onLabel)
            )

            gen.dup() ;; target, target
            gen.invokeStatic(UTIL_TYPE, Method.getMethod("Class classOf(Object)")) ;; target, class
            gen.putStatic(objx.objtype, objx.cachedClassName(siteIndex), CLASS_TYPE) ;; target

            gen.mark(callLabel) ;; target
            objx.emitVar(gen, v)
            gen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()")) ;; target, proto-fn
            gen.swap()
            emitArgsAndCall(1, context, objx, gen)
            gen.goTo(endLabel)

            gen.mark(onLabel) ;; target
            if (protocolOn != nil)
            (§
                gen.checkCast(Type.getType(protocolOn))
                MethodExpr.emitTypedArgs(objx, gen, onMethod.getParameterTypes(), RT.subvec(args, 1, args.count()))
                if (context == C.RETURN)
                (§
                    ObjMethod method = (ObjMethod) METHOD.deref()
                    method.emitClearLocals(gen)
                )
                Method m = new Method(onMethod.getName(), Type.getReturnType(onMethod), Type.getArgumentTypes(onMethod))
                gen.invokeInterface(Type.getType(protocolOn), m)
                HostExpr.emitBoxReturn(objx, gen, onMethod.getReturnType())
            )
            gen.mark(endLabel)
        )

        void emitArgsAndCall(int firstArgToEmit, C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            for (int i = firstArgToEmit i < Math.min(MAX_POSITIONAL_ARITY, args.count()) i++)
            (§
                Expr e = (Expr) args.nth(i)
                e.emit(C.EXPRESSION, objx, gen)
            )
            if (args.count() > MAX_POSITIONAL_ARITY)
            (§
                PersistentVector restArgs = PersistentVector.EMPTY
                for (int i = MAX_POSITIONAL_ARITY i < args.count() i++)
                (§
                    restArgs = restArgs.cons(args.nth(i))
                )
                MethodExpr.emitArgsAsArray(restArgs, objx, gen)
            )
            gen.visitLineNumber(line, gen.mark())

            if (tailPosition && !objx.canBeDirect)
            (§
                ObjMethod method = (ObjMethod) METHOD.deref()
                method.emitClearThis(gen)
            )

            gen.invokeInterface(IFN_TYPE, new Method("invoke", OBJECT_TYPE, ARG_TYPES[Math.min(MAX_POSITIONAL_ARITY + 1, args.count())]))
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (tag != nil)))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = HostExpr.tagToClass(tag)
            )
            (§ return (§ expr jc))
        )

        static public Expr parse(C context, ISeq form)
        (§
            boolean tailPosition = inTailCall(context)
            if (context != C.EVAL)
            (§
                context = C.EXPRESSION
            )
            Expr fexpr = analyze(context, form.first())
            if (fexpr instanceof VarExpr && ((VarExpr)fexpr).var.equals(INSTANCE) && RT.count(form) == 3)
            (§
                Expr sexpr = analyze(C.EXPRESSION, RT.second(form))
                if (sexpr instanceof ConstantExpr)
                (§
                    Object val = ((ConstantExpr) sexpr).val()
                    if (val instanceof Class)
                    (§
                        (§ return (§ expr new InstanceOfExpr((Class) val, analyze(context, RT.third(form)))))
                    )
                )
            )

            if (RT.booleanCast(getCompilerOption(directLinkingKey)) && fexpr instanceof VarExpr && context != C.EVAL)
            (§
                Var v = ((VarExpr)fexpr).var
                if (!v.isDynamic() && !RT.booleanCast(RT.get(v.meta(), redefKey, false)))
                (§
                    Symbol formtag = tagOf(form)
                    Object arglists = RT.get(RT.meta(v), arglistsKey)
                    int arity = RT.count(form.next())
                    Object sigtag = sigTag(arity, v)
                    Object vtag = RT.get(RT.meta(v), RT.TAG_KEY)
                    Expr ret = StaticInvokeExpr.parse(v, RT.next(form), (formtag != nil) ? formtag :or (sigtag != nil) ? sigtag :or vtag, tailPosition)
                    if (ret != nil)
                    (§
                        (§ return (§ expr ret))
                    )
                )
            )

            if (fexpr instanceof VarExpr && context != C.EVAL)
            (§
                Var v = ((VarExpr)fexpr).var
                Object arglists = RT.get(RT.meta(v), arglistsKey)
                int arity = RT.count(form.next())
                for (ISeq s = RT.seq(arglists) s != nil s = s.next())
                (§
                    IPersistentVector args = (IPersistentVector) s.first()
                    if (args.count() == arity)
                    (§
                        String primc = FnMethod.primInterface(args)
                        if (primc != nil)
                        (§
                            (§ return (§ expr analyze(context, ((IObj)RT.listStar(Symbol.intern(".invokePrim"), ((Symbol) form.first()).withMeta(RT.map(RT.TAG_KEY, Symbol.intern(primc))), form.next())).withMeta((IPersistentMap)RT.conj(RT.meta(v), RT.meta(form))))))
                        )
                        break
                    )
                )
            )

            if (fexpr instanceof KeywordExpr && RT.count(form) == 2 && KEYWORD_CALLSITES.isBound())
            (§
                Expr target = analyze(context, RT.second(form))
                (§ return (§ expr new KeywordInvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), (KeywordExpr) fexpr, target)))
            )
            PersistentVector args = PersistentVector.EMPTY
            for (ISeq s = RT.seq(form.next()) s != nil s = s.next())
            (§
                args = args.cons(analyze(context, s.first()))
            )

            (§ return (§ expr new InvokeExpr((String) SOURCE.deref(), lineDeref(), columnDeref(), tagOf(form), fexpr, args, tailPosition)))
        )
    )

    static class SourceDebugExtensionAttribute extends Attribute
    (§
        public SourceDebugExtensionAttribute()
        (§
            super("SourceDebugExtension")
        )

        void writeSMAP(ClassWriter cw, String smap)
        (§
            ByteVector bv = write(cw, nil, -1, -1, -1)
            bv.putUTF8(smap)
        )
    )

    static public class FnExpr extends ObjExpr
    (§
        final static Type aFnType = Type.getType(AFunction.class)
        final static Type restFnType = Type.getType(RestFn.class)

        ;; if there is a variadic overload (there can only be one) it is stored here
        FnMethod variadicMethod = nil
        IPersistentCollection methods
        private boolean hasPrimSigs
        private boolean hasMeta
        private boolean hasEnclosingMethod

        Class jc

        public FnExpr(Object tag)
        (§
            super(tag)
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        boolean supportsMeta()
        (§
            (§ return (§ expr hasMeta))
        )

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = (tag != nil) ? HostExpr.tagToClass(tag) :or AFunction.class
            )
            (§ return (§ expr jc))
        )

        protected void emitMethods(ClassVisitor cv)
        (§
            ;; override of invoke/doInvoke for each method
            for (ISeq s = RT.seq(methods) s != nil s = s.next())
            (§
                ObjMethod method = (ObjMethod) s.first()
                method.emit(this, cv)
            )

            if (isVariadic())
            (§
                GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, Method.getMethod("int getRequiredArity()"), nil, nil, cv)
                gen.visitCode()
                gen.push(variadicMethod.reqParms.count())
                gen.returnValue()
                gen.endMethod()
            )
        )

        static Expr parse(C context, ISeq form, String name)
        (§
            ISeq origForm = form
            FnExpr fn = new FnExpr(tagOf(form))
            Keyword retkey = Keyword.intern(nil, "rettag")
            Object rettag = RT.get(RT.meta(form), retkey)
            fn.src = form
            ObjMethod enclosingMethod = (ObjMethod) METHOD.deref()
            fn.hasEnclosingMethod = enclosingMethod != nil
            if (((IMeta) form.first()).meta() != nil)
            (§
                fn.onceOnly = RT.booleanCast(RT.get(RT.meta(form.first()), Keyword.intern(nil, "once")))
            )

            String basename = ((enclosingMethod != nil) ? enclosingMethod.objx.name :or munge(currentNS().name.name)) + "$"

            Symbol nm = nil

            if (RT.second(form) instanceof Symbol)
            (§
                nm = (Symbol) RT.second(form)
                name = nm.name + "__" + RT.nextID()
            )
            else
            (§
                if (name == nil)
                (§
                    name = "fn__" + RT.nextID()
                )
                else if (enclosingMethod != nil)
                (§
                    name += "__" + RT.nextID()
                )
            )

            String simpleName = munge(name).replace(".", "_DOT_")

            fn.name = basename + simpleName
            fn.internalName = fn.name.replace(\., \/)
            fn.objtype = Type.getObjectType(fn.internalName)
            ArrayList<String> prims = new ArrayList()
            try
            (§
                Var.pushThreadBindings(RT.mapUniqueKeys(CONSTANTS, PersistentVector.EMPTY,
                            CONSTANT_IDS, new IdentityHashMap(),
                            KEYWORDS, PersistentHashMap.EMPTY,
                            VARS, PersistentHashMap.EMPTY,
                            KEYWORD_CALLSITES, PersistentVector.EMPTY,
                            PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                            VAR_CALLSITES, emptyVarCallSites(),
                            NO_RECUR, nil
                ))

                ;; arglist might be preceded by symbol naming this fn
                if (nm != nil)
                (§
                    fn.thisName = nm.name
                    form = RT.cons(FN, RT.next(RT.next(form)))
                )

                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                ;; turn former into latter
                if (RT.second(form) instanceof IPersistentVector)
                (§
                    form = RT.list(FN, RT.next(form))
                )
                fn.line = lineDeref()
                fn.column = columnDeref()
                FnMethod[] methodArray = new FnMethod[MAX_POSITIONAL_ARITY + 1]
                FnMethod variadicMethod = nil
                boolean usesThis = false
                for (ISeq s = RT.next(form) s != nil s = RT.next(s))
                (§
                    FnMethod f = FnMethod.parse(fn, (ISeq) RT.first(s), rettag)
                    if (f.usesThis)
                    (§
                        usesThis = true
                    )
                    if (f.isVariadic())
                    (§
                        if (variadicMethod == nil)
                        (§
                            variadicMethod = f
                        )
                        else
                        (§
                            throw Util.runtimeException("Can't have more than 1 variadic overload")
                        )
                    )
                    else if (methodArray[f.reqParms.count()] == nil)
                    (§
                        methodArray[f.reqParms.count()] = f
                    )
                    else
                    (§
                        throw Util.runtimeException("Can't have 2 overloads with same arity")
                    )
                    if (f.prim != nil)
                    (§
                        prims.add(f.prim)
                    )
                )
                if (variadicMethod != nil)
                (§
                    for (int i = variadicMethod.reqParms.count() + 1 i <= MAX_POSITIONAL_ARITY i++)
                    (§
                        if (methodArray[i] != nil)
                        (§
                            throw Util.runtimeException("Can't have fixed arity function with more params than variadic function")
                        )
                    )
                )

                fn.canBeDirect = (!fn.hasEnclosingMethod && fn.closes.count() == 0 && !usesThis)

                IPersistentCollection methods = nil
                for (int i = 0 i < methodArray.length i++)
                (§
                    if (methodArray[i] != nil)
                    (§
                        methods = RT.conj(methods, methodArray[i])
                    )
                )
                if (variadicMethod != nil)
                (§
                    methods = RT.conj(methods, variadicMethod)
                )

                if (fn.canBeDirect)
                (§
                    for (FnMethod fm :in (Collection<FnMethod>)methods)
                    (§
                        if (fm.locals != nil)
                        (§
                            for (LocalBinding lb :in (Collection<LocalBinding>)RT.keys(fm.locals))
                            (§
                                if (lb.isArg)
                                (§
                                    lb.idx -= 1
                                )
                            )
                        )
                    )
                )

                fn.methods = methods
                fn.variadicMethod = variadicMethod
                fn.keywords = (IPersistentMap) KEYWORDS.deref()
                fn.vars = (IPersistentMap) VARS.deref()
                fn.constants = (PersistentVector) CONSTANTS.deref()
                fn.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref()
                fn.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref()
                fn.varCallsites = (IPersistentSet) VAR_CALLSITES.deref()

                fn.constantsID = RT.nextID()
            )
            finally
            (§
                Var.popThreadBindings()
            )
            fn.hasPrimSigs = prims.size() > 0
            IPersistentMap fmeta = RT.meta(origForm)
            if (fmeta != nil)
            (§
                fmeta = fmeta.without(RT.LINE_KEY).without(RT.COLUMN_KEY).without(RT.FILE_KEY).without(retkey)
            )

            fn.hasMeta = RT.count(fmeta) > 0

            try
            (§
                fn.compile(fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (prims.size() == 0) ? nil :or prims.toArray(new String[prims.size()]), fn.onceOnly)
            )
            catch (IOException e)
            (§
                throw Util.sneakyThrow(e)
            )
            fn.getCompiledClass()

            if (fn.supportsMeta())
            (§
                (§ return (§ expr new MetaExpr(fn, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, fmeta))))
            )
            else
            (§
                (§ return (§ expr fn))
            )
        )

        public final ObjMethod variadicMethod()
        (§
            (§ return (§ expr variadicMethod))
        )

        boolean isVariadic()
        (§
            (§ return (§ expr (variadicMethod != nil)))
        )

        public final IPersistentCollection methods()
        (§
            (§ return (§ expr methods))
        )

        public void emitForDefn(ObjExpr objx, GeneratorAdapter gen)
        (§
            emit(C.EXPRESSION, objx, gen)
        )
    )

    static public class ObjExpr implements Expr
    (§
        static final String CONST_PREFIX = "const__"

        String name
        String internalName
        String thisName
        Type objtype
        public final Object tag
        ;; localbinding->itself
        IPersistentMap closes = PersistentHashMap.EMPTY
        ;; localbndingexprs
        IPersistentVector closesExprs = PersistentVector.EMPTY
        ;; symbols
        IPersistentSet volatiles = PersistentHashSet.EMPTY

        ;; symbol->lb
        IPersistentMap fields = nil

        ;; hinted fields
        IPersistentVector hintedFields = PersistentVector.EMPTY

        ;; Keyword->KeywordExpr
        IPersistentMap keywords = PersistentHashMap.EMPTY
        IPersistentMap vars = PersistentHashMap.EMPTY
        Class compiledClass
        int line
        int column
        PersistentVector constants
        IPersistentSet usedConstants = PersistentHashSet.EMPTY

        int constantsID
        int altCtorDrops = 0

        IPersistentVector keywordCallsites
        IPersistentVector protocolCallsites
        IPersistentSet varCallsites
        boolean onceOnly = false

        Object src

        IPersistentMap opts = PersistentHashMap.EMPTY

        final static Method voidctor = Method.getMethod("void <init>()")
        protected IPersistentMap classMeta
        protected boolean canBeDirect

        public final String name()
        (§
            (§ return (§ expr name))
        )

        public final String internalName()
        (§
            (§ return (§ expr internalName))
        )

        public final String thisName()
        (§
            (§ return (§ expr thisName))
        )

        public final Type objtype()
        (§
            (§ return (§ expr objtype))
        )

        public final IPersistentMap closes()
        (§
            (§ return (§ expr closes))
        )

        public final IPersistentMap keywords()
        (§
            (§ return (§ expr keywords))
        )

        public final IPersistentMap vars()
        (§
            (§ return (§ expr vars))
        )

        public final Class compiledClass()
        (§
            (§ return (§ expr compiledClass))
        )

        public final int line()
        (§
            (§ return (§ expr line))
        )

        public final int column()
        (§
            (§ return (§ expr column))
        )

        public final PersistentVector constants()
        (§
            (§ return (§ expr constants))
        )

        public final int constantsID()
        (§
            (§ return (§ expr constantsID))
        )

        final static Method kwintern = Method.getMethod("cloiure.lang.Keyword intern(String, String)")
        final static Method symintern = Method.getMethod("cloiure.lang.Symbol intern(String)")
        final static Method varintern = Method.getMethod("cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)")

        final static Type DYNAMIC_CLASSLOADER_TYPE = Type.getType(DynamicClassLoader.class)
        final static Method getClassMethod = Method.getMethod("Class getClass()")
        final static Method getClassLoaderMethod = Method.getMethod("ClassLoader getClassLoader()")
        final static Method getConstantsMethod = Method.getMethod("Object[] getConstants(int)")
        final static Method readStringMethod = Method.getMethod("Object readString(String)")

        final static Type ILOOKUP_SITE_TYPE = Type.getType(ILookupSite.class)
        final static Type ILOOKUP_THUNK_TYPE = Type.getType(ILookupThunk.class)
        final static Type KEYWORD_LOOKUPSITE_TYPE = Type.getType(KeywordLookupSite.class)

        private DynamicClassLoader loader
        private byte[] bytecode

        public ObjExpr(Object tag)
        (§
            this.tag = tag
        )

        static String trimGenID(String name)
        (§
            int i = name.lastIndexOf("__")
            (§ return (§ expr (i == -1) ? name :or name.substring(0, i)))
        )

        Type[] ctorTypes()
        (§
            IPersistentVector tv = !supportsMeta() ? PersistentVector.EMPTY :or RT.vector(IPERSISTENTMAP_TYPE)
            for (ISeq s = RT.keys(closes) s != nil s = s.next())
            (§
                LocalBinding lb = (LocalBinding) s.first()
                if (lb.getPrimitiveType() != nil)
                (§
                    tv = tv.cons(Type.getType(lb.getPrimitiveType()))
                )
                else
                (§
                    tv = tv.cons(OBJECT_TYPE)
                )
            )
            Type[] ret = new Type[tv.count()]
            for (int i = 0 i < tv.count() i++)
            (§
                ret[i] = (Type) tv.nth(i)
            )
            (§ return (§ expr ret))
        )

        void compile(String superName, String[] interfaceNames, boolean oneTimeUse) throws IOException
        (§
            ;; create bytecode for a class
            ;; with name current_ns.defname[$letname]+
            ;; anonymous fns get names fn__id
            ;; derived from AFn/RestFn
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS)
            ClassVisitor cv = cw
            cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER + ACC_FINAL, internalName, nil, superName, interfaceNames)
            String source = (String) SOURCE.deref()
            int lineBefore = (Integer) LINE_BEFORE.deref()
            int lineAfter = (Integer) LINE_AFTER.deref() + 1
            int columnBefore = (Integer) COLUMN_BEFORE.deref()
            int columnAfter = (Integer) COLUMN_AFTER.deref() + 1

            if (source != nil && SOURCE_PATH.deref() != nil)
            (§
                String smap = "SMAP\n"
                    + ((source.lastIndexOf(\.) > 0) ? source.substring(0, source.lastIndexOf(\.)) :or source) ;; :or simpleName
                    + ".java\n"
                    + "Cloiure\n"
                    + "*S Cloiure\n"
                    + "*F\n"
                    + "+ 1 " + source + "\n"
                    + (String) SOURCE_PATH.deref() + "\n"
                    + "*L\n"
                    + String.format("%d#1,%d:%d\n", lineBefore, lineAfter - lineBefore, lineBefore)
                    + "*E"
                cv.visitSource(source, smap)
            )
            addAnnotation(cv, classMeta)

            if (supportsMeta())
            (§
                cv.visitField(ACC_FINAL, "__meta", IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil)
            )
            ;; instance fields for closed-overs
            for (ISeq s = RT.keys(closes) s != nil s = s.next())
            (§
                LocalBinding lb = (LocalBinding) s.first()
                if (isDeftype())
                (§
                    int access = isVolatile(lb) ? ACC_VOLATILE :or isMutable(lb) ? 0 :or (ACC_PUBLIC + ACC_FINAL)
                    FieldVisitor fv
                    if (lb.getPrimitiveType() != nil)
                    (§
                        fv = cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil)
                    )
                    else
                    (§
                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                        fv = cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil)
                    )
                    addAnnotation(fv, RT.meta(lb.sym))
                )
                else
                (§
                    ;; todo - only enable this non-private+writability for letfns where we need it
                    if (lb.getPrimitiveType() != nil)
                    (§
                        cv.visitField(0 + (isVolatile(lb) ? ACC_VOLATILE :or 0), lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil)
                    )
                    else
                    (§
                        cv.visitField(0, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil)
                    )
                )
            )

            ;; static fields for callsites and thunks
            for (int i = 0 i < protocolCallsites.count() i++)
            (§
                cv.visitField(ACC_PRIVATE + ACC_STATIC, cachedClassName(i), CLASS_TYPE.getDescriptor(), nil, nil)
            )

            ;; ctor that takes closed-overs and inits base + fields
            Method m = new Method("<init>", Type.VOID_TYPE, ctorTypes())
            GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv)
            Label start = ctorgen.newLabel()
            Label end = ctorgen.newLabel()
            ctorgen.visitCode()
            ctorgen.visitLineNumber(line, ctorgen.mark())
            ctorgen.visitLabel(start)
            ctorgen.loadThis()
            ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor)

            if (supportsMeta())
            (§
                ctorgen.loadThis()
                ctorgen.visitVarInsn(IPERSISTENTMAP_TYPE.getOpcode(Opcodes.ILOAD), 1)
                ctorgen.putField(objtype, "__meta", IPERSISTENTMAP_TYPE)
            )

            int a = supportsMeta() ? 2 :or 1
            for (ISeq s = RT.keys(closes) s != nil s = s.next(), ++a)
            (§
                LocalBinding lb = (LocalBinding) s.first()
                ctorgen.loadThis()
                Class primc = lb.getPrimitiveType()
                if (primc != nil)
                (§
                    ctorgen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), a)
                    ctorgen.putField(objtype, lb.name, Type.getType(primc))
                    if (primc == Long.TYPE || primc == Double.TYPE)
                    (§
                        ++a
                    )
                )
                else
                (§
                    ctorgen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), a)
                    ctorgen.putField(objtype, lb.name, OBJECT_TYPE)
                )
                closesExprs = closesExprs.cons(new LocalBindingExpr(lb, nil))
            )

            ctorgen.visitLabel(end)

            ctorgen.returnValue()

            ctorgen.endMethod()

            if (altCtorDrops > 0)
            (§
                ;; ctor that takes closed-overs and inits base + fields
                Type[] ctorTypes = ctorTypes()
                Type[] altCtorTypes = new Type[ctorTypes.length-altCtorDrops]
                for (int i = 0 i < altCtorTypes.length i++)
                (§
                    altCtorTypes[i] = ctorTypes[i]
                )
                Method alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.loadArgs()

                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; __meta
                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; __extmap
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hash
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hasheq

                ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()

                ;; alt ctor no __hash, __hasheq
                altCtorTypes = new Type[ctorTypes.length-2]
                for (int i = 0 i < altCtorTypes.length i++)
                (§
                    altCtorTypes[i] = ctorTypes[i]
                )

                alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.loadArgs()

                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hash
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hasheq

                ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()
            )

            if (supportsMeta())
            (§
                ;; ctor that takes closed-overs but not meta
                Type[] ctorTypes = ctorTypes()
                Type[] noMetaCtorTypes = new Type[ctorTypes.length-1]
                for (int i = 1 i < ctorTypes.length i++)
                (§
                    noMetaCtorTypes[i-1] = ctorTypes[i]
                )
                Method alt = new Method("<init>", Type.VOID_TYPE, noMetaCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; nil meta
                ctorgen.loadArgs()
                ctorgen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()

                ;; meta()
                Method meth = Method.getMethod("cloiure.lang.IPersistentMap meta()")

                GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv)
                gen.visitCode()
                gen.loadThis()
                gen.getField(objtype, "__meta", IPERSISTENTMAP_TYPE)

                gen.returnValue()
                gen.endMethod()

                ;; withMeta()
                meth = Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")

                gen = new GeneratorAdapter(ACC_PUBLIC, meth, nil, nil, cv)
                gen.visitCode()
                gen.newInstance(objtype)
                gen.dup()
                gen.loadArg(0)

                for (ISeq s = RT.keys(closes) s != nil s = s.next(), ++a)
                (§
                    LocalBinding lb = (LocalBinding) s.first()
                    gen.loadThis()
                    Class primc = lb.getPrimitiveType()
                    if (primc != nil)
                    (§
                        gen.getField(objtype, lb.name, Type.getType(primc))
                    )
                    else
                    (§
                        gen.getField(objtype, lb.name, OBJECT_TYPE)
                    )
                )

                gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes))
                gen.returnValue()
                gen.endMethod()
            )

            emitStatics(cv)
            emitMethods(cv)

            ;; static fields for constants
            for (int i = 0 i < constants.count() i++)
            (§
                if (usedConstants.contains(i))
                (§
                    cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, constantName(i), constantType(i).getDescriptor(), nil, nil)
                )
            )

            ;; static fields for lookup sites
            for (int i = 0 i < keywordCallsites.count() i++)
            (§
                cv.visitField(ACC_FINAL + ACC_STATIC, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil)
                cv.visitField(ACC_STATIC, thunkNameStatic(i), ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil)
            )

            ;; static init for constants, keywords and vars
            GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv)
            clinitgen.visitCode()
            clinitgen.visitLineNumber(line, clinitgen.mark())

            if (constants.count() > 0)
            (§
                emitConstants(clinitgen)
            )

            if (keywordCallsites.count() > 0)
            (§
                emitKeywordCallsites(clinitgen)
            )

            if (isDeftype() && RT.booleanCast(RT.get(opts, loadNs)))
            (§
                String nsname = ((Symbol)RT.second(src)).getNamespace()
                if (!nsname.equals("cloiure.core"))
                (§
                    clinitgen.push("cloiure.core")
                    clinitgen.push("require")
                    clinitgen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)"))
                    clinitgen.invokeVirtual(VAR_TYPE, Method.getMethod("Object getRawRoot()"))
                    clinitgen.checkCast(IFN_TYPE)
                    clinitgen.push(nsname)
                    clinitgen.invokeStatic(SYMBOL_TYPE, Method.getMethod("cloiure.lang.Symbol create(String)"))
                    clinitgen.invokeInterface(IFN_TYPE, Method.getMethod("Object invoke(Object)"))
                    clinitgen.pop()
                )
            )

            clinitgen.returnValue()

            clinitgen.endMethod()

            ;; end of class
            cv.visitEnd()

            bytecode = cw.toByteArray()
            if (RT.booleanCast(COMPILE_FILES.deref()))
            (§
                writeClassFile(internalName, bytecode)
            )
        )

        private void emitKeywordCallsites(GeneratorAdapter clinitgen)
        (§
            for (int i = 0 i < keywordCallsites.count() i++)
            (§
                Keyword k = (Keyword) keywordCallsites.nth(i)
                clinitgen.newInstance(KEYWORD_LOOKUPSITE_TYPE)
                clinitgen.dup()
                emitValue(k, clinitgen)
                clinitgen.invokeConstructor(KEYWORD_LOOKUPSITE_TYPE, Method.getMethod("void <init>(cloiure.lang.Keyword)"))
                clinitgen.dup()
                clinitgen.putStatic(objtype, siteNameStatic(i), KEYWORD_LOOKUPSITE_TYPE)
                clinitgen.putStatic(objtype, thunkNameStatic(i), ILOOKUP_THUNK_TYPE)
            )
        )

        protected void emitStatics(ClassVisitor gen)
        (§
        )

        protected void emitMethods(ClassVisitor gen)
        (§
        )

        void emitListAsObjectArray(Object value, GeneratorAdapter gen)
        (§
            gen.push(((List) value).size())
            gen.newArray(OBJECT_TYPE)
            int i = 0
            for (Iterator it = ((List) value).iterator() it.hasNext() i++)
            (§
                gen.dup()
                gen.push(i)
                emitValue(it.next(), gen)
                gen.arrayStore(OBJECT_TYPE)
            )
        )

        void emitValue(Object value, GeneratorAdapter gen)
        (§
            boolean partial = true

            if (value == nil)
            (§
                gen.visitInsn(Opcodes.ACONST_NULL)
            )
            else if (value instanceof String)
            (§
                gen.push((String) value)
            )
            else if (value instanceof Boolean)
            (§
                if (((Boolean) value).booleanValue())
                (§
                    gen.getStatic(BOOLEAN_OBJECT_TYPE, "TRUE", BOOLEAN_OBJECT_TYPE)
                )
                else
                (§
                    gen.getStatic(BOOLEAN_OBJECT_TYPE, "FALSE", BOOLEAN_OBJECT_TYPE)
                )
            )
            else if (value instanceof Integer)
            (§
                gen.push(((Integer) value).intValue())
                gen.invokeStatic(Type.getType(Integer.class), Method.getMethod("Integer valueOf(int)"))
            )
            else if (value instanceof Long)
            (§
                gen.push(((Long) value).longValue())
                gen.invokeStatic(Type.getType(Long.class), Method.getMethod("Long valueOf(long)"))
            )
            else if (value instanceof Double)
            (§
                gen.push(((Double) value).doubleValue())
                gen.invokeStatic(Type.getType(Double.class), Method.getMethod("Double valueOf(double)"))
            )
            else if (value instanceof Character)
            (§
                gen.push(((Character) value).charValue())
                gen.invokeStatic(Type.getType(Character.class), Method.getMethod("Character valueOf(char)"))
            )
            else if (value instanceof Class)
            (§
                Class cc = (Class)value
                if (cc.isPrimitive())
                (§
                    Type bt
                    if (cc == boolean.class)
                    (§
                        bt = Type.getType(Boolean.class)
                    )
                    else if (cc == byte.class)
                    (§
                        bt = Type.getType(Byte.class)
                    )
                    else if (cc == char.class)
                    (§
                        bt = Type.getType(Character.class)
                    )
                    else if (cc == double.class)
                    (§
                        bt = Type.getType(Double.class)
                    )
                    else if (cc == float.class)
                    (§
                        bt = Type.getType(Float.class)
                    )
                    else if (cc == int.class)
                    (§
                        bt = Type.getType(Integer.class)
                    )
                    else if (cc == long.class)
                    (§
                        bt = Type.getType(Long.class)
                    )
                    else if (cc == short.class)
                    (§
                        bt = Type.getType(Short.class)
                    )
                    else
                    (§
                        throw Util.runtimeException("Can't embed unknown primitive in code: " + value)
                    )
                    gen.getStatic(bt, "TYPE", Type.getType(Class.class))
                )
                else
                (§
                    gen.push(destubClassName(cc.getName()))
                    gen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)"))
                )
            )
            else if (value instanceof Symbol)
            (§
                gen.push(((Symbol) value).ns)
                gen.push(((Symbol) value).name)
                gen.invokeStatic(Type.getType(Symbol.class), Method.getMethod("cloiure.lang.Symbol intern(String,String)"))
            )
            else if (value instanceof Keyword)
            (§
                gen.push(((Keyword) value).sym.ns)
                gen.push(((Keyword) value).sym.name)
                gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Keyword keyword(String,String)"))
            )
            else if (value instanceof Var)
            (§
                Var var = (Var) value
                gen.push(var.ns.name.toString())
                gen.push(var.sym.toString())
                gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.Var var(String,String)"))
            )
            else if (value instanceof IType)
            (§
                Method ctor = new Method("<init>", Type.getConstructorDescriptor(value.getClass().getConstructors()[0]))
                gen.newInstance(Type.getType(value.getClass()))
                gen.dup()
                IPersistentVector fields = (IPersistentVector) Reflector.invokeStaticMethod(value.getClass(), "getBasis", new Object[] (§))
                for (ISeq s = RT.seq(fields) s != nil s = s.next())
                (§
                    Symbol field = (Symbol) s.first()
                    Class k = tagClass(tagOf(field))
                    Object val = Reflector.getInstanceField(value, munge(field.name))
                    emitValue(val, gen)

                    if (k.isPrimitive())
                    (§
                        Type b = Type.getType(boxClass(k))
                        String p = Type.getType(k).getDescriptor()
                        String n = k.getName()

                        gen.invokeVirtual(b, new Method(n+"Value", "()"+p))
                    )
                )
                gen.invokeConstructor(Type.getType(value.getClass()), ctor)
            )
            else if (value instanceof IRecord)
            (§
                Method createMethod = Method.getMethod(value.getClass().getName() + " create(cloiure.lang.IPersistentMap)")
                emitValue(PersistentArrayMap.create((java.util.Map) value), gen)
                gen.invokeStatic(getType(value.getClass()), createMethod)
            )
            else if (value instanceof IPersistentMap)
            (§
                List entries = new ArrayList()
                for (Map.Entry entry :in (Set<Map.Entry>) ((Map) value).entrySet())
                (§
                    entries.add(entry.getKey())
                    entries.add(entry.getValue())
                )
                emitListAsObjectArray(entries, gen)
                gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentMap map(Object[])"))
            )
            else if (value instanceof IPersistentVector)
            (§
                IPersistentVector args = (IPersistentVector) value
                if (args.count() <= Tuple.MAX_SIZE)
                (§
                    for (int i = 0 i < args.count() i++)
                    (§
                        emitValue(args.nth(i), gen)
                    )
                    gen.invokeStatic(TUPLE_TYPE, createTupleMethods[args.count()])
                )
                else
                (§
                    emitListAsObjectArray(value, gen)
                    gen.invokeStatic(RT_TYPE, Method.getMethod("cloiure.lang.IPersistentVector vector(Object[])"))
                )
            )
            else if (value instanceof PersistentHashSet)
            (§
                ISeq vs = RT.seq(value)
                if (vs == nil)
                (§
                    gen.getStatic(Type.getType(PersistentHashSet.class), "EMPTY", Type.getType(PersistentHashSet.class))
                )
                else
                (§
                    emitListAsObjectArray(vs, gen)
                    gen.invokeStatic(Type.getType(PersistentHashSet.class), Method.getMethod("cloiure.lang.PersistentHashSet create(Object[])"))
                )
            )
            else if (value instanceof ISeq || value instanceof IPersistentList)
            (§
                emitListAsObjectArray(value, gen)
                gen.invokeStatic(Type.getType(java.util.Arrays.class), Method.getMethod("java.util.List asList(Object[])"))
                gen.invokeStatic(Type.getType(PersistentList.class), Method.getMethod("cloiure.lang.IPersistentList create(java.util.List)"))
            )
            else if (value instanceof Pattern)
            (§
                emitValue(value.toString(), gen)
                gen.invokeStatic(Type.getType(Pattern.class), Method.getMethod("java.util.regex.Pattern compile(String)"))
            )
            else
            (§
                String cs = nil
                try
                (§
                    cs = RT.printString(value)
                )
                catch (Exception e)
                (§
                    throw Util.runtimeException("Can't embed object in code, maybe print-dup not defined: " + value)
                )
                if (cs.length() == 0)
                (§
                    throw Util.runtimeException("Can't embed unreadable object in code: " + value)
                )

                if (cs.startsWith("#<"))
                (§
                    throw Util.runtimeException("Can't embed unreadable object in code: " + cs)
                )

                gen.push(cs)
                gen.invokeStatic(RT_TYPE, readStringMethod)
                partial = false
            )

            if (partial)
            (§
                if (value instanceof IObj && RT.count(((IObj) value).meta()) > 0)
                (§
                    gen.checkCast(IOBJ_TYPE)
                    Object m = ((IObj) value).meta()
                    emitValue(elideMeta(m), gen)
                    gen.checkCast(IPERSISTENTMAP_TYPE)
                    gen.invokeInterface(IOBJ_TYPE, Method.getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))
                )
            )
        )

        void emitConstants(GeneratorAdapter clinitgen)
        (§
            try
            (§
                Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T))

                for (int i = 0 i < constants.count() i++)
                (§
                    if (usedConstants.contains(i))
                    (§
                        emitValue(constants.nth(i), clinitgen)
                        clinitgen.checkCast(constantType(i))
                        clinitgen.putStatic(objtype, constantName(i), constantType(i))
                    )
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )

        boolean isMutable(LocalBinding lb)
        (§
            (§ return (§ expr isVolatile(lb) || RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("unsynchronized-mutable")))))
        )

        boolean isVolatile(LocalBinding lb)
        (§
            (§ return (§ expr RT.booleanCast(RT.contains(fields, lb.sym)) && RT.booleanCast(RT.get(lb.sym.meta(), Keyword.intern("volatile-mutable")))))
        )

        boolean isDeftype()
        (§
            (§ return (§ expr (fields != nil)))
        )

        boolean supportsMeta()
        (§
            (§ return (§ expr !isDeftype()))
        )

        void emitClearCloses(GeneratorAdapter gen)
        (§
        )

        synchronized Class getCompiledClass()
        (§
            if (compiledClass == nil)
            (§
                loader = (DynamicClassLoader) LOADER.deref()
                compiledClass = loader.defineClass(name, bytecode, src)
            )
            (§ return (§ expr compiledClass))
        )

        public Object eval()
        (§
            if (isDeftype())
            (§
                (§ return (§ expr nil))
            )
            try
            (§
                (§ return (§ expr getCompiledClass().newInstance()))
            )
            catch (Exception e)
            (§
                throw Util.sneakyThrow(e)
            )
        )

        public void emitLetFnInits(GeneratorAdapter gen, ObjExpr objx, IPersistentSet letFnLocals)
        (§
            ;; objx arg is enclosing objx, not this
            gen.checkCast(objtype)

            for (ISeq s = RT.keys(closes) s != nil s = s.next())
            (§
                LocalBinding lb = (LocalBinding) s.first()
                if (letFnLocals.contains(lb))
                (§
                    Class primc = lb.getPrimitiveType()
                    gen.dup()
                    if (primc != nil)
                    (§
                        objx.emitUnboxedLocal(gen, lb)
                        gen.putField(objtype, lb.name, Type.getType(primc))
                    )
                    else
                    (§
                        objx.emitLocal(gen, lb, false)
                        gen.putField(objtype, lb.name, OBJECT_TYPE)
                    )
                )
            )
            gen.pop()
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
            ;; objx arg is enclosing objx, not this
            if (isDeftype())
            (§
                gen.visitInsn(Opcodes.ACONST_NULL)
            )
            else
            (§
                gen.newInstance(objtype)
                gen.dup()
                if (supportsMeta())
                (§
                    gen.visitInsn(Opcodes.ACONST_NULL)
                )
                for (ISeq s = RT.seq(closesExprs) s != nil s = s.next())
                (§
                    LocalBindingExpr lbe = (LocalBindingExpr) s.first()
                    LocalBinding lb = lbe.b
                    if (lb.getPrimitiveType() != nil)
                    (§
                        objx.emitUnboxedLocal(gen, lb)
                    )
                    else
                    (§
                        objx.emitLocal(gen, lb, lbe.shouldClear)
                    )
                )
                gen.invokeConstructor(objtype, new Method("<init>", Type.VOID_TYPE, ctorTypes()))
            )
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        Class jc

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = (compiledClass != nil) ? compiledClass :or (tag != nil) ? HostExpr.tagToClass(tag) :or IFn.class
            )
            (§ return (§ expr jc))
        )

        public void emitAssignLocal(GeneratorAdapter gen, LocalBinding lb, Expr val)
        (§
            if (!isMutable(lb))
            (§
                throw new IllegalArgumentException("Cannot assign to non-mutable: " + lb.name)
            )
            Class primc = lb.getPrimitiveType()
            gen.loadThis()
            if (primc != nil)
            (§
                if (!(val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) val).canEmitPrimitive()))
                (§
                    throw new IllegalArgumentException("Must assign primitive to primitive mutable: " + lb.name)
                )
                MaybePrimitiveExpr me = (MaybePrimitiveExpr) val
                me.emitUnboxed(C.EXPRESSION, this, gen)
                gen.putField(objtype, lb.name, Type.getType(primc))
            )
            else
            (§
                val.emit(C.EXPRESSION, this, gen)
                gen.putField(objtype, lb.name, OBJECT_TYPE)
            )
        )

        private void emitLocal(GeneratorAdapter gen, LocalBinding lb, boolean clear)
        (§
            if (closes.containsKey(lb))
            (§
                Class primc = lb.getPrimitiveType()
                gen.loadThis()
                if (primc != nil)
                (§
                    gen.getField(objtype, lb.name, Type.getType(primc))
                    HostExpr.emitBoxReturn(this, gen, primc)
                )
                else
                (§
                    gen.getField(objtype, lb.name, OBJECT_TYPE)
                    if (onceOnly && clear && lb.canBeCleared)
                    (§
                        gen.loadThis()
                        gen.visitInsn(Opcodes.ACONST_NULL)
                        gen.putField(objtype, lb.name, OBJECT_TYPE)
                    )
                )
            )
            else
            (§
                int argoff = canBeDirect ? 0 :or 1
                Class primc = lb.getPrimitiveType()
                if (lb.isArg)
                (§
                    gen.loadArg(lb.idx-argoff)
                    if (primc != nil)
                    (§
                        HostExpr.emitBoxReturn(this, gen, primc)
                    )
                    else if (clear && lb.canBeCleared)
                    (§
                        gen.visitInsn(Opcodes.ACONST_NULL)
                        gen.storeArg(lb.idx - argoff)
                    )
                )
                else
                (§
                    if (primc != nil)
                    (§
                        gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx)
                        HostExpr.emitBoxReturn(this, gen, primc)
                    )
                    else
                    (§
                        gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), lb.idx)
                        if (clear && lb.canBeCleared)
                        (§
                            gen.visitInsn(Opcodes.ACONST_NULL)
                            gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx)
                        )
                    )
                )
            )
        )

        private void emitUnboxedLocal(GeneratorAdapter gen, LocalBinding lb)
        (§
            int argoff = canBeDirect ? 0 :or 1
            Class primc = lb.getPrimitiveType()
            if (closes.containsKey(lb))
            (§
                gen.loadThis()
                gen.getField(objtype, lb.name, Type.getType(primc))
            )
            else if (lb.isArg)
            (§
                gen.loadArg(lb.idx-argoff)
            )
            else
            (§
                gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ILOAD), lb.idx)
            )
        )

        public void emitVar(GeneratorAdapter gen, Var var)
        (§
            Integer i = (Integer) vars.valAt(var)
            emitConstant(gen, i)
        )

        final static Method varGetMethod = Method.getMethod("Object get()")
        final static Method varGetRawMethod = Method.getMethod("Object getRawRoot()")

        public void emitVarValue(GeneratorAdapter gen, Var v)
        (§
            Integer i = (Integer) vars.valAt(v)
            if (!v.isDynamic())
            (§
                emitConstant(gen, i)
                gen.invokeVirtual(VAR_TYPE, varGetRawMethod)
            )
            else
            (§
                emitConstant(gen, i)
                gen.invokeVirtual(VAR_TYPE, varGetMethod)
            )
        )

        public void emitKeyword(GeneratorAdapter gen, Keyword k)
        (§
            Integer i = (Integer) keywords.valAt(k)
            emitConstant(gen, i)
        )

        public void emitConstant(GeneratorAdapter gen, int id)
        (§
            usedConstants = (IPersistentSet) usedConstants.cons(id)
            gen.getStatic(objtype, constantName(id), constantType(id))
        )

        String constantName(int id)
        (§
            (§ return (§ expr CONST_PREFIX + id))
        )

        String siteName(int n)
        (§
            (§ return (§ expr "__site__" + n))
        )

        String siteNameStatic(int n)
        (§
            (§ return (§ expr siteName(n) + "__"))
        )

        String thunkName(int n)
        (§
            (§ return (§ expr "__thunk__" + n))
        )

        String cachedClassName(int n)
        (§
            (§ return (§ expr "__cached_class__" + n))
        )

        String cachedVarName(int n)
        (§
            (§ return (§ expr "__cached_var__" + n))
        )

        String varCallsiteName(int n)
        (§
            (§ return (§ expr "__var__callsite__" + n))
        )

        String thunkNameStatic(int n)
        (§
            (§ return (§ expr thunkName(n) + "__"))
        )

        Type constantType(int id)
        (§
            Object o = constants.nth(id)
            Class c = cloiure.lang.Util.classOf(o)
            if (c!= nil && Modifier.isPublic(c.getModifiers()))
            (§
                ;; can't emit derived fn types due to visibility
                if (LazySeq.class.isAssignableFrom(c))
                (§
                    (§ return (§ expr Type.getType(ISeq.class)))
                )
                else if (c == Keyword.class)
                (§
                    (§ return (§ expr Type.getType(Keyword.class)))
                )
                else if (RestFn.class.isAssignableFrom(c))
                (§
                    (§ return (§ expr Type.getType(RestFn.class)))
                )
                else if (AFn.class.isAssignableFrom(c))
                (§
                    (§ return (§ expr Type.getType(AFn.class)))
                )
                else if (c == Var.class)
                (§
                    (§ return (§ expr Type.getType(Var.class)))
                )
                else if (c == String.class)
                (§
                    (§ return (§ expr Type.getType(String.class)))
                )
            )
            (§ return (§ expr OBJECT_TYPE))
        )
    )

    enum PATHTYPE
    (§
        PATH, BRANCH
    )

    static class PathNode
    (§
        final PATHTYPE type
        final PathNode parent

        PathNode(PATHTYPE type, PathNode parent)
        (§
            this.type = type
            this.parent = parent
        )
    )

    static PathNode clearPathRoot()
    (§
        (§ return (§ expr (PathNode) CLEAR_ROOT.get()))
    )

    enum PSTATE
    (§
        REQ, REST, DONE
    )

    public static class FnMethod extends ObjMethod
    (§
        ;; localbinding->localbinding
        PersistentVector reqParms = PersistentVector.EMPTY
        LocalBinding restParm = nil
        Type[] argtypes
        Class[] argclasses
        Class retClass
        String prim

        public FnMethod(ObjExpr objx, ObjMethod parent)
        (§
            super(objx, parent)
        )

        static public char classChar(Object x)
        (§
            Class c = nil
            if (x instanceof Class)
            (§
                c = (Class) x
            )
            else if (x instanceof Symbol)
            (§
                c = primClass((Symbol) x)
            )
            if (c == nil || !c.isPrimitive())
            (§
                (§ return (§ expr \O))
            )
            if (c == long.class)
            (§
                (§ return (§ expr \L))
            )
            if (c == double.class)
            (§
                (§ return (§ expr \D))
            )
            throw new IllegalArgumentException("Only long and double primitives are supported")
        )

        static public String primInterface(IPersistentVector arglist)
        (§
            StringBuilder sb = new StringBuilder()
            for (int i = 0 i < arglist.count() i++)
            (§
                sb.append(classChar(tagOf(arglist.nth(i))))
            )
            sb.append(classChar(tagOf(arglist)))
            String ret = sb.toString()
            boolean prim = ret.contains("L") || ret.contains("D")
            if (prim && arglist.count() > 4)
            (§
                throw new IllegalArgumentException("fns taking primitives support only 4 or fewer args")
            )
            if (prim)
            (§
                (§ return (§ expr "cloiure.lang.IFn$" + ret))
            )
            (§ return (§ expr nil))
        )

        static FnMethod parse(ObjExpr objx, ISeq form, Object rettag)
        (§
            ;; ([args] body...)
            IPersistentVector parms = (IPersistentVector) RT.first(form)
            ISeq body = RT.next(form)
            try
            (§
                FnMethod method = new FnMethod(objx, (ObjMethod) METHOD.deref())
                method.line = lineDeref()
                method.column = columnDeref()
                ;; register as the current method and set up a new env frame
                PathNode pnode =  (PathNode) CLEAR_PATH.get()
                if (pnode == nil)
                (§
                    pnode = new PathNode(PATHTYPE.PATH, nil)
                )
                Var.pushThreadBindings(RT.mapUniqueKeys(
                            METHOD, method,
                            LOCAL_ENV, LOCAL_ENV.deref(),
                            LOOP_LOCALS, nil,
                            NEXT_LOCAL_NUM, 0,
                            CLEAR_PATH, pnode,
                            CLEAR_ROOT, pnode,
                            CLEAR_SITES, PersistentHashMap.EMPTY,
                            METHOD_RETURN_CONTEXT, RT.T
                ))

                method.prim = primInterface(parms)
                if (method.prim != nil)
                (§
                    method.prim = method.prim.replace(\., \/)
                )

                if (rettag instanceof String)
                (§
                    rettag = Symbol.intern(nil, (String) rettag)
                )
                if (!(rettag instanceof Symbol))
                (§
                    rettag = nil
                )
                if (rettag != nil)
                (§
                    String retstr = ((Symbol)rettag).getName()
                    if (!(retstr.equals("long") || retstr.equals("double")))
                    (§
                        rettag = nil
                    )
                )
                method.retClass = tagClass((tagOf(parms) != nil) ? tagOf(parms) :or rettag)
                if (method.retClass.isPrimitive())
                (§
                    if (!(method.retClass == double.class || method.retClass == long.class))
                    (§
                        throw new IllegalArgumentException("Only long and double primitives are supported")
                    )
                )
                else
                (§
                    method.retClass = Object.class
                )
                ;; register 'this' as local 0
                if (objx.thisName != nil)
                (§
                    registerLocal(Symbol.intern(objx.thisName), nil, nil, false)
                )
                else
                (§
                    getAndIncLocalNum()
                )
                PSTATE state = PSTATE.REQ
                PersistentVector argLocals = PersistentVector.EMPTY
                ArrayList<Type> argtypes = new ArrayList()
                ArrayList<Class> argclasses = new ArrayList()
                for (int i = 0 i < parms.count() i++)
                (§
                    if (!(parms.nth(i) instanceof Symbol))
                    (§
                        throw new IllegalArgumentException("fn params must be Symbols")
                    )
                    Symbol p = (Symbol) parms.nth(i)
                    if (p.getNamespace() != nil)
                    (§
                        throw Util.runtimeException("Can't use qualified name as parameter: " + p)
                    )
                    if (p.equals(_AMP_))
                    (§
                        if (state == PSTATE.REQ)
                        (§
                            state = PSTATE.REST
                        )
                        else
                        (§
                            throw Util.runtimeException("Invalid parameter list")
                        )
                    )

                    else
                    (§
                        Class pc = primClass(tagClass(tagOf(p)))
                        if (pc.isPrimitive() && !(pc == double.class || pc == long.class))
                        (§
                            throw new IllegalArgumentException("Only long and double primitives are supported: " + p)
                        )

                        if (state == PSTATE.REST && tagOf(p) != nil)
                        (§
                            throw Util.runtimeException("& arg cannot have type hint")
                        )
                        if (state == PSTATE.REST && method.prim != nil)
                        (§
                            throw Util.runtimeException("fns taking primitives cannot be variadic")
                        )

                        if (state == PSTATE.REST)
                        (§
                            pc = ISeq.class
                        )
                        argtypes.add(Type.getType(pc))
                        argclasses.add(pc)
                        LocalBinding lb = pc.isPrimitive() ? registerLocal(p, nil, new MethodParamExpr(pc), true) :or registerLocal(p, (state == PSTATE.REST) ? ISEQ :or tagOf(p), nil, true)
                        argLocals = argLocals.cons(lb)
                        switch (state)
                        (§
                            (§ case REQ)
                                method.reqParms = method.reqParms.cons(lb)
                                break
                            (§ case REST)
                                method.restParm = lb
                                state = PSTATE.DONE
                                break
                            (§ default)
                                throw Util.runtimeException("Unexpected parameter")
                        )
                    )
                )
                if (method.reqParms.count() > MAX_POSITIONAL_ARITY)
                (§
                    throw Util.runtimeException("Can't specify more than " + MAX_POSITIONAL_ARITY + " params")
                )
                LOOP_LOCALS.set(argLocals)
                method.argLocals = argLocals
                method.argtypes = argtypes.toArray(new Type[argtypes.size()])
                method.argclasses = argclasses.toArray(new Class[argtypes.size()])
                if (method.prim != nil)
                (§
                    for (int i = 0 i < method.argclasses.length i++)
                    (§
                        if (method.argclasses[i] == long.class || method.argclasses[i] == double.class)
                        (§
                            getAndIncLocalNum()
                        )
                    )
                )
                method.body = (new BodyExpr.Parser()).parse(C.RETURN, body)
                (§ return (§ expr method))
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )

        public void emit(ObjExpr fn, ClassVisitor cv)
        (§
            if (fn.canBeDirect)
            (§
                doEmitStatic(fn, cv)
            )
            else if (prim != nil)
            (§
                doEmitPrim(fn, cv)
            )
            else
            (§
                doEmit(fn, cv)
            )
        )

        public void doEmitStatic(ObjExpr fn, ClassVisitor cv)
        (§
            Type returnType = Type.getType(retClass)

            Method ms = new Method("invokeStatic", returnType, argtypes)

            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC,
                    ms,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()
            Label loopLabel = gen.mark()
            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))
                emitBody(objx, gen, retClass, body)

                Label end = gen.mark()
                for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, argtypes[lb.idx].getDescriptor(), nil, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()

            ;; generate the regular invoke, calling the static method
            Method m = new Method(getMethodName(), OBJECT_TYPE, getArgTypes())

            gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()
            for (int i = 0 i < argtypes.length i++)
            (§
                gen.loadArg(i)
                HostExpr.emitUnboxArg(fn, gen, argclasses[i])
                if (!argclasses[i].isPrimitive())
                (§
                    gen.visitInsn(Opcodes.ACONST_NULL)
                    gen.storeArg(i)
                )
            )
            Label callLabel = gen.mark()
            gen.visitLineNumber(line, callLabel)
            gen.invokeStatic(objx.objtype, ms)
            gen.box(returnType)

            gen.returnValue()
            gen.endMethod()

            ;; generate primInvoke if prim
            if (prim != nil)
            (§
                if (retClass == double.class || retClass == long.class)
                (§
                    returnType = getReturnType()
                )
                else returnType = OBJECT_TYPE

                Method pm = new Method("invokePrim", returnType, argtypes)

                gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
                        pm,
                        nil,
                        ;; todo don't hardwire this
                        EXCEPTION_TYPES,
                        cv)
                gen.visitCode()
                for (int i = 0 i < argtypes.length i++)
                (§
                    gen.loadArg(i)
                    if (!argclasses[i].isPrimitive())
                    (§
                        gen.visitInsn(Opcodes.ACONST_NULL)
                        gen.storeArg(i)
                    )
                )
                gen.invokeStatic(objx.objtype, ms)

                gen.returnValue()
                gen.endMethod()
            )
        )

        public void doEmitPrim(ObjExpr fn, ClassVisitor cv)
        (§
            Type returnType
            if (retClass == double.class || retClass == long.class)
            (§
                returnType = getReturnType()
            )
            else
            (§
                returnType = OBJECT_TYPE
            )
            Method ms = new Method("invokePrim", returnType, argtypes)

            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_FINAL,
                    ms,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()

            Label loopLabel = gen.mark()
            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))
                emitBody(objx, gen, retClass, body)

                Label end = gen.mark()
                gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, argtypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()

            ;; generate the regular invoke, calling the prim method
            Method m = new Method(getMethodName(), OBJECT_TYPE, getArgTypes())

            gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()
            gen.loadThis()
            for (int i = 0 i < argtypes.length i++)
            (§
                gen.loadArg(i)
                HostExpr.emitUnboxArg(fn, gen, argclasses[i])
            )
            gen.invokeInterface(Type.getType("L"+prim+";"), ms)
            gen.box(getReturnType())

            gen.returnValue()
            gen.endMethod()
        )

        public void doEmit(ObjExpr fn, ClassVisitor cv)
        (§
            Method m = new Method(getMethodName(), getReturnType(), getArgTypes())

            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()

            Label loopLabel = gen.mark()
            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))

                body.emit(C.RETURN, fn, gen)
                Label end = gen.mark()

                gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()
        )

        public final PersistentVector reqParms()
        (§
            (§ return (§ expr reqParms))
        )

        public final LocalBinding restParm()
        (§
            (§ return (§ expr restParm))
        )

        boolean isVariadic()
        (§
            (§ return (§ expr (restParm != nil)))
        )

        int numParams()
        (§
            (§ return (§ expr reqParms.count() + (isVariadic() ? 1 :or 0)))
        )

        String getMethodName()
        (§
            (§ return (§ expr isVariadic() ? "doInvoke" :or "invoke"))
        )

        Type getReturnType()
        (§
            if (prim != nil) ;; objx.isStatic
            (§
                (§ return (§ expr Type.getType(retClass)))
            )
            (§ return (§ expr OBJECT_TYPE))
        )

        Type[] getArgTypes()
        (§
            if (isVariadic() && reqParms.count() == MAX_POSITIONAL_ARITY)
            (§
                Type[] ret = new Type[MAX_POSITIONAL_ARITY + 1]
                for (int i = 0 i < MAX_POSITIONAL_ARITY + 1 i++)
                (§
                    ret[i] = OBJECT_TYPE
                )
                (§ return (§ expr ret))
            )
            (§ return (§ expr  ARG_TYPES[numParams()]))
        )

        void emitClearLocals(GeneratorAdapter gen)
        (§
        )
    )

    abstract public static class ObjMethod
    (§
        ;; when closures are defined inside other closures,
        ;; the closed over locals need to be propagated to the enclosing objx
        public final ObjMethod parent
        ;; localbinding->localbinding
        IPersistentMap locals = nil
        ;; num->localbinding
        IPersistentMap indexlocals = nil
        Expr body = nil
        ObjExpr objx
        PersistentVector argLocals
        int maxLocal = 0
        int line
        int column
        boolean usesThis = false
        PersistentHashSet localsUsedInCatchFinally = PersistentHashSet.EMPTY
        protected IPersistentMap methodMeta

        public final IPersistentMap locals()
        (§
            (§ return (§ expr locals))
        )

        public final Expr body()
        (§
            (§ return (§ expr body))
        )

        public final ObjExpr objx()
        (§
            (§ return (§ expr objx))
        )

        public final PersistentVector argLocals()
        (§
            (§ return (§ expr argLocals))
        )

        public final int maxLocal()
        (§
            (§ return (§ expr maxLocal))
        )

        public final int line()
        (§
            (§ return (§ expr line))
        )

        public final int column()
        (§
            (§ return (§ expr column))
        )

        public ObjMethod(ObjExpr objx, ObjMethod parent)
        (§
            this.parent = parent
            this.objx = objx
        )

        static void emitBody(ObjExpr objx, GeneratorAdapter gen, Class retClass, Expr body)
        (§
            MaybePrimitiveExpr be = (MaybePrimitiveExpr) body
            if (Util.isPrimitive(retClass) && be.canEmitPrimitive())
            (§
                Class bc = maybePrimitiveType(be)
                if (bc == retClass)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                )
                else if (retClass == long.class && bc == int.class)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                    gen.visitInsn(I2L)
                )
                else if (retClass == double.class && bc == float.class)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                    gen.visitInsn(F2D)
                )
                else if (retClass == int.class && bc == long.class)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                    gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)"))
                )
                else if (retClass == float.class && bc == double.class)
                (§
                    be.emitUnboxed(C.RETURN, objx, gen)
                    gen.visitInsn(D2F)
                )
                else
                (§
                    throw new IllegalArgumentException("Mismatched primitive return, expected: " + retClass + ", had: " + be.getJavaClass())
                )
            )
            else
            (§
                body.emit(C.RETURN, objx, gen)
                if (retClass == void.class)
                (§
                    gen.pop()
                )
                else
                (§
                    gen.unbox(Type.getType(retClass))
                )
            )
        )

        abstract int numParams()
        abstract String getMethodName()
        abstract Type getReturnType()
        abstract Type[] getArgTypes()

        public void emit(ObjExpr fn, ClassVisitor cv)
        (§
            Method m = new Method(getMethodName(), getReturnType(), getArgTypes())

            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC,
                    m,
                    nil,
                    ;; todo don't hardwire this
                    EXCEPTION_TYPES,
                    cv)
            gen.visitCode()

            Label loopLabel = gen.mark()
            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))

                body.emit(C.RETURN, fn, gen)
                Label end = gen.mark()
                gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, "Ljava/lang/Object;", nil, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()
        )

        void emitClearLocals(GeneratorAdapter gen)
        (§
        )

        void emitClearLocalsOld(GeneratorAdapter gen)
        (§
            for (int i = 0 i < argLocals.count() i++)
            (§
                LocalBinding lb = (LocalBinding) argLocals.nth(i)
                if (!localsUsedInCatchFinally.contains(lb.idx) && lb.getPrimitiveType() == nil)
                (§
                    gen.visitInsn(Opcodes.ACONST_NULL)
                    gen.storeArg(lb.idx - 1)
                )
            )
            for (int i = numParams() + 1 i < maxLocal + 1 i++)
            (§
                if (!localsUsedInCatchFinally.contains(i))
                (§
                    LocalBinding b = (LocalBinding) RT.get(indexlocals, i)
                    if (b == nil || maybePrimitiveType(b.init) == nil)
                    (§
                        gen.visitInsn(Opcodes.ACONST_NULL)
                        gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), i)
                    )
                )
            )
        )

        void emitClearThis(GeneratorAdapter gen)
        (§
            gen.visitInsn(Opcodes.ACONST_NULL)
            gen.visitVarInsn(Opcodes.ASTORE, 0)
        )
    )

    public static class LocalBinding
    (§
        public final Symbol sym
        public final Symbol tag
        public Expr init
        int idx
        public final String name
        public final boolean isArg
        public final PathNode clearPathRoot
        public boolean canBeCleared = !RT.booleanCast(getCompilerOption(disableLocalsClearingKey))
        public boolean recurMistmatch = false
        public boolean used = false

        public LocalBinding(int num, Symbol sym, Symbol tag, Expr init, boolean isArg, PathNode clearPathRoot)
        (§
            if (maybePrimitiveType(init) != nil && tag != nil)
            (§
                throw new UnsupportedOperationException("Can't type hint a local with a primitive initializer")
            )
            this.idx = num
            this.sym = sym
            this.tag = tag
            this.init = init
            this.isArg = isArg
            this.clearPathRoot = clearPathRoot
            name = munge(sym.name)
        )

        Boolean hjc

        public boolean hasJavaClass()
        (§
            if (hjc == nil)
            (§
                if (init != nil && init.hasJavaClass() && Util.isPrimitive(init.getJavaClass()) && !(init instanceof MaybePrimitiveExpr))
                (§
                    hjc =  false
                )
                else
                (§
                    hjc = (tag != nil || (init != nil && init.hasJavaClass()))
                )
            )
            (§ return (§ expr hjc))
        )

        Class jc

        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                jc = (tag != nil) ? HostExpr.tagToClass(tag) :or init.getJavaClass()
            )
            (§ return (§ expr jc))
        )

        public Class getPrimitiveType()
        (§
            (§ return (§ expr maybePrimitiveType(init)))
        )
    )

    public static class LocalBindingExpr implements Expr, MaybePrimitiveExpr, AssignableExpr
    (§
        public final LocalBinding b
        public final Symbol tag

        public final PathNode clearPath
        public final PathNode clearRoot
        public boolean shouldClear = false

        public LocalBindingExpr(LocalBinding b, Symbol tag)
        (§
            if (b.getPrimitiveType() != nil && tag != nil)
            (§
                throw new UnsupportedOperationException("Can't type hint a primitive local")
            )
            this.b = b
            this.tag = tag

            this.clearPath = (PathNode)CLEAR_PATH.get()
            this.clearRoot = (PathNode)CLEAR_ROOT.get()
            IPersistentCollection sites = (IPersistentCollection) RT.get(CLEAR_SITES.get(), b)
            b.used = true

            if (b.idx > 0)
            (§
                if (sites != nil)
                (§
                    for (ISeq s = sites.seq() s != nil s = s.next())
                    (§
                        LocalBindingExpr o = (LocalBindingExpr) s.first()
                        PathNode common = commonPath(clearPath, o.clearPath)
                        if (common != nil && common.type == PATHTYPE.PATH)
                        (§
                            o.shouldClear = false
                        )
                    )
                )

                if (clearRoot == b.clearPathRoot)
                (§
                    this.shouldClear = true
                    sites = RT.conj(sites, this)
                    CLEAR_SITES.set(RT.assoc(CLEAR_SITES.get(), b, sites))
                )
            )
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval locals")
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr (b.getPrimitiveType() != nil)))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            objx.emitUnboxedLocal(gen, b)
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            if (context != C.STATEMENT)
            (§
                objx.emitLocal(gen, b, shouldClear)
            )
        )

        public Object evalAssign(Expr val)
        (§
            throw new UnsupportedOperationException("Can't eval locals")
        )

        public void emitAssign(C context, ObjExpr objx, GeneratorAdapter gen, Expr val)
        (§
            objx.emitAssignLocal(gen, b, val)
            if (context != C.STATEMENT)
            (§
                objx.emitLocal(gen, b, false)
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (tag != nil || b.hasJavaClass())))
        )

        Class jc
        public Class getJavaClass()
        (§
            if (jc == nil)
            (§
                if (tag != nil)
                (§
                    jc = HostExpr.tagToClass(tag)
                )
                else
                (§
                    jc = b.getJavaClass()
                )
            )
            (§ return (§ expr jc))
        )
    )

    public static class BodyExpr implements Expr, MaybePrimitiveExpr
    (§
        PersistentVector exprs

        public final PersistentVector exprs()
        (§
            (§ return (§ expr exprs))
        )

        public BodyExpr(PersistentVector exprs)
        (§
            this.exprs = exprs
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frms)
            (§
                ISeq forms = (ISeq) frms
                if (Util.equals(RT.first(forms), DO))
                (§
                    forms = RT.next(forms)
                )
                PersistentVector exprs = PersistentVector.EMPTY
                for (  forms != nil forms = forms.next())
                (§
                    Expr e = (context != C.EVAL && (context == C.STATEMENT || forms.next() != nil)) ? analyze(C.STATEMENT, forms.first()) :or analyze(context, forms.first())
                    exprs = exprs.cons(e)
                )
                if (exprs.count() == 0)
                (§
                    exprs = exprs.cons(NIL_EXPR)
                )
                (§ return (§ expr new BodyExpr(exprs)))
            )
        )

        public Object eval()
        (§
            Object ret = nil
            for (Object o :in exprs)
            (§
                Expr e = (Expr) o
                ret = e.eval()
            )
            (§ return (§ expr ret))
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive())))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            for (int i = 0 i < exprs.count() - 1 i++)
            (§
                Expr e = (Expr) exprs.nth(i)
                e.emit(C.STATEMENT, objx, gen)
            )
            MaybePrimitiveExpr last = (MaybePrimitiveExpr) exprs.nth(exprs.count() - 1)
            last.emitUnboxed(context, objx, gen)
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            for (int i = 0 i < exprs.count() - 1 i++)
            (§
                Expr e = (Expr) exprs.nth(i)
                e.emit(C.STATEMENT, objx, gen)
            )
            Expr last = (Expr) exprs.nth(exprs.count() - 1)
            last.emit(context, objx, gen)
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr lastExpr().hasJavaClass()))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr lastExpr().getJavaClass()))
        )

        private Expr lastExpr()
        (§
            (§ return (§ expr (Expr) exprs.nth(exprs.count() - 1)))
        )
    )

    public static class BindingInit
    (§
        LocalBinding binding
        Expr init

        public final LocalBinding binding()
        (§
            (§ return (§ expr binding))
        )

        public final Expr init()
        (§
            (§ return (§ expr init))
        )

        public BindingInit(LocalBinding binding, Expr init)
        (§
            this.binding = binding
            this.init = init
        )
    )

    public static class LetFnExpr implements Expr
    (§
        public final PersistentVector bindingInits
        public final Expr body

        public LetFnExpr(PersistentVector bindingInits, Expr body)
        (§
            this.bindingInits = bindingInits
            this.body = body
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                ;; (letfns* [var (fn [args] body) ...] body...)
                if (!(RT.second(form) instanceof IPersistentVector))
                (§
                    throw new IllegalArgumentException("Bad binding form, expected vector")
                )

                IPersistentVector bindings = (IPersistentVector) RT.second(form)
                if ((bindings.count() % 2) != 0)
                (§
                    throw new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")
                )

                ISeq body = RT.next(RT.next(form))

                if (context == C.EVAL)
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref())

                try
                (§
                    Var.pushThreadBindings(dynamicBindings)

                    ;; pre-seed env (like Lisp labels)
                    PersistentVector lbs = PersistentVector.EMPTY
                    for (int i = 0 i < bindings.count() i += 2)
                    (§
                        if (!(bindings.nth(i) instanceof Symbol))
                        (§
                            throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))
                        )
                        Symbol sym = (Symbol) bindings.nth(i)
                        if (sym.getNamespace() != nil)
                        (§
                            throw Util.runtimeException("Can't let qualified name: " + sym)
                        )
                        LocalBinding lb = registerLocal(sym, tagOf(sym), nil, false)
                        lb.canBeCleared = false
                        lbs = lbs.cons(lb)
                    )
                    PersistentVector bindingInits = PersistentVector.EMPTY
                    for (int i = 0 i < bindings.count() i += 2)
                    (§
                        Symbol sym = (Symbol) bindings.nth(i)
                        Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name)
                        LocalBinding lb = (LocalBinding) lbs.nth(i / 2)
                        lb.init = init
                        BindingInit bi = new BindingInit(lb, init)
                        bindingInits = bindingInits.cons(bi)
                    )
                    (§ return (§ expr new LetFnExpr(bindingInits, (new BodyExpr.Parser()).parse(context, body))))
                )
                finally
                (§
                    Var.popThreadBindings()
                )
            )
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval letfns")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            for (int i = 0 i < bindingInits.count() i++)
            (§
                BindingInit bi = (BindingInit) bindingInits.nth(i)
                gen.visitInsn(Opcodes.ACONST_NULL)
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx)
            )

            IPersistentSet lbset = PersistentHashSet.EMPTY

            for (int i = 0 i < bindingInits.count() i++)
            (§
                BindingInit bi = (BindingInit) bindingInits.nth(i)
                lbset = (IPersistentSet) lbset.cons(bi.binding)
                bi.init.emit(C.EXPRESSION, objx, gen)
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx)
            )

            for (int i = 0 i < bindingInits.count() i++)
            (§
                BindingInit bi = (BindingInit) bindingInits.nth(i)
                ObjExpr fe = (ObjExpr) bi.init
                gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ILOAD), bi.binding.idx)
                fe.emitLetFnInits(gen, objx, lbset)
            )

            Label loopLabel = gen.mark()

            body.emit(context, objx, gen)

            Label end = gen.mark()
            for (ISeq bis = bindingInits.seq() bis != nil bis = bis.next())
            (§
                BindingInit bi = (BindingInit) bis.first()
                String lname = bi.binding.name
                if (lname.endsWith("__auto__"))
                (§
                    lname += RT.nextID()
                )
                Class primc = maybePrimitiveType(bi.init)
                if (primc != nil)
                (§
                    gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, loopLabel, end, bi.binding.idx)
                )
                else
                (§
                    gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, loopLabel, end, bi.binding.idx)
                )
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr body.hasJavaClass()))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr body.getJavaClass()))
        )
    )

    public static class LetExpr implements Expr, MaybePrimitiveExpr
    (§
        public final PersistentVector bindingInits
        public final Expr body
        public final boolean isLoop

        public LetExpr(PersistentVector bindingInits, Expr body, boolean isLoop)
        (§
            this.bindingInits = bindingInits
            this.body = body
            this.isLoop = isLoop
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                ;; (let [var val var2 val2 ...] body...)
                boolean isLoop = RT.first(form).equals(LOOP)
                if (!(RT.second(form) instanceof IPersistentVector))
                (§
                    throw new IllegalArgumentException("Bad binding form, expected vector")
                )

                IPersistentVector bindings = (IPersistentVector) RT.second(form)
                if ((bindings.count() % 2) != 0)
                (§
                    throw new IllegalArgumentException("Bad binding form, expected matched symbol expression pairs")
                )

                ISeq body = RT.next(RT.next(form))

                if (context == C.EVAL || (context == C.EXPRESSION && isLoop))
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )

                ObjMethod method = (ObjMethod) METHOD.deref()
                IPersistentMap backupMethodLocals = method.locals
                IPersistentMap backupMethodIndexLocals = method.indexlocals
                IPersistentVector recurMismatches = PersistentVector.EMPTY
                for (int i = 0 i < bindings.count() / 2 i++)
                (§
                    recurMismatches = recurMismatches.cons(RT.F)
                )

                ;; may repeat once for each binding with a mismatch, return breaks
                while (true)
                (§
                    IPersistentMap dynamicBindings = RT.map(LOCAL_ENV, LOCAL_ENV.deref(), NEXT_LOCAL_NUM, NEXT_LOCAL_NUM.deref())
                    method.locals = backupMethodLocals
                    method.indexlocals = backupMethodIndexLocals

                    PathNode looproot = new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get())
                    PathNode clearroot = new PathNode(PATHTYPE.PATH, looproot)
                    PathNode clearpath = new PathNode(PATHTYPE.PATH, looproot)
                    if (isLoop)
                    (§
                        dynamicBindings = dynamicBindings.assoc(LOOP_LOCALS, nil)
                    )

                    try
                    (§
                        Var.pushThreadBindings(dynamicBindings)

                        PersistentVector bindingInits = PersistentVector.EMPTY
                        PersistentVector loopLocals = PersistentVector.EMPTY
                        for (int i = 0 i < bindings.count() i += 2)
                        (§
                            if (!(bindings.nth(i) instanceof Symbol))
                            (§
                                throw new IllegalArgumentException("Bad binding form, expected symbol, got: " + bindings.nth(i))
                            )
                            Symbol sym = (Symbol) bindings.nth(i)
                            if (sym.getNamespace() != nil)
                            (§
                                throw Util.runtimeException("Can't let qualified name: " + sym)
                            )
                            Expr init = analyze(C.EXPRESSION, bindings.nth(i + 1), sym.name)
                            if (isLoop)
                            (§
                                if (recurMismatches != nil && RT.booleanCast(recurMismatches.nth(i / 2)))
                                (§
                                    init = new StaticMethodExpr("", 0, 0, nil, RT.class, "box", RT.vector(init), false)
                                    if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                                    (§
                                        RT.errPrintWriter().println("Auto-boxing loop arg: " + sym)
                                    )
                                )
                                else if (maybePrimitiveType(init) == int.class)
                                (§
                                    init = new StaticMethodExpr("", 0, 0, nil, RT.class, "longCast", RT.vector(init), false)
                                )
                                else if (maybePrimitiveType(init) == float.class)
                                (§
                                    init = new StaticMethodExpr("", 0, 0, nil, RT.class, "doubleCast", RT.vector(init), false)
                                )
                            )
                            ;; sequential enhancement of env (like Lisp let*)
                            try
                            (§
                                if (isLoop)
                                (§
                                    Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath, CLEAR_ROOT, clearroot, NO_RECUR, nil))
                                )
                                LocalBinding lb = registerLocal(sym, tagOf(sym), init, false)
                                BindingInit bi = new BindingInit(lb, init)
                                bindingInits = bindingInits.cons(bi)
                                if (isLoop)
                                (§
                                    loopLocals = loopLocals.cons(lb)
                                )
                            )
                            finally
                            (§
                                if (isLoop)
                                (§
                                    Var.popThreadBindings()
                                )
                            )
                        )
                        if (isLoop)
                        (§
                            LOOP_LOCALS.set(loopLocals)
                        )
                        Expr bodyExpr
                        boolean moreMismatches = false
                        try
                        (§
                            if (isLoop)
                            (§
                                Object methodReturnContext = (context == C.RETURN) ? METHOD_RETURN_CONTEXT.deref() :or nil
                                Var.pushThreadBindings(RT.map(CLEAR_PATH, clearpath,
                                            CLEAR_ROOT, clearroot,
                                            NO_RECUR, nil,
                                            METHOD_RETURN_CONTEXT, methodReturnContext
                                ))
                            )
                            bodyExpr = (new BodyExpr.Parser()).parse(isLoop ? C.RETURN :or context, body)
                        )
                        finally
                        (§
                            if (isLoop)
                            (§
                                Var.popThreadBindings()
                                for (int i = 0 i < loopLocals.count() i++)
                                (§
                                    LocalBinding lb = (LocalBinding) loopLocals.nth(i)
                                    if (lb.recurMistmatch)
                                    (§
                                        recurMismatches = (IPersistentVector)recurMismatches.assoc(i, RT.T)
                                        moreMismatches = true
                                    )
                                )
                            )
                        )
                        if (!moreMismatches)
                        (§
                            (§ return (§ expr new LetExpr(bindingInits, bodyExpr, isLoop)))
                        )
                    )
                    finally
                    (§
                        Var.popThreadBindings()
                    )
                )
            )
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval let/loop")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, false)
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, true)
        )

        public void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
        (§
            HashMap<BindingInit, Label> bindingLabels = new HashMap()
            for (int i = 0 i < bindingInits.count() i++)
            (§
                BindingInit bi = (BindingInit) bindingInits.nth(i)
                Class primc = maybePrimitiveType(bi.init)
                if (primc != nil)
                (§
                    ((MaybePrimitiveExpr) bi.init).emitUnboxed(C.EXPRESSION, objx, gen)
                    gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), bi.binding.idx)
                )
                else
                (§
                    bi.init.emit(C.EXPRESSION, objx, gen)
                    if (!bi.binding.used && bi.binding.canBeCleared)
                    (§
                        gen.pop()
                    )
                    else
                    (§
                        gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), bi.binding.idx)
                    )
                )
                bindingLabels.put(bi, gen.mark())
            )
            Label loopLabel = gen.mark()
            if (isLoop)
            (§
                try
                (§
                    Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel))
                    if (emitUnboxed)
                    (§
                        ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen)
                    )
                    else
                    (§
                        body.emit(context, objx, gen)
                    )
                )
                finally
                (§
                    Var.popThreadBindings()
                )
            )
            else
            (§
                if (emitUnboxed)
                (§
                    ((MaybePrimitiveExpr)body).emitUnboxed(context, objx, gen)
                )
                else
                (§
                    body.emit(context, objx, gen)
                )
            )
            Label end = gen.mark()
            for (ISeq bis = bindingInits.seq() bis != nil bis = bis.next())
            (§
                BindingInit bi = (BindingInit) bis.first()
                String lname = bi.binding.name
                if (lname.endsWith("__auto__"))
                (§
                    lname += RT.nextID()
                )
                Class primc = maybePrimitiveType(bi.init)
                if (primc != nil)
                (§
                    gen.visitLocalVariable(lname, Type.getDescriptor(primc), nil, bindingLabels.get(bi), end, bi.binding.idx)
                )
                else
                (§
                    gen.visitLocalVariable(lname, "Ljava/lang/Object;", nil, bindingLabels.get(bi), end, bi.binding.idx)
                )
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr body.hasJavaClass()))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr body.getJavaClass()))
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr (body instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)body).canEmitPrimitive())))
        )
    )

    public static class RecurExpr implements Expr, MaybePrimitiveExpr
    (§
        public final IPersistentVector args
        public final IPersistentVector loopLocals

        final int line
        final int column
        final String source

        public RecurExpr(IPersistentVector loopLocals, IPersistentVector args, int line, int column, String source)
        (§
            this.loopLocals = loopLocals
            this.args = args
            this.line = line
            this.column = column
            this.source = source
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval recur")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            Label loopLabel = (Label) LOOP_LABEL.deref()
            if (loopLabel == nil)
            (§
                throw new IllegalStateException()
            )
            for (int i = 0 i < loopLocals.count() i++)
            (§
                LocalBinding lb = (LocalBinding) loopLocals.nth(i)
                Expr arg = (Expr) args.nth(i)
                if (lb.getPrimitiveType() != nil)
                (§
                    Class primc = lb.getPrimitiveType()
                    final Class pc = maybePrimitiveType(arg)
                    if (pc == primc)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                    )
                    else if (primc == long.class && pc == int.class)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(I2L)
                    )
                    else if (primc == double.class && pc == float.class)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(F2D)
                    )
                    else if (primc == int.class && pc == long.class)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.invokeStatic(RT_TYPE, Method.getMethod("int intCast(long)"))
                    )
                    else if (primc == float.class && pc == double.class)
                    (§
                        ((MaybePrimitiveExpr) arg).emitUnboxed(C.EXPRESSION, objx, gen)
                        gen.visitInsn(D2F)
                    )
                    else
                    (§
                        throw new IllegalArgumentException("recur arg for primitive local: " + lb.name + " is not matching primitive, had: " + (arg.hasJavaClass() ? arg.getJavaClass().getName() :or "Object") + ", needed: " + primc.getName())
                    )
                )
                else
                (§
                    arg.emit(C.EXPRESSION, objx, gen)
                )
            )

            for (int i = loopLocals.count() - 1 i >= 0 i--)
            (§
                LocalBinding lb = (LocalBinding) loopLocals.nth(i)
                Class primc = lb.getPrimitiveType()
                if (lb.isArg)
                (§
                    gen.storeArg(lb.idx - (objx.canBeDirect ? 0 :or 1))
                )
                else
                (§
                    if (primc != nil)
                    (§
                        gen.visitVarInsn(Type.getType(primc).getOpcode(Opcodes.ISTORE), lb.idx)
                    )
                    else
                    (§
                        gen.visitVarInsn(OBJECT_TYPE.getOpcode(Opcodes.ISTORE), lb.idx)
                    )
                )
            )

            gen.goTo(loopLabel)
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr true))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr RECUR_CLASS))
        )

        static class Parser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                int line = lineDeref()
                int column = columnDeref()
                String source = (String) SOURCE.deref()

                ISeq form = (ISeq) frm
                IPersistentVector loopLocals = (IPersistentVector) LOOP_LOCALS.deref()
                if (context != C.RETURN || loopLocals == nil)
                (§
                    throw new UnsupportedOperationException("Can only recur from tail position")
                )
                if (NO_RECUR.deref() != nil)
                (§
                    throw new UnsupportedOperationException("Cannot recur across try")
                )
                PersistentVector args = PersistentVector.EMPTY
                for (ISeq s = RT.seq(form.next()) s != nil s = s.next())
                (§
                    args = args.cons(analyze(C.EXPRESSION, s.first()))
                )
                if (args.count() != loopLocals.count())
                (§
                    throw new IllegalArgumentException(String.format("Mismatched argument count to recur, expected: %d args, got: %d", loopLocals.count(), args.count()))
                )
                for (int i = 0 i < loopLocals.count() i++)
                (§
                    LocalBinding lb = (LocalBinding) loopLocals.nth(i)
                    Class primc = lb.getPrimitiveType()
                    if (primc != nil)
                    (§
                        boolean mismatch = false
                        final Class pc = maybePrimitiveType((Expr) args.nth(i))
                        if (primc == long.class)
                        (§
                            if (!(pc == long.class || pc == int.class || pc == short.class || pc == char.class || pc == byte.class))
                            (§
                                mismatch = true
                            )
                        )
                        else if (primc == double.class)
                        (§
                            if (!(pc == double.class || pc == float.class))
                            (§
                                mismatch = true
                            )
                        )
                        if (mismatch)
                        (§
                            lb.recurMistmatch = true
                            if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                            (§
                                RT.errPrintWriter().println(source + ":" + line + " recur arg for primitive local: " + lb.name + " is not matching primitive, had: " +
                                     ((pc != nil) ? pc.getName() :or "Object") + ", needed: " + primc.getName())
                            )
                        )
                    )
                )
                (§ return (§ expr new RecurExpr(loopLocals, args, line, column, source)))
            )
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr true))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            emit(context, objx, gen)
        )
    )

    private static LocalBinding registerLocal(Symbol sym, Symbol tag, Expr init, boolean isArg)
    (§
        int num = getAndIncLocalNum()
        LocalBinding b = new LocalBinding(num, sym, tag, init, isArg, clearPathRoot())
        IPersistentMap localsMap = (IPersistentMap) LOCAL_ENV.deref()
        LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b))
        ObjMethod method = (ObjMethod) METHOD.deref()
        method.locals = (IPersistentMap) RT.assoc(method.locals, b, b)
        method.indexlocals = (IPersistentMap) RT.assoc(method.indexlocals, num, b)
        (§ return (§ expr b))
    )

    private static int getAndIncLocalNum()
    (§
        int num = ((Number) NEXT_LOCAL_NUM.deref()).intValue()
        ObjMethod m = (ObjMethod) METHOD.deref()
        if (num > m.maxLocal)
        (§
            m.maxLocal = num
        )
        NEXT_LOCAL_NUM.set(num + 1)
        (§ return (§ expr num))
    )

    public static Expr analyze(C context, Object form)
    (§
        (§ return (§ expr analyze(context, form, nil)))
    )

    private static Expr analyze(C context, Object form, String name)
    (§
        ;; todo symbol macro expansion?
        try
        (§
            if (form instanceof LazySeq)
            (§
                Object mform = form
                form = RT.seq(form)
                if (form == nil)
                (§
                    form = PersistentList.EMPTY
                )
                form = ((IObj)form).withMeta(RT.meta(mform))
            )
            if (form == nil)
            (§
                (§ return (§ expr NIL_EXPR))
            )
            else if (form == Boolean.TRUE)
            (§
                (§ return (§ expr TRUE_EXPR))
            )
            else if (form == Boolean.FALSE)
            (§
                (§ return (§ expr FALSE_EXPR))
            )
            Class fclass = form.getClass()
            if (fclass == Symbol.class)
            (§
                (§ return (§ expr analyzeSymbol((Symbol) form)))
            )
            else if (fclass == Keyword.class)
            (§
                (§ return (§ expr registerKeyword((Keyword) form)))
            )
            else if (form instanceof Number)
            (§
                (§ return (§ expr NumberExpr.parse((Number) form)))
            )
            else if (fclass == String.class)
            (§
                (§ return (§ expr new StringExpr(((String) form).intern())))
            )
            else if (form instanceof IPersistentCollection && !(form instanceof IRecord) && !(form instanceof IType) && ((IPersistentCollection) form).count() == 0)
            (§
                Expr ret = new EmptyExpr(form)
                if (RT.meta(form) != nil)
                (§
                    ret = new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) form).meta()))
                )
                (§ return (§ expr ret))
            )
            else if (form instanceof ISeq)
            (§
                (§ return (§ expr analyzeSeq(context, (ISeq) form, name)))
            )
            else if (form instanceof IPersistentVector)
            (§
                (§ return (§ expr VectorExpr.parse(context, (IPersistentVector) form)))
            )
            else if (form instanceof IRecord)
            (§
                (§ return (§ expr new ConstantExpr(form)))
            )
            else if (form instanceof IType)
            (§
                (§ return (§ expr new ConstantExpr(form)))
            )
            else if (form instanceof IPersistentMap)
            (§
                (§ return (§ expr MapExpr.parse(context, (IPersistentMap) form)))
            )
            else if (form instanceof IPersistentSet)
            (§
                (§ return (§ expr SetExpr.parse(context, (IPersistentSet) form)))
            )

            (§ return (§ expr new ConstantExpr(form)))
        )
        catch (Throwable e)
        (§
            if (!(e instanceof CompilerException))
            (§
                throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)
            )
            else
            (§
                throw (CompilerException) e
            )
        )
    )

    static public class CompilerException extends RuntimeException
    (§
        final public String source

        final public int line

        public CompilerException(String source, int line, int column, Throwable cause)
        (§
            super(errorMsg(source, line, column, cause.toString()), cause)
            this.source = source
            this.line = line
        )

        public String toString()
        (§
            (§ return (§ expr getMessage()))
        )
    )

    static public Var isMacro(Object op)
    (§
        ;; no local macros for now
        if (op instanceof Symbol && referenceLocal((Symbol) op) != nil)
        (§
            (§ return (§ expr nil))
        )
        if (op instanceof Symbol || op instanceof Var)
        (§
            Var v = (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false, false)
            if (v != nil && v.isMacro())
            (§
                if (v.ns != currentNS() && !v.isPublic())
                (§
                    throw new IllegalStateException("var: " + v + " is not public")
                )
                (§ return (§ expr v))
            )
        )
        (§ return (§ expr nil))
    )

    static public IFn isInline(Object op, int arity)
    (§
        ;; no local inlines for now
        if (op instanceof Symbol && referenceLocal((Symbol) op) != nil)
        (§
            (§ return (§ expr nil))
        )
        if (op instanceof Symbol || op instanceof Var)
        (§
            Var v = (op instanceof Var) ? (Var) op :or lookupVar((Symbol) op, false)
            if (v != nil)
            (§
                if (v.ns != currentNS() && !v.isPublic())
                (§
                    throw new IllegalStateException("var: " + v + " is not public")
                )
                IFn ret = (IFn) RT.get(v.meta(), inlineKey)
                if (ret != nil)
                (§
                    IFn arityPred = (IFn) RT.get(v.meta(), inlineAritiesKey)
                    if (arityPred == nil || RT.booleanCast(arityPred.invoke(arity)))
                    (§
                        (§ return (§ expr ret))
                    )
                )
            )
        )
        (§ return (§ expr nil))
    )

    public static boolean namesStaticMember(Symbol sym)
    (§
        (§ return (§ expr (sym.ns != nil && namespaceFor(sym) == nil)))
    )

    public static Object preserveTag(ISeq src, Object dst)
    (§
        Symbol tag = tagOf(src)
        if (tag != nil && dst instanceof IObj)
        (§
            IPersistentMap meta = RT.meta(dst)
            (§ return (§ expr ((IObj) dst).withMeta((IPersistentMap) RT.assoc(meta, RT.TAG_KEY, tag))))
        )
        (§ return (§ expr dst))
    )

    private static volatile Var MACRO_CHECK = nil
    private static volatile boolean MACRO_CHECK_LOADING = false
    private static final Object MACRO_CHECK_LOCK = new Object()

    private static Var ensureMacroCheck() throws ClassNotFoundException, IOException
    (§
        if (MACRO_CHECK == nil)
        (§
            synchronized (MACRO_CHECK_LOCK)
            (§
                if (MACRO_CHECK == nil)
                (§
                    MACRO_CHECK_LOADING = true
                    RT.load("cloiure/spec/alpha")
                    RT.load("cloiure/core/specs/alpha")
                    MACRO_CHECK = Var.find(Symbol.intern("cloiure.spec.alpha", "macroexpand-check"))
                    MACRO_CHECK_LOADING = false
                )
            )
        )
        (§ return (§ expr MACRO_CHECK))
    )

    public static void checkSpecs(Var v, ISeq form)
    (§
        if (RT.CHECK_SPECS && !MACRO_CHECK_LOADING)
        (§
            try
            (§
                ensureMacroCheck().applyTo(RT.cons(v, RT.list(form.next())))
            )
            catch (Exception e)
            (§
                throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)
            )
        )
    )

    public static Object macroexpand1(Object x)
    (§
        if (x instanceof ISeq)
        (§
            ISeq form = (ISeq) x
            Object op = RT.first(form)
            if (isSpecial(op))
            (§
                (§ return (§ expr x))
            )
            ;; macro expansion
            Var v = isMacro(op)
            if (v != nil)
            (§
                checkSpecs(v, form)

                try
                (§
                    ISeq args = RT.cons(form, RT.cons(Compiler.LOCAL_ENV.get(), form.next()))
                    (§ return (§ expr v.applyTo(args)))
                )
                catch (ArityException e)
                (§
                    ;; hide the 2 extra params for a macro
                    throw new ArityException(e.actual - 2, e.name)
                )
            )
            else
            (§
                if (op instanceof Symbol)
                (§
                    Symbol sym = (Symbol) op
                    String sname = sym.name
                    ;; (.substring s 2 5) => (. s substring 2 5)
                    if (sym.name.charAt(0) == \.)
                    (§
                        if (RT.length(form) < 2)
                        (§
                            throw new IllegalArgumentException("Malformed member expression, expecting (.member target ...)")
                        )
                        Symbol meth = Symbol.intern(sname.substring(1))
                        Object target = RT.second(form)
                        if (HostExpr.maybeClass(target, false) != nil)
                        (§
                            target = ((IObj)RT.list(IDENTITY, target)).withMeta(RT.map(RT.TAG_KEY, CLASS))
                        )
                        (§ return (§ expr preserveTag(form, RT.listStar(DOT, target, meth, form.next().next()))))
                    )
                    else if (namesStaticMember(sym))
                    (§
                        Symbol target = Symbol.intern(sym.ns)
                        Class c = HostExpr.maybeClass(target, false)
                        if (c != nil)
                        (§
                            Symbol meth = Symbol.intern(sym.name)
                            (§ return (§ expr preserveTag(form, RT.listStar(DOT, target, meth, form.next()))))
                        )
                    )
                    else
                    (§
                        ;; (s.substring 2 5) => (. s substring 2 5)
                        ;; also (package.class.name ...) (. package.class name ...)
                        int idx = sname.lastIndexOf(\.)
                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                        if (idx == sname.length() - 1)
                        (§
                            (§ return (§ expr RT.listStar(NEW, Symbol.intern(sname.substring(0, idx)), form.next())))
                        )
                    )
                )
            )
        )
        (§ return (§ expr x))
    )

    static Object macroexpand(Object form)
    (§
        Object exf = macroexpand1(form)
        if (exf != form)
        (§
            (§ return (§ expr macroexpand(exf)))
        )
        (§ return (§ expr form))
    )

    private static Expr analyzeSeq(C context, ISeq form, String name)
    (§
        Object line = lineDeref()
        Object column = columnDeref()
        if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
        (§
            line = RT.meta(form).valAt(RT.LINE_KEY)
        )
        if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
        (§
            column = RT.meta(form).valAt(RT.COLUMN_KEY)
        )
        Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column))
        try
        (§
            Object me = macroexpand1(form)
            if (me != form)
            (§
                (§ return (§ expr analyze(context, me, name)))
            )

            Object op = RT.first(form)
            if (op == nil)
            (§
                throw new IllegalArgumentException("Can't call nil, form: " + form)
            )
            IFn inline = isInline(op, RT.count(RT.next(form)))
            if (inline != nil)
            (§
                (§ return (§ expr analyze(context, preserveTag(form, inline.applyTo(RT.next(form))))))
            )
            IParser p
            if (op.equals(FN))
            (§
                (§ return (§ expr FnExpr.parse(context, form, name)))
            )
            else if ((p = (IParser) specials.valAt(op)) != nil)
            (§
                (§ return (§ expr p.parse(context, form)))
            )
            else
            (§
                (§ return (§ expr InvokeExpr.parse(context, form)))
            )
        )
        catch (Throwable e)
        (§
            if (!(e instanceof CompilerException))
            (§
                throw new CompilerException((String) SOURCE_PATH.deref(), lineDeref(), columnDeref(), e)
            )
            else
            (§
                throw (CompilerException) e
            )
        )
        finally
        (§
            Var.popThreadBindings()
        )
    )

    static String errorMsg(String source, int line, int column, String s)
    (§
        (§ return (§ expr String.format("%s, compiling:(%s:%d:%d)", s, source, line, column)))
    )

    public static Object eval(Object form)
    (§
        (§ return (§ expr eval(form, true)))
    )

    public static Object eval(Object form, boolean freshLoader)
    (§
        boolean createdLoader = false
        if (true) ;; !LOADER.isBound()
        (§
            Var.pushThreadBindings(RT.map(LOADER, RT.makeClassLoader()))
            createdLoader = true
        )
        try
        (§
            Object line = lineDeref()
            Object column = columnDeref()
            if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
            (§
                line = RT.meta(form).valAt(RT.LINE_KEY)
            )
            if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
            (§
                column = RT.meta(form).valAt(RT.COLUMN_KEY)
            )
            Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column))
            try
            (§
                form = macroexpand(form)
                if (form instanceof ISeq && Util.equals(RT.first(form), DO))
                (§
                    ISeq s = RT.next(form)
                    for (  RT.next(s) != nil s = RT.next(s))
                    (§
                        eval(RT.first(s), false)
                    )
                    (§ return (§ expr eval(RT.first(s), false)))
                )
                else if ((form instanceof IType) || (form instanceof IPersistentCollection && !(RT.first(form) instanceof Symbol && ((Symbol) RT.first(form)).name.startsWith("def"))))
                (§
                    ObjExpr fexpr = (ObjExpr) analyze(C.EXPRESSION, RT.list(FN, PersistentVector.EMPTY, form), "eval" + RT.nextID())
                    IFn fn = (IFn) fexpr.eval()
                    (§ return (§ expr fn.invoke()))
                )
                else
                (§
                    Expr expr = analyze(C.EVAL, form)
                    (§ return (§ expr expr.eval()))
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )
        finally
        (§
            if (createdLoader)
            (§
                Var.popThreadBindings()
            )
        )
    )

    private static int registerConstant(Object o)
    (§
        if (!CONSTANTS.isBound())
        (§
            (§ return (§ expr -1))
        )
        PersistentVector v = (PersistentVector) CONSTANTS.deref()
        IdentityHashMap<Object, Integer> ids = (IdentityHashMap<Object, Integer>) CONSTANT_IDS.deref()
        Integer i = ids.get(o)
        if (i != nil)
        (§
            (§ return (§ expr i))
        )
        CONSTANTS.set(RT.conj(v, o))
        ids.put(o, v.count())
        (§ return (§ expr v.count()))
    )

    private static KeywordExpr registerKeyword(Keyword keyword)
    (§
        if (!KEYWORDS.isBound())
        (§
            (§ return (§ expr new KeywordExpr(keyword)))
        )

        IPersistentMap keywordsMap = (IPersistentMap) KEYWORDS.deref()
        Object id = RT.get(keywordsMap, keyword)
        if (id == nil)
        (§
            KEYWORDS.set(RT.assoc(keywordsMap, keyword, registerConstant(keyword)))
        )
        (§ return (§ expr new KeywordExpr(keyword)))
    )

    private static int registerKeywordCallsite(Keyword keyword)
    (§
        if (!KEYWORD_CALLSITES.isBound())
        (§
            throw new IllegalAccessError("KEYWORD_CALLSITES is not bound")
        )

        IPersistentVector keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref()

        keywordCallsites = keywordCallsites.cons(keyword)
        KEYWORD_CALLSITES.set(keywordCallsites)
        (§ return (§ expr keywordCallsites.count() - 1))
    )

    private static int registerProtocolCallsite(Var v)
    (§
        if (!PROTOCOL_CALLSITES.isBound())
        (§
            throw new IllegalAccessError("PROTOCOL_CALLSITES is not bound")
        )

        IPersistentVector protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref()

        protocolCallsites = protocolCallsites.cons(v)
        PROTOCOL_CALLSITES.set(protocolCallsites)
        (§ return (§ expr protocolCallsites.count() - 1))
    )

    private static void registerVarCallsite(Var v)
    (§
        if (!VAR_CALLSITES.isBound())
        (§
            throw new IllegalAccessError("VAR_CALLSITES is not bound")
        )

        IPersistentCollection varCallsites = (IPersistentCollection) VAR_CALLSITES.deref()

        varCallsites = varCallsites.cons(v)
        VAR_CALLSITES.set(varCallsites)
    )

    static ISeq fwdPath(PathNode p1)
    (§
        ISeq ret = nil
        for (  p1 != nil p1 = p1.parent)
        (§
            ret = RT.cons(p1, ret)
        )
        (§ return (§ expr ret))
    )

    static PathNode commonPath(PathNode n1, PathNode n2)
    (§
        ISeq xp = fwdPath(n1)
        ISeq yp = fwdPath(n2)
        if (RT.first(xp) != RT.first(yp))
        (§
            (§ return (§ expr nil))
        )
        while (RT.second(xp) != nil && RT.second(xp) == RT.second(yp))
        (§
            xp = xp.next()
            yp = yp.next()
        )
        (§ return (§ expr (PathNode) RT.first(xp)))
    )

    static void addAnnotation(Object visitor, IPersistentMap meta)
    (§
        if (meta != nil && ADD_ANNOTATIONS.isBound())
        (§
            ADD_ANNOTATIONS.invoke(visitor, meta)
        )
    )

    static void addParameterAnnotation(Object visitor, IPersistentMap meta, int i)
    (§
        if (meta != nil && ADD_ANNOTATIONS.isBound())
        (§
            ADD_ANNOTATIONS.invoke(visitor, meta, i)
        )
    )

    private static Expr analyzeSymbol(Symbol sym)
    (§
        Symbol tag = tagOf(sym)
        if (sym.ns == nil) ;; ns-qualified syms are always Vars
        (§
            LocalBinding b = referenceLocal(sym)
            if (b != nil)
            (§
                (§ return (§ expr new LocalBindingExpr(b, tag)))
            )
        )
        else if (namespaceFor(sym) == nil)
        (§
            Symbol nsSym = Symbol.intern(sym.ns)
            Class c = HostExpr.maybeClass(nsSym, false)
            if (c != nil)
            (§
                if (Reflector.getField(c, sym.name, true) != nil)
                (§
                    (§ return (§ expr new StaticFieldExpr(lineDeref(), columnDeref(), c, sym.name, tag)))
                )
                throw Util.runtimeException("Unable to find static field: " + sym.name + " in " + c)
            )
        )
        Object o = resolve(sym)
        if (o instanceof Var)
        (§
            Var v = (Var) o
            if (isMacro(v) != nil)
            (§
                throw Util.runtimeException("Can't take value of a macro: " + v)
            )
            if (RT.booleanCast(RT.get(v.meta(), RT.CONST_KEY)))
            (§
                (§ return (§ expr analyze(C.EXPRESSION, RT.list(QUOTE, v.get()))))
            )
            registerVar(v)
            (§ return (§ expr new VarExpr(v, tag)))
        )
        else if (o instanceof Class)
        (§
            (§ return (§ expr new ConstantExpr(o)))
        )
        else if (o instanceof Symbol)
        (§
            (§ return (§ expr new UnresolvedVarExpr((Symbol) o)))
        )

        throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")
    )

    static String destubClassName(String className)
    (§
        ;; skip over prefix + '.' or '/'
        if (className.startsWith(COMPILE_STUB_PREFIX))
        (§
            (§ return (§ expr className.substring(COMPILE_STUB_PREFIX.length() + 1)))
        )
        (§ return (§ expr className))
    )

    static Type getType(Class c)
    (§
        String descriptor = Type.getType(c).getDescriptor()
        if (descriptor.startsWith("L"))
        (§
            descriptor = "L" + destubClassName(descriptor.substring(1))
        )
        (§ return (§ expr Type.getType(descriptor)))
    )

    static Object resolve(Symbol sym, boolean allowPrivate)
    (§
        (§ return (§ expr resolveIn(currentNS(), sym, allowPrivate)))
    )

    static Object resolve(Symbol sym)
    (§
        (§ return (§ expr resolveIn(currentNS(), sym, false)))
    )

    static Namespace namespaceFor(Symbol sym)
    (§
        (§ return (§ expr namespaceFor(currentNS(), sym)))
    )

    static Namespace namespaceFor(Namespace inns, Symbol sym)
    (§
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        Symbol nsSym = Symbol.intern(sym.ns)
        Namespace ns = inns.lookupAlias(nsSym)
        if (ns == nil)
        (§
            ;; ...otherwise check the Namespaces map.
            ns = Namespace.find(nsSym)
        )
        (§ return (§ expr ns))
    )

    static public Object resolveIn(Namespace n, Symbol sym, boolean allowPrivate)
    (§
        ;; note - ns-qualified vars must already exist
        if (sym.ns != nil)
        (§
            Namespace ns = namespaceFor(n, sym)
            if (ns == nil)
            (§
                throw Util.runtimeException("No such namespace: " + sym.ns)
            )

            Var v = ns.findInternedVar(Symbol.intern(sym.name))
            if (v == nil)
            (§
                throw Util.runtimeException("No such var: " + sym)
            )
            else if (v.ns != currentNS() && !v.isPublic() && !allowPrivate)
            (§
                throw new IllegalStateException("var: " + sym + " is not public")
            )
            (§ return (§ expr v))
        )
        else if (sym.name.indexOf(\.) > 0 || sym.name.charAt(0) == \[)
        (§
            (§ return (§ expr RT.classForName(sym.name)))
        )
        else if (sym.equals(NS))
        (§
            (§ return (§ expr RT.NS_VAR))
        )
        else if (sym.equals(IN_NS))
        (§
            (§ return (§ expr RT.IN_NS_VAR))
        )
        else
        (§
            if (Util.equals(sym, COMPILE_STUB_SYM.get()))
            (§
                (§ return (§ expr COMPILE_STUB_CLASS.get()))
            )
            Object o = n.getMapping(sym)
            if (o == nil)
            (§
                if (RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref()))
                (§
                    (§ return (§ expr sym))
                )
                else
                (§
                    throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context")
                )
            )
            (§ return (§ expr o))
        )
    )

    static public Object maybeResolveIn(Namespace n, Symbol sym)
    (§
        ;; note - ns-qualified vars must already exist
        if (sym.ns != nil)
        (§
            Namespace ns = namespaceFor(n, sym)
            if (ns == nil)
            (§
                (§ return (§ expr nil))
            )
            Var v = ns.findInternedVar(Symbol.intern(sym.name))
            if (v == nil)
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr v))
        )
        else if (sym.name.indexOf(\.) > 0 && !sym.name.endsWith(".") || sym.name.charAt(0) == \[)
        (§
            (§ return (§ expr RT.classForName(sym.name)))
        )
        else if (sym.equals(NS))
        (§
            (§ return (§ expr RT.NS_VAR))
        )
        else if (sym.equals(IN_NS))
        (§
            (§ return (§ expr RT.IN_NS_VAR))
        )
        else
        (§
            Object o = n.getMapping(sym)
            (§ return (§ expr o))
        )
    )

    static Var lookupVar(Symbol sym, boolean internNew, boolean registerMacro)
    (§
        Var var = nil

        ;; note - ns-qualified vars in other namespaces must already exist
        if (sym.ns != nil)
        (§
            Namespace ns = namespaceFor(sym)
            if (ns == nil)
            (§
                (§ return (§ expr nil))
            )
            Symbol name = Symbol.intern(sym.name)
            if (internNew && ns == currentNS())
            (§
                var = currentNS().intern(name)
            )
            else
            (§
                var = ns.findInternedVar(name)
            )
        )
        else if (sym.equals(NS))
        (§
            var = RT.NS_VAR
        )
        else if (sym.equals(IN_NS))
        (§
            var = RT.IN_NS_VAR
        )
        else
        (§
            ;; is it mapped?
            Object o = currentNS().getMapping(sym)
            if (o == nil)
            (§
                ;; introduce a new var in the current ns
                if (internNew)
                (§
                    var = currentNS().intern(Symbol.intern(sym.name))
                )
            )
            else if (o instanceof Var)
            (§
                var = (Var) o
            )
            else
            (§
                throw Util.runtimeException("Expecting var, but " + sym + " is mapped to " + o)
            )
        )
        if (var != nil && (!var.isMacro() || registerMacro))
        (§
            registerVar(var)
        )
        (§ return (§ expr var))
    )

    static Var lookupVar(Symbol sym, boolean internNew)
    (§
        (§ return (§ expr lookupVar(sym, internNew, true)))
    )

    private static void registerVar(Var var)
    (§
        if (!VARS.isBound())
        (§
            (§ return (§ expr ))
        )
        IPersistentMap varsMap = (IPersistentMap) VARS.deref()
        Object id = RT.get(varsMap, var)
        if (id == nil)
        (§
            VARS.set(RT.assoc(varsMap, var, registerConstant(var)))
        )
    )

    static Namespace currentNS()
    (§
        (§ return (§ expr (Namespace) RT.CURRENT_NS.deref()))
    )

    static void closeOver(LocalBinding b, ObjMethod method)
    (§
        if (b != nil && method != nil)
        (§
            LocalBinding lb = (LocalBinding) RT.get(method.locals, b)
            if (lb == nil)
            (§
                method.objx.closes = (IPersistentMap) RT.assoc(method.objx.closes, b, b)
                closeOver(b, method.parent)
            )
            else
            (§
                if (lb.idx == 0)
                (§
                    method.usesThis = true
                )
                if (IN_CATCH_FINALLY.deref() != nil)
                (§
                    method.localsUsedInCatchFinally = (PersistentHashSet) method.localsUsedInCatchFinally.cons(b.idx)
                )
            )
        )
    )

    static LocalBinding referenceLocal(Symbol sym)
    (§
        if (!LOCAL_ENV.isBound())
        (§
            (§ return (§ expr nil))
        )
        LocalBinding b = (LocalBinding) RT.get(LOCAL_ENV.deref(), sym)
        if (b != nil)
        (§
            ObjMethod method = (ObjMethod) METHOD.deref()
            if (b.idx == 0)
            (§
                method.usesThis = true
            )
            closeOver(b, method)
        )
        (§ return (§ expr b))
    )

    private static Symbol tagOf(Object o)
    (§
        Object tag = RT.get(RT.meta(o), RT.TAG_KEY)
        if (tag instanceof Symbol)
        (§
            (§ return (§ expr (Symbol) tag))
        )
        else if (tag instanceof String)
        (§
            (§ return (§ expr Symbol.intern(nil, (String) tag)))
        )
        (§ return (§ expr nil))
    )

    public static Object loadFile(String file) throws IOException
    (§
        FileInputStream f = new FileInputStream(file)
        try
        (§
            (§ return (§ expr load(new InputStreamReader(f, RT.UTF8), new File(file).getAbsolutePath(), (new File(file)).getName())))
        )
        finally
        (§
            f.close()
        )
    )

    public static Object load(Reader rdr)
    (§
        (§ return (§ expr load(rdr, nil, "NO_SOURCE_FILE")))
    )

    static void consumeWhitespaces(LineNumberingPushbackReader pushbackReader)
    (§
        int ch = LispReader.read1(pushbackReader)
        while (LispReader.isWhitespace(ch))
            ch = LispReader.read1(pushbackReader)
        LispReader.unread(pushbackReader, ch)
    )

    private static final Object OPTS_COND_ALLOWED = RT.mapUniqueKeys(LispReader.OPT_READ_COND, LispReader.COND_ALLOW)

    private static Object readerOpts(String sourceName)
    (§
        if (sourceName != nil && sourceName.endsWith(".clic"))
        (§
            (§ return (§ expr OPTS_COND_ALLOWED))
        )
        else
        (§
            (§ return (§ expr nil))
        )
    )

    public static Object load(Reader rdr, String sourcePath, String sourceName)
    (§
        Object EOF = new Object()
        Object ret = nil
        LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr)
        consumeWhitespaces(pushbackReader)
        Var.pushThreadBindings(RT.mapUniqueKeys(LOADER, RT.makeClassLoader(),
                    SOURCE_PATH, sourcePath,
                    SOURCE, sourceName,
                    METHOD, nil,
                    LOCAL_ENV, nil,
                    LOOP_LOCALS, nil,
                    NEXT_LOCAL_NUM, 0,
                    RT.READEVAL, RT.T,
                    RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                    LINE_BEFORE, pushbackReader.getLineNumber(),
                    COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                    LINE_AFTER, pushbackReader.getLineNumber(),
                    COLUMN_AFTER, pushbackReader.getColumnNumber(),
                    RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                    RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                    RT.DATA_READERS, RT.DATA_READERS.deref()
        ))

        Object readerOpts = readerOpts(sourceName)
        try
        (§
            for (Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts) r != EOF r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))
            (§
                consumeWhitespaces(pushbackReader)
                LINE_AFTER.set(pushbackReader.getLineNumber())
                COLUMN_AFTER.set(pushbackReader.getColumnNumber())
                ret = eval(r, false)
                LINE_BEFORE.set(pushbackReader.getLineNumber())
                COLUMN_BEFORE.set(pushbackReader.getColumnNumber())
            )
        )
        catch (LispReader.ReaderException e)
        (§
            throw new CompilerException(sourcePath, e.line, e.column, e.getCause())
        )
        catch (Throwable e)
        (§
            if (!(e instanceof CompilerException))
            (§
                throw new CompilerException(sourcePath, (Integer) LINE_BEFORE.deref(), (Integer) COLUMN_BEFORE.deref(), e)
            )
            else
            (§
                throw (CompilerException) e
            )
        )
        finally
        (§
            Var.popThreadBindings()
        )
        (§ return (§ expr ret))
    )

    static public void writeClassFile(String internalName, byte[] bytecode) throws IOException
    (§
        String genPath = (String) COMPILE_PATH.deref()
        if (genPath == nil)
        (§
            throw Util.runtimeException("*compile-path* not set")
        )
        String[] dirs = internalName.split("/")
        String p = genPath
        for (int i = 0 i < dirs.length - 1 i++)
        (§
            p += File.separator + dirs[i]
            (new File(p)).mkdir()
        )
        String path = genPath + File.separator + internalName + ".class"
        File cf = new File(path)
        cf.createNewFile()
        FileOutputStream cfs = new FileOutputStream(cf)
        try
        (§
            cfs.write(bytecode)
            cfs.flush()
        )
        finally
        (§
            cfs.close()
        )
    )

    public static void pushNS()
    (§
        Var.pushThreadBindings(PersistentHashMap.create(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil))
    )

    public static void pushNSandLoader(ClassLoader loader)
    (§
        Var.pushThreadBindings(RT.map(Var.intern(Symbol.intern("cloiure.core"), Symbol.intern("*ns*")).setDynamic(), nil, RT.FN_LOADER_VAR, loader, RT.READEVAL, RT.T))
    )

    public static ILookupThunk getLookupThunk(Object target, Keyword k)
    (§
        (§ return (§ expr nil))
    )

    static void compile1(GeneratorAdapter gen, ObjExpr objx, Object form)
    (§
        Object line = lineDeref()
        Object column = columnDeref()
        if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.LINE_KEY))
        (§
            line = RT.meta(form).valAt(RT.LINE_KEY)
        )
        if (RT.meta(form) != nil && RT.meta(form).containsKey(RT.COLUMN_KEY))
        (§
            column = RT.meta(form).valAt(RT.COLUMN_KEY)
        )
        Var.pushThreadBindings(RT.map(LINE, line, COLUMN, column,
                    LOADER, RT.makeClassLoader()
        ))
        try
        (§
            form = macroexpand(form)
            if (form instanceof ISeq && Util.equals(RT.first(form), DO))
            (§
                for (ISeq s = RT.next(form) s != nil s = RT.next(s))
                (§
                    compile1(gen, objx, RT.first(s))
                )
            )
            else
            (§
                Expr expr = analyze(C.EVAL, form)
                objx.keywords = (IPersistentMap) KEYWORDS.deref()
                objx.vars = (IPersistentMap) VARS.deref()
                objx.constants = (PersistentVector) CONSTANTS.deref()
                expr.emit(C.EXPRESSION, objx, gen)
                expr.eval()
            )
        )
        finally
        (§
            Var.popThreadBindings()
        )
    )

    public static Object compile(Reader rdr, String sourcePath, String sourceName) throws IOException
    (§
        if (COMPILE_PATH.deref() == nil)
        (§
            throw Util.runtimeException("*compile-path* not set")
        )

        Object EOF = new Object()
        Object ret = nil
        LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) rdr :or new LineNumberingPushbackReader(rdr)
        Var.pushThreadBindings(RT.mapUniqueKeys(SOURCE_PATH, sourcePath,
                    SOURCE, sourceName,
                    METHOD, nil,
                    LOCAL_ENV, nil,
                    LOOP_LOCALS, nil,
                    NEXT_LOCAL_NUM, 0,
                    RT.READEVAL, RT.T,
                    RT.CURRENT_NS, RT.CURRENT_NS.deref(),
                    LINE_BEFORE, pushbackReader.getLineNumber(),
                    COLUMN_BEFORE, pushbackReader.getColumnNumber(),
                    LINE_AFTER, pushbackReader.getLineNumber(),
                    COLUMN_AFTER, pushbackReader.getColumnNumber(),
                    CONSTANTS, PersistentVector.EMPTY,
                    CONSTANT_IDS, new IdentityHashMap(),
                    KEYWORDS, PersistentHashMap.EMPTY,
                    VARS, PersistentHashMap.EMPTY,
                    RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref(),
                    RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION.deref(),
                    RT.DATA_READERS, RT.DATA_READERS.deref()
        ))

        try
        (§
            ;; generate loader class
            ObjExpr objx = new ObjExpr(nil)
            objx.internalName = sourcePath.replace(File.separator, "/").substring(0, sourcePath.lastIndexOf(\.)) + RT.LOADER_SUFFIX

            objx.objtype = Type.getObjectType(objx.internalName)
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS)
            ClassVisitor cv = cw
            cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, objx.internalName, nil, "java/lang/Object", nil)

            ;; static load method
            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void load ()"), nil, nil, cv)
            gen.visitCode()

            Object readerOpts = readerOpts(sourceName)
            for (Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts) r != EOF r = LispReader.read(pushbackReader, false, EOF, false, readerOpts))
            (§
                LINE_AFTER.set(pushbackReader.getLineNumber())
                COLUMN_AFTER.set(pushbackReader.getColumnNumber())
                compile1(gen, objx, r)
                LINE_BEFORE.set(pushbackReader.getLineNumber())
                COLUMN_BEFORE.set(pushbackReader.getColumnNumber())
            )
            ;; end of load
            gen.returnValue()
            gen.endMethod()

            ;; static fields for constants
            for (int i = 0 i < objx.constants.count() i++)
            (§
                if (objx.usedConstants.contains(i))
                (§
                    cv.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, objx.constantName(i), objx.constantType(i).getDescriptor(), nil, nil)
                )
            )

            final int INITS_PER = 100
            int numInits =  objx.constants.count() / INITS_PER
            if (objx.constants.count() % INITS_PER != 0)
            (§
                ++numInits
            )

            for (int n = 0 n < numInits n++)
            (§
                GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void __init" + n + "()"), nil, nil, cv)
                clinitgen.visitCode()
                try
                (§
                    Var.pushThreadBindings(RT.map(RT.PRINT_DUP, RT.T))

                    for (int i = n * INITS_PER i < objx.constants.count() && i < (n + 1) * INITS_PER i++)
                    (§
                        if (objx.usedConstants.contains(i))
                        (§
                            objx.emitValue(objx.constants.nth(i), clinitgen)
                            clinitgen.checkCast(objx.constantType(i))
                            clinitgen.putStatic(objx.objtype, objx.constantName(i), objx.constantType(i))
                        )
                    )
                )
                finally
                (§
                    Var.popThreadBindings()
                )
                clinitgen.returnValue()
                clinitgen.endMethod()
            )

            ;; static init for constants, keywords and vars
            GeneratorAdapter clinitgen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, Method.getMethod("void <clinit> ()"), nil, nil, cv)
            clinitgen.visitCode()
            Label startTry = clinitgen.newLabel()
            Label endTry = clinitgen.newLabel()
            Label end = clinitgen.newLabel()
            Label finallyLabel = clinitgen.newLabel()

            for (int n = 0 n < numInits n++)
            (§
                clinitgen.invokeStatic(objx.objtype, Method.getMethod("void __init" + n + "()"))
            )

            clinitgen.push(objx.internalName.replace(\/, \.))
            clinitgen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)"))
            clinitgen.invokeVirtual(CLASS_TYPE, Method.getMethod("ClassLoader getClassLoader()"))
            clinitgen.invokeStatic(Type.getType(Compiler.class), Method.getMethod("void pushNSandLoader(ClassLoader)"))
            clinitgen.mark(startTry)
            clinitgen.invokeStatic(objx.objtype, Method.getMethod("void load()"))
            clinitgen.mark(endTry)
            clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()"))
            clinitgen.goTo(end)

            clinitgen.mark(finallyLabel)
            ;; exception should be on stack
            clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()"))
            clinitgen.throwException()
            clinitgen.mark(end)
            clinitgen.visitTryCatchBlock(startTry, endTry, finallyLabel, nil)

            ;; end of static init
            clinitgen.returnValue()
            clinitgen.endMethod()

            ;; end of class
            cv.visitEnd()

            writeClassFile(objx.internalName, cw.toByteArray())
        )
        catch (LispReader.ReaderException e)
        (§
            throw new CompilerException(sourcePath, e.line, e.column, e.getCause())
        )
        finally
        (§
            Var.popThreadBindings()
        )
        (§ return (§ expr ret))
    )

    static public class NewInstanceExpr extends ObjExpr
    (§
        IPersistentCollection methods

        Map<IPersistentVector, java.lang.reflect.Method> mmap
        Map<IPersistentVector, Set<Class>> covariants

        public NewInstanceExpr(Object tag)
        (§
            super(tag)
        )

        static class DeftypeParser implements IParser
        (§
            public Expr parse(C context, final Object frm)
            (§
                ISeq rform = (ISeq) frm
                ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
                rform = RT.next(rform)
                String tagname = ((Symbol) rform.first()).getName()
                rform = rform.next()
                Symbol classname = (Symbol) rform.first()
                rform = rform.next()
                IPersistentVector fields = (IPersistentVector) rform.first()
                rform = rform.next()
                IPersistentMap opts = PersistentHashMap.EMPTY
                while (rform != nil && rform.first() instanceof Keyword)
                (§
                    opts = opts.assoc(rform.first(), RT.second(rform))
                    rform = rform.next().next()
                )

                ObjExpr ret = build((IPersistentVector)RT.get(opts, implementsKey, PersistentVector.EMPTY), fields, nil, tagname, classname, (Symbol) RT.get(opts, RT.TAG_KEY), rform, frm, opts)
                (§ return (§ expr ret))
            )
        )

        static class ReifyParser implements IParser
        (§
            public Expr parse(C context, Object frm)
            (§
                ;; (reify this-name? [interfaces] (method-name [args] body)*)
                ISeq form = (ISeq) frm
                ObjMethod enclosingMethod = (ObjMethod) METHOD.deref()
                String basename = (enclosingMethod != nil) ? (trimGenID(enclosingMethod.objx.name) + "$") :or (munge(currentNS().name.name) + "$")
                String simpleName = "reify__" + RT.nextID()
                String classname = basename + simpleName

                ISeq rform = RT.next(form)

                IPersistentVector interfaces = ((IPersistentVector) RT.first(rform)).cons(Symbol.intern("cloiure.lang.IObj"))

                rform = RT.next(rform)

                ObjExpr ret = build(interfaces, nil, nil, classname, Symbol.intern(classname), nil, rform, frm, nil)
                if (frm instanceof IObj && ((IObj) frm).meta() != nil)
                (§
                    (§ return (§ expr new MetaExpr(ret, MapExpr.parse((context == C.EVAL) ? context :or C.EXPRESSION, ((IObj) frm).meta()))))
                )
                else
                (§
                    (§ return (§ expr ret))
                )
            )
        )

        static ObjExpr build(IPersistentVector interfaceSyms, IPersistentVector fieldSyms, Symbol thisSym, String tagName, Symbol className, Symbol typeTag, ISeq methodForms, Object frm, IPersistentMap opts)
        (§
            NewInstanceExpr ret = new NewInstanceExpr(nil)

            ret.src = frm
            ret.name = className.toString()
            ret.classMeta = RT.meta(className)
            ret.internalName = ret.name.replace(\., \/)
            ret.objtype = Type.getObjectType(ret.internalName)
            ret.opts = opts

            if (thisSym != nil)
            (§
                ret.thisName = thisSym.name
            )

            if (fieldSyms != nil)
            (§
                IPersistentMap fmap = PersistentHashMap.EMPTY
                Object[] closesvec = new Object[2 * fieldSyms.count()]
                for (int i = 0 i < fieldSyms.count() i++)
                (§
                    Symbol sym = (Symbol) fieldSyms.nth(i)
                    LocalBinding lb = new LocalBinding(-1, sym, nil, new MethodParamExpr(tagClass(tagOf(sym))), false, nil)
                    fmap = fmap.assoc(sym, lb)
                    closesvec[i * 2] = lb
                    closesvec[i * 2 + 1] = lb
                )

                ;; todo - inject __meta et al into closes - when?
                ;; use array map to preserve ctor order
                ret.closes = new PersistentArrayMap(closesvec)
                ret.fields = fmap
                for (int i = fieldSyms.count() - 1 i >= 0 && (((Symbol)fieldSyms.nth(i)).name.equals("__meta") || ((Symbol)fieldSyms.nth(i)).name.equals("__extmap") || ((Symbol)fieldSyms.nth(i)).name.equals("__hash") || ((Symbol)fieldSyms.nth(i)).name.equals("__hasheq")) --i)
                (§
                    ret.altCtorDrops++
                )
            )

            PersistentVector interfaces = PersistentVector.EMPTY
            for (ISeq s = RT.seq(interfaceSyms) s != nil s = s.next())
            (§
                Class c = (Class) resolve((Symbol) s.first())
                if (!c.isInterface())
                (§
                    throw new IllegalArgumentException("only interfaces are supported, had: " + c.getName())
                )
                interfaces = interfaces.cons(c)
            )
            Class superClass = Object.class
            Map[] mc = gatherMethods(superClass, RT.seq(interfaces))
            Map overrideables = mc[0]
            Map covariants = mc[1]
            ret.mmap = overrideables
            ret.covariants = covariants

            String[] inames = interfaceNames(interfaces)

            Class stub = compileStub(slashname(superClass), ret, inames, frm)
            Symbol thistag = Symbol.intern(nil, stub.getName())

            try
            (§
                Var.pushThreadBindings(RT.mapUniqueKeys(CONSTANTS, PersistentVector.EMPTY,
                            CONSTANT_IDS, new IdentityHashMap(),
                            KEYWORDS, PersistentHashMap.EMPTY,
                            VARS, PersistentHashMap.EMPTY,
                            KEYWORD_CALLSITES, PersistentVector.EMPTY,
                            PROTOCOL_CALLSITES, PersistentVector.EMPTY,
                            VAR_CALLSITES, emptyVarCallSites(),
                            NO_RECUR, nil
                ))
                if (ret.isDeftype())
                (§
                    Var.pushThreadBindings(RT.mapUniqueKeys(METHOD, nil,
                                LOCAL_ENV, ret.fields,
                                COMPILE_STUB_SYM, Symbol.intern(nil, tagName),
                                COMPILE_STUB_CLASS, stub
                    ))

                    ret.hintedFields = RT.subvec(fieldSyms, 0, fieldSyms.count() - ret.altCtorDrops)
                )

                ;; now (methodname [args] body)*
                ret.line = lineDeref()
                ret.column = columnDeref()
                IPersistentCollection methods = nil
                for (ISeq s = methodForms s != nil s = RT.next(s))
                (§
                    NewInstanceMethod m = NewInstanceMethod.parse(ret, (ISeq) RT.first(s), thistag, overrideables)
                    methods = RT.conj(methods, m)
                )

                ret.methods = methods
                ret.keywords = (IPersistentMap) KEYWORDS.deref()
                ret.vars = (IPersistentMap) VARS.deref()
                ret.constants = (PersistentVector) CONSTANTS.deref()
                ret.constantsID = RT.nextID()
                ret.keywordCallsites = (IPersistentVector) KEYWORD_CALLSITES.deref()
                ret.protocolCallsites = (IPersistentVector) PROTOCOL_CALLSITES.deref()
                ret.varCallsites = (IPersistentSet) VAR_CALLSITES.deref()
            )
            finally
            (§
                if (ret.isDeftype())
                (§
                    Var.popThreadBindings()
                )
                Var.popThreadBindings()
            )

            try
            (§
                ret.compile(slashname(superClass), inames, false)
            )
            catch (IOException e)
            (§
                throw Util.sneakyThrow(e)
            )
            ret.getCompiledClass()
            (§ return (§ expr ret))
        )

        ;;;
         ; Current host interop uses reflection, which requires pre-existing classes
         ; Work around this by:
         ; Generate a stub class that has the same interfaces and fields as the class we are generating.
         ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
         ; Unmunge the name (using a magic prefix) on any code gen for classes
         ;;
        static Class compileStub(String superName, NewInstanceExpr ret, String[] interfaceNames, Object frm)
        (§
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS)
            ClassVisitor cv = cw
            cv.visit(V1_5, ACC_PUBLIC + ACC_SUPER, COMPILE_STUB_PREFIX + "/" + ret.internalName, nil, superName, interfaceNames)

            ;; instance fields for closed-overs
            for (ISeq s = RT.keys(ret.closes) s != nil s = s.next())
            (§
                LocalBinding lb = (LocalBinding) s.first()
                int access = ACC_PUBLIC + (ret.isVolatile(lb) ? ACC_VOLATILE :or ret.isMutable(lb) ? 0 :or ACC_FINAL)
                if (lb.getPrimitiveType() != nil)
                (§
                    cv.visitField(access, lb.name, Type.getType(lb.getPrimitiveType()).getDescriptor(), nil, nil)
                )
                else
                (§
                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                    cv.visitField(access, lb.name, OBJECT_TYPE.getDescriptor(), nil, nil)
                )
            )

            ;; ctor that takes closed-overs and does nothing
            Method m = new Method("<init>", Type.VOID_TYPE, ret.ctorTypes())
            GeneratorAdapter ctorgen = new GeneratorAdapter(ACC_PUBLIC, m, nil, nil, cv)
            ctorgen.visitCode()
            ctorgen.loadThis()
            ctorgen.invokeConstructor(Type.getObjectType(superName), voidctor)
            ctorgen.returnValue()
            ctorgen.endMethod()

            if (ret.altCtorDrops > 0)
            (§
                Type[] ctorTypes = ret.ctorTypes()
                Type[] altCtorTypes = new Type[ctorTypes.length-ret.altCtorDrops]
                for (int i = 0 i < altCtorTypes.length i++)
                (§
                    altCtorTypes[i] = ctorTypes[i]
                )
                Method alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.loadArgs()

                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; __meta
                ctorgen.visitInsn(Opcodes.ACONST_NULL) ;; __extmap
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hash
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hasheq

                ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()

                ;; alt ctor no __hash, __hasheq
                altCtorTypes = new Type[ctorTypes.length-2]
                for (int i = 0 i < altCtorTypes.length i++)
                (§
                    altCtorTypes[i] = ctorTypes[i]
                )

                alt = new Method("<init>", Type.VOID_TYPE, altCtorTypes)
                ctorgen = new GeneratorAdapter(ACC_PUBLIC, alt, nil, nil, cv)
                ctorgen.visitCode()
                ctorgen.loadThis()
                ctorgen.loadArgs()

                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hash
                ctorgen.visitInsn(Opcodes.ICONST_0) ;; __hasheq

                ctorgen.invokeConstructor(Type.getObjectType(COMPILE_STUB_PREFIX + "/" + ret.internalName), new Method("<init>", Type.VOID_TYPE, ctorTypes))

                ctorgen.returnValue()
                ctorgen.endMethod()
            )
            ;; end of class
            cv.visitEnd()

            byte[] bytecode = cw.toByteArray()
            DynamicClassLoader loader = (DynamicClassLoader) LOADER.deref()
            (§ return (§ expr loader.defineClass(COMPILE_STUB_PREFIX + "." + ret.name, bytecode, frm)))
        )

        static String[] interfaceNames(IPersistentVector interfaces)
        (§
            int icnt = interfaces.count()
            String[] inames = (icnt > 0) ? new String[icnt] :or nil
            for (int i = 0 i < icnt i++)
            (§
                inames[i] = slashname((Class) interfaces.nth(i))
            )
            (§ return (§ expr inames))
        )

        static String slashname(Class c)
        (§
            (§ return (§ expr c.getName().replace(\., \/)))
        )

        protected void emitStatics(ClassVisitor cv)
        (§
            if (this.isDeftype())
            (§
                ;; getBasis()
                Method meth = Method.getMethod("cloiure.lang.IPersistentVector getBasis()")
                GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, meth, nil, nil, cv)
                emitValue(hintedFields, gen)
                gen.returnValue()
                gen.endMethod()

                if (this.isDeftype() && this.fields.count() > this.hintedFields.count())
                (§
                    ;; create(IPersistentMap)
                    String className = name.replace(\., \/)
                    int i = 1
                    int fieldCount = hintedFields.count()

                    MethodVisitor mv = cv.visitMethod(ACC_PUBLIC + ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + className + ";", nil, nil)
                    mv.visitCode()

                    for (ISeq s = RT.seq(hintedFields) s != nil s = s.next(), i++)
                    (§
                        String bName = ((Symbol)s.first()).name
                        Class k = tagClass(tagOf(s.first()))

                        mv.visitVarInsn(ALOAD, 0)
                        mv.visitLdcInsn(bName)
                        mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                        mv.visitInsn(ACONST_NULL)
                        mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
                        if (k.isPrimitive())
                        (§
                            mv.visitTypeInsn(CHECKCAST, Type.getType(boxClass(k)).getInternalName())
                        )
                        mv.visitVarInsn(ASTORE, i)
                        mv.visitVarInsn(ALOAD, 0)
                        mv.visitLdcInsn(bName)
                        mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                        mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;")
                        mv.visitVarInsn(ASTORE, 0)
                    )

                    mv.visitTypeInsn(Opcodes.NEW, className)
                    mv.visitInsn(DUP)

                    Method ctor = new Method("<init>", Type.VOID_TYPE, ctorTypes())

                    if (hintedFields.count() > 0)
                    (§
                        for (i = 1 i <= fieldCount i++)
                        (§
                            mv.visitVarInsn(ALOAD, i)
                            Class k = tagClass(tagOf(hintedFields.nth(i - 1)))
                            if (k.isPrimitive())
                            (§
                                String b = Type.getType(boxClass(k)).getInternalName()
                                String p = Type.getType(k).getDescriptor()
                                String n = k.getName()

                                mv.visitMethodInsn(INVOKEVIRTUAL, b, n+"Value", "()" + p)
                            )
                        )
                    )

                    mv.visitInsn(ACONST_NULL) ;; __meta
                    mv.visitVarInsn(ALOAD, 0) ;; __extmap
                    mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;")
                    mv.visitInsn(ICONST_0) ;; __hash
                    mv.visitInsn(ICONST_0) ;; __hasheq
                    mv.visitMethodInsn(INVOKESPECIAL, className, "<init>", ctor.getDescriptor())
                    mv.visitInsn(ARETURN)
                    mv.visitMaxs(4 + fieldCount, 1 + fieldCount)
                    mv.visitEnd()
                )
            )
        )

        protected void emitMethods(ClassVisitor cv)
        (§
            for (ISeq s = RT.seq(methods) s != nil s = s.next())
            (§
                ObjMethod method = (ObjMethod) s.first()
                method.emit(this, cv)
            )
            ;; emit bridge methods
            for (Map.Entry<IPersistentVector, Set<Class>> e :in covariants.entrySet())
            (§
                java.lang.reflect.Method m = mmap.get(e.getKey())
                Class[] params = m.getParameterTypes()
                Type[] argTypes = new Type[params.length]

                for (int i = 0 i < params.length i++)
                (§
                    argTypes[i] = Type.getType(params[i])
                )

                Method target = new Method(m.getName(), Type.getType(m.getReturnType()), argTypes)

                for (Class retType :in e.getValue())
                (§
                    Method meth = new Method(m.getName(), Type.getType(retType), argTypes)

                    GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC + ACC_BRIDGE,
                            meth,
                            nil,
                            ;; todo don't hardwire this
                            EXCEPTION_TYPES,
                            cv)
                    gen.visitCode()
                    gen.loadThis()
                    gen.loadArgs()
                    gen.invokeInterface(Type.getType(m.getDeclaringClass()), target)
                    gen.returnValue()
                    gen.endMethod()
                )
            )
        )

        static public IPersistentVector msig(java.lang.reflect.Method m)
        (§
            (§ return (§ expr RT.vector(m.getName(), RT.seq(m.getParameterTypes()), m.getReturnType())))
        )

        static void considerMethod(java.lang.reflect.Method m, Map mm)
        (§
            IPersistentVector mk = msig(m)
            int mods = m.getModifiers()

            if (!(mm.containsKey(mk) || !(Modifier.isPublic(mods) || Modifier.isProtected(mods)) || Modifier.isStatic(mods) || Modifier.isFinal(mods)))
            (§
                mm.put(mk, m)
            )
        )

        static void gatherMethods(Class c, Map mm)
        (§
            for (  c != nil c = c.getSuperclass())
            (§
                for (java.lang.reflect.Method m :in c.getDeclaredMethods())
                (§
                    considerMethod(m, mm)
                )
                for (java.lang.reflect.Method m :in c.getMethods())
                (§
                    considerMethod(m, mm)
                )
            )
        )

        static public Map[] gatherMethods(Class sc, ISeq interfaces)
        (§
            Map allm = new HashMap()
            gatherMethods(sc, allm)
            for (  interfaces != nil interfaces = interfaces.next())
            (§
                gatherMethods((Class) interfaces.first(), allm)
            )

            Map<IPersistentVector, java.lang.reflect.Method> mm = new HashMap<IPersistentVector, java.lang.reflect.Method>()
            Map<IPersistentVector, Set<Class>> covariants = new HashMap<IPersistentVector, Set<Class>>()
            for (Object o :in allm.entrySet())
            (§
                Map.Entry e = (Map.Entry) o
                IPersistentVector mk = (IPersistentVector) e.getKey()
                mk = (IPersistentVector) mk.pop()
                java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue()
                if (mm.containsKey(mk)) ;; covariant return
                (§
                    Set<Class> cvs = covariants.get(mk)
                    if (cvs == nil)
                    (§
                        cvs = new HashSet<Class>()
                        covariants.put(mk, cvs)
                    )
                    java.lang.reflect.Method om = mm.get(mk)
                    if (om.getReturnType().isAssignableFrom(m.getReturnType()))
                    (§
                        cvs.add(om.getReturnType())
                        mm.put(mk, m)
                    )
                    else
                    (§
                        cvs.add(m.getReturnType())
                    )
                )
                else
                (§
                    mm.put(mk, m)
                )
            )
            (§ return (§ expr new Map[] (§ mm, covariants )))
        )
    )

    public static class NewInstanceMethod extends ObjMethod
    (§
        String name
        Type[] argTypes
        Type retType
        Class retClass
        Class[] exclasses

        static Symbol dummyThis = Symbol.intern(nil, "dummy_this_dlskjsdfower")
        private IPersistentVector parms

        public NewInstanceMethod(ObjExpr objx, ObjMethod parent)
        (§
            super(objx, parent)
        )

        int numParams()
        (§
            (§ return (§ expr argLocals.count()))
        )

        String getMethodName()
        (§
            (§ return (§ expr name))
        )

        Type getReturnType()
        (§
            (§ return (§ expr retType))
        )

        Type[] getArgTypes()
        (§
            (§ return (§ expr argTypes))
        )

        static public IPersistentVector msig(String name, Class[] paramTypes)
        (§
            (§ return (§ expr RT.vector(name, RT.seq(paramTypes))))
        )

        static NewInstanceMethod parse(ObjExpr objx, ISeq form, Symbol thistag, Map overrideables)
        (§
            ;; (methodname [this-name args*] body...)
            ;; this-name might be nil
            NewInstanceMethod method = new NewInstanceMethod(objx, (ObjMethod) METHOD.deref())
            Symbol dotname = (Symbol)RT.first(form)
            Symbol name = (Symbol) Symbol.intern(nil, munge(dotname.name)).withMeta(RT.meta(dotname))
            IPersistentVector parms = (IPersistentVector) RT.second(form)
            if (parms.count() == 0)
            (§
                throw new IllegalArgumentException("Must supply at least one argument for 'this' in: " + dotname)
            )
            Symbol thisName = (Symbol) parms.nth(0)
            parms = RT.subvec(parms, 1, parms.count())
            ISeq body = RT.next(RT.next(form))
            try
            (§
                method.line = lineDeref()
                method.column = columnDeref()
                ;; register as the current method and set up a new env frame
                PathNode pnode =  new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get())
                Var.pushThreadBindings(RT.mapUniqueKeys(
                            METHOD, method,
                            LOCAL_ENV, LOCAL_ENV.deref(),
                            LOOP_LOCALS, nil,
                            NEXT_LOCAL_NUM, 0,
                            CLEAR_PATH, pnode,
                            CLEAR_ROOT, pnode,
                            CLEAR_SITES, PersistentHashMap.EMPTY,
                            METHOD_RETURN_CONTEXT, RT.T
                ))

                ;; register 'this' as local 0
                if (thisName != nil)
                (§
                    registerLocal((thisName == nil) ? dummyThis:thisName, thistag, nil, false)
                )
                else
                (§
                    getAndIncLocalNum()
                )

                PersistentVector argLocals = PersistentVector.EMPTY
                method.retClass = tagClass(tagOf(name))
                method.argTypes = new Type[parms.count()]
                boolean hinted = tagOf(name) != nil
                Class[] pclasses = new Class[parms.count()]
                Symbol[] psyms = new Symbol[parms.count()]

                for (int i = 0 i < parms.count() i++)
                (§
                    if (!(parms.nth(i) instanceof Symbol))
                    (§
                        throw new IllegalArgumentException("params must be Symbols")
                    )
                    Symbol p = (Symbol) parms.nth(i)
                    Object tag = tagOf(p)
                    if (tag != nil)
                    (§
                        hinted = true
                    )
                    if (p.getNamespace() != nil)
                    (§
                        p = Symbol.intern(p.name)
                    )
                    Class pclass = tagClass(tag)
                    pclasses[i] = pclass
                    psyms[i] = p
                )
                Map matches = findMethodsWithNameAndArity(name.name, parms.count(), overrideables)
                Object mk = msig(name.name, pclasses)
                java.lang.reflect.Method m = nil
                if (matches.size() > 0)
                (§
                    ;; multiple methods
                    if (matches.size() > 1)
                    (§
                        ;; must be hinted and match one method
                        if (!hinted)
                        (§
                            throw new IllegalArgumentException("Must hint overloaded method: " + name.name)
                        )
                        m = (java.lang.reflect.Method) matches.get(mk)
                        if (m == nil)
                        (§
                            throw new IllegalArgumentException("Can't find matching overloaded method: " + name.name)
                        )
                        if (m.getReturnType() != method.retClass)
                        (§
                            throw new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName())
                        )
                    )
                    else ;; one match
                    (§
                        ;; if hinted, validate match
                        if (hinted)
                        (§
                            m = (java.lang.reflect.Method) matches.get(mk)
                            if (m == nil)
                            (§
                                throw new IllegalArgumentException("Can't find matching method: " + name.name + ", leave off hints for auto match.")
                            )
                            if (m.getReturnType() != method.retClass)
                            (§
                                throw new IllegalArgumentException("Mismatched return type: " + name.name + ", expected: " + m.getReturnType().getName()  + ", had: " + method.retClass.getName())
                            )
                        )
                        else ;; adopt found method sig
                        (§
                            m = (java.lang.reflect.Method) matches.values().iterator().next()
                            method.retClass = m.getReturnType()
                            pclasses = m.getParameterTypes()
                        )
                    )
                )
                else
                (§
                    throw new IllegalArgumentException("Can't define method not in interfaces: " + name.name)
                )

                ;; validate unque name+arity among additional methods

                method.retType = Type.getType(method.retClass)
                method.exclasses = m.getExceptionTypes()

                for (int i = 0 i < parms.count() i++)
                (§
                    LocalBinding lb = registerLocal(psyms[i], nil, new MethodParamExpr(pclasses[i]), true)
                    argLocals = argLocals.assocN(i, lb)
                    method.argTypes[i] = Type.getType(pclasses[i])
                )
                for (int i = 0 i < parms.count() i++)
                (§
                    if (pclasses[i] == long.class || pclasses[i] == double.class)
                    (§
                        getAndIncLocalNum()
                    )
                )
                LOOP_LOCALS.set(argLocals)
                method.name = name.name
                method.methodMeta = RT.meta(name)
                method.parms = parms
                method.argLocals = argLocals
                method.body = (new BodyExpr.Parser()).parse(C.RETURN, body)
                (§ return (§ expr method))
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )

        private static Map findMethodsWithNameAndArity(String name, int arity, Map mm)
        (§
            Map ret = new HashMap()
            for (Object o :in mm.entrySet())
            (§
                Map.Entry e = (Map.Entry) o
                java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue()
                if (name.equals(m.getName()) && m.getParameterTypes().length == arity)
                (§
                    ret.put(e.getKey(), e.getValue())
                )
            )
            (§ return (§ expr ret))
        )

        private static Map findMethodsWithName(String name, Map mm)
        (§
            Map ret = new HashMap()
            for (Object o :in mm.entrySet())
            (§
                Map.Entry e = (Map.Entry) o
                java.lang.reflect.Method m = (java.lang.reflect.Method) e.getValue()
                if (name.equals(m.getName()))
                (§
                    ret.put(e.getKey(), e.getValue())
                )
            )
            (§ return (§ expr ret))
        )

        public void emit(ObjExpr obj, ClassVisitor cv)
        (§
            Method m = new Method(getMethodName(), getReturnType(), getArgTypes())

            Type[] extypes = nil
            if (exclasses.length > 0)
            (§
                extypes = new Type[exclasses.length]
                for (int i = 0 i < exclasses.length i++)
                (§
                    extypes[i] = Type.getType(exclasses[i])
                )
            )
            GeneratorAdapter gen = new GeneratorAdapter(ACC_PUBLIC, m, nil, extypes, cv)
            addAnnotation(gen, methodMeta)
            for (int i = 0 i < parms.count() i++)
            (§
                IPersistentMap meta = RT.meta(parms.nth(i))
                addParameterAnnotation(gen, meta, i)
            )
            gen.visitCode()

            Label loopLabel = gen.mark()

            gen.visitLineNumber(line, loopLabel)
            try
            (§
                Var.pushThreadBindings(RT.map(LOOP_LABEL, loopLabel, METHOD, this))

                emitBody(objx, gen, retClass, body)
                Label end = gen.mark()
                gen.visitLocalVariable("this", obj.objtype.getDescriptor(), nil, loopLabel, end, 0)
                for (ISeq lbs = argLocals.seq() lbs != nil lbs = lbs.next())
                (§
                    LocalBinding lb = (LocalBinding) lbs.first()
                    gen.visitLocalVariable(lb.name, argTypes[lb.idx-1].getDescriptor(), nil, loopLabel, end, lb.idx)
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )

            gen.returnValue()
            gen.endMethod()
        )
    )

    static boolean inty(Class c)
    (§
        (§ return (§ expr (c == int.class || c == short.class || c == byte.class || c == char.class)))
    )

    static Class retType(Class tc, Class ret)
    (§
        if (tc == nil)
        (§
            (§ return (§ expr ret))
        )
        if (ret == nil)
        (§
            (§ return (§ expr tc))
        )
        if (ret.isPrimitive() && tc.isPrimitive())
        (§
            if ((inty(ret) && inty(tc)) || (ret == tc))
            (§
                (§ return (§ expr tc))
            )
            throw new UnsupportedOperationException("Cannot coerce " + ret + " to " + tc + ", use a cast instead")
        )
        (§ return (§ expr tc))
    )

    static Class primClass(Symbol sym)
    (§
        if (sym == nil)
        (§
            (§ return (§ expr nil))
        )
        Class c = nil
        if (sym.name.equals("int"))
        (§
            c = int.class
        )
        else if (sym.name.equals("long"))
        (§
            c = long.class
        )
        else if (sym.name.equals("float"))
        (§
            c = float.class
        )
        else if (sym.name.equals("double"))
        (§
            c = double.class
        )
        else if (sym.name.equals("char"))
        (§
            c = char.class
        )
        else if (sym.name.equals("short"))
        (§
            c = short.class
        )
        else if (sym.name.equals("byte"))
        (§
            c = byte.class
        )
        else if (sym.name.equals("boolean"))
        (§
            c = boolean.class
        )
        else if (sym.name.equals("void"))
        (§
            c = void.class
        )
        (§ return (§ expr c))
    )

    static Class tagClass(Object tag)
    (§
        if (tag == nil)
        (§
            (§ return (§ expr Object.class))
        )
        Class c = nil
        if (tag instanceof Symbol)
        (§
            c = primClass((Symbol) tag)
        )
        if (c == nil)
        (§
            c = HostExpr.tagToClass(tag)
        )
        (§ return (§ expr c))
    )

    static Class primClass(Class c)
    (§
        (§ return (§ expr c.isPrimitive() ? c :or Object.class))
    )

    static Class boxClass(Class p)
    (§
        if (!p.isPrimitive())
        (§
            (§ return (§ expr p))
        )

        Class c = nil

        if (p == Integer.TYPE)
        (§
            c = Integer.class
        )
        else if (p == Long.TYPE)
        (§
            c = Long.class
        )
        else if (p == Float.TYPE)
        (§
            c = Float.class
        )
        else if (p == Double.TYPE)
        (§
            c = Double.class
        )
        else if (p == Character.TYPE)
        (§
            c = Character.class
        )
        else if (p == Short.TYPE)
        (§
            c = Short.class
        )
        else if (p == Byte.TYPE)
        (§
            c = Byte.class
        )
        else if (p == Boolean.TYPE)
        (§
            c = Boolean.class
        )

        (§ return (§ expr c))
    )

    static public class MethodParamExpr implements Expr, MaybePrimitiveExpr
    (§
        final Class c

        public MethodParamExpr(Class c)
        (§
            this.c = c
        )

        public Object eval()
        (§
            throw Util.runtimeException("Can't eval")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            throw Util.runtimeException("Can't emit")
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (c != nil)))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr c))
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr Util.isPrimitive(c)))
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            throw Util.runtimeException("Can't emit")
        )
    )

    public static class CaseExpr implements Expr, MaybePrimitiveExpr
    (§
        public final LocalBindingExpr expr
        public final int shift, mask, low, high
        public final Expr defaultExpr
        public final SortedMap<Integer, Expr> tests
        public final HashMap<Integer, Expr> thens
        public final Keyword switchType
        public final Keyword testType
        public final Set<Integer> skipCheck
        public final Class returnType
        public final int line
        public final int column

        final static Type NUMBER_TYPE = Type.getType(Number.class)
        final static Method intValueMethod = Method.getMethod("int intValue()")

        final static Method hashMethod = Method.getMethod("int hash(Object)")
        final static Method hashCodeMethod = Method.getMethod("int hashCode()")
        final static Method equivMethod = Method.getMethod("boolean equiv(Object, Object)")
        final static Keyword compactKey = Keyword.intern(nil, "compact")
        final static Keyword sparseKey = Keyword.intern(nil, "sparse")
        final static Keyword hashIdentityKey = Keyword.intern(nil, "hash-identity")
        final static Keyword hashEquivKey = Keyword.intern(nil, "hash-equiv")
        final static Keyword intKey = Keyword.intern(nil, "int")

        ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
        public CaseExpr(int line, int column, LocalBindingExpr expr, int shift, int mask, int low, int high, Expr defaultExpr, SortedMap<Integer, Expr> tests, HashMap<Integer, Expr> thens, Keyword switchType, Keyword testType, Set<Integer> skipCheck)
        (§
            this.expr = expr
            this.shift = shift
            this.mask = mask
            this.low = low
            this.high = high
            this.defaultExpr = defaultExpr
            this.tests = tests
            this.thens = thens
            this.line = line
            this.column = column
            if (switchType != compactKey && switchType != sparseKey)
            (§
                throw new IllegalArgumentException("Unexpected switch type: "+switchType)
            )
            this.switchType = switchType
            if (testType != intKey && testType != hashEquivKey && testType != hashIdentityKey)
            (§
                throw new IllegalArgumentException("Unexpected test type: "+switchType)
            )
            this.testType = testType
            this.skipCheck = skipCheck
            Collection<Expr> returns = new ArrayList(thens.values())
            returns.add(defaultExpr)
            this.returnType = maybeJavaClass(returns)
            if (RT.count(skipCheck) > 0 && RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
            (§
                RT.errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", SOURCE_PATH.deref(), line, column)
            )
        )

        public boolean hasJavaClass()
        (§
            (§ return (§ expr (returnType != nil)))
        )

        public boolean canEmitPrimitive()
        (§
            (§ return (§ expr Util.isPrimitive(returnType)))
        )

        public Class getJavaClass()
        (§
            (§ return (§ expr returnType))
        )

        public Object eval()
        (§
            throw new UnsupportedOperationException("Can't eval case")
        )

        public void emit(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, false)
        )

        public void emitUnboxed(C context, ObjExpr objx, GeneratorAdapter gen)
        (§
            doEmit(context, objx, gen, true)
        )

        public void doEmit(C context, ObjExpr objx, GeneratorAdapter gen, boolean emitUnboxed)
        (§
            Label defaultLabel = gen.newLabel()
            Label endLabel = gen.newLabel()
            SortedMap<Integer, Label> labels = new TreeMap()

            for (Integer i :in tests.keySet())
            (§
                labels.put(i, gen.newLabel())
            )

            gen.visitLineNumber(line, gen.mark())

            Class primExprClass = maybePrimitiveType(expr)
            Type primExprType = (primExprClass == nil) ? nil :or Type.getType(primExprClass)

            if (testType == intKey)
            (§
                emitExprForInts(objx, gen, primExprType, defaultLabel)
            )
            else
            (§
                emitExprForHashes(objx, gen)
            )

            if (switchType == sparseKey)
            (§
                Label[] la = new Label[labels.size()]
                la = labels.values().toArray(la)
                int[] ints = Numbers.int_array(tests.keySet())
                gen.visitLookupSwitchInsn(defaultLabel, ints, la)
            )
            else
            (§
                Label[] la = new Label[(high - low) + 1]
                for (int i = low i <= high i++)
                (§
                    la[i-low] = labels.containsKey(i) ? labels.get(i) :or defaultLabel
                )
                gen.visitTableSwitchInsn(low, high, defaultLabel, la)
            )

            for (Integer i :in labels.keySet())
            (§
                gen.mark(labels.get(i))
                if (testType == intKey)
                (§
                    emitThenForInts(objx, gen, primExprType, tests.get(i), thens.get(i), defaultLabel, emitUnboxed)
                )
                else if (RT.contains(skipCheck, i) == RT.T)
                (§
                    emitExpr(objx, gen, thens.get(i), emitUnboxed)
                )
                else
                (§
                    emitThenForHashes(objx, gen, tests.get(i), thens.get(i), defaultLabel, emitUnboxed)
                )
                gen.goTo(endLabel)
            )

            gen.mark(defaultLabel)
            emitExpr(objx, gen, defaultExpr, emitUnboxed)
            gen.mark(endLabel)
            if (context == C.STATEMENT)
            (§
                gen.pop()
            )
        )

        private boolean isShiftMasked()
        (§
            (§ return (§ expr (mask != 0)))
        )

        private void emitShiftMask(GeneratorAdapter gen)
        (§
            if (isShiftMasked())
            (§
                gen.push(shift)
                gen.visitInsn(ISHR)
                gen.push(mask)
                gen.visitInsn(IAND)
            )
        )

        private void emitExprForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Label defaultLabel)
        (§
            if (exprType == nil)
            (§
                if (RT.booleanCast(RT.WARN_ON_REFLECTION.deref()))
                (§
                    RT.errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", SOURCE_PATH.deref(), line, column)
                )
                expr.emit(C.EXPRESSION, objx, gen)
                gen.instanceOf(NUMBER_TYPE)
                gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel)
                expr.emit(C.EXPRESSION, objx, gen)
                gen.checkCast(NUMBER_TYPE)
                gen.invokeVirtual(NUMBER_TYPE, intValueMethod)
                emitShiftMask(gen)
            )
            else if (exprType == Type.LONG_TYPE || exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
            (§
                expr.emitUnboxed(C.EXPRESSION, objx, gen)
                gen.cast(exprType, Type.INT_TYPE)
                emitShiftMask(gen)
            )
            else
            (§
                gen.goTo(defaultLabel)
            )
        )

        private void emitThenForInts(ObjExpr objx, GeneratorAdapter gen, Type exprType, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
        (§
            if (exprType == nil)
            (§
                expr.emit(C.EXPRESSION, objx, gen)
                test.emit(C.EXPRESSION, objx, gen)
                gen.invokeStatic(UTIL_TYPE, equivMethod)
                gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel)
                emitExpr(objx, gen, then, emitUnboxed)
            )
            else if (exprType == Type.LONG_TYPE)
            (§
                ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen)
                expr.emitUnboxed(C.EXPRESSION, objx, gen)
                gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel)
                emitExpr(objx, gen, then, emitUnboxed)
            )
            else if (exprType == Type.INT_TYPE || exprType == Type.SHORT_TYPE || exprType == Type.BYTE_TYPE)
            (§
                if (isShiftMasked())
                (§
                    ((NumberExpr)test).emitUnboxed(C.EXPRESSION, objx, gen)
                    expr.emitUnboxed(C.EXPRESSION, objx, gen)
                    gen.cast(exprType, Type.LONG_TYPE)
                    gen.ifCmp(Type.LONG_TYPE, GeneratorAdapter.NE, defaultLabel)
                )
                ;; else direct match
                emitExpr(objx, gen, then, emitUnboxed)
            )
            else
            (§
                gen.goTo(defaultLabel)
            )
        )

        private void emitExprForHashes(ObjExpr objx, GeneratorAdapter gen)
        (§
            expr.emit(C.EXPRESSION, objx, gen)
            gen.invokeStatic(UTIL_TYPE, hashMethod)
            emitShiftMask(gen)
        )

        private void emitThenForHashes(ObjExpr objx, GeneratorAdapter gen, Expr test, Expr then, Label defaultLabel, boolean emitUnboxed)
        (§
            expr.emit(C.EXPRESSION, objx, gen)
            test.emit(C.EXPRESSION, objx, gen)
            if (testType == hashIdentityKey)
            (§
                gen.visitJumpInsn(IF_ACMPNE, defaultLabel)
            )
            else
            (§
                gen.invokeStatic(UTIL_TYPE, equivMethod)
                gen.ifZCmp(GeneratorAdapter.EQ, defaultLabel)
            )
            emitExpr(objx, gen, then, emitUnboxed)
        )

        private static void emitExpr(ObjExpr objx, GeneratorAdapter gen, Expr expr, boolean emitUnboxed)
        (§
            if (emitUnboxed && expr instanceof MaybePrimitiveExpr)
            (§
                ((MaybePrimitiveExpr)expr).emitUnboxed(C.EXPRESSION, objx, gen)
            )
            else
            (§
                expr.emit(C.EXPRESSION, objx, gen)
            )
        )

        static class Parser implements IParser
        (§
            ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
            ;; prepared by case macro and presumed correct
            ;; case macro binds actual expr in let so expr is always a local,
            ;; no need to worry about multiple evaluation
            public Expr parse(C context, Object frm)
            (§
                ISeq form = (ISeq) frm
                if (context == C.EVAL)
                (§
                    (§ return (§ expr analyze(context, RT.list(RT.list(FNONCE, PersistentVector.EMPTY, form)))))
                )
                IPersistentVector args = LazilyPersistentVector.create(form.next())

                Object exprForm = args.nth(0)
                int shift = ((Number)args.nth(1)).intValue()
                int mask = ((Number)args.nth(2)).intValue()
                Object defaultForm = args.nth(3)
                Map caseMap = (Map)args.nth(4)
                Keyword switchType = ((Keyword)args.nth(5))
                Keyword testType = ((Keyword)args.nth(6))
                Set skipCheck = (RT.count(args) < 8) ? nil :or (Set)args.nth(7)

                ISeq keys = RT.keys(caseMap)
                int low = ((Number)RT.first(keys)).intValue()
                int high = ((Number)RT.nth(keys, RT.count(keys) - 1)).intValue()

                LocalBindingExpr testexpr = (LocalBindingExpr) analyze(C.EXPRESSION, exprForm)
                testexpr.shouldClear = false

                SortedMap<Integer, Expr> tests = new TreeMap()
                HashMap<Integer, Expr> thens = new HashMap()

                PathNode branch = new PathNode(PATHTYPE.BRANCH, (PathNode) CLEAR_PATH.get())

                for (Object o :in caseMap.entrySet())
                (§
                    Map.Entry e = (Map.Entry) o
                    Integer minhash = ((Number)e.getKey()).intValue()
                    Object pair = e.getValue() ;; [test-val then-expr]
                    Expr testExpr = (testType == intKey) ? NumberExpr.parse(((Number)RT.first(pair)).intValue()) :or new ConstantExpr(RT.first(pair))
                    tests.put(minhash, testExpr)

                    Expr thenExpr
                    try
                    (§
                        Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch)))
                        thenExpr = analyze(context, RT.second(pair))
                    )
                    finally
                    (§
                        Var.popThreadBindings()
                    )
                    thens.put(minhash, thenExpr)
                )

                Expr defaultExpr
                try
                (§
                    Var.pushThreadBindings(RT.map(CLEAR_PATH, new PathNode(PATHTYPE.PATH, branch)))
                    defaultExpr = analyze(context, args.nth(3))
                )
                finally
                (§
                    Var.popThreadBindings()
                )

                int line = ((Number)LINE.deref()).intValue()
                int column = ((Number)COLUMN.deref()).intValue()
                (§ return (§ expr new CaseExpr(line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck)))
            )
        )
    )

    static IPersistentCollection emptyVarCallSites()
    (§
        (§ return (§ expr PersistentHashSet.EMPTY))
    )
)
)

(java-ns cloiure.lang.Cons

(§ import java.io.Serializable)

(§ class final public class Cons extends ASeq implements Serializable)
(§
    private final Object _first
    private final ISeq _more

    public Cons(Object first, ISeq _more)
    (§
        this._first = first
        this._more = _more
    )

    public Cons(IPersistentMap meta, Object _first, ISeq _more)
    (§
        super(meta)
        this._first = _first
        this._more = _more
    )

    public Object first()
    (§
        (§ return (§ expr _first))
    )

    public ISeq next()
    (§
        (§ return (§ expr more().seq()))
    )

    public ISeq more()
    (§
        if (_more == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _more))
    )

    public int count()
    (§
        (§ return (§ expr 1 + RT.count(_more)))
    )

    public Cons withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new Cons(meta, _first, _more)))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(§ interface public interface Counted)
(§
    int count()
)
)

(java-ns cloiure.lang.Cycle

(§ class public class Cycle extends ASeq implements IReduce, IPending)
(§
    private final ISeq all ;; never nil
    private final ISeq prev
    private volatile ISeq _current ;; lazily realized
    private volatile ISeq _next ;; cached

    private Cycle(ISeq all, ISeq prev, ISeq current)
    (§
        this.all = all
        this.prev = prev
        this._current = current
    )

    private Cycle(IPersistentMap meta, ISeq all, ISeq prev, ISeq current, ISeq next)
    (§
        super(meta)
        this.all = all
        this.prev = prev
        this._current = current
        this._next = next
    )

    public static ISeq create(ISeq vals)
    (§
        if (vals == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr new Cycle(vals, nil, vals)))
    )

    ;; realization for use of current
    private ISeq current()
    (§
        if (_current == nil)
        (§
            ISeq current = prev.next()
            _current = (current == nil) ? all :or current
        )
        (§ return (§ expr _current))
    )

    public boolean isRealized()
    (§
        (§ return (§ expr (_current != nil)))
    )

    public Object first()
    (§
        (§ return (§ expr current().first()))
    )

    public ISeq next()
    (§
        if (_next == nil)
        (§
            _next = new Cycle(all, current(), nil)
        )
        (§ return (§ expr _next))
    )

    public Cycle withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new Cycle(meta, all, prev, _current, _next)))
    )

    public Object reduce(IFn f)
    (§
        ISeq s = current()
        Object ret = s.first()
        while (true)
        (§
            s = s.next()
            if (s == nil)
            (§
                s = all
            )
            ret = f.invoke(ret, s.first())
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
        )
    )

    public Object reduce(IFn f, Object start)
    (§
        Object ret = start
        ISeq s = current()
        while (true)
        (§
            ret = f.invoke(ret, s.first())
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            s = s.next()
            if (s == nil)
            (§
                s = all
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(§ class public class Delay implements IDeref, IPending)
(§
    volatile Object val
    volatile Throwable exception
    volatile IFn fn

    public Delay(IFn fn)
    (§
        this.fn = fn
        this.val = nil
        this.exception = nil
    )

    static public Object force(Object x)
    (§
        (§ return (§ expr (x instanceof Delay) ? ((Delay) x).deref() :or x))
    )

    public Object deref()
    (§
        if (fn != nil)
        (§
            synchronized (this)
            (§
                ;; double check
                if (fn != nil)
                (§
                    try
                    (§
                        val = fn.invoke()
                    )
                    catch (Throwable t)
                    (§
                        exception = t
                    )
                    fn = nil
                )
            )
        )
        if (exception != nil)
        (§
            throw Util.sneakyThrow(exception)
        )
        (§ return (§ expr val))
    )

    synchronized public boolean isRealized()
    (§
        (§ return (§ expr (fn == nil)))
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(§ class public class DynamicClassLoader extends URLClassLoader)
(§
    HashMap<Integer, Object[]> constantVals = new HashMap<Integer, Object[]>()
    static ConcurrentHashMap<String, Reference<Class>>classCache = new ConcurrentHashMap<String, Reference<Class> >()

    static final URL[] EMPTY_URLS = new URL[] (§)

    static final ReferenceQueue rq = new ReferenceQueue()

    public DynamicClassLoader()
    (§
        ;; pseudo test in lieu of hasContextClassLoader()
        super(EMPTY_URLS, (Thread.currentThread().getContextClassLoader() == nil || Thread.currentThread().getContextClassLoader() == ClassLoader.getSystemClassLoader()) ? Compiler.class.getClassLoader() :or Thread.currentThread().getContextClassLoader())
    )

    public DynamicClassLoader(ClassLoader parent)
    (§
        super(EMPTY_URLS, parent)
    )

    public Class defineClass(String name, byte[] bytes, Object srcForm)
    (§
        Util.clearCache(rq, classCache)
        Class c = defineClass(name, bytes, 0, bytes.length)
        classCache.put(name, new SoftReference(c, rq))
        (§ return (§ expr c))
    )

    static Class<?> findInMemoryClass(String name)
    (§
        Reference<Class> cr = classCache.get(name)
        if (cr != nil)
        (§
            Class c = cr.get()
            if (c != nil)
            (§
                (§ return (§ expr c))
            )
            else
            (§
                classCache.remove(name, cr)
            )
        )
        (§ return (§ expr nil))
    )

    protected Class<?>findClass(String name) throws ClassNotFoundException
    (§
        Class c = findInMemoryClass(name)
        if (c != nil)
        (§
            (§ return (§ expr c))
        )
        else
        (§
            (§ return (§ expr super.findClass(name)))
        )
    )

    protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
    (§
        Class c = findLoadedClass(name)
        if (c == nil)
        (§
            c = findInMemoryClass(name)
            if (c == nil)
            (§
                c = super.loadClass(name, false)
            )
        )
        if (resolve)
        (§
            resolveClass(c)
        )
        (§ return (§ expr c))
    )

    public void registerConstants(int id, Object[] val)
    (§
        constantVals.put(id, val)
    )

    public Object[] getConstants(int id)
    (§
        (§ return (§ expr constantVals.get(id)))
    )

    public void addURL(URL url)
    (§
        super.addURL(url)
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(§ class public class EdnReader)
(§
    static IFn[] macros = new IFn[256]
    static IFn[] dispatchMacros = new IFn[256]
    static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")
    static Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")
    static Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)")
    static Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")

    static IFn taggedReader = new TaggedReader()

    static
    (§
        macros[\"] = new StringReader() ;; oops! "
        macros[\;] = new CommentReader()
        macros[\^] = new MetaReader()
        macros[\(] = new ListReader()
        macros[\)] = new UnmatchedDelimiterReader()
        macros[\[] = new VectorReader()
        macros[\]] = new UnmatchedDelimiterReader()
        macros[\{] = new MapReader()
        macros[\}] = new UnmatchedDelimiterReader()
        macros[\\] = new CharacterReader()
        macros[\#] = new DispatchReader()

        dispatchMacros[\#] = new SymbolicValueReader()
        dispatchMacros[\^] = new MetaReader()
        dispatchMacros[\{] = new SetReader()
        dispatchMacros[\<] = new UnreadableReader()
        dispatchMacros[\_] = new DiscardReader()
        dispatchMacros[\:] = new NamespaceMapReader()
    )

    static boolean nonConstituent(int ch)
    (§
        (§ return (§ expr (ch == \@ || ch == \` || ch == \~)))
    )

    static public Object readString(String s, IPersistentMap opts)
    (§
        PushbackReader r = new PushbackReader(new java.io.StringReader(s))
        (§ return (§ expr read(r, opts)))
    )

    static boolean isWhitespace(int ch)
    (§
        (§ return (§ expr (Character.isWhitespace(ch) || ch == \,)))
    )

    static void unread(PushbackReader r, int ch)
    (§
        if (ch != -1)
        (§
            try
            (§
                r.unread(ch)
            )
            catch (IOException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
    )

    public static class ReaderException extends RuntimeException
    (§
        final int line
        final int column

        public ReaderException(int line, int column, Throwable cause)
        (§
            super(cause)
            this.line = line
            this.column = column
        )
    )

    static public int read1(Reader r)
    (§
        try
        (§
            (§ return (§ expr r.read()))
        )
        catch (IOException e)
        (§
            throw Util.sneakyThrow(e)
        )
    )

    static final Keyword EOF = Keyword.intern(nil, "eof")

    static public Object read(PushbackReader r, IPersistentMap opts)
    (§
        (§ return (§ expr read(r, !opts.containsKey(EOF), opts.valAt(EOF), false, opts)))
    )

    static public Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
    (§
        try
        (§
            while (true)
            (§
                int ch = read1(r)

                while (isWhitespace(ch))
                    ch = read1(r)

                if (ch == -1)
                (§
                    if (eofIsError)
                    (§
                        throw Util.runtimeException("EOF while reading")
                    )
                    (§ return (§ expr eofValue))
                )

                if (Character.isDigit(ch))
                (§
                    Object n = readNumber(r, (char) ch)
                    if (RT.suppressRead())
                    (§
                        (§ return (§ expr nil))
                    )
                    (§ return (§ expr n))
                )

                IFn macroFn = getMacro(ch)
                if (macroFn != nil)
                (§
                    Object ret = macroFn.invoke(r, (char) ch, opts)
                    if (RT.suppressRead())
                    (§
                        (§ return (§ expr nil))
                    )
                    ;; no op macros return the reader
                    if (ret == r)
                    (§
                        continue
                    )
                    (§ return (§ expr ret))
                )

                if (ch == \+ || ch == \-)
                (§
                    int ch2 = read1(r)
                    if (Character.isDigit(ch2))
                    (§
                        unread(r, ch2)
                        Object n = readNumber(r, (char) ch)
                        if (RT.suppressRead())
                        (§
                            (§ return (§ expr nil))
                        )
                        (§ return (§ expr n))
                    )
                    unread(r, ch2)
                )

                String token = readToken(r, (char) ch, true)
                if (RT.suppressRead())
                (§
                    (§ return (§ expr nil))
                )
                (§ return (§ expr interpretToken(token)))
            )
        )
        catch (Exception e)
        (§
            if (isRecursive || !(r instanceof LineNumberingPushbackReader))
            (§
                throw Util.sneakyThrow(e)
            )
            LineNumberingPushbackReader rdr = (LineNumberingPushbackReader) r
            throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)
        )
    )

    static private String readToken(PushbackReader r, char initch, boolean leadConstituent)
    (§
        StringBuilder sb = new StringBuilder()
        if (leadConstituent && nonConstituent(initch))
        (§
            throw Util.runtimeException("Invalid leading character: " + (char)initch)
        )

        sb.append(initch)

        while (true)
        (§
            int ch = read1(r)

            if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
            (§
                unread(r, ch)
                (§ return (§ expr sb.toString()))
            )
            else if (nonConstituent(ch))
            (§
                throw Util.runtimeException("Invalid constituent character: " + (char)ch)
            )
            sb.append((char) ch)
        )
    )

    static private Object readNumber(PushbackReader r, char initch)
    (§
        StringBuilder sb = new StringBuilder()
        sb.append(initch)

        while (true)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isMacro(ch))
            (§
                unread(r, ch)
                break
            )
            sb.append((char) ch)
        )

        String s = sb.toString()
        Object n = matchNumber(s)
        if (n == nil)
        (§
            throw new NumberFormatException("Invalid number: " + s)
        )
        (§ return (§ expr n))
    )

    static private int readUnicodeChar(String token, int offset, int length, int base)
    (§
        if (token.length() != offset + length)
        (§
            throw new IllegalArgumentException("Invalid unicode character: \\" + token)
        )
        int uc = 0
        for (int i = offset i < offset + length ++i)
        (§
            int d = Character.digit(token.charAt(i), base)
            if (d == -1)
            (§
                throw new IllegalArgumentException("Invalid digit: " + token.charAt(i))
            )
            uc = uc * base + d
        )
        (§ return (§ expr (char) uc))
    )

    static private int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
    (§
        int uc = Character.digit(initch, base)
        if (uc == -1)
        (§
            throw new IllegalArgumentException("Invalid digit: " + (char) initch)
        )
        int i = 1
        for (  i < length ++i)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isMacro(ch))
            (§
                unread(r, ch)
                break
            )
            int d = Character.digit(ch, base)
            if (d == -1)
            (§
                throw new IllegalArgumentException("Invalid digit: " + (char) ch)
            )
            uc = uc * base + d
        )
        if (i != length && exact)
        (§
            throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)
        )
        (§ return (§ expr uc))
    )

    static private Object interpretToken(String s)
    (§
        if (s.equals("nil"))
        (§
            (§ return (§ expr nil))
        )
        else if (s.equals("true"))
        (§
            (§ return (§ expr RT.T))
        )
        else if (s.equals("false"))
        (§
            (§ return (§ expr RT.F))
        )

        Object ret = nil

        ret = matchSymbol(s)
        if (ret != nil)
        (§
            (§ return (§ expr ret))
        )

        throw Util.runtimeException("Invalid token: " + s)
    )

    private static Object matchSymbol(String s)
    (§
        Matcher m = symbolPat.matcher(s)
        if (m.matches())
        (§
            int gc = m.groupCount()
            String ns = m.group(1)
            String name = m.group(2)
            if (ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
            (§
                (§ return (§ expr nil))
            )
            if (s.startsWith("::"))
            (§
                (§ return (§ expr nil))
            )
            boolean isKeyword = s.charAt(0) == \:
            Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 :or 0))
            if (isKeyword)
            (§
                (§ return (§ expr Keyword.intern(sym)))
            )
            (§ return (§ expr sym))
        )
        (§ return (§ expr nil))
    )

    private static Object matchNumber(String s)
    (§
        Matcher m = intPat.matcher(s)
        if (m.matches())
        (§
            if (m.group(2) != nil)
            (§
                if (m.group(8) != nil)
                (§
                    (§ return (§ expr BigInt.ZERO))
                )
                (§ return (§ expr Numbers.num(0)))
            )
            boolean negate = m.group(1).equals("-")
            String n
            int radix = 10
            if ((n = m.group(3)) != nil)
            (§
                radix = 10
            )
            else if ((n = m.group(4)) != nil)
            (§
                radix = 16
            )
            else if ((n = m.group(5)) != nil)
            (§
                radix = 8
            )
            else if ((n = m.group(7)) != nil)
            (§
                radix = Integer.parseInt(m.group(6))
            )
            if (n == nil)
            (§
                (§ return (§ expr nil))
            )
            BigInteger bn = new BigInteger(n, radix)
            if (negate)
            (§
                bn = bn.negate()
            )
            if (m.group(8) != nil)
            (§
                (§ return (§ expr BigInt.fromBigInteger(bn)))
            )
            (§ return (§ expr (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
        )
        m = floatPat.matcher(s)
        if (m.matches())
        (§
            if (m.group(4) != nil)
            (§
                (§ return (§ expr new BigDecimal(m.group(1))))
            )
            (§ return (§ expr Double.parseDouble(s)))
        )
        m = ratioPat.matcher(s)
        if (m.matches())
        (§
            String numerator = m.group(1)
            if (numerator.startsWith("+"))
            (§
                numerator = numerator.substring(1)
            )

            (§ return (§ expr Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
        )
        (§ return (§ expr nil))
    )

    static private IFn getMacro(int ch)
    (§
        if (ch < macros.length)
        (§
            (§ return (§ expr macros[ch]))
        )
        (§ return (§ expr nil))
    )

    static private boolean isMacro(int ch)
    (§
        (§ return (§ expr (ch < macros.length && macros[ch] != nil)))
    )

    static private boolean isTerminatingMacro(int ch)
    (§
        (§ return (§ expr (ch != \# && ch != \' && isMacro(ch))))
    )

    public static class StringReader extends AFn
    (§
        public Object invoke(Object reader, Object doublequote, Object opts)
        (§
            StringBuilder sb = new StringBuilder()
            Reader r = (Reader) reader

            for (int ch = read1(r) ch != \" ch = read1(r)) ;; oops! "
            (§
                if (ch == -1)
                (§
                    throw Util.runtimeException("EOF while reading string")
                )
                if (ch == \\) ;; escape
                (§
                    ch = read1(r)
                    if (ch == -1)
                    (§
                        throw Util.runtimeException("EOF while reading string")
                    )
                    switch (ch)
                    (§
                        (§ case \t)
                            ch = \tab
                            break
                        (§ case \r)
                            ch = \return
                            break
                        (§ case \n)
                            ch = \newline
                            break
                        (§ case \\)
                            break
                        (§ case \") ;; oops! "
                            break
                        (§ case \b)
                            ch = \backspace
                            break
                        (§ case \f)
                            ch = \formfeed
                            break
                        (§ case \u)
                        (§
                            ch = read1(r)
                            if (Character.digit(ch, 16) == -1)
                            (§
                                throw Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)
                            )
                            ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true)
                            break
                        )
                        (§ default)
                        (§
                            if (Character.isDigit(ch))
                            (§
                                ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false)
                                if (ch > 0377)
                                (§
                                    throw Util.runtimeException("Octal escape sequence must be in range [0, 377].")
                                )
                            )
                            else
                            (§
                                throw Util.runtimeException("Unsupported escape character: \\" + (char) ch)
                            )
                            break
                        )
                    )
                )
                sb.append((char) ch)
            )
            (§ return (§ expr sb.toString()))
        )
    )

    public static class CommentReader extends AFn
    (§
        public Object invoke(Object reader, Object semicolon, Object opts)
        (§
            Reader r = (Reader) reader
            int ch
            do
            (§
                ch = read1(r)
            ) while (ch != -1 && ch != \newline && ch != \return)
            (§ return (§ expr r))
        )
    )

    public static class DiscardReader extends AFn
    (§
        public Object invoke(Object reader, Object underscore, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            read(r, true, nil, true, opts)
            (§ return (§ expr r))
        )
    )

    public static class NamespaceMapReader extends AFn
    (§
        public Object invoke(Object reader, Object colon, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader

            ;; Read ns symbol
            Object sym = read(r, true, nil, false, opts)
            if (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
            (§
                throw new RuntimeException("Namespaced map must specify a valid namespace: " + sym)
            )
            String ns = ((Symbol)sym).getName()

            ;; Read map
            int nextChar = read1(r)
            while (isWhitespace(nextChar))
                nextChar = read1(r)
            if (\{ != nextChar)
            (§
                throw new RuntimeException("Namespaced map must specify a map")
            )
            List kvs = readDelimitedList(\}, r, true, opts)
            if ((kvs.size() & 1) == 1)
            (§
                throw Util.runtimeException("Namespaced map literal must contain an even number of forms")
            )

            ;; Construct output map
            Object[] a = new Object[kvs.size()]
            Iterator iter = kvs.iterator()
            for (int i = 0 iter.hasNext() i += 2)
            (§
                Object key = iter.next()
                Object val = iter.next()

                if (key instanceof Keyword)
                (§
                    Keyword kw = (Keyword) key
                    if (kw.getNamespace() == nil)
                    (§
                        key = Keyword.intern(ns, kw.getName())
                    )
                    else if (kw.getNamespace().equals("_"))
                    (§
                        key = Keyword.intern(nil, kw.getName())
                    )
                )
                else if (key instanceof Symbol)
                (§
                    Symbol s = (Symbol) key
                    if (s.getNamespace() == nil)
                    (§
                        key = Symbol.intern(ns, s.getName())
                    )
                    else if (s.getNamespace().equals("_"))
                    (§
                        key = Symbol.intern(nil, s.getName())
                    )
                )
                a[i] = key
                a[i + 1] = val
            )
            (§ return (§ expr RT.map(a)))
        )
    )

    public static class DispatchReader extends AFn
    (§
        public Object invoke(Object reader, Object hash, Object opts)
        (§
            int ch = read1((Reader) reader)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            IFn fn = dispatchMacros[ch]

            if (fn == nil)
            (§
                ;; try tagged reader
                if (Character.isLetter(ch))
                (§
                    unread((PushbackReader) reader, ch)
                    (§ return (§ expr taggedReader.invoke(reader, ch, opts)))
                )

                throw Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))
            )
            (§ return (§ expr fn.invoke(reader, ch, opts)))
        )
    )

    public static class MetaReader extends AFn
    (§
        public Object invoke(Object reader, Object caret, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            int line = -1
            int column = -1
            if (r instanceof LineNumberingPushbackReader)
            (§
                line = ((LineNumberingPushbackReader) r).getLineNumber()
                column = ((LineNumberingPushbackReader) r).getColumnNumber()-1
            )
            Object meta = read(r, true, nil, true, opts)
            if (meta instanceof Symbol || meta instanceof String)
            (§
                meta = RT.map(RT.TAG_KEY, meta)
            )
            else if (meta instanceof Keyword)
            (§
                meta = RT.map(meta, RT.T)
            )
            else if (!(meta instanceof IPersistentMap))
            (§
                throw new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")
            )

            Object o = read(r, true, nil, true, opts)
            if (o instanceof IMeta)
            (§
                if (line != -1 && o instanceof ISeq)
                (§
                    meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column)
                )
                if (o instanceof IReference)
                (§
                    ((IReference)o).resetMeta((IPersistentMap) meta)
                    (§ return (§ expr o))
                )
                Object ometa = RT.meta(o)
                for (ISeq s = RT.seq(meta) s != nil s = s.next())
                (§
                    IMapEntry kv = (IMapEntry) s.first()
                    ometa = RT.assoc(ometa, kv.getKey(), kv.getValue())
                )
                (§ return (§ expr ((IObj) o).withMeta((IPersistentMap) ometa)))
            )
            else
            (§
                throw new IllegalArgumentException("Metadata can only be applied to IMetas")
            )
        )
    )

    public static class CharacterReader extends AFn
    (§
        public Object invoke(Object reader, Object backslash, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            int ch = read1(r)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            String token = readToken(r, (char) ch, false)
            if (token.length() == 1)
            (§
                (§ return (§ expr Character.valueOf(token.charAt(0))))
            )
            else if (token.equals("newline"))
            (§
                (§ return (§ expr \newline))
            )
            else if (token.equals("space"))
            (§
                (§ return (§ expr \space))
            )
            else if (token.equals("tab"))
            (§
                (§ return (§ expr \tab))
            )
            else if (token.equals("backspace"))
            (§
                (§ return (§ expr \backspace))
            )
            else if (token.equals("formfeed"))
            (§
                (§ return (§ expr \formfeed))
            )
            else if (token.equals("return"))
            (§
                (§ return (§ expr \return))
            )
            else if (token.startsWith("u"))
            (§
                char c = (char) readUnicodeChar(token, 1, 4, 16)
                if (c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                (§
                    throw Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))
                )
                (§ return (§ expr c))
            )
            else if (token.startsWith("o"))
            (§
                int len = token.length() - 1
                if (len > 3)
                (§
                    throw Util.runtimeException("Invalid octal escape sequence length: " + len)
                )
                int uc = readUnicodeChar(token, 1, len, 8)
                if (uc > 0377)
                (§
                    throw Util.runtimeException("Octal escape sequence must be in range [0, 377].")
                )
                (§ return (§ expr (char) uc))
            )
            throw Util.runtimeException("Unsupported character: \\" + token)
        )
    )

    public static class ListReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            int line = -1
            int column = -1
            if (r instanceof LineNumberingPushbackReader)
            (§
                line = ((LineNumberingPushbackReader) r).getLineNumber()
                column = ((LineNumberingPushbackReader) r).getColumnNumber()-1
            )
            List list = readDelimitedList(\), r, true, opts)
            if (list.isEmpty())
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            IObj s = (IObj) PersistentList.create(list)
            (§ return (§ expr s))
        )
    )

    public static class VectorReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            (§ return (§ expr LazilyPersistentVector.create(readDelimitedList(\], r, true, opts))))
        )
    )

    public static class MapReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            Object[] a = readDelimitedList(\}, r, true, opts).toArray()
            if ((a.length & 1) == 1)
            (§
                throw Util.runtimeException("Map literal must contain an even number of forms")
            )
            (§ return (§ expr RT.map(a)))
        )
    )

    public static class SetReader extends AFn
    (§
        public Object invoke(Object reader, Object leftbracket, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            (§ return (§ expr PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts))))
        )
    )

    public static class UnmatchedDelimiterReader extends AFn
    (§
        public Object invoke(Object reader, Object rightdelim, Object opts)
        (§
            throw Util.runtimeException("Unmatched delimiter: " + rightdelim)
        )
    )

    public static class UnreadableReader extends AFn
    (§
        public Object invoke(Object reader, Object leftangle, Object opts)
        (§
            throw Util.runtimeException("Unreadable form")
        )
    )

    public static class SymbolicValueReader extends AFn
    (§
        static IPersistentMap specials = PersistentHashMap.create(
            Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
            Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
            Symbol.intern("NaN"), Double.NaN
        )

        public Object invoke(Object reader, Object quote, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, nil, true, opts)

            if (!(o instanceof Symbol))
            (§
                throw Util.runtimeException("Invalid token: ##" + o)
            )
            if (!(specials.containsKey(o)))
            (§
                throw Util.runtimeException("Unknown symbolic value: ##" + o)
            )

            (§ return (§ expr specials.valAt(o)))
        )
    )

    public static List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts)
    (§
        final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1

        ArrayList a = new ArrayList()

        while (true)
        (§
            int ch = read1(r)

            while (isWhitespace(ch))
                ch = read1(r)

            if (ch == -1)
            (§
                if (firstline < 0)
                (§
                    throw Util.runtimeException("EOF while reading")
                )
                else
                (§
                    throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                )
            )

            if (ch == delim)
            (§
                break
            )

            IFn macroFn = getMacro(ch)
            if (macroFn != nil)
            (§
                Object mret = macroFn.invoke(r, (char) ch, opts)
                ;; no op macros return the reader
                if (mret != r)
                (§
                    a.add(mret)
                )
            )
            else
            (§
                unread(r, ch)

                Object o = read(r, true, nil, isRecursive, opts)
                if (o != r)
                (§
                    a.add(o)
                )
            )
        )

        (§ return (§ expr a))
    )

    public static class TaggedReader extends AFn
    (§
        public Object invoke(Object reader, Object firstChar, Object opts)
        (§
            PushbackReader r = (PushbackReader) reader
            Object name = read(r, true, nil, false, opts)
            if (!(name instanceof Symbol))
            (§
                throw new RuntimeException("Reader tag must be a symbol")
            )
            Symbol sym = (Symbol)name
            (§ return (§ expr readTagged(r, sym, (IPersistentMap) opts)))
        )

        static Keyword READERS = Keyword.intern(nil, "readers")
        static Keyword DEFAULT = Keyword.intern(nil, "default")

        private Object readTagged(PushbackReader reader, Symbol tag, IPersistentMap opts)
        (§
            Object o = read(reader, true, nil, true, opts)

            ILookup readers = (ILookup)RT.get(opts, READERS)
            IFn dataReader = (IFn)RT.get(readers, tag)
            if (dataReader == nil)
            (§
                dataReader = (IFn)RT.get(RT.DEFAULT_DATA_READERS.deref(), tag)
            )
            if (dataReader == nil)
            (§
                IFn defaultReader = (IFn)RT.get(opts, DEFAULT)
                if (defaultReader != nil)
                (§
                    (§ return (§ expr defaultReader.invoke(tag, o)))
                )
                else
                (§
                    throw new RuntimeException("No reader function for tag " + tag.toString())
                )
            )
            else
            (§
                (§ return (§ expr dataReader.invoke(o)))
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.io.NotSerializableException)
(§ import java.util.Enumeration)

(§ class public class EnumerationSeq extends ASeq)
(§
    final Enumeration iter
    final State state

    static class State
    (§
        volatile Object val
        volatile Object _rest
    )

    public static EnumerationSeq create(Enumeration iter)
    (§
        if (iter.hasMoreElements())
        (§
            (§ return (§ expr new EnumerationSeq(iter)))
        )
        (§ return (§ expr nil))
    )

    EnumerationSeq(Enumeration iter)
    (§
        this.iter = iter
        state = new State()
        this.state.val = state
        this.state._rest = state
    )

    EnumerationSeq(IPersistentMap meta, Enumeration iter, State state)
    (§
        super(meta)
        this.iter = iter
        this.state = state
    )

    public Object first()
    (§
        if (state.val == state)
        (§
            synchronized (state)
            (§
                if (state.val == state)
                (§
                    state.val = iter.nextElement()
                )
            )
        )
        (§ return (§ expr state.val))
    )

    public ISeq next()
    (§
        if (state._rest == state)
        (§
            synchronized (state)
            (§
                if (state._rest == state)
                (§
                    first()
                    state._rest = create(iter)
                )
            )
        )
        (§ return (§ expr (ISeq) state._rest))
    )

    public EnumerationSeq withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new EnumerationSeq(meta, iter, state)))
    )

    private void writeObject (java.io.ObjectOutputStream out) throws IOException
    (§
        throw new NotSerializableException(getClass().getName())
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(§ class public class ExceptionInfo extends RuntimeException implements IExceptionInfo)
(§
    public final IPersistentMap data

    public ExceptionInfo(String s, IPersistentMap data)
    (§
        this(s, data, nil)
    )

    public ExceptionInfo(String s, IPersistentMap data, Throwable throwable)
    (§
        ;; nil cause is equivalent to not passing a cause
        super(s, throwable)
        if (data != nil)
        (§
            this.data = data
        )
        else
        (§
            throw new IllegalArgumentException("Additional data must be non-nil.")
        )
    )

    public IPersistentMap getData()
    (§
        (§ return (§ expr data))
    )

    public String toString()
    (§
        (§ return (§ expr "cloiure.lang.ExceptionInfo: " + getMessage() + " " + data.toString()))
    )
)
)

(java-ns cloiure.lang.Fn

(§ interface public interface Fn)
(§
)
)

(java-ns cloiure.lang.FnLoaderThunk

(§ class public class FnLoaderThunk extends RestFn)
(§
    final Var v
    final ClassLoader loader
    final String fnClassName
    IFn fn

    public FnLoaderThunk(Var v, String fnClassName)
    (§
        this.v = v
        this.loader = (ClassLoader) RT.FN_LOADER_VAR.get()
        this.fnClassName = fnClassName
        fn = nil
    )

    public Object invoke(Object arg1)
    (§
        load()
        (§ return (§ expr fn.invoke(arg1)))
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        load()
        (§ return (§ expr fn.invoke(arg1, arg2)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        load()
        (§ return (§ expr fn.invoke(arg1, arg2, arg3)))
    )

    protected Object doInvoke(Object args)
    (§
        load()
        (§ return (§ expr fn.applyTo((ISeq) args)))
    )

    private void load()
    (§
        if (fn == nil)
        (§
            try
            (§
                fn = (IFn) Class.forName(fnClassName, true, loader).newInstance()
            )
            catch (Exception e)
            (§
                throw Util.sneakyThrow(e)
            )
            v.root = fn
        )
    )

    public int getRequiredArity()
    (§
        (§ return (§ expr 0))
    )

    public IObj withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr this))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr nil))
    )
)
)

(java-ns cloiure.lang.IAtom

(§ interface public interface IAtom)
(§
    Object swap(IFn f)

    Object swap(IFn f, Object arg)

    Object swap(IFn f, Object arg1, Object arg2)

    Object swap(IFn f, Object x, Object y, ISeq args)

    boolean compareAndSet(Object oldv, Object newv)

    Object reset(Object newval)
)
)

(java-ns cloiure.lang.IAtom2

(§ interface public interface IAtom2 extends IAtom)
(§
    IPersistentVector swapVals(IFn f)

    IPersistentVector swapVals(IFn f, Object arg)

    IPersistentVector swapVals(IFn f, Object arg1, Object arg2)

    IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args)

    IPersistentVector resetVals(Object newv)
)
)

(java-ns cloiure.lang.IBlockingDeref

(§ interface public interface IBlockingDeref)
(§
    Object deref(long ms, Object timeoutValue)
)
)

(java-ns cloiure.lang.IChunk

(§ interface public interface IChunk extends Indexed)
(§
    IChunk dropFirst()

    Object reduce(IFn f, Object start)
)
)

(java-ns cloiure.lang.IChunkedSeq

(§ interface public interface IChunkedSeq extends ISeq, Sequential)
(§
    IChunk chunkedFirst()

    ISeq chunkedNext()

    ISeq chunkedMore()
)
)

(java-ns cloiure.lang.IDeref

(§ interface public interface IDeref)
(§
    Object deref()
)
)

(java-ns cloiure.lang.IEditableCollection

(§ interface public interface IEditableCollection)
(§
    ITransientCollection asTransient()
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(§ interface public interface IExceptionInfo)
(§
    public IPersistentMap getData()
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(§ interface public interface IFn extends Callable, Runnable)
(§
    public Object invoke()

    public Object invoke(Object arg1)

    public Object invoke(Object arg1, Object arg2)

    public Object invoke(Object arg1, Object arg2, Object arg3)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)

    public Object applyTo(ISeq arglist)

    static public interface L (§ long invokePrim() )
    static public interface D (§ double invokePrim() )
    static public interface OL (§ long invokePrim(Object arg0) )
    static public interface OD (§ double invokePrim(Object arg0) )
    static public interface LO (§ Object invokePrim(long arg0) )
    static public interface LL (§ long invokePrim(long arg0) )
    static public interface LD (§ double invokePrim(long arg0) )
    static public interface DO (§ Object invokePrim(double arg0) )
    static public interface DL (§ long invokePrim(double arg0) )
    static public interface DD (§ double invokePrim(double arg0) )
    static public interface OOL (§ long invokePrim(Object arg0, Object arg1) )
    static public interface OOD (§ double invokePrim(Object arg0, Object arg1) )
    static public interface OLO (§ Object invokePrim(Object arg0, long arg1) )
    static public interface OLL (§ long invokePrim(Object arg0, long arg1) )
    static public interface OLD (§ double invokePrim(Object arg0, long arg1) )
    static public interface ODO (§ Object invokePrim(Object arg0, double arg1) )
    static public interface ODL (§ long invokePrim(Object arg0, double arg1) )
    static public interface ODD (§ double invokePrim(Object arg0, double arg1) )
    static public interface LOO (§ Object invokePrim(long arg0, Object arg1) )
    static public interface LOL (§ long invokePrim(long arg0, Object arg1) )
    static public interface LOD (§ double invokePrim(long arg0, Object arg1) )
    static public interface LLO (§ Object invokePrim(long arg0, long arg1) )
    static public interface LLL (§ long invokePrim(long arg0, long arg1) )
    static public interface LLD (§ double invokePrim(long arg0, long arg1) )
    static public interface LDO (§ Object invokePrim(long arg0, double arg1) )
    static public interface LDL (§ long invokePrim(long arg0, double arg1) )
    static public interface LDD (§ double invokePrim(long arg0, double arg1) )
    static public interface DOO (§ Object invokePrim(double arg0, Object arg1) )
    static public interface DOL (§ long invokePrim(double arg0, Object arg1) )
    static public interface DOD (§ double invokePrim(double arg0, Object arg1) )
    static public interface DLO (§ Object invokePrim(double arg0, long arg1) )
    static public interface DLL (§ long invokePrim(double arg0, long arg1) )
    static public interface DLD (§ double invokePrim(double arg0, long arg1) )
    static public interface DDO (§ Object invokePrim(double arg0, double arg1) )
    static public interface DDL (§ long invokePrim(double arg0, double arg1) )
    static public interface DDD (§ double invokePrim(double arg0, double arg1) )
    static public interface OOOL (§ long invokePrim(Object arg0, Object arg1, Object arg2) )
    static public interface OOOD (§ double invokePrim(Object arg0, Object arg1, Object arg2) )
    static public interface OOLO (§ Object invokePrim(Object arg0, Object arg1, long arg2) )
    static public interface OOLL (§ long invokePrim(Object arg0, Object arg1, long arg2) )
    static public interface OOLD (§ double invokePrim(Object arg0, Object arg1, long arg2) )
    static public interface OODO (§ Object invokePrim(Object arg0, Object arg1, double arg2) )
    static public interface OODL (§ long invokePrim(Object arg0, Object arg1, double arg2) )
    static public interface OODD (§ double invokePrim(Object arg0, Object arg1, double arg2) )
    static public interface OLOO (§ Object invokePrim(Object arg0, long arg1, Object arg2) )
    static public interface OLOL (§ long invokePrim(Object arg0, long arg1, Object arg2) )
    static public interface OLOD (§ double invokePrim(Object arg0, long arg1, Object arg2) )
    static public interface OLLO (§ Object invokePrim(Object arg0, long arg1, long arg2) )
    static public interface OLLL (§ long invokePrim(Object arg0, long arg1, long arg2) )
    static public interface OLLD (§ double invokePrim(Object arg0, long arg1, long arg2) )
    static public interface OLDO (§ Object invokePrim(Object arg0, long arg1, double arg2) )
    static public interface OLDL (§ long invokePrim(Object arg0, long arg1, double arg2) )
    static public interface OLDD (§ double invokePrim(Object arg0, long arg1, double arg2) )
    static public interface ODOO (§ Object invokePrim(Object arg0, double arg1, Object arg2) )
    static public interface ODOL (§ long invokePrim(Object arg0, double arg1, Object arg2) )
    static public interface ODOD (§ double invokePrim(Object arg0, double arg1, Object arg2) )
    static public interface ODLO (§ Object invokePrim(Object arg0, double arg1, long arg2) )
    static public interface ODLL (§ long invokePrim(Object arg0, double arg1, long arg2) )
    static public interface ODLD (§ double invokePrim(Object arg0, double arg1, long arg2) )
    static public interface ODDO (§ Object invokePrim(Object arg0, double arg1, double arg2) )
    static public interface ODDL (§ long invokePrim(Object arg0, double arg1, double arg2) )
    static public interface ODDD (§ double invokePrim(Object arg0, double arg1, double arg2) )
    static public interface LOOO (§ Object invokePrim(long arg0, Object arg1, Object arg2) )
    static public interface LOOL (§ long invokePrim(long arg0, Object arg1, Object arg2) )
    static public interface LOOD (§ double invokePrim(long arg0, Object arg1, Object arg2) )
    static public interface LOLO (§ Object invokePrim(long arg0, Object arg1, long arg2) )
    static public interface LOLL (§ long invokePrim(long arg0, Object arg1, long arg2) )
    static public interface LOLD (§ double invokePrim(long arg0, Object arg1, long arg2) )
    static public interface LODO (§ Object invokePrim(long arg0, Object arg1, double arg2) )
    static public interface LODL (§ long invokePrim(long arg0, Object arg1, double arg2) )
    static public interface LODD (§ double invokePrim(long arg0, Object arg1, double arg2) )
    static public interface LLOO (§ Object invokePrim(long arg0, long arg1, Object arg2) )
    static public interface LLOL (§ long invokePrim(long arg0, long arg1, Object arg2) )
    static public interface LLOD (§ double invokePrim(long arg0, long arg1, Object arg2) )
    static public interface LLLO (§ Object invokePrim(long arg0, long arg1, long arg2) )
    static public interface LLLL (§ long invokePrim(long arg0, long arg1, long arg2) )
    static public interface LLLD (§ double invokePrim(long arg0, long arg1, long arg2) )
    static public interface LLDO (§ Object invokePrim(long arg0, long arg1, double arg2) )
    static public interface LLDL (§ long invokePrim(long arg0, long arg1, double arg2) )
    static public interface LLDD (§ double invokePrim(long arg0, long arg1, double arg2) )
    static public interface LDOO (§ Object invokePrim(long arg0, double arg1, Object arg2) )
    static public interface LDOL (§ long invokePrim(long arg0, double arg1, Object arg2) )
    static public interface LDOD (§ double invokePrim(long arg0, double arg1, Object arg2) )
    static public interface LDLO (§ Object invokePrim(long arg0, double arg1, long arg2) )
    static public interface LDLL (§ long invokePrim(long arg0, double arg1, long arg2) )
    static public interface LDLD (§ double invokePrim(long arg0, double arg1, long arg2) )
    static public interface LDDO (§ Object invokePrim(long arg0, double arg1, double arg2) )
    static public interface LDDL (§ long invokePrim(long arg0, double arg1, double arg2) )
    static public interface LDDD (§ double invokePrim(long arg0, double arg1, double arg2) )
    static public interface DOOO (§ Object invokePrim(double arg0, Object arg1, Object arg2) )
    static public interface DOOL (§ long invokePrim(double arg0, Object arg1, Object arg2) )
    static public interface DOOD (§ double invokePrim(double arg0, Object arg1, Object arg2) )
    static public interface DOLO (§ Object invokePrim(double arg0, Object arg1, long arg2) )
    static public interface DOLL (§ long invokePrim(double arg0, Object arg1, long arg2) )
    static public interface DOLD (§ double invokePrim(double arg0, Object arg1, long arg2) )
    static public interface DODO (§ Object invokePrim(double arg0, Object arg1, double arg2) )
    static public interface DODL (§ long invokePrim(double arg0, Object arg1, double arg2) )
    static public interface DODD (§ double invokePrim(double arg0, Object arg1, double arg2) )
    static public interface DLOO (§ Object invokePrim(double arg0, long arg1, Object arg2) )
    static public interface DLOL (§ long invokePrim(double arg0, long arg1, Object arg2) )
    static public interface DLOD (§ double invokePrim(double arg0, long arg1, Object arg2) )
    static public interface DLLO (§ Object invokePrim(double arg0, long arg1, long arg2) )
    static public interface DLLL (§ long invokePrim(double arg0, long arg1, long arg2) )
    static public interface DLLD (§ double invokePrim(double arg0, long arg1, long arg2) )
    static public interface DLDO (§ Object invokePrim(double arg0, long arg1, double arg2) )
    static public interface DLDL (§ long invokePrim(double arg0, long arg1, double arg2) )
    static public interface DLDD (§ double invokePrim(double arg0, long arg1, double arg2) )
    static public interface DDOO (§ Object invokePrim(double arg0, double arg1, Object arg2) )
    static public interface DDOL (§ long invokePrim(double arg0, double arg1, Object arg2) )
    static public interface DDOD (§ double invokePrim(double arg0, double arg1, Object arg2) )
    static public interface DDLO (§ Object invokePrim(double arg0, double arg1, long arg2) )
    static public interface DDLL (§ long invokePrim(double arg0, double arg1, long arg2) )
    static public interface DDLD (§ double invokePrim(double arg0, double arg1, long arg2) )
    static public interface DDDO (§ Object invokePrim(double arg0, double arg1, double arg2) )
    static public interface DDDL (§ long invokePrim(double arg0, double arg1, double arg2) )
    static public interface DDDD (§ double invokePrim(double arg0, double arg1, double arg2) )
    static public interface OOOOL (§ long invokePrim(Object arg0, Object arg1, Object arg2, Object arg3) )
    static public interface OOOOD (§ double invokePrim(Object arg0, Object arg1, Object arg2, Object arg3) )
    static public interface OOOLO (§ Object invokePrim(Object arg0, Object arg1, Object arg2, long arg3) )
    static public interface OOOLL (§ long invokePrim(Object arg0, Object arg1, Object arg2, long arg3) )
    static public interface OOOLD (§ double invokePrim(Object arg0, Object arg1, Object arg2, long arg3) )
    static public interface OOODO (§ Object invokePrim(Object arg0, Object arg1, Object arg2, double arg3) )
    static public interface OOODL (§ long invokePrim(Object arg0, Object arg1, Object arg2, double arg3) )
    static public interface OOODD (§ double invokePrim(Object arg0, Object arg1, Object arg2, double arg3) )
    static public interface OOLOO (§ Object invokePrim(Object arg0, Object arg1, long arg2, Object arg3) )
    static public interface OOLOL (§ long invokePrim(Object arg0, Object arg1, long arg2, Object arg3) )
    static public interface OOLOD (§ double invokePrim(Object arg0, Object arg1, long arg2, Object arg3) )
    static public interface OOLLO (§ Object invokePrim(Object arg0, Object arg1, long arg2, long arg3) )
    static public interface OOLLL (§ long invokePrim(Object arg0, Object arg1, long arg2, long arg3) )
    static public interface OOLLD (§ double invokePrim(Object arg0, Object arg1, long arg2, long arg3) )
    static public interface OOLDO (§ Object invokePrim(Object arg0, Object arg1, long arg2, double arg3) )
    static public interface OOLDL (§ long invokePrim(Object arg0, Object arg1, long arg2, double arg3) )
    static public interface OOLDD (§ double invokePrim(Object arg0, Object arg1, long arg2, double arg3) )
    static public interface OODOO (§ Object invokePrim(Object arg0, Object arg1, double arg2, Object arg3) )
    static public interface OODOL (§ long invokePrim(Object arg0, Object arg1, double arg2, Object arg3) )
    static public interface OODOD (§ double invokePrim(Object arg0, Object arg1, double arg2, Object arg3) )
    static public interface OODLO (§ Object invokePrim(Object arg0, Object arg1, double arg2, long arg3) )
    static public interface OODLL (§ long invokePrim(Object arg0, Object arg1, double arg2, long arg3) )
    static public interface OODLD (§ double invokePrim(Object arg0, Object arg1, double arg2, long arg3) )
    static public interface OODDO (§ Object invokePrim(Object arg0, Object arg1, double arg2, double arg3) )
    static public interface OODDL (§ long invokePrim(Object arg0, Object arg1, double arg2, double arg3) )
    static public interface OODDD (§ double invokePrim(Object arg0, Object arg1, double arg2, double arg3) )
    static public interface OLOOO (§ Object invokePrim(Object arg0, long arg1, Object arg2, Object arg3) )
    static public interface OLOOL (§ long invokePrim(Object arg0, long arg1, Object arg2, Object arg3) )
    static public interface OLOOD (§ double invokePrim(Object arg0, long arg1, Object arg2, Object arg3) )
    static public interface OLOLO (§ Object invokePrim(Object arg0, long arg1, Object arg2, long arg3) )
    static public interface OLOLL (§ long invokePrim(Object arg0, long arg1, Object arg2, long arg3) )
    static public interface OLOLD (§ double invokePrim(Object arg0, long arg1, Object arg2, long arg3) )
    static public interface OLODO (§ Object invokePrim(Object arg0, long arg1, Object arg2, double arg3) )
    static public interface OLODL (§ long invokePrim(Object arg0, long arg1, Object arg2, double arg3) )
    static public interface OLODD (§ double invokePrim(Object arg0, long arg1, Object arg2, double arg3) )
    static public interface OLLOO (§ Object invokePrim(Object arg0, long arg1, long arg2, Object arg3) )
    static public interface OLLOL (§ long invokePrim(Object arg0, long arg1, long arg2, Object arg3) )
    static public interface OLLOD (§ double invokePrim(Object arg0, long arg1, long arg2, Object arg3) )
    static public interface OLLLO (§ Object invokePrim(Object arg0, long arg1, long arg2, long arg3) )
    static public interface OLLLL (§ long invokePrim(Object arg0, long arg1, long arg2, long arg3) )
    static public interface OLLLD (§ double invokePrim(Object arg0, long arg1, long arg2, long arg3) )
    static public interface OLLDO (§ Object invokePrim(Object arg0, long arg1, long arg2, double arg3) )
    static public interface OLLDL (§ long invokePrim(Object arg0, long arg1, long arg2, double arg3) )
    static public interface OLLDD (§ double invokePrim(Object arg0, long arg1, long arg2, double arg3) )
    static public interface OLDOO (§ Object invokePrim(Object arg0, long arg1, double arg2, Object arg3) )
    static public interface OLDOL (§ long invokePrim(Object arg0, long arg1, double arg2, Object arg3) )
    static public interface OLDOD (§ double invokePrim(Object arg0, long arg1, double arg2, Object arg3) )
    static public interface OLDLO (§ Object invokePrim(Object arg0, long arg1, double arg2, long arg3) )
    static public interface OLDLL (§ long invokePrim(Object arg0, long arg1, double arg2, long arg3) )
    static public interface OLDLD (§ double invokePrim(Object arg0, long arg1, double arg2, long arg3) )
    static public interface OLDDO (§ Object invokePrim(Object arg0, long arg1, double arg2, double arg3) )
    static public interface OLDDL (§ long invokePrim(Object arg0, long arg1, double arg2, double arg3) )
    static public interface OLDDD (§ double invokePrim(Object arg0, long arg1, double arg2, double arg3) )
    static public interface ODOOO (§ Object invokePrim(Object arg0, double arg1, Object arg2, Object arg3) )
    static public interface ODOOL (§ long invokePrim(Object arg0, double arg1, Object arg2, Object arg3) )
    static public interface ODOOD (§ double invokePrim(Object arg0, double arg1, Object arg2, Object arg3) )
    static public interface ODOLO (§ Object invokePrim(Object arg0, double arg1, Object arg2, long arg3) )
    static public interface ODOLL (§ long invokePrim(Object arg0, double arg1, Object arg2, long arg3) )
    static public interface ODOLD (§ double invokePrim(Object arg0, double arg1, Object arg2, long arg3) )
    static public interface ODODO (§ Object invokePrim(Object arg0, double arg1, Object arg2, double arg3) )
    static public interface ODODL (§ long invokePrim(Object arg0, double arg1, Object arg2, double arg3) )
    static public interface ODODD (§ double invokePrim(Object arg0, double arg1, Object arg2, double arg3) )
    static public interface ODLOO (§ Object invokePrim(Object arg0, double arg1, long arg2, Object arg3) )
    static public interface ODLOL (§ long invokePrim(Object arg0, double arg1, long arg2, Object arg3) )
    static public interface ODLOD (§ double invokePrim(Object arg0, double arg1, long arg2, Object arg3) )
    static public interface ODLLO (§ Object invokePrim(Object arg0, double arg1, long arg2, long arg3) )
    static public interface ODLLL (§ long invokePrim(Object arg0, double arg1, long arg2, long arg3) )
    static public interface ODLLD (§ double invokePrim(Object arg0, double arg1, long arg2, long arg3) )
    static public interface ODLDO (§ Object invokePrim(Object arg0, double arg1, long arg2, double arg3) )
    static public interface ODLDL (§ long invokePrim(Object arg0, double arg1, long arg2, double arg3) )
    static public interface ODLDD (§ double invokePrim(Object arg0, double arg1, long arg2, double arg3) )
    static public interface ODDOO (§ Object invokePrim(Object arg0, double arg1, double arg2, Object arg3) )
    static public interface ODDOL (§ long invokePrim(Object arg0, double arg1, double arg2, Object arg3) )
    static public interface ODDOD (§ double invokePrim(Object arg0, double arg1, double arg2, Object arg3) )
    static public interface ODDLO (§ Object invokePrim(Object arg0, double arg1, double arg2, long arg3) )
    static public interface ODDLL (§ long invokePrim(Object arg0, double arg1, double arg2, long arg3) )
    static public interface ODDLD (§ double invokePrim(Object arg0, double arg1, double arg2, long arg3) )
    static public interface ODDDO (§ Object invokePrim(Object arg0, double arg1, double arg2, double arg3) )
    static public interface ODDDL (§ long invokePrim(Object arg0, double arg1, double arg2, double arg3) )
    static public interface ODDDD (§ double invokePrim(Object arg0, double arg1, double arg2, double arg3) )
    static public interface LOOOO (§ Object invokePrim(long arg0, Object arg1, Object arg2, Object arg3) )
    static public interface LOOOL (§ long invokePrim(long arg0, Object arg1, Object arg2, Object arg3) )
    static public interface LOOOD (§ double invokePrim(long arg0, Object arg1, Object arg2, Object arg3) )
    static public interface LOOLO (§ Object invokePrim(long arg0, Object arg1, Object arg2, long arg3) )
    static public interface LOOLL (§ long invokePrim(long arg0, Object arg1, Object arg2, long arg3) )
    static public interface LOOLD (§ double invokePrim(long arg0, Object arg1, Object arg2, long arg3) )
    static public interface LOODO (§ Object invokePrim(long arg0, Object arg1, Object arg2, double arg3) )
    static public interface LOODL (§ long invokePrim(long arg0, Object arg1, Object arg2, double arg3) )
    static public interface LOODD (§ double invokePrim(long arg0, Object arg1, Object arg2, double arg3) )
    static public interface LOLOO (§ Object invokePrim(long arg0, Object arg1, long arg2, Object arg3) )
    static public interface LOLOL (§ long invokePrim(long arg0, Object arg1, long arg2, Object arg3) )
    static public interface LOLOD (§ double invokePrim(long arg0, Object arg1, long arg2, Object arg3) )
    static public interface LOLLO (§ Object invokePrim(long arg0, Object arg1, long arg2, long arg3) )
    static public interface LOLLL (§ long invokePrim(long arg0, Object arg1, long arg2, long arg3) )
    static public interface LOLLD (§ double invokePrim(long arg0, Object arg1, long arg2, long arg3) )
    static public interface LOLDO (§ Object invokePrim(long arg0, Object arg1, long arg2, double arg3) )
    static public interface LOLDL (§ long invokePrim(long arg0, Object arg1, long arg2, double arg3) )
    static public interface LOLDD (§ double invokePrim(long arg0, Object arg1, long arg2, double arg3) )
    static public interface LODOO (§ Object invokePrim(long arg0, Object arg1, double arg2, Object arg3) )
    static public interface LODOL (§ long invokePrim(long arg0, Object arg1, double arg2, Object arg3) )
    static public interface LODOD (§ double invokePrim(long arg0, Object arg1, double arg2, Object arg3) )
    static public interface LODLO (§ Object invokePrim(long arg0, Object arg1, double arg2, long arg3) )
    static public interface LODLL (§ long invokePrim(long arg0, Object arg1, double arg2, long arg3) )
    static public interface LODLD (§ double invokePrim(long arg0, Object arg1, double arg2, long arg3) )
    static public interface LODDO (§ Object invokePrim(long arg0, Object arg1, double arg2, double arg3) )
    static public interface LODDL (§ long invokePrim(long arg0, Object arg1, double arg2, double arg3) )
    static public interface LODDD (§ double invokePrim(long arg0, Object arg1, double arg2, double arg3) )
    static public interface LLOOO (§ Object invokePrim(long arg0, long arg1, Object arg2, Object arg3) )
    static public interface LLOOL (§ long invokePrim(long arg0, long arg1, Object arg2, Object arg3) )
    static public interface LLOOD (§ double invokePrim(long arg0, long arg1, Object arg2, Object arg3) )
    static public interface LLOLO (§ Object invokePrim(long arg0, long arg1, Object arg2, long arg3) )
    static public interface LLOLL (§ long invokePrim(long arg0, long arg1, Object arg2, long arg3) )
    static public interface LLOLD (§ double invokePrim(long arg0, long arg1, Object arg2, long arg3) )
    static public interface LLODO (§ Object invokePrim(long arg0, long arg1, Object arg2, double arg3) )
    static public interface LLODL (§ long invokePrim(long arg0, long arg1, Object arg2, double arg3) )
    static public interface LLODD (§ double invokePrim(long arg0, long arg1, Object arg2, double arg3) )
    static public interface LLLOO (§ Object invokePrim(long arg0, long arg1, long arg2, Object arg3) )
    static public interface LLLOL (§ long invokePrim(long arg0, long arg1, long arg2, Object arg3) )
    static public interface LLLOD (§ double invokePrim(long arg0, long arg1, long arg2, Object arg3) )
    static public interface LLLLO (§ Object invokePrim(long arg0, long arg1, long arg2, long arg3) )
    static public interface LLLLL (§ long invokePrim(long arg0, long arg1, long arg2, long arg3) )
    static public interface LLLLD (§ double invokePrim(long arg0, long arg1, long arg2, long arg3) )
    static public interface LLLDO (§ Object invokePrim(long arg0, long arg1, long arg2, double arg3) )
    static public interface LLLDL (§ long invokePrim(long arg0, long arg1, long arg2, double arg3) )
    static public interface LLLDD (§ double invokePrim(long arg0, long arg1, long arg2, double arg3) )
    static public interface LLDOO (§ Object invokePrim(long arg0, long arg1, double arg2, Object arg3) )
    static public interface LLDOL (§ long invokePrim(long arg0, long arg1, double arg2, Object arg3) )
    static public interface LLDOD (§ double invokePrim(long arg0, long arg1, double arg2, Object arg3) )
    static public interface LLDLO (§ Object invokePrim(long arg0, long arg1, double arg2, long arg3) )
    static public interface LLDLL (§ long invokePrim(long arg0, long arg1, double arg2, long arg3) )
    static public interface LLDLD (§ double invokePrim(long arg0, long arg1, double arg2, long arg3) )
    static public interface LLDDO (§ Object invokePrim(long arg0, long arg1, double arg2, double arg3) )
    static public interface LLDDL (§ long invokePrim(long arg0, long arg1, double arg2, double arg3) )
    static public interface LLDDD (§ double invokePrim(long arg0, long arg1, double arg2, double arg3) )
    static public interface LDOOO (§ Object invokePrim(long arg0, double arg1, Object arg2, Object arg3) )
    static public interface LDOOL (§ long invokePrim(long arg0, double arg1, Object arg2, Object arg3) )
    static public interface LDOOD (§ double invokePrim(long arg0, double arg1, Object arg2, Object arg3) )
    static public interface LDOLO (§ Object invokePrim(long arg0, double arg1, Object arg2, long arg3) )
    static public interface LDOLL (§ long invokePrim(long arg0, double arg1, Object arg2, long arg3) )
    static public interface LDOLD (§ double invokePrim(long arg0, double arg1, Object arg2, long arg3) )
    static public interface LDODO (§ Object invokePrim(long arg0, double arg1, Object arg2, double arg3) )
    static public interface LDODL (§ long invokePrim(long arg0, double arg1, Object arg2, double arg3) )
    static public interface LDODD (§ double invokePrim(long arg0, double arg1, Object arg2, double arg3) )
    static public interface LDLOO (§ Object invokePrim(long arg0, double arg1, long arg2, Object arg3) )
    static public interface LDLOL (§ long invokePrim(long arg0, double arg1, long arg2, Object arg3) )
    static public interface LDLOD (§ double invokePrim(long arg0, double arg1, long arg2, Object arg3) )
    static public interface LDLLO (§ Object invokePrim(long arg0, double arg1, long arg2, long arg3) )
    static public interface LDLLL (§ long invokePrim(long arg0, double arg1, long arg2, long arg3) )
    static public interface LDLLD (§ double invokePrim(long arg0, double arg1, long arg2, long arg3) )
    static public interface LDLDO (§ Object invokePrim(long arg0, double arg1, long arg2, double arg3) )
    static public interface LDLDL (§ long invokePrim(long arg0, double arg1, long arg2, double arg3) )
    static public interface LDLDD (§ double invokePrim(long arg0, double arg1, long arg2, double arg3) )
    static public interface LDDOO (§ Object invokePrim(long arg0, double arg1, double arg2, Object arg3) )
    static public interface LDDOL (§ long invokePrim(long arg0, double arg1, double arg2, Object arg3) )
    static public interface LDDOD (§ double invokePrim(long arg0, double arg1, double arg2, Object arg3) )
    static public interface LDDLO (§ Object invokePrim(long arg0, double arg1, double arg2, long arg3) )
    static public interface LDDLL (§ long invokePrim(long arg0, double arg1, double arg2, long arg3) )
    static public interface LDDLD (§ double invokePrim(long arg0, double arg1, double arg2, long arg3) )
    static public interface LDDDO (§ Object invokePrim(long arg0, double arg1, double arg2, double arg3) )
    static public interface LDDDL (§ long invokePrim(long arg0, double arg1, double arg2, double arg3) )
    static public interface LDDDD (§ double invokePrim(long arg0, double arg1, double arg2, double arg3) )
    static public interface DOOOO (§ Object invokePrim(double arg0, Object arg1, Object arg2, Object arg3) )
    static public interface DOOOL (§ long invokePrim(double arg0, Object arg1, Object arg2, Object arg3) )
    static public interface DOOOD (§ double invokePrim(double arg0, Object arg1, Object arg2, Object arg3) )
    static public interface DOOLO (§ Object invokePrim(double arg0, Object arg1, Object arg2, long arg3) )
    static public interface DOOLL (§ long invokePrim(double arg0, Object arg1, Object arg2, long arg3) )
    static public interface DOOLD (§ double invokePrim(double arg0, Object arg1, Object arg2, long arg3) )
    static public interface DOODO (§ Object invokePrim(double arg0, Object arg1, Object arg2, double arg3) )
    static public interface DOODL (§ long invokePrim(double arg0, Object arg1, Object arg2, double arg3) )
    static public interface DOODD (§ double invokePrim(double arg0, Object arg1, Object arg2, double arg3) )
    static public interface DOLOO (§ Object invokePrim(double arg0, Object arg1, long arg2, Object arg3) )
    static public interface DOLOL (§ long invokePrim(double arg0, Object arg1, long arg2, Object arg3) )
    static public interface DOLOD (§ double invokePrim(double arg0, Object arg1, long arg2, Object arg3) )
    static public interface DOLLO (§ Object invokePrim(double arg0, Object arg1, long arg2, long arg3) )
    static public interface DOLLL (§ long invokePrim(double arg0, Object arg1, long arg2, long arg3) )
    static public interface DOLLD (§ double invokePrim(double arg0, Object arg1, long arg2, long arg3) )
    static public interface DOLDO (§ Object invokePrim(double arg0, Object arg1, long arg2, double arg3) )
    static public interface DOLDL (§ long invokePrim(double arg0, Object arg1, long arg2, double arg3) )
    static public interface DOLDD (§ double invokePrim(double arg0, Object arg1, long arg2, double arg3) )
    static public interface DODOO (§ Object invokePrim(double arg0, Object arg1, double arg2, Object arg3) )
    static public interface DODOL (§ long invokePrim(double arg0, Object arg1, double arg2, Object arg3) )
    static public interface DODOD (§ double invokePrim(double arg0, Object arg1, double arg2, Object arg3) )
    static public interface DODLO (§ Object invokePrim(double arg0, Object arg1, double arg2, long arg3) )
    static public interface DODLL (§ long invokePrim(double arg0, Object arg1, double arg2, long arg3) )
    static public interface DODLD (§ double invokePrim(double arg0, Object arg1, double arg2, long arg3) )
    static public interface DODDO (§ Object invokePrim(double arg0, Object arg1, double arg2, double arg3) )
    static public interface DODDL (§ long invokePrim(double arg0, Object arg1, double arg2, double arg3) )
    static public interface DODDD (§ double invokePrim(double arg0, Object arg1, double arg2, double arg3) )
    static public interface DLOOO (§ Object invokePrim(double arg0, long arg1, Object arg2, Object arg3) )
    static public interface DLOOL (§ long invokePrim(double arg0, long arg1, Object arg2, Object arg3) )
    static public interface DLOOD (§ double invokePrim(double arg0, long arg1, Object arg2, Object arg3) )
    static public interface DLOLO (§ Object invokePrim(double arg0, long arg1, Object arg2, long arg3) )
    static public interface DLOLL (§ long invokePrim(double arg0, long arg1, Object arg2, long arg3) )
    static public interface DLOLD (§ double invokePrim(double arg0, long arg1, Object arg2, long arg3) )
    static public interface DLODO (§ Object invokePrim(double arg0, long arg1, Object arg2, double arg3) )
    static public interface DLODL (§ long invokePrim(double arg0, long arg1, Object arg2, double arg3) )
    static public interface DLODD (§ double invokePrim(double arg0, long arg1, Object arg2, double arg3) )
    static public interface DLLOO (§ Object invokePrim(double arg0, long arg1, long arg2, Object arg3) )
    static public interface DLLOL (§ long invokePrim(double arg0, long arg1, long arg2, Object arg3) )
    static public interface DLLOD (§ double invokePrim(double arg0, long arg1, long arg2, Object arg3) )
    static public interface DLLLO (§ Object invokePrim(double arg0, long arg1, long arg2, long arg3) )
    static public interface DLLLL (§ long invokePrim(double arg0, long arg1, long arg2, long arg3) )
    static public interface DLLLD (§ double invokePrim(double arg0, long arg1, long arg2, long arg3) )
    static public interface DLLDO (§ Object invokePrim(double arg0, long arg1, long arg2, double arg3) )
    static public interface DLLDL (§ long invokePrim(double arg0, long arg1, long arg2, double arg3) )
    static public interface DLLDD (§ double invokePrim(double arg0, long arg1, long arg2, double arg3) )
    static public interface DLDOO (§ Object invokePrim(double arg0, long arg1, double arg2, Object arg3) )
    static public interface DLDOL (§ long invokePrim(double arg0, long arg1, double arg2, Object arg3) )
    static public interface DLDOD (§ double invokePrim(double arg0, long arg1, double arg2, Object arg3) )
    static public interface DLDLO (§ Object invokePrim(double arg0, long arg1, double arg2, long arg3) )
    static public interface DLDLL (§ long invokePrim(double arg0, long arg1, double arg2, long arg3) )
    static public interface DLDLD (§ double invokePrim(double arg0, long arg1, double arg2, long arg3) )
    static public interface DLDDO (§ Object invokePrim(double arg0, long arg1, double arg2, double arg3) )
    static public interface DLDDL (§ long invokePrim(double arg0, long arg1, double arg2, double arg3) )
    static public interface DLDDD (§ double invokePrim(double arg0, long arg1, double arg2, double arg3) )
    static public interface DDOOO (§ Object invokePrim(double arg0, double arg1, Object arg2, Object arg3) )
    static public interface DDOOL (§ long invokePrim(double arg0, double arg1, Object arg2, Object arg3) )
    static public interface DDOOD (§ double invokePrim(double arg0, double arg1, Object arg2, Object arg3) )
    static public interface DDOLO (§ Object invokePrim(double arg0, double arg1, Object arg2, long arg3) )
    static public interface DDOLL (§ long invokePrim(double arg0, double arg1, Object arg2, long arg3) )
    static public interface DDOLD (§ double invokePrim(double arg0, double arg1, Object arg2, long arg3) )
    static public interface DDODO (§ Object invokePrim(double arg0, double arg1, Object arg2, double arg3) )
    static public interface DDODL (§ long invokePrim(double arg0, double arg1, Object arg2, double arg3) )
    static public interface DDODD (§ double invokePrim(double arg0, double arg1, Object arg2, double arg3) )
    static public interface DDLOO (§ Object invokePrim(double arg0, double arg1, long arg2, Object arg3) )
    static public interface DDLOL (§ long invokePrim(double arg0, double arg1, long arg2, Object arg3) )
    static public interface DDLOD (§ double invokePrim(double arg0, double arg1, long arg2, Object arg3) )
    static public interface DDLLO (§ Object invokePrim(double arg0, double arg1, long arg2, long arg3) )
    static public interface DDLLL (§ long invokePrim(double arg0, double arg1, long arg2, long arg3) )
    static public interface DDLLD (§ double invokePrim(double arg0, double arg1, long arg2, long arg3) )
    static public interface DDLDO (§ Object invokePrim(double arg0, double arg1, long arg2, double arg3) )
    static public interface DDLDL (§ long invokePrim(double arg0, double arg1, long arg2, double arg3) )
    static public interface DDLDD (§ double invokePrim(double arg0, double arg1, long arg2, double arg3) )
    static public interface DDDOO (§ Object invokePrim(double arg0, double arg1, double arg2, Object arg3) )
    static public interface DDDOL (§ long invokePrim(double arg0, double arg1, double arg2, Object arg3) )
    static public interface DDDOD (§ double invokePrim(double arg0, double arg1, double arg2, Object arg3) )
    static public interface DDDLO (§ Object invokePrim(double arg0, double arg1, double arg2, long arg3) )
    static public interface DDDLL (§ long invokePrim(double arg0, double arg1, double arg2, long arg3) )
    static public interface DDDLD (§ double invokePrim(double arg0, double arg1, double arg2, long arg3) )
    static public interface DDDDO (§ Object invokePrim(double arg0, double arg1, double arg2, double arg3) )
    static public interface DDDDL (§ long invokePrim(double arg0, double arg1, double arg2, double arg3) )
    static public interface DDDDD (§ double invokePrim(double arg0, double arg1, double arg2, double arg3) )
)
)

(java-ns cloiure.lang.IHashEq

(§ interface public interface IHashEq)
(§
    int hasheq()
)
)

(java-ns cloiure.lang.IKeywordLookup

(§ interface public interface IKeywordLookup)
(§
    ILookupThunk getLookupThunk(Keyword k)
)
)

(java-ns cloiure.lang.IKVReduce

(§ interface public interface IKVReduce)
(§
    Object kvreduce(IFn f, Object init)
)
)

(java-ns cloiure.lang.ILookup

(§ interface public interface ILookup)
(§
    Object valAt(Object key)

    Object valAt(Object key, Object notFound)
)
)

(java-ns cloiure.lang.ILookupSite

(§ interface public interface ILookupSite)
(§
    ILookupThunk fault(Object target)
)
)

(java-ns cloiure.lang.ILookupThunk

(§ interface public interface ILookupThunk)
(§
    Object get(Object target)
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(§ interface public interface IMapEntry extends Map.Entry)
(§
    Object key()

    Object val()
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(§ interface public interface IMapIterable)
(§
    Iterator keyIterator()

    Iterator valIterator()
)
)

(java-ns cloiure.lang.IMeta

(§ interface public interface IMeta)
(§
    IPersistentMap meta()
)
)

(java-ns cloiure.lang.Indexed

(§ interface public interface Indexed extends Counted)
(§
    Object nth(int i)

    Object nth(int i, Object notFound)
)
)

(java-ns cloiure.lang.IndexedSeq

(§ interface public interface IndexedSeq extends ISeq, Sequential, Counted)
(§
    public int index()
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

(§ class public class Intrinsics implements Opcodes)
(§
    private static Object[] oa(Object... arr)
    (§
        (§ return (§ expr arr))
    )

    static IPersistentMap ops = RT.map(
            "public static double cloiure.lang.Numbers.add(double,double)", DADD,
            "public static long cloiure.lang.Numbers.and(long,long)", LAND,
            "public static long cloiure.lang.Numbers.or(long,long)", LOR,
            "public static long cloiure.lang.Numbers.xor(long,long)", LXOR,
            "public static double cloiure.lang.Numbers.multiply(double,double)", DMUL,
            "public static double cloiure.lang.Numbers.divide(double,double)", DDIV,
            "public static long cloiure.lang.Numbers.remainder(long,long)", LREM,
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)", oa(L2I, LSHL),
            "public static long cloiure.lang.Numbers.shiftRight(long,long)", oa(L2I, LSHR),
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)", oa(L2I, LUSHR),
            "public static double cloiure.lang.Numbers.minus(double)", DNEG,
            "public static double cloiure.lang.Numbers.minus(double,double)", DSUB,
            "public static double cloiure.lang.Numbers.inc(double)", oa(DCONST_1, DADD),
            "public static double cloiure.lang.Numbers.dec(double)", oa(DCONST_1, DSUB),
            "public static long cloiure.lang.Numbers.quotient(long,long)", LDIV,
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)", ISHL,
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)", ISHR,
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)", IUSHR,
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)", IADD,
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)", ISUB,
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)", INEG,
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)", oa(ICONST_1, IADD),
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)", oa(ICONST_1, ISUB),
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)", IMUL,
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)", IDIV,
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)", IREM,
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)", LADD,
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)", DADD,
            "public static long cloiure.lang.Numbers.unchecked_minus(long)", LNEG,
            "public static double cloiure.lang.Numbers.unchecked_minus(double)", DNEG,
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)", DSUB,
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)", LSUB,
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)", LMUL,
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)", DMUL,
            "public static double cloiure.lang.Numbers.unchecked_inc(double)", oa(DCONST_1, DADD),
            "public static long cloiure.lang.Numbers.unchecked_inc(long)", oa(LCONST_1, LADD),
            "public static double cloiure.lang.Numbers.unchecked_dec(double)", oa(DCONST_1, DSUB),
            "public static long cloiure.lang.Numbers.unchecked_dec(long)", oa(LCONST_1, LSUB),

            "public static short cloiure.lang.RT.aget(short[],int)", SALOAD,
            "public static float cloiure.lang.RT.aget(float[],int)", FALOAD,
            "public static double cloiure.lang.RT.aget(double[],int)", DALOAD,
            "public static int cloiure.lang.RT.aget(int[],int)", IALOAD,
            "public static long cloiure.lang.RT.aget(long[],int)", LALOAD,
            "public static char cloiure.lang.RT.aget(char[],int)", CALOAD,
            "public static byte cloiure.lang.RT.aget(byte[],int)", BALOAD,
            "public static boolean cloiure.lang.RT.aget(boolean[],int)", BALOAD,
            "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)", AALOAD,
            "public static int cloiure.lang.RT.alength(int[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(long[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(char[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(java.lang.Object[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(byte[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(float[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(short[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(boolean[])", ARRAYLENGTH,
            "public static int cloiure.lang.RT.alength(double[])", ARRAYLENGTH,

            "public static double cloiure.lang.RT.doubleCast(long)", L2D,
            "public static double cloiure.lang.RT.doubleCast(double)", NOP,
            "public static double cloiure.lang.RT.doubleCast(float)", F2D,
            "public static double cloiure.lang.RT.doubleCast(int)", I2D,
            "public static double cloiure.lang.RT.doubleCast(short)", I2D,
            "public static double cloiure.lang.RT.doubleCast(byte)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)", NOP,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)", F2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)", L2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)", I2D,
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)", I2D,
            "public static long cloiure.lang.RT.longCast(long)", NOP,
            "public static long cloiure.lang.RT.longCast(short)", I2L,
            "public static long cloiure.lang.RT.longCast(byte)", I2L,
            "public static long cloiure.lang.RT.longCast(int)", I2L,
            "public static int cloiure.lang.RT.uncheckedIntCast(long)", L2I,
            "public static int cloiure.lang.RT.uncheckedIntCast(double)", D2I,
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(short)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(char)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(int)", NOP,
            "public static int cloiure.lang.RT.uncheckedIntCast(float)", F2I,
            "public static long cloiure.lang.RT.uncheckedLongCast(short)", I2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(float)", F2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(double)", D2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)", I2L,
            "public static long cloiure.lang.RT.uncheckedLongCast(long)", NOP,
            "public static long cloiure.lang.RT.uncheckedLongCast(int)", I2L
    )

    ;; map to instructions terminated with comparator for branch to false
    static IPersistentMap preds = RT.map(
            "public static boolean cloiure.lang.Numbers.lt(double,double)", oa(DCMPG, IFGE),
            "public static boolean cloiure.lang.Numbers.lt(long,long)", oa(LCMP, IFGE),
            "public static boolean cloiure.lang.Numbers.equiv(double,double)", oa(DCMPL, IFNE),
            "public static boolean cloiure.lang.Numbers.equiv(long,long)", oa(LCMP, IFNE),
            "public static boolean cloiure.lang.Numbers.lte(double,double)", oa(DCMPG, IFGT),
            "public static boolean cloiure.lang.Numbers.lte(long,long)", oa(LCMP, IFGT),
            "public static boolean cloiure.lang.Numbers.gt(long,long)", oa(LCMP, IFLE),
            "public static boolean cloiure.lang.Numbers.gt(double,double)", oa(DCMPL, IFLE),
            "public static boolean cloiure.lang.Numbers.gte(long,long)", oa(LCMP, IFLT),
            "public static boolean cloiure.lang.Numbers.gte(double,double)", oa(DCMPL, IFLT),
            "public static boolean cloiure.lang.Util.equiv(long,long)", oa(LCMP, IFNE),
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)", oa(IF_ICMPNE),
            "public static boolean cloiure.lang.Util.equiv(double,double)", oa(DCMPL, IFNE),

            "public static boolean cloiure.lang.Numbers.isZero(double)", oa(DCONST_0, DCMPL, IFNE),
            "public static boolean cloiure.lang.Numbers.isZero(long)", oa(LCONST_0, LCMP, IFNE),
            "public static boolean cloiure.lang.Numbers.isPos(long)", oa(LCONST_0, LCMP, IFLE),
            "public static boolean cloiure.lang.Numbers.isPos(double)", oa(DCONST_0, DCMPL, IFLE),
            "public static boolean cloiure.lang.Numbers.isNeg(long)", oa(LCONST_0, LCMP, IFGE),
            "public static boolean cloiure.lang.Numbers.isNeg(double)", oa(DCONST_0, DCMPG, IFGE)
    )
)
)

(java-ns cloiure.lang.IObj

(§ interface public interface IObj extends IMeta)
(§
    public IObj withMeta(IPersistentMap meta)
)
)

(java-ns cloiure.lang.IPending

(§ interface public interface IPending)
(§
    boolean isRealized()
)
)

(java-ns cloiure.lang.IPersistentCollection

(§ interface public interface IPersistentCollection extends Seqable)
(§
    int count()

    IPersistentCollection cons(Object o)

    IPersistentCollection empty()

    boolean equiv(Object o)
)
)

(java-ns cloiure.lang.IPersistentList

(§ interface public interface IPersistentList extends Sequential, IPersistentStack)
(§
)
)

(java-ns cloiure.lang.IPersistentMap

(§ interface public interface IPersistentMap extends Iterable, Associative, Counted)
(§
    IPersistentMap assoc(Object key, Object val)

    IPersistentMap assocEx(Object key, Object val)

    IPersistentMap without(Object key)
)
)

(java-ns cloiure.lang.IPersistentSet

(§ interface public interface IPersistentSet extends IPersistentCollection, Counted)
(§
    public IPersistentSet disjoin(Object key)
    public boolean contains(Object key)
    public Object get(Object key)
)
)

(java-ns cloiure.lang.IPersistentStack

(§ interface public interface IPersistentStack extends IPersistentCollection)
(§
    Object peek()

    IPersistentStack pop()
)
)

(java-ns cloiure.lang.IPersistentVector

(§ interface public interface IPersistentVector extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
(§
    int length()

    IPersistentVector assocN(int i, Object val)

    IPersistentVector cons(Object o)
)
)

(java-ns cloiure.lang.IProxy

(§ interface public interface IProxy)
(§
    public void __initCloiureFnMappings(IPersistentMap m)
    public void __updateCloiureFnMappings(IPersistentMap m)
    public IPersistentMap __getCloiureFnMappings()
)
)

(java-ns cloiure.lang.IRecord

(§ interface public interface IRecord)
(§
)
)

(java-ns cloiure.lang.IReduce

(§ interface public interface IReduce extends IReduceInit)
(§
    Object reduce(IFn f)
)
)

(java-ns cloiure.lang.IReduceInit

(§ interface public interface IReduceInit)
(§
    Object reduce(IFn f, Object start)
)
)

(java-ns cloiure.lang.IRef

(§ interface public interface IRef extends IDeref)
(§
    void setValidator(IFn vf)

    IFn getValidator()

    IPersistentMap getWatches()

    IRef addWatch(Object key, IFn callback)

    IRef removeWatch(Object key)
)
)

(java-ns cloiure.lang.IReference

(§ interface public interface IReference extends IMeta)
(§
    IPersistentMap alterMeta(IFn alter, ISeq args)
    IPersistentMap resetMeta(IPersistentMap m)
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(§ interface public interface ISeq extends IPersistentCollection)
(§
    Object first()

    ISeq next()

    ISeq more()

    ISeq cons(Object o)
)
)

(java-ns cloiure.lang.Iterate

(§ class public class Iterate extends ASeq implements IReduce, IPending)
(§
    private static final Object UNREALIZED_SEED = new Object()
    private final IFn f ;; never nil
    private final Object prevSeed
    private volatile Object _seed ;; lazily realized
    private volatile ISeq _next ;; cached

    private Iterate(IFn f, Object prevSeed, Object seed)
    (§
        this.f = f
        this.prevSeed = prevSeed
        this._seed = seed
    )

    private Iterate(IPersistentMap meta, IFn f, Object prevSeed, Object seed, ISeq next)
    (§
        super(meta)
        this.f = f
        this.prevSeed = prevSeed
        this._seed = seed
        this._next = next
    )

    public static ISeq create(IFn f, Object seed)
    (§
        (§ return (§ expr new Iterate(f, nil, seed)))
    )

    public boolean isRealized()
    (§
        (§ return (§ expr (_seed != UNREALIZED_SEED)))
    )

    public Object first()
    (§
        if (_seed == UNREALIZED_SEED)
        (§
            _seed = f.invoke(prevSeed)
        )
        (§ return (§ expr _seed))
    )

    public ISeq next()
    (§
        if (_next == nil)
        (§
            _next = new Iterate(f, first(), UNREALIZED_SEED)
        )
        (§ return (§ expr _next))
    )

    public Iterate withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new Iterate(meta, f, prevSeed, _seed, _next)))
    )

    public Object reduce(IFn rf)
    (§
        Object first = first()
        Object ret = first
        Object v = f.invoke(first)
        while (true)
        (§
            ret = rf.invoke(ret, v)
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            v = f.invoke(v)
        )
    )

    public Object reduce(IFn rf, Object start)
    (§
        Object ret = start
        Object v = first()
        while (true)
        (§
            ret = rf.invoke(ret, v)
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            v = f.invoke(v)
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.io.NotSerializableException)
(§ import java.util.Iterator)

(§ class public class IteratorSeq extends ASeq)
(§
    final Iterator iter
    final State state

    static class State
    (§
        volatile Object val
        volatile Object _rest
    )

    public static IteratorSeq create(Iterator iter)
    (§
        if (iter.hasNext())
        (§
            (§ return (§ expr new IteratorSeq(iter)))
        )
        (§ return (§ expr nil))
    )

    IteratorSeq(Iterator iter)
    (§
        this.iter = iter
        state = new State()
        this.state.val = state
        this.state._rest = state
    )

    IteratorSeq(IPersistentMap meta, Iterator iter, State state)
    (§
        super(meta)
        this.iter = iter
        this.state = state
    )

    public Object first()
    (§
        if (state.val == state)
        (§
            synchronized (state)
            (§
                if (state.val == state)
                (§
                    state.val = iter.next()
                )
            )
        )
        (§ return (§ expr state.val))
    )

    public ISeq next()
    (§
        if (state._rest == state)
        (§
            synchronized (state)
            (§
                if (state._rest == state)
                (§
                    first()
                    state._rest = create(iter)
                )
            )
        )
        (§ return (§ expr (ISeq) state._rest))
    )

    public IteratorSeq withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new IteratorSeq(meta, iter, state)))
    )

    private void writeObject (java.io.ObjectOutputStream out) throws IOException
    (§
        throw new NotSerializableException(getClass().getName())
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(§ interface public interface ITransientAssociative extends ITransientCollection, ILookup)
(§
    ITransientAssociative assoc(Object key, Object val)
)
)

(java-ns cloiure.lang.ITransientAssociative2

(§ interface public interface ITransientAssociative2 extends ITransientAssociative)
(§
    boolean containsKey(Object key)
    IMapEntry entryAt(Object key)
)
)

(java-ns cloiure.lang.ITransientCollection

(§ interface public interface ITransientCollection)
(§
    ITransientCollection conj(Object val)

    IPersistentCollection persistent()
)
)

(java-ns cloiure.lang.ITransientMap

(§ interface public interface ITransientMap extends ITransientAssociative, Counted)
(§
    ITransientMap assoc(Object key, Object val)

    ITransientMap without(Object key)

    IPersistentMap persistent()
)
)

(java-ns cloiure.lang.ITransientSet

(§ interface public interface ITransientSet extends ITransientCollection, Counted)
(§
    public ITransientSet disjoin(Object key)
    public boolean contains(Object key)
    public Object get(Object key)
)
)

(java-ns cloiure.lang.ITransientVector

(§ interface public interface ITransientVector extends ITransientAssociative, Indexed)
(§
    ITransientVector assocN(int i, Object val)

    ITransientVector pop()
)
)

(java-ns cloiure.lang.IType

(§ interface public interface IType)
(§
)
)

(java-ns cloiure.lang.Keyword

(§ import java.io.ObjectStreamException)
(§ import java.io.Serializable)
(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(§ class public class Keyword implements IFn, Comparable, Named, Serializable, IHashEq)
(§
    private static ConcurrentHashMap<Symbol, Reference<Keyword>> table = new ConcurrentHashMap()

    static final ReferenceQueue rq = new ReferenceQueue()

    public final Symbol sym
    final int hasheq
    transient String _str

    public static Keyword intern(Symbol sym)
    (§
        Keyword k = nil
        Reference<Keyword> existingRef = table.get(sym)
        if (existingRef == nil)
        (§
            Util.clearCache(rq, table)
            if (sym.meta() != nil)
            (§
                sym = (Symbol) sym.withMeta(nil)
            )
            k = new Keyword(sym)
            existingRef = table.putIfAbsent(sym, new WeakReference<Keyword>(k, rq))
        )
        if (existingRef == nil)
        (§
            (§ return (§ expr k))
        )
        Keyword existingk = existingRef.get()
        if (existingk != nil)
        (§
            (§ return (§ expr existingk))
        )
        ;; entry died in the interim, do over
        table.remove(sym, existingRef)
        (§ return (§ expr intern(sym)))
    )

    public static Keyword intern(String ns, String name)
    (§
        (§ return (§ expr intern(Symbol.intern(ns, name))))
    )

    public static Keyword intern(String nsname)
    (§
        (§ return (§ expr intern(Symbol.intern(nsname))))
    )

    private Keyword(Symbol sym)
    (§
        this.sym = sym
        hasheq = sym.hasheq() + 0x9e3779b9
    )

    public static Keyword find(Symbol sym)
    (§
        Reference<Keyword> ref = table.get(sym)
        if (ref != nil)
        (§
            (§ return (§ expr ref.get()))
        )
        else
        (§
            (§ return (§ expr nil))
        )
    )

    public static Keyword find(String ns, String name)
    (§
        (§ return (§ expr find(Symbol.intern(ns, name))))
    )

    public static Keyword find(String nsname)
    (§
        (§ return (§ expr find(Symbol.intern(nsname))))
    )

    public final int hashCode()
    (§
        (§ return (§ expr sym.hashCode() + 0x9e3779b9))
    )

    public int hasheq()
    (§
        (§ return (§ expr hasheq))
    )

    public String toString()
    (§
        if (_str == nil)
        (§
            _str = (":" + sym)
        )
        (§ return (§ expr _str))
    )

    public Object throwArity()
    (§
        throw new IllegalArgumentException("Wrong number of args passed to keyword: " + toString())
    )

    public Object call()
    (§
        (§ return (§ expr throwArity()))
    )

    public void run()
    (§
        throw new UnsupportedOperationException()
    )

    public Object invoke()
    (§
        (§ return (§ expr throwArity()))
    )

    public int compareTo(Object o)
    (§
        (§ return (§ expr sym.compareTo(((Keyword) o).sym)))
    )

    public String getNamespace()
    (§
        (§ return (§ expr sym.getNamespace()))
    )

    public String getName()
    (§
        (§ return (§ expr sym.getName()))
    )

    private Object readResolve() throws ObjectStreamException
    (§
        (§ return (§ expr intern(sym)))
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    final public Object invoke(Object obj)
    (§
        if (obj instanceof ILookup)
        (§
            (§ return (§ expr ((ILookup)obj).valAt(this)))
        )
        (§ return (§ expr RT.get(obj, this)))
    )

    final public Object invoke(Object obj, Object notFound)
    (§
        if (obj instanceof ILookup)
        (§
            (§ return (§ expr ((ILookup)obj).valAt(this, notFound)))
        )
        (§ return (§ expr RT.get(obj, this, notFound)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
    (§
        (§ return (§ expr throwArity()))
    )

    public Object applyTo(ISeq arglist)
    (§
        (§ return (§ expr AFn.applyToHelper(this, arglist)))
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(§ class public final class KeywordLookupSite implements ILookupSite, ILookupThunk)
(§
    final Keyword k

    public KeywordLookupSite(Keyword k)
    (§
        this.k = k
    )

    public ILookupThunk fault(Object target)
    (§
        if (target instanceof IKeywordLookup)
        (§
            (§ return (§ expr install(target)))
        )
        else if (target instanceof ILookup)
        (§
            (§ return (§ expr ilookupThunk(target.getClass())))
        )
        (§ return (§ expr this))
    )

    public Object get(Object target)
    (§
        if (target instanceof IKeywordLookup || target instanceof ILookup)
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr RT.get(target, k)))
    )

    private ILookupThunk ilookupThunk(final Class c)
    (§
        (§ return (§ expr new ILookupThunk()
        (§
            public Object get(Object target)
            (§
                if (target != nil && target.getClass() == c)
                (§
                    (§ return (§ expr ((ILookup) target).valAt(k)))
                )
                (§ return (§ expr this))
            )
        )))
    )

    private ILookupThunk install(Object target)
    (§
        ILookupThunk t = ((IKeywordLookup)target).getLookupThunk(k)
        if (t != nil)
        (§
            (§ return (§ expr t))
        )
        (§ return (§ expr ilookupThunk(target.getClass())))
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

(§ class public class LazilyPersistentVector)
(§
    static public IPersistentVector createOwning(Object... items)
    (§
        if (items.length <= 32)
        (§
            (§ return (§ expr new PersistentVector(items.length, 5, PersistentVector.EMPTY_NODE, items)))
        )
        (§ return (§ expr PersistentVector.create(items)))
    )

    static int fcount(Object c)
    (§
        if (c instanceof Counted)
        (§
            (§ return (§ expr ((Counted) c).count()))
        )
        (§ return (§ expr ((Collection)c).size()))
    )

    static public IPersistentVector create(Object obj)
    (§
        if (obj instanceof IReduceInit)
        (§
            (§ return (§ expr PersistentVector.create((IReduceInit) obj)))
        )
        else if (obj instanceof ISeq)
        (§
            (§ return (§ expr PersistentVector.create(RT.seq(obj))))
        )
        else if (obj instanceof Iterable)
        (§
            (§ return (§ expr PersistentVector.create((Iterable)obj)))
        )
        else
        (§
            (§ return (§ expr createOwning(RT.toArray(obj))))
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(§ class public final class LazySeq extends Obj implements ISeq, Sequential, List, IPending, IHashEq)
(§
    private IFn fn
    private Object sv
    private ISeq s

    public LazySeq(IFn fn)
    (§
        this.fn = fn
    )

    private LazySeq(IPersistentMap meta, ISeq s)
    (§
        super(meta)
        this.fn = nil
        this.s = s
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new LazySeq(meta, seq())))
    )

    final synchronized Object sval()
    (§
        if (fn != nil)
        (§
            sv = fn.invoke()
            fn = nil
        )
        if (sv != nil)
        (§
            (§ return (§ expr sv))
        )
        (§ return (§ expr s))
    )

    final synchronized public ISeq seq()
    (§
        sval()
        if (sv != nil)
        (§
            Object ls = sv
            sv = nil
            while (ls instanceof LazySeq)
            (§
                ls = ((LazySeq)ls).sval()
            )
            s = RT.seq(ls)
        )
        (§ return (§ expr s))
    )

    public int count()
    (§
        int c = 0
        for (ISeq s = seq() s != nil s = s.next())
        (§
            ++c
        )
        (§ return (§ expr c))
    )

    public Object first()
    (§
        seq()
        if (s == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr s.first()))
    )

    public ISeq next()
    (§
        seq()
        if (s == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr s.next()))
    )

    public ISeq more()
    (§
        seq()
        if (s == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr s.more()))
    )

    public ISeq cons(Object o)
    (§
        (§ return (§ expr RT.cons(o, seq())))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr PersistentList.EMPTY))
    )

    public boolean equiv(Object o)
    (§
        ISeq s = seq()
        if (s != nil)
        (§
            (§ return (§ expr s.equiv(o)))
        )
        else
        (§
            (§ return (§ expr (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil))
        )
    )

    public int hashCode()
    (§
        ISeq s = seq()
        if (s == nil)
        (§
            (§ return (§ expr 1))
        )
        (§ return (§ expr Util.hash(s)))
    )

    public int hasheq()
    (§
        (§ return (§ expr Murmur3.hashOrdered(this)))
    )

    public boolean equals(Object o)
    (§
        ISeq s = seq()
        if (s != nil)
        (§
            (§ return (§ expr s.equals(o)))
        )
        else
        (§
            (§ return (§ expr (o instanceof Sequential || o instanceof List) && RT.seq(o) == nil))
        )
    )

    public Object[] toArray()
    (§
        (§ return (§ expr RT.seqToArray(seq())))
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (!contains(o))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr true))
    )

    public Object[] toArray(Object[] a)
    (§
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    public int size()
    (§
        (§ return (§ expr count()))
    )

    public boolean isEmpty()
    (§
        (§ return (§ expr (seq() == nil)))
    )

    public boolean contains(Object o)
    (§
        for (ISeq s = seq() s != nil s = s.next())
        (§
            if (Util.equiv(s.first(), o))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    public Iterator iterator()
    (§
        (§ return (§ expr new SeqIterator(this)))
    )

    private List reify()
    (§
        (§ return (§ expr new ArrayList(this)))
    )

    public List subList(int fromIndex, int toIndex)
    (§
        (§ return (§ expr reify().subList(fromIndex, toIndex)))
    )

    public Object set(int index, Object element)
    (§
        throw new UnsupportedOperationException()
    )

    public Object remove(int index)
    (§
        throw new UnsupportedOperationException()
    )

    public int indexOf(Object o)
    (§
        ISeq s = seq()
        for (int i = 0 s != nil s = s.next(), i++)
        (§
            if (Util.equiv(s.first(), o))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    public int lastIndexOf(Object o)
    (§
        (§ return (§ expr reify().lastIndexOf(o)))
    )

    public ListIterator listIterator()
    (§
        (§ return (§ expr reify().listIterator()))
    )

    public ListIterator listIterator(int index)
    (§
        (§ return (§ expr reify().listIterator(index)))
    )

    public Object get(int index)
    (§
        (§ return (§ expr RT.nth(this, index)))
    )

    public void add(int index, Object element)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(int index, Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    synchronized public boolean isRealized()
    (§
        (§ return (§ expr (fn == nil)))
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(§ class public class LineNumberingPushbackReader extends PushbackReader)
(§
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.

    private static final int newline = (int) \newline

    private boolean _atLineStart = true
    private boolean _prev
    private int _columnNumber = 1

    public LineNumberingPushbackReader(Reader r)
    (§
        super(new LineNumberReader(r))
    )

    public LineNumberingPushbackReader(Reader r, int size)
    (§
        super(new LineNumberReader(r, size))
    )

    public int getLineNumber()
    (§
        (§ return (§ expr ((LineNumberReader) in).getLineNumber() + 1))
    )

    public void setLineNumber(int line) (§ ((LineNumberReader) in).setLineNumber(line - 1) )

    public int getColumnNumber()
    (§
        (§ return (§ expr _columnNumber))
    )

    public int read() throws IOException
    (§
        int c = super.read()
        _prev = _atLineStart
        if ((c == newline) || (c == -1))
        (§
            _atLineStart = true
            _columnNumber = 1
        )
        else
        (§
            _atLineStart = false
            _columnNumber++
        )
        (§ return (§ expr c))
    )

    public void unread(int c) throws IOException
    (§
        super.unread(c)
        _atLineStart = _prev
        _columnNumber--
    )

    public String readLine() throws IOException
    (§
        int c = read()
        String line
        switch (c)
        (§
            (§ case -1)
                line = nil
                break
            (§ case newline)
                line = ""
                break
            (§ default)
                String first = String.valueOf((char) c)
                String rest = ((LineNumberReader)in).readLine()
                line = (rest == nil) ? first :or first + rest
                _prev = false
                _atLineStart = true
                _columnNumber = 1
                break
        )
        (§ return (§ expr line))
    )

    public boolean atLineStart()
    (§
        (§ return (§ expr _atLineStart))
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(§ class public class LispReader)
(§
    static final Symbol QUOTE = Symbol.intern("quote")
    static final Symbol THE_VAR = Symbol.intern("var")

    static Symbol UNQUOTE = Symbol.intern("cloiure.core", "unquote")
    static Symbol UNQUOTE_SPLICING = Symbol.intern("cloiure.core", "unquote-splicing")
    static Symbol CONCAT = Symbol.intern("cloiure.core", "concat")
    static Symbol SEQ = Symbol.intern("cloiure.core", "seq")
    static Symbol LIST = Symbol.intern("cloiure.core", "list")
    static Symbol APPLY = Symbol.intern("cloiure.core", "apply")
    static Symbol HASHMAP = Symbol.intern("cloiure.core", "hash-map")
    static Symbol HASHSET = Symbol.intern("cloiure.core", "hash-set")
    static Symbol VECTOR = Symbol.intern("cloiure.core", "vector")
    static Symbol WITH_META = Symbol.intern("cloiure.core", "with-meta")
    static Symbol META = Symbol.intern("cloiure.core", "meta")
    static Symbol DEREF = Symbol.intern("cloiure.core", "deref")
    static Symbol READ_COND = Symbol.intern("cloiure.core", "read-cond")
    static Symbol READ_COND_SPLICING = Symbol.intern("cloiure.core", "read-cond-splicing")
    static Keyword UNKNOWN = Keyword.intern(nil, "unknown")

    static IFn[] macros = new IFn[256]
    static IFn[] dispatchMacros = new IFn[256]

    static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)")
    static Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?")
    static Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)")
    static Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?")

    ;; symbol->gensymbol
    static Var GENSYM_ENV = Var.create(nil).setDynamic()
    ;; sorted-map num->gensymbol
    static Var ARG_ENV = Var.create(nil).setDynamic()
    static IFn ctorReader = new CtorReader()

    ;; Dynamic var set to true in a read-cond context
    static Var READ_COND_ENV = Var.create(nil).setDynamic()

    static
    (§
        macros[\"] = new StringReader() ;; oops! "
        macros[\;] = new CommentReader()
        macros[\'] = new WrappingReader(QUOTE)
        macros[\@] = new WrappingReader(DEREF)
        macros[\^] = new MetaReader()
        macros[\`] = new SyntaxQuoteReader()
        macros[\~] = new UnquoteReader()
        macros[\(] = new ListReader()
        macros[\)] = new UnmatchedDelimiterReader()
        macros[\[] = new VectorReader()
        macros[\]] = new UnmatchedDelimiterReader()
        macros[\{] = new MapReader()
        macros[\}] = new UnmatchedDelimiterReader()
        macros[\\] = new CharacterReader()
        macros[\%] = new ArgReader()
        macros[\#] = new DispatchReader()

        dispatchMacros[\^] = new MetaReader()
        dispatchMacros[\#] = new SymbolicValueReader()
        dispatchMacros[\'] = new VarReader()
        dispatchMacros[\"] = new RegexReader() ;; oops! "
        dispatchMacros[\(] = new FnReader()
        dispatchMacros[\{] = new SetReader()
        dispatchMacros[\=] = new EvalReader()
        dispatchMacros[\!] = new CommentReader()
        dispatchMacros[\<] = new UnreadableReader()
        dispatchMacros[\_] = new DiscardReader()
        dispatchMacros[\?] = new ConditionalReader()
        dispatchMacros[\:] = new NamespaceMapReader()
    )

    public static interface Resolver
    (§
        Symbol currentNS()
        Symbol resolveClass(Symbol sym)
        Symbol resolveAlias(Symbol sym)
        Symbol resolveVar(Symbol sym)
    )

    static boolean isWhitespace(int ch)
    (§
        (§ return (§ expr (Character.isWhitespace(ch) || ch == \,)))
    )

    static void unread(PushbackReader r, int ch)
    (§
        if (ch != -1)
        (§
            try
            (§
                r.unread(ch)
            )
            catch (IOException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
    )

    public static class ReaderException extends RuntimeException
    (§
        final int line
        final int column

        public ReaderException(int line, int column, Throwable cause)
        (§
            super(cause)
            this.line = line
            this.column = column
        )
    )

    static public int read1(Reader r)
    (§
        try
        (§
            (§ return (§ expr r.read()))
        )
        catch (IOException e)
        (§
            throw Util.sneakyThrow(e)
        )
    )

    ;; Reader opts
    static public final Keyword OPT_EOF = Keyword.intern(nil, "eof")
    static public final Keyword OPT_FEATURES = Keyword.intern(nil, "features")
    static public final Keyword OPT_READ_COND = Keyword.intern(nil, "read-cond")

    ;; EOF special value to throw on eof
    static public final Keyword EOFTHROW = Keyword.intern(nil, "eofthrow")

    ;; Platform features - always installed
    static private final Keyword PLATFORM_KEY = Keyword.intern(nil, "cli")
    static private final Object PLATFORM_FEATURES = PersistentHashSet.create(PLATFORM_KEY)

    ;; Reader conditional options - use with :read-cond
    static public final Keyword COND_ALLOW = Keyword.intern(nil, "allow")
    static public final Keyword COND_PRESERVE = Keyword.intern(nil, "preserve")

    static public Object read(PushbackReader r, Object opts)
    (§
        boolean eofIsError = true
        Object eofValue = nil
        if (opts != nil && opts instanceof IPersistentMap)
        (§
            Object eof = ((IPersistentMap)opts).valAt(OPT_EOF, EOFTHROW)
            if (!EOFTHROW.equals(eof))
            (§
                eofIsError = false
                eofValue = eof
            )
        )
        (§ return (§ expr read(r, eofIsError, eofValue, false, opts)))
    )

    static public Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive)
    (§
        (§ return (§ expr read(r, eofIsError, eofValue, isRecursive, PersistentHashMap.EMPTY)))
    )

    static public Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts)
    (§
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (§ return (§ expr read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, nil, (Resolver) RT.READER_RESOLVER.deref())))
    )

    static private Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts, Object pendingForms)
    (§
        (§ return (§ expr read(r, eofIsError, eofValue, nil, nil, isRecursive, opts, ensurePending(pendingForms), (Resolver) RT.READER_RESOLVER.deref())))
    )

    static private Object ensurePending(Object pendingForms)
    (§
        if (pendingForms == nil)
        (§
            (§ return (§ expr new LinkedList()))
        )
        else
        (§
            (§ return (§ expr pendingForms))
        )
    )

    static private Object installPlatformFeature(Object opts)
    (§
        if (opts == nil)
        (§
            (§ return (§ expr RT.mapUniqueKeys(LispReader.OPT_FEATURES, PLATFORM_FEATURES)))
        )
        else
        (§
            IPersistentMap mopts = (IPersistentMap) opts
            Object features = mopts.valAt(OPT_FEATURES)
            if (features == nil)
            (§
                (§ return (§ expr mopts.assoc(LispReader.OPT_FEATURES, PLATFORM_FEATURES)))
            )
            else
            (§
                (§ return (§ expr mopts.assoc(LispReader.OPT_FEATURES, RT.conj((IPersistentSet) features, PLATFORM_KEY))))
            )
        )
    )

    static private Object read(PushbackReader r, boolean eofIsError, Object eofValue, Character returnOn, Object returnOnValue, boolean isRecursive, Object opts, Object pendingForms, Resolver resolver)
    (§
        if (RT.READEVAL.deref() == UNKNOWN)
        (§
            throw Util.runtimeException("Reading disallowed - *read-eval* bound to :unknown")
        )

        opts = installPlatformFeature(opts)

        try
        (§
            while (true)
            (§
                if (pendingForms instanceof List && !((List)pendingForms).isEmpty())
                (§
                    (§ return (§ expr ((List)pendingForms).remove(0)))
                )

                int ch = read1(r)

                while (isWhitespace(ch))
                    ch = read1(r)

                if (ch == -1)
                (§
                    if (eofIsError)
                    (§
                        throw Util.runtimeException("EOF while reading")
                    )
                    (§ return (§ expr eofValue))
                )

                if (returnOn != nil && (returnOn.charValue() == ch))
                (§
                    (§ return (§ expr returnOnValue))
                )

                if (Character.isDigit(ch))
                (§
                    Object n = readNumber(r, (char) ch)
                    (§ return (§ expr n))
                )

                IFn macroFn = getMacro(ch)
                if (macroFn != nil)
                (§
                    Object ret = macroFn.invoke(r, (char) ch, opts, pendingForms)
                    ;; no op macros return the reader
                    if (ret == r)
                    (§
                        continue
                    )
                    (§ return (§ expr ret))
                )

                if (ch == \+ || ch == \-)
                (§
                    int ch2 = read1(r)
                    if (Character.isDigit(ch2))
                    (§
                        unread(r, ch2)
                        Object n = readNumber(r, (char) ch)
                        (§ return (§ expr n))
                    )
                    unread(r, ch2)
                )

                String token = readToken(r, (char) ch)
                (§ return (§ expr interpretToken(token, resolver)))
            )
        )
        catch (Exception e)
        (§
            if (isRecursive || !(r instanceof LineNumberingPushbackReader))
            (§
                throw Util.sneakyThrow(e)
            )
            LineNumberingPushbackReader rdr = (LineNumberingPushbackReader) r
            throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e)
        )
    )

    static private String readToken(PushbackReader r, char initch)
    (§
        StringBuilder sb = new StringBuilder()
        sb.append(initch)

        while (true)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
            (§
                unread(r, ch)
                (§ return (§ expr sb.toString()))
            )
            sb.append((char) ch)
        )
    )

    static private Object readNumber(PushbackReader r, char initch)
    (§
        StringBuilder sb = new StringBuilder()
        sb.append(initch)

        while (true)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isMacro(ch))
            (§
                unread(r, ch)
                break
            )
            sb.append((char) ch)
        )

        String s = sb.toString()
        Object n = matchNumber(s)
        if (n == nil)
        (§
            throw new NumberFormatException("Invalid number: " + s)
        )
        (§ return (§ expr n))
    )

    static private int readUnicodeChar(String token, int offset, int length, int base)
    (§
        if (token.length() != offset + length)
        (§
            throw new IllegalArgumentException("Invalid unicode character: \\" + token)
        )
        int uc = 0
        for (int i = offset i < offset + length ++i)
        (§
            int d = Character.digit(token.charAt(i), base)
            if (d == -1)
            (§
                throw new IllegalArgumentException("Invalid digit: " + token.charAt(i))
            )
            uc = uc * base + d
        )
        (§ return (§ expr (char) uc))
    )

    static private int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact)
    (§
        int uc = Character.digit(initch, base)
        if (uc == -1)
        (§
            throw new IllegalArgumentException("Invalid digit: " + (char) initch)
        )
        int i = 1
        for (  i < length ++i)
        (§
            int ch = read1(r)
            if (ch == -1 || isWhitespace(ch) || isMacro(ch))
            (§
                unread(r, ch)
                break
            )
            int d = Character.digit(ch, base)
            if (d == -1)
            (§
                throw new IllegalArgumentException("Invalid digit: " + (char) ch)
            )
            uc = uc * base + d
        )
        if (i != length && exact)
        (§
            throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length)
        )
        (§ return (§ expr uc))
    )

    static private Object interpretToken(String s, Resolver resolver)
    (§
        if (s.equals("nil"))
        (§
            (§ return (§ expr nil))
        )
        else if (s.equals("true"))
        (§
            (§ return (§ expr RT.T))
        )
        else if (s.equals("false"))
        (§
            (§ return (§ expr RT.F))
        )
        Object ret = nil

        ret = matchSymbol(s, resolver)
        if (ret != nil)
        (§
            (§ return (§ expr ret))
        )

        throw Util.runtimeException("Invalid token: " + s)
    )

    private static Object matchSymbol(String s, Resolver resolver)
    (§
        Matcher m = symbolPat.matcher(s)
        if (m.matches())
        (§
            int gc = m.groupCount()
            String ns = m.group(1)
            String name = m.group(2)
            if (ns != nil && ns.endsWith(":/") || name.endsWith(":") || s.indexOf("::", 1) != -1)
            (§
                (§ return (§ expr nil))
            )
            if (s.startsWith("::"))
            (§
                Symbol ks = Symbol.intern(s.substring(2))
                if (resolver != nil)
                (§
                    Symbol nsym
                    if (ks.ns != nil)
                    (§
                        nsym = resolver.resolveAlias(Symbol.intern(ks.ns))
                    )
                    else
                    (§
                        nsym = resolver.currentNS()
                    )
                    ;; auto-resolving keyword
                    if (nsym != nil)
                    (§
                        (§ return (§ expr Keyword.intern(nsym.name, ks.name)))
                    )
                    else
                    (§
                        (§ return (§ expr nil))
                    )
                )
                else
                (§
                    Namespace kns
                    if (ks.ns != nil)
                    (§
                        kns = Compiler.currentNS().lookupAlias(Symbol.intern(ks.ns))
                    )
                    else
                    (§
                        kns = Compiler.currentNS()
                    )
                    ;; auto-resolving keyword
                    if (kns != nil)
                    (§
                        (§ return (§ expr Keyword.intern(kns.name.name, ks.name)))
                    )
                    else
                    (§
                        (§ return (§ expr nil))
                    )
                )
            )
            boolean isKeyword = (s.charAt(0) == \:)
            Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 :or 0))
            if (isKeyword)
            (§
                (§ return (§ expr Keyword.intern(sym)))
            )
            (§ return (§ expr sym))
        )
        (§ return (§ expr nil))
    )

    private static Object matchNumber(String s)
    (§
        Matcher m = intPat.matcher(s)
        if (m.matches())
        (§
            if (m.group(2) != nil)
            (§
                if (m.group(8) != nil)
                (§
                    (§ return (§ expr BigInt.ZERO))
                )
                (§ return (§ expr Numbers.num(0)))
            )
            boolean negate = m.group(1).equals("-")
            String n
            int radix = 10
            if ((n = m.group(3)) != nil)
            (§
                radix = 10
            )
            else if ((n = m.group(4)) != nil)
            (§
                radix = 16
            )
            else if ((n = m.group(5)) != nil)
            (§
                radix = 8
            )
            else if ((n = m.group(7)) != nil)
            (§
                radix = Integer.parseInt(m.group(6))
            )
            if (n == nil)
            (§
                (§ return (§ expr nil))
            )
            BigInteger bn = new BigInteger(n, radix)
            if (negate)
            (§
                bn = bn.negate()
            )
            if (m.group(8) != nil)
            (§
                (§ return (§ expr BigInt.fromBigInteger(bn)))
            )
            (§ return (§ expr (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) :or BigInt.fromBigInteger(bn)))
        )
        m = floatPat.matcher(s)
        if (m.matches())
        (§
            if (m.group(4) != nil)
            (§
                (§ return (§ expr new BigDecimal(m.group(1))))
            )
            (§ return (§ expr Double.parseDouble(s)))
        )
        m = ratioPat.matcher(s)
        if (m.matches())
        (§
            String numerator = m.group(1)
            if (numerator.startsWith("+"))
            (§
                numerator = numerator.substring(1)
            )
            (§ return (§ expr Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))))))
        )
        (§ return (§ expr nil))
    )

    static private IFn getMacro(int ch)
    (§
        if (ch < macros.length)
        (§
            (§ return (§ expr macros[ch]))
        )
        (§ return (§ expr nil))
    )

    static private boolean isMacro(int ch)
    (§
        (§ return (§ expr (ch < macros.length && macros[ch] != nil)))
    )

    static private boolean isTerminatingMacro(int ch)
    (§
        (§ return (§ expr (ch != \# && ch != \' && ch != \% && isMacro(ch))))
    )

    public static class RegexReader extends AFn
    (§
        static StringReader stringrdr = new StringReader()

        public Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
        (§
            StringBuilder sb = new StringBuilder()
            Reader r = (Reader) reader
            for (int ch = read1(r) ch != \" ch = read1(r)) ;; oops! "
            (§
                if (ch == -1)
                (§
                    throw Util.runtimeException("EOF while reading regex")
                )
                sb.append((char) ch)
                if (ch == \\) ;; escape
                (§
                    ch = read1(r)
                    if (ch == -1)
                    (§
                        throw Util.runtimeException("EOF while reading regex")
                    )
                    sb.append((char) ch)
                )
            )
            (§ return (§ expr Pattern.compile(sb.toString())))
        )
    )

    public static class StringReader extends AFn
    (§
        public Object invoke(Object reader, Object doublequote, Object opts, Object pendingForms)
        (§
            StringBuilder sb = new StringBuilder()
            Reader r = (Reader) reader

            for (int ch = read1(r) ch != \" ch = read1(r)) ;; oops! "
            (§
                if (ch == -1)
                (§
                    throw Util.runtimeException("EOF while reading string")
                )
                if (ch == \\) ;; escape
                (§
                    ch = read1(r)
                    if (ch == -1)
                    (§
                        throw Util.runtimeException("EOF while reading string")
                    )
                    switch (ch)
                    (§
                        (§ case \t)
                            ch = \tab
                            break
                        (§ case \r)
                            ch = \return
                            break
                        (§ case \n)
                            ch = \newline
                            break
                        (§ case \\)
                            break
                        (§ case \") ;; oops! "
                            break
                        (§ case \b)
                            ch = \backspace
                            break
                        (§ case \f)
                            ch = \formfeed
                            break
                        (§ case \u)
                        (§
                            ch = read1(r)
                            if (Character.digit(ch, 16) == -1)
                            (§
                                throw Util.runtimeException("Invalid unicode escape: \\u" + (char) ch)
                            )
                            ch = readUnicodeChar((PushbackReader) r, ch, 16, 4, true)
                            break
                        )
                        (§ default)
                        (§
                            if (Character.isDigit(ch))
                            (§
                                ch = readUnicodeChar((PushbackReader) r, ch, 8, 3, false)
                                if (ch > 0377)
                                (§
                                    throw Util.runtimeException("Octal escape sequence must be in range [0, 377].")
                                )
                            )
                            else
                            (§
                                throw Util.runtimeException("Unsupported escape character: \\" + (char) ch)
                            )
                            break
                        )
                    )
                )
                sb.append((char) ch)
            )
            (§ return (§ expr sb.toString()))
        )
    )

    public static class CommentReader extends AFn
    (§
        public Object invoke(Object reader, Object semicolon, Object opts, Object pendingForms)
        (§
            Reader r = (Reader) reader
            int ch
            do
            (§
                ch = read1(r)
            ) while (ch != -1 && ch != \newline && ch != \return)
            (§ return (§ expr r))
        )
    )

    public static class DiscardReader extends AFn
    (§
        public Object invoke(Object reader, Object underscore, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            read(r, true, nil, true, opts, ensurePending(pendingForms))
            (§ return (§ expr r))
        )
    )

    ;; :a.b{:c 1} => {:a.b/c 1}
    ;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
    ;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
    public static class NamespaceMapReader extends AFn
    (§
        public Object invoke(Object reader, Object colon, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader

            boolean auto = false
            int autoChar = read1(r)
            if (autoChar == \:)
            (§
                auto = true
            )
            else
            (§
                unread(r, autoChar)
            )

            Object sym = nil
            int nextChar = read1(r)
            if (isWhitespace(nextChar)) ;; the #:: { } case or an error
            (§
                if (auto)
                (§
                    while (isWhitespace(nextChar))
                        nextChar = read1(r)
                    if (nextChar != \{)
                    (§
                        unread(r, nextChar)
                        throw Util.runtimeException("Namespaced map must specify a namespace")
                    )
                )
                else
                (§
                    unread(r, nextChar)
                    throw Util.runtimeException("Namespaced map must specify a namespace")
                )
            )
            else if (nextChar != \{) ;; #:foo { } or #::foo { }
            (§
                unread(r, nextChar)
                sym = read(r, true, nil, false, opts, pendingForms)
                nextChar = read1(r)
                while (isWhitespace(nextChar))
                    nextChar = read1(r)
            )
            if (nextChar != \{)
            (§
                throw Util.runtimeException("Namespaced map must specify a map")
            )

            ;; Resolve autoresolved ns
            String ns
            if (auto)
            (§
                Resolver resolver = (Resolver) RT.READER_RESOLVER.deref()
                if (sym == nil)
                (§
                    if (resolver != nil)
                    (§
                        ns = resolver.currentNS().name
                    )
                    else
                    (§
                        ns = Compiler.currentNS().getName().getName()
                    )
                )
                else if (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
                (§
                    throw Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)
                )
                else
                (§
                    Symbol resolvedNS
                    if (resolver != nil)
                    (§
                        resolvedNS = resolver.resolveAlias((Symbol) sym)
                    )
                    else
                    (§
                        Namespace rns = Compiler.currentNS().lookupAlias((Symbol)sym)
                        resolvedNS = (rns != nil) ? rns.getName() :or nil
                    )

                    if (resolvedNS == nil)
                    (§
                        throw Util.runtimeException("Unknown auto-resolved namespace alias: " + sym)
                    )
                    else
                    (§
                        ns = resolvedNS.getName()
                    )
                )
            )
            else if (!(sym instanceof Symbol) || ((Symbol)sym).getNamespace() != nil)
            (§
                throw Util.runtimeException("Namespaced map must specify a valid namespace: " + sym)
            )
            else
            (§
                ns = ((Symbol)sym).getName()
            )

            ;; Read map
            List kvs = readDelimitedList(\}, r, true, opts, ensurePending(pendingForms))
            if ((kvs.size() & 1) == 1)
            (§
                throw Util.runtimeException("Namespaced map literal must contain an even number of forms")
            )

            ;; Construct output map
            Object[] a = new Object[kvs.size()]
            Iterator iter = kvs.iterator()
            for (int i = 0 iter.hasNext() i += 2)
            (§
                Object key = iter.next()
                Object val = iter.next()

                if (key instanceof Keyword)
                (§
                    Keyword kw = (Keyword) key
                    if (kw.getNamespace() == nil)
                    (§
                        key = Keyword.intern(ns, kw.getName())
                    )
                    else if (kw.getNamespace().equals("_"))
                    (§
                        key = Keyword.intern(nil, kw.getName())
                    )
                )
                else if (key instanceof Symbol)
                (§
                    Symbol s = (Symbol) key
                    if (s.getNamespace() == nil)
                    (§
                        key = Symbol.intern(ns, s.getName())
                    )
                    else if (s.getNamespace().equals("_"))
                    (§
                        key = Symbol.intern(nil, s.getName())
                    )
                )
                a[i] = key
                a[i + 1] = val
            )
            (§ return (§ expr RT.map(a)))
        )
    )

    public static class SymbolicValueReader extends AFn
    (§
        static IPersistentMap  specials = PersistentHashMap.create(
            Symbol.intern("Inf"), Double.POSITIVE_INFINITY,
            Symbol.intern("-Inf"), Double.NEGATIVE_INFINITY,
            Symbol.intern("NaN"), Double.NaN
        )

        public Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, nil, true, opts, ensurePending(pendingForms))

            if (!(o instanceof Symbol))
            (§
                throw Util.runtimeException("Invalid token: ##" + o)
            )
            if (!(specials.containsKey(o)))
            (§
                throw Util.runtimeException("Unknown symbolic value: ##" + o)
            )

            (§ return (§ expr specials.valAt(o)))
        )
    )

    public static class WrappingReader extends AFn
    (§
        final Symbol sym

        public WrappingReader(Symbol sym)
        (§
            this.sym = sym
        )

        public Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, nil, true, opts, ensurePending(pendingForms))
            (§ return (§ expr RT.list(sym, o)))
        )
    )

    public static class DeprecatedWrappingReader extends AFn
    (§
        final Symbol sym
        final String macro

        public DeprecatedWrappingReader(Symbol sym, String macro)
        (§
            this.sym = sym
            this.macro = macro
        )

        public Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
        (§
            System.out.println("WARNING: reader macro " + macro + " is deprecated; use " + sym.getName() + " instead")
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, nil, true, opts, ensurePending(pendingForms))
            (§ return (§ expr RT.list(sym, o)))
        )
    )

    public static class VarReader extends AFn
    (§
        public Object invoke(Object reader, Object quote, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, nil, true, opts, ensurePending(pendingForms))
            (§ return (§ expr RT.list(THE_VAR, o)))
        )
    )

    public static class DispatchReader extends AFn
    (§
        public Object invoke(Object reader, Object hash, Object opts, Object pendingForms)
        (§
            int ch = read1((Reader) reader)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            IFn fn = dispatchMacros[ch]

            ;; Try the ctor reader first
            if (fn == nil)
            (§
                unread((PushbackReader) reader, ch)
                pendingForms = ensurePending(pendingForms)
                Object result = ctorReader.invoke(reader, ch, opts, pendingForms)

                if (result != nil)
                (§
                    (§ return (§ expr result))
                )
                else
                (§
                    throw Util.runtimeException(String.format("No dispatch macro for: %c", (char) ch))
                )
            )
            (§ return (§ expr fn.invoke(reader, ch, opts, pendingForms)))
        )
    )

    static Symbol garg(int n)
    (§
        (§ return (§ expr Symbol.intern(nil, ((n == -1) ? "rest" :or ("p" + n)) + "__" + RT.nextID() + "#")))
    )

    public static class FnReader extends AFn
    (§
        public Object invoke(Object reader, Object lparen, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            if (ARG_ENV.deref() != nil)
            (§
                throw new IllegalStateException("Nested #()s are not allowed")
            )
            try
            (§
                Var.pushThreadBindings(RT.map(ARG_ENV, PersistentTreeMap.EMPTY))
                unread(r, \()
                Object form = read(r, true, nil, true, opts, ensurePending(pendingForms))

                PersistentVector args = PersistentVector.EMPTY
                PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV.deref()
                ISeq rargs = argsyms.rseq()
                if (rargs != nil)
                (§
                    int higharg = (Integer) ((Map.Entry) rargs.first()).getKey()
                    if (higharg > 0)
                    (§
                        for (int i = 1 i <= higharg ++i)
                        (§
                            Object sym = argsyms.valAt(i)
                            if (sym == nil)
                            (§
                                sym = garg(i)
                            )
                            args = args.cons(sym)
                        )
                    )
                    Object restsym = argsyms.valAt(-1)
                    if (restsym != nil)
                    (§
                        args = args.cons(Compiler._AMP_)
                        args = args.cons(restsym)
                    )
                )
                (§ return (§ expr RT.list(Compiler.FN, args, form)))
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )
    )

    static Symbol registerArg(int n)
    (§
        PersistentTreeMap argsyms = (PersistentTreeMap) ARG_ENV.deref()
        if (argsyms == nil)
        (§
            throw new IllegalStateException("arg literal not in #()")
        )
        Symbol ret = (Symbol) argsyms.valAt(n)
        if (ret == nil)
        (§
            ret = garg(n)
            ARG_ENV.set(argsyms.assoc(n, ret))
        )
        (§ return (§ expr ret))
    )

    static class ArgReader extends AFn
    (§
        public Object invoke(Object reader, Object pct, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            if (ARG_ENV.deref() == nil)
            (§
                (§ return (§ expr interpretToken(readToken(r, \%), nil)))
            )
            int ch = read1(r)
            unread(r, ch)
            ;; % alone is first arg
            if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch))
            (§
                (§ return (§ expr registerArg(1)))
            )
            Object n = read(r, true, nil, true, opts, ensurePending(pendingForms))
            if (n.equals(Compiler._AMP_))
            (§
                (§ return (§ expr registerArg(-1)))
            )
            if (!(n instanceof Number))
            (§
                throw new IllegalStateException("arg literal must be %, %& or %integer")
            )
            (§ return (§ expr registerArg(((Number) n).intValue())))
        )
    )

    public static class MetaReader extends AFn
    (§
        public Object invoke(Object reader, Object caret, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            int line = -1
            int column = -1
            if (r instanceof LineNumberingPushbackReader)
            (§
                line = ((LineNumberingPushbackReader) r).getLineNumber()
                column = ((LineNumberingPushbackReader) r).getColumnNumber()-1
            )
            pendingForms = ensurePending(pendingForms)
            Object meta = read(r, true, nil, true, opts, pendingForms)
            if (meta instanceof Symbol || meta instanceof String)
            (§
                meta = RT.map(RT.TAG_KEY, meta)
            )
            else if (meta instanceof Keyword)
            (§
                meta = RT.map(meta, RT.T)
            )
            else if (!(meta instanceof IPersistentMap))
            (§
                throw new IllegalArgumentException("Metadata must be Symbol, Keyword, String or Map")
            )

            Object o = read(r, true, nil, true, opts, pendingForms)
            if (o instanceof IMeta)
            (§
                if (line != -1 && o instanceof ISeq)
                (§
                    meta = ((IPersistentMap) meta).assoc(RT.LINE_KEY, line).assoc(RT.COLUMN_KEY, column)
                )
                if (o instanceof IReference)
                (§
                    ((IReference)o).resetMeta((IPersistentMap) meta)
                    (§ return (§ expr o))
                )
                Object ometa = RT.meta(o)
                for (ISeq s = RT.seq(meta) s != nil s = s.next())
                (§
                    IMapEntry kv = (IMapEntry) s.first()
                    ometa = RT.assoc(ometa, kv.getKey(), kv.getValue())
                )
                (§ return (§ expr ((IObj) o).withMeta((IPersistentMap) ometa)))
            )
            else
            (§
                throw new IllegalArgumentException("Metadata can only be applied to IMetas")
            )
        )
    )

    public static class SyntaxQuoteReader extends AFn
    (§
        public Object invoke(Object reader, Object backquote, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            try
            (§
                Var.pushThreadBindings(RT.map(GENSYM_ENV, PersistentHashMap.EMPTY))

                Object form = read(r, true, nil, true, opts, ensurePending(pendingForms))
                (§ return (§ expr syntaxQuote(form)))
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )

        static Object syntaxQuote(Object form)
        (§
            Object ret
            if (Compiler.isSpecial(form))
            (§
                ret = RT.list(Compiler.QUOTE, form)
            )
            else if (form instanceof Symbol)
            (§
                Resolver resolver = (Resolver) RT.READER_RESOLVER.deref()
                Symbol sym = (Symbol) form
                if (sym.ns == nil && sym.name.endsWith("#"))
                (§
                    IPersistentMap gmap = (IPersistentMap) GENSYM_ENV.deref()
                    if (gmap == nil)
                    (§
                        throw new IllegalStateException("Gensym literal not in syntax-quote")
                    )
                    Symbol gs = (Symbol) gmap.valAt(sym)
                    if (gs == nil)
                    (§
                        GENSYM_ENV.set(gmap.assoc(sym, gs = Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1) + "__" + RT.nextID() + "__auto__")))
                    )
                    sym = gs
                )
                else if (sym.ns == nil && sym.name.endsWith("."))
                (§
                    Symbol csym = Symbol.intern(nil, sym.name.substring(0, sym.name.length() - 1))
                    if (resolver != nil)
                    (§
                        Symbol rc = resolver.resolveClass(csym)
                        if (rc != nil)
                        (§
                            csym = rc
                        )
                    )
                    else
                    (§
                        csym = Compiler.resolveSymbol(csym)
                    )
                    sym = Symbol.intern(nil, csym.name.concat("."))
                )
                else if (sym.ns == nil && sym.name.startsWith("."))
                (§
                    ;; Simply quote method names.
                )
                else if (resolver != nil)
                (§
                    Symbol nsym = nil
                    if (sym.ns != nil)
                    (§
                        Symbol alias = Symbol.intern(nil, sym.ns)
                        nsym = resolver.resolveClass(alias)
                        if (nsym == nil)
                        (§
                            nsym = resolver.resolveAlias(alias)
                        )
                    )
                    if (nsym != nil)
                    (§
                        ;; Classname/foo -> package.qualified.Classname/foo
                        sym = Symbol.intern(nsym.name, sym.name)
                    )
                    else if (sym.ns == nil)
                    (§
                        Symbol rsym = resolver.resolveClass(sym)
                        if (rsym == nil)
                        (§
                            rsym = resolver.resolveVar(sym)
                        )
                        if (rsym != nil)
                        (§
                            sym = rsym
                        )
                        else
                        (§
                            sym = Symbol.intern(resolver.currentNS().name, sym.name)
                        )
                    )
                    ;; leave alone if qualified
                )
                else
                (§
                    Object maybeClass = nil
                    if (sym.ns != nil)
                    (§
                        maybeClass = Compiler.currentNS().getMapping(Symbol.intern(nil, sym.ns))
                    )
                    if (maybeClass instanceof Class)
                    (§
                        ;; Classname/foo -> package.qualified.Classname/foo
                        sym = Symbol.intern(((Class)maybeClass).getName(), sym.name)
                    )
                    else
                    (§
                        sym = Compiler.resolveSymbol(sym)
                    )
                )
                ret = RT.list(Compiler.QUOTE, sym)
            )
            else if (isUnquote(form))
            (§
                (§ return (§ expr RT.second(form)))
            )
            else if (isUnquoteSplicing(form))
            (§
                throw new IllegalStateException("splice not in list")
            )
            else if (form instanceof IPersistentCollection)
            (§
                if (form instanceof IRecord)
                (§
                    ret = form
                )
                else if (form instanceof IPersistentMap)
                (§
                    IPersistentVector keyvals = flattenMap(form)
                    ret = RT.list(APPLY, HASHMAP, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(keyvals.seq()))))
                )
                else if (form instanceof IPersistentVector)
                (§
                    ret = RT.list(APPLY, VECTOR, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentVector) form).seq()))))
                )
                else if (form instanceof IPersistentSet)
                (§
                    ret = RT.list(APPLY, HASHSET, RT.list(SEQ, RT.cons(CONCAT, sqExpandList(((IPersistentSet) form).seq()))))
                )
                else if (form instanceof ISeq || form instanceof IPersistentList)
                (§
                    ISeq seq = RT.seq(form)
                    if (seq == nil)
                    (§
                        ret = RT.cons(LIST, nil)
                    )
                    else
                    (§
                        ret = RT.list(SEQ, RT.cons(CONCAT, sqExpandList(seq)))
                    )
                )
                else
                (§
                    throw new UnsupportedOperationException("Unknown Collection type")
                )
            )
            else if (form instanceof Keyword || form instanceof Number || form instanceof Character || form instanceof String)
            (§
                ret = form
            )
            else
            (§
                ret = RT.list(Compiler.QUOTE, form)
            )

            if (form instanceof IObj && RT.meta(form) != nil)
            (§
                ;; filter line and column numbers
                IPersistentMap newMeta = ((IObj) form).meta().without(RT.LINE_KEY).without(RT.COLUMN_KEY)
                if (newMeta.count() > 0)
                (§
                    (§ return (§ expr RT.list(WITH_META, ret, syntaxQuote(((IObj) form).meta()))))
                )
            )
            (§ return (§ expr ret))
        )

        private static ISeq sqExpandList(ISeq seq)
        (§
            PersistentVector ret = PersistentVector.EMPTY
            for (  seq != nil seq = seq.next())
            (§
                Object item = seq.first()
                if (isUnquote(item))
                (§
                    ret = ret.cons(RT.list(LIST, RT.second(item)))
                )
                else if (isUnquoteSplicing(item))
                (§
                    ret = ret.cons(RT.second(item))
                )
                else
                (§
                    ret = ret.cons(RT.list(LIST, syntaxQuote(item)))
                )
            )
            (§ return (§ expr ret.seq()))
        )

        private static IPersistentVector flattenMap(Object form)
        (§
            IPersistentVector keyvals = PersistentVector.EMPTY
            for (ISeq s = RT.seq(form) s != nil s = s.next())
            (§
                IMapEntry e = (IMapEntry) s.first()
                keyvals = (IPersistentVector) keyvals.cons(e.key())
                keyvals = (IPersistentVector) keyvals.cons(e.val())
            )
            (§ return (§ expr keyvals))
        )
    )

    static boolean isUnquoteSplicing(Object form)
    (§
        (§ return (§ expr form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE_SPLICING)))
    )

    static boolean isUnquote(Object form)
    (§
        (§ return (§ expr form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE)))
    )

    static class UnquoteReader extends AFn
    (§
        public Object invoke(Object reader, Object comma, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            int ch = read1(r)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            pendingForms = ensurePending(pendingForms)
            if (ch == \@)
            (§
                Object o = read(r, true, nil, true, opts, pendingForms)
                (§ return (§ expr RT.list(UNQUOTE_SPLICING, o)))
            )
            else
            (§
                unread(r, ch)
                Object o = read(r, true, nil, true, opts, pendingForms)
                (§ return (§ expr RT.list(UNQUOTE, o)))
            )
        )
    )

    public static class CharacterReader extends AFn
    (§
        public Object invoke(Object reader, Object backslash, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            int ch = read1(r)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )
            String token = readToken(r, (char) ch)
            if (token.length() == 1)
            (§
                (§ return (§ expr Character.valueOf(token.charAt(0))))
            )
            else if (token.equals("newline"))
            (§
                (§ return (§ expr \newline))
            )
            else if (token.equals("space"))
            (§
                (§ return (§ expr \space))
            )
            else if (token.equals("tab"))
            (§
                (§ return (§ expr \tab))
            )
            else if (token.equals("backspace"))
            (§
                (§ return (§ expr \backspace))
            )
            else if (token.equals("formfeed"))
            (§
                (§ return (§ expr \formfeed))
            )
            else if (token.equals("return"))
            (§
                (§ return (§ expr \return))
            )
            else if (token.startsWith("u"))
            (§
                char c = (char) readUnicodeChar(token, 1, 4, 16)
                if (c >= (§ char "\ud800") && c <= (§ char "\udfff")) ;; surrogate code unit?
                (§
                    throw Util.runtimeException("Invalid character constant: \\u" + Integer.toString(c, 16))
                )
                (§ return (§ expr c))
            )
            else if (token.startsWith("o"))
            (§
                int len = token.length() - 1
                if (len > 3)
                (§
                    throw Util.runtimeException("Invalid octal escape sequence length: " + len)
                )
                int uc = readUnicodeChar(token, 1, len, 8)
                if (uc > 0377)
                (§
                    throw Util.runtimeException("Octal escape sequence must be in range [0, 377].")
                )
                (§ return (§ expr (char) uc))
            )
            throw Util.runtimeException("Unsupported character: \\" + token)
        )
    )

    public static class ListReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            int line = -1
            int column = -1
            if (r instanceof LineNumberingPushbackReader)
            (§
                line = ((LineNumberingPushbackReader) r).getLineNumber()
                column = ((LineNumberingPushbackReader) r).getColumnNumber()-1
            )
            List list = readDelimitedList(\), r, true, opts, ensurePending(pendingForms))
            if (list.isEmpty())
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            IObj s = (IObj) PersistentList.create(list)
            if (line != -1)
            (§
                (§ return (§ expr s.withMeta(RT.map(RT.LINE_KEY, line, RT.COLUMN_KEY, column))))
            )
            else
            (§
                (§ return (§ expr s))
            )
        )
    )

    public static class EvalReader extends AFn
    (§
        public Object invoke(Object reader, Object eq, Object opts, Object pendingForms)
        (§
            if (!RT.booleanCast(RT.READEVAL.deref()))
            (§
                throw Util.runtimeException("EvalReader not allowed when *read-eval* is false.")
            )

            PushbackReader r = (PushbackReader) reader
            Object o = read(r, true, nil, true, opts, ensurePending(pendingForms))
            if (o instanceof Symbol)
            (§
                (§ return (§ expr RT.classForName(o.toString())))
            )
            else if (o instanceof IPersistentList)
            (§
                Symbol fs = (Symbol) RT.first(o)
                if (fs.equals(THE_VAR))
                (§
                    Symbol vs = (Symbol) RT.second(o)
                    (§ return (§ expr RT.var(vs.ns, vs.name)))
                )
                if (fs.name.endsWith("."))
                (§
                    Object[] args = RT.toArray(RT.next(o))
                    (§ return (§ expr Reflector.invokeConstructor(RT.classForName(fs.name.substring(0, fs.name.length() - 1)), args)))
                )
                if (Compiler.namesStaticMember(fs))
                (§
                    Object[] args = RT.toArray(RT.next(o))
                    (§ return (§ expr Reflector.invokeStaticMethod(fs.ns, fs.name, args)))
                )
                Object v = Compiler.maybeResolveIn(Compiler.currentNS(), fs)
                if (v instanceof Var)
                (§
                    (§ return (§ expr ((IFn) v).applyTo(RT.next(o))))
                )
                throw Util.runtimeException("Can't resolve " + fs)
            )
            else
            (§
                throw new IllegalArgumentException("Unsupported #= form")
            )
        )
    )

    public static class VectorReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            (§ return (§ expr LazilyPersistentVector.create(readDelimitedList(\], r, true, opts, ensurePending(pendingForms)))))
        )
    )

    public static class MapReader extends AFn
    (§
        public Object invoke(Object reader, Object leftparen, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            Object[] a = readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)).toArray()
            if ((a.length & 1) == 1)
            (§
                throw Util.runtimeException("Map literal must contain an even number of forms")
            )
            (§ return (§ expr RT.map(a)))
        )
    )

    public static class SetReader extends AFn
    (§
        public Object invoke(Object reader, Object leftbracket, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            (§ return (§ expr PersistentHashSet.createWithCheck(readDelimitedList(\}, r, true, opts, ensurePending(pendingForms)))))
        )
    )

    public static class UnmatchedDelimiterReader extends AFn
    (§
        public Object invoke(Object reader, Object rightdelim, Object opts, Object pendingForms)
        (§
            throw Util.runtimeException("Unmatched delimiter: " + rightdelim)
        )
    )

    public static class UnreadableReader extends AFn
    (§
        public Object invoke(Object reader, Object leftangle, Object opts, Object pendingForms)
        (§
            throw Util.runtimeException("Unreadable form")
        )
    )

    ;; Sentinel values for reading lists
    private static final Object READ_EOF = new Object()
    private static final Object READ_FINISHED = new Object()

    public static List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts, Object pendingForms)
    (§
        final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1

        ArrayList a = new ArrayList()
        Resolver resolver = (Resolver) RT.READER_RESOLVER.deref()

        while (true)
        (§
            Object form = read(r, false, READ_EOF, delim, READ_FINISHED, isRecursive, opts, pendingForms, resolver)

            if (form == READ_EOF)
            (§
                if (firstline < 0)
                (§
                    throw Util.runtimeException("EOF while reading")
                )
                else
                (§
                    throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                )
            )
            else if (form == READ_FINISHED)
            (§
                (§ return (§ expr a))
            )

            a.add(form)
        )
    )

    public static class CtorReader extends AFn
    (§
        public Object invoke(Object reader, Object firstChar, Object opts, Object pendingForms)
        (§
            PushbackReader r = (PushbackReader) reader
            pendingForms = ensurePending(pendingForms)
            Object name = read(r, true, nil, false, opts, pendingForms)
            if (!(name instanceof Symbol))
            (§
                throw new RuntimeException("Reader tag must be a symbol")
            )
            Symbol sym = (Symbol)name
            Object form = read(r, true, nil, true, opts, pendingForms)

            if (isPreserveReadCond(opts) || RT.suppressRead())
            (§
                (§ return (§ expr TaggedLiteral.create(sym, form)))
            )
            else
            (§
                (§ return (§ expr sym.getName().contains(".") ? readRecord(form, sym, opts, pendingForms) :or readTagged(form, sym, opts, pendingForms)))
            )
        )

        private Object readTagged(Object o, Symbol tag, Object opts, Object pendingForms)
        (§
            ILookup data_readers = (ILookup)RT.DATA_READERS.deref()
            IFn data_reader = (IFn)RT.get(data_readers, tag)
            if (data_reader == nil)
            (§
                data_readers = (ILookup)RT.DEFAULT_DATA_READERS.deref()
                data_reader = (IFn)RT.get(data_readers, tag)
                if (data_reader == nil)
                (§
                    IFn default_reader = (IFn)RT.DEFAULT_DATA_READER_FN.deref()
                    if (default_reader != nil)
                    (§
                        (§ return (§ expr default_reader.invoke(tag, o)))
                    )
                    else
                    (§
                        throw new RuntimeException("No reader function for tag " + tag.toString())
                    )
                )
            )

            (§ return (§ expr data_reader.invoke(o)))
        )

        private Object readRecord(Object form, Symbol recordName, Object opts, Object pendingForms)
        (§
            boolean readeval = RT.booleanCast(RT.READEVAL.deref())

            if (!readeval)
            (§
                throw Util.runtimeException("Record construction syntax can only be used when *read-eval* == true")
            )

            Class recordClass = RT.classForNameNonLoading(recordName.toString())

            boolean shortForm = true

            if (form instanceof IPersistentMap)
            (§
                shortForm = false
            )
            else if (form instanceof IPersistentVector)
            (§
                shortForm = true
            )
            else
            (§
                throw Util.runtimeException("Unreadable constructor form starting with \"#" + recordName + "\"")
            )

            Object ret = nil
            Constructor[] allctors = ((Class)recordClass).getConstructors()

            if (shortForm)
            (§
                IPersistentVector recordEntries = (IPersistentVector)form
                boolean ctorFound = false
                for (Constructor ctor :in allctors)
                (§
                    if (ctor.getParameterTypes().length == recordEntries.count())
                    (§
                        ctorFound = true
                    )
                )

                if (!ctorFound)
                (§
                    throw Util.runtimeException("Unexpected number of constructor arguments to " + recordClass.toString() + ": got " + recordEntries.count())
                )

                ret = Reflector.invokeConstructor(recordClass, RT.toArray(recordEntries))
            )
            else
            (§
                IPersistentMap vals = (IPersistentMap)form
                for (ISeq s = RT.keys(vals) s != nil s = s.next())
                (§
                    if (!(s.first() instanceof Keyword))
                    (§
                        throw Util.runtimeException("Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " + s.first().toString())
                    )
                )
                ret = Reflector.invokeStaticMethod(recordClass, "create", new Object[] (§ vals ))
            )

            (§ return (§ expr ret))
        )
    )

    static boolean isPreserveReadCond(Object opts)
    (§
        if (RT.booleanCast(READ_COND_ENV.deref()) && opts instanceof IPersistentMap)
        (§
            Object readCond = ((IPersistentMap) opts).valAt(OPT_READ_COND)
            (§ return (§ expr COND_PRESERVE.equals(readCond)))
        )
        else
        (§
            (§ return (§ expr false))
        )
    )

    public static class ConditionalReader extends AFn
    (§
        final static private Object READ_STARTED = new Object()
        final static public Keyword DEFAULT_FEATURE = Keyword.intern(nil, "default")
        final static public IPersistentSet RESERVED_FEATURES = RT.set(Keyword.intern(nil, "else"), Keyword.intern(nil, "none"))

        public static boolean hasFeature(Object feature, Object opts)
        (§
            if (!(feature instanceof Keyword))
            (§
                throw Util.runtimeException("Feature should be a keyword: " + feature)
            )

            if (DEFAULT_FEATURE.equals(feature))
            (§
                (§ return (§ expr true))
            )

            IPersistentSet custom = (IPersistentSet) ((IPersistentMap)opts).valAt(OPT_FEATURES)
            (§ return (§ expr (custom != nil && custom.contains(feature))))
        )

        public static Object readCondDelimited(PushbackReader r, boolean splicing, Object opts, Object pendingForms)
        (§
            Object result = READ_STARTED
            Object form ;; The most recently ready form
            boolean toplevel = (pendingForms == nil)
            pendingForms = ensurePending(pendingForms)

            final int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) r).getLineNumber() :or -1

            while (true)
            (§
                if (result == READ_STARTED)
                (§
                    ;; Read the next feature
                    form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, nil)

                    if (form == READ_EOF)
                    (§
                        if (firstline < 0)
                        (§
                            throw Util.runtimeException("EOF while reading")
                        )
                        else
                        (§
                            throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                        )
                    )
                    else if (form == READ_FINISHED)
                    (§
                        break ;; read-cond form is done
                    )

                    if (RESERVED_FEATURES.contains(form))
                    (§
                        throw Util.runtimeException("Feature name " + form + " is reserved.")
                    )

                    if (hasFeature(form, opts))
                    (§
                        ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                        form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref())

                        if (form == READ_EOF)
                        (§
                            if (firstline < 0)
                            (§
                                throw Util.runtimeException("EOF while reading")
                            )
                            else
                            (§
                                throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                            )
                        )
                        else if (form == READ_FINISHED)
                        (§
                            if (firstline < 0)
                            (§
                                throw Util.runtimeException("read-cond requires an even number of forms.")
                            )
                            else
                            (§
                                throw Util.runtimeException("read-cond starting on line " + firstline + " requires an even number of forms")
                            )
                        )
                        else
                        (§
                            result = form
                        )
                    )
                )

                ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                try
                (§
                    Var.pushThreadBindings(RT.map(RT.SUPPRESS_READ, RT.T))
                    form = read(r, false, READ_EOF, \), READ_FINISHED, true, opts, pendingForms, (Resolver) RT.READER_RESOLVER.deref())

                    if (form == READ_EOF)
                    (§
                        if (firstline < 0)
                        (§
                            throw Util.runtimeException("EOF while reading")
                        )
                        else
                        (§
                            throw Util.runtimeException("EOF while reading, starting at line " + firstline)
                        )
                    )
                    else if (form == READ_FINISHED)
                    (§
                        break
                    )
                )
                finally
                (§
                    Var.popThreadBindings()
                )
            )

            if (result == READ_STARTED) ;; no features matched
            (§
                (§ return (§ expr r))
            )

            if (splicing)
            (§
                if (!(result instanceof List))
                (§
                    throw Util.runtimeException("Spliced form list in read-cond-splicing must implement java.util.List")
                )

                if (toplevel)
                (§
                    throw Util.runtimeException("Reader conditional splicing not allowed at the top level.")
                )

                ((List)pendingForms).addAll(0, (List)result)

                (§ return (§ expr r))
            )
            else
            (§
                (§ return (§ expr result))
            )
        )

        private static void checkConditionalAllowed(Object opts)
        (§
            IPersistentMap mopts = (IPersistentMap)opts
            if (!(opts != nil && (COND_ALLOW.equals(mopts.valAt(OPT_READ_COND)) || COND_PRESERVE.equals(mopts.valAt(OPT_READ_COND)))))
            (§
                throw Util.runtimeException("Conditional read not allowed")
            )
        )

        public Object invoke(Object reader, Object mode, Object opts, Object pendingForms)
        (§
            checkConditionalAllowed(opts)

            PushbackReader r = (PushbackReader) reader
            int ch = read1(r)
            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )

            boolean splicing = false

            if (ch == \@)
            (§
                splicing = true
                ch = read1(r)
            )

            while (isWhitespace(ch))
                ch = read1(r)

            if (ch == -1)
            (§
                throw Util.runtimeException("EOF while reading character")
            )

            if (ch != \()
            (§
                throw Util.runtimeException("read-cond body must be a list")
            )

            try
            (§
                Var.pushThreadBindings(RT.map(READ_COND_ENV, RT.T))

                if (isPreserveReadCond(opts))
                (§
                    IFn listReader = getMacro(ch) ;; should always be a list
                    Object form = listReader.invoke(r, ch, opts, ensurePending(pendingForms))

                    (§ return (§ expr ReaderConditional.create(form, splicing)))
                )
                else
                (§
                    (§ return (§ expr readCondDelimited(r, splicing, opts, pendingForms)))
                )
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(§ anno @SuppressWarnings((§ "SynchronizeOnNonFinalField" )))
(§ class public class LockingTransaction)
(§
    public static final int RETRY_LIMIT = 10000
    public static final int LOCK_WAIT_MSECS = 100
    public static final long BARGE_WAIT_NANOS = 10 * 1000000

    static final int RUNNING = 0
    static final int COMMITTING = 1
    static final int RETRY = 2
    static final int KILLED = 3
    static final int COMMITTED = 4

    final static ThreadLocal<LockingTransaction> transaction = new ThreadLocal<LockingTransaction>()

    static class RetryEx extends Error
    (§
    )

    static class AbortException extends Exception
    (§
    )

    public static class Info
    (§
        final AtomicInteger status
        final long startPoint
        final CountDownLatch latch

        public Info(int status, long startPoint)
        (§
            this.status = new AtomicInteger(status)
            this.startPoint = startPoint
            this.latch = new CountDownLatch(1)
        )

        public boolean running()
        (§
            int s = status.get()
            (§ return (§ expr (s == RUNNING || s == COMMITTING)))
        )
    )

    static class CFn
    (§
        final IFn fn
        final ISeq args

        public CFn(IFn fn, ISeq args)
        (§
            this.fn = fn
            this.args = args
        )
    )

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    final private static AtomicLong lastPoint = new AtomicLong()

    void getReadPoint()
    (§
        readPoint = lastPoint.incrementAndGet()
    )

    long getCommitPoint()
    (§
        (§ return (§ expr lastPoint.incrementAndGet()))
    )

    void stop(int status)
    (§
        if (info != nil)
        (§
            synchronized (info)
            (§
                info.status.set(status)
                info.latch.countDown()
            )
            info = nil
            vals.clear()
            sets.clear()
            commutes.clear()
        )
    )

    Info info
    long readPoint
    long startPoint
    long startTime

    final RetryEx retryex = new RetryEx()
    final ArrayList<Agent.Action> actions = new ArrayList<Agent.Action>()
    final HashMap<Ref, Object> vals = new HashMap<Ref, Object>()
    final HashSet<Ref> sets = new HashSet<Ref>()
    final TreeMap<Ref, ArrayList<CFn>> commutes = new TreeMap<Ref, ArrayList<CFn>>()

    final HashSet<Ref> ensures = new HashSet<Ref>() ;; all hold readLock

    void tryWriteLock(Ref ref)
    (§
        try
        (§
            if (!ref.lock.writeLock().tryLock(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS))
            (§
                throw retryex
            )
        )
        catch (InterruptedException e)
        (§
            throw retryex
        )
    )

    ;; returns the most recent val
    Object lock(Ref ref)
    (§
        ;; can't upgrade readLock, so release it
        releaseIfEnsured(ref)

        boolean unlocked = true
        try
        (§
            tryWriteLock(ref)
            unlocked = false

            if (ref.tvals != nil && ref.tvals.point > readPoint)
            (§
                throw retryex
            )
            Info refinfo = ref.tinfo

            ;; write lock conflict
            if (refinfo != nil && refinfo != info && refinfo.running())
            (§
                if (!barge(refinfo))
                (§
                    ref.lock.writeLock().unlock()
                    unlocked = true
                    (§ return (§ expr blockAndBail(refinfo)))
                )
            )
            ref.tinfo = info
            (§ return (§ expr (ref.tvals == nil) ? nil :or ref.tvals.val))
        )
        finally
        (§
            if (!unlocked)
            (§
                ref.lock.writeLock().unlock()
            )
        )
    )

    private Object blockAndBail(Info refinfo)
    (§
        ;; stop prior to blocking
        stop(RETRY)
        try
        (§
            refinfo.latch.await(LOCK_WAIT_MSECS, TimeUnit.MILLISECONDS)
        )
        catch (InterruptedException e)
        (§
            ;; ignore
        )
        throw retryex
    )

    private void releaseIfEnsured(Ref ref)
    (§
        if (ensures.contains(ref))
        (§
            ensures.remove(ref)
            ref.lock.readLock().unlock()
        )
    )

    void abort() throws AbortException
    (§
        stop(KILLED)
        throw new AbortException()
    )

    private boolean bargeTimeElapsed()
    (§
        (§ return (§ expr (System.nanoTime() - startTime > BARGE_WAIT_NANOS)))
    )

    private boolean barge(Info refinfo)
    (§
        boolean barged = false
        ;; if this transaction is older, try to abort the other
        if (bargeTimeElapsed() && startPoint < refinfo.startPoint)
        (§
            barged = refinfo.status.compareAndSet(RUNNING, KILLED)
            if (barged)
            (§
                refinfo.latch.countDown()
            )
        )
        (§ return (§ expr barged))
    )

    static LockingTransaction getEx()
    (§
        LockingTransaction t = transaction.get()
        if (t == nil || t.info == nil)
        (§
            throw new IllegalStateException("No transaction running")
        )
        (§ return (§ expr t))
    )

    static public boolean isRunning()
    (§
        (§ return (§ expr (getRunning() != nil)))
    )

    static LockingTransaction getRunning()
    (§
        LockingTransaction t = transaction.get()
        if (t == nil || t.info == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr t))
    )

    static public Object runInTransaction(Callable fn) throws Exception
    (§
        LockingTransaction t = transaction.get()
        Object ret
        if (t == nil)
        (§
            transaction.set(t = new LockingTransaction())
            try
            (§
                ret = t.run(fn)
            )
            finally
            (§
                transaction.remove()
            )
        )
        else
        (§
            if (t.info != nil)
            (§
                ret = fn.call()
            )
            else
            (§
                ret = t.run(fn)
            )
        )

        (§ return (§ expr ret))
    )

    static class Notify
    (§
        final public Ref ref
        final public Object oldval
        final public Object newval

        Notify(Ref ref, Object oldval, Object newval)
        (§
            this.ref = ref
            this.oldval = oldval
            this.newval = newval
        )
    )

    Object run(Callable fn) throws Exception
    (§
        boolean done = false
        Object ret = nil
        ArrayList<Ref> locked = new ArrayList<Ref>()
        ArrayList<Notify> notify = new ArrayList<Notify>()

        for (int i = 0 !done && i < RETRY_LIMIT i++)
        (§
            try
            (§
                getReadPoint()
                if (i == 0)
                (§
                    startPoint = readPoint
                    startTime = System.nanoTime()
                )
                info = new Info(RUNNING, startPoint)
                ret = fn.call()
                ;; make sure no one has killed us before this point, and can't from now on
                if (info.status.compareAndSet(RUNNING, COMMITTING))
                (§
                    for (Map.Entry<Ref, ArrayList<CFn>> e :in commutes.entrySet())
                    (§
                        Ref ref = e.getKey()
                        if (sets.contains(ref))
                        (§
                            continue
                        )

                        boolean wasEnsured = ensures.contains(ref)
                        ;; can't upgrade readLock, so release it
                        releaseIfEnsured(ref)
                        tryWriteLock(ref)
                        locked.add(ref)
                        if (wasEnsured && ref.tvals != nil && ref.tvals.point > readPoint)
                        (§
                            throw retryex
                        )

                        Info refinfo = ref.tinfo
                        if (refinfo != nil && refinfo != info && refinfo.running())
                        (§
                            if (!barge(refinfo))
                            (§
                                throw retryex
                            )
                        )
                        Object val = (ref.tvals == nil) ? nil :or ref.tvals.val
                        vals.put(ref, val)
                        for (CFn f :in e.getValue())
                        (§
                            vals.put(ref, f.fn.applyTo(RT.cons(vals.get(ref), f.args)))
                        )
                    )
                    for (Ref ref :in sets)
                    (§
                        tryWriteLock(ref)
                        locked.add(ref)
                    )

                    ;; validate and enqueue notifications
                    for (Map.Entry<Ref, Object> e :in vals.entrySet())
                    (§
                        Ref ref = e.getKey()
                        ref.validate(ref.getValidator(), e.getValue())
                    )

                    ;; at this point, all values calced, all refs to be written locked
                    ;; no more client code to be called
                    long commitPoint = getCommitPoint()
                    for (Map.Entry<Ref, Object> e :in vals.entrySet())
                    (§
                        Ref ref = e.getKey()
                        Object oldval = (ref.tvals == nil) ? nil :or ref.tvals.val
                        Object newval = e.getValue()
                        int hcount = ref.histCount()

                        if (ref.tvals == nil)
                        (§
                            ref.tvals = new Ref.TVal(newval, commitPoint)
                        )
                        else if ((ref.faults.get() > 0 && hcount < ref.maxHistory) || hcount < ref.minHistory)
                        (§
                            ref.tvals = new Ref.TVal(newval, commitPoint, ref.tvals)
                            ref.faults.set(0)
                        )
                        else
                        (§
                            ref.tvals = ref.tvals.next
                            ref.tvals.val = newval
                            ref.tvals.point = commitPoint
                        )
                        if (ref.getWatches().count() > 0)
                        (§
                            notify.add(new Notify(ref, oldval, newval))
                        )
                    )

                    done = true
                    info.status.set(COMMITTED)
                )
            )
            catch (RetryEx retry)
            (§
                ;; eat this so we retry rather than fall out
            )
            finally
            (§
                for (int k = locked.size() - 1 k >= 0 --k)
                (§
                    locked.get(k).lock.writeLock().unlock()
                )
                locked.clear()
                for (Ref r :in ensures)
                (§
                    r.lock.readLock().unlock()
                )
                ensures.clear()
                stop(done ? COMMITTED :or RETRY)
                try
                (§
                    if (done) ;; re-dispatch out of transaction
                    (§
                        for (Notify n :in notify)
                        (§
                            n.ref.notifyWatches(n.oldval, n.newval)
                        )
                        for (Agent.Action action :in actions)
                        (§
                            Agent.dispatchAction(action)
                        )
                    )
                )
                finally
                (§
                    notify.clear()
                    actions.clear()
                )
            )
        )
        if (!done)
        (§
            throw Util.runtimeException("Transaction failed after reaching retry limit")
        )
        (§ return (§ expr ret))
    )

    public void enqueue(Agent.Action action)
    (§
        actions.add(action)
    )

    Object doGet(Ref ref)
    (§
        if (!info.running())
        (§
            throw retryex
        )
        if (vals.containsKey(ref))
        (§
            (§ return (§ expr vals.get(ref)))
        )
        try
        (§
            ref.lock.readLock().lock()
            if (ref.tvals == nil)
            (§
                throw new IllegalStateException(ref.toString() + " is unbound.")
            )
            Ref.TVal ver = ref.tvals
            do
            (§
                if (ver.point <= readPoint)
                (§
                    (§ return (§ expr ver.val))
                )
            ) while ((ver = ver.prior) != ref.tvals)
        )
        finally
        (§
            ref.lock.readLock().unlock()
        )
        ;; no version of val precedes the read point
        ref.faults.incrementAndGet()
        throw retryex
    )

    Object doSet(Ref ref, Object val)
    (§
        if (!info.running())
        (§
            throw retryex
        )
        if (commutes.containsKey(ref))
        (§
            throw new IllegalStateException("Can't set after commute")
        )
        if (!sets.contains(ref))
        (§
            sets.add(ref)
            lock(ref)
        )
        vals.put(ref, val)
        (§ return (§ expr val))
    )

    void doEnsure(Ref ref)
    (§
        if (!info.running())
        (§
            throw retryex
        )
        if (ensures.contains(ref))
        (§
            (§ return (§ expr ))
        )
        ref.lock.readLock().lock()

        ;; someone completed a write after our snapshot
        if (ref.tvals != nil && ref.tvals.point > readPoint)
        (§
            ref.lock.readLock().unlock()
            throw retryex
        )

        Info refinfo = ref.tinfo

        ;; writer exists
        if (refinfo != nil && refinfo.running())
        (§
            ref.lock.readLock().unlock()

            if (refinfo != info) ;; not us, ensure is doomed
            (§
                blockAndBail(refinfo)
            )
        )
        else
        (§
            ensures.add(ref)
        )
    )

    Object doCommute(Ref ref, IFn fn, ISeq args)
    (§
        if (!info.running())
        (§
            throw retryex
        )
        if (!vals.containsKey(ref))
        (§
            Object val = nil
            try
            (§
                ref.lock.readLock().lock()
                val = (ref.tvals == nil) ? nil :or ref.tvals.val
            )
            finally
            (§
                ref.lock.readLock().unlock()
            )
            vals.put(ref, val)
        )
        ArrayList<CFn> fns = commutes.get(ref)
        if (fns == nil)
        (§
            commutes.put(ref, fns = new ArrayList<CFn>())
        )
        fns.add(new CFn(fn, args))
        Object ret = fn.applyTo(RT.cons(vals.get(ref), args))
        vals.put(ref, ret)
        (§ return (§ expr ret))
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.io.Serializable)

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(§ class public class LongRange extends ASeq implements Counted, IChunkedSeq, IReduce)
(§
    private static final int CHUNK_SIZE = 32

    ;; Invariants guarantee this is never an empty or infinite seq
    final long start
    final long end
    final long step
    final BoundsCheck boundsCheck

    private volatile LongChunk _chunk ;; lazy
    private volatile ISeq _chunkNext ;; lazy
    private volatile ISeq _next ;; cached

    private static interface BoundsCheck extends Serializable
    (§
        boolean exceededBounds(long val)
    )

    private static BoundsCheck positiveStep(final long end)
    (§
        (§ return (§ expr new BoundsCheck()
        (§
            public boolean exceededBounds(long val)
            (§
                (§ return (§ expr (val >= end)))
            )
        )))
    )

    private static BoundsCheck negativeStep(final long end)
    (§
        (§ return (§ expr new BoundsCheck()
        (§
            public boolean exceededBounds(long val)
            (§
                (§ return (§ expr (val <= end)))
            )
        )))
    )

    private LongRange(long start, long end, long step, BoundsCheck boundsCheck)
    (§
        this.start = start
        this.end = end
        this.step = step
        this.boundsCheck = boundsCheck
    )

    private LongRange(long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
    (§
        this.start = start
        this.end = end
        this.step = step
        this.boundsCheck = boundsCheck
        this._chunk = chunk
        this._chunkNext = chunkNext
    )

    private LongRange(IPersistentMap meta, long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext)
    (§
        super(meta)
        this.start = start
        this.end = end
        this.step = step
        this.boundsCheck = boundsCheck
        this._chunk = chunk
        this._chunkNext = chunkNext
    )

    public static ISeq create(long end)
    (§
        if (end > 0)
        (§
            (§ return (§ expr new LongRange(0, end, 1, positiveStep(end))))
        )
        (§ return (§ expr PersistentList.EMPTY))
    )

    public static ISeq create(long start, long end)
    (§
        if (start >= end)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr new LongRange(start, end, 1, positiveStep(end))))
    )

    public static ISeq create(final long start, long end, long step)
    (§
        if (step > 0)
        (§
            if (end <= start)
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ return (§ expr new LongRange(start, end, step, positiveStep(end))))
        )
        else if (step < 0)
        (§
            if (end >= start)
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ return (§ expr new LongRange(start, end, step, negativeStep(end))))
        )
        else
        (§
            if (end == start)
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ return (§ expr Repeat.create(start)))
        )
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        if (meta == _meta)
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new LongRange(meta, start, end, step, boundsCheck, _chunk, _chunkNext)))
    )

    public Object first()
    (§
        (§ return (§ expr start))
    )

    public void forceChunk()
    (§
        if (_chunk != nil)
        (§
            (§ return (§ expr ))
        )

        long count
        try
        (§
            count = rangeCount(start, end, step)
        )
        catch (ArithmeticException e)
        (§
            ;; size of total range is > Long.MAX_VALUE so must step to count
            ;; this only happens in pathological range cases like:
            ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
            count = steppingCount(start, end, step)
        )

        if (count > CHUNK_SIZE) ;; not last chunk
        (§
            long nextStart = start + (step * CHUNK_SIZE) ;; cannot overflow, must be < end
            _chunkNext = new LongRange(nextStart, end, step, boundsCheck)
            _chunk = new LongChunk(start, step, CHUNK_SIZE)
        )
        else ;; last chunk
        (§
            _chunk = new LongChunk(start, step, (int) count) ;; count must be <= CHUNK_SIZE
        )
    )

    public ISeq next()
    (§
        if (_next != nil)
        (§
            (§ return (§ expr _next))
        )

        forceChunk()
        if (_chunk.count() > 1)
        (§
            LongChunk smallerChunk = _chunk.dropFirst()
            _next = new LongRange(smallerChunk.first(), end, step, boundsCheck, smallerChunk, _chunkNext)
            (§ return (§ expr _next))
        )
        (§ return (§ expr chunkedNext()))
    )

    public IChunk chunkedFirst()
    (§
        forceChunk()
        (§ return (§ expr _chunk))
    )

    public ISeq chunkedNext()
    (§
        (§ return (§ expr chunkedMore().seq()))
    )

    public ISeq chunkedMore()
    (§
        forceChunk()
        if (_chunkNext == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _chunkNext))
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    long steppingCount(long start, long end, long step)
    (§
        long count = 1
        long s = start
        while (count <= CHUNK_SIZE)
        (§
            try
            (§
                s = Numbers.add(s, step)
                if (boundsCheck.exceededBounds(s))
                (§
                    break
                )
                else
                (§
                    count++
                )
            )
            catch (ArithmeticException e)
            (§
                break
            )
        )
        (§ return (§ expr count))
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    long rangeCount(long start, long end, long step)
    (§
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (§ return (§ expr Numbers.add(Numbers.add(Numbers.minus(end, start), step), (this.step > 0) ? -1 :or 1) / step))
    )

    public int count()
    (§
        try
        (§
            long c = rangeCount(start, end, step)
            if (c > Integer.MAX_VALUE)
            (§
                (§ return (§ expr Numbers.throwIntOverflow()))
            )
            else
            (§
                (§ return (§ expr (int) c))
            )
        )
        catch (ArithmeticException e)
        (§
            ;; rare case from large range or step, fall back to iterating and counting
            Iterator iter = this.iterator()
            long count = 0
            while (iter.hasNext())
            (§
                iter.next()
                count++
            )

            if (count > Integer.MAX_VALUE)
            (§
                (§ return (§ expr Numbers.throwIntOverflow()))
            )
            else
            (§
                (§ return (§ expr (int)count))
            )
        )
    )

    public Object reduce(IFn f)
    (§
        Object acc = start
        long i = start + step
        while (!boundsCheck.exceededBounds(i))
        (§
            acc = f.invoke(acc, i)
            if (acc instanceof Reduced)
            (§
                (§ return (§ expr ((Reduced)acc).deref()))
            )
            i += step
        )
        (§ return (§ expr acc))
    )

    public Object reduce(IFn f, Object val)
    (§
        Object acc = val
        long i = start
        do
        (§
            acc = f.invoke(acc, i)
            if (RT.isReduced(acc))
            (§
                (§ return (§ expr ((Reduced)acc).deref()))
            )
            i += step
        ) while (!boundsCheck.exceededBounds(i))
        (§ return (§ expr acc))
    )

    public Iterator iterator()
    (§
        (§ return (§ expr new LongRangeIterator()))
    )

    class LongRangeIterator implements Iterator
    (§
        private long next
        private boolean hasNext

        public LongRangeIterator()
        (§
            this.next = start
            this.hasNext = true
        )

        public boolean hasNext()
        (§
            (§ return (§ expr hasNext))
        )

        public Object next()
        (§
            if (hasNext)
            (§
                long ret = next
                try
                (§
                    next = Numbers.add(next, step)
                    hasNext = !boundsCheck.exceededBounds(next)
                )
                catch (ArithmeticException e)
                (§
                    hasNext = false
                )
                (§ return (§ expr ret))
            )
            else
            (§
                throw new NoSuchElementException()
            )
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    private static class LongChunk implements IChunk, Serializable
    (§
        final long start
        final long step
        final int count

        public LongChunk(long start, long step, int count)
        (§
            this.start = start
            this.step = step
            this.count = count
        )

        public long first()
        (§
            (§ return (§ expr start))
        )

        public Object nth(int i)
        (§
            (§ return (§ expr start + (i * step)))
        )

        public Object nth(int i, Object notFound)
        (§
            if (i >= 0 && i < count)
            (§
                (§ return (§ expr start + (i * step)))
            )
            (§ return (§ expr notFound))
        )

        public int count()
        (§
            (§ return (§ expr count))
        )

        public LongChunk dropFirst()
        (§
            if (count <= 1)
            (§
                throw new IllegalStateException("dropFirst of empty chunk")
            )
            (§ return (§ expr new LongChunk(start + step, step, count - 1)))
        )

        public Object reduce(IFn f, Object init)
        (§
            long x = start
            Object ret = init
            for (int i = 0 i < count i++)
            (§
                ret = f.invoke(ret, x)
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ret))
                )
                x += step
            )
            (§ return (§ expr ret))
        )
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(§ class public class MapEntry extends AMapEntry)
(§
    final Object _key
    final Object _val

    static public MapEntry create(Object key, Object val)
    (§
        (§ return (§ expr new MapEntry(key, val)))
    )

    public MapEntry(Object key, Object val)
    (§
        this._key = key
        this._val = val
    )

    public Object key()
    (§
        (§ return (§ expr _key))
    )

    public Object val()
    (§
        (§ return (§ expr _val))
    )

    public Object getKey()
    (§
        (§ return (§ expr key()))
    )

    public Object getValue()
    (§
        (§ return (§ expr val()))
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(§ interface public interface MapEquivalence)
(§
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(§ class public final class MethodImplCache)
(§
    static public class Entry
    (§
        final public Class c
        final public IFn fn

        public Entry(Class c, IFn fn)
        (§
            this.c = c
            this.fn = fn
        )
    )

    public final IPersistentMap protocol
    public final Keyword methodk
    public final int shift
    public final int mask
    public final Object[] table ;; [class, entry. class, entry ...]
    public final Map map

    Entry mre = nil

    public MethodImplCache(IPersistentMap protocol, Keyword methodk)
    (§
        this(protocol, methodk, 0, 0, RT.EMPTY_ARRAY)
    )

    public MethodImplCache(IPersistentMap protocol, Keyword methodk, int shift, int mask, Object[] table)
    (§
        this.protocol = protocol
        this.methodk = methodk
        this.shift = shift
        this.mask = mask
        this.table = table
        this.map = nil
    )

    public MethodImplCache(IPersistentMap protocol, Keyword methodk, Map map)
    (§
        this.protocol = protocol
        this.methodk = methodk
        this.shift = 0
        this.mask = 0
        this.table = nil
        this.map = map
    )

    public IFn fnFor(Class c)
    (§
        Entry last = mre
        if (last != nil && last.c == c)
        (§
            (§ return (§ expr last.fn))
        )
        (§ return (§ expr findFnFor(c)))
    )

    IFn findFnFor(Class c)
    (§
        if (map != nil)
        (§
            Entry e = (Entry) map.get(c)
            mre = e
            (§ return (§ expr (e != nil) ? e.fn :or nil))
        )
        else
        (§
            int idx = ((Util.hash(c) >> shift) & mask) << 1
            if (idx < table.length && table[idx] == c)
            (§
                Entry e = ((Entry) table[idx + 1])
                mre = e
                (§ return (§ expr (e != nil) ? e.fn :or nil))
            )
            (§ return (§ expr nil))
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(§ class public class MultiFn extends AFn)
(§
    final public IFn dispatchFn
    final public Object defaultDispatchVal
    final public IRef hierarchy
    final String name
    final ReentrantReadWriteLock rw

    volatile IPersistentMap methodTable
    volatile IPersistentMap preferTable
    volatile IPersistentMap methodCache
    volatile Object cachedHierarchy

    static final Var assoc = RT.var("cloiure.core", "assoc")
    static final Var dissoc = RT.var("cloiure.core", "dissoc")
    static final Var isa = RT.var("cloiure.core", "isa?")
    static final Var parents = RT.var("cloiure.core", "parents")

    public MultiFn(String name, IFn dispatchFn, Object defaultDispatchVal, IRef hierarchy)
    (§
        this.rw = new ReentrantReadWriteLock()
        this.name = name
        this.dispatchFn = dispatchFn
        this.defaultDispatchVal = defaultDispatchVal
        this.methodTable = PersistentHashMap.EMPTY
        this.methodCache = getMethodTable()
        this.preferTable = PersistentHashMap.EMPTY
        this.hierarchy = hierarchy
        cachedHierarchy = nil
    )

    public MultiFn reset()
    (§
        rw.writeLock().lock()
        try
        (§
            methodTable = methodCache = preferTable = PersistentHashMap.EMPTY
            cachedHierarchy = nil
            (§ return (§ expr this))
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public MultiFn addMethod(Object dispatchVal, IFn method)
    (§
        rw.writeLock().lock()
        try
        (§
            methodTable = getMethodTable().assoc(dispatchVal, method)
            resetCache()
            (§ return (§ expr this))
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public MultiFn removeMethod(Object dispatchVal)
    (§
        rw.writeLock().lock()
        try
        (§
            methodTable = getMethodTable().without(dispatchVal)
            resetCache()
            (§ return (§ expr this))
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public MultiFn preferMethod(Object dispatchValX, Object dispatchValY)
    (§
        rw.writeLock().lock()
        try
        (§
            if (prefers(dispatchValY, dispatchValX))
            (§
                throw new IllegalStateException(String.format("Preference conflict in multimethod '%s': %s is already preferred to %s", name, dispatchValY, dispatchValX))
            )
            preferTable = getPreferTable().assoc(dispatchValX, RT.conj((IPersistentCollection) RT.get(getPreferTable(), dispatchValX, PersistentHashSet.EMPTY), dispatchValY))
            resetCache()
            (§ return (§ expr this))
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    private boolean prefers(Object x, Object y)
    (§
        IPersistentSet xprefs = (IPersistentSet) getPreferTable().valAt(x)
        if (xprefs != nil && xprefs.contains(y))
        (§
            (§ return (§ expr true))
        )
        for (ISeq ps = RT.seq(parents.invoke(y)) ps != nil ps = ps.next())
        (§
            if (prefers(x, ps.first()))
            (§
                (§ return (§ expr true))
            )
        )
        for (ISeq ps = RT.seq(parents.invoke(x)) ps != nil ps = ps.next())
        (§
            if (prefers(ps.first(), y))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    private boolean isA(Object x, Object y)
    (§
        (§ return (§ expr RT.booleanCast(isa.invoke(hierarchy.deref(), x, y))))
    )

    private boolean dominates(Object x, Object y)
    (§
        (§ return (§ expr prefers(x, y) || isA(x, y)))
    )

    private IPersistentMap resetCache()
    (§
        rw.writeLock().lock()
        try
        (§
            methodCache = getMethodTable()
            cachedHierarchy = hierarchy.deref()
            (§ return (§ expr methodCache))
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public IFn getMethod(Object dispatchVal)
    (§
        if (cachedHierarchy != hierarchy.deref())
        (§
            resetCache()
        )
        IFn targetFn = (IFn) methodCache.valAt(dispatchVal)
        if (targetFn != nil)
        (§
            (§ return (§ expr targetFn))
        )
        (§ return (§ expr findAndCacheBestMethod(dispatchVal)))
    )

    private IFn getFn(Object dispatchVal)
    (§
        IFn targetFn = getMethod(dispatchVal)
        if (targetFn == nil)
        (§
            throw new IllegalArgumentException(String.format("No method in multimethod '%s' for dispatch value: %s", name, dispatchVal))
        )
        (§ return (§ expr targetFn))
    )

    private IFn findAndCacheBestMethod(Object dispatchVal)
    (§
        rw.readLock().lock()
        Object bestValue
        IPersistentMap mt = methodTable
        IPersistentMap pt = preferTable
        Object ch = cachedHierarchy
        try
        (§
            Map.Entry bestEntry = nil
            for (Object o :in getMethodTable())
            (§
                Map.Entry e = (Map.Entry) o
                if (isA(dispatchVal, e.getKey()))
                (§
                    if (bestEntry == nil || dominates(e.getKey(), bestEntry.getKey()))
                    (§
                        bestEntry = e
                    )
                    if (!dominates(bestEntry.getKey(), e.getKey()))
                    (§
                        throw new IllegalArgumentException(String.format("Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", name, dispatchVal, e.getKey(), bestEntry.getKey()))
                    )
                )
            )
            if (bestEntry == nil)
            (§
                bestValue = methodTable.valAt(defaultDispatchVal)
                if (bestValue == nil)
                (§
                    (§ return (§ expr nil))
                )
            )
            else
            (§
                bestValue = bestEntry.getValue()
            )
        )
        finally
        (§
            rw.readLock().unlock()
        )

        ;; ensure basis has stayed stable throughout, else redo
        rw.writeLock().lock()
        try
        (§
            if (mt == methodTable && pt == preferTable && ch == cachedHierarchy && cachedHierarchy == hierarchy.deref())
            (§
                ;; place in cache
                methodCache = methodCache.assoc(dispatchVal, bestValue)
                (§ return (§ expr (IFn) bestValue))
            )
            else
            (§
                resetCache()
                (§ return (§ expr findAndCacheBestMethod(dispatchVal)))
            )
        )
        finally
        (§
            rw.writeLock().unlock()
        )
    )

    public Object invoke()
    (§
        (§ return (§ expr getFn(dispatchFn.invoke()).invoke()))
    )

    public Object invoke(Object arg1)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1)).invoke(Util.ret1(arg1, arg1 = nil))))
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2)).
            invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3)).
            invoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        (§ return (§ expr getFn(dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        (§ return (§ expr getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        (§ return (§ expr getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        (§ return (§ expr getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        (§ return (§ expr getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        (§ return (§ expr getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        (§ return (§ expr getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        (§ return (§ expr getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args)
    (§
        (§ return (§ expr getFn(
                dispatchFn.invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14,
                    arg15, arg16, arg17, arg18, arg19, arg20, args)).
            invoke(Util.ret1(arg1, arg1 = nil),
                    Util.ret1(arg2, arg2 = nil),
                    Util.ret1(arg3, arg3 = nil),
                    Util.ret1(arg4, arg4 = nil),
                    Util.ret1(arg5, arg5 = nil),
                    Util.ret1(arg6, arg6 = nil),
                    Util.ret1(arg7, arg7 = nil),
                    Util.ret1(arg8, arg8 = nil),
                    Util.ret1(arg9, arg9 = nil),
                    Util.ret1(arg10, arg10 = nil),
                    Util.ret1(arg11, arg11 = nil),
                    Util.ret1(arg12, arg12 = nil),
                    Util.ret1(arg13, arg13 = nil),
                    Util.ret1(arg14, arg14 = nil),
                    Util.ret1(arg15, arg15 = nil),
                    Util.ret1(arg16, arg16 = nil),
                    Util.ret1(arg17, arg17 = nil),
                    Util.ret1(arg18, arg18 = nil),
                    Util.ret1(arg19, arg19 = nil),
                    Util.ret1(arg20, arg20 = nil),
                    args)))
    )

    public IPersistentMap getMethodTable()
    (§
        (§ return (§ expr methodTable))
    )

    public IPersistentMap getPreferTable()
    (§
        (§ return (§ expr preferTable))
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.io.Serializable)
(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
(§ class public final class Murmur3)
(§
    private static final int seed = 0
    private static final int C1 = 0xcc9e2d51
    private static final int C2 = 0x1b873593

    public static int hashInt(int input)
    (§
        if (input == 0)
        (§
            (§ return (§ expr 0))
        )
        int k1 = mixK1(input)
        int h1 = mixH1(seed, k1)

        (§ return (§ expr fmix(h1, 4)))
    )

    public static int hashLong(long input)
    (§
        if (input == 0)
        (§
            (§ return (§ expr 0))
        )
        int low = (int) input
        int high = (int) (input >>> 32)

        int k1 = mixK1(low)
        int h1 = mixH1(seed, k1)

        k1 = mixK1(high)
        h1 = mixH1(h1, k1)

        (§ return (§ expr fmix(h1, 8)))
    )

    public static int hashUnencodedChars(CharSequence input)
    (§
        int h1 = seed

        ;; step through the CharSequence 2 chars at a time
        for (int i = 1 i < input.length() i += 2)
        (§
            int k1 = input.charAt(i - 1) | (input.charAt(i) << 16)
            k1 = mixK1(k1)
            h1 = mixH1(h1, k1)
        )

        ;; deal with any remaining characters
        if ((input.length() & 1) == 1)
        (§
            int k1 = input.charAt(input.length() - 1)
            k1 = mixK1(k1)
            h1 ^= k1
        )

        (§ return (§ expr fmix(h1, 2 * input.length())))
    )

    public static int mixCollHash(int hash, int count)
    (§
        int h1 = seed
        int k1 = mixK1(hash)
        h1 = mixH1(h1, k1)
        (§ return (§ expr fmix(h1, count)))
    )

    public static int hashOrdered(Iterable xs)
    (§
        int n = 0
        int hash = 1

        for (Object x :in xs)
        (§
            hash = 31 * hash + Util.hasheq(x)
            ++n
        )

        (§ return (§ expr mixCollHash(hash, n)))
    )

    public static int hashUnordered(Iterable xs)
    (§
        int hash = 0
        int n = 0
        for (Object x :in xs)
        (§
            hash += Util.hasheq(x)
            ++n
        )

        (§ return (§ expr mixCollHash(hash, n)))
    )

    private static int mixK1(int k1)
    (§
        k1 *= C1
        k1 = Integer.rotateLeft(k1, 15)
        k1 *= C2
        (§ return (§ expr k1))
    )

    private static int mixH1(int h1, int k1)
    (§
        h1 ^= k1
        h1 = Integer.rotateLeft(h1, 13)
        h1 = h1 * 5 + 0xe6546b64
        (§ return (§ expr h1))
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    private static int fmix(int h1, int length)
    (§
        h1 ^= length
        h1 ^= h1 >>> 16
        h1 *= 0x85ebca6b
        h1 ^= h1 >>> 13
        h1 *= 0xc2b2ae35
        h1 ^= h1 >>> 16
        (§ return (§ expr h1))
    )
)
)

(java-ns cloiure.lang.Named

(§ interface public interface Named)
(§
    String getNamespace()

    String getName()
)
)

(java-ns cloiure.lang.Namespace

(§ import java.io.ObjectStreamException)
(§ import java.io.Serializable)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(§ class public class Namespace extends AReference implements Serializable)
(§
    final public Symbol name

    transient final AtomicReference<IPersistentMap> mappings = new AtomicReference<IPersistentMap>()
    transient final AtomicReference<IPersistentMap> aliases = new AtomicReference<IPersistentMap>()

    final static ConcurrentHashMap<Symbol, Namespace> namespaces = new ConcurrentHashMap<Symbol, Namespace>()

    public String toString()
    (§
        (§ return (§ expr name.toString()))
    )

    Namespace(Symbol name)
    (§
        super(name.meta())
        this.name = name
        mappings.set(RT.DEFAULT_IMPORTS)
        aliases.set(RT.map())
    )

    public static ISeq all()
    (§
        (§ return (§ expr RT.seq(namespaces.values())))
    )

    public Symbol getName()
    (§
        (§ return (§ expr name))
    )

    public IPersistentMap getMappings()
    (§
        (§ return (§ expr mappings.get()))
    )

    public Var intern(Symbol sym)
    (§
        if (sym.ns != nil)
        (§
            throw new IllegalArgumentException("Can't intern namespace-qualified symbol")
        )
        IPersistentMap map = getMappings()
        Object o
        Var v = nil
        while ((o = map.valAt(sym)) == nil)
        (§
            if (v == nil)
            (§
                v = new Var(this, sym)
            )
            IPersistentMap newMap = map.assoc(sym, v)
            mappings.compareAndSet(map, newMap)
            map = getMappings()
        )
        if (o instanceof Var && ((Var) o).ns == this)
        (§
            (§ return (§ expr (Var) o))
        )

        if (v == nil)
        (§
            v = new Var(this, sym)
        )

        warnOrFailOnReplace(sym, o, v)

        while (!mappings.compareAndSet(map, map.assoc(sym, v)))
            map = getMappings()

        (§ return (§ expr v))
    )

    private void warnOrFailOnReplace(Symbol sym, Object o, Object v)
    (§
        if (o instanceof Var)
        (§
            Namespace ns = ((Var)o).ns
            if (ns == this || (v instanceof Var && ((Var)v).ns  == RT.CLOIURE_NS))
            (§
                (§ return (§ expr ))
            )
            if (ns != RT.CLOIURE_NS)
            (§
                throw new IllegalStateException(sym + " already refers to: " + o + " in namespace: " + name)
            )
        )
        RT.errPrintWriter().println("WARNING: " + sym + " already refers to: " + o + " in namespace: " + name + ", being replaced by: " + v)
    )

    Object reference(Symbol sym, Object val)
    (§
        if (sym.ns != nil)
        (§
            throw new IllegalArgumentException("Can't intern namespace-qualified symbol")
        )
        IPersistentMap map = getMappings()
        Object o
        while ((o = map.valAt(sym)) == nil)
        (§
            IPersistentMap newMap = map.assoc(sym, val)
            mappings.compareAndSet(map, newMap)
            map = getMappings()
        )
        if (o == val)
        (§
            (§ return (§ expr o))
        )

        warnOrFailOnReplace(sym, o, val)

        while (!mappings.compareAndSet(map, map.assoc(sym, val)))
            map = getMappings()

        (§ return (§ expr val))
    )

    public static boolean areDifferentInstancesOfSameClassName(Class cls1, Class cls2)
    (§
        (§ return (§ expr (cls1 != cls2) && (cls1.getName().equals(cls2.getName()))))
    )

    Class referenceClass(Symbol sym, Class val)
    (§
        if (sym.ns != nil)
        (§
            throw new IllegalArgumentException("Can't intern namespace-qualified symbol")
        )
        IPersistentMap map = getMappings()
        Class c = (Class) map.valAt(sym)
        while ((c == nil) || (areDifferentInstancesOfSameClassName(c, val)))
        (§
            IPersistentMap newMap = map.assoc(sym, val)
            mappings.compareAndSet(map, newMap)
            map = getMappings()
            c = (Class) map.valAt(sym)
        )
        if (c == val)
        (§
            (§ return (§ expr c))
        )

        throw new IllegalStateException(sym + " already refers to: " + c + " in namespace: " + name)
    )

    public void unmap(Symbol sym)
    (§
        if (sym.ns != nil)
        (§
            throw new IllegalArgumentException("Can't unintern namespace-qualified symbol")
        )
        IPersistentMap map = getMappings()
        while (map.containsKey(sym))
        (§
            IPersistentMap newMap = map.without(sym)
            mappings.compareAndSet(map, newMap)
            map = getMappings()
        )
    )

    public Class importClass(Symbol sym, Class c)
    (§
        (§ return (§ expr referenceClass(sym, c)))
    )

    public Class importClass(Class c)
    (§
        String n = c.getName()
        (§ return (§ expr importClass(Symbol.intern(n.substring(n.lastIndexOf(\.) + 1)), c)))
    )

    public Var refer(Symbol sym, Var var)
    (§
        (§ return (§ expr (Var) reference(sym, var)))
    )

    public static Namespace findOrCreate(Symbol name)
    (§
        Namespace ns = namespaces.get(name)
        if (ns != nil)
        (§
            (§ return (§ expr ns))
        )
        Namespace newns = new Namespace(name)
        ns = namespaces.putIfAbsent(name, newns)
        (§ return (§ expr (ns == nil) ? newns :or ns))
    )

    public static Namespace remove(Symbol name)
    (§
        if (name.equals(RT.CLOIURE_NS.name))
        (§
            throw new IllegalArgumentException("Cannot remove cloiure namespace")
        )
        (§ return (§ expr namespaces.remove(name)))
    )

    public static Namespace find(Symbol name)
    (§
        (§ return (§ expr namespaces.get(name)))
    )

    public Object getMapping(Symbol name)
    (§
        (§ return (§ expr mappings.get().valAt(name)))
    )

    public Var findInternedVar(Symbol symbol)
    (§
        Object o = mappings.get().valAt(symbol)
        if (o != nil && o instanceof Var && ((Var) o).ns == this)
        (§
            (§ return (§ expr (Var) o))
        )
        (§ return (§ expr nil))
    )

    public IPersistentMap getAliases()
    (§
        (§ return (§ expr aliases.get()))
    )

    public Namespace lookupAlias(Symbol alias)
    (§
        IPersistentMap map = getAliases()
        (§ return (§ expr (Namespace) map.valAt(alias)))
    )

    public void addAlias(Symbol alias, Namespace ns)
    (§
        if (alias == nil || ns == nil)
        (§
            throw new NullPointerException("Expecting Symbol + Namespace")
        )
        IPersistentMap map = getAliases()
        while (!map.containsKey(alias))
        (§
            IPersistentMap newMap = map.assoc(alias, ns)
            aliases.compareAndSet(map, newMap)
            map = getAliases()
        )
        ;; you can rebind an alias, but only to the initially-aliased namespace.
        if (!map.valAt(alias).equals(ns))
        (§
            throw new IllegalStateException("Alias " + alias + " already exists in namespace " + name + ", aliasing " + map.valAt(alias))
        )
    )

    public void removeAlias(Symbol alias)
    (§
        IPersistentMap map = getAliases()
        while (map.containsKey(alias))
        (§
            IPersistentMap newMap = map.without(alias)
            aliases.compareAndSet(map, newMap)
            map = getAliases()
        )
    )

    private Object readResolve() throws ObjectStreamException
    (§
        ;; ensures that serialized namespaces are "deserialized" to the
        ;; namespace in the present runtime
        (§ return (§ expr findOrCreate(name)))
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(§ class public class Numbers)
(§
    static interface Ops
    (§
        Ops combine(Ops y)

        Ops opsWith(LongOps x)

        Ops opsWith(DoubleOps x)

        Ops opsWith(RatioOps x)

        Ops opsWith(BigIntOps x)

        Ops opsWith(BigDecimalOps x)

        public boolean isZero(Number x)

        public boolean isPos(Number x)

        public boolean isNeg(Number x)

        public Number add(Number x, Number y)
        public Number addP(Number x, Number y)

        public Number multiply(Number x, Number y)
        public Number multiplyP(Number x, Number y)

        public Number divide(Number x, Number y)

        public Number quotient(Number x, Number y)

        public Number remainder(Number x, Number y)

        public boolean equiv(Number x, Number y)

        public boolean lt(Number x, Number y)
        public boolean lte(Number x, Number y)
        public boolean gte(Number x, Number y)

        public Number negate(Number x)
        public Number negateP(Number x)

        public Number inc(Number x)
        public Number incP(Number x)

        public Number dec(Number x)
        public Number decP(Number x)
    )

    static abstract class OpsP implements Ops
    (§
        public Number addP(Number x, Number y)
        (§
            (§ return (§ expr add(x, y)))
        )

        public Number multiplyP(Number x, Number y)
        (§
            (§ return (§ expr multiply(x, y)))
        )

        public Number negateP(Number x)
        (§
            (§ return (§ expr negate(x)))
        )

        public Number incP(Number x)
        (§
            (§ return (§ expr inc(x)))
        )

        public Number decP(Number x)
        (§
            (§ return (§ expr dec(x)))
        )
    )

    static public boolean isZero(Object x)
    (§
        (§ return (§ expr ops(x).isZero((Number)x)))
    )

    static public boolean isPos(Object x)
    (§
        (§ return (§ expr ops(x).isPos((Number)x)))
    )

    static public boolean isNeg(Object x)
    (§
        (§ return (§ expr ops(x).isNeg((Number)x)))
    )

    static public Number minus(Object x)
    (§
        (§ return (§ expr ops(x).negate((Number)x)))
    )

    static public Number minusP(Object x)
    (§
        (§ return (§ expr ops(x).negateP((Number)x)))
    )

    static public Number inc(Object x)
    (§
        (§ return (§ expr ops(x).inc((Number)x)))
    )

    static public Number incP(Object x)
    (§
        (§ return (§ expr ops(x).incP((Number)x)))
    )

    static public Number dec(Object x)
    (§
        (§ return (§ expr ops(x).dec((Number)x)))
    )

    static public Number decP(Object x)
    (§
        (§ return (§ expr ops(x).decP((Number)x)))
    )

    static public Number add(Object x, Object y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).add((Number)x, (Number)y)))
    )

    static public Number addP(Object x, Object y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).addP((Number)x, (Number)y)))
    )

    static public Number minus(Object x, Object y)
    (§
        Ops yops = ops(y)
        (§ return (§ expr ops(x).combine(yops).add((Number)x, yops.negate((Number)y))))
    )

    static public Number minusP(Object x, Object y)
    (§
        Ops yops = ops(y)
        Number negativeY = yops.negateP((Number) y)
        Ops negativeYOps = ops(negativeY)
        (§ return (§ expr ops(x).combine(negativeYOps).addP((Number)x, negativeY)))
    )

    static public Number multiply(Object x, Object y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).multiply((Number)x, (Number)y)))
    )

    static public Number multiplyP(Object x, Object y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).multiplyP((Number)x, (Number)y)))
    )

    static public Number divide(Object x, Object y)
    (§
        if (isNaN(x))
        (§
            (§ return (§ expr (Number)x))
        )
        else if (isNaN(y))
        (§
            (§ return (§ expr (Number)y))
        )
        Ops yops = ops(y)
        if (yops.isZero((Number)y))
        (§
            throw new ArithmeticException("Divide by zero")
        )
        (§ return (§ expr ops(x).combine(yops).divide((Number)x, (Number)y)))
    )

    static public Number quotient(Object x, Object y)
    (§
        Ops yops = ops(y)
        if (yops.isZero((Number) y))
        (§
            throw new ArithmeticException("Divide by zero")
        )
        (§ return (§ expr ops(x).combine(yops).quotient((Number)x, (Number)y)))
    )

    static public Number remainder(Object x, Object y)
    (§
        Ops yops = ops(y)
        if (yops.isZero((Number) y))
        (§
            throw new ArithmeticException("Divide by zero")
        )
        (§ return (§ expr ops(x).combine(yops).remainder((Number)x, (Number)y)))
    )

    static public double quotient(double n, double d)
    (§
        if (d == 0)
        (§
            throw new ArithmeticException("Divide by zero")
        )

        double q = n / d
        if (q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
        (§
            (§ return (§ expr (double)(long) q))
        )
        else ;; bigint quotient
        (§
            (§ return (§ expr new BigDecimal(q).toBigInteger().doubleValue()))
        )
    )

    static public double remainder(double n, double d)
    (§
        if (d == 0)
        (§
            throw new ArithmeticException("Divide by zero")
        )

        double q = n / d
        if (q <= Long.MAX_VALUE && q >= Long.MIN_VALUE)
        (§
            (§ return (§ expr (n - ((long) q) * d)))
        )
        else ;; bigint quotient
        (§
            Number bq = new BigDecimal(q).toBigInteger()
            (§ return (§ expr (n - bq.doubleValue() * d)))
        )
    )

    static public boolean equiv(Object x, Object y)
    (§
        (§ return (§ expr equiv((Number) x, (Number) y)))
    )

    static public boolean equiv(Number x, Number y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).equiv(x, y)))
    )

    static public boolean equal(Number x, Number y)
    (§
        (§ return (§ expr (category(x) == category(y) && ops(x).combine(ops(y)).equiv(x, y))))
    )

    static public boolean lt(Object x, Object y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).lt((Number)x, (Number)y)))
    )

    static public boolean lte(Object x, Object y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).lte((Number)x, (Number)y)))
    )

    static public boolean gt(Object x, Object y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).lt((Number)y, (Number)x)))
    )

    static public boolean gte(Object x, Object y)
    (§
        (§ return (§ expr ops(x).combine(ops(y)).gte((Number)x, (Number)y)))
    )

    static public int compare(Number x, Number y)
    (§
        Ops ops = ops(x).combine(ops(y))
        if (ops.lt(x, y))
        (§
            (§ return (§ expr -1))
        )
        else if (ops.lt(y, x))
        (§
            (§ return (§ expr 1))
        )
        (§ return (§ expr 0))
    )

    (§ anno @WarnBoxedMath(false))
    static BigInt toBigInt(Object x)
    (§
        if (x instanceof BigInt)
        (§
            (§ return (§ expr (BigInt) x))
        )
        if (x instanceof BigInteger)
        (§
            (§ return (§ expr BigInt.fromBigInteger((BigInteger) x)))
        )
        else
        (§
            (§ return (§ expr BigInt.fromLong(((Number) x).longValue())))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static BigInteger toBigInteger(Object x)
    (§
        if (x instanceof BigInteger)
        (§
            (§ return (§ expr (BigInteger) x))
        )
        else if (x instanceof BigInt)
        (§
            (§ return (§ expr ((BigInt) x).toBigInteger()))
        )
        else
        (§
            (§ return (§ expr BigInteger.valueOf(((Number) x).longValue())))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static BigDecimal toBigDecimal(Object x)
    (§
        if (x instanceof BigDecimal)
        (§
            (§ return (§ expr (BigDecimal) x))
        )
        else if (x instanceof BigInt)
        (§
            BigInt bi = (BigInt) x
            if (bi.bipart == nil)
            (§
                (§ return (§ expr BigDecimal.valueOf(bi.lpart)))
            )
            else
            (§
                (§ return (§ expr new BigDecimal(bi.bipart)))
            )
        )
        else if (x instanceof BigInteger)
        (§
            (§ return (§ expr new BigDecimal((BigInteger) x)))
        )
        else if (x instanceof Double)
        (§
            (§ return (§ expr new BigDecimal(((Number) x).doubleValue())))
        )
        else if (x instanceof Float)
        (§
            (§ return (§ expr new BigDecimal(((Number) x).doubleValue())))
        )
        else if (x instanceof Ratio)
        (§
            Ratio r = (Ratio)x
            (§ return (§ expr (BigDecimal)divide(new BigDecimal(r.numerator), r.denominator)))
        )
        else
        (§
            (§ return (§ expr BigDecimal.valueOf(((Number) x).longValue())))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public Ratio toRatio(Object x)
    (§
        if (x instanceof Ratio)
        (§
            (§ return (§ expr (Ratio) x))
        )
        else if (x instanceof BigDecimal)
        (§
            BigDecimal bx = (BigDecimal) x
            BigInteger bv = bx.unscaledValue()
            int scale = bx.scale()
            if (scale < 0)
            (§
                (§ return (§ expr new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)), BigInteger.ONE)))
            )
            else
            (§
                (§ return (§ expr new Ratio(bv, BigInteger.TEN.pow(scale))))
            )
        )
        (§ return (§ expr new Ratio(toBigInteger(x), BigInteger.ONE)))
    )

    (§ anno @WarnBoxedMath(false))
    static public Number rationalize(Number x)
    (§
        if (x instanceof Float || x instanceof Double)
        (§
            (§ return (§ expr rationalize(BigDecimal.valueOf(x.doubleValue()))))
        )
        else if (x instanceof BigDecimal)
        (§
            BigDecimal bx = (BigDecimal) x
            BigInteger bv = bx.unscaledValue()
            int scale = bx.scale()
            if (scale < 0)
            (§
                (§ return (§ expr BigInt.fromBigInteger(bv.multiply(BigInteger.TEN.pow(-scale)))))
            )
            else
            (§
                (§ return (§ expr divide(bv, BigInteger.TEN.pow(scale))))
            )
        )
        (§ return (§ expr x))
    )

    (§ anno @WarnBoxedMath(false))
    static public Number reduceBigInt(BigInt val)
    (§
        if (val.bipart == nil)
        (§
            (§ return (§ expr num(val.lpart)))
        )
        else
        (§
            (§ return (§ expr val.bipart))
        )
    )

    static public Number divide(BigInteger n, BigInteger d)
    (§
        if (d.equals(BigInteger.ZERO))
        (§
            throw new ArithmeticException("Divide by zero")
        )
        BigInteger gcd = n.gcd(d)
        if (gcd.equals(BigInteger.ZERO))
        (§
            (§ return (§ expr BigInt.ZERO))
        )
        n = n.divide(gcd)
        d = d.divide(gcd)
        if (d.equals(BigInteger.ONE))
        (§
            (§ return (§ expr BigInt.fromBigInteger(n)))
        )
        else if (d.equals(BigInteger.ONE.negate()))
        (§
            (§ return (§ expr BigInt.fromBigInteger(n.negate())))
        )
        (§ return (§ expr new Ratio(((d.signum() < 0) ? n.negate() :or n), ((d.signum() < 0) ? d.negate() :or d))))
    )

    static public int shiftLeftInt(int x, int n)
    (§
        (§ return (§ expr x << n))
    )

    static public long shiftLeft(Object x, Object y)
    (§
        (§ return (§ expr shiftLeft(bitOpsCast(x), bitOpsCast(y))))
    )
    static public long shiftLeft(Object x, long y)
    (§
        (§ return (§ expr shiftLeft(bitOpsCast(x), y)))
    )
    static public long shiftLeft(long x, Object y)
    (§
        (§ return (§ expr shiftLeft(x, bitOpsCast(y))))
    )
    static public long shiftLeft(long x, long n)
    (§
        (§ return (§ expr x << n))
    )

    static public int shiftRightInt(int x, int n)
    (§
        (§ return (§ expr x >> n))
    )

    static public long shiftRight(Object x, Object y)
    (§
        (§ return (§ expr shiftRight(bitOpsCast(x), bitOpsCast(y))))
    )
    static public long shiftRight(Object x, long y)
    (§
        (§ return (§ expr shiftRight(bitOpsCast(x), y)))
    )
    static public long shiftRight(long x, Object y)
    (§
        (§ return (§ expr shiftRight(x, bitOpsCast(y))))
    )
    static public long shiftRight(long x, long n)
    (§
        (§ return (§ expr x >> n))
    )

    static public int unsignedShiftRightInt(int x, int n)
    (§
        (§ return (§ expr x >>> n))
    )

    static public long unsignedShiftRight(Object x, Object y)
    (§
        (§ return (§ expr unsignedShiftRight(bitOpsCast(x), bitOpsCast(y))))
    )
    static public long unsignedShiftRight(Object x, long y)
    (§
        (§ return (§ expr unsignedShiftRight(bitOpsCast(x), y)))
    )
    static public long unsignedShiftRight(long x, Object y)
    (§
        (§ return (§ expr unsignedShiftRight(x, bitOpsCast(y))))
    )
    static public long unsignedShiftRight(long x, long n)
    (§
        (§ return (§ expr x >>> n))
    )

    final static class LongOps implements Ops
    (§
        public Ops combine(Ops y)
        (§
            (§ return (§ expr y.opsWith(this)))
        )

        final public Ops opsWith(LongOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(DoubleOps x)
        (§
            (§ return (§ expr DOUBLE_OPS))
        )

        final public Ops opsWith(RatioOps x)
        (§
            (§ return (§ expr RATIO_OPS))
        )

        final public Ops opsWith(BigIntOps x)
        (§
            (§ return (§ expr BIGINT_OPS))
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            (§ return (§ expr BIGDECIMAL_OPS))
        )

        public boolean isZero(Number x)
        (§
            (§ return (§ expr (x.longValue() == 0)))
        )

        public boolean isPos(Number x)
        (§
            (§ return (§ expr (x.longValue() > 0)))
        )

        public boolean isNeg(Number x)
        (§
            (§ return (§ expr (x.longValue() < 0)))
        )

        final public Number add(Number x, Number y)
        (§
            (§ return (§ expr num(Numbers.add(x.longValue(), y.longValue()))))
        )

        final public Number addP(Number x, Number y)
        (§
            long lx = x.longValue(), ly = y.longValue()
            long ret = lx + ly
            if ((ret :xor lx) < 0 && (ret :xor ly) < 0)
            (§
                (§ return (§ expr BIGINT_OPS.add(x, y)))
            )
            (§ return (§ expr num(ret)))
        )

        final public Number multiply(Number x, Number y)
        (§
            (§ return (§ expr num(Numbers.multiply(x.longValue(), y.longValue()))))
        )

        final public Number multiplyP(Number x, Number y)
        (§
            long lx = x.longValue(), ly = y.longValue()
            if (lx == Long.MIN_VALUE && ly < 0)
            (§
                (§ return (§ expr BIGINT_OPS.multiply(x, y)))
            )
            long ret = lx * ly
            if (ly != 0 && ret/ly != lx)
            (§
                (§ return (§ expr BIGINT_OPS.multiply(x, y)))
            )
            (§ return (§ expr num(ret)))
        )

        static long gcd(long u, long v)
        (§
            while (v != 0)
            (§
                long r = u % v
                u = v
                v = r
            )
            (§ return (§ expr u))
        )

        public Number divide(Number x, Number y)
        (§
            long n = x.longValue()
            long val = y.longValue()
            long gcd = gcd(n, val)
            if (gcd == 0)
            (§
                (§ return (§ expr num(0)))
            )

            n = n / gcd
            long d = val / gcd
            if (d == 1)
            (§
                (§ return (§ expr num(n)))
            )
            if (d < 0)
            (§
                n = -n
                d = -d
            )
            (§ return (§ expr new Ratio(BigInteger.valueOf(n), BigInteger.valueOf(d))))
        )

        public Number quotient(Number x, Number y)
        (§
            (§ return (§ expr num(x.longValue() / y.longValue())))
        )

        public Number remainder(Number x, Number y)
        (§
            (§ return (§ expr num(x.longValue() % y.longValue())))
        )

        public boolean equiv(Number x, Number y)
        (§
            (§ return (§ expr (x.longValue() == y.longValue())))
        )

        public boolean lt(Number x, Number y)
        (§
            (§ return (§ expr (x.longValue() < y.longValue())))
        )

        public boolean lte(Number x, Number y)
        (§
            (§ return (§ expr (x.longValue() <= y.longValue())))
        )

        public boolean gte(Number x, Number y)
        (§
            (§ return (§ expr (x.longValue() >= y.longValue())))
        )

        final public Number negate(Number x)
        (§
            long val = x.longValue()
            (§ return (§ expr num(Numbers.minus(val))))
        )

        final public Number negateP(Number x)
        (§
            long val = x.longValue()
            if (val > Long.MIN_VALUE)
            (§
                (§ return (§ expr num(-val)))
            )
            (§ return (§ expr BigInt.fromBigInteger(BigInteger.valueOf(val).negate())))
        )

        public Number inc(Number x)
        (§
            long val = x.longValue()
            (§ return (§ expr num(Numbers.inc(val))))
        )

        public Number incP(Number x)
        (§
            long val = x.longValue()
            if (val < Long.MAX_VALUE)
            (§
                (§ return (§ expr num(val + 1)))
            )
            (§ return (§ expr BIGINT_OPS.inc(x)))
        )

        public Number dec(Number x)
        (§
            long val = x.longValue()
            (§ return (§ expr num(Numbers.dec(val))))
        )

        public Number decP(Number x)
        (§
            long val = x.longValue()
            if (val > Long.MIN_VALUE)
            (§
                (§ return (§ expr num(val - 1)))
            )
            (§ return (§ expr BIGINT_OPS.dec(x)))
        )
    )

    final static class DoubleOps extends OpsP
    (§
        public Ops combine(Ops y)
        (§
            (§ return (§ expr y.opsWith(this)))
        )

        final public Ops opsWith(LongOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(DoubleOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(RatioOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(BigIntOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            (§ return (§ expr this))
        )

        public boolean isZero(Number x)
        (§
            (§ return (§ expr (x.doubleValue() == 0)))
        )

        public boolean isPos(Number x)
        (§
            (§ return (§ expr (x.doubleValue() > 0)))
        )

        public boolean isNeg(Number x)
        (§
            (§ return (§ expr (x.doubleValue() < 0)))
        )

        final public Number add(Number x, Number y)
        (§
            (§ return (§ expr Double.valueOf(x.doubleValue() + y.doubleValue())))
        )

        final public Number multiply(Number x, Number y)
        (§
            (§ return (§ expr Double.valueOf(x.doubleValue() * y.doubleValue())))
        )

        public Number divide(Number x, Number y)
        (§
            (§ return (§ expr Double.valueOf(x.doubleValue() / y.doubleValue())))
        )

        public Number quotient(Number x, Number y)
        (§
            (§ return (§ expr Numbers.quotient(x.doubleValue(), y.doubleValue())))
        )

        public Number remainder(Number x, Number y)
        (§
            (§ return (§ expr Numbers.remainder(x.doubleValue(), y.doubleValue())))
        )

        public boolean equiv(Number x, Number y)
        (§
            (§ return (§ expr (x.doubleValue() == y.doubleValue())))
        )

        public boolean lt(Number x, Number y)
        (§
            (§ return (§ expr (x.doubleValue() < y.doubleValue())))
        )

        public boolean lte(Number x, Number y)
        (§
            (§ return (§ expr (x.doubleValue() <= y.doubleValue())))
        )

        public boolean gte(Number x, Number y)
        (§
            (§ return (§ expr (x.doubleValue() >= y.doubleValue())))
        )

        final public Number negate(Number x)
        (§
            (§ return (§ expr Double.valueOf(-x.doubleValue())))
        )

        public Number inc(Number x)
        (§
            (§ return (§ expr Double.valueOf(x.doubleValue() + 1)))
        )

        public Number dec(Number x)
        (§
            (§ return (§ expr Double.valueOf(x.doubleValue() - 1)))
        )
    )

    final static class RatioOps extends OpsP
    (§
        public Ops combine(Ops y)
        (§
            (§ return (§ expr y.opsWith(this)))
        )

        final public Ops opsWith(LongOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(DoubleOps x)
        (§
            (§ return (§ expr DOUBLE_OPS))
        )

        final public Ops opsWith(RatioOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(BigIntOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            (§ return (§ expr BIGDECIMAL_OPS))
        )

        public boolean isZero(Number x)
        (§
            Ratio r = (Ratio) x
            (§ return (§ expr (r.numerator.signum() == 0)))
        )

        public boolean isPos(Number x)
        (§
            Ratio r = (Ratio) x
            (§ return (§ expr (r.numerator.signum() > 0)))
        )

        public boolean isNeg(Number x)
        (§
            Ratio r = (Ratio) x
            (§ return (§ expr (r.numerator.signum() < 0)))
        )

        static Number normalizeRet(Number ret, Number x, Number y)
        (§
            (§ return (§ expr ret))
        )

        final public Number add(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            Number ret = divide(ry.numerator.multiply(rx.denominator).add(rx.numerator.multiply(ry.denominator)), ry.denominator.multiply(rx.denominator))
            (§ return (§ expr normalizeRet(ret, x, y)))
        )

        final public Number multiply(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            Number ret = Numbers.divide(ry.numerator.multiply(rx.numerator), ry.denominator.multiply(rx.denominator))
            (§ return (§ expr normalizeRet(ret, x, y)))
        )

        public Number divide(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            Number ret = Numbers.divide(ry.denominator.multiply(rx.numerator), ry.numerator.multiply(rx.denominator))
            (§ return (§ expr normalizeRet(ret, x, y)))
        )

        public Number quotient(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            BigInteger q = rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator))
            (§ return (§ expr normalizeRet(BigInt.fromBigInteger(q), x, y)))
        )

        public Number remainder(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            BigInteger q = rx.numerator.multiply(ry.denominator).divide(rx.denominator.multiply(ry.numerator))
            Number ret = Numbers.minus(x, Numbers.multiply(q, y))
            (§ return (§ expr normalizeRet(ret, x, y)))
        )

        public boolean equiv(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            (§ return (§ expr (rx.numerator.equals(ry.numerator) && rx.denominator.equals(ry.denominator))))
        )

        public boolean lt(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            (§ return (§ expr Numbers.lt(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))))
        )

        public boolean lte(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            (§ return (§ expr Numbers.lte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))))
        )

        public boolean gte(Number x, Number y)
        (§
            Ratio rx = toRatio(x)
            Ratio ry = toRatio(y)
            (§ return (§ expr Numbers.gte(rx.numerator.multiply(ry.denominator), ry.numerator.multiply(rx.denominator))))
        )

        final public Number negate(Number x)
        (§
            Ratio r = (Ratio) x
            (§ return (§ expr new Ratio(r.numerator.negate(), r.denominator)))
        )

        public Number inc(Number x)
        (§
            (§ return (§ expr Numbers.add(x, 1)))
        )

        public Number dec(Number x)
        (§
            (§ return (§ expr Numbers.add(x, -1)))
        )
    )

    final static class BigIntOps extends OpsP
    (§
        public Ops combine(Ops y)
        (§
            (§ return (§ expr y.opsWith(this)))
        )

        final public Ops opsWith(LongOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(DoubleOps x)
        (§
            (§ return (§ expr DOUBLE_OPS))
        )

        final public Ops opsWith(RatioOps x)
        (§
            (§ return (§ expr RATIO_OPS))
        )

        final public Ops opsWith(BigIntOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            (§ return (§ expr BIGDECIMAL_OPS))
        )

        public boolean isZero(Number x)
        (§
            BigInt bx = toBigInt(x)
            if (bx.bipart == nil)
            (§
                (§ return (§ expr (bx.lpart == 0)))
            )
            (§ return (§ expr (bx.bipart.signum() == 0)))
        )

        public boolean isPos(Number x)
        (§
            BigInt bx = toBigInt(x)
            if (bx.bipart == nil)
            (§
                (§ return (§ expr (bx.lpart > 0)))
            )
            (§ return (§ expr (bx.bipart.signum() > 0)))
        )

        public boolean isNeg(Number x)
        (§
            BigInt bx = toBigInt(x)
            if (bx.bipart == nil)
            (§
                (§ return (§ expr (bx.lpart < 0)))
            )
            (§ return (§ expr (bx.bipart.signum() < 0)))
        )

        final public Number add(Number x, Number y)
        (§
            (§ return (§ expr toBigInt(x).add(toBigInt(y))))
        )

        final public Number multiply(Number x, Number y)
        (§
            (§ return (§ expr toBigInt(x).multiply(toBigInt(y))))
        )

        public Number divide(Number x, Number y)
        (§
            (§ return (§ expr Numbers.divide(toBigInteger(x), toBigInteger(y))))
        )

        public Number quotient(Number x, Number y)
        (§
            (§ return (§ expr toBigInt(x).quotient(toBigInt(y))))
        )

        public Number remainder(Number x, Number y)
        (§
            (§ return (§ expr toBigInt(x).remainder(toBigInt(y))))
        )

        public boolean equiv(Number x, Number y)
        (§
            (§ return (§ expr toBigInt(x).equals(toBigInt(y))))
        )

        public boolean lt(Number x, Number y)
        (§
            (§ return (§ expr toBigInt(x).lt(toBigInt(y))))
        )

        public boolean lte(Number x, Number y)
        (§
            (§ return (§ expr (toBigInteger(x).compareTo(toBigInteger(y)) <= 0)))
        )

        public boolean gte(Number x, Number y)
        (§
            (§ return (§ expr (toBigInteger(x).compareTo(toBigInteger(y)) >= 0)))
        )

        final public Number negate(Number x)
        (§
            (§ return (§ expr BigInt.fromBigInteger(toBigInteger(x).negate())))
        )

        public Number inc(Number x)
        (§
            BigInteger bx = toBigInteger(x)
            (§ return (§ expr BigInt.fromBigInteger(bx.add(BigInteger.ONE))))
        )

        public Number dec(Number x)
        (§
            BigInteger bx = toBigInteger(x)
            (§ return (§ expr BigInt.fromBigInteger(bx.subtract(BigInteger.ONE))))
        )
    )

    final static class BigDecimalOps extends OpsP
    (§
        final static Var MATH_CONTEXT = RT.MATH_CONTEXT

        public Ops combine(Ops y)
        (§
            (§ return (§ expr y.opsWith(this)))
        )

        final public Ops opsWith(LongOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(DoubleOps x)
        (§
            (§ return (§ expr DOUBLE_OPS))
        )

        final public Ops opsWith(RatioOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(BigIntOps x)
        (§
            (§ return (§ expr this))
        )

        final public Ops opsWith(BigDecimalOps x)
        (§
            (§ return (§ expr this))
        )

        public boolean isZero(Number x)
        (§
            BigDecimal bx = (BigDecimal) x
            (§ return (§ expr (bx.signum() == 0)))
        )

        public boolean isPos(Number x)
        (§
            BigDecimal bx = (BigDecimal) x
            (§ return (§ expr (bx.signum() > 0)))
        )

        public boolean isNeg(Number x)
        (§
            BigDecimal bx = (BigDecimal) x
            (§ return (§ expr (bx.signum() < 0)))
        )

        final public Number add(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).add(toBigDecimal(y)) :or toBigDecimal(x).add(toBigDecimal(y), mc)))
        )

        final public Number multiply(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).multiply(toBigDecimal(y)) :or toBigDecimal(x).multiply(toBigDecimal(y), mc)))
        )

        public Number divide(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).divide(toBigDecimal(y)) :or toBigDecimal(x).divide(toBigDecimal(y), mc)))
        )

        public Number quotient(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).divideToIntegralValue(toBigDecimal(y)) :or toBigDecimal(x).divideToIntegralValue(toBigDecimal(y), mc)))
        )

        public Number remainder(Number x, Number y)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            (§ return (§ expr (mc == nil) ? toBigDecimal(x).remainder(toBigDecimal(y)) :or toBigDecimal(x).remainder(toBigDecimal(y), mc)))
        )

        public boolean equiv(Number x, Number y)
        (§
            (§ return (§ expr (toBigDecimal(x).compareTo(toBigDecimal(y)) == 0)))
        )

        public boolean lt(Number x, Number y)
        (§
            (§ return (§ expr (toBigDecimal(x).compareTo(toBigDecimal(y)) < 0)))
        )

        public boolean lte(Number x, Number y)
        (§
            (§ return (§ expr (toBigDecimal(x).compareTo(toBigDecimal(y)) <= 0)))
        )

        public boolean gte(Number x, Number y)
        (§
            (§ return (§ expr (toBigDecimal(x).compareTo(toBigDecimal(y)) >= 0)))
        )

        final public Number negate(Number x)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            (§ return (§ expr (mc == nil) ? ((BigDecimal) x).negate() :or ((BigDecimal) x).negate(mc)))
        )

        public Number inc(Number x)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            BigDecimal bx = (BigDecimal) x
            (§ return (§ expr (mc == nil) ? bx.add(BigDecimal.ONE) :or bx.add(BigDecimal.ONE, mc)))
        )

        public Number dec(Number x)
        (§
            MathContext mc = (MathContext) MATH_CONTEXT.deref()
            BigDecimal bx = (BigDecimal) x
            (§ return (§ expr (mc == nil) ? bx.subtract(BigDecimal.ONE) :or bx.subtract(BigDecimal.ONE, mc)))
        )
    )

    static final LongOps LONG_OPS = new LongOps()
    static final DoubleOps DOUBLE_OPS = new DoubleOps()
    static final RatioOps RATIO_OPS = new RatioOps()
    static final BigIntOps BIGINT_OPS = new BigIntOps()
    static final BigDecimalOps BIGDECIMAL_OPS = new BigDecimalOps()

    static public enum Category
    (§
        INTEGER, FLOATING, DECIMAL, RATIO
    )

    static Ops ops(Object x)
    (§
        Class xc = x.getClass()

        if (xc == Long.class)
        (§
            (§ return (§ expr LONG_OPS))
        )
        else if (xc == Double.class)
        (§
            (§ return (§ expr DOUBLE_OPS))
        )
        else if (xc == Integer.class)
        (§
            (§ return (§ expr LONG_OPS))
        )
        else if (xc == Float.class)
        (§
            (§ return (§ expr DOUBLE_OPS))
        )
        else if (xc == BigInt.class)
        (§
            (§ return (§ expr BIGINT_OPS))
        )
        else if (xc == BigInteger.class)
        (§
            (§ return (§ expr BIGINT_OPS))
        )
        else if (xc == Ratio.class)
        (§
            (§ return (§ expr RATIO_OPS))
        )
        else if (xc == BigDecimal.class)
        (§
            (§ return (§ expr BIGDECIMAL_OPS))
        )
        else
        (§
            (§ return (§ expr LONG_OPS))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static int hasheqFrom(Number x, Class xc)
    (§
        if (xc == Integer.class || xc == Short.class || xc == Byte.class || (xc == BigInteger.class && lte(x, Long.MAX_VALUE) && gte(x, Long.MIN_VALUE)))
        (§
            long lpart = x.longValue()
            (§ return (§ expr Murmur3.hashLong(lpart)))
        )
        if (xc == BigDecimal.class)
        (§
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode.  Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            if (isZero(x))
            (§
                (§ return (§ expr BigDecimal.ZERO.hashCode()))
            )
            else
            (§
                (§ return (§ expr ((BigDecimal) x).stripTrailingZeros().hashCode()))
            )
        )
        if (xc == Float.class && x.equals((§ float -0.0)))
        (§
            (§ return (§ expr 0)) ;; match 0.0f
        )
        (§ return (§ expr x.hashCode()))
    )

    (§ anno @WarnBoxedMath(false))
    static int hasheq(Number x)
    (§
        Class xc = x.getClass()

        if (xc == Long.class)
        (§
            long lpart = x.longValue()
            (§ return (§ expr Murmur3.hashLong(lpart)))
        )
        if (xc == Double.class)
        (§
            if (x.equals(-0.0))
            (§
                (§ return (§ expr 0)) ;; match 0.0
            )
            (§ return (§ expr x.hashCode()))
        )
        (§ return (§ expr hasheqFrom(x, xc)))
    )

    static Category category(Object x)
    (§
        Class xc = x.getClass()

        if (xc == Integer.class)
        (§
            (§ return (§ expr Category.INTEGER))
        )
        else if (xc == Double.class)
        (§
            (§ return (§ expr Category.FLOATING))
        )
        else if (xc == Long.class)
        (§
            (§ return (§ expr Category.INTEGER))
        )
        else if (xc == Float.class)
        (§
            (§ return (§ expr Category.FLOATING))
        )
        else if (xc == BigInt.class)
        (§
            (§ return (§ expr Category.INTEGER))
        )
        else if (xc == Ratio.class)
        (§
            (§ return (§ expr Category.RATIO))
        )
        else if (xc == BigDecimal.class)
        (§
            (§ return (§ expr Category.DECIMAL))
        )
        else
        (§
            (§ return (§ expr Category.INTEGER))
        )
    )

    static long bitOpsCast(Object x)
    (§
        Class xc = x.getClass()

        if (xc == Long.class || xc == Integer.class || xc == Short.class || xc == Byte.class)
        (§
            (§ return (§ expr RT.longCast(x)))
        )
        ;; no bignums, no decimals
        throw new IllegalArgumentException("bit operation not supported for: " + xc)
    )

    (§ anno @WarnBoxedMath(false))
    static public float[] float_array(int size, Object init)
    (§
        float[] ret = new float[size]
        if (init instanceof Number)
        (§
            float f = ((Number) init).floatValue()
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = f
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).floatValue()
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    static public float[] float_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new float[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            float[] ret = new float[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).floatValue()
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public double[] double_array(int size, Object init)
    (§
        double[] ret = new double[size]
        if (init instanceof Number)
        (§
            double f = ((Number) init).doubleValue()
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = f
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).doubleValue()
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    static public double[] double_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new double[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            double[] ret = new double[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).doubleValue()
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public int[] int_array(int size, Object init)
    (§
        int[] ret = new int[size]
        if (init instanceof Number)
        (§
            int f = ((Number) init).intValue()
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = f
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).intValue()
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    static public int[] int_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new int[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            int[] ret = new int[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).intValue()
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public long[] long_array(int size, Object init)
    (§
        long[] ret = new long[size]
        if (init instanceof Number)
        (§
            long f = ((Number) init).longValue()
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = f
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).longValue()
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    static public long[] long_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new long[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            long[] ret = new long[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).longValue()
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public short[] short_array(int size, Object init)
    (§
        short[] ret = new short[size]
        if (init instanceof Short)
        (§
            short s = (Short) init
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = s
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).shortValue()
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    static public short[] short_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new short[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            short[] ret = new short[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).shortValue()
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public char[] char_array(int size, Object init)
    (§
        char[] ret = new char[size]
        if (init instanceof Character)
        (§
            char c = (Character) init
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = c
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = (Character) s.first()
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    static public char[] char_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new char[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            char[] ret = new char[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = (Character) s.first()
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public byte[] byte_array(int size, Object init)
    (§
        byte[] ret = new byte[size]
        if (init instanceof Byte)
        (§
            byte b = (Byte) init
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = b
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).byteValue()
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    static public byte[] byte_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new byte[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            byte[] ret = new byte[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = ((Number) s.first()).byteValue()
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public boolean[] boolean_array(int size, Object init)
    (§
        boolean[] ret = new boolean[size]
        if (init instanceof Boolean)
        (§
            boolean b = (Boolean) init
            for (int i = 0 i < ret.length i++)
            (§
                ret[i] = b
            )
        )
        else
        (§
            ISeq s = RT.seq(init)
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = (Boolean)s.first()
            )
        )
        (§ return (§ expr ret))
    )

    (§ anno @WarnBoxedMath(false))
    static public boolean[] boolean_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new boolean[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            boolean[] ret = new boolean[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = (Boolean)s.first()
            )
            (§ return (§ expr ret))
        )
    )

    (§ anno @WarnBoxedMath(false))
    static public boolean[] booleans(Object array)
    (§
        (§ return (§ expr (boolean[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    static public byte[] bytes(Object array)
    (§
        (§ return (§ expr (byte[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    static public char[] chars(Object array)
    (§
        (§ return (§ expr (char[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    static public short[] shorts(Object array)
    (§
        (§ return (§ expr (short[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    static public float[] floats(Object array)
    (§
        (§ return (§ expr (float[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    static public double[] doubles(Object array)
    (§
        (§ return (§ expr (double[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    static public int[] ints(Object array)
    (§
        (§ return (§ expr (int[]) array))
    )

    (§ anno @WarnBoxedMath(false))
    static public long[] longs(Object array)
    (§
        (§ return (§ expr (long[]) array))
    )

    static public Number num(Object x)
    (§
        (§ return (§ expr (Number) x))
    )

    static public Number num(float x)
    (§
        (§ return (§ expr Float.valueOf(x)))
    )

    static public Number num(double x)
    (§
        (§ return (§ expr Double.valueOf(x)))
    )

    static public double add(double x, double y)
    (§
        (§ return (§ expr x + y))
    )

    static public double addP(double x, double y)
    (§
        (§ return (§ expr x + y))
    )

    static public double minus(double x, double y)
    (§
        (§ return (§ expr x - y))
    )

    static public double minusP(double x, double y)
    (§
        (§ return (§ expr x - y))
    )

    static public double minus(double x)
    (§
        (§ return (§ expr -x))
    )

    static public double minusP(double x)
    (§
        (§ return (§ expr -x))
    )

    static public double inc(double x)
    (§
        (§ return (§ expr x + 1))
    )

    static public double incP(double x)
    (§
        (§ return (§ expr x + 1))
    )

    static public double dec(double x)
    (§
        (§ return (§ expr x - 1))
    )

    static public double decP(double x)
    (§
        (§ return (§ expr x - 1))
    )

    static public double multiply(double x, double y)
    (§
        (§ return (§ expr x * y))
    )

    static public double multiplyP(double x, double y)
    (§
        (§ return (§ expr x * y))
    )

    static public double divide(double x, double y)
    (§
        (§ return (§ expr x / y))
    )

    static public boolean equiv(double x, double y)
    (§
        (§ return (§ expr (x == y)))
    )

    static public boolean lt(double x, double y)
    (§
        (§ return (§ expr (x < y)))
    )

    static public boolean lte(double x, double y)
    (§
        (§ return (§ expr (x <= y)))
    )

    static public boolean gt(double x, double y)
    (§
        (§ return (§ expr (x > y)))
    )

    static public boolean gte(double x, double y)
    (§
        (§ return (§ expr (x >= y)))
    )

    static public boolean isPos(double x)
    (§
        (§ return (§ expr (x > 0)))
    )

    static public boolean isNeg(double x)
    (§
        (§ return (§ expr (x < 0)))
    )

    static public boolean isZero(double x)
    (§
        (§ return (§ expr (x == 0)))
    )

    static int throwIntOverflow()
    (§
        throw new ArithmeticException("integer overflow")
    )

    static public int unchecked_int_add(int x, int y)
    (§
        (§ return (§ expr x + y))
    )

    static public int unchecked_int_subtract(int x, int y)
    (§
        (§ return (§ expr x - y))
    )

    static public int unchecked_int_negate(int x)
    (§
        (§ return (§ expr -x))
    )

    static public int unchecked_int_inc(int x)
    (§
        (§ return (§ expr x + 1))
    )

    static public int unchecked_int_dec(int x)
    (§
        (§ return (§ expr x - 1))
    )

    static public int unchecked_int_multiply(int x, int y)
    (§
        (§ return (§ expr x * y))
    )

    static public long not(Object x)
    (§
        (§ return (§ expr not(bitOpsCast(x))))
    )

    static public long not(long x)
    (§
        (§ return (§ expr ~x))
    )

    static public long and(Object x, Object y)
    (§
        (§ return (§ expr and(bitOpsCast(x), bitOpsCast(y))))
    )

    static public long and(Object x, long y)
    (§
        (§ return (§ expr and(bitOpsCast(x), y)))
    )

    static public long and(long x, Object y)
    (§
        (§ return (§ expr and(x, bitOpsCast(y))))
    )

    static public long and(long x, long y)
    (§
        (§ return (§ expr x & y))
    )

    static public long or(Object x, Object y)
    (§
        (§ return (§ expr or(bitOpsCast(x), bitOpsCast(y))))
    )

    static public long or(Object x, long y)
    (§
        (§ return (§ expr or(bitOpsCast(x), y)))
    )

    static public long or(long x, Object y)
    (§
        (§ return (§ expr or(x, bitOpsCast(y))))
    )

    static public long or(long x, long y)
    (§
        (§ return (§ expr x | y))
    )

    static public long xor(Object x, Object y)
    (§
        (§ return (§ expr xor(bitOpsCast(x), bitOpsCast(y))))
    )

    static public long xor(Object x, long y)
    (§
        (§ return (§ expr xor(bitOpsCast(x), y)))
    )

    static public long xor(long x, Object y)
    (§
        (§ return (§ expr xor(x, bitOpsCast(y))))
    )

    static public long xor(long x, long y)
    (§
        (§ return (§ expr x :xor y))
    )

    static public long andNot(Object x, Object y)
    (§
        (§ return (§ expr andNot(bitOpsCast(x), bitOpsCast(y))))
    )

    static public long andNot(Object x, long y)
    (§
        (§ return (§ expr andNot(bitOpsCast(x), y)))
    )

    static public long andNot(long x, Object y)
    (§
        (§ return (§ expr andNot(x, bitOpsCast(y))))
    )

    static public long andNot(long x, long y)
    (§
        (§ return (§ expr x & ~y))
    )

    static public long clearBit(Object x, Object y)
    (§
        (§ return (§ expr clearBit(bitOpsCast(x), bitOpsCast(y))))
    )

    static public long clearBit(Object x, long y)
    (§
        (§ return (§ expr clearBit(bitOpsCast(x), y)))
    )

    static public long clearBit(long x, Object y)
    (§
        (§ return (§ expr clearBit(x, bitOpsCast(y))))
    )

    static public long clearBit(long x, long n)
    (§
        (§ return (§ expr x & ~(1 << n)))
    )

    static public long setBit(Object x, Object y)
    (§
        (§ return (§ expr setBit(bitOpsCast(x), bitOpsCast(y))))
    )

    static public long setBit(Object x, long y)
    (§
        (§ return (§ expr setBit(bitOpsCast(x), y)))
    )

    static public long setBit(long x, Object y)
    (§
        (§ return (§ expr setBit(x, bitOpsCast(y))))
    )

    static public long setBit(long x, long n)
    (§
        (§ return (§ expr x | (1 << n)))
    )

    static public long flipBit(Object x, Object y)
    (§
        (§ return (§ expr flipBit(bitOpsCast(x), bitOpsCast(y))))
    )

    static public long flipBit(Object x, long y)
    (§
        (§ return (§ expr flipBit(bitOpsCast(x), y)))
    )

    static public long flipBit(long x, Object y)
    (§
        (§ return (§ expr flipBit(x, bitOpsCast(y))))
    )

    static public long flipBit(long x, long n)
    (§
        (§ return (§ expr x :xor (1 << n)))
    )

    static public boolean testBit(Object x, Object y)
    (§
        (§ return (§ expr testBit(bitOpsCast(x), bitOpsCast(y))))
    )

    static public boolean testBit(Object x, long y)
    (§
        (§ return (§ expr testBit(bitOpsCast(x), y)))
    )

    static public boolean testBit(long x, Object y)
    (§
        (§ return (§ expr testBit(x, bitOpsCast(y))))
    )

    static public boolean testBit(long x, long n)
    (§
        (§ return (§ expr ((x & (1 << n)) != 0)))
    )

    static public int unchecked_int_divide(int x, int y)
    (§
        (§ return (§ expr x / y))
    )

    static public int unchecked_int_remainder(int x, int y)
    (§
        (§ return (§ expr x % y))
    )

    static public Number num(long x)
    (§
        (§ return (§ expr Long.valueOf(x)))
    )

    static public long unchecked_add(long x, long y) (§ return (§ expr x + y ))
    static public long unchecked_minus(long x, long y) (§ return (§ expr x - y ))
    static public long unchecked_multiply(long x, long y) (§ return (§ expr x * y ))
    static public long unchecked_minus(long x) (§ return (§ expr -x ))
    static public long unchecked_inc(long x) (§ return (§ expr x + 1 ))
    static public long unchecked_dec(long x) (§ return (§ expr x - 1 ))

    static public Number unchecked_add(Object x, Object y) (§ return (§ expr add(x, y) ))
    static public Number unchecked_minus(Object x, Object y) (§ return (§ expr minus(x, y) ))
    static public Number unchecked_multiply(Object x, Object y) (§ return (§ expr multiply(x, y) ))
    static public Number unchecked_minus(Object x) (§ return (§ expr minus(x) ))
    static public Number unchecked_inc(Object x) (§ return (§ expr inc(x) ))
    static public Number unchecked_dec(Object x) (§ return (§ expr dec(x) ))

    static public double unchecked_add(double x, double y) (§ return (§ expr add(x, y) ))
    static public double unchecked_minus(double x, double y) (§ return (§ expr minus(x, y) ))
    static public double unchecked_multiply(double x, double y) (§ return (§ expr multiply(x, y) ))
    static public double unchecked_minus(double x) (§ return (§ expr minus(x) ))
    static public double unchecked_inc(double x) (§ return (§ expr inc(x) ))
    static public double unchecked_dec(double x) (§ return (§ expr dec(x) ))

    static public double unchecked_add(double x, Object y) (§ return (§ expr add(x, y) ))
    static public double unchecked_minus(double x, Object y) (§ return (§ expr minus(x, y) ))
    static public double unchecked_multiply(double x, Object y) (§ return (§ expr multiply(x, y) ))
    static public double unchecked_add(Object x, double y) (§ return (§ expr add(x, y) ))
    static public double unchecked_minus(Object x, double y) (§ return (§ expr minus(x, y) ))
    static public double unchecked_multiply(Object x, double y) (§ return (§ expr multiply(x, y) ))

    static public double unchecked_add(double x, long y) (§ return (§ expr add(x, y) ))
    static public double unchecked_minus(double x, long y) (§ return (§ expr minus(x, y) ))
    static public double unchecked_multiply(double x, long y) (§ return (§ expr multiply(x, y) ))
    static public double unchecked_add(long x, double y) (§ return (§ expr add(x, y) ))
    static public double unchecked_minus(long x, double y) (§ return (§ expr minus(x, y) ))
    static public double unchecked_multiply(long x, double y) (§ return (§ expr multiply(x, y) ))

    static public Number unchecked_add(long x, Object y) (§ return (§ expr add(x, y) ))
    static public Number unchecked_minus(long x, Object y) (§ return (§ expr minus(x, y) ))
    static public Number unchecked_multiply(long x, Object y) (§ return (§ expr multiply(x, y) ))
    static public Number unchecked_add(Object x, long y) (§ return (§ expr add(x, y) ))
    static public Number unchecked_minus(Object x, long y) (§ return (§ expr minus(x, y) ))
    static public Number unchecked_multiply(Object x, long y) (§ return (§ expr multiply(x, y) ))

    static public Number quotient(double x, Object y) (§ return (§ expr quotient((Object)x, y) ))
    static public Number quotient(Object x, double y) (§ return (§ expr quotient(x, (Object)y) ))
    static public Number quotient(long x, Object y) (§ return (§ expr quotient((Object)x, y) ))
    static public Number quotient(Object x, long y) (§ return (§ expr quotient(x, (Object)y) ))
    static public double quotient(double x, long y) (§ return (§ expr quotient(x, (double)y) ))
    static public double quotient(long x, double y) (§ return (§ expr quotient((double)x, y) ))

    static public Number remainder(double x, Object y) (§ return (§ expr remainder((Object)x, y) ))
    static public Number remainder(Object x, double y) (§ return (§ expr remainder(x, (Object)y) ))
    static public Number remainder(long x, Object y) (§ return (§ expr remainder((Object)x, y) ))
    static public Number remainder(Object x, long y) (§ return (§ expr remainder(x, (Object)y) ))
    static public double remainder(double x, long y) (§ return (§ expr remainder(x, (double)y) ))
    static public double remainder(long x, double y) (§ return (§ expr remainder((double)x, y) ))

    static public long add(long x, long y)
    (§
        long ret = x + y
        if ((ret :xor x) < 0 && (ret :xor y) < 0)
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr ret))
    )

    static public Number addP(long x, long y)
    (§
        long ret = x + y
        if ((ret :xor x) < 0 && (ret :xor y) < 0)
        (§
            (§ return (§ expr addP((Number)x, (Number)y)))
        )
        (§ return (§ expr num(ret)))
    )

    static public long minus(long x, long y)
    (§
        long ret = x - y
        if (((ret :xor x) < 0 && (ret :xor ~y) < 0))
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr ret))
    )

    static public Number minusP(long x, long y)
    (§
        long ret = x - y
        if (((ret :xor x) < 0 && (ret :xor ~y) < 0))
        (§
            (§ return (§ expr minusP((Number)x, (Number)y)))
        )
        (§ return (§ expr num(ret)))
    )

    static public long minus(long x)
    (§
        if (x == Long.MIN_VALUE)
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr -x))
    )

    static public Number minusP(long x)
    (§
        if (x == Long.MIN_VALUE)
        (§
            (§ return (§ expr BigInt.fromBigInteger(BigInteger.valueOf(x).negate())))
        )
        (§ return (§ expr num(-x)))
    )

    static public long inc(long x)
    (§
        if (x == Long.MAX_VALUE)
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr x + 1))
    )

    static public Number incP(long x)
    (§
        if (x == Long.MAX_VALUE)
        (§
            (§ return (§ expr BIGINT_OPS.inc(x)))
        )
        (§ return (§ expr num(x + 1)))
    )

    static public long dec(long x)
    (§
        if (x == Long.MIN_VALUE)
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr x - 1))
    )

    static public Number decP(long x)
    (§
        if (x == Long.MIN_VALUE)
        (§
            (§ return (§ expr BIGINT_OPS.dec(x)))
        )
        (§ return (§ expr num(x - 1)))
    )

    static public long multiply(long x, long y)
    (§
        if (x == Long.MIN_VALUE && y < 0)
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        long ret = x * y
        if (y != 0 && ret/y != x)
        (§
            (§ return (§ expr throwIntOverflow()))
        )
        (§ return (§ expr ret))
    )

    static public Number multiplyP(long x, long y)
    (§
        if (x == Long.MIN_VALUE && y < 0)
        (§
            (§ return (§ expr multiplyP((Number)x, (Number)y)))
        )
        long ret = x * y
        if (y != 0 && ret/y != x)
        (§
            (§ return (§ expr multiplyP((Number)x, (Number)y)))
        )
        (§ return (§ expr num(ret)))
    )

    static public long quotient(long x, long y)
    (§
        (§ return (§ expr x / y))
    )

    static public long remainder(long x, long y)
    (§
        (§ return (§ expr x % y))
    )

    static public boolean equiv(long x, long y)
    (§
        (§ return (§ expr (x == y)))
    )

    static public boolean lt(long x, long y)
    (§
        (§ return (§ expr (x < y)))
    )

    static public boolean lte(long x, long y)
    (§
        (§ return (§ expr (x <= y)))
    )

    static public boolean gt(long x, long y)
    (§
        (§ return (§ expr (x > y)))
    )

    static public boolean gte(long x, long y)
    (§
        (§ return (§ expr (x >= y)))
    )

    static public boolean isPos(long x)
    (§
        (§ return (§ expr (x > 0)))
    )

    static public boolean isNeg(long x)
    (§
        (§ return (§ expr (x < 0)))
    )

    static public boolean isZero(long x)
    (§
        (§ return (§ expr (x == 0)))
    )

    ;; overload resolution

    static public Number add(long x, Object y)
    (§
        (§ return (§ expr add((Object)x, y)))
    )

    static public Number add(Object x, long y)
    (§
        (§ return (§ expr add(x, (Object)y)))
    )

    static public Number addP(long x, Object y)
    (§
        (§ return (§ expr addP((Object)x, y)))
    )

    static public Number addP(Object x, long y)
    (§
        (§ return (§ expr addP(x, (Object)y)))
    )

    static public double add(double x, Object y)
    (§
        (§ return (§ expr add(x, ((Number)y).doubleValue())))
    )

    static public double add(Object x, double y)
    (§
        (§ return (§ expr add(((Number)x).doubleValue(), y)))
    )

    static public double add(double x, long y)
    (§
        (§ return (§ expr x + y))
    )

    static public double add(long x, double y)
    (§
        (§ return (§ expr x + y))
    )

    static public double addP(double x, Object y)
    (§
        (§ return (§ expr addP(x, ((Number)y).doubleValue())))
    )

    static public double addP(Object x, double y)
    (§
        (§ return (§ expr addP(((Number)x).doubleValue(), y)))
    )

    static public double addP(double x, long y)
    (§
        (§ return (§ expr x + y))
    )

    static public double addP(long x, double y)
    (§
        (§ return (§ expr x + y))
    )

    static public Number minus(long x, Object y)
    (§
        (§ return (§ expr minus((Object)x, y)))
    )

    static public Number minus(Object x, long y)
    (§
        (§ return (§ expr minus(x, (Object)y)))
    )

    static public Number minusP(long x, Object y)
    (§
        (§ return (§ expr minusP((Object)x, y)))
    )

    static public Number minusP(Object x, long y)
    (§
        (§ return (§ expr minusP(x, (Object)y)))
    )

    static public double minus(double x, Object y)
    (§
        (§ return (§ expr minus(x, ((Number)y).doubleValue())))
    )

    static public double minus(Object x, double y)
    (§
        (§ return (§ expr minus(((Number)x).doubleValue(), y)))
    )

    static public double minus(double x, long y)
    (§
        (§ return (§ expr x - y))
    )

    static public double minus(long x, double y)
    (§
        (§ return (§ expr x - y))
    )

    static public double minusP(double x, Object y)
    (§
        (§ return (§ expr minus(x, ((Number)y).doubleValue())))
    )

    static public double minusP(Object x, double y)
    (§
        (§ return (§ expr minus(((Number)x).doubleValue(), y)))
    )

    static public double minusP(double x, long y)
    (§
        (§ return (§ expr x - y))
    )

    static public double minusP(long x, double y)
    (§
        (§ return (§ expr x - y))
    )

    static public Number multiply(long x, Object y)
    (§
        (§ return (§ expr multiply((Object)x, y)))
    )

    static public Number multiply(Object x, long y)
    (§
        (§ return (§ expr multiply(x, (Object)y)))
    )

    static public Number multiplyP(long x, Object y)
    (§
        (§ return (§ expr multiplyP((Object)x, y)))
    )

    static public Number multiplyP(Object x, long y)
    (§
        (§ return (§ expr multiplyP(x, (Object)y)))
    )

    static public double multiply(double x, Object y)
    (§
        (§ return (§ expr multiply(x, ((Number)y).doubleValue())))
    )

    static public double multiply(Object x, double y)
    (§
        (§ return (§ expr multiply(((Number)x).doubleValue(), y)))
    )

    static public double multiply(double x, long y)
    (§
        (§ return (§ expr x * y))
    )

    static public double multiply(long x, double y)
    (§
        (§ return (§ expr x * y))
    )

    static public double multiplyP(double x, Object y)
    (§
        (§ return (§ expr multiplyP(x, ((Number)y).doubleValue())))
    )

    static public double multiplyP(Object x, double y)
    (§
        (§ return (§ expr multiplyP(((Number)x).doubleValue(), y)))
    )

    static public double multiplyP(double x, long y)
    (§
        (§ return (§ expr x * y))
    )

    static public double multiplyP(long x, double y)
    (§
        (§ return (§ expr x * y))
    )

    static public Number divide(long x, Object y)
    (§
        (§ return (§ expr divide((Object)x, y)))
    )

    static public Number divide(Object x, long y)
    (§
        (§ return (§ expr divide(x, (Object)y)))
    )

    static public double divide(double x, Object y)
    (§
        (§ return (§ expr x / ((Number)y).doubleValue()))
    )

    static public double divide(Object x, double y)
    (§
        (§ return (§ expr ((Number)x).doubleValue() / y))
    )

    static public double divide(double x, long y)
    (§
        (§ return (§ expr x / y))
    )

    static public double divide(long x, double y)
    (§
        (§ return (§ expr x / y))
    )

    static public Number divide(long x, long y)
    (§
        (§ return (§ expr divide((Number)x, (Number)y)))
    )

    static public boolean lt(long x, Object y)
    (§
        (§ return (§ expr lt((Object)x, y)))
    )

    static public boolean lt(Object x, long y)
    (§
        (§ return (§ expr lt(x, (Object)y)))
    )

    static public boolean lt(double x, Object y)
    (§
        (§ return (§ expr (x < ((Number)y).doubleValue())))
    )

    static public boolean lt(Object x, double y)
    (§
        (§ return (§ expr (((Number)x).doubleValue() < y)))
    )

    static public boolean lt(double x, long y)
    (§
        (§ return (§ expr (x < y)))
    )

    static public boolean lt(long x, double y)
    (§
        (§ return (§ expr (x < y)))
    )

    static public boolean lte(long x, Object y)
    (§
        (§ return (§ expr lte((Object)x, y)))
    )

    static public boolean lte(Object x, long y)
    (§
        (§ return (§ expr lte(x, (Object)y)))
    )

    static public boolean lte(double x, Object y)
    (§
        (§ return (§ expr (x <= ((Number)y).doubleValue())))
    )

    static public boolean lte(Object x, double y)
    (§
        (§ return (§ expr (((Number)x).doubleValue() <= y)))
    )

    static public boolean lte(double x, long y)
    (§
        (§ return (§ expr (x <= y)))
    )

    static public boolean lte(long x, double y)
    (§
        (§ return (§ expr (x <= y)))
    )

    static public boolean gt(long x, Object y)
    (§
        (§ return (§ expr gt((Object)x, y)))
    )

    static public boolean gt(Object x, long y)
    (§
        (§ return (§ expr gt(x, (Object)y)))
    )

    static public boolean gt(double x, Object y)
    (§
        (§ return (§ expr (x > ((Number)y).doubleValue())))
    )

    static public boolean gt(Object x, double y)
    (§
        (§ return (§ expr (((Number)x).doubleValue() > y)))
    )

    static public boolean gt(double x, long y)
    (§
        (§ return (§ expr (x > y)))
    )

    static public boolean gt(long x, double y)
    (§
        (§ return (§ expr (x > y)))
    )

    static public boolean gte(long x, Object y)
    (§
        (§ return (§ expr gte((Object)x, y)))
    )

    static public boolean gte(Object x, long y)
    (§
        (§ return (§ expr gte(x, (Object)y)))
    )

    static public boolean gte(double x, Object y)
    (§
        (§ return (§ expr (x >= ((Number)y).doubleValue())))
    )

    static public boolean gte(Object x, double y)
    (§
        (§ return (§ expr (((Number)x).doubleValue() >= y)))
    )

    static public boolean gte(double x, long y)
    (§
        (§ return (§ expr (x >= y)))
    )

    static public boolean gte(long x, double y)
    (§
        (§ return (§ expr (x >= y)))
    )

    static public boolean equiv(long x, Object y)
    (§
        (§ return (§ expr equiv((Object)x, y)))
    )

    static public boolean equiv(Object x, long y)
    (§
        (§ return (§ expr equiv(x, (Object)y)))
    )

    static public boolean equiv(double x, Object y)
    (§
        (§ return (§ expr (x == ((Number)y).doubleValue())))
    )

    static public boolean equiv(Object x, double y)
    (§
        (§ return (§ expr (((Number)x).doubleValue() == y)))
    )

    static public boolean equiv(double x, long y)
    (§
        (§ return (§ expr (x == y)))
    )

    static public boolean equiv(long x, double y)
    (§
        (§ return (§ expr (x == y)))
    )

    static boolean isNaN(Object x)
    (§
        (§ return (§ expr (x instanceof Double) && ((Double)x).isNaN() || (x instanceof Float) && ((Float)x).isNaN()))
    )

    static public double max(double x, double y)
    (§
        (§ return (§ expr Math.max(x, y)))
    )

    static public Object max(double x, long y)
    (§
        if (Double.isNaN(x))
        (§
            (§ return (§ expr x))
        )
        if (x > y)
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object max(double x, Object y)
    (§
        if (Double.isNaN(x))
        (§
            (§ return (§ expr x))
        )
        else if (isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (x > ((Number)y).doubleValue())
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object max(long x, double y)
    (§
        if (Double.isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (x > y)
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public long max(long x, long y)
    (§
        if (x > y)
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object max(long x, Object y)
    (§
        if (isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (gt(x, y))
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object max(Object x, long y)
    (§
        if (isNaN(x))
        (§
            (§ return (§ expr x))
        )
        if (gt(x, y))
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object max(Object x, double y)
    (§
        if (isNaN(x))
        (§
            (§ return (§ expr x))
        )
        else if (Double.isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (((Number)x).doubleValue() > y)
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object max(Object x, Object y)
    (§
        if (isNaN(x))
        (§
            (§ return (§ expr x))
        )
        else if (isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (gt(x, y))
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public double min(double x, double y)
    (§
        (§ return (§ expr Math.min(x, y)))
    )

    static public Object min(double x, long y)
    (§
        if (Double.isNaN(x))
        (§
            (§ return (§ expr x))
        )
        if (x < y)
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object min(double x, Object y)
    (§
        if (Double.isNaN(x))
        (§
            (§ return (§ expr x))
        )
        else if (isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (x < ((Number)y).doubleValue())
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object min(long x, double y)
    (§
        if (Double.isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (x < y)
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public long min(long x, long y)
    (§
        if (x < y)
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object min(long x, Object y)
    (§
        if (isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (lt(x, y))
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object min(Object x, long y)
    (§
        if (isNaN(x))
        (§
            (§ return (§ expr x))
        )
        if (lt(x, y))
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object min(Object x, double y)
    (§
        if (isNaN(x))
        (§
            (§ return (§ expr x))
        )
        else if (Double.isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (((Number)x).doubleValue() < y)
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )

    static public Object min(Object x, Object y)
    (§
        if (isNaN(x))
        (§
            (§ return (§ expr x))
        )
        else if (isNaN(y))
        (§
            (§ return (§ expr y))
        )
        if (lt(x, y))
        (§
            (§ return (§ expr x))
        )
        else
        (§
            (§ return (§ expr y))
        )
    )
)
)

(java-ns cloiure.lang.Obj

(§ import java.io.Serializable)

(§ class public abstract class Obj implements IObj, Serializable)
(§
    final IPersistentMap _meta

    public Obj(IPersistentMap meta)
    (§
        this._meta = meta
    )

    public Obj()
    (§
        _meta = nil
    )

    final public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )

    abstract public Obj withMeta(IPersistentMap meta)
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.io.Serializable)
(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(§ class public class PersistentArrayMap extends APersistentMap implements IObj, IEditableCollection, IMapIterable, IKVReduce)
(§
    final Object[] array
    static final int HASHTABLE_THRESHOLD = 16

    public static final PersistentArrayMap EMPTY = new PersistentArrayMap()
    private final IPersistentMap _meta

    static public IPersistentMap create(Map other)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (Object o :in other.entrySet())
        (§
            Map.Entry e = (Entry) o
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        (§ return (§ expr ret.persistent()))
    )

    protected PersistentArrayMap()
    (§
        this.array = new Object[] (§)
        this._meta = nil
    )

    public PersistentArrayMap withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new PersistentArrayMap(meta, array)))
    )

    PersistentArrayMap create(Object... init)
    (§
        (§ return (§ expr new PersistentArrayMap(meta(), init)))
    )

    IPersistentMap createHT(Object[] init)
    (§
        (§ return (§ expr PersistentHashMap.create(meta(), init)))
    )

    static public PersistentArrayMap createWithCheck(Object[] init)
    (§
        for (int i = 0 i < init.length i += 2)
        (§
            for (int j = i + 2 j < init.length j += 2)
            (§
                if (equalKey(init[i], init[j]))
                (§
                    throw new IllegalArgumentException("Duplicate key: " + init[i])
                )
            )
        )
        (§ return (§ expr new PersistentArrayMap(init)))
    )

    static public PersistentArrayMap createAsIfByAssoc(Object[] init)
    (§
        if ((init.length & 1) == 1)
        (§
            throw new IllegalArgumentException(String.format("No value supplied for key: %s", init[init.length - 1]))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        int n = 0
        for (int i = 0 i < init.length i += 2)
        (§
            boolean duplicateKey = false
            for (int j = 0 j < i j += 2)
            (§
                if (equalKey(init[i], init[j]))
                (§
                    duplicateKey = true
                    break
                )
            )
            if (!duplicateKey)
            (§
                n += 2
            )
        )
        if (n < init.length)
        (§
            ;; Create a new shorter array with unique keys, and
            ;; the last value associated with each key.  To behave
            ;; like assoc, the first occurrence of each key must
            ;; be used, since its metadata may be different than
            ;; later equal keys.
            Object[] nodups = new Object[n]
            int m = 0
            for (int i = 0 i < init.length i += 2)
            (§
                boolean duplicateKey = false
                for (int j = 0 j < m j += 2)
                (§
                    if (equalKey(init[i], nodups[j]))
                    (§
                        duplicateKey = true
                        break
                    )
                )
                if (!duplicateKey)
                (§
                    int j
                    for (j = init.length - 2 j >= i j -= 2)
                    (§
                        if (equalKey(init[i], init[j]))
                        (§
                            break
                        )
                    )
                    nodups[m] = init[i]
                    nodups[m + 1] = init[j + 1]
                    m += 2
                )
            )
            if (m != n)
            (§
                throw new IllegalArgumentException("Internal error: m=" + m)
            )
            init = nodups
        )
        (§ return (§ expr new PersistentArrayMap(init)))
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    public PersistentArrayMap(Object[] init)
    (§
        this.array = init
        this._meta = nil
    )

    public PersistentArrayMap(IPersistentMap meta, Object[] init)
    (§
        this._meta = meta
        this.array = init
    )

    public int count()
    (§
        (§ return (§ expr array.length / 2))
    )

    public boolean containsKey(Object key)
    (§
        (§ return (§ expr (indexOf(key) >= 0)))
    )

    public IMapEntry entryAt(Object key)
    (§
        int i = indexOf(key)
        if (i >= 0)
        (§
            (§ return (§ expr (IMapEntry) MapEntry.create(array[i], array[i + 1])))
        )
        (§ return (§ expr nil))
    )

    public IPersistentMap assocEx(Object key, Object val)
    (§
        int i = indexOf(key)
        Object[] newArray
        if (i >= 0)
        (§
            throw Util.runtimeException("Key already present")
        )
        else ;; didn't have key, grow
        (§
            if (array.length > HASHTABLE_THRESHOLD)
            (§
                (§ return (§ expr createHT(array).assocEx(key, val)))
            )
            newArray = new Object[array.length + 2]
            if (array.length > 0)
            (§
                System.arraycopy(array, 0, newArray, 2, array.length)
            )
            newArray[0] = key
            newArray[1] = val
        )
        (§ return (§ expr create(newArray)))
    )

    public IPersistentMap assoc(Object key, Object val)
    (§
        int i = indexOf(key)
        Object[] newArray
        if (i >= 0) ;; already have key, same-sized replacement
        (§
            if (array[i + 1] == val) ;; no change, no op
            (§
                (§ return (§ expr this))
            )
            newArray = array.clone()
            newArray[i + 1] = val
        )
        else ;; didn't have key, grow
        (§
            if (array.length > HASHTABLE_THRESHOLD)
            (§
                (§ return (§ expr createHT(array).assoc(key, val)))
            )
            newArray = new Object[array.length + 2]
            if (array.length > 0)
            (§
                System.arraycopy(array, 0, newArray, 0, array.length)
            )
            newArray[newArray.length - 2] = key
            newArray[newArray.length - 1] = val
        )
        (§ return (§ expr create(newArray)))
    )

    public IPersistentMap without(Object key)
    (§
        int i = indexOf(key)
        if (i >= 0) ;; have key, will remove
        (§
            int newlen = array.length - 2
            if (newlen == 0)
            (§
                (§ return (§ expr empty()))
            )
            Object[] newArray = new Object[newlen]
            System.arraycopy(array, 0, newArray, 0, i)
            System.arraycopy(array, i + 2, newArray, i, newlen - i)
            (§ return (§ expr create(newArray)))
        )
        ;; don't have key, no op
        (§ return (§ expr this))
    )

    public IPersistentMap empty()
    (§
        (§ return (§ expr (IPersistentMap) EMPTY.withMeta(meta())))
    )

    final public Object valAt(Object key, Object notFound)
    (§
        int i = indexOf(key)
        if (i >= 0)
        (§
            (§ return (§ expr array[i + 1]))
        )
        (§ return (§ expr notFound))
    )

    public Object valAt(Object key)
    (§
        (§ return (§ expr valAt(key, nil)))
    )

    public int capacity()
    (§
        (§ return (§ expr count()))
    )

    private int indexOfObject(Object key)
    (§
        Util.EquivPred ep = Util.equivPred(key)
        for (int i = 0 i < array.length i += 2)
        (§
            if (ep.equiv(key, array[i]))
            (§
                (§ return (§ expr i))
            )
        )
        (§ return (§ expr -1))
    )

    private int indexOf(Object key)
    (§
        if (key instanceof Keyword)
        (§
            for (int i = 0 i < array.length i += 2)
            (§
                if (key == array[i])
                (§
                    (§ return (§ expr i))
                )
            )
            (§ return (§ expr -1))
        )
        else
        (§
            (§ return (§ expr indexOfObject(key)))
        )
    )

    static boolean equalKey(Object k1, Object k2)
    (§
        if (k1 instanceof Keyword)
        (§
            (§ return (§ expr (k1 == k2)))
        )
        (§ return (§ expr Util.equiv(k1, k2)))
    )

    public Iterator iterator()
    (§
        (§ return (§ expr new Iter(array, APersistentMap.MAKE_ENTRY)))
    )

    public Iterator keyIterator()
    (§
        (§ return (§ expr new Iter(array, APersistentMap.MAKE_KEY)))
    )

    public Iterator valIterator()
    (§
        (§ return (§ expr new Iter(array, APersistentMap.MAKE_VAL)))
    )

    public ISeq seq()
    (§
        if (array.length > 0)
        (§
            (§ return (§ expr new Seq(array, 0)))
        )
        (§ return (§ expr nil))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )

    static class Seq extends ASeq implements Counted
    (§
        final Object[] array
        final int i

        Seq(Object[] array, int i)
        (§
            this.array = array
            this.i = i
        )

        public Seq(IPersistentMap meta, Object[] array, int i)
        (§
            super(meta)
            this.array = array
            this.i = i
        )

        public Object first()
        (§
            (§ return (§ expr MapEntry.create(array[i], array[i + 1])))
        )

        public ISeq next()
        (§
            if (i + 2 < array.length)
            (§
                (§ return (§ expr new Seq(array, i + 2)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            (§ return (§ expr (array.length - i) / 2))
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new Seq(meta, array, i)))
        )
    )

    static class Iter implements Iterator
    (§
        IFn f
        Object[] array
        int i

        ;; for iterator
        Iter(Object[] array, IFn f)
        (§
            this(array, -2, f)
        )

        ;; for entryAt
        Iter(Object[] array, int i, IFn f)
        (§
            this.array = array
            this.i = i
            this.f = f
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (i < array.length - 2)))
        )

        public Object next()
        (§
            try
            (§
                i += 2
                (§ return (§ expr f.invoke(array[i], array[i + 1])))
            )
            catch (IndexOutOfBoundsException e)
            (§
                throw new NoSuchElementException()
            )
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    public Object kvreduce(IFn f, Object init)
    (§
        for (int i = 0 i < array.length i += 2)
        (§
            init = f.invoke(init, array[i], array[i + 1])
            if (RT.isReduced(init))
            (§
                (§ return (§ expr ((IDeref)init).deref()))
            )
        )
        (§ return (§ expr init))
    )

    public ITransientMap asTransient()
    (§
        (§ return (§ expr new TransientArrayMap(array)))
    )

    static final class TransientArrayMap extends ATransientMap
    (§
        volatile int len
        final Object[] array
        volatile Thread owner

        public TransientArrayMap(Object[] array)
        (§
            this.owner = Thread.currentThread()
            this.array = new Object[Math.max(HASHTABLE_THRESHOLD, array.length)]
            System.arraycopy(array, 0, this.array, 0, array.length)
            this.len = array.length
        )

        private int indexOf(Object key)
        (§
            for (int i = 0 i < len i += 2)
            (§
                if (equalKey(array[i], key))
                (§
                    (§ return (§ expr i))
                )
            )
            (§ return (§ expr -1))
        )

        ITransientMap doAssoc(Object key, Object val)
        (§
            int i = indexOf(key)
            if (i >= 0) ;; already have key,
            (§
                if (array[i + 1] != val) ;; no change, no op
                (§
                    array[i + 1] = val
                )
            )
            else ;; didn't have key, grow
            (§
                if (len >= array.length)
                (§
                    (§ return (§ expr PersistentHashMap.create(array).asTransient().assoc(key, val)))
                )
                array[len++] = key
                array[len++] = val
            )
            (§ return (§ expr this))
        )

        ITransientMap doWithout(Object key)
        (§
            int i = indexOf(key)
            if (i >= 0) ;; have key, will remove
            (§
                if (len >= 2)
                (§
                    array[i] = array[len - 2]
                    array[i + 1] = array[len - 1]
                )
                len -= 2
            )
            (§ return (§ expr this))
        )

        Object doValAt(Object key, Object notFound)
        (§
            int i = indexOf(key)
            if (i >= 0)
            (§
                (§ return (§ expr array[i + 1]))
            )
            (§ return (§ expr notFound))
        )

        int doCount()
        (§
            (§ return (§ expr len / 2))
        )

        IPersistentMap doPersistent()
        (§
            ensureEditable()
            owner = nil
            Object[] a = new Object[len]
            System.arraycopy(array, 0, a, 0, len)
            (§ return (§ expr new PersistentArrayMap(a)))
        )

        void ensureEditable()
        (§
            if (owner == nil)
            (§
                throw new IllegalAccessError("Transient used after persistent! call")
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.io.Serializable)
(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(§ class public class PersistentHashMap extends APersistentMap implements IEditableCollection, IObj, IMapIterable, IKVReduce)
(§
    final int count
    final INode root
    final boolean hasNull
    final Object nullValue
    final IPersistentMap _meta

    final public static PersistentHashMap EMPTY = new PersistentHashMap(0, nil, false, nil)
    final private static Object NOT_FOUND = new Object()

    static public IPersistentMap create(Map other)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (Object o :in other.entrySet())
        (§
            Map.Entry e = (Entry) o
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        (§ return (§ expr ret.persistent()))
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    public static PersistentHashMap create(Object... init)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (int i = 0 i < init.length i += 2)
        (§
            ret = ret.assoc(init[i], init[i + 1])
        )
        (§ return (§ expr (PersistentHashMap) ret.persistent()))
    )

    public static PersistentHashMap createWithCheck(Object... init)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (int i = 0 i < init.length i += 2)
        (§
            ret = ret.assoc(init[i], init[i + 1])
            if (ret.count() != i / 2 + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + init[i])
            )
        )
        (§ return (§ expr (PersistentHashMap) ret.persistent()))
    )

    static public PersistentHashMap create(ISeq items)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (  items != nil items = items.next().next())
        (§
            if (items.next() == nil)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))
            )
            ret = ret.assoc(items.first(), RT.second(items))
        )
        (§ return (§ expr (PersistentHashMap) ret.persistent()))
    )

    static public PersistentHashMap createWithCheck(ISeq items)
    (§
        ITransientMap ret = EMPTY.asTransient()
        for (int i = 0 items != nil items = items.next().next(), ++i)
        (§
            if (items.next() == nil)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))
            )
            ret = ret.assoc(items.first(), RT.second(items))
            if (ret.count() != i + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + items.first())
            )
        )
        (§ return (§ expr (PersistentHashMap) ret.persistent()))
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    public static PersistentHashMap create(IPersistentMap meta, Object... init)
    (§
        (§ return (§ expr create(init).withMeta(meta)))
    )

    PersistentHashMap(int count, INode root, boolean hasNull, Object nullValue)
    (§
        this.count = count
        this.root = root
        this.hasNull = hasNull
        this.nullValue = nullValue
        this._meta = nil
    )

    public PersistentHashMap(IPersistentMap meta, int count, INode root, boolean hasNull, Object nullValue)
    (§
        this._meta = meta
        this.count = count
        this.root = root
        this.hasNull = hasNull
        this.nullValue = nullValue
    )

    static int hash(Object k)
    (§
        (§ return (§ expr Util.hasheq(k)))
    )

    public boolean containsKey(Object key)
    (§
        if (key == nil)
        (§
            (§ return (§ expr hasNull))
        )
        (§ return (§ expr (root != nil) ? (root.find(0, hash(key), key, NOT_FOUND) != NOT_FOUND) :or false))
    )

    public IMapEntry entryAt(Object key)
    (§
        if (key == nil)
        (§
            (§ return (§ expr hasNull ? (IMapEntry) MapEntry.create(nil, nullValue) :or nil))
        )
        (§ return (§ expr (root != nil) ? root.find(0, hash(key), key) :or nil))
    )

    public IPersistentMap assoc(Object key, Object val)
    (§
        if (key == nil)
        (§
            if (hasNull && val == nullValue)
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new PersistentHashMap(meta(), hasNull ? count :or count + 1, root, true, val)))
        )
        Box addedLeaf = new Box(nil)
        INode newroot = ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(0, hash(key), key, val, addedLeaf)
        if (newroot == root)
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new PersistentHashMap(meta(), (addedLeaf.val == nil) ? count :or count + 1, newroot, hasNull, nullValue)))
    )

    public Object valAt(Object key, Object notFound)
    (§
        if (key == nil)
        (§
            (§ return (§ expr hasNull ? nullValue :or notFound))
        )
        (§ return (§ expr (root != nil) ? root.find(0, hash(key), key, notFound) :or notFound))
    )

    public Object valAt(Object key)
    (§
        (§ return (§ expr valAt(key, nil)))
    )

    public IPersistentMap assocEx(Object key, Object val)
    (§
        if (containsKey(key))
        (§
            throw Util.runtimeException("Key already present")
        )
        (§ return (§ expr assoc(key, val)))
    )

    public IPersistentMap without(Object key)
    (§
        if (key == nil)
        (§
            (§ return (§ expr hasNull ? new PersistentHashMap(meta(), count - 1, root, false, nil) :or this))
        )
        if (root == nil)
        (§
            (§ return (§ expr this))
        )
        INode newroot = root.without(0, hash(key), key)
        if (newroot == root)
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new PersistentHashMap(meta(), count - 1, newroot, hasNull, nullValue)))
    )

    static final Iterator EMPTY_ITER = new Iterator()
    (§
        public boolean hasNext()
        (§
            (§ return (§ expr false))
        )

        public Object next()
        (§
            throw new NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    private Iterator iterator(final IFn f)
    (§
        final Iterator rootIter = (root == nil) ? EMPTY_ITER :or root.iterator(f)
        if (hasNull)
        (§
            (§ return (§ expr new Iterator()
            (§
                private boolean seen = false
                public boolean hasNext()
                (§
                    if (!seen)
                    (§
                        (§ return (§ expr true))
                    )
                    else
                    (§
                        (§ return (§ expr rootIter.hasNext()))
                    )
                )

                public Object next()
                (§
                    if (!seen)
                    (§
                        seen = true
                        (§ return (§ expr f.invoke(nil, nullValue)))
                    )
                    else
                    (§
                        (§ return (§ expr rootIter.next()))
                    )
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )))
        )
        else
        (§
            (§ return (§ expr rootIter))
        )
    )

    public Iterator iterator()
    (§
        (§ return (§ expr iterator(APersistentMap.MAKE_ENTRY)))
    )

    public Iterator keyIterator()
    (§
        (§ return (§ expr iterator(APersistentMap.MAKE_KEY)))
    )

    public Iterator valIterator()
    (§
        (§ return (§ expr iterator(APersistentMap.MAKE_VAL)))
    )

    public Object kvreduce(IFn f, Object init)
    (§
        init = hasNull ? f.invoke(init, nil, nullValue) :or init
        if (RT.isReduced(init))
        (§
            (§ return (§ expr ((IDeref)init).deref()))
        )
        if (root != nil)
        (§
            init = root.kvreduce(f, init)
            if (RT.isReduced(init))
            (§
                (§ return (§ expr ((IDeref)init).deref()))
            )
            else
            (§
                (§ return (§ expr init))
            )
        )
        (§ return (§ expr init))
    )

    public Object fold(long n, final IFn combinef, final IFn reducef, IFn fjinvoke, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
    (§
        ;; we are ignoring n for now
        Callable top = new Callable()
        (§
            public Object call() throws Exception
            (§
                Object ret = combinef.invoke()
                if (root != nil)
                (§
                    ret = combinef.invoke(ret, root.fold(combinef, reducef, fjtask, fjfork, fjjoin))
                )
                (§ return (§ expr hasNull ? combinef.invoke(ret, reducef.invoke(combinef.invoke(), nil, nullValue)) :or ret))
            )
        )
        (§ return (§ expr fjinvoke.invoke(top)))
    )

    public int count()
    (§
        (§ return (§ expr count))
    )

    public ISeq seq()
    (§
        ISeq s = (root != nil) ? root.nodeSeq() :or nil
        (§ return (§ expr hasNull ? new Cons(MapEntry.create(nil, nullValue), s) :or s))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    static int mask(int hash, int shift)
    (§
        (§ return (§ expr (hash >>> shift) & 0x01f))
    )

    public PersistentHashMap withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new PersistentHashMap(meta, count, root, hasNull, nullValue)))
    )

    public TransientHashMap asTransient()
    (§
        (§ return (§ expr new TransientHashMap(this)))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )

    static final class TransientHashMap extends ATransientMap
    (§
        final AtomicReference<Thread> edit
        volatile INode root
        volatile int count
        volatile boolean hasNull
        volatile Object nullValue
        final Box leafFlag = new Box(nil)

        TransientHashMap(PersistentHashMap m)
        (§
            this(new AtomicReference<Thread>(Thread.currentThread()), m.root, m.count, m.hasNull, m.nullValue)
        )

        TransientHashMap(AtomicReference<Thread> edit, INode root, int count, boolean hasNull, Object nullValue)
        (§
            this.edit = edit
            this.root = root
            this.count = count
            this.hasNull = hasNull
            this.nullValue = nullValue
        )

        ITransientMap doAssoc(Object key, Object val)
        (§
            if (key == nil)
            (§
                if (this.nullValue != val)
                (§
                    this.nullValue = val
                )
                if (!hasNull)
                (§
                    this.count++
                    this.hasNull = true
                )
                (§ return (§ expr this))
            )
            leafFlag.val = nil
            INode n = ((root == nil) ? BitmapIndexedNode.EMPTY :or root).assoc(edit, 0, hash(key), key, val, leafFlag)
            if (n != this.root)
            (§
                this.root = n
            )
            if (leafFlag.val != nil)
            (§
                this.count++
            )
            (§ return (§ expr this))
        )

        ITransientMap doWithout(Object key)
        (§
            if (key == nil)
            (§
                if (!hasNull)
                (§
                    (§ return (§ expr this))
                )
                hasNull = false
                nullValue = nil
                this.count--
                (§ return (§ expr this))
            )
            if (root == nil)
            (§
                (§ return (§ expr this))
            )
            leafFlag.val = nil
            INode n = root.without(edit, 0, hash(key), key, leafFlag)
            if (n != root)
            (§
                this.root = n
            )
            if (leafFlag.val != nil)
            (§
                this.count--
            )
            (§ return (§ expr this))
        )

        IPersistentMap doPersistent()
        (§
            edit.set(nil)
            (§ return (§ expr new PersistentHashMap(count, root, hasNull, nullValue)))
        )

        Object doValAt(Object key, Object notFound)
        (§
            if (key == nil)
            (§
                if (hasNull)
                (§
                    (§ return (§ expr nullValue))
                )
                else
                (§
                    (§ return (§ expr notFound))
                )
            )
            if (root == nil)
            (§
                (§ return (§ expr notFound))
            )
            (§ return (§ expr root.find(0, hash(key), key, notFound)))
        )

        int doCount()
        (§
            (§ return (§ expr count))
        )

        void ensureEditable()
        (§
            if (edit.get() == nil)
            (§
                throw new IllegalAccessError("Transient used after persistent! call")
            )
        )
    )

    static interface INode extends Serializable
    (§
        INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)

        INode without(int shift, int hash, Object key)

        IMapEntry find(int shift, int hash, Object key)

        Object find(int shift, int hash, Object key, Object notFound)

        ISeq nodeSeq()

        INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)

        INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)

        public Object kvreduce(IFn f, Object init)

        Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)

        ;; returns the result of (f [k v]) for each iterated element
        Iterator iterator(IFn f)
    )

    final static class ArrayNode implements INode
    (§
        int count
        final INode[] array
        final AtomicReference<Thread> edit

        ArrayNode(AtomicReference<Thread> edit, int count, INode[] array)
        (§
            this.array = array
            this.edit = edit
            this.count = count
        )

        public INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == nil)
            (§
                (§ return (§ expr new ArrayNode(nil, count + 1, cloneAndSet(array, idx, BitmapIndexedNode.EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)))))
            )
            INode n = node.assoc(shift + 5, hash, key, val, addedLeaf)
            if (n == node)
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new ArrayNode(nil, count, cloneAndSet(array, idx, n))))
        )

        public INode without(int shift, int hash, Object key)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == nil)
            (§
                (§ return (§ expr this))
            )
            INode n = node.without(shift + 5, hash, key)
            if (n == node)
            (§
                (§ return (§ expr this))
            )
            if (n == nil)
            (§
                if (count <= 8) ;; shrink
                (§
                    (§ return (§ expr pack(nil, idx)))
                )
                (§ return (§ expr new ArrayNode(nil, count - 1, cloneAndSet(array, idx, n))))
            )
            else
            (§
                (§ return (§ expr new ArrayNode(nil, count, cloneAndSet(array, idx, n))))
            )
        )

        public IMapEntry find(int shift, int hash, Object key)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == nil)
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr node.find(shift + 5, hash, key)))
        )

        public Object find(int shift, int hash, Object key, Object notFound)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == nil)
            (§
                (§ return (§ expr notFound))
            )
            (§ return (§ expr node.find(shift + 5, hash, key, notFound)))
        )

        public ISeq nodeSeq()
        (§
            (§ return (§ expr Seq.create(array)))
        )

        public Iterator iterator(IFn f)
        (§
            (§ return (§ expr new Iter(array, f)))
        )

        public Object kvreduce(IFn f, Object init)
        (§
            for (INode node :in array)
            (§
                if (node != nil)
                (§
                    init = node.kvreduce(f, init)
                    if (RT.isReduced(init))
                    (§
                        (§ return (§ expr init))
                    )
                )
            )
            (§ return (§ expr init))
        )

        public Object fold(final IFn combinef, final IFn reducef, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
        (§
            List<Callable> tasks = new ArrayList()
            for (final INode node :in array)
            (§
                if (node != nil)
                (§
                    tasks.add(new Callable()
                    (§
                        public Object call() throws Exception
                        (§
                            (§ return (§ expr node.fold(combinef, reducef, fjtask, fjfork, fjjoin)))
                        )
                    ))
                )
            )

            (§ return (§ expr foldTasks(tasks, combinef, fjtask, fjfork, fjjoin)))
        )

        static public Object foldTasks(List<Callable> tasks, final IFn combinef, final IFn fjtask, final IFn fjfork, final IFn fjjoin)
        (§
            if (tasks.isEmpty())
            (§
                (§ return (§ expr combinef.invoke()))
            )

            if (tasks.size() == 1)
            (§
                Object ret = nil
                try
                (§
                    (§ return (§ expr tasks.get(0).call()))
                )
                catch (Exception e)
                (§
                    throw Util.sneakyThrow(e)
                )
            )

            List<Callable> t1 = tasks.subList(0, tasks.size() / 2)
            final List<Callable> t2 = tasks.subList(tasks.size() / 2, tasks.size())

            Object forked = fjfork.invoke(fjtask.invoke(new Callable()
            (§
                public Object call() throws Exception
                (§
                    (§ return (§ expr foldTasks(t2, combinef, fjtask, fjfork, fjjoin)))
                )
            )))

            (§ return (§ expr combinef.invoke(foldTasks(t1, combinef, fjtask, fjfork, fjjoin), fjjoin.invoke(forked))))
        )

        private ArrayNode ensureEditable(AtomicReference<Thread> edit)
        (§
            if (this.edit == edit)
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new ArrayNode(edit, count, this.array.clone())))
        )

        private ArrayNode editAndSet(AtomicReference<Thread> edit, int i, INode n)
        (§
            ArrayNode editable = ensureEditable(edit)
            editable.array[i] = n
            (§ return (§ expr editable))
        )

        private INode pack(AtomicReference<Thread> edit, int idx)
        (§
            Object[] newArray = new Object[2 * (count - 1)]
            int j = 1
            int bitmap = 0
            for (int i = 0 i < idx i++)
            (§
                if (array[i] != nil)
                (§
                    newArray[j] = array[i]
                    bitmap |= 1 << i
                    j += 2
                )
            )
            for (int i = idx + 1 i < array.length i++)
            (§
                if (array[i] != nil)
                (§
                    newArray[j] = array[i]
                    bitmap |= 1 << i
                    j += 2
                )
            )
            (§ return (§ expr new BitmapIndexedNode(edit, bitmap, newArray)))
        )

        public INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == nil)
            (§
                ArrayNode editable = editAndSet(edit, idx, BitmapIndexedNode.EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf))
                editable.count++
                (§ return (§ expr editable))
            )
            INode n = node.assoc(edit, shift + 5, hash, key, val, addedLeaf)
            if (n == node)
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr editAndSet(edit, idx, n)))
        )

        public INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
        (§
            int idx = mask(hash, shift)
            INode node = array[idx]
            if (node == nil)
            (§
                (§ return (§ expr this))
            )
            INode n = node.without(edit, shift + 5, hash, key, removedLeaf)
            if (n == node)
            (§
                (§ return (§ expr this))
            )
            if (n == nil)
            (§
                if (count <= 8) ;; shrink
                (§
                    (§ return (§ expr pack(edit, idx)))
                )
                ArrayNode editable = editAndSet(edit, idx, n)
                editable.count--
                (§ return (§ expr editable))
            )
            (§ return (§ expr editAndSet(edit, idx, n)))
        )

        static class Seq extends ASeq
        (§
            final INode[] nodes
            final int i
            final ISeq s

            static ISeq create(INode[] nodes)
            (§
                (§ return (§ expr create(nil, nodes, 0, nil)))
            )

            private static ISeq create(IPersistentMap meta, INode[] nodes, int i, ISeq s)
            (§
                if (s != nil)
                (§
                    (§ return (§ expr new Seq(meta, nodes, i, s)))
                )
                for (int j = i j < nodes.length j++)
                (§
                    if (nodes[j] != nil)
                    (§
                        ISeq ns = nodes[j].nodeSeq()
                        if (ns != nil)
                        (§
                            (§ return (§ expr new Seq(meta, nodes, j + 1, ns)))
                        )
                    )
                )
                (§ return (§ expr nil))
            )

            private Seq(IPersistentMap meta, INode[] nodes, int i, ISeq s)
            (§
                super(meta)
                this.nodes = nodes
                this.i = i
                this.s = s
            )

            public Obj withMeta(IPersistentMap meta)
            (§
                (§ return (§ expr new Seq(meta, nodes, i, s)))
            )

            public Object first()
            (§
                (§ return (§ expr s.first()))
            )

            public ISeq next()
            (§
                (§ return (§ expr create(nil, nodes, i, s.next())))
            )
        )

        static class Iter implements Iterator
        (§
            private final INode[] array
            private final IFn f
            private int i = 0
            private Iterator nestedIter

            private Iter(INode[] array, IFn f)
            (§
                this.array = array
                this.f = f
            )

            public boolean hasNext()
            (§
                while (true)
                (§
                    if (nestedIter != nil)
                    (§
                        if (nestedIter.hasNext())
                        (§
                            (§ return (§ expr true))
                        )
                        else
                        (§
                            nestedIter = nil
                        )
                    )

                    if (i < array.length)
                    (§
                        INode node = array[i++]
                        if (node != nil)
                        (§
                            nestedIter = node.iterator(f)
                        )
                    )
                    else
                    (§
                        (§ return (§ expr false))
                    )
                )
            )

            public Object next()
            (§
                if (hasNext())
                (§
                    (§ return (§ expr nestedIter.next()))
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )
    )

    final static class BitmapIndexedNode implements INode
    (§
        static final BitmapIndexedNode EMPTY = new BitmapIndexedNode(nil, 0, new Object[0])

        int bitmap
        Object[] array
        final AtomicReference<Thread> edit

        final int index(int bit)
        (§
            (§ return (§ expr Integer.bitCount(bitmap & (bit - 1))))
        )

        BitmapIndexedNode(AtomicReference<Thread> edit, int bitmap, Object[] array)
        (§
            this.bitmap = bitmap
            this.array = array
            this.edit = edit
        )

        public INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            int bit = bitpos(hash, shift)
            int idx = index(bit)
            if ((bitmap & bit) != 0)
            (§
                Object keyOrNull = array[2 * idx]
                Object valOrNode = array[2 * idx + 1]
                if (keyOrNull == nil)
                (§
                    INode n = ((INode) valOrNode).assoc(shift + 5, hash, key, val, addedLeaf)
                    if (n == valOrNode)
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                )
                if (Util.equiv(key, keyOrNull))
                (§
                    if (val == valOrNode)
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, val))))
                )
                addedLeaf.val = addedLeaf
                (§ return (§ expr new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx, nil, 2 * idx + 1, createNode(shift + 5, keyOrNull, valOrNode, hash, key, val)))))
            )
            else
            (§
                int n = Integer.bitCount(bitmap)
                if (n >= 16)
                (§
                    INode[] nodes = new INode[32]
                    int jdx = mask(hash, shift)
                    nodes[jdx] = EMPTY.assoc(shift + 5, hash, key, val, addedLeaf)
                    int j = 0
                    for (int i = 0 i < 32 i++)
                    (§
                        if (((bitmap >>> i) & 1) != 0)
                        (§
                            if (array[j] == nil)
                            (§
                                nodes[i] = (INode) array[j + 1]
                            )
                            else
                            (§
                                nodes[i] = EMPTY.assoc(shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf)
                            )
                            j += 2
                        )
                    )
                    (§ return (§ expr new ArrayNode(nil, n + 1, nodes)))
                )
                else
                (§
                    Object[] newArray = new Object[2 * (n + 1)]
                    System.arraycopy(array, 0, newArray, 0, 2 * idx)
                    newArray[2 * idx] = key
                    addedLeaf.val = addedLeaf
                    newArray[2 * idx + 1] = val
                    System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx))
                    (§ return (§ expr new BitmapIndexedNode(nil, bitmap | bit, newArray)))
                )
            )
        )

        public INode without(int shift, int hash, Object key)
        (§
            int bit = bitpos(hash, shift)
            if ((bitmap & bit) == 0)
            (§
                (§ return (§ expr this))
            )
            int idx = index(bit)
            Object keyOrNull = array[2 * idx]
            Object valOrNode = array[2 * idx + 1]
            if (keyOrNull == nil)
            (§
                INode n = ((INode) valOrNode).without(shift + 5, hash, key)
                if (n == valOrNode)
                (§
                    (§ return (§ expr this))
                )
                if (n != nil)
                (§
                    (§ return (§ expr new BitmapIndexedNode(nil, bitmap, cloneAndSet(array, 2 * idx + 1, n))))
                )
                if (bitmap == bit)
                (§
                    (§ return (§ expr nil))
                )
                (§ return (§ expr new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
            )
            if (Util.equiv(key, keyOrNull))
            (§
                ;; TODO: collapse
                (§ return (§ expr new BitmapIndexedNode(nil, bitmap :xor bit, removePair(array, idx))))
            )
            (§ return (§ expr this))
        )

        public IMapEntry find(int shift, int hash, Object key)
        (§
            int bit = bitpos(hash, shift)
            if ((bitmap & bit) == 0)
            (§
                (§ return (§ expr nil))
            )
            int idx = index(bit)
            Object keyOrNull = array[2 * idx]
            Object valOrNode = array[2 * idx + 1]
            if (keyOrNull == nil)
            (§
                (§ return (§ expr ((INode) valOrNode).find(shift + 5, hash, key)))
            )
            if (Util.equiv(key, keyOrNull))
            (§
                (§ return (§ expr (IMapEntry) MapEntry.create(keyOrNull, valOrNode)))
            )
            (§ return (§ expr nil))
        )

        public Object find(int shift, int hash, Object key, Object notFound)
        (§
            int bit = bitpos(hash, shift)
            if ((bitmap & bit) == 0)
            (§
                (§ return (§ expr notFound))
            )
            int idx = index(bit)
            Object keyOrNull = array[2 * idx]
            Object valOrNode = array[2 * idx + 1]
            if (keyOrNull == nil)
            (§
                (§ return (§ expr ((INode) valOrNode).find(shift + 5, hash, key, notFound)))
            )
            if (Util.equiv(key, keyOrNull))
            (§
                (§ return (§ expr valOrNode))
            )
            (§ return (§ expr notFound))
        )

        public ISeq nodeSeq()
        (§
            (§ return (§ expr NodeSeq.create(array)))
        )

        public Iterator iterator(IFn f)
        (§
            (§ return (§ expr new NodeIter(array, f)))
        )

        public Object kvreduce(IFn f, Object init)
        (§
            (§ return (§ expr NodeSeq.kvreduce(array, f, init)))
        )

        public Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
        (§
            (§ return (§ expr NodeSeq.kvreduce(array, reducef, combinef.invoke())))
        )

        private BitmapIndexedNode ensureEditable(AtomicReference<Thread> edit)
        (§
            if (this.edit == edit)
            (§
                (§ return (§ expr this))
            )
            int n = Integer.bitCount(bitmap)
            Object[] newArray = new Object[(n >= 0) ? 2 * (n + 1) :or 4] ;; make room for next assoc
            System.arraycopy(array, 0, newArray, 0, 2 * n)
            (§ return (§ expr new BitmapIndexedNode(edit, bitmap, newArray)))
        )

        private BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
        (§
            BitmapIndexedNode editable = ensureEditable(edit)
            editable.array[i] = a
            (§ return (§ expr editable))
        )

        private BitmapIndexedNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
        (§
            BitmapIndexedNode editable = ensureEditable(edit)
            editable.array[i] = a
            editable.array[j] = b
            (§ return (§ expr editable))
        )

        private BitmapIndexedNode editAndRemovePair(AtomicReference<Thread> edit, int bit, int i)
        (§
            if (bitmap == bit)
            (§
                (§ return (§ expr nil))
            )
            BitmapIndexedNode editable = ensureEditable(edit)
            editable.bitmap ^= bit
            System.arraycopy(editable.array, 2 * (i + 1), editable.array, 2 * i, editable.array.length - 2 * (i + 1))
            editable.array[editable.array.length - 2] = nil
            editable.array[editable.array.length - 1] = nil
            (§ return (§ expr editable))
        )

        public INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            int bit = bitpos(hash, shift)
            int idx = index(bit)
            if ((bitmap & bit) != 0)
            (§
                Object keyOrNull = array[2 * idx]
                Object valOrNode = array[2 * idx + 1]
                if (keyOrNull == nil)
                (§
                    INode n = ((INode) valOrNode).assoc(edit, shift + 5, hash, key, val, addedLeaf)
                    if (n == valOrNode)
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr editAndSet(edit, 2 * idx + 1, n)))
                )
                if (Util.equiv(key, keyOrNull))
                (§
                    if (val == valOrNode)
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr editAndSet(edit, 2 * idx + 1, val)))
                )
                addedLeaf.val = addedLeaf
                (§ return (§ expr editAndSet(edit, 2 * idx, nil, 2 * idx + 1, createNode(edit, shift + 5, keyOrNull, valOrNode, hash, key, val))))
            )
            else
            (§
                int n = Integer.bitCount(bitmap)
                if (n * 2 < array.length)
                (§
                    addedLeaf.val = addedLeaf
                    BitmapIndexedNode editable = ensureEditable(edit)
                    System.arraycopy(editable.array, 2 * idx, editable.array, 2 * (idx + 1), 2 * (n - idx))
                    editable.array[2 * idx] = key
                    editable.array[2 * idx + 1] = val
                    editable.bitmap |= bit
                    (§ return (§ expr editable))
                )
                if (n >= 16)
                (§
                    INode[] nodes = new INode[32]
                    int jdx = mask(hash, shift)
                    nodes[jdx] = EMPTY.assoc(edit, shift + 5, hash, key, val, addedLeaf)
                    int j = 0
                    for (int i = 0 i < 32 i++)
                    (§
                        if (((bitmap >>> i) & 1) != 0)
                        (§
                            if (array[j] == nil)
                            (§
                                nodes[i] = (INode) array[j + 1]
                            )
                            else
                            (§
                                nodes[i] = EMPTY.assoc(edit, shift + 5, hash(array[j]), array[j], array[j + 1], addedLeaf)
                            )
                            j += 2
                        )
                    )
                    (§ return (§ expr new ArrayNode(edit, n + 1, nodes)))
                )
                else
                (§
                    Object[] newArray = new Object[2 * (n + 4)]
                    System.arraycopy(array, 0, newArray, 0, 2 * idx)
                    newArray[2 * idx] = key
                    addedLeaf.val = addedLeaf
                    newArray[2 * idx + 1] = val
                    System.arraycopy(array, 2 * idx, newArray, 2 * (idx + 1), 2 * (n - idx))
                    BitmapIndexedNode editable = ensureEditable(edit)
                    editable.array = newArray
                    editable.bitmap |= bit
                    (§ return (§ expr editable))
                )
            )
        )

        public INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
        (§
            int bit = bitpos(hash, shift)
            if ((bitmap & bit) == 0)
            (§
                (§ return (§ expr this))
            )
            int idx = index(bit)
            Object keyOrNull = array[2 * idx]
            Object valOrNode = array[2 * idx + 1]
            if (keyOrNull == nil)
            (§
                INode n = ((INode) valOrNode).without(edit, shift + 5, hash, key, removedLeaf)
                if (n == valOrNode)
                (§
                    (§ return (§ expr this))
                )
                if (n != nil)
                (§
                    (§ return (§ expr editAndSet(edit, 2 * idx + 1, n)))
                )
                if (bitmap == bit)
                (§
                    (§ return (§ expr nil))
                )
                (§ return (§ expr editAndRemovePair(edit, bit, idx)))
            )
            if (Util.equiv(key, keyOrNull))
            (§
                removedLeaf.val = removedLeaf
                ;; TODO: collapse
                (§ return (§ expr editAndRemovePair(edit, bit, idx)))
            )
            (§ return (§ expr this))
        )
    )

    final static class HashCollisionNode implements INode
    (§
        final int hash
        int count
        Object[] array
        final AtomicReference<Thread> edit

        HashCollisionNode(AtomicReference<Thread> edit, int hash, int count, Object... array)
        (§
            this.edit = edit
            this.hash = hash
            this.count = count
            this.array = array
        )

        public INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            if (hash == this.hash)
            (§
                int idx = findIndex(key)
                if (idx != -1)
                (§
                    if (array[idx + 1] == val)
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr new HashCollisionNode(nil, hash, count, cloneAndSet(array, idx + 1, val))))
                )
                Object[] newArray = new Object[2 * (count + 1)]
                System.arraycopy(array, 0, newArray, 0, 2 * count)
                newArray[2 * count] = key
                newArray[2 * count + 1] = val
                addedLeaf.val = addedLeaf
                (§ return (§ expr new HashCollisionNode(edit, hash, count + 1, newArray)))
            )
            ;; nest it in a bitmap node
            (§ return (§ expr new BitmapIndexedNode(nil, bitpos(this.hash, shift), new Object[] (§ nil, this )).assoc(shift, hash, key, val, addedLeaf)))
        )

        public INode without(int shift, int hash, Object key)
        (§
            int idx = findIndex(key)
            if (idx == -1)
            (§
                (§ return (§ expr this))
            )
            if (count == 1)
            (§
                (§ return (§ expr nil))
            )
            (§ return (§ expr new HashCollisionNode(nil, hash, count - 1, removePair(array, idx / 2))))
        )

        public IMapEntry find(int shift, int hash, Object key)
        (§
            int idx = findIndex(key)
            if (idx < 0)
            (§
                (§ return (§ expr nil))
            )
            if (Util.equiv(key, array[idx]))
            (§
                (§ return (§ expr (IMapEntry) MapEntry.create(array[idx], array[idx + 1])))
            )
            (§ return (§ expr nil))
        )

        public Object find(int shift, int hash, Object key, Object notFound)
        (§
            int idx = findIndex(key)
            if (idx < 0)
            (§
                (§ return (§ expr notFound))
            )
            if (Util.equiv(key, array[idx]))
            (§
                (§ return (§ expr array[idx + 1]))
            )
            (§ return (§ expr notFound))
        )

        public ISeq nodeSeq()
        (§
            (§ return (§ expr NodeSeq.create(array)))
        )

        public Iterator iterator(IFn f)
        (§
            (§ return (§ expr new NodeIter(array, f)))
        )

        public Object kvreduce(IFn f, Object init)
        (§
            (§ return (§ expr NodeSeq.kvreduce(array, f, init)))
        )

        public Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin)
        (§
            (§ return (§ expr NodeSeq.kvreduce(array, reducef, combinef.invoke())))
        )

        public int findIndex(Object key)
        (§
            for (int i = 0 i < 2 * count i += 2)
            (§
                if (Util.equiv(key, array[i]))
                (§
                    (§ return (§ expr i))
                )
            )
            (§ return (§ expr -1))
        )

        private HashCollisionNode ensureEditable(AtomicReference<Thread> edit)
        (§
            if (this.edit == edit)
            (§
                (§ return (§ expr this))
            )
            Object[] newArray = new Object[2 * (count + 1)] ;; make room for next assoc
            System.arraycopy(array, 0, newArray, 0, 2 * count)
            (§ return (§ expr new HashCollisionNode(edit, hash, count, newArray)))
        )

        private HashCollisionNode ensureEditable(AtomicReference<Thread> edit, int count, Object[] array)
        (§
            if (this.edit == edit)
            (§
                this.array = array
                this.count = count
                (§ return (§ expr this))
            )
            (§ return (§ expr new HashCollisionNode(edit, hash, count, array)))
        )

        private HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a)
        (§
            HashCollisionNode editable = ensureEditable(edit)
            editable.array[i] = a
            (§ return (§ expr editable))
        )

        private HashCollisionNode editAndSet(AtomicReference<Thread> edit, int i, Object a, int j, Object b)
        (§
            HashCollisionNode editable = ensureEditable(edit)
            editable.array[i] = a
            editable.array[j] = b
            (§ return (§ expr editable))
        )

        public INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf)
        (§
            if (hash == this.hash)
            (§
                int idx = findIndex(key)
                if (idx != -1)
                (§
                    if (array[idx + 1] == val)
                    (§
                        (§ return (§ expr this))
                    )
                    (§ return (§ expr editAndSet(edit, idx + 1, val)))
                )
                if (array.length > 2 * count)
                (§
                    addedLeaf.val = addedLeaf
                    HashCollisionNode editable = editAndSet(edit, 2 * count, key, 2 * count + 1, val)
                    editable.count++
                    (§ return (§ expr editable))
                )
                Object[] newArray = new Object[array.length + 2]
                System.arraycopy(array, 0, newArray, 0, array.length)
                newArray[array.length] = key
                newArray[array.length + 1] = val
                addedLeaf.val = addedLeaf
                (§ return (§ expr ensureEditable(edit, count + 1, newArray)))
            )
            ;; nest it in a bitmap node
            (§ return (§ expr new BitmapIndexedNode(edit, bitpos(this.hash, shift), new Object[] (§ nil, this, nil, nil )).assoc(edit, shift, hash, key, val, addedLeaf)))
        )

        public INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf)
        (§
            int idx = findIndex(key)
            if (idx == -1)
            (§
                (§ return (§ expr this))
            )
            removedLeaf.val = removedLeaf
            if (count == 1)
            (§
                (§ return (§ expr nil))
            )
            HashCollisionNode editable = ensureEditable(edit)
            editable.array[idx] = editable.array[2 * count - 2]
            editable.array[idx + 1] = editable.array[2 * count - 1]
            editable.array[2 * count - 2] = editable.array[2 * count - 1] = nil
            editable.count--
            (§ return (§ expr editable))
        )
    )

    private static INode[] cloneAndSet(INode[] array, int i, INode a)
    (§
        INode[] clone = array.clone()
        clone[i] = a
        (§ return (§ expr clone))
    )

    private static Object[] cloneAndSet(Object[] array, int i, Object a)
    (§
        Object[] clone = array.clone()
        clone[i] = a
        (§ return (§ expr clone))
    )

    private static Object[] cloneAndSet(Object[] array, int i, Object a, int j, Object b)
    (§
        Object[] clone = array.clone()
        clone[i] = a
        clone[j] = b
        (§ return (§ expr clone))
    )

    private static Object[] removePair(Object[] array, int i)
    (§
        Object[] newArray = new Object[array.length - 2]
        System.arraycopy(array, 0, newArray, 0, 2 * i)
        System.arraycopy(array, 2 * (i + 1), newArray, 2 * i, newArray.length - 2 * i)
        (§ return (§ expr newArray))
    )

    private static INode createNode(int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
    (§
        int key1hash = hash(key1)
        if (key1hash == key2hash)
        (§
            (§ return (§ expr new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
        )
        Box addedLeaf = new Box(nil)
        AtomicReference<Thread> edit = new AtomicReference<Thread>()
        (§ return (§ expr BitmapIndexedNode.EMPTY
            .assoc(edit, shift, key1hash, key1, val1, addedLeaf)
            .assoc(edit, shift, key2hash, key2, val2, addedLeaf)))
    )

    private static INode createNode(AtomicReference<Thread> edit, int shift, Object key1, Object val1, int key2hash, Object key2, Object val2)
    (§
        int key1hash = hash(key1)
        if (key1hash == key2hash)
        (§
            (§ return (§ expr new HashCollisionNode(nil, key1hash, 2, new Object[] (§ key1, val1, key2, val2 ))))
        )
        Box addedLeaf = new Box(nil)
        (§ return (§ expr BitmapIndexedNode.EMPTY
            .assoc(edit, shift, key1hash, key1, val1, addedLeaf)
            .assoc(edit, shift, key2hash, key2, val2, addedLeaf)))
    )

    private static int bitpos(int hash, int shift)
    (§
        (§ return (§ expr 1 << mask(hash, shift)))
    )

    static final class NodeIter implements Iterator
    (§
        private static final Object NULL = new Object()
        final Object[] array
        final IFn f
        private int i = 0
        private Object nextEntry = NULL
        private Iterator nextIter

        NodeIter(Object[] array, IFn f)
        (§
            this.array = array
            this.f = f
        )

        private boolean advance()
        (§
            while (i<array.length)
            (§
                Object key = array[i]
                Object nodeOrVal = array[i + 1]
                i += 2
                if (key != nil)
                (§
                    nextEntry = f.invoke(key, nodeOrVal)
                    (§ return (§ expr true))
                )
                else if (nodeOrVal != nil)
                (§
                    Iterator iter = ((INode) nodeOrVal).iterator(f)
                    if (iter != nil && iter.hasNext())
                    (§
                        nextIter = iter
                        (§ return (§ expr true))
                    )
                )
            )
            (§ return (§ expr false))
        )

        public boolean hasNext()
        (§
            if (nextEntry != NULL || nextIter != nil)
            (§
                (§ return (§ expr true))
            )
            (§ return (§ expr advance()))
        )

        public Object next()
        (§
            Object ret = nextEntry
            if (ret != NULL)
            (§
                nextEntry = NULL
                (§ return (§ expr ret))
            )
            else if (nextIter != nil)
            (§
                ret = nextIter.next()
                if (!nextIter.hasNext())
                (§
                    nextIter = nil
                )
                (§ return (§ expr ret))
            )
            else if (advance())
            (§
                (§ return (§ expr next()))
            )
            throw new NoSuchElementException()
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    static final class NodeSeq extends ASeq
    (§
        final Object[] array
        final int i
        final ISeq s

        NodeSeq(Object[] array, int i)
        (§
            this(nil, array, i, nil)
        )

        static ISeq create(Object[] array)
        (§
            (§ return (§ expr create(array, 0, nil)))
        )

        static public Object kvreduce(Object[] array, IFn f, Object init)
        (§
            for (int i = 0 i < array.length i += 2)
            (§
                if (array[i] != nil)
                (§
                    init = f.invoke(init, array[i], array[i + 1])
                )
                else
                (§
                    INode node = (INode) array[i + 1]
                    if (node != nil)
                    (§
                        init = node.kvreduce(f, init)
                    )
                )
                if (RT.isReduced(init))
                (§
                    (§ return (§ expr init))
                )
            )
            (§ return (§ expr init))
        )

        private static ISeq create(Object[] array, int i, ISeq s)
        (§
            if (s != nil)
            (§
                (§ return (§ expr new NodeSeq(nil, array, i, s)))
            )
            for (int j = i j < array.length j+=2)
            (§
                if (array[j] != nil)
                (§
                    (§ return (§ expr new NodeSeq(nil, array, j, nil)))
                )
                INode node = (INode) array[j + 1]
                if (node != nil)
                (§
                    ISeq nodeSeq = node.nodeSeq()
                    if (nodeSeq != nil)
                    (§
                        (§ return (§ expr new NodeSeq(nil, array, j + 2, nodeSeq)))
                    )
                )
            )
            (§ return (§ expr nil))
        )

        NodeSeq(IPersistentMap meta, Object[] array, int i, ISeq s)
        (§
            super(meta)
            this.array = array
            this.i = i
            this.s = s
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new NodeSeq(meta, array, i, s)))
        )

        public Object first()
        (§
            if (s != nil)
            (§
                (§ return (§ expr s.first()))
            )
            (§ return (§ expr MapEntry.create(array[i], array[i + 1])))
        )

        public ISeq next()
        (§
            if (s != nil)
            (§
                (§ return (§ expr create(array, i, s.next())))
            )
            (§ return (§ expr create(array, i + 2, nil)))
        )
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

(§ class public class PersistentHashSet extends APersistentSet implements IObj, IEditableCollection)
(§
    static public final PersistentHashSet EMPTY = new PersistentHashSet(nil, PersistentHashMap.EMPTY)

    final IPersistentMap _meta

    public static PersistentHashSet create(Object... init)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (int i = 0 i < init.length i++)
        (§
            ret = (ITransientSet)ret.conj(init[i])
        )
        (§ return (§ expr (PersistentHashSet)ret.persistent()))
    )

    public static PersistentHashSet create(List init)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (Object key :in init)
        (§
            ret = (ITransientSet) ret.conj(key)
        )
        (§ return (§ expr (PersistentHashSet)ret.persistent()))
    )

    static public PersistentHashSet create(ISeq items)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (  items != nil items = items.next())
        (§
            ret = (ITransientSet) ret.conj(items.first())
        )
        (§ return (§ expr (PersistentHashSet)ret.persistent()))
    )

    public static PersistentHashSet createWithCheck(Object... init)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (int i = 0 i < init.length i++)
        (§
            ret = (ITransientSet) ret.conj(init[i])
            if (ret.count() != i + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + init[i])
            )
        )
        (§ return (§ expr (PersistentHashSet) ret.persistent()))
    )

    public static PersistentHashSet createWithCheck(List init)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        int i = 0
        for (Object key :in init)
        (§
            ret = (ITransientSet) ret.conj(key)
            if (ret.count() != i + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + key)
            )
            ++i
        )
        (§ return (§ expr (PersistentHashSet) ret.persistent()))
    )

    static public PersistentHashSet createWithCheck(ISeq items)
    (§
        ITransientSet ret = (ITransientSet)EMPTY.asTransient()
        for (int i = 0 items != nil items = items.next(), ++i)
        (§
            ret = (ITransientSet) ret.conj(items.first())
            if (ret.count() != i + 1)
            (§
                throw new IllegalArgumentException("Duplicate key: " + items.first())
            )
        )
        (§ return (§ expr (PersistentHashSet) ret.persistent()))
    )

    PersistentHashSet(IPersistentMap meta, IPersistentMap impl)
    (§
        super(impl)
        this._meta = meta
    )

    public IPersistentSet disjoin(Object key)
    (§
        if (contains(key))
        (§
            (§ return (§ expr new PersistentHashSet(meta(), impl.without(key))))
        )
        (§ return (§ expr this))
    )

    public IPersistentSet cons(Object o)
    (§
        if (contains(o))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new PersistentHashSet(meta(), impl.assoc(o, o))))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    public PersistentHashSet withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new PersistentHashSet(meta, impl)))
    )

    public ITransientCollection asTransient()
    (§
        (§ return (§ expr new TransientHashSet(((PersistentHashMap) impl).asTransient())))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )

    static final class TransientHashSet extends ATransientSet
    (§
        TransientHashSet(ITransientMap impl)
        (§
            super(impl)
        )

        public IPersistentCollection persistent()
        (§
            (§ return (§ expr new PersistentHashSet(nil, impl.persistent())))
        )
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.io.Serializable)
(§ import java.util.*)

(§ class public class PersistentList extends ASeq implements IPersistentList, IReduce, List, Counted)
(§
    private final Object _first
    private final IPersistentList _rest
    private final int _count

    static public class Primordial extends RestFn
    (§
        final public int getRequiredArity()
        (§
            (§ return (§ expr 0))
        )

        final protected Object doInvoke(Object args)
        (§
            if (args instanceof ArraySeq)
            (§
                Object[] argsarray = ((ArraySeq) args).array
                IPersistentList ret = EMPTY
                for (int i = argsarray.length - 1 i >= ((ArraySeq)args).i --i)
                (§
                    ret = (IPersistentList) ret.cons(argsarray[i])
                )
                (§ return (§ expr ret))
            )
            LinkedList list = new LinkedList()
            for (ISeq s = RT.seq(args) s != nil s = s.next())
            (§
                list.add(s.first())
            )
            (§ return (§ expr create(list)))
        )

        static public Object invokeStatic(ISeq args)
        (§
            if (args instanceof ArraySeq)
            (§
                Object[] argsarray = ((ArraySeq) args).array
                IPersistentList ret = EMPTY
                for (int i = argsarray.length - 1 i >= 0 --i)
                (§
                    ret = (IPersistentList) ret.cons(argsarray[i])
                )
                (§ return (§ expr ret))
            )
            LinkedList list = new LinkedList()
            for (ISeq s = RT.seq(args) s != nil s = s.next())
            (§
                list.add(s.first())
            )
            (§ return (§ expr create(list)))
        )

        public IObj withMeta(IPersistentMap meta)
        (§
            throw new UnsupportedOperationException()
        )

        public IPersistentMap meta()
        (§
            (§ return (§ expr nil))
        )
    )

    public static IFn creator = new Primordial()

    final public static EmptyList EMPTY = new EmptyList(nil)

    public PersistentList(Object first)
    (§
        this._first = first
        this._rest = nil

        this._count = 1
    )

    PersistentList(IPersistentMap meta, Object _first, IPersistentList _rest, int _count)
    (§
        super(meta)
        this._first = _first
        this._rest = _rest
        this._count = _count
    )

    public static IPersistentList create(List init)
    (§
        IPersistentList ret = EMPTY
        for (ListIterator i = init.listIterator(init.size()) i.hasPrevious() )
        (§
            ret = (IPersistentList) ret.cons(i.previous())
        )
        (§ return (§ expr ret))
    )

    public Object first()
    (§
        (§ return (§ expr _first))
    )

    public ISeq next()
    (§
        if (_count == 1)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr (ISeq) _rest))
    )

    public Object peek()
    (§
        (§ return (§ expr first()))
    )

    public IPersistentList pop()
    (§
        if (_rest == nil)
        (§
            (§ return (§ expr EMPTY.withMeta(_meta)))
        )
        (§ return (§ expr _rest))
    )

    public int count()
    (§
        (§ return (§ expr _count))
    )

    public PersistentList cons(Object o)
    (§
        (§ return (§ expr new PersistentList(meta(), o, this, _count + 1)))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    public PersistentList withMeta(IPersistentMap meta)
    (§
        if (meta != _meta)
        (§
            (§ return (§ expr new PersistentList(meta, _first, _rest, _count)))
        )
        (§ return (§ expr this))
    )

    public Object reduce(IFn f)
    (§
        Object ret = first()
        for (ISeq s = next() s != nil s = s.next())
        (§
            ret = f.invoke(ret, s.first())
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
        )
        (§ return (§ expr ret))
    )

    public Object reduce(IFn f, Object start)
    (§
        Object ret = f.invoke(start, first())
        for (ISeq s = next() s != nil s = s.next())
        (§
            if (RT.isReduced(ret))
            (§
                (§ return (§ expr ((IDeref)ret).deref()))
            )
            ret = f.invoke(ret, s.first())
        )
        if (RT.isReduced(ret))
        (§
            (§ return (§ expr ((IDeref)ret).deref()))
        )
        (§ return (§ expr ret))
    )

    static class EmptyList extends Obj implements IPersistentList, List, ISeq, Counted, IHashEq
    (§
        static final int hasheq = Murmur3.hashOrdered(Collections.EMPTY_LIST)

        public int hashCode()
        (§
            (§ return (§ expr 1))
        )

        public int hasheq()
        (§
            (§ return (§ expr hasheq))
        )

        public String toString()
        (§
            (§ return (§ expr "()"))
        )

        public boolean equals(Object o)
        (§
            (§ return (§ expr ((o instanceof Sequential || o instanceof List) && RT.seq(o) == nil)))
        )

        public boolean equiv(Object o)
        (§
            (§ return (§ expr equals(o)))
        )

        EmptyList(IPersistentMap meta)
        (§
            super(meta)
        )

        public Object first()
        (§
            (§ return (§ expr nil))
        )

        public ISeq next()
        (§
            (§ return (§ expr nil))
        )

        public ISeq more()
        (§
            (§ return (§ expr this))
        )

        public PersistentList cons(Object o)
        (§
            (§ return (§ expr new PersistentList(meta(), o, nil, 1)))
        )

        public IPersistentCollection empty()
        (§
            (§ return (§ expr this))
        )

        public EmptyList withMeta(IPersistentMap meta)
        (§
            if (meta != meta())
            (§
                (§ return (§ expr new EmptyList(meta)))
            )
            (§ return (§ expr this))
        )

        public Object peek()
        (§
            (§ return (§ expr nil))
        )

        public IPersistentList pop()
        (§
            throw new IllegalStateException("Can't pop empty list")
        )

        public int count()
        (§
            (§ return (§ expr 0))
        )

        public ISeq seq()
        (§
            (§ return (§ expr nil))
        )

        public int size()
        (§
            (§ return (§ expr 0))
        )

        public boolean isEmpty()
        (§
            (§ return (§ expr true))
        )

        public boolean contains(Object o)
        (§
            (§ return (§ expr false))
        )

        public Iterator iterator()
        (§
            (§ return (§ expr new Iterator()
            (§
                public boolean hasNext()
                (§
                    (§ return (§ expr false))
                )

                public Object next()
                (§
                    throw new NoSuchElementException()
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )))
        )

        public Object[] toArray()
        (§
            (§ return (§ expr RT.EMPTY_ARRAY))
        )

        public boolean add(Object o)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean remove(Object o)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean addAll(Collection collection)
        (§
            throw new UnsupportedOperationException()
        )

        public void clear()
        (§
            throw new UnsupportedOperationException()
        )

        public boolean retainAll(Collection collection)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean removeAll(Collection collection)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean containsAll(Collection collection)
        (§
            (§ return (§ expr collection.isEmpty()))
        )

        public Object[] toArray(Object[] objects)
        (§
            if (objects.length > 0)
            (§
                objects[0] = nil
            )
            (§ return (§ expr objects))
        )

        private List reify()
        (§
            (§ return (§ expr Collections.unmodifiableList(new ArrayList(this))))
        )

        public List subList(int fromIndex, int toIndex)
        (§
            (§ return (§ expr reify().subList(fromIndex, toIndex)))
        )

        public Object set(int index, Object element)
        (§
            throw new UnsupportedOperationException()
        )

        public Object remove(int index)
        (§
            throw new UnsupportedOperationException()
        )

        public int indexOf(Object o)
        (§
            ISeq s = seq()
            for (int i = 0 s != nil s = s.next(), i++)
            (§
                if (Util.equiv(s.first(), o))
                (§
                    (§ return (§ expr i))
                )
            )
            (§ return (§ expr -1))
        )

        public int lastIndexOf(Object o)
        (§
            (§ return (§ expr reify().lastIndexOf(o)))
        )

        public ListIterator listIterator()
        (§
            (§ return (§ expr reify().listIterator()))
        )

        public ListIterator listIterator(int index)
        (§
            (§ return (§ expr reify().listIterator(index)))
        )

        public Object get(int index)
        (§
            (§ return (§ expr RT.nth(this, index)))
        )

        public void add(int index, Object element)
        (§
            throw new UnsupportedOperationException()
        )

        public boolean addAll(int index, Collection c)
        (§
            throw new UnsupportedOperationException()
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(§ class public class PersistentQueue extends Obj implements IPersistentList, Collection, Counted, IHashEq)
(§
    final public static PersistentQueue EMPTY = new PersistentQueue(nil, 0, nil, nil)

    final int cnt
    final ISeq f
    final PersistentVector r
    int _hash
    int _hasheq

    PersistentQueue(IPersistentMap meta, int cnt, ISeq f, PersistentVector r)
    (§
        super(meta)
        this.cnt = cnt
        this.f = f
        this.r = r
    )

    public boolean equiv(Object obj)
    (§
        if (!(obj instanceof Sequential))
        (§
            (§ return (§ expr false))
        )
        ISeq ms = RT.seq(obj)
        for (ISeq s = seq() s != nil s = s.next(), ms = ms.next())
        (§
            if (ms == nil || !Util.equiv(s.first(), ms.first()))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr (ms == nil)))
    )

    public boolean equals(Object obj)
    (§
        if (!(obj instanceof Sequential))
        (§
            (§ return (§ expr false))
        )
        ISeq ms = RT.seq(obj)
        for (ISeq s = seq() s != nil s = s.next(), ms = ms.next())
        (§
            if (ms == nil || !Util.equals(s.first(), ms.first()))
            (§
                (§ return (§ expr false))
            )
        )
        (§ return (§ expr (ms == nil)))
    )

    public int hashCode()
    (§
        int hash = this._hash
        if (hash == 0)
        (§
            hash = 1
            for (ISeq s = seq() s != nil s = s.next())
            (§
                hash = 31 * hash + ((s.first() == nil) ? 0 :or s.first().hashCode())
            )
            this._hash = hash
        )
        (§ return (§ expr hash))
    )

    public int hasheq()
    (§
        int cached = this._hasheq
        if (cached == 0)
        (§
            this._hasheq  = cached = Murmur3.hashOrdered(this)
        )
        (§ return (§ expr cached))
    )

    public Object peek()
    (§
        (§ return (§ expr RT.first(f)))
    )

    public PersistentQueue pop()
    (§
        if (f == nil) ;; hmmm... pop of empty queue -> empty queue?
        (§
            (§ return (§ expr this))
        )
        ISeq f1 = f.next()
        PersistentVector r1 = r
        if (f1 == nil)
        (§
            f1 = RT.seq(r)
            r1 = nil
        )
        (§ return (§ expr new PersistentQueue(meta(), cnt - 1, f1, r1)))
    )

    public int count()
    (§
        (§ return (§ expr cnt))
    )

    public ISeq seq()
    (§
        if (f == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr new Seq(f, RT.seq(r))))
    )

    public PersistentQueue cons(Object o)
    (§
        if (f == nil) ;; empty
        (§
            (§ return (§ expr new PersistentQueue(meta(), cnt + 1, RT.list(o), nil)))
        )
        else
        (§
            (§ return (§ expr new PersistentQueue(meta(), cnt + 1, f, ((r != nil) ? r :or PersistentVector.EMPTY).cons(o))))
        )
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    public PersistentQueue withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new PersistentQueue(meta, cnt, f, r)))
    )

    static class Seq extends ASeq
    (§
        final ISeq f
        final ISeq rseq

        Seq(ISeq f, ISeq rseq)
        (§
            this.f = f
            this.rseq = rseq
        )

        Seq(IPersistentMap meta, ISeq f, ISeq rseq)
        (§
            super(meta)
            this.f = f
            this.rseq = rseq
        )

        public Object first()
        (§
            (§ return (§ expr f.first()))
        )

        public ISeq next()
        (§
            ISeq f1 = f.next()
            ISeq r1 = rseq
            if (f1 == nil)
            (§
                if (rseq == nil)
                (§
                    (§ return (§ expr nil))
                )
                f1 = rseq
                r1 = nil
            )
            (§ return (§ expr new Seq(f1, r1)))
        )

        public int count()
        (§
            (§ return (§ expr RT.count(f) + RT.count(rseq)))
        )

        public Seq withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new Seq(meta, f, rseq)))
        )
    )

    public Object[] toArray()
    (§
        (§ return (§ expr RT.seqToArray(seq())))
    )

    public boolean add(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean remove(Object o)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean addAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public void clear()
    (§
        throw new UnsupportedOperationException()
    )

    public boolean retainAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean removeAll(Collection c)
    (§
        throw new UnsupportedOperationException()
    )

    public boolean containsAll(Collection c)
    (§
        for (Object o :in c)
        (§
            if (contains(o))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    public Object[] toArray(Object[] a)
    (§
        (§ return (§ expr RT.seqToPassedArray(seq(), a)))
    )

    public int size()
    (§
        (§ return (§ expr count()))
    )

    public boolean isEmpty()
    (§
        (§ return (§ expr (count() == 0)))
    )

    public boolean contains(Object o)
    (§
        for (ISeq s = seq() s != nil s = s.next())
        (§
            if (Util.equiv(s.first(), o))
            (§
                (§ return (§ expr true))
            )
        )
        (§ return (§ expr false))
    )

    public Iterator iterator()
    (§
        (§ return (§ expr new Iterator()
        (§
            private ISeq fseq = f
            private final Iterator riter = (r != nil) ? r.iterator() :or nil

            public boolean hasNext()
            (§
                (§ return (§ expr ((fseq != nil && fseq.seq() != nil) || (riter != nil && riter.hasNext()))))
            )

            public Object next()
            (§
                if (fseq != nil)
                (§
                    Object ret = fseq.first()
                    fseq = fseq.next()
                    (§ return (§ expr ret))
                )
                else if (riter != nil && riter.hasNext())
                (§
                    (§ return (§ expr riter.next()))
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )))
    )
)
)

(java-ns cloiure.lang.PersistentStructMap

(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.io.Serializable)
(§ import java.util.NoSuchElementException)

(§ class public class PersistentStructMap extends APersistentMap implements IObj)
(§
    public static class Def implements Serializable
    (§
        final ISeq keys
        final IPersistentMap keyslots

        Def(ISeq keys, IPersistentMap keyslots)
        (§
            this.keys = keys
            this.keyslots = keyslots
        )
    )

    final Def def
    final Object[] vals
    final IPersistentMap ext
    final IPersistentMap _meta

    static public Def createSlotMap(ISeq keys)
    (§
        if (keys == nil)
        (§
            throw new IllegalArgumentException("Must supply keys")
        )
        int c = RT.count(keys)
        Object[] v = new Object[2 * c]
        int i = 0
        for (ISeq s = keys s != nil s = s.next(), i++)
        (§
            v[2 * i] =  s.first()
            v[2 * i + 1] = i
        )
        (§ return (§ expr new Def(keys, RT.map(v))))
    )

    static public PersistentStructMap create(Def def, ISeq keyvals)
    (§
        Object[] vals = new Object[def.keyslots.count()]
        IPersistentMap ext = PersistentHashMap.EMPTY
        for (  keyvals != nil keyvals = keyvals.next().next())
        (§
            if (keyvals.next() == nil)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", keyvals.first()))
            )
            Object k = keyvals.first()
            Object v = RT.second(keyvals)
            Map.Entry e = def.keyslots.entryAt(k)
            if (e != nil)
            (§
                vals[(Integer) e.getValue()] = v
            )
            else
            (§
                ext = ext.assoc(k, v)
            )
        )
        (§ return (§ expr new PersistentStructMap(nil, def, vals, ext)))
    )

    static public PersistentStructMap construct(Def def, ISeq valseq)
    (§
        Object[] vals = new Object[def.keyslots.count()]
        IPersistentMap ext = PersistentHashMap.EMPTY
        for (int i = 0 i < vals.length && valseq != nil valseq = valseq.next(), i++)
        (§
            vals[i] = valseq.first()
        )
        if (valseq != nil)
        (§
            throw new IllegalArgumentException("Too many arguments to struct constructor")
        )
        (§ return (§ expr new PersistentStructMap(nil, def, vals, ext)))
    )

    static public IFn getAccessor(final Def def, Object key)
    (§
        Map.Entry e = def.keyslots.entryAt(key)
        if (e != nil)
        (§
            final int i = (Integer) e.getValue()
            (§ return (§ expr new AFn()
            (§
                public Object invoke(Object arg1)
                (§
                    PersistentStructMap m = (PersistentStructMap) arg1
                    if (m.def != def)
                    (§
                        throw Util.runtimeException("Accessor/struct mismatch")
                    )
                    (§ return (§ expr m.vals[i]))
                )
            )))
        )
        throw new IllegalArgumentException("Not a key of struct")
    )

    protected PersistentStructMap(IPersistentMap meta, Def def, Object[] vals, IPersistentMap ext)
    (§
        this._meta = meta
        this.ext = ext
        this.def = def
        this.vals = vals
    )

    ;;;
     ; Returns a new instance of PersistentStructMap using the given parameters.
     ; This function is used instead of the PersistentStructMap constructor by
     ; all methods that return a new PersistentStructMap.  This is done so as to
     ; allow subclasses to return instances of their class from all
     ; PersistentStructMap methods.
     ;;
    protected PersistentStructMap makeNew(IPersistentMap meta, Def def, Object[] vals, IPersistentMap ext)
    (§
        (§ return (§ expr new PersistentStructMap(meta, def, vals, ext)))
    )

    public IObj withMeta(IPersistentMap meta)
    (§
        if (meta == _meta)
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr makeNew(meta, def, vals, ext)))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )

    public boolean containsKey(Object key)
    (§
        (§ return (§ expr def.keyslots.containsKey(key) || ext.containsKey(key)))
    )

    public IMapEntry entryAt(Object key)
    (§
        Map.Entry e = def.keyslots.entryAt(key)
        if (e != nil)
        (§
            (§ return (§ expr (IMapEntry) MapEntry.create(e.getKey(), vals[(Integer) e.getValue()])))
        )
        (§ return (§ expr ext.entryAt(key)))
    )

    public IPersistentMap assoc(Object key, Object val)
    (§
        Map.Entry e = def.keyslots.entryAt(key)
        if (e != nil)
        (§
            int i = (Integer) e.getValue()
            Object[] newVals = vals.clone()
            newVals[i] = val
            (§ return (§ expr makeNew(_meta, def, newVals, ext)))
        )
        (§ return (§ expr makeNew(_meta, def, vals, ext.assoc(key, val))))
    )

    public Object valAt(Object key)
    (§
        Integer i = (Integer) def.keyslots.valAt(key)
        if (i != nil)
        (§
            (§ return (§ expr vals[i]))
        )
        (§ return (§ expr ext.valAt(key)))
    )

    public Object valAt(Object key, Object notFound)
    (§
        Integer i = (Integer) def.keyslots.valAt(key)
        if (i != nil)
        (§
            (§ return (§ expr vals[i]))
        )
        (§ return (§ expr ext.valAt(key, notFound)))
    )

    public IPersistentMap assocEx(Object key, Object val)
    (§
        if (containsKey(key))
        (§
            throw Util.runtimeException("Key already present")
        )
        (§ return (§ expr assoc(key, val)))
    )

    public IPersistentMap without(Object key)
    (§
        Map.Entry e = def.keyslots.entryAt(key)
        if (e != nil)
        (§
            throw Util.runtimeException("Can't remove struct key")
        )
        IPersistentMap newExt = ext.without(key)
        if (newExt == ext)
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr makeNew(_meta, def, vals, newExt)))
    )

    public Iterator iterator()
    (§
        (§ return (§ expr new Iterator()
        (§
            private ISeq ks = def.keys
            private Iterator extIter = (ext == nil) ? nil :or ext.iterator()

            public boolean hasNext()
            (§
                (§ return (§ expr ((ks != nil && ks.seq() != nil) || (extIter != nil && extIter.hasNext()))))
            )

            public Object next()
            (§
                if (ks != nil)
                (§
                    Object key = ks.first()
                    ks = ks.next()
                    (§ return (§ expr entryAt(key)))
                )
                else if (extIter != nil && extIter.hasNext())
                (§
                    (§ return (§ expr extIter.next()))
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )))
    )

    public int count()
    (§
        (§ return (§ expr vals.length + RT.count(ext)))
    )

    public ISeq seq()
    (§
        (§ return (§ expr new Seq(nil, def.keys, vals, 0, ext)))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr construct(def, nil)))
    )

    static class Seq extends ASeq
    (§
        final int i
        final ISeq keys
        final Object[] vals
        final IPersistentMap ext

        public Seq(IPersistentMap meta, ISeq keys, Object[] vals, int i, IPersistentMap ext)
        (§
            super(meta)
            this.i = i
            this.keys = keys
            this.vals = vals
            this.ext = ext
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            if (meta != _meta)
            (§
                (§ return (§ expr new Seq(meta, keys, vals, i, ext)))
            )
            (§ return (§ expr this))
        )

        public Object first()
        (§
            (§ return (§ expr MapEntry.create(keys.first(), vals[i])))
        )

        public ISeq next()
        (§
            if (i + 1 < vals.length)
            (§
                (§ return (§ expr new Seq(_meta, keys.next(), vals, i + 1, ext)))
            )
            (§ return (§ expr ext.seq()))
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(§ class public class PersistentTreeMap extends APersistentMap implements IObj, Reversible, Sorted, IKVReduce)
(§
    public final Comparator comp
    public final Node tree
    public final int _count
    final IPersistentMap _meta

    final static public PersistentTreeMap EMPTY = new PersistentTreeMap()

    static public IPersistentMap create(Map other)
    (§
        IPersistentMap ret = EMPTY
        for (Object o :in other.entrySet())
        (§
            Map.Entry e = (Entry) o
            ret = ret.assoc(e.getKey(), e.getValue())
        )
        (§ return (§ expr ret))
    )

    public PersistentTreeMap()
    (§
        this(RT.DEFAULT_COMPARATOR)
    )

    public PersistentTreeMap withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new PersistentTreeMap(meta, comp, tree, _count)))
    )

    private PersistentTreeMap(Comparator comp)
    (§
        this(nil, comp)
    )

    public PersistentTreeMap(IPersistentMap meta, Comparator comp)
    (§
        this.comp = comp
        this._meta = meta
        tree = nil
        _count = 0
    )

    PersistentTreeMap(IPersistentMap meta, Comparator comp, Node tree, int _count)
    (§
        this._meta = meta
        this.comp = comp
        this.tree = tree
        this._count = _count
    )

    static public PersistentTreeMap create(ISeq items)
    (§
        IPersistentMap ret = EMPTY
        for (  items != nil items = items.next().next())
        (§
            if (items.next() == nil)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))
            )
            ret = ret.assoc(items.first(), RT.second(items))
        )
        (§ return (§ expr (PersistentTreeMap) ret))
    )

    static public PersistentTreeMap create(Comparator comp, ISeq items)
    (§
        IPersistentMap ret = new PersistentTreeMap(comp)
        for (  items != nil items = items.next().next())
        (§
            if (items.next() == nil)
            (§
                throw new IllegalArgumentException(String.format("No value supplied for key: %s", items.first()))
            )
            ret = ret.assoc(items.first(), RT.second(items))
        )
        (§ return (§ expr (PersistentTreeMap) ret))
    )

    public boolean containsKey(Object key)
    (§
        (§ return (§ expr (entryAt(key) != nil)))
    )

    public boolean equals(Object obj)
    (§
        try
        (§
            (§ return (§ expr super.equals(obj)))
        )
        catch (ClassCastException e)
        (§
            (§ return (§ expr false))
        )
    )

    public boolean equiv(Object obj)
    (§
        try
        (§
            (§ return (§ expr super.equiv(obj)))
        )
        catch (ClassCastException e)
        (§
            (§ return (§ expr false))
        )
    )

    public PersistentTreeMap assocEx(Object key, Object val)
    (§
        Box found = new Box(nil)
        Node t = add(tree, key, val, found)
        if (t == nil) ;; nil == already contains key
        (§
            throw Util.runtimeException("Key already present")
        )
        (§ return (§ expr new PersistentTreeMap(comp, t.blacken(), _count + 1, meta())))
    )

    public PersistentTreeMap assoc(Object key, Object val)
    (§
        Box found = new Box(nil)
        Node t = add(tree, key, val, found)
        if (t == nil) ;; nil == already contains key
        (§
            Node foundNode = (Node) found.val
            if (foundNode.val() == val) ;; note only get same collection on identity of val, not equals()
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new PersistentTreeMap(comp, replace(tree, key, val), _count, meta())))
        )
        (§ return (§ expr new PersistentTreeMap(comp, t.blacken(), _count + 1, meta())))
    )

    public PersistentTreeMap without(Object key)
    (§
        Box found = new Box(nil)
        Node t = remove(tree, key, found)
        if (t == nil)
        (§
            if (found.val == nil) ;; nil == doesn't contain key
            (§
                (§ return (§ expr this))
            )
            ;; empty
            (§ return (§ expr new PersistentTreeMap(meta(), comp)))
        )
        (§ return (§ expr new PersistentTreeMap(comp, t.blacken(), _count - 1, meta())))
    )

    public ISeq seq()
    (§
        if (_count > 0)
        (§
            (§ return (§ expr Seq.create(tree, true, _count)))
        )
        (§ return (§ expr nil))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr new PersistentTreeMap(meta(), comp)))
    )

    public ISeq rseq()
    (§
        if (_count > 0)
        (§
            (§ return (§ expr Seq.create(tree, false, _count)))
        )
        (§ return (§ expr nil))
    )

    public Comparator comparator()
    (§
        (§ return (§ expr comp))
    )

    public Object entryKey(Object entry)
    (§
        (§ return (§ expr ((IMapEntry) entry).key()))
    )

    public ISeq seq(boolean ascending)
    (§
        if (_count > 0)
        (§
            (§ return (§ expr Seq.create(tree, ascending, _count)))
        )
        (§ return (§ expr nil))
    )

    public ISeq seqFrom(Object key, boolean ascending)
    (§
        if (_count > 0)
        (§
            ISeq stack = nil
            Node t = tree
            while (t != nil)
            (§
                int c = doCompare(key, t.key)
                if (c == 0)
                (§
                    stack = RT.cons(t, stack)
                    (§ return (§ expr new Seq(stack, ascending)))
                )
                else if (ascending)
                (§
                    if (c < 0)
                    (§
                        stack = RT.cons(t, stack)
                        t = t.left()
                    )
                    else
                    (§
                        t = t.right()
                    )
                )
                else
                (§
                    if (c > 0)
                    (§
                        stack = RT.cons(t, stack)
                        t = t.right()
                    )
                    else
                    (§
                        t = t.left()
                    )
                )
            )
            if (stack != nil)
            (§
                (§ return (§ expr new Seq(stack, ascending)))
            )
        )
        (§ return (§ expr nil))
    )

    public NodeIterator iterator()
    (§
        (§ return (§ expr new NodeIterator(tree, true)))
    )

    public Object kvreduce(IFn f, Object init)
    (§
        if (tree != nil)
        (§
            init = tree.kvreduce(f, init)
        )
        if (RT.isReduced(init))
        (§
            init = ((IDeref)init).deref()
        )
        (§ return (§ expr init))
    )

    public NodeIterator reverseIterator()
    (§
        (§ return (§ expr new NodeIterator(tree, false)))
    )

    public Iterator keys()
    (§
        (§ return (§ expr keys(iterator())))
    )

    public Iterator vals()
    (§
        (§ return (§ expr vals(iterator())))
    )

    public Iterator keys(NodeIterator it)
    (§
        (§ return (§ expr new KeyIterator(it)))
    )

    public Iterator vals(NodeIterator it)
    (§
        (§ return (§ expr new ValIterator(it)))
    )

    public Object minKey()
    (§
        Node t = min()
        (§ return (§ expr (t != nil) ? t.key :or nil))
    )

    public Node min()
    (§
        Node t = tree
        if (t != nil)
        (§
            while (t.left() != nil)
                t = t.left()
        )
        (§ return (§ expr t))
    )

    public Object maxKey()
    (§
        Node t = max()
        (§ return (§ expr (t != nil) ? t.key :or nil))
    )

    public Node max()
    (§
        Node t = tree
        if (t != nil)
        (§
            while (t.right() != nil)
                t = t.right()
        )
        (§ return (§ expr t))
    )

    public int depth()
    (§
        (§ return (§ expr depth(tree)))
    )

    int depth(Node t)
    (§
        if (t == nil)
        (§
            (§ return (§ expr 0))
        )
        (§ return (§ expr 1 + Math.max(depth(t.left()), depth(t.right()))))
    )

    public Object valAt(Object key, Object notFound)
    (§
        Node n = entryAt(key)
        (§ return (§ expr (n != nil) ? n.val() :or notFound))
    )

    public Object valAt(Object key)
    (§
        (§ return (§ expr valAt(key, nil)))
    )

    public int capacity()
    (§
        (§ return (§ expr _count))
    )

    public int count()
    (§
        (§ return (§ expr _count))
    )

    public Node entryAt(Object key)
    (§
        Node t = tree
        while (t != nil)
        (§
            int c = doCompare(key, t.key)
            if (c == 0)
            (§
                (§ return (§ expr t))
            )
            else if (c < 0)
            (§
                t = t.left()
            )
            else
            (§
                t = t.right()
            )
        )
        (§ return (§ expr t))
    )

    public int doCompare(Object k1, Object k2)
    (§
        (§ return (§ expr comp.compare(k1, k2)))
    )

    Node add(Node t, Object key, Object val, Box found)
    (§
        if (t == nil)
        (§
            if (val == nil)
            (§
                (§ return (§ expr new Red(key)))
            )
            (§ return (§ expr new RedVal(key, val)))
        )
        int c = doCompare(key, t.key)
        if (c == 0)
        (§
            found.val = t
            (§ return (§ expr nil))
        )
        Node ins = (c < 0) ? add(t.left(), key, val, found) :or add(t.right(), key, val, found)
        if (ins == nil) ;; found below
        (§
            (§ return (§ expr nil))
        )
        if (c < 0)
        (§
            (§ return (§ expr t.addLeft(ins)))
        )
        (§ return (§ expr t.addRight(ins)))
    )

    Node remove(Node t, Object key, Box found)
    (§
        if (t == nil)
        (§
            (§ return (§ expr nil)) ;; not found indicator
        )
        int c = doCompare(key, t.key)
        if (c == 0)
        (§
            found.val = t
            (§ return (§ expr append(t.left(), t.right())))
        )
        Node del = (c < 0) ? remove(t.left(), key, found) :or remove(t.right(), key, found)
        if (del == nil && found.val == nil) ;; not found below
        (§
            (§ return (§ expr nil))
        )
        if (c < 0)
        (§
            if (t.left() instanceof Black)
            (§
                (§ return (§ expr balanceLeftDel(t.key, t.val(), del, t.right())))
            )
            else
            (§
                (§ return (§ expr red(t.key, t.val(), del, t.right())))
            )
        )
        if (t.right() instanceof Black)
        (§
            (§ return (§ expr balanceRightDel(t.key, t.val(), t.left(), del)))
        )
        (§ return (§ expr red(t.key, t.val(), t.left(), del)))
    )

    static Node append(Node left, Node right)
    (§
        if (left == nil)
        (§
            (§ return (§ expr right))
        )
        else if (right == nil)
        (§
            (§ return (§ expr left))
        )
        else if (left instanceof Red)
        (§
            if (right instanceof Red)
            (§
                Node app = append(left.right(), right.left())
                if (app instanceof Red)
                (§
                    (§ return (§ expr red(app.key, app.val(), red(left.key, left.val(), left.left(), app.left()), red(right.key, right.val(), app.right(), right.right()))))
                )
                else
                (§
                    (§ return (§ expr red(left.key, left.val(), left.left(), red(right.key, right.val(), app, right.right()))))
                )
            )
            else
            (§
                (§ return (§ expr red(left.key, left.val(), left.left(), append(left.right(), right))))
            )
        )
        else if (right instanceof Red)
        (§
            (§ return (§ expr red(right.key, right.val(), append(left, right.left()), right.right())))
        )
        else ;; black/black
        (§
            Node app = append(left.right(), right.left())
            if (app instanceof Red)
            (§
                (§ return (§ expr red(app.key, app.val(), black(left.key, left.val(), left.left(), app.left()), black(right.key, right.val(), app.right(), right.right()))))
            )
            else
            (§
                (§ return (§ expr balanceLeftDel(left.key, left.val(), left.left(), black(right.key, right.val(), app, right.right()))))
            )
        )
    )

    static Node balanceLeftDel(Object key, Object val, Node del, Node right)
    (§
        if (del instanceof Red)
        (§
            (§ return (§ expr red(key, val, del.blacken(), right)))
        )
        else if (right instanceof Black)
        (§
            (§ return (§ expr rightBalance(key, val, del, right.redden())))
        )
        else if (right instanceof Red && right.left() instanceof Black)
        (§
            (§ return (§ expr red(right.left().key, right.left().val(), black(key, val, del, right.left().left()), rightBalance(right.key, right.val(), right.left().right(), right.right().redden()))))
        )
        else
        (§
            throw new UnsupportedOperationException("Invariant violation")
        )
    )

    static Node balanceRightDel(Object key, Object val, Node left, Node del)
    (§
        if (del instanceof Red)
        (§
            (§ return (§ expr red(key, val, left, del.blacken())))
        )
        else if (left instanceof Black)
        (§
            (§ return (§ expr leftBalance(key, val, left.redden(), del)))
        )
        else if (left instanceof Red && left.right() instanceof Black)
        (§
            (§ return (§ expr red(left.right().key, left.right().val(), leftBalance(left.key, left.val(), left.left().redden(), left.right().left()), black(key, val, left.right().right(), del))))
        )
        else
        (§
            throw new UnsupportedOperationException("Invariant violation")
        )
    )

    static Node leftBalance(Object key, Object val, Node ins, Node right)
    (§
        if (ins instanceof Red && ins.left() instanceof Red)
        (§
            (§ return (§ expr red(ins.key, ins.val(), ins.left().blacken(), black(key, val, ins.right(), right))))
        )
        else if (ins instanceof Red && ins.right() instanceof Red)
        (§
            (§ return (§ expr red(ins.right().key, ins.right().val(), black(ins.key, ins.val(), ins.left(), ins.right().left()), black(key, val, ins.right().right(), right))))
        )
        else
        (§
            (§ return (§ expr black(key, val, ins, right)))
        )
    )

    static Node rightBalance(Object key, Object val, Node left, Node ins)
    (§
        if (ins instanceof Red && ins.right() instanceof Red)
        (§
            (§ return (§ expr red(ins.key, ins.val(), black(key, val, left, ins.left()), ins.right().blacken())))
        )
        else if (ins instanceof Red && ins.left() instanceof Red)
        (§
            (§ return (§ expr red(ins.left().key, ins.left().val(), black(key, val, left, ins.left().left()), black(ins.key, ins.val(), ins.left().right(), ins.right()))))
        )
        else
        (§
            (§ return (§ expr black(key, val, left, ins)))
        )
    )

    Node replace(Node t, Object key, Object val)
    (§
        int c = doCompare(key, t.key)
        (§ return (§ expr t.replace(t.key, (c == 0) ? val :or t.val(), (c < 0) ? replace(t.left(), key, val) :or t.left(), (c > 0) ? replace(t.right(), key, val) :or t.right())))
    )

    PersistentTreeMap(Comparator comp, Node tree, int count, IPersistentMap meta)
    (§
        this._meta = meta
        this.comp = comp
        this.tree = tree
        this._count = count
    )

    static Red red(Object key, Object val, Node left, Node right)
    (§
        if (left == nil && right == nil)
        (§
            if (val == nil)
            (§
                (§ return (§ expr new Red(key)))
            )
            (§ return (§ expr new RedVal(key, val)))
        )
        if (val == nil)
        (§
            (§ return (§ expr new RedBranch(key, left, right)))
        )
        (§ return (§ expr new RedBranchVal(key, val, left, right)))
    )

    static Black black(Object key, Object val, Node left, Node right)
    (§
        if (left == nil && right == nil)
        (§
            if (val == nil)
            (§
                (§ return (§ expr new Black(key)))
            )
            (§ return (§ expr new BlackVal(key, val)))
        )
        if (val == nil)
        (§
            (§ return (§ expr new BlackBranch(key, left, right)))
        )
        (§ return (§ expr new BlackBranchVal(key, val, left, right)))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )

    static abstract class Node extends AMapEntry
    (§
        final Object key

        Node(Object key)
        (§
            this.key = key
        )

        public Object key()
        (§
            (§ return (§ expr key))
        )

        public Object val()
        (§
            (§ return (§ expr nil))
        )

        public Object getKey()
        (§
            (§ return (§ expr key()))
        )

        public Object getValue()
        (§
            (§ return (§ expr val()))
        )

        Node left()
        (§
            (§ return (§ expr nil))
        )

        Node right()
        (§
            (§ return (§ expr nil))
        )

        abstract Node addLeft(Node ins)

        abstract Node addRight(Node ins)

        abstract Node removeLeft(Node del)

        abstract Node removeRight(Node del)

        abstract Node blacken()

        abstract Node redden()

        Node balanceLeft(Node parent)
        (§
            (§ return (§ expr black(parent.key, parent.val(), this, parent.right())))
        )

        Node balanceRight(Node parent)
        (§
            (§ return (§ expr black(parent.key, parent.val(), parent.left(), this)))
        )

        abstract Node replace(Object key, Object val, Node left, Node right)

        public Object kvreduce(IFn f, Object init)
        (§
            if (left() != nil)
            (§
                init = left().kvreduce(f, init)
                if (RT.isReduced(init))
                (§
                    (§ return (§ expr init))
                )
            )
            init = f.invoke(init, key(), val())
            if (RT.isReduced(init))
            (§
                (§ return (§ expr init))
            )

            if (right() != nil)
            (§
                init = right().kvreduce(f, init)
            )
            (§ return (§ expr init))
        )
    )

    static class Black extends Node
    (§
        public Black(Object key)
        (§
            super(key)
        )

        Node addLeft(Node ins)
        (§
            (§ return (§ expr ins.balanceLeft(this)))
        )

        Node addRight(Node ins)
        (§
            (§ return (§ expr ins.balanceRight(this)))
        )

        Node removeLeft(Node del)
        (§
            (§ return (§ expr balanceLeftDel(key, val(), del, right())))
        )

        Node removeRight(Node del)
        (§
            (§ return (§ expr balanceRightDel(key, val(), left(), del)))
        )

        Node blacken()
        (§
            (§ return (§ expr this))
        )

        Node redden()
        (§
            (§ return (§ expr new Red(key)))
        )

        Node replace(Object key, Object val, Node left, Node right)
        (§
            (§ return (§ expr black(key, val, left, right)))
        )
    )

    static class BlackVal extends Black
    (§
        final Object val

        public BlackVal(Object key, Object val)
        (§
            super(key)
            this.val = val
        )

        public Object val()
        (§
            (§ return (§ expr val))
        )

        Node redden()
        (§
            (§ return (§ expr new RedVal(key, val)))
        )
    )

    static class BlackBranch extends Black
    (§
        final Node left

        final Node right

        public BlackBranch(Object key, Node left, Node right)
        (§
            super(key)
            this.left = left
            this.right = right
        )

        public Node left()
        (§
            (§ return (§ expr left))
        )

        public Node right()
        (§
            (§ return (§ expr right))
        )

        Node redden()
        (§
            (§ return (§ expr new RedBranch(key, left, right)))
        )
    )

    static class BlackBranchVal extends BlackBranch
    (§
        final Object val

        public BlackBranchVal(Object key, Object val, Node left, Node right)
        (§
            super(key, left, right)
            this.val = val
        )

        public Object val()
        (§
            (§ return (§ expr val))
        )

        Node redden()
        (§
            (§ return (§ expr new RedBranchVal(key, val, left, right)))
        )
    )

    static class Red extends Node
    (§
        public Red(Object key)
        (§
            super(key)
        )

        Node addLeft(Node ins)
        (§
            (§ return (§ expr red(key, val(), ins, right())))
        )

        Node addRight(Node ins)
        (§
            (§ return (§ expr red(key, val(), left(), ins)))
        )

        Node removeLeft(Node del)
        (§
            (§ return (§ expr red(key, val(), del, right())))
        )

        Node removeRight(Node del)
        (§
            (§ return (§ expr red(key, val(), left(), del)))
        )

        Node blacken()
        (§
            (§ return (§ expr new Black(key)))
        )

        Node redden()
        (§
            throw new UnsupportedOperationException("Invariant violation")
        )

        Node replace(Object key, Object val, Node left, Node right)
        (§
            (§ return (§ expr red(key, val, left, right)))
        )
    )

    static class RedVal extends Red
    (§
        final Object val

        public RedVal(Object key, Object val)
        (§
            super(key)
            this.val = val
        )

        public Object val()
        (§
            (§ return (§ expr val))
        )

        Node blacken()
        (§
            (§ return (§ expr new BlackVal(key, val)))
        )
    )

    static class RedBranch extends Red
    (§
        final Node left

        final Node right

        public RedBranch(Object key, Node left, Node right)
        (§
            super(key)
            this.left = left
            this.right = right
        )

        public Node left()
        (§
            (§ return (§ expr left))
        )

        public Node right()
        (§
            (§ return (§ expr right))
        )

        Node balanceLeft(Node parent)
        (§
            if (left instanceof Red)
            (§
                (§ return (§ expr red(key, val(), left.blacken(), black(parent.key, parent.val(), right, parent.right()))))
            )
            else if (right instanceof Red)
            (§
                (§ return (§ expr red(right.key, right.val(), black(key, val(), left, right.left()), black(parent.key, parent.val(), right.right(), parent.right()))))
            )
            else
            (§
                (§ return (§ expr super.balanceLeft(parent)))
            )
        )

        Node balanceRight(Node parent)
        (§
            if (right instanceof Red)
            (§
                (§ return (§ expr red(key, val(), black(parent.key, parent.val(), parent.left(), left), right.blacken())))
            )
            else if (left instanceof Red)
            (§
                (§ return (§ expr red(left.key, left.val(), black(parent.key, parent.val(), parent.left(), left.left()), black(key, val(), left.right(), right))))
            )
            else
            (§
                (§ return (§ expr super.balanceRight(parent)))
            )
        )

        Node blacken()
        (§
            (§ return (§ expr new BlackBranch(key, left, right)))
        )
    )

    static class RedBranchVal extends RedBranch
    (§
        final Object val

        public RedBranchVal(Object key, Object val, Node left, Node right)
        (§
            super(key, left, right)
            this.val = val
        )

        public Object val()
        (§
            (§ return (§ expr val))
        )

        Node blacken()
        (§
            (§ return (§ expr new BlackBranchVal(key, val, left, right)))
        )
    )

    static public class Seq extends ASeq
    (§
        final ISeq stack
        final boolean asc
        final int cnt

        public Seq(ISeq stack, boolean asc)
        (§
            this.stack = stack
            this.asc = asc
            this.cnt = -1
        )

        public Seq(ISeq stack, boolean asc, int cnt)
        (§
            this.stack = stack
            this.asc = asc
            this.cnt = cnt
        )

        Seq(IPersistentMap meta, ISeq stack, boolean asc, int cnt)
        (§
            super(meta)
            this.stack = stack
            this.asc = asc
            this.cnt = cnt
        )

        static Seq create(Node t, boolean asc, int cnt)
        (§
            (§ return (§ expr new Seq(push(t, nil, asc), asc, cnt)))
        )

        static ISeq push(Node t, ISeq stack, boolean asc)
        (§
            while (t != nil)
            (§
                stack = RT.cons(t, stack)
                t = asc ? t.left() :or t.right()
            )
            (§ return (§ expr stack))
        )

        public Object first()
        (§
            (§ return (§ expr stack.first()))
        )

        public ISeq next()
        (§
            Node t = (Node) stack.first()
            ISeq nextstack = push(asc ? t.right() :or t.left(), stack.next(), asc)
            if (nextstack != nil)
            (§
                (§ return (§ expr new Seq(nextstack, asc, cnt - 1)))
            )
            (§ return (§ expr nil))
        )

        public int count()
        (§
            if (cnt < 0)
            (§
                (§ return (§ expr super.count()))
            )
            (§ return (§ expr cnt))
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            (§ return (§ expr new Seq(meta, stack, asc, cnt)))
        )
    )

    static public class NodeIterator implements Iterator
    (§
        Stack stack = new Stack()
        boolean asc

        NodeIterator(Node t, boolean asc)
        (§
            this.asc = asc
            push(t)
        )

        void push(Node t)
        (§
            while (t != nil)
            (§
                stack.push(t)
                t = asc ? t.left() :or t.right()
            )
        )

        public boolean hasNext()
        (§
            (§ return (§ expr !stack.isEmpty()))
        )

        public Object next()
        (§
            try
            (§
                Node t = (Node) stack.pop()
                push(asc ? t.right() :or t.left())
                (§ return (§ expr t))
            )
            catch (EmptyStackException e)
            (§
                throw new NoSuchElementException()
            )
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    static class KeyIterator implements Iterator
    (§
        NodeIterator it

        KeyIterator(NodeIterator it)
        (§
            this.it = it
        )

        public boolean hasNext()
        (§
            (§ return (§ expr it.hasNext()))
        )

        public Object next()
        (§
            (§ return (§ expr ((Node) it.next()).key))
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )

    static class ValIterator implements Iterator
    (§
        NodeIterator it

        ValIterator(NodeIterator it)
        (§
            this.it = it
        )

        public boolean hasNext()
        (§
            (§ return (§ expr it.hasNext()))
        )

        public Object next()
        (§
            (§ return (§ expr ((Node) it.next()).val()))
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(§ class public class PersistentTreeSet extends APersistentSet implements IObj, Reversible, Sorted)
(§
    static public final PersistentTreeSet EMPTY = new PersistentTreeSet(nil, PersistentTreeMap.EMPTY)

    final IPersistentMap _meta

    static public PersistentTreeSet create(ISeq items)
    (§
        PersistentTreeSet ret = EMPTY
        for (  items != nil items = items.next())
        (§
            ret = (PersistentTreeSet) ret.cons(items.first())
        )
        (§ return (§ expr ret))
    )

    static public PersistentTreeSet create(Comparator comp, ISeq items)
    (§
        PersistentTreeSet ret = new PersistentTreeSet(nil, new PersistentTreeMap(nil, comp))
        for (  items != nil items = items.next())
        (§
            ret = (PersistentTreeSet) ret.cons(items.first())
        )
        (§ return (§ expr ret))
    )

    PersistentTreeSet(IPersistentMap meta, IPersistentMap impl)
    (§
        super(impl)
        this._meta = meta
    )

    public boolean equals(Object obj)
    (§
        try
        (§
            (§ return (§ expr super.equals(obj)))
        )
        catch (ClassCastException e)
        (§
            (§ return (§ expr false))
        )
    )

    public boolean equiv(Object obj)
    (§
        try
        (§
            (§ return (§ expr super.equiv(obj)))
        )
        catch (ClassCastException e)
        (§
            (§ return (§ expr false))
        )
    )

    public IPersistentSet disjoin(Object key)
    (§
        if (contains(key))
        (§
            (§ return (§ expr new PersistentTreeSet(meta(), impl.without(key))))
        )
        (§ return (§ expr this))
    )

    public IPersistentSet cons(Object o)
    (§
        if (contains(o))
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new PersistentTreeSet(meta(), impl.assoc(o, o))))
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr new PersistentTreeSet(meta(), (PersistentTreeMap)impl.empty())))
    )

    public ISeq rseq()
    (§
        (§ return (§ expr APersistentMap.KeySeq.create(((Reversible) impl).rseq())))
    )

    public PersistentTreeSet withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new PersistentTreeSet(meta, impl)))
    )

    public Comparator comparator()
    (§
        (§ return (§ expr ((Sorted)impl).comparator()))
    )

    public Object entryKey(Object entry)
    (§
        (§ return (§ expr entry))
    )

    public ISeq seq(boolean ascending)
    (§
        PersistentTreeMap m = (PersistentTreeMap) impl
        (§ return (§ expr RT.keys(m.seq(ascending))))
    )

    public ISeq seqFrom(Object key, boolean ascending)
    (§
        PersistentTreeMap m = (PersistentTreeMap) impl
        (§ return (§ expr RT.keys(m.seqFrom(key, ascending))))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.io.Serializable)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(§ class public class PersistentVector extends APersistentVector implements IObj, IEditableCollection, IReduce, IKVReduce)
(§
    public static class Node implements Serializable
    (§
        transient public final AtomicReference<Thread> edit
        public final Object[] array

        public Node(AtomicReference<Thread> edit, Object[] array)
        (§
            this.edit = edit
            this.array = array
        )

        Node(AtomicReference<Thread> edit)
        (§
            this.edit = edit
            this.array = new Object[32]
        )
    )

    final static AtomicReference<Thread> NOEDIT = new AtomicReference<Thread>(nil)
    public final static Node EMPTY_NODE = new Node(NOEDIT, new Object[32])

    final int cnt
    public final int shift
    public final Node root
    public final Object[] tail
    final IPersistentMap _meta

    public final static PersistentVector EMPTY = new PersistentVector(0, 5, EMPTY_NODE, new Object[] (§))

    private static final IFn TRANSIENT_VECTOR_CONJ = new AFn()
    (§
        public Object invoke(Object coll, Object val)
        (§
            (§ return (§ expr ((ITransientVector)coll).conj(val)))
        )
        public Object invoke(Object coll)
        (§
            (§ return (§ expr coll))
        )
    )

    static public PersistentVector adopt(Object [] items)
    (§
        (§ return (§ expr new PersistentVector(items.length, 5, EMPTY_NODE, items)))
    )

    static public PersistentVector create(IReduceInit items)
    (§
        TransientVector ret = EMPTY.asTransient()
        items.reduce(TRANSIENT_VECTOR_CONJ, ret)
        (§ return (§ expr ret.persistent()))
    )

    static public PersistentVector create(ISeq items)
    (§
        Object[] arr = new Object[32]
        int i = 0
        for (  items != nil && i < 32 items = items.next())
        (§
            arr[i++] = items.first()
        )

        if (items != nil) ;; >32, construct with array directly
        (§
            PersistentVector start = new PersistentVector(32, 5, EMPTY_NODE, arr)
            TransientVector ret = start.asTransient()
            for (  items != nil items = items.next())
            (§
                ret = ret.conj(items.first())
            )
            (§ return (§ expr ret.persistent()))
        )
        else if (i == 32) ;; exactly 32, skip copy
        (§
            (§ return (§ expr new PersistentVector(32, 5, EMPTY_NODE, arr)))
        )
        else ;; <32, copy to minimum array and construct
        (§
            Object[] arr2 = new Object[i]
            System.arraycopy(arr, 0, arr2, 0, i)
            (§ return (§ expr new PersistentVector(i, 5, EMPTY_NODE, arr2)))
        )
    )

    static public PersistentVector create(List list)
    (§
        int size = list.size()
        if (size <= 32)
        (§
            (§ return (§ expr new PersistentVector(size, 5, PersistentVector.EMPTY_NODE, list.toArray())))
        )

        TransientVector ret = EMPTY.asTransient()
        for (int i = 0 i < size i++)
        (§
            ret = ret.conj(list.get(i))
        )
        (§ return (§ expr ret.persistent()))
    )

    static public PersistentVector create(Iterable items)
    (§
        ;; optimize common case
        if (items instanceof ArrayList)
        (§
            (§ return (§ expr create((ArrayList)items)))
        )

        Iterator iter = items.iterator()
        TransientVector ret = EMPTY.asTransient()
        while (iter.hasNext())
            ret = ret.conj(iter.next())
        (§ return (§ expr ret.persistent()))
    )

    static public PersistentVector create(Object... items)
    (§
        TransientVector ret = EMPTY.asTransient()
        for (Object item :in items)
        (§
            ret = ret.conj(item)
        )
        (§ return (§ expr ret.persistent()))
    )

    PersistentVector(int cnt, int shift, Node root, Object[] tail)
    (§
        this._meta = nil
        this.cnt = cnt
        this.shift = shift
        this.root = root
        this.tail = tail
    )

    PersistentVector(IPersistentMap meta, int cnt, int shift, Node root, Object[] tail)
    (§
        this._meta = meta
        this.cnt = cnt
        this.shift = shift
        this.root = root
        this.tail = tail
    )

    public TransientVector asTransient()
    (§
        (§ return (§ expr new TransientVector(this)))
    )

    final int tailoff()
    (§
        if (cnt < 32)
        (§
            (§ return (§ expr 0))
        )
        (§ return (§ expr ((cnt - 1) >>> 5) << 5))
    )

    public Object[] arrayFor(int i)
    (§
        if (i >= 0 && i < cnt)
        (§
            if (i >= tailoff())
            (§
                (§ return (§ expr tail))
            )
            Node node = root
            for (int level = shift level > 0 level -= 5)
            (§
                node = (Node) node.array[(i >>> level) & 0x01f]
            )
            (§ return (§ expr node.array))
        )
        throw new IndexOutOfBoundsException()
    )

    public Object nth(int i)
    (§
        Object[] node = arrayFor(i)
        (§ return (§ expr node[i & 0x01f]))
    )

    public Object nth(int i, Object notFound)
    (§
        if (i >= 0 && i < cnt)
        (§
            (§ return (§ expr nth(i)))
        )
        (§ return (§ expr notFound))
    )

    public PersistentVector assocN(int i, Object val)
    (§
        if (i >= 0 && i < cnt)
        (§
            if (i >= tailoff())
            (§
                Object[] newTail = new Object[tail.length]
                System.arraycopy(tail, 0, newTail, 0, tail.length)
                newTail[i & 0x01f] = val

                (§ return (§ expr new PersistentVector(meta(), cnt, shift, root, newTail)))
            )

            (§ return (§ expr new PersistentVector(meta(), cnt, shift, doAssoc(shift, root, i, val), tail)))
        )
        if (i == cnt)
        (§
            (§ return (§ expr cons(val)))
        )
        throw new IndexOutOfBoundsException()
    )

    private static Node doAssoc(int level, Node node, int i, Object val)
    (§
        Node ret = new Node(node.edit, node.array.clone())
        if (level == 0)
        (§
            ret.array[i & 0x01f] = val
        )
        else
        (§
            int subidx = (i >>> level) & 0x01f
            ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val)
        )
        (§ return (§ expr ret))
    )

    public int count()
    (§
        (§ return (§ expr cnt))
    )

    public PersistentVector withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new PersistentVector(meta, cnt, shift, root, tail)))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )

    public PersistentVector cons(Object val)
    (§
        ;; room in tail?
        if (cnt - tailoff() < 32)
        (§
            Object[] newTail = new Object[tail.length + 1]
            System.arraycopy(tail, 0, newTail, 0, tail.length)
            newTail[tail.length] = val
            (§ return (§ expr new PersistentVector(meta(), cnt + 1, shift, root, newTail)))
        )
        ;; full tail, push into tree
        Node newroot
        Node tailnode = new Node(root.edit, tail)
        int newshift = shift
        ;; overflow root?
        if ((cnt >>> 5) > (1 << shift))
        (§
            newroot = new Node(root.edit)
            newroot.array[0] = root
            newroot.array[1] = newPath(root.edit, shift, tailnode)
            newshift += 5
        )
        else
        (§
            newroot = pushTail(shift, root, tailnode)
        )
        (§ return (§ expr new PersistentVector(meta(), cnt + 1, newshift, newroot, new Object[] (§ val ))))
    )

    private Node pushTail(int level, Node parent, Node tailnode)
    (§
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        int subidx = ((cnt - 1) >>> level) & 0x01f
        Node ret = new Node(parent.edit, parent.array.clone())
        Node nodeToInsert
        if (level == 5)
        (§
            nodeToInsert = tailnode
        )
        else
        (§
            Node child = (Node) parent.array[subidx]
            nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode)
        )
        ret.array[subidx] = nodeToInsert
        (§ return (§ expr ret))
    )

    private static Node newPath(AtomicReference<Thread> edit, int level, Node node)
    (§
        if (level == 0)
        (§
            (§ return (§ expr node))
        )
        Node ret = new Node(edit)
        ret.array[0] = newPath(edit, level - 5, node)
        (§ return (§ expr ret))
    )

    public IChunkedSeq chunkedSeq()
    (§
        if (count() == 0)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr new ChunkedSeq(this, 0, 0)))
    )

    public ISeq seq()
    (§
        (§ return (§ expr chunkedSeq()))
    )

    (§ anno @Override)
    Iterator rangedIterator(final int start, final int end)
    (§
        (§ return (§ expr new Iterator()
        (§
            int i = start
            int base = i - (i%32)
            Object[] array = (start < count()) ? arrayFor(i) :or nil

            public boolean hasNext()
            (§
                (§ return (§ expr (i < end)))
            )

            public Object next()
            (§
                if (i < end)
                (§
                    if (i - base == 32)
                    (§
                        array = arrayFor(i)
                        base += 32
                    )
                    (§ return (§ expr array[i++ & 0x01f]))
                )
                else
                (§
                    throw new NoSuchElementException()
                )
            )

            public void remove()
            (§
                throw new UnsupportedOperationException()
            )
        )))
    )

    public Iterator iterator()
    (§
        (§ return (§ expr rangedIterator(0, count())))
    )

    public Object reduce(IFn f)
    (§
        Object init
        if (cnt > 0)
        (§
            init = arrayFor(0)[0]
        )
        else
        (§
            (§ return (§ expr f.invoke()))
        )
        int step = 0
        for (int i = 0 i < cnt i += step)
        (§
            Object[] array = arrayFor(i)
            for (int j = (i == 0) ? 1 :or 0 j < array.length ++j)
            (§
                init = f.invoke(init, array[j])
                if (RT.isReduced(init))
                (§
                    (§ return (§ expr ((IDeref)init).deref()))
                )
            )
            step = array.length
        )
        (§ return (§ expr init))
    )

    public Object reduce(IFn f, Object init)
    (§
        int step = 0
        for (int i = 0 i < cnt i += step)
        (§
            Object[] array = arrayFor(i)
            for (int j = 0 j < array.length ++j)
            (§
                init = f.invoke(init, array[j])
                if (RT.isReduced(init))
                (§
                    (§ return (§ expr ((IDeref)init).deref()))
                )
            )
            step = array.length
        )
        (§ return (§ expr init))
    )

    public Object kvreduce(IFn f, Object init)
    (§
        int step = 0
        for (int i = 0 i < cnt i += step)
        (§
            Object[] array = arrayFor(i)
            for (int j = 0 j < array.length ++j)
            (§
                init = f.invoke(init, j + i, array[j])
                if (RT.isReduced(init))
                (§
                    (§ return (§ expr ((IDeref)init).deref()))
                )
            )
            step = array.length
        )
        (§ return (§ expr init))
    )

    static public final class ChunkedSeq extends ASeq implements IChunkedSeq, Counted
    (§
        public final PersistentVector vec
        final Object[] node
        final int i
        public final int offset

        public ChunkedSeq(PersistentVector vec, int i, int offset)
        (§
            this.vec = vec
            this.i = i
            this.offset = offset
            this.node = vec.arrayFor(i)
        )

        ChunkedSeq(IPersistentMap meta, PersistentVector vec, Object[] node, int i, int offset)
        (§
            super(meta)
            this.vec = vec
            this.node = node
            this.i = i
            this.offset = offset
        )

        ChunkedSeq(PersistentVector vec, Object[] node, int i, int offset)
        (§
            this.vec = vec
            this.node = node
            this.i = i
            this.offset = offset
        )

        public IChunk chunkedFirst()
        (§
            (§ return (§ expr new ArrayChunk(node, offset)))
        )

        public ISeq chunkedNext()
        (§
            if (i + node.length < vec.cnt)
            (§
                (§ return (§ expr new ChunkedSeq(vec, i + node.length, 0)))
            )
            (§ return (§ expr nil))
        )

        public ISeq chunkedMore()
        (§
            ISeq s = chunkedNext()
            if (s == nil)
            (§
                (§ return (§ expr PersistentList.EMPTY))
            )
            (§ return (§ expr s))
        )

        public Obj withMeta(IPersistentMap meta)
        (§
            if (meta == this._meta)
            (§
                (§ return (§ expr this))
            )
            (§ return (§ expr new ChunkedSeq(meta, vec, node, i, offset)))
        )

        public Object first()
        (§
            (§ return (§ expr node[offset]))
        )

        public ISeq next()
        (§
            if (offset + 1 < node.length)
            (§
                (§ return (§ expr new ChunkedSeq(vec, node, i, offset + 1)))
            )
            (§ return (§ expr chunkedNext()))
        )

        public int count()
        (§
            (§ return (§ expr vec.cnt - (i + offset)))
        )
    )

    public IPersistentCollection empty()
    (§
        (§ return (§ expr EMPTY.withMeta(meta())))
    )

    public PersistentVector pop()
    (§
        if (cnt == 0)
        (§
            throw new IllegalStateException("Can't pop empty vector")
        )
        if (cnt == 1)
        (§
            (§ return (§ expr EMPTY.withMeta(meta())))
        )
        if (cnt - tailoff() > 1)
        (§
            Object[] newTail = new Object[tail.length - 1]
            System.arraycopy(tail, 0, newTail, 0, newTail.length)
            (§ return (§ expr new PersistentVector(meta(), cnt - 1, shift, root, newTail)))
        )
        Object[] newtail = arrayFor(cnt - 2)

        Node newroot = popTail(shift, root)
        int newshift = shift
        if (newroot == nil)
        (§
            newroot = EMPTY_NODE
        )
        if (shift > 5 && newroot.array[1] == nil)
        (§
            newroot = (Node) newroot.array[0]
            newshift -= 5
        )
        (§ return (§ expr new PersistentVector(meta(), cnt - 1, newshift, newroot, newtail)))
    )

    private Node popTail(int level, Node node)
    (§
        int subidx = ((cnt - 2) >>> level) & 0x01f
        if (level > 5)
        (§
            Node newchild = popTail(level - 5, (Node) node.array[subidx])
            if (newchild == nil && subidx == 0)
            (§
                (§ return (§ expr nil))
            )
            else
            (§
                Node ret = new Node(root.edit, node.array.clone())
                ret.array[subidx] = newchild
                (§ return (§ expr ret))
            )
        )
        else if (subidx == 0)
        (§
            (§ return (§ expr nil))
        )
        else
        (§
            Node ret = new Node(root.edit, node.array.clone())
            ret.array[subidx] = nil
            (§ return (§ expr ret))
        )
    )

    static final class TransientVector extends AFn implements ITransientVector, ITransientAssociative2, Counted
    (§
        volatile int cnt
        volatile int shift
        volatile Node root
        volatile Object[] tail

        TransientVector(int cnt, int shift, Node root, Object[] tail)
        (§
            this.cnt = cnt
            this.shift = shift
            this.root = root
            this.tail = tail
        )

        TransientVector(PersistentVector v)
        (§
            this(v.cnt, v.shift, editableRoot(v.root), editableTail(v.tail))
        )

        public int count()
        (§
            ensureEditable()
            (§ return (§ expr cnt))
        )

        Node ensureEditable(Node node)
        (§
            if (node.edit == root.edit)
            (§
                (§ return (§ expr node))
            )
            (§ return (§ expr new Node(root.edit, node.array.clone())))
        )

        void ensureEditable()
        (§
            if (root.edit.get() == nil)
            (§
                throw new IllegalAccessError("Transient used after persistent! call")
            )
        )

        static Node editableRoot(Node node)
        (§
            (§ return (§ expr new Node(new AtomicReference<Thread>(Thread.currentThread()), node.array.clone())))
        )

        public PersistentVector persistent()
        (§
            ensureEditable()
            root.edit.set(nil)
            Object[] trimmedTail = new Object[cnt - tailoff()]
            System.arraycopy(tail, 0, trimmedTail, 0, trimmedTail.length)
            (§ return (§ expr new PersistentVector(cnt, shift, root, trimmedTail)))
        )

        static Object[] editableTail(Object[] tl)
        (§
            Object[] ret = new Object[32]
            System.arraycopy(tl, 0, ret, 0, tl.length)
            (§ return (§ expr ret))
        )

        public TransientVector conj(Object val)
        (§
            ensureEditable()
            int i = cnt
            ;; room in tail?
            if (i - tailoff() < 32)
            (§
                tail[i & 0x01f] = val
                ++cnt
                (§ return (§ expr this))
            )
            ;; full tail, push into tree
            Node newroot
            Node tailnode = new Node(root.edit, tail)
            tail = new Object[32]
            tail[0] = val
            int newshift = shift
            ;; overflow root?
            if ((cnt >>> 5) > (1 << shift))
            (§
                newroot = new Node(root.edit)
                newroot.array[0] = root
                newroot.array[1] = newPath(root.edit, shift, tailnode)
                newshift += 5
            )
            else
            (§
                newroot = pushTail(shift, root, tailnode)
            )
            root = newroot
            shift = newshift
            ++cnt
            (§ return (§ expr this))
        )

        private Node pushTail(int level, Node parent, Node tailnode)
        (§
            ;; if parent is leaf, insert node,
            ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
            ;; else alloc new path
            ;; return nodeToInsert placed in parent
            parent = ensureEditable(parent)
            int subidx = ((cnt - 1) >>> level) & 0x01f
            Node ret = parent
            Node nodeToInsert
            if (level == 5)
            (§
                nodeToInsert = tailnode
            )
            else
            (§
                Node child = (Node) parent.array[subidx]
                nodeToInsert = (child != nil) ? pushTail(level - 5, child, tailnode) :or newPath(root.edit, level - 5, tailnode)
            )
            ret.array[subidx] = nodeToInsert
            (§ return (§ expr ret))
        )

        final private int tailoff()
        (§
            if (cnt < 32)
            (§
                (§ return (§ expr 0))
            )
            (§ return (§ expr ((cnt - 1) >>> 5) << 5))
        )

        private Object[] arrayFor(int i)
        (§
            if (i >= 0 && i < cnt)
            (§
                if (i >= tailoff())
                (§
                    (§ return (§ expr tail))
                )
                Node node = root
                for (int level = shift level > 0 level -= 5)
                (§
                    node = (Node) node.array[(i >>> level) & 0x01f]
                )
                (§ return (§ expr node.array))
            )
            throw new IndexOutOfBoundsException()
        )

        private Object[] editableArrayFor(int i)
        (§
            if (i >= 0 && i < cnt)
            (§
                if (i >= tailoff())
                (§
                    (§ return (§ expr tail))
                )
                Node node = root
                for (int level = shift level > 0 level -= 5)
                (§
                    node = ensureEditable((Node) node.array[(i >>> level) & 0x01f])
                )
                (§ return (§ expr node.array))
            )
            throw new IndexOutOfBoundsException()
        )

        public Object valAt(Object key)
        (§
            ;; note - relies on ensureEditable in 2-arg valAt
            (§ return (§ expr valAt(key, nil)))
        )

        public Object valAt(Object key, Object notFound)
        (§
            ensureEditable()
            if (Util.isInteger(key))
            (§
                int i = ((Number) key).intValue()
                if (i >= 0 && i < cnt)
                (§
                    (§ return (§ expr nth(i)))
                )
            )
            (§ return (§ expr notFound))
        )

        private static final Object NOT_FOUND = new Object()

        public final boolean containsKey(Object key)
        (§
            (§ return (§ expr (valAt(key, NOT_FOUND) != NOT_FOUND)))
        )

        public final IMapEntry entryAt(Object key)
        (§
            Object v = valAt(key, NOT_FOUND)
            if (v != NOT_FOUND)
            (§
                (§ return (§ expr MapEntry.create(key, v)))
            )
            (§ return (§ expr nil))
        )

        public Object invoke(Object arg1)
        (§
            ;; note - relies on ensureEditable in nth
            if (Util.isInteger(arg1))
            (§
                (§ return (§ expr nth(((Number) arg1).intValue())))
            )
            throw new IllegalArgumentException("Key must be integer")
        )

        public Object nth(int i)
        (§
            ensureEditable()
            Object[] node = arrayFor(i)
            (§ return (§ expr node[i & 0x01f]))
        )

        public Object nth(int i, Object notFound)
        (§
            if (i >= 0 && i < count())
            (§
                (§ return (§ expr nth(i)))
            )
            (§ return (§ expr notFound))
        )

        public TransientVector assocN(int i, Object val)
        (§
            ensureEditable()
            if (i >= 0 && i < cnt)
            (§
                if (i >= tailoff())
                (§
                    tail[i & 0x01f] = val
                    (§ return (§ expr this))
                )

                root = doAssoc(shift, root, i, val)
                (§ return (§ expr this))
            )
            if (i == cnt)
            (§
                (§ return (§ expr conj(val)))
            )
            throw new IndexOutOfBoundsException()
        )

        public TransientVector assoc(Object key, Object val)
        (§
            ;; note - relies on ensureEditable in assocN
            if (Util.isInteger(key))
            (§
                int i = ((Number) key).intValue()
                (§ return (§ expr assocN(i, val)))
            )
            throw new IllegalArgumentException("Key must be integer")
        )

        private Node doAssoc(int level, Node node, int i, Object val)
        (§
            node = ensureEditable(node)
            Node ret = node
            if (level == 0)
            (§
                ret.array[i & 0x01f] = val
            )
            else
            (§
                int subidx = (i >>> level) & 0x01f
                ret.array[subidx] = doAssoc(level - 5, (Node) node.array[subidx], i, val)
            )
            (§ return (§ expr ret))
        )

        public TransientVector pop()
        (§
            ensureEditable()
            if (cnt == 0)
            (§
                throw new IllegalStateException("Can't pop empty vector")
            )
            if (cnt == 1)
            (§
                cnt = 0
                (§ return (§ expr this))
            )
            int i = cnt - 1
            ;; pop in tail?
            if ((i & 0x01f) > 0)
            (§
                --cnt
                (§ return (§ expr this))
            )

            Object[] newtail = editableArrayFor(cnt - 2)

            Node newroot = popTail(shift, root)
            int newshift = shift
            if (newroot == nil)
            (§
                newroot = new Node(root.edit)
            )
            if (shift > 5 && newroot.array[1] == nil)
            (§
                newroot = ensureEditable((Node) newroot.array[0])
                newshift -= 5
            )
            root = newroot
            shift = newshift
            --cnt
            tail = newtail
            (§ return (§ expr this))
        )

        private Node popTail(int level, Node node)
        (§
            node = ensureEditable(node)
            int subidx = ((cnt - 2) >>> level) & 0x01f
            if (level > 5)
            (§
                Node newchild = popTail(level - 5, (Node) node.array[subidx])
                if (newchild == nil && subidx == 0)
                (§
                    (§ return (§ expr nil))
                )
                else
                (§
                    Node ret = node
                    ret.array[subidx] = newchild
                    (§ return (§ expr ret))
                )
            )
            else if (subidx == 0)
            (§
                (§ return (§ expr nil))
            )
            else
            (§
                Node ret = node
                ret.array[subidx] = nil
                (§ return (§ expr ret))
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(§ class public class ProxyHandler implements InvocationHandler)
(§
    ;; method-name-string->fn
    final IPersistentMap fns

    public ProxyHandler(IPersistentMap fns)
    (§
        this.fns = fns
    )

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
    (§
        Class rt = method.getReturnType()
        IFn fn = (IFn) fns.valAt(method.getName())
        if (fn == nil)
        (§
            if (rt == Void.TYPE)
            (§
                (§ return (§ expr nil))
            )
            else if (method.getName().equals("equals"))
            (§
                (§ return (§ expr (proxy == args[0])))
            )
            else if (method.getName().equals("hashCode"))
            (§
                (§ return (§ expr System.identityHashCode(proxy)))
            )
            else if (method.getName().equals("toString"))
            (§
                (§ return (§ expr "Proxy: " + System.identityHashCode(proxy)))
            )
            throw new UnsupportedOperationException()
        )
        Object ret = fn.applyTo(ArraySeq.create(args))
        if (rt == Void.TYPE)
        (§
            (§ return (§ expr nil))
        )
        else if (rt.isPrimitive())
        (§
            if (rt == Character.TYPE)
            (§
                (§ return (§ expr ret))
            )
            else if (rt == Integer.TYPE)
            (§
                (§ return (§ expr ((Number) ret).intValue()))
            )
            else if (rt == Long.TYPE)
            (§
                (§ return (§ expr ((Number) ret).longValue()))
            )
            else if (rt == Float.TYPE)
            (§
                (§ return (§ expr ((Number) ret).floatValue()))
            )
            else if (rt == Double.TYPE)
            (§
                (§ return (§ expr ((Number) ret).doubleValue()))
            )
            else if (rt == Boolean.TYPE && !(ret instanceof Boolean))
            (§
                (§ return (§ expr (ret == nil) ? Boolean.FALSE :or Boolean.TRUE))
            )
            else if (rt == Byte.TYPE)
            (§
                (§ return (§ expr (byte) ((Number) ret).intValue()))
            )
            else if (rt == Short.TYPE)
            (§
                (§ return (§ expr (short) ((Number) ret).intValue()))
            )
        )
        (§ return (§ expr ret))
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.io.Serializable)
(§ import java.util.*)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(§ class public class Range extends ASeq implements IChunkedSeq, IReduce)
(§
    private static final int CHUNK_SIZE = 32

    ;; Invariants guarantee this is never an "empty" seq
    final Object end
    final Object start
    final Object step
    final BoundsCheck boundsCheck

    private volatile IChunk _chunk ;; lazy
    private volatile ISeq _chunkNext ;; lazy
    private volatile ISeq _next ;; cached

    private static interface BoundsCheck extends Serializable
    (§
        boolean exceededBounds(Object val)
    )

    private static BoundsCheck positiveStep(final Object end)
    (§
        (§ return (§ expr new BoundsCheck()
        (§
            public boolean exceededBounds(Object val)
            (§
                (§ return (§ expr Numbers.gte(val, end)))
            )
        )))
    )

    private static BoundsCheck negativeStep(final Object end)
    (§
        (§ return (§ expr new BoundsCheck()
        (§
            public boolean exceededBounds(Object val)
            (§
                (§ return (§ expr Numbers.lte(val, end)))
            )
        )))
    )

    private Range(Object start, Object end, Object step, BoundsCheck boundsCheck)
    (§
        this.end = end
        this.start = start
        this.step = step
        this.boundsCheck = boundsCheck
    )

    private Range(Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
    (§
        this.end = end
        this.start = start
        this.step = step
        this.boundsCheck = boundsCheck
        this._chunk = chunk
        this._chunkNext = chunkNext
    )

    private Range(IPersistentMap meta, Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext)
    (§
        super(meta)
        this.end = end
        this.start = start
        this.step = step
        this.boundsCheck = boundsCheck
        this._chunk = chunk
        this._chunkNext = chunkNext
    )

    public static ISeq create(Object end)
    (§
        if (Numbers.isPos(end))
        (§
            (§ return (§ expr new Range(0, end, 1, positiveStep(end))))
        )
        (§ return (§ expr PersistentList.EMPTY))
    )

    public static ISeq create(Object start, Object end)
    (§
        (§ return (§ expr create(start, end, 1)))
    )

    public static ISeq create(final Object start, Object end, Object step)
    (§
        if ((Numbers.isPos(step) && Numbers.gt(start, end)) || (Numbers.isNeg(step) && Numbers.gt(end, start)) || Numbers.equiv(start, end))
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        if (Numbers.isZero(step))
        (§
            (§ return (§ expr Repeat.create(start)))
        )
        (§ return (§ expr new Range(start, end, step, Numbers.isPos(step) ? positiveStep(end) :or negativeStep(end))))
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        if (meta == _meta)
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new Range(meta, end, start, step, boundsCheck, _chunk, _chunkNext)))
    )

    public Object first()
    (§
        (§ return (§ expr start))
    )

    public void forceChunk()
    (§
        if (_chunk != nil)
        (§
            (§ return (§ expr ))
        )

        Object[] arr = new Object[CHUNK_SIZE]
        int n = 0
        Object val = start
        while (n < CHUNK_SIZE)
        (§
            arr[n++] = val
            val = Numbers.addP(val, step)
            if (boundsCheck.exceededBounds(val))
            (§
                ;; partial last chunk
                _chunk = new ArrayChunk(arr, 0, n)
                (§ return (§ expr ))
            )
        )

        ;; full last chunk
        if (boundsCheck.exceededBounds(val))
        (§
            _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE)
            (§ return (§ expr ))
        )

        ;; full intermediate chunk
        _chunk = new ArrayChunk(arr, 0, CHUNK_SIZE)
        _chunkNext = new Range(val, end, step, boundsCheck)
    )

    public ISeq next()
    (§
        if (_next != nil)
        (§
            (§ return (§ expr _next))
        )

        forceChunk()
        if (_chunk.count() > 1)
        (§
            IChunk smallerChunk = _chunk.dropFirst()
            _next = new Range(smallerChunk.nth(0), end, step, boundsCheck, smallerChunk, _chunkNext)
            (§ return (§ expr _next))
        )
        (§ return (§ expr chunkedNext()))
    )

    public IChunk chunkedFirst()
    (§
        forceChunk()
        (§ return (§ expr _chunk))
    )

    public ISeq chunkedNext()
    (§
        (§ return (§ expr chunkedMore().seq()))
    )

    public ISeq chunkedMore()
    (§
        forceChunk()
        if (_chunkNext == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr _chunkNext))
    )

    public Object reduce(IFn f)
    (§
        Object acc = start
        Number i = Numbers.addP(start, step)
        while (!boundsCheck.exceededBounds(i))
        (§
            acc = f.invoke(acc, i)
            if (RT.isReduced(acc))
            (§
                (§ return (§ expr ((Reduced)acc).deref()))
            )
            i = Numbers.addP(i, step)
        )
        (§ return (§ expr acc))
    )

    public Object reduce(IFn f, Object val)
    (§
        Object acc = val
        Object i = start
        while (!boundsCheck.exceededBounds(i))
        (§
            acc = f.invoke(acc, i)
            if (RT.isReduced(acc))
            (§
                (§ return (§ expr ((Reduced)acc).deref()))
            )
            i = Numbers.addP(i, step)
        )
        (§ return (§ expr acc))
    )

    public Iterator iterator()
    (§
        (§ return (§ expr new RangeIterator()))
    )

    private class RangeIterator implements Iterator
    (§
        private Object next

        public RangeIterator()
        (§
            this.next = start
        )

        public boolean hasNext()
        (§
            (§ return (§ expr (!boundsCheck.exceededBounds(next))))
        )

        public Object next()
        (§
            if (hasNext())
            (§
                Object ret = next
                next = Numbers.addP(next, step)
                (§ return (§ expr ret))
            )
            else
            (§
                throw new NoSuchElementException()
            )
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(§ class public class Ratio extends Number implements Comparable)
(§
    final public BigInteger numerator
    final public BigInteger denominator

    public Ratio(BigInteger numerator, BigInteger denominator)
    (§
        this.numerator = numerator
        this.denominator = denominator
    )

    public boolean equals(Object arg0)
    (§
        (§ return (§ expr (arg0 != nil && arg0 instanceof Ratio && ((Ratio) arg0).numerator.equals(numerator) && ((Ratio) arg0).denominator.equals(denominator))))
    )

    public int hashCode()
    (§
        (§ return (§ expr numerator.hashCode() :xor denominator.hashCode()))
    )

    public String toString()
    (§
        (§ return (§ expr numerator.toString() + "/" + denominator.toString()))
    )

    public int intValue()
    (§
        (§ return (§ expr (int) doubleValue()))
    )

    public long longValue()
    (§
        (§ return (§ expr bigIntegerValue().longValue()))
    )

    public float floatValue()
    (§
        (§ return (§ expr (float)doubleValue()))
    )

    public double doubleValue()
    (§
        (§ return (§ expr decimalValue(MathContext.DECIMAL64).doubleValue()))
    )

    public BigDecimal decimalValue()
    (§
        (§ return (§ expr decimalValue(MathContext.UNLIMITED)))
    )

    public BigDecimal decimalValue(MathContext mc)
    (§
        BigDecimal numerator = new BigDecimal(this.numerator)
        BigDecimal denominator = new BigDecimal(this.denominator)

        (§ return (§ expr numerator.divide(denominator, mc)))
    )

    public BigInteger bigIntegerValue()
    (§
        (§ return (§ expr numerator.divide(denominator)))
    )

    public int compareTo(Object o)
    (§
        Number other = (Number)o
        (§ return (§ expr Numbers.compare(this, other)))
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(§ class public class ReaderConditional implements ILookup)
(§
    public static final Keyword FORM_KW = Keyword.intern("form")
    public static final Keyword SPLICING_KW = Keyword.intern("splicing?")

    public final Object form
    public final Boolean splicing

    public static ReaderConditional create(Object form, boolean splicing)
    (§
        (§ return (§ expr new ReaderConditional(form, splicing)))
    )

    private ReaderConditional(Object form, boolean splicing)
    (§
        this.form = form
        this.splicing = splicing
    )

    public Object valAt(Object key)
    (§
        (§ return (§ expr valAt(key, nil)))
    )

    public Object valAt(Object key, Object notFound)
    (§
        if (FORM_KW.equals(key))
        (§
            (§ return (§ expr this.form))
        )
        else if (SPLICING_KW.equals(key))
        (§
            (§ return (§ expr this.splicing))
        )
        else
        (§
            (§ return (§ expr notFound))
        )
    )

    (§ anno @Override)
    public boolean equals(Object o)
    (§
        if (this == o)
        (§
            (§ return (§ expr true))
        )
        if (o == nil || getClass() != o.getClass())
        (§
            (§ return (§ expr false))
        )

        ReaderConditional that = (ReaderConditional) o

        if ((form != nil) ? !form.equals(that.form) :or that.form != nil)
        (§
            (§ return (§ expr false))
        )
        if ((splicing != nil) ? !splicing.equals(that.splicing) :or that.splicing != nil)
        (§
            (§ return (§ expr false))
        )
        (§ return (§ expr true))
    )

    (§ anno @Override)
    public int hashCode()
    (§
        int result = Util.hash(form)
        result = 31 * result + Util.hash(splicing)
        (§ return (§ expr result))
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(§ class public final class RecordIterator implements Iterator)
(§
    int i = 0
    final int basecnt
    final ILookup rec
    final IPersistentVector basefields
    final Iterator extmap

    public RecordIterator (ILookup rec, IPersistentVector basefields, Iterator extmap)
    (§
        this.rec = rec
        this.basefields = basefields
        this.basecnt = basefields.count()
        this.extmap = extmap
    )

    public boolean hasNext()
    (§
        if (i < basecnt)
        (§
            (§ return (§ expr true))
        )
        else
        (§
            (§ return (§ expr extmap.hasNext()))
        )
    )

    public Object next()
    (§
        if (i < basecnt)
        (§
            Object k = basefields.nth(i)
            i++
            (§ return (§ expr MapEntry.create(k, rec.valAt(k))))
        )
        else
        (§
            (§ return (§ expr extmap.next()))
        )
    )

    public void remove()
    (§
        throw new UnsupportedOperationException()
    )
)
)

(java-ns cloiure.lang.Reduced

(§ class public final class Reduced implements IDeref)
(§
    Object val

    public Reduced(Object val)
    (§
        this.val = val
    )

    public Object deref()
    (§
        (§ return (§ expr val))
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(§ class public class Ref extends ARef implements IFn, Comparable<Ref>, IRef)
(§
    public int compareTo(Ref ref)
    (§
        if (this.id == ref.id)
        (§
            (§ return (§ expr 0))
        )
        else if (this.id < ref.id)
        (§
            (§ return (§ expr -1))
        )
        else
        (§
            (§ return (§ expr 1))
        )
    )

    public int getMinHistory()
    (§
        (§ return (§ expr minHistory))
    )

    public Ref setMinHistory(int minHistory)
    (§
        this.minHistory = minHistory
        (§ return (§ expr this))
    )

    public int getMaxHistory()
    (§
        (§ return (§ expr maxHistory))
    )

    public Ref setMaxHistory(int maxHistory)
    (§
        this.maxHistory = maxHistory
        (§ return (§ expr this))
    )

    public static class TVal
    (§
        Object val
        long point
        TVal prior
        TVal next

        TVal(Object val, long point, TVal prior)
        (§
            this.val = val
            this.point = point
            this.prior = prior
            this.next = prior.next
            this.prior.next = this
            this.next.prior = this
        )

        TVal(Object val, long point)
        (§
            this.val = val
            this.point = point
            this.next = this
            this.prior = this
        )
    )

    TVal tvals
    final AtomicInteger faults
    final ReentrantReadWriteLock lock
    LockingTransaction.Info tinfo
    final long id

    volatile int minHistory = 0
    volatile int maxHistory = 10

    static final AtomicLong ids = new AtomicLong()

    public Ref(Object initVal)
    (§
        this(initVal, nil)
    )

    public Ref(Object initVal, IPersistentMap meta)
    (§
        super(meta)
        this.id = ids.getAndIncrement()
        this.faults = new AtomicInteger()
        this.lock = new ReentrantReadWriteLock()
        tvals = new TVal(initVal, 0)
    )

    ;; the latest val

    ;; ok out of transaction
    Object currentVal()
    (§
        try
        (§
            lock.readLock().lock()
            if (tvals != nil)
            (§
                (§ return (§ expr tvals.val))
            )
            throw new IllegalStateException(this.toString() + " is unbound.")
        )
        finally
        (§
            lock.readLock().unlock()
        )
    )

    public Object deref()
    (§
        LockingTransaction t = LockingTransaction.getRunning()
        if (t == nil)
        (§
            (§ return (§ expr currentVal()))
        )
        (§ return (§ expr t.doGet(this)))
    )

    public Object set(Object val)
    (§
        (§ return (§ expr LockingTransaction.getEx().doSet(this, val)))
    )

    public Object commute(IFn fn, ISeq args)
    (§
        (§ return (§ expr LockingTransaction.getEx().doCommute(this, fn, args)))
    )

    public Object alter(IFn fn, ISeq args)
    (§
        LockingTransaction t = LockingTransaction.getEx()
        (§ return (§ expr t.doSet(this, fn.applyTo(RT.cons(t.doGet(this), args)))))
    )

    public void touch()
    (§
        LockingTransaction.getEx().doEnsure(this)
    )

    boolean isBound()
    (§
        try
        (§
            lock.readLock().lock()
            (§ return (§ expr (tvals != nil)))
        )
        finally
        (§
            lock.readLock().unlock()
        )
    )

    public void trimHistory()
    (§
        try
        (§
            lock.writeLock().lock()
            if (tvals != nil)
            (§
                tvals.next = tvals
                tvals.prior = tvals
            )
        )
        finally
        (§
            lock.writeLock().unlock()
        )
    )

    public int getHistoryCount()
    (§
        try
        (§
            lock.writeLock().lock()
            (§ return (§ expr histCount()))
        )
        finally
        (§
            lock.writeLock().unlock()
        )
    )

    int histCount()
    (§
        if (tvals == nil)
        (§
            (§ return (§ expr 0))
        )
        else
        (§
            int count = 0
            for (TVal tv = tvals.next tv != tvals tv = tv.next)
            (§
                count++
            )
            (§ return (§ expr count))
        )
    )

    final public IFn fn()
    (§
        (§ return (§ expr (IFn) deref()))
    )

    public Object call()
    (§
        (§ return (§ expr invoke()))
    )

    public void run()
    (§
        invoke()
    )

    public Object invoke()
    (§
        (§ return (§ expr fn().invoke()))
    )

    public Object invoke(Object arg1)
    (§
        (§ return (§ expr fn().invoke(arg1)))
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20)))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
    (§
        (§ return (§ expr fn().invoke(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args)))
    )

    public Object applyTo(ISeq arglist)
    (§
        (§ return (§ expr AFn.applyToHelper(this, arglist)))
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

(§ class public class Reflector)
(§
    public static Object invokeInstanceMethod(Object target, String methodName, Object[] args)
    (§
        Class c = target.getClass()
        List methods = getMethods(c, args.length, methodName, false)
        (§ return (§ expr invokeMatchingMethod(methodName, methods, target, args)))
    )

    private static Throwable getCauseOrElse(Exception e)
    (§
        if (e.getCause() != nil)
        (§
            (§ return (§ expr e.getCause()))
        )
        (§ return (§ expr e))
    )

    private static RuntimeException throwCauseOrElseException(Exception e)
    (§
        if (e.getCause() != nil)
        (§
            throw Util.sneakyThrow(e.getCause())
        )
        throw Util.sneakyThrow(e)
    )

    private static String noMethodReport(String methodName, Object target)
    (§
        (§ return (§ expr "No matching method found: " + methodName + ((target == nil) ? "" :or " for " + target.getClass())))
    )

    static Object invokeMatchingMethod(String methodName, List methods, Object target, Object[] args)
    (§
        Method m = nil
        Object[] boxedArgs = nil
        if (methods.isEmpty())
        (§
            throw new IllegalArgumentException(noMethodReport(methodName, target))
        )
        else if (methods.size() == 1)
        (§
            m = (Method) methods.get(0)
            boxedArgs = boxArgs(m.getParameterTypes(), args)
        )
        else ;; overloaded w/same arity
        (§
            Method foundm = nil
            for (Iterator i = methods.iterator() i.hasNext() )
            (§
                m = (Method) i.next()

                Class[] params = m.getParameterTypes()
                if (isCongruent(params, args))
                (§
                    if (foundm == nil || Compiler.subsumes(params, foundm.getParameterTypes()))
                    (§
                        foundm = m
                        boxedArgs = boxArgs(params, args)
                    )
                )
            )
            m = foundm
        )
        if (m == nil)
        (§
            throw new IllegalArgumentException(noMethodReport(methodName, target))
        )

        if (!Modifier.isPublic(m.getDeclaringClass().getModifiers()))
        (§
            ;; public method of non-public class, try to find it in hierarchy
            Method oldm = m
            m = getAsMethodOfPublicBase(target.getClass(), m)
            if (m == nil)
            (§
                throw new IllegalArgumentException("Can't call public method of non-public class: " + oldm.toString())
            )
        )
        try
        (§
            (§ return (§ expr prepRet(m.getReturnType(), m.invoke(target, boxedArgs))))
        )
        catch (Exception e)
        (§
            throw Util.sneakyThrow(getCauseOrElse(e))
        )
    )

    public static Method getAsMethodOfPublicBase(Class c, Method m)
    (§
        for (Class iface :in c.getInterfaces())
        (§
            for (Method im :in iface.getMethods())
            (§
                if (isMatch(im, m))
                (§
                    (§ return (§ expr im))
                )
            )
        )
        Class sc = c.getSuperclass()
        if (sc == nil)
        (§
            (§ return (§ expr nil))
        )
        for (Method scm :in sc.getMethods())
        (§
            if (isMatch(scm, m))
            (§
                (§ return (§ expr scm))
            )
        )
        (§ return (§ expr getAsMethodOfPublicBase(sc, m)))
    )

    public static boolean isMatch(Method lhs, Method rhs)
    (§
        if (!lhs.getName().equals(rhs.getName()) || !Modifier.isPublic(lhs.getDeclaringClass().getModifiers()))
        (§
            (§ return (§ expr false))
        )

        Class[] types1 = lhs.getParameterTypes()
        Class[] types2 = rhs.getParameterTypes()
        if (types1.length != types2.length)
        (§
            (§ return (§ expr false))
        )

        boolean match = true
        for (int i = 0 i < types1.length ++i)
        (§
            if (!types1[i].isAssignableFrom(types2[i]))
            (§
                match = false
                break
            )
        )
        (§ return (§ expr match))
    )

    public static Object invokeConstructor(Class c, Object[] args)
    (§
        try
        (§
            Constructor[] allctors = c.getConstructors()
            ArrayList ctors = new ArrayList()
            for (int i = 0 i < allctors.length i++)
            (§
                Constructor ctor = allctors[i]
                if (ctor.getParameterTypes().length == args.length)
                (§
                    ctors.add(ctor)
                )
            )
            if (ctors.isEmpty())
            (§
                throw new IllegalArgumentException("No matching ctor found for " + c)
            )
            else if (ctors.size() == 1)
            (§
                Constructor ctor = (Constructor) ctors.get(0)
                (§ return (§ expr ctor.newInstance(boxArgs(ctor.getParameterTypes(), args))))
            )
            else ;; overloaded w/same arity
            (§
                for (Iterator iterator = ctors.iterator() iterator.hasNext() )
                (§
                    Constructor ctor = (Constructor) iterator.next()
                    Class[] params = ctor.getParameterTypes()
                    if (isCongruent(params, args))
                    (§
                        Object[] boxedArgs = boxArgs(params, args)
                        (§ return (§ expr ctor.newInstance(boxedArgs)))
                    )
                )
                throw new IllegalArgumentException("No matching ctor found for " + c)
            )
        )
        catch (Exception e)
        (§
            throw Util.sneakyThrow(getCauseOrElse(e))
        )
    )

    public static Object invokeStaticMethodVariadic(String className, String methodName, Object... args)
    (§
        (§ return (§ expr invokeStaticMethod(className, methodName, args)))
    )

    public static Object invokeStaticMethod(String className, String methodName, Object[] args)
    (§
        Class c = RT.classForName(className)
        (§ return (§ expr invokeStaticMethod(c, methodName, args)))
    )

    public static Object invokeStaticMethod(Class c, String methodName, Object[] args)
    (§
        if (methodName.equals("new"))
        (§
            (§ return (§ expr invokeConstructor(c, args)))
        )
        List methods = getMethods(c, args.length, methodName, true)
        (§ return (§ expr invokeMatchingMethod(methodName, methods, nil, args)))
    )

    public static Object getStaticField(String className, String fieldName)
    (§
        Class c = RT.classForName(className)
        (§ return (§ expr getStaticField(c, fieldName)))
    )

    public static Object getStaticField(Class c, String fieldName)
    (§
        Field f = getField(c, fieldName, true)
        if (f != nil)
        (§
            try
            (§
                (§ return (§ expr prepRet(f.getType(), f.get(nil))))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
        throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + c)
    )

    public static Object setStaticField(String className, String fieldName, Object val)
    (§
        Class c = RT.classForName(className)
        (§ return (§ expr setStaticField(c, fieldName, val)))
    )

    public static Object setStaticField(Class c, String fieldName, Object val)
    (§
        Field f = getField(c, fieldName, true)
        if (f != nil)
        (§
            try
            (§
                f.set(nil, boxArg(f.getType(), val))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
            (§ return (§ expr val))
        )
        throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + c)
    )

    public static Object getInstanceField(Object target, String fieldName)
    (§
        Class c = target.getClass()
        Field f = getField(c, fieldName, false)
        if (f != nil)
        (§
            try
            (§
                (§ return (§ expr prepRet(f.getType(), f.get(target))))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
        throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())
    )

    public static Object setInstanceField(Object target, String fieldName, Object val)
    (§
        Class c = target.getClass()
        Field f = getField(c, fieldName, false)
        if (f != nil)
        (§
            try
            (§
                f.set(target, boxArg(f.getType(), val))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
            (§ return (§ expr val))
        )
        throw new IllegalArgumentException("No matching field found: " + fieldName + " for " + target.getClass())
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    public static Object invokeNoArgInstanceMember(Object target, String name)
    (§
        (§ return (§ expr invokeNoArgInstanceMember(target, name, false)))
    )

    public static Object invokeNoArgInstanceMember(Object target, String name, boolean requireField)
    (§
        Class c = target.getClass()

        if (requireField)
        (§
            Field f = getField(c, name, false)
            if (f != nil)
            (§
                (§ return (§ expr getInstanceField(target, name)))
            )
            else
            (§
                throw new IllegalArgumentException("No matching field found: " + name + " for " + target.getClass())
            )
        )
        else
        (§
            List meths = getMethods(c, 0, name, false)
            if (meths.size() > 0)
            (§
                (§ return (§ expr invokeMatchingMethod(name, meths, target, RT.EMPTY_ARRAY)))
            )
            else
            (§
                (§ return (§ expr getInstanceField(target, name)))
            )
        )
    )

    public static Object invokeInstanceMember(Object target, String name)
    (§
        ;; check for field first
        Class c = target.getClass()
        Field f = getField(c, name, false)
        if (f != nil) ;; field get
        (§
            try
            (§
                (§ return (§ expr prepRet(f.getType(), f.get(target))))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
        )
        (§ return (§ expr invokeInstanceMethod(target, name, RT.EMPTY_ARRAY)))
    )

    public static Object invokeInstanceMember(String name, Object target, Object arg1)
    (§
        ;; check for field first
        Class c = target.getClass()
        Field f = getField(c, name, false)
        if (f != nil) ;; field set
        (§
            try
            (§
                f.set(target, boxArg(f.getType(), arg1))
            )
            catch (IllegalAccessException e)
            (§
                throw Util.sneakyThrow(e)
            )
            (§ return (§ expr arg1))
        )
        (§ return (§ expr invokeInstanceMethod(target, name, new Object[] (§ arg1 ))))
    )

    public static Object invokeInstanceMember(String name, Object target, Object... args)
    (§
        (§ return (§ expr invokeInstanceMethod(target, name, args)))
    )

    static public Field getField(Class c, String name, boolean getStatics)
    (§
        Field[] allfields = c.getFields()
        for (int i = 0 i < allfields.length i++)
        (§
            if (name.equals(allfields[i].getName()) && Modifier.isStatic(allfields[i].getModifiers()) == getStatics)
            (§
                (§ return (§ expr allfields[i]))
            )
        )
        (§ return (§ expr nil))
    )

    static public List getMethods(Class c, int arity, String name, boolean getStatics)
    (§
        Method[] allmethods = c.getMethods()
        ArrayList methods = new ArrayList()
        ArrayList bridgeMethods = new ArrayList()
        for (int i = 0 i < allmethods.length i++)
        (§
            Method method = allmethods[i]
            if (name.equals(method.getName()) && Modifier.isStatic(method.getModifiers()) == getStatics && method.getParameterTypes().length == arity)
            (§
                try
                (§
                    if (method.isBridge() && c.getMethod(method.getName(), method.getParameterTypes()).equals(method))
                    (§
                        bridgeMethods.add(method)
                    )
                    else
                    (§
                        methods.add(method)
                    )
                )
                catch (NoSuchMethodException e)
                (§
                )
            )
        )

        if (methods.isEmpty())
        (§
            methods.addAll(bridgeMethods)
        )
        if (!getStatics && c.isInterface())
        (§
            allmethods = Object.class.getMethods()
            for (int i = 0 i < allmethods.length i++)
            (§
                if (name.equals(allmethods[i].getName()) && Modifier.isStatic(allmethods[i].getModifiers()) == getStatics && allmethods[i].getParameterTypes().length == arity)
                (§
                    methods.add(allmethods[i])
                )
            )
        )
        (§ return (§ expr methods))
    )

    static Object boxArg(Class paramType, Object arg)
    (§
        if (!paramType.isPrimitive())
        (§
            (§ return (§ expr paramType.cast(arg)))
        )
        else if (paramType == boolean.class)
        (§
            (§ return (§ expr Boolean.class.cast(arg)))
        )
        else if (paramType == char.class)
        (§
            (§ return (§ expr Character.class.cast(arg)))
        )
        else if (arg instanceof Number)
        (§
            Number n = (Number) arg
            if (paramType == int.class)
            (§
                (§ return (§ expr n.intValue()))
            )
            else if (paramType == float.class)
            (§
                (§ return (§ expr n.floatValue()))
            )
            else if (paramType == double.class)
            (§
                (§ return (§ expr n.doubleValue()))
            )
            else if (paramType == long.class)
            (§
                (§ return (§ expr n.longValue()))
            )
            else if (paramType == short.class)
            (§
                (§ return (§ expr n.shortValue()))
            )
            else if (paramType == byte.class)
            (§
                (§ return (§ expr n.byteValue()))
            )
        )
        throw new IllegalArgumentException("Unexpected param type, expected: " + paramType + ", given: " + arg.getClass().getName())
    )

    static Object[] boxArgs(Class[] params, Object[] args)
    (§
        if (params.length == 0)
        (§
            (§ return (§ expr nil))
        )
        Object[] ret = new Object[params.length]
        for (int i = 0 i < params.length i++)
        (§
            Object arg = args[i]
            Class paramType = params[i]
            ret[i] = boxArg(paramType, arg)
        )
        (§ return (§ expr ret))
    )

    static public boolean paramArgTypeMatch(Class paramType, Class argType)
    (§
        if (argType == nil)
        (§
            (§ return (§ expr !paramType.isPrimitive()))
        )
        if (paramType == argType || paramType.isAssignableFrom(argType))
        (§
            (§ return (§ expr true))
        )
        if (paramType == int.class)
        (§
            (§ return (§ expr argType == Integer.class
                || argType == long.class
                || argType == Long.class
                || argType == short.class
                || argType == byte.class))
        )
        else if (paramType == float.class)
        (§
            (§ return (§ expr argType == Float.class
                || argType == double.class))
        )
        else if (paramType == double.class)
        (§
            (§ return (§ expr argType == Double.class
                || argType == float.class))
        )
        else if (paramType == long.class)
        (§
            (§ return (§ expr argType == Long.class
                || argType == int.class
                || argType == short.class
                || argType == byte.class))
        )
        else if (paramType == char.class)
        (§
            (§ return (§ expr argType == Character.class))
        )
        else if (paramType == short.class)
        (§
            (§ return (§ expr argType == Short.class))
        )
        else if (paramType == byte.class)
        (§
            (§ return (§ expr argType == Byte.class))
        )
        else if (paramType == boolean.class)
        (§
            (§ return (§ expr argType == Boolean.class))
        )
        (§ return (§ expr false))
    )

    static boolean isCongruent(Class[] params, Object[] args)
    (§
        boolean ret = false
        if (args == nil)
        (§
            (§ return (§ expr (params.length == 0)))
        )
        if (params.length == args.length)
        (§
            ret = true
            for (int i = 0 ret && i < params.length i++)
            (§
                Object arg = args[i]
                Class argType = (arg == nil) ? nil :or arg.getClass()
                Class paramType = params[i]
                ret = paramArgTypeMatch(paramType, argType)
            )
        )
        (§ return (§ expr ret))
    )

    public static Object prepRet(Class c, Object x)
    (§
        if (!(c.isPrimitive() || c == Boolean.class))
        (§
            (§ return (§ expr x))
        )
        if (x instanceof Boolean)
        (§
            (§ return (§ expr ((Boolean) x) ? Boolean.TRUE :or Boolean.FALSE))
        )
        (§ return (§ expr x))
    )
)
)

(java-ns cloiure.lang.Repeat

(§ class public class Repeat extends ASeq implements IReduce)
(§
    private static final long INFINITE = -1

    private final long count ;; always INFINITE or >0
    private final Object val
    private volatile ISeq _next ;; cached

    private Repeat(long count, Object val)
    (§
        this.count = count
        this.val = val
    )

    private Repeat(IPersistentMap meta, long count, Object val)
    (§
        super(meta)
        this.count = count
        this.val = val
    )

    public static Repeat create(Object val)
    (§
        (§ return (§ expr new Repeat(INFINITE, val)))
    )

    public static ISeq create(long count, Object val)
    (§
        if (count <= 0)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr new Repeat(count, val)))
    )

    public Object first()
    (§
        (§ return (§ expr val))
    )

    public ISeq next()
    (§
        if (_next == nil)
        (§
            if (count > 1)
            (§
                _next = new Repeat(count - 1, val)
            )
            else if (count == INFINITE)
            (§
                _next = this
            )
        )
        (§ return (§ expr _next))
    )

    public Repeat withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new Repeat(meta, count, val)))
    )

    public Object reduce(IFn f)
    (§
        Object ret = val
        if (count == INFINITE)
        (§
            while (true)
            (§
                ret = f.invoke(ret, val)
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
        )
        else
        (§
            for (long i = 1 i < count i++)
            (§
                ret = f.invoke(ret, val)
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )
    )

    public Object reduce(IFn f, Object start)
    (§
        Object ret = start
        if (count == INFINITE)
        (§
            while (true)
            (§
                ret = f.invoke(ret, val)
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
        )
        else
        (§
            for (long i = 0 i < count i++)
            (§
                ret = f.invoke(ret, val)
                if (RT.isReduced(ret))
                (§
                    (§ return (§ expr ((IDeref)ret).deref()))
                )
            )
            (§ return (§ expr ret))
        )
    )
)
)

(java-ns cloiure.lang.RestFn

(§ class public abstract class RestFn extends AFunction)
(§
    abstract public int getRequiredArity()

    protected Object doInvoke(Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
            Object args)
    (§
        (§ return (§ expr nil))
    )

    protected Object doInvoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13,
            Object arg14, Object arg15, Object arg16, Object arg17, Object arg18, Object arg19,
            Object arg20, Object args)
    (§
        (§ return (§ expr nil))
    )

    public Object applyTo(ISeq args)
    (§
        if (RT.boundedLength(args, getRequiredArity()) <= getRequiredArity())
        (§
            (§ return (§ expr AFn.applyToHelper(this, Util.ret1(args, args = nil))))
        )
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(Util.ret1(args, args = nil))))
            (§ case 1)
                (§ return (§ expr doInvoke(args.first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 2)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 3)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 4)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 5)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 6)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 7)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 8)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 9)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 10)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 11)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 12)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 13)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 14)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 15)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 16)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 17)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 18)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 19)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
            (§ case 20)
                (§ return (§ expr doInvoke(args.first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        (args = args.next()).first(),
                        Util.ret1(args.next(), args = nil))))
        )
        (§ return (§ expr throwArity(-1)))
    )

    public Object invoke()
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(nil)))
            (§ default)
                (§ return (§ expr throwArity(0)))
        )
    )

    public Object invoke(Object arg1)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(1)))
        )
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(2)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(3)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(4)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(5)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        ArraySeq.create(Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(Util.ret1(arg3, arg3 = nil), Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(Util.ret1(arg6, arg6 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        nil)))
            (§ default)
                (§ return (§ expr throwArity(6)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil), ArraySeq.create(Util.ret1(arg7, arg7 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(7)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil), ArraySeq.create(Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), ArraySeq.create(Util.ret1(arg8, arg8 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(8)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil), ArraySeq.create(Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), ArraySeq.create(Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil), ArraySeq.create(Util.ret1(arg9, arg9 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(9)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil), ArraySeq.create(Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), ArraySeq.create(Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil), ArraySeq.create(Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil), ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(10)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil), ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil), ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil), ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(11)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil), ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil), ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil), ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil), ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(12)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(
                        ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(13)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil)))))
            (§ case 14)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        nil)))
            (§ default)
                (§ return (§ expr throwArity(14)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 14)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil)))))
            (§ case 15)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(15)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 14)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 15)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil), ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil)))))
            (§ case 16)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(16)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 14)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 15)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil), ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 16)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil)))))
            (§ case 17)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(17)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil), ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),

                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 14)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 15)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil), ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 16)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 17)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil), ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil)))))
            (§ case 18)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(18)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 1)
                ISeq packed = PersistentList.EMPTY
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil), ArraySeq.create(
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil), ArraySeq.create(
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),

                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil), ArraySeq.create(
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),

                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), ArraySeq.create(
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),

                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil), ArraySeq.create(
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),

                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        ArraySeq.create(
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        ArraySeq.create(
                            Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(
                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        ArraySeq.create(
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 14)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),
                        ArraySeq.create(
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 15)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil), ArraySeq.create(
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 16)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), ArraySeq.create(
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 17)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil), ArraySeq.create(
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 18)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil), ArraySeq.create(
                            Util.ret1(arg19, arg19 = nil)))))
            (§ case 19)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil),
                        Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil),
                        Util.ret1(arg5, arg5 = nil),
                        Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil),
                        Util.ret1(arg8, arg8 = nil),
                        Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil),
                        Util.ret1(arg11, arg11 = nil),
                        Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil),
                        Util.ret1(arg14, arg14 = nil),

                        Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil),
                        Util.ret1(arg17, arg17 = nil),
                        Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(19)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ArraySeq.create(
                            Util.ret1(arg1, arg1 = nil),
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), ArraySeq.create(
                            Util.ret1(arg2, arg2 = nil),
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil),
                        Util.ret1(arg2, arg2 = nil), ArraySeq.create(
                            Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil),
                            Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil),
                            Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil),

                            Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        ArraySeq.create(Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ArraySeq.create(Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil), Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), ArraySeq.create(Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        ArraySeq.create(Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), ArraySeq.create(Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), ArraySeq.create(Util.ret1(arg9, arg9 = nil), Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        ArraySeq.create(Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), ArraySeq.create(Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), ArraySeq.create(Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        ArraySeq.create(Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), ArraySeq.create(Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 14)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), ArraySeq.create(Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 15)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        ArraySeq.create(Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 16)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), ArraySeq.create(Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 17)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), ArraySeq.create(Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 18)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                        ArraySeq.create(Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 19)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil), ArraySeq.create(Util.ret1(arg20, arg20 = nil)))))
            (§ case 20)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil), nil)))
            (§ default)
                (§ return (§ expr throwArity(20)))
        )
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20, Object... args)
    (§
        switch (getRequiredArity())
        (§
            (§ case 0)
                (§ return (§ expr doInvoke(ontoArrayPrepend(args, Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 1)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), ontoArrayPrepend(args, Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 2)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), ontoArrayPrepend(args, Util.ret1(arg3, arg3 = nil),
                            Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil),
                            Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 3)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        ontoArrayPrepend(args, Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                            Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 4)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), ontoArrayPrepend(args, Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil), Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 5)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), ontoArrayPrepend(args, Util.ret1(arg6, arg6 = nil), Util.ret1(arg7, arg7 = nil),
                            Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 6)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        ontoArrayPrepend(args, Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 7)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), ontoArrayPrepend(args, Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                            Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil),
                            Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 8)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), ontoArrayPrepend(args, Util.ret1(arg9, arg9 = nil), Util.ret1(arg10, arg10 = nil),
                            Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 9)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        ontoArrayPrepend(args, Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 10)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), ontoArrayPrepend(args, Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                            Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil),
                            Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 11)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), ontoArrayPrepend(args, Util.ret1(arg12, arg12 = nil), Util.ret1(arg13, arg13 = nil),
                            Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 12)
                (§ return (§ expr doInvoke(
                        Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        ontoArrayPrepend(args, Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 13)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), ontoArrayPrepend(args, Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                            Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil),
                            Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 14)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), ontoArrayPrepend(args, Util.ret1(arg15, arg15 = nil), Util.ret1(arg16, arg16 = nil),
                            Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 15)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        ontoArrayPrepend(args, Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 16)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), ontoArrayPrepend(args, Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                            Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 17)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), ontoArrayPrepend(args, Util.ret1(arg18, arg18 = nil), Util.ret1(arg19, arg19 = nil),
                            Util.ret1(arg20, arg20 = nil)))))
            (§ case 18)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                        ontoArrayPrepend(args, Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil)))))
            (§ case 19)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil), ontoArrayPrepend(args, Util.ret1(arg20, arg20 = nil)))))
            (§ case 20)
                (§ return (§ expr doInvoke(Util.ret1(arg1, arg1 = nil), Util.ret1(arg2, arg2 = nil), Util.ret1(arg3, arg3 = nil),
                        Util.ret1(arg4, arg4 = nil), Util.ret1(arg5, arg5 = nil), Util.ret1(arg6, arg6 = nil),
                        Util.ret1(arg7, arg7 = nil), Util.ret1(arg8, arg8 = nil), Util.ret1(arg9, arg9 = nil),
                        Util.ret1(arg10, arg10 = nil), Util.ret1(arg11, arg11 = nil), Util.ret1(arg12, arg12 = nil),
                        Util.ret1(arg13, arg13 = nil), Util.ret1(arg14, arg14 = nil), Util.ret1(arg15, arg15 = nil),
                        Util.ret1(arg16, arg16 = nil), Util.ret1(arg17, arg17 = nil), Util.ret1(arg18, arg18 = nil),
                        Util.ret1(arg19, arg19 = nil), Util.ret1(arg20, arg20 = nil), ArraySeq.create(args))))
            (§ default)
                (§ return (§ expr throwArity(21)))
        )
    )

    protected static ISeq ontoArrayPrepend(Object[] array, Object... args)
    (§
        ISeq ret = ArraySeq.create(array)
        for (int i = args.length - 1 i >= 0 --i)
        (§
            ret = RT.cons(args[i], ret)
        )
        (§ return (§ expr ret))
    )

    protected static ISeq findKey(Object key, ISeq args)
    (§
        while (args != nil)
        (§
            if (key == args.first())
            (§
                (§ return (§ expr args.next()))
            )
            args = RT.next(args)
            args = RT.next(args)
        )
        (§ return (§ expr nil))
    )
)
)

(java-ns cloiure.lang.Reversible

(§ interface public interface Reversible)
(§
    ISeq rseq()
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

(§ class public class RT)
(§
    static final public Boolean T = Boolean.TRUE
    static final public Boolean F = Boolean.FALSE
    static final public String LOADER_SUFFIX = "__init"

    ;; simple-symbol->class
    final static public IPersistentMap DEFAULT_IMPORTS = map(
            Symbol.intern("Boolean"), Boolean.class,
            Symbol.intern("Byte"), Byte.class,
            Symbol.intern("Character"), Character.class,
            Symbol.intern("Class"), Class.class,
            Symbol.intern("ClassLoader"), ClassLoader.class,
            Symbol.intern("Compiler"), Compiler.class,
            Symbol.intern("Double"), Double.class,
            Symbol.intern("Enum"), Enum.class,
            Symbol.intern("Float"), Float.class,
            Symbol.intern("InheritableThreadLocal"), InheritableThreadLocal.class,
            Symbol.intern("Integer"), Integer.class,
            Symbol.intern("Long"), Long.class,
            Symbol.intern("Math"), Math.class,
            Symbol.intern("Number"), Number.class,
            Symbol.intern("Object"), Object.class,
            Symbol.intern("Package"), Package.class,
            Symbol.intern("Process"), Process.class,
            Symbol.intern("ProcessBuilder"), ProcessBuilder.class,
            Symbol.intern("Runtime"), Runtime.class,
            Symbol.intern("RuntimePermission"), RuntimePermission.class,
            Symbol.intern("SecurityManager"), SecurityManager.class,
            Symbol.intern("Short"), Short.class,
            Symbol.intern("StackTraceElement"), StackTraceElement.class,
            Symbol.intern("StrictMath"), StrictMath.class,
            Symbol.intern("String"), String.class,
            Symbol.intern("StringBuffer"), StringBuffer.class,
            Symbol.intern("StringBuilder"), StringBuilder.class,
            Symbol.intern("System"), System.class,
            Symbol.intern("Thread"), Thread.class,
            Symbol.intern("ThreadGroup"), ThreadGroup.class,
            Symbol.intern("ThreadLocal"), ThreadLocal.class,
            Symbol.intern("Throwable"), Throwable.class,
            Symbol.intern("Void"), Void.class,
            Symbol.intern("Appendable"), Appendable.class,
            Symbol.intern("CharSequence"), CharSequence.class,
            Symbol.intern("Cloneable"), Cloneable.class,
            Symbol.intern("Comparable"), Comparable.class,
            Symbol.intern("Iterable"), Iterable.class,
            Symbol.intern("Readable"), Readable.class,
            Symbol.intern("Runnable"), Runnable.class,
            Symbol.intern("Callable"), Callable.class,
            Symbol.intern("BigInteger"), BigInteger.class,
            Symbol.intern("BigDecimal"), BigDecimal.class,
            Symbol.intern("ArithmeticException"), ArithmeticException.class,
            Symbol.intern("ArrayIndexOutOfBoundsException"), ArrayIndexOutOfBoundsException.class,
            Symbol.intern("ArrayStoreException"), ArrayStoreException.class,
            Symbol.intern("ClassCastException"), ClassCastException.class,
            Symbol.intern("ClassNotFoundException"), ClassNotFoundException.class,
            Symbol.intern("CloneNotSupportedException"), CloneNotSupportedException.class,
            Symbol.intern("EnumConstantNotPresentException"), EnumConstantNotPresentException.class,
            Symbol.intern("Exception"), Exception.class,
            Symbol.intern("IllegalAccessException"), IllegalAccessException.class,
            Symbol.intern("IllegalArgumentException"), IllegalArgumentException.class,
            Symbol.intern("IllegalMonitorStateException"), IllegalMonitorStateException.class,
            Symbol.intern("IllegalStateException"), IllegalStateException.class,
            Symbol.intern("IllegalThreadStateException"), IllegalThreadStateException.class,
            Symbol.intern("IndexOutOfBoundsException"), IndexOutOfBoundsException.class,
            Symbol.intern("InstantiationException"), InstantiationException.class,
            Symbol.intern("InterruptedException"), InterruptedException.class,
            Symbol.intern("NegativeArraySizeException"), NegativeArraySizeException.class,
            Symbol.intern("NoSuchFieldException"), NoSuchFieldException.class,
            Symbol.intern("NoSuchMethodException"), NoSuchMethodException.class,
            Symbol.intern("NullPointerException"), NullPointerException.class,
            Symbol.intern("NumberFormatException"), NumberFormatException.class,
            Symbol.intern("RuntimeException"), RuntimeException.class,
            Symbol.intern("SecurityException"), SecurityException.class,
            Symbol.intern("StringIndexOutOfBoundsException"), StringIndexOutOfBoundsException.class,
            Symbol.intern("TypeNotPresentException"), TypeNotPresentException.class,
            Symbol.intern("UnsupportedOperationException"), UnsupportedOperationException.class,
            Symbol.intern("AbstractMethodError"), AbstractMethodError.class,
            Symbol.intern("AssertionError"), AssertionError.class,
            Symbol.intern("ClassCircularityError"), ClassCircularityError.class,
            Symbol.intern("ClassFormatError"), ClassFormatError.class,
            Symbol.intern("Error"), Error.class,
            Symbol.intern("ExceptionInInitializerError"), ExceptionInInitializerError.class,
            Symbol.intern("IllegalAccessError"), IllegalAccessError.class,
            Symbol.intern("IncompatibleClassChangeError"), IncompatibleClassChangeError.class,
            Symbol.intern("InstantiationError"), InstantiationError.class,
            Symbol.intern("InternalError"), InternalError.class,
            Symbol.intern("LinkageError"), LinkageError.class,
            Symbol.intern("NoClassDefFoundError"), NoClassDefFoundError.class,
            Symbol.intern("NoSuchFieldError"), NoSuchFieldError.class,
            Symbol.intern("NoSuchMethodError"), NoSuchMethodError.class,
            Symbol.intern("OutOfMemoryError"), OutOfMemoryError.class,
            Symbol.intern("StackOverflowError"), StackOverflowError.class,
            Symbol.intern("ThreadDeath"), ThreadDeath.class,
            Symbol.intern("UnknownError"), UnknownError.class,
            Symbol.intern("UnsatisfiedLinkError"), UnsatisfiedLinkError.class,
            Symbol.intern("UnsupportedClassVersionError"), UnsupportedClassVersionError.class,
            Symbol.intern("VerifyError"), VerifyError.class,
            Symbol.intern("VirtualMachineError"), VirtualMachineError.class,
            Symbol.intern("Thread$UncaughtExceptionHandler"), Thread.UncaughtExceptionHandler.class,
            Symbol.intern("Thread$State"), Thread.State.class,
            Symbol.intern("Deprecated"), Deprecated.class,
            Symbol.intern("Override"), Override.class,
            Symbol.intern("SuppressWarnings"), SuppressWarnings.class
    )

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    static public Charset UTF8 = Charset.forName("UTF-8")

    static Object readTrueFalseUnknown(String s)
    (§
        if (s.equals("true"))
        (§
            (§ return (§ expr Boolean.TRUE))
        )
        else if (s.equals("false"))
        (§
            (§ return (§ expr Boolean.FALSE))
        )
        (§ return (§ expr Keyword.intern(nil, "unknown")))
    )

    static public final Namespace CLOIURE_NS = Namespace.findOrCreate(Symbol.intern("cloiure.core"))
    final static public Var OUT = Var.intern(CLOIURE_NS, Symbol.intern("*out*"), new OutputStreamWriter(System.out)).setDynamic()
    final static public Var IN = Var.intern(CLOIURE_NS, Symbol.intern("*in*"), new LineNumberingPushbackReader(new InputStreamReader(System.in))).setDynamic()
    final static public Var ERR = Var.intern(CLOIURE_NS, Symbol.intern("*err*"), new PrintWriter(new OutputStreamWriter(System.err), true)).setDynamic()
    final static Keyword TAG_KEY = Keyword.intern(nil, "tag")
    final static Keyword CONST_KEY = Keyword.intern(nil, "const")
    final static public Var AGENT = Var.intern(CLOIURE_NS, Symbol.intern("*agent*"), nil).setDynamic()
    static Object readeval = readTrueFalseUnknown(System.getProperty("cloiure.read.eval", "true"))
    final static public Var READEVAL = Var.intern(CLOIURE_NS, Symbol.intern("*read-eval*"),  readeval).setDynamic()
    final static public Var DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("*data-readers*"), RT.map()).setDynamic()
    final static public Var DEFAULT_DATA_READER_FN = Var.intern(CLOIURE_NS, Symbol.intern("*default-data-reader-fn*"), RT.map()).setDynamic()
    final static public Var DEFAULT_DATA_READERS = Var.intern(CLOIURE_NS, Symbol.intern("default-data-readers"), RT.map())
    final static public Var SUPPRESS_READ = Var.intern(CLOIURE_NS, Symbol.intern("*suppress-read*"), nil).setDynamic()
    final static public Var ASSERT = Var.intern(CLOIURE_NS, Symbol.intern("*assert*"), T).setDynamic()
    final static public Var MATH_CONTEXT = Var.intern(CLOIURE_NS, Symbol.intern("*math-context*"), nil).setDynamic()
    static Keyword LINE_KEY = Keyword.intern(nil, "line")
    static Keyword COLUMN_KEY = Keyword.intern(nil, "column")
    static Keyword FILE_KEY = Keyword.intern(nil, "file")
    static Keyword DECLARED_KEY = Keyword.intern(nil, "declared")
    static Keyword DOC_KEY = Keyword.intern(nil, "doc")
    final static public Var USE_CONTEXT_CLASSLOADER = Var.intern(CLOIURE_NS, Symbol.intern("*use-context-classloader*"), T).setDynamic()
    ;; boolean
    static final public Var UNCHECKED_MATH = Var.intern(Namespace.findOrCreate(Symbol.intern("cloiure.core")), Symbol.intern("*unchecked-math*"), Boolean.FALSE).setDynamic()

    final static Symbol LOAD_FILE = Symbol.intern("load-file")
    final static Symbol IN_NAMESPACE = Symbol.intern("in-ns")
    final static Symbol NAMESPACE = Symbol.intern("ns")
    static final Symbol IDENTICAL = Symbol.intern("identical?")
    final static Var CMD_LINE_ARGS = Var.intern(CLOIURE_NS, Symbol.intern("*command-line-args*"), nil).setDynamic()
    ;; symbol
    final public static Var CURRENT_NS = Var.intern(CLOIURE_NS, Symbol.intern("*ns*"), CLOIURE_NS).setDynamic()

    final static Var FLUSH_ON_NEWLINE = Var.intern(CLOIURE_NS, Symbol.intern("*flush-on-newline*"), T).setDynamic()
    final static Var PRINT_META = Var.intern(CLOIURE_NS, Symbol.intern("*print-meta*"), F).setDynamic()
    final static Var PRINT_READABLY = Var.intern(CLOIURE_NS, Symbol.intern("*print-readably*"), T).setDynamic()
    final static Var PRINT_DUP = Var.intern(CLOIURE_NS, Symbol.intern("*print-dup*"), F).setDynamic()
    final static Var WARN_ON_REFLECTION = Var.intern(CLOIURE_NS, Symbol.intern("*warn-on-reflection*"), F).setDynamic()
    final static Var ALLOW_UNRESOLVED_VARS = Var.intern(CLOIURE_NS, Symbol.intern("*allow-unresolved-vars*"), F).setDynamic()
    final static Var READER_RESOLVER = Var.intern(CLOIURE_NS, Symbol.intern("*reader-resolver*"), nil).setDynamic()

    final static Var IN_NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("in-ns"), F)
    final static Var NS_VAR = Var.intern(CLOIURE_NS, Symbol.intern("ns"), F)
    final static Var FN_LOADER_VAR = Var.intern(CLOIURE_NS, Symbol.intern("*fn-loader*"), nil).setDynamic()
    static final Var PRINT_INITIALIZED = Var.intern(CLOIURE_NS, Symbol.intern("print-initialized"))
    static final Var PR_ON = Var.intern(CLOIURE_NS, Symbol.intern("pr-on"))

    final static IFn inNamespace = new AFn()
    (§
        public Object invoke(Object arg1)
        (§
            Symbol nsname = (Symbol) arg1
            Namespace ns = Namespace.findOrCreate(nsname)
            CURRENT_NS.set(ns)
            (§ return (§ expr ns))
        )
    )

    final static IFn bootNamespace = new AFn()
    (§
        public Object invoke(Object __form, Object __env, Object arg1)
        (§
            Symbol nsname = (Symbol) arg1
            Namespace ns = Namespace.findOrCreate(nsname)
            CURRENT_NS.set(ns)
            (§ return (§ expr ns))
        )
    )

    public static List<String> processCommandLine(String[] args)
    (§
        List<String> arglist = Arrays.asList(args)
        int split = arglist.indexOf("--")
        if (split >= 0)
        (§
            CMD_LINE_ARGS.bindRoot(RT.seq(arglist.subList(split + 1, args.length)))
            (§ return (§ expr arglist.subList(0, split)))
        )
        (§ return (§ expr arglist))
    )

    ;; duck typing stderr plays nice with e.g. swank
    public static PrintWriter errPrintWriter()
    (§
        Writer w = (Writer) ERR.deref()
        if (w instanceof PrintWriter)
        (§
            (§ return (§ expr (PrintWriter) w))
        )
        else
        (§
            (§ return (§ expr new PrintWriter(w)))
        )
    )

    static public final Object[] EMPTY_ARRAY = new Object[] (§)
    static public final Comparator DEFAULT_COMPARATOR = new DefaultComparator()

    private static final class DefaultComparator implements Comparator, Serializable
    (§
        public int compare(Object o1, Object o2)
        (§
            (§ return (§ expr Util.compare(o1, o2)))
        )

        private Object readResolve() throws ObjectStreamException
        (§
            ;; ensures that we aren't hanging onto a new default comparator for every
            ;; sorted set, etc., we deserialize
            (§ return (§ expr DEFAULT_COMPARATOR))
        )
    )

    static AtomicInteger id = new AtomicInteger(1)

    static public void addURL(Object url) throws MalformedURLException
    (§
        URL u = (url instanceof String) ? (new URL((String) url)) :or (URL) url
        ClassLoader ccl = Thread.currentThread().getContextClassLoader()
        if (ccl instanceof DynamicClassLoader)
        (§
            ((DynamicClassLoader)ccl).addURL(u)
        )
        else
        (§
            throw new IllegalAccessError("Context classloader is not a DynamicClassLoader")
        )
    )

    public static boolean checkSpecAsserts = Boolean.getBoolean("cloiure.spec.check-asserts")
    public static boolean instrumentMacros = ! Boolean.getBoolean("cloiure.spec.skip-macros")
    static volatile boolean CHECK_SPECS = false

    static
    (§
        Keyword arglistskw = Keyword.intern(nil, "arglists")
        Symbol namesym = Symbol.intern("name")
        OUT.setTag(Symbol.intern("java.io.Writer"))
        CURRENT_NS.setTag(Symbol.intern("cloiure.lang.Namespace"))
        AGENT.setMeta(map(DOC_KEY, "The agent currently running an action on this thread, else nil"))
        AGENT.setTag(Symbol.intern("cloiure.lang.Agent"))
        MATH_CONTEXT.setTag(Symbol.intern("java.math.MathContext"))
        Var nv = Var.intern(CLOIURE_NS, NAMESPACE, bootNamespace)
        nv.setMacro()
        Var v
        v = Var.intern(CLOIURE_NS, IN_NAMESPACE, inNamespace)
        v.setMeta(map(DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", arglistskw, list(vector(namesym))))
        v = Var.intern(CLOIURE_NS, LOAD_FILE, new AFn()
        (§
            public Object invoke(Object arg1)
            (§
                try
                (§
                    (§ return (§ expr Compiler.loadFile((String) arg1)))
                )
                catch (IOException e)
                (§
                    throw Util.sneakyThrow(e)
                )
            )
        ))
        v.setMeta(map(DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", arglistskw, list(vector(namesym))))
        try
        (§
            doInit()
        )
        catch (Exception e)
        (§
            throw Util.sneakyThrow(e)
        )

        CHECK_SPECS = RT.instrumentMacros
    )

    static public Keyword keyword(String ns, String name)
    (§
        (§ return (§ expr Keyword.intern((Symbol.intern(ns, name)))))
    )

    static public Var var(String ns, String name)
    (§
        (§ return (§ expr Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name))))
    )

    static public Var var(String ns, String name, Object init)
    (§
        (§ return (§ expr Var.intern(Namespace.findOrCreate(Symbol.intern(nil, ns)), Symbol.intern(nil, name), init)))
    )

    public static void loadResourceScript(String name) throws IOException
    (§
        loadResourceScript(name, true)
    )

    public static void maybeLoadResourceScript(String name) throws IOException
    (§
        loadResourceScript(name, false)
    )

    public static void loadResourceScript(String name, boolean failIfNotFound) throws IOException
    (§
        loadResourceScript(RT.class, name, failIfNotFound)
    )

    public static void loadResourceScript(Class c, String name) throws IOException
    (§
        loadResourceScript(c, name, true)
    )

    public static void loadResourceScript(Class c, String name, boolean failIfNotFound) throws IOException
    (§
        int slash = name.lastIndexOf(\/)
        String file = (slash >= 0) ? name.substring(slash + 1) :or name
        InputStream ins = resourceAsStream(baseLoader(), name)
        if (ins != nil)
        (§
            try
            (§
                Compiler.load(new InputStreamReader(ins, UTF8), name, file)
            )
            finally
            (§
                ins.close()
            )
        )
        else if (failIfNotFound)
        (§
            throw new FileNotFoundException("Could not locate Cloiure resource on classpath: " + name)
        )
    )

    static public void init()
    (§
        RT.errPrintWriter().println("No need to call RT.init() anymore")
    )

    static public long lastModified(URL url, String libfile) throws IOException
    (§
        URLConnection connection = url.openConnection()
        try
        (§
            if (url.getProtocol().equals("jar"))
            (§
                (§ return (§ expr ((JarURLConnection) connection).getJarFile().getEntry(libfile).getTime()))
            )
            else
            (§
                (§ return (§ expr connection.getLastModified()))
            )
        )
        finally
        (§
            InputStream ins = connection.getInputStream()
            if (ins != nil)
            (§
                ins.close()
            )
        )
    )

    static void compile(String cljfile) throws IOException
    (§
        InputStream ins = resourceAsStream(baseLoader(), cljfile)
        if (ins != nil)
        (§
            try
            (§
                Compiler.compile(new InputStreamReader(ins, UTF8), cljfile, cljfile.substring(1 + cljfile.lastIndexOf("/")))
            )
            finally
            (§
                ins.close()
            )
        )
        else
        (§
            throw new FileNotFoundException("Could not locate Cloiure resource on classpath: " + cljfile)
        )
    )

    static public void load(String scriptbase) throws IOException, ClassNotFoundException
    (§
        load(scriptbase, true)
    )

    static public void load(String scriptbase, boolean failIfNotFound) throws IOException, ClassNotFoundException
    (§
        String classfile = scriptbase + LOADER_SUFFIX + ".class"
        String cljfile = scriptbase + ".cli"
        String scriptfile = cljfile
        URL classURL = getResource(baseLoader(), classfile)
        URL cljURL = getResource(baseLoader(), scriptfile)
        if (cljURL == nil)
        (§
            scriptfile = scriptbase + ".clic"
            cljURL = getResource(baseLoader(), scriptfile)
        )
        boolean loaded = false

        if ((classURL != nil && (cljURL == nil || lastModified(classURL, classfile) > lastModified(cljURL, scriptfile))) || classURL == nil)
        (§
            try
            (§
                Var.pushThreadBindings(RT.mapUniqueKeys(
                            CURRENT_NS, CURRENT_NS.deref(),
                            WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                            RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
                ))
                loaded = (loadClassForName(scriptbase.replace(\/, \.) + LOADER_SUFFIX) != nil)
            )
            finally
            (§
                Var.popThreadBindings()
            )
        )
        if (!loaded && cljURL != nil)
        (§
            if (booleanCast(Compiler.COMPILE_FILES.deref()))
            (§
                compile(scriptfile)
            )
            else
            (§
                loadResourceScript(RT.class, scriptfile)
            )
        )
        else if (!loaded && failIfNotFound)
        (§
            throw new FileNotFoundException(String.format("Could not locate %s or %s on classpath.%s", classfile, cljfile, scriptbase.contains("_") ? " Please check that namespaces with dashes use underscores in the Cloiure file name." :or ""))
        )
    )

    static void doInit() throws ClassNotFoundException, IOException
    (§
        load("cloiure/core")

        Var.pushThreadBindings(RT.mapUniqueKeys(
                    CURRENT_NS, CURRENT_NS.deref(),
                    WARN_ON_REFLECTION, WARN_ON_REFLECTION.deref(),
                    RT.UNCHECKED_MATH, RT.UNCHECKED_MATH.deref()
        ))
        try
        (§
            Symbol USER = Symbol.intern("user")
            Symbol CLOIURE = Symbol.intern("cloiure.core")

            Var in_ns = var("cloiure.core", "in-ns")
            Var refer = var("cloiure.core", "refer")
            in_ns.invoke(USER)
            refer.invoke(CLOIURE)
            maybeLoadResourceScript("user.cli")

            ;; start socket servers
            Var require = var("cloiure.core", "require")
            Symbol SERVER = Symbol.intern("cloiure.core.server")
            require.invoke(SERVER)
            Var start_servers = var("cloiure.core.server", "start-servers")
            start_servers.invoke(System.getProperties())
        )
        finally
        (§
            Var.popThreadBindings()
        )
    )

    static public int nextID()
    (§
        (§ return (§ expr id.getAndIncrement()))
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    public static void loadLibrary(String libname)
    (§
        System.loadLibrary(libname)
    )

    private static final int CHUNK_SIZE = 32

    public static ISeq chunkIteratorSeq(final Iterator iter)
    (§
        if (iter.hasNext())
        (§
            (§ return (§ expr new LazySeq(new AFn()
            (§
                public Object invoke()
                (§
                    Object[] arr = new Object[CHUNK_SIZE]
                    int n = 0
                    while (iter.hasNext() && n < CHUNK_SIZE)
                        arr[n++] = iter.next()
                    (§ return (§ expr new ChunkedCons(new ArrayChunk(arr, 0, n), chunkIteratorSeq(iter))))
                )
            ))))
        )
        (§ return (§ expr nil))
    )

    static public ISeq seq(Object coll)
    (§
        if (coll instanceof ASeq)
        (§
            (§ return (§ expr (ASeq) coll))
        )
        else if (coll instanceof LazySeq)
        (§
            (§ return (§ expr ((LazySeq) coll).seq()))
        )
        else
        (§
            (§ return (§ expr seqFrom(coll)))
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    static ISeq seqFrom(Object coll)
    (§
        if (coll instanceof Seqable)
        (§
            (§ return (§ expr ((Seqable) coll).seq()))
        )
        else if (coll == nil)
        (§
            (§ return (§ expr nil))
        )
        else if (coll instanceof Iterable)
        (§
            (§ return (§ expr chunkIteratorSeq(((Iterable) coll).iterator())))
        )
        else if (coll.getClass().isArray())
        (§
            (§ return (§ expr ArraySeq.createFromObject(coll)))
        )
        else if (coll instanceof CharSequence)
        (§
            (§ return (§ expr StringSeq.create((CharSequence) coll)))
        )
        else if (coll instanceof Map)
        (§
            (§ return (§ expr seq(((Map) coll).entrySet())))
        )
        else
        (§
            Class c = coll.getClass()
            Class sc = c.getSuperclass()
            throw new IllegalArgumentException("Don't know how to create ISeq from: " + c.getName())
        )
    )

    static public boolean canSeq(Object coll)
    (§
        (§ return (§ expr coll instanceof ISeq
            || coll instanceof Seqable
            || coll == nil
            || coll instanceof Iterable
            || coll.getClass().isArray()
            || coll instanceof CharSequence
            || coll instanceof Map))
    )

    static public Iterator iter(Object coll)
    (§
        if (coll instanceof Iterable)
        (§
            (§ return (§ expr ((Iterable)coll).iterator()))
        )
        else if (coll == nil)
        (§
            (§ return (§ expr new Iterator()
            (§
                public boolean hasNext()
                (§
                    (§ return (§ expr false))
                )

                public Object next()
                (§
                    throw new NoSuchElementException()
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )))
        )
        else if (coll instanceof Map)
        (§
            (§ return (§ expr ((Map)coll).entrySet().iterator()))
        )
        else if (coll instanceof String)
        (§
            final String s = (String) coll
            (§ return (§ expr new Iterator()
            (§
                int i = 0

                public boolean hasNext()
                (§
                    (§ return (§ expr (i < s.length())))
                )

                public Object next()
                (§
                    (§ return (§ expr s.charAt(i++)))
                )

                public void remove()
                (§
                    throw new UnsupportedOperationException()
                )
            )))
        )
        else if (coll.getClass().isArray())
        (§
            (§ return (§ expr ArrayIter.createFromObject(coll)))
        )
        else
        (§
            (§ return (§ expr iter(seq(coll))))
        )
    )

    static public Object seqOrElse(Object o)
    (§
        (§ return (§ expr (seq(o) == nil) ? nil :or o))
    )

    static public ISeq keys(Object coll)
    (§
        if (coll instanceof IPersistentMap)
        (§
            (§ return (§ expr APersistentMap.KeySeq.createFromMap((IPersistentMap)coll)))
        )
        else
        (§
            (§ return (§ expr APersistentMap.KeySeq.create(seq(coll))))
        )
    )

    static public ISeq vals(Object coll)
    (§
        if (coll instanceof IPersistentMap)
        (§
            (§ return (§ expr APersistentMap.ValSeq.createFromMap((IPersistentMap)coll)))
        )
        else
        (§
            (§ return (§ expr APersistentMap.ValSeq.create(seq(coll))))
        )
    )

    static public IPersistentMap meta(Object x)
    (§
        if (x instanceof IMeta)
        (§
            (§ return (§ expr ((IMeta) x).meta()))
        )
        (§ return (§ expr nil))
    )

    public static int count(Object o)
    (§
        if (o instanceof Counted)
        (§
            (§ return (§ expr ((Counted) o).count()))
        )
        (§ return (§ expr countFrom(Util.ret1(o, o = nil))))
    )

    static int countFrom(Object o)
    (§
        if (o == nil)
        (§
            (§ return (§ expr 0))
        )
        else if (o instanceof IPersistentCollection)
        (§
            ISeq s = seq(o)
            o = nil
            int i = 0
            for (  s != nil s = s.next())
            (§
                if (s instanceof Counted)
                (§
                    (§ return (§ expr i + s.count()))
                )
                i++
            )
            (§ return (§ expr i))
        )
        else if (o instanceof CharSequence)
        (§
            (§ return (§ expr ((CharSequence) o).length()))
        )
        else if (o instanceof Collection)
        (§
            (§ return (§ expr ((Collection) o).size()))
        )
        else if (o instanceof Map)
        (§
            (§ return (§ expr ((Map) o).size()))
        )
        else if (o instanceof Map.Entry)
        (§
            (§ return (§ expr 2))
        )
        else if (o.getClass().isArray())
        (§
            (§ return (§ expr Array.getLength(o)))
        )

        throw new UnsupportedOperationException("count not supported on this type: " + o.getClass().getSimpleName())
    )

    static public IPersistentCollection conj(IPersistentCollection coll, Object x)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr new PersistentList(x)))
        )
        (§ return (§ expr coll.cons(x)))
    )

    static public ISeq cons(Object x, Object coll)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr new PersistentList(x)))
        )
        else if (coll instanceof ISeq)
        (§
            (§ return (§ expr new Cons(x, (ISeq) coll)))
        )
        else
        (§
            (§ return (§ expr new Cons(x, seq(coll))))
        )
    )

    static public Object first(Object x)
    (§
        if (x instanceof ISeq)
        (§
            (§ return (§ expr ((ISeq) x).first()))
        )
        ISeq seq = seq(x)
        if (seq == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr seq.first()))
    )

    static public Object second(Object x)
    (§
        (§ return (§ expr first(next(x))))
    )

    static public Object third(Object x)
    (§
        (§ return (§ expr first(next(next(x)))))
    )

    static public Object fourth(Object x)
    (§
        (§ return (§ expr first(next(next(next(x))))))
    )

    static public ISeq next(Object x)
    (§
        if (x instanceof ISeq)
        (§
            (§ return (§ expr ((ISeq) x).next()))
        )
        ISeq seq = seq(x)
        if (seq == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr seq.next()))
    )

    static public ISeq more(Object x)
    (§
        if (x instanceof ISeq)
        (§
            (§ return (§ expr ((ISeq) x).more()))
        )
        ISeq seq = seq(x)
        if (seq == nil)
        (§
            (§ return (§ expr PersistentList.EMPTY))
        )
        (§ return (§ expr seq.more()))
    )

    static public Object peek(Object x)
    (§
        if (x == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr ((IPersistentStack) x).peek()))
    )

    static public Object pop(Object x)
    (§
        if (x == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr ((IPersistentStack) x).pop()))
    )

    static public Object get(Object coll, Object key)
    (§
        if (coll instanceof ILookup)
        (§
            (§ return (§ expr ((ILookup) coll).valAt(key)))
        )
        (§ return (§ expr getFrom(coll, key)))
    )

    static Object getFrom(Object coll, Object key)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr nil))
        )
        else if (coll instanceof Map)
        (§
            Map m = (Map) coll
            (§ return (§ expr m.get(key)))
        )
        else if (coll instanceof IPersistentSet)
        (§
            IPersistentSet set = (IPersistentSet) coll
            (§ return (§ expr set.get(key)))
        )
        else if (key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
        (§
            int n = ((Number) key).intValue()
            if (n >= 0 && n < count(coll))
            (§
                (§ return (§ expr nth(coll, n)))
            )
            (§ return (§ expr nil))
        )
        else if (coll instanceof ITransientSet)
        (§
            ITransientSet set = (ITransientSet) coll
            (§ return (§ expr set.get(key)))
        )

        (§ return (§ expr nil))
    )

    static public Object get(Object coll, Object key, Object notFound)
    (§
        if (coll instanceof ILookup)
        (§
            (§ return (§ expr ((ILookup) coll).valAt(key, notFound)))
        )
        (§ return (§ expr getFrom(coll, key, notFound)))
    )

    static Object getFrom(Object coll, Object key, Object notFound)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr notFound))
        )
        else if (coll instanceof Map)
        (§
            Map m = (Map) coll
            if (m.containsKey(key))
            (§
                (§ return (§ expr m.get(key)))
            )
            (§ return (§ expr notFound))
        )
        else if (coll instanceof IPersistentSet)
        (§
            IPersistentSet set = (IPersistentSet) coll
            if (set.contains(key))
            (§
                (§ return (§ expr set.get(key)))
            )
            (§ return (§ expr notFound))
        )
        else if (key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
        (§
            int n = ((Number) key).intValue()
            (§ return (§ expr (n >= 0 && n < count(coll)) ? nth(coll, n) :or notFound))
        )
        else if (coll instanceof ITransientSet)
        (§
            ITransientSet set = (ITransientSet) coll
            if (set.contains(key))
            (§
                (§ return (§ expr set.get(key)))
            )
            (§ return (§ expr notFound))
        )
        (§ return (§ expr notFound))
    )

    static public Associative assoc(Object coll, Object key, Object val)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr new PersistentArrayMap(new Object[] (§ key, val ))))
        )
        (§ return (§ expr ((Associative) coll).assoc(key, val)))
    )

    static public Object contains(Object coll, Object key)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr F))
        )
        else if (coll instanceof Associative)
        (§
            (§ return (§ expr ((Associative) coll).containsKey(key) ? T :or F))
        )
        else if (coll instanceof IPersistentSet)
        (§
            (§ return (§ expr ((IPersistentSet) coll).contains(key) ? T :or F))
        )
        else if (coll instanceof Map)
        (§
            Map m = (Map) coll
            (§ return (§ expr m.containsKey(key) ? T :or F))
        )
        else if (coll instanceof Set)
        (§
            Set s = (Set) coll
            (§ return (§ expr s.contains(key) ? T :or F))
        )
        else if (key instanceof Number && (coll instanceof String || coll.getClass().isArray()))
        (§
            int n = ((Number) key).intValue()
            (§ return (§ expr (n >= 0 && n < count(coll)) ? T :or F))
        )
        else if (coll instanceof ITransientSet)
        (§
            (§ return (§ expr ((ITransientSet)coll).contains(key) ? T :or F))
        )
        else if (coll instanceof ITransientAssociative2)
        (§
            (§ return (§ expr (((ITransientAssociative2)coll).containsKey(key)) ? T :or F))
        )
        throw new IllegalArgumentException("contains? not supported on type: " + coll.getClass().getName())
    )

    static public Object find(Object coll, Object key)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr nil))
        )
        else if (coll instanceof Associative)
        (§
            (§ return (§ expr ((Associative) coll).entryAt(key)))
        )
        else if (coll instanceof Map)
        (§
            Map m = (Map) coll
            if (m.containsKey(key))
            (§
                (§ return (§ expr MapEntry.create(key, m.get(key))))
            )
            (§ return (§ expr nil))
        )
        else if (coll instanceof ITransientAssociative2)
        (§
            (§ return (§ expr ((ITransientAssociative2) coll).entryAt(key)))
        )
        throw new IllegalArgumentException("find not supported on type: " + coll.getClass().getName())
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    static public ISeq findKey(Keyword key, ISeq keyvals)
    (§
        while (keyvals != nil)
        (§
            ISeq r = keyvals.next()
            if (r == nil)
            (§
                throw Util.runtimeException("Malformed keyword argslist")
            )
            if (keyvals.first() == key)
            (§
                (§ return (§ expr r))
            )
            keyvals = r.next()
        )
        (§ return (§ expr nil))
    )

    static public Object dissoc(Object coll, Object key)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr ((IPersistentMap) coll).without(key)))
    )

    static public Object nth(Object coll, int n)
    (§
        if (coll instanceof Indexed)
        (§
            (§ return (§ expr ((Indexed) coll).nth(n)))
        )
        (§ return (§ expr nthFrom(Util.ret1(coll, coll = nil), n)))
    )

    static Object nthFrom(Object coll, int n)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr nil))
        )
        else if (coll instanceof CharSequence)
        (§
            (§ return (§ expr Character.valueOf(((CharSequence) coll).charAt(n))))
        )
        else if (coll.getClass().isArray())
        (§
            (§ return (§ expr Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))))
        )
        else if (coll instanceof RandomAccess)
        (§
            (§ return (§ expr ((List) coll).get(n)))
        )
        else if (coll instanceof Matcher)
        (§
            (§ return (§ expr ((Matcher) coll).group(n)))
        )
        else if (coll instanceof Map.Entry)
        (§
            Map.Entry e = (Map.Entry) coll
            if (n == 0)
            (§
                (§ return (§ expr e.getKey()))
            )
            else if (n == 1)
            (§
                (§ return (§ expr e.getValue()))
            )
            throw new IndexOutOfBoundsException()
        )
        else if (coll instanceof Sequential)
        (§
            ISeq seq = RT.seq(coll)
            coll = nil
            for (int i = 0 i <= n && seq != nil ++i, seq = seq.next())
            (§
                if (i == n)
                (§
                    (§ return (§ expr seq.first()))
                )
            )
            throw new IndexOutOfBoundsException()
        )
        else
        (§
            throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())
        )
    )

    static public Object nth(Object coll, int n, Object notFound)
    (§
        if (coll instanceof Indexed)
        (§
            Indexed v = (Indexed) coll
            (§ return (§ expr v.nth(n, notFound)))
        )
        (§ return (§ expr nthFrom(coll, n, notFound)))
    )

    static Object nthFrom(Object coll, int n, Object notFound)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr notFound))
        )
        else if (n < 0)
        (§
            (§ return (§ expr notFound))
        )
        else if (coll instanceof CharSequence)
        (§
            CharSequence s = (CharSequence) coll
            if (n < s.length())
            (§
                (§ return (§ expr Character.valueOf(s.charAt(n))))
            )
            (§ return (§ expr notFound))
        )
        else if (coll.getClass().isArray())
        (§
            if (n < Array.getLength(coll))
            (§
                (§ return (§ expr Reflector.prepRet(coll.getClass().getComponentType(), Array.get(coll, n))))
            )
            (§ return (§ expr notFound))
        )
        else if (coll instanceof RandomAccess)
        (§
            List list = (List) coll
            if (n < list.size())
            (§
                (§ return (§ expr list.get(n)))
            )
            (§ return (§ expr notFound))
        )
        else if (coll instanceof Matcher)
        (§
            Matcher m = (Matcher) coll
            if (n < m.groupCount())
            (§
                (§ return (§ expr m.group(n)))
            )
            (§ return (§ expr notFound))
        )
        else if (coll instanceof Map.Entry)
        (§
            Map.Entry e = (Map.Entry) coll
            if (n == 0)
            (§
                (§ return (§ expr e.getKey()))
            )
            else if (n == 1)
            (§
                (§ return (§ expr e.getValue()))
            )
            (§ return (§ expr notFound))
        )
        else if (coll instanceof Sequential)
        (§
            ISeq seq = RT.seq(coll)
            coll = nil
            for (int i = 0 i <= n && seq != nil ++i, seq = seq.next())
            (§
                if (i == n)
                (§
                    (§ return (§ expr seq.first()))
                )
            )
            (§ return (§ expr notFound))
        )
        else
        (§
            throw new UnsupportedOperationException("nth not supported on this type: " + coll.getClass().getSimpleName())
        )
    )

    static public Object assocN(int n, Object val, Object coll)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr nil))
        )
        else if (coll instanceof IPersistentVector)
        (§
            (§ return (§ expr ((IPersistentVector) coll).assocN(n, val)))
        )
        else if (coll instanceof Object[])
        (§
            ;; hmm... this is not persistent
            Object[] array = ((Object[]) coll)
            array[n] = val
            (§ return (§ expr array))
        )
        else
        (§
            (§ return (§ expr nil))
        )
    )

    static boolean hasTag(Object o, Object tag)
    (§
        (§ return (§ expr Util.equals(tag, RT.get(RT.meta(o), TAG_KEY))))
    )

    static public Object box(Object x)
    (§
        (§ return (§ expr x))
    )

    static public Character box(char x)
    (§
        (§ return (§ expr Character.valueOf(x)))
    )

    static public Object box(boolean x)
    (§
        (§ return (§ expr x ? T :or F))
    )

    static public Object box(Boolean x)
    (§
        (§ return (§ expr x))
    )

    static public Number box(byte x)
    (§
        (§ return (§ expr x))
    )

    static public Number box(short x)
    (§
        (§ return (§ expr x))
    )

    static public Number box(int x)
    (§
        (§ return (§ expr x))
    )

    static public Number box(long x)
    (§
        (§ return (§ expr x))
    )

    static public Number box(float x)
    (§
        (§ return (§ expr x))
    )

    static public Number box(double x)
    (§
        (§ return (§ expr x))
    )

    static public char charCast(Object x)
    (§
        if (x instanceof Character)
        (§
            (§ return (§ expr ((Character) x).charValue()))
        )
        long n = ((Number) x).longValue()
        if (n < Character.MIN_VALUE || n > Character.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        (§ return (§ expr (char) n))
    )

    static public char charCast(byte x)
    (§
        char i = (char) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        (§ return (§ expr i))
    )

    static public char charCast(short x)
    (§
        char i = (char) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        (§ return (§ expr i))
    )

    static public char charCast(char x)
    (§
        (§ return (§ expr x))
    )

    static public char charCast(int x)
    (§
        char i = (char) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        (§ return (§ expr i))
    )

    static public char charCast(long x)
    (§
        char i = (char) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for char: " + x)
        )
        (§ return (§ expr i))
    )

    static public char charCast(float x)
    (§
        if (x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
        (§
            (§ return (§ expr (char) x))
        )
        throw new IllegalArgumentException("Value out of range for char: " + x)
    )

    static public char charCast(double x)
    (§
        if (x >= Character.MIN_VALUE && x <= Character.MAX_VALUE)
        (§
            (§ return (§ expr (char) x))
        )
        throw new IllegalArgumentException("Value out of range for char: " + x)
    )

    static public boolean booleanCast(Object x)
    (§
        if (x instanceof Boolean)
        (§
            (§ return (§ expr ((Boolean) x).booleanValue()))
        )
        (§ return (§ expr (x != nil)))
    )

    static public boolean booleanCast(boolean x)
    (§
        (§ return (§ expr x))
    )

    static public byte byteCast(Object x)
    (§
        if (x instanceof Byte)
        (§
            (§ return (§ expr ((Byte) x).byteValue()))
        )
        long n = longCast(x)
        if (n < Byte.MIN_VALUE || n > Byte.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for byte: " + x)
        )
        (§ return (§ expr (byte) n))
    )

    static public byte byteCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public byte byteCast(short x)
    (§
        byte i = (byte) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for byte: " + x)
        )
        (§ return (§ expr i))
    )

    static public byte byteCast(int x)
    (§
        byte i = (byte) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for byte: " + x)
        )
        (§ return (§ expr i))
    )

    static public byte byteCast(long x)
    (§
        byte i = (byte) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for byte: " + x)
        )
        (§ return (§ expr i))
    )

    static public byte byteCast(float x)
    (§
        if (x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
        (§
            (§ return (§ expr (byte) x))
        )
        throw new IllegalArgumentException("Value out of range for byte: " + x)
    )

    static public byte byteCast(double x)
    (§
        if (x >= Byte.MIN_VALUE && x <= Byte.MAX_VALUE)
        (§
            (§ return (§ expr (byte) x))
        )
        throw new IllegalArgumentException("Value out of range for byte: " + x)
    )

    static public short shortCast(Object x)
    (§
        if (x instanceof Short)
        (§
            (§ return (§ expr ((Short) x).shortValue()))
        )
        long n = longCast(x)
        if (n < Short.MIN_VALUE || n > Short.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for short: " + x)
        )
        (§ return (§ expr (short) n))
    )

    static public short shortCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public short shortCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public short shortCast(int x)
    (§
        short i = (short) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for short: " + x)
        )
        (§ return (§ expr i))
    )

    static public short shortCast(long x)
    (§
        short i = (short) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for short: " + x)
        )
        (§ return (§ expr i))
    )

    static public short shortCast(float x)
    (§
        if (x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
        (§
            (§ return (§ expr (short) x))
        )
        throw new IllegalArgumentException("Value out of range for short: " + x)
    )

    static public short shortCast(double x)
    (§
        if (x >= Short.MIN_VALUE && x <= Short.MAX_VALUE)
        (§
            (§ return (§ expr (short) x))
        )
        throw new IllegalArgumentException("Value out of range for short: " + x)
    )

    static public int intCast(Object x)
    (§
        if (x instanceof Integer)
        (§
            (§ return (§ expr ((Integer)x).intValue()))
        )
        if (x instanceof Number)
        (§
            long n = longCast(x)
            (§ return (§ expr intCast(n)))
        )
        (§ return (§ expr ((Character) x).charValue()))
    )

    static public int intCast(char x)
    (§
        (§ return (§ expr x))
    )

    static public int intCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public int intCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public int intCast(int x)
    (§
        (§ return (§ expr x))
    )

    static public int intCast(float x)
    (§
        if (x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for int: " + x)
        )
        (§ return (§ expr (int) x))
    )

    static public int intCast(long x)
    (§
        int i = (int) x
        if (i != x)
        (§
            throw new IllegalArgumentException("Value out of range for int: " + x)
        )
        (§ return (§ expr i))
    )

    static public int intCast(double x)
    (§
        if (x < Integer.MIN_VALUE || x > Integer.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for int: " + x)
        )
        (§ return (§ expr (int) x))
    )

    static public long longCast(Object x)
    (§
        if (x instanceof Integer || x instanceof Long)
        (§
            (§ return (§ expr ((Number) x).longValue()))
        )
        else if (x instanceof BigInt)
        (§
            BigInt bi = (BigInt) x
            if (bi.bipart == nil)
            (§
                (§ return (§ expr bi.lpart))
            )
            else
            (§
                throw new IllegalArgumentException("Value out of range for long: " + x)
            )
        )
        else if (x instanceof BigInteger)
        (§
            BigInteger bi = (BigInteger) x
            if (bi.bitLength() < 64)
            (§
                (§ return (§ expr bi.longValue()))
            )
            else
            (§
                throw new IllegalArgumentException("Value out of range for long: " + x)
            )
        )
        else if (x instanceof Byte || x instanceof Short)
        (§
            (§ return (§ expr ((Number) x).longValue()))
        )
        else if (x instanceof Ratio)
        (§
            (§ return (§ expr longCast(((Ratio)x).bigIntegerValue())))
        )
        else if (x instanceof Character)
        (§
            (§ return (§ expr longCast(((Character) x).charValue())))
        )
        else
        (§
            (§ return (§ expr longCast(((Number)x).doubleValue())))
        )
    )

    static public long longCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public long longCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public long longCast(int x)
    (§
        (§ return (§ expr x))
    )

    static public long longCast(float x)
    (§
        if (x < Long.MIN_VALUE || x > Long.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for long: " + x)
        )
        (§ return (§ expr (long) x))
    )

    static public long longCast(long x)
    (§
        (§ return (§ expr x))
    )

    static public long longCast(double x)
    (§
        if (x < Long.MIN_VALUE || x > Long.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for long: " + x)
        )
        (§ return (§ expr (long) x))
    )

    static public float floatCast(Object x)
    (§
        if (x instanceof Float)
        (§
            (§ return (§ expr ((Float) x).floatValue()))
        )
        double n = ((Number) x).doubleValue()
        if (n < -Float.MAX_VALUE || n > Float.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for float: " + x)
        )
        (§ return (§ expr (float) n))
    )

    static public float floatCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public float floatCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public float floatCast(int x)
    (§
        (§ return (§ expr x))
    )

    static public float floatCast(float x)
    (§
        (§ return (§ expr x))
    )

    static public float floatCast(long x)
    (§
        (§ return (§ expr x))
    )

    static public float floatCast(double x)
    (§
        if (x < -Float.MAX_VALUE || x > Float.MAX_VALUE)
        (§
            throw new IllegalArgumentException("Value out of range for float: " + x)
        )
        (§ return (§ expr (float) x))
    )

    static public double doubleCast(Object x)
    (§
        (§ return (§ expr ((Number) x).doubleValue()))
    )

    static public double doubleCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public double doubleCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public double doubleCast(int x)
    (§
        (§ return (§ expr x))
    )

    static public double doubleCast(float x)
    (§
        (§ return (§ expr x))
    )

    static public double doubleCast(long x)
    (§
        (§ return (§ expr x))
    )

    static public double doubleCast(double x)
    (§
        (§ return (§ expr x))
    )

    static public byte uncheckedByteCast(Object x)
    (§
        (§ return (§ expr ((Number) x).byteValue()))
    )

    static public byte uncheckedByteCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public byte uncheckedByteCast(short x)
    (§
        (§ return (§ expr (byte) x))
    )

    static public byte uncheckedByteCast(int x)
    (§
        (§ return (§ expr (byte) x))
    )

    static public byte uncheckedByteCast(long x)
    (§
        (§ return (§ expr (byte) x))
    )

    static public byte uncheckedByteCast(float x)
    (§
        (§ return (§ expr (byte) x))
    )

    static public byte uncheckedByteCast(double x)
    (§
        (§ return (§ expr (byte) x))
    )

    static public short uncheckedShortCast(Object x)
    (§
        (§ return (§ expr ((Number) x).shortValue()))
    )

    static public short uncheckedShortCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public short uncheckedShortCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public short uncheckedShortCast(int x)
    (§
        (§ return (§ expr (short) x))
    )

    static public short uncheckedShortCast(long x)
    (§
        (§ return (§ expr (short) x))
    )

    static public short uncheckedShortCast(float x)
    (§
        (§ return (§ expr (short) x))
    )

    static public short uncheckedShortCast(double x)
    (§
        (§ return (§ expr (short) x))
    )

    static public char uncheckedCharCast(Object x)
    (§
        if (x instanceof Character)
        (§
            (§ return (§ expr ((Character) x).charValue()))
        )
        (§ return (§ expr (char) ((Number) x).longValue()))
    )

    static public char uncheckedCharCast(byte x)
    (§
        (§ return (§ expr (char) x))
    )

    static public char uncheckedCharCast(short x)
    (§
        (§ return (§ expr (char) x))
    )

    static public char uncheckedCharCast(char x)
    (§
        (§ return (§ expr x))
    )

    static public char uncheckedCharCast(int x)
    (§
        (§ return (§ expr (char) x))
    )

    static public char uncheckedCharCast(long x)
    (§
        (§ return (§ expr (char) x))
    )

    static public char uncheckedCharCast(float x)
    (§
        (§ return (§ expr (char) x))
    )

    static public char uncheckedCharCast(double x)
    (§
        (§ return (§ expr (char) x))
    )

    static public int uncheckedIntCast(Object x)
    (§
        if (x instanceof Number)
        (§
            (§ return (§ expr ((Number)x).intValue()))
        )
        (§ return (§ expr ((Character) x).charValue()))
    )

    static public int uncheckedIntCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public int uncheckedIntCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public int uncheckedIntCast(char x)
    (§
        (§ return (§ expr x))
    )

    static public int uncheckedIntCast(int x)
    (§
        (§ return (§ expr x))
    )

    static public int uncheckedIntCast(long x)
    (§
        (§ return (§ expr (int) x))
    )

    static public int uncheckedIntCast(float x)
    (§
        (§ return (§ expr (int) x))
    )

    static public int uncheckedIntCast(double x)
    (§
        (§ return (§ expr (int) x))
    )

    static public long uncheckedLongCast(Object x)
    (§
        (§ return (§ expr ((Number) x).longValue()))
    )

    static public long uncheckedLongCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public long uncheckedLongCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public long uncheckedLongCast(int x)
    (§
        (§ return (§ expr x))
    )

    static public long uncheckedLongCast(long x)
    (§
        (§ return (§ expr x))
    )

    static public long uncheckedLongCast(float x)
    (§
        (§ return (§ expr (long) x))
    )

    static public long uncheckedLongCast(double x)
    (§
        (§ return (§ expr (long) x))
    )

    static public float uncheckedFloatCast(Object x)
    (§
        (§ return (§ expr ((Number) x).floatValue()))
    )

    static public float uncheckedFloatCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public float uncheckedFloatCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public float uncheckedFloatCast(int x)
    (§
        (§ return (§ expr x))
    )

    static public float uncheckedFloatCast(long x)
    (§
        (§ return (§ expr x))
    )

    static public float uncheckedFloatCast(float x)
    (§
        (§ return (§ expr x))
    )

    static public float uncheckedFloatCast(double x)
    (§
        (§ return (§ expr (float) x))
    )

    static public double uncheckedDoubleCast(Object x)
    (§
        (§ return (§ expr ((Number) x).doubleValue()))
    )

    static public double uncheckedDoubleCast(byte x)
    (§
        (§ return (§ expr x))
    )

    static public double uncheckedDoubleCast(short x)
    (§
        (§ return (§ expr x))
    )

    static public double uncheckedDoubleCast(int x)
    (§
        (§ return (§ expr x))
    )

    static public double uncheckedDoubleCast(long x)
    (§
        (§ return (§ expr x))
    )

    static public double uncheckedDoubleCast(float x)
    (§
        (§ return (§ expr x))
    )

    static public double uncheckedDoubleCast(double x)
    (§
        (§ return (§ expr x))
    )

    static public IPersistentMap map(Object... init)
    (§
        if (init == nil)
        (§
            (§ return (§ expr PersistentArrayMap.EMPTY))
        )
        else if (init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
        (§
            (§ return (§ expr PersistentArrayMap.createWithCheck(init)))
        )
        (§ return (§ expr PersistentHashMap.createWithCheck(init)))
    )

    static public IPersistentMap mapUniqueKeys(Object... init)
    (§
        if (init == nil)
        (§
            (§ return (§ expr PersistentArrayMap.EMPTY))
        )
        else if (init.length <= PersistentArrayMap.HASHTABLE_THRESHOLD)
        (§
            (§ return (§ expr new PersistentArrayMap(init)))
        )
        (§ return (§ expr PersistentHashMap.create(init)))
    )

    static public IPersistentSet set(Object... init)
    (§
        (§ return (§ expr PersistentHashSet.createWithCheck(init)))
    )

    static public IPersistentVector vector(Object... init)
    (§
        (§ return (§ expr LazilyPersistentVector.createOwning(init)))
    )

    static public IPersistentVector subvec(IPersistentVector v, int start, int end)
    (§
        if (end < start || start < 0 || end > v.count())
        (§
            throw new IndexOutOfBoundsException()
        )
        if (start == end)
        (§
            (§ return (§ expr PersistentVector.EMPTY))
        )
        (§ return (§ expr new APersistentVector.SubVector(nil, v, start, end)))
    )

    static public ISeq list()
    (§
        (§ return (§ expr nil))
    )

    static public ISeq list(Object arg1)
    (§
        (§ return (§ expr new PersistentList(arg1)))
    )

    static public ISeq list(Object arg1, Object arg2)
    (§
        (§ return (§ expr listStar(arg1, arg2, nil)))
    )

    static public ISeq list(Object arg1, Object arg2, Object arg3)
    (§
        (§ return (§ expr listStar(arg1, arg2, arg3, nil)))
    )

    static public ISeq list(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        (§ return (§ expr listStar(arg1, arg2, arg3, arg4, nil)))
    )

    static public ISeq list(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        (§ return (§ expr listStar(arg1, arg2, arg3, arg4, arg5, nil)))
    )

    static public ISeq listStar(Object arg1, ISeq rest)
    (§
        (§ return (§ expr (ISeq) cons(arg1, rest)))
    )

    static public ISeq listStar(Object arg1, Object arg2, ISeq rest)
    (§
        (§ return (§ expr (ISeq) cons(arg1, cons(arg2, rest))))
    )

    static public ISeq listStar(Object arg1, Object arg2, Object arg3, ISeq rest)
    (§
        (§ return (§ expr (ISeq) cons(arg1, cons(arg2, cons(arg3, rest)))))
    )

    static public ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, ISeq rest)
    (§
        (§ return (§ expr (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, rest))))))
    )

    static public ISeq listStar(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, ISeq rest)
    (§
        (§ return (§ expr (ISeq) cons(arg1, cons(arg2, cons(arg3, cons(arg4, cons(arg5, rest)))))))
    )

    static public ISeq arrayToList(Object[] a)
    (§
        ISeq ret = nil
        for (int i = a.length - 1 i >= 0 --i)
        (§
            ret = (ISeq) cons(a[i], ret)
        )
        (§ return (§ expr ret))
    )

    static public Object[] object_array(Object sizeOrSeq)
    (§
        if (sizeOrSeq instanceof Number)
        (§
            (§ return (§ expr new Object[((Number) sizeOrSeq).intValue()]))
        )
        else
        (§
            ISeq s = RT.seq(sizeOrSeq)
            int size = RT.count(s)
            Object[] ret = new Object[size]
            for (int i = 0 i < size && s != nil i++, s = s.next())
            (§
                ret[i] = s.first()
            )
            (§ return (§ expr ret))
        )
    )

    static public Object[] toArray(Object coll)
    (§
        if (coll == nil)
        (§
            (§ return (§ expr EMPTY_ARRAY))
        )
        else if (coll instanceof Object[])
        (§
            (§ return (§ expr (Object[]) coll))
        )
        else if (coll instanceof Collection)
        (§
            (§ return (§ expr ((Collection) coll).toArray()))
        )
        else if (coll instanceof Iterable)
        (§
            ArrayList ret = new ArrayList()
            for (Object o :in (Iterable)coll)
            (§
                ret.add(o)
            )
            (§ return (§ expr ret.toArray()))
        )
        else if (coll instanceof Map)
        (§
            (§ return (§ expr ((Map) coll).entrySet().toArray()))
        )
        else if (coll instanceof String)
        (§
            char[] chars = ((String) coll).toCharArray()
            Object[] ret = new Object[chars.length]
            for (int i = 0 i < chars.length i++)
            (§
                ret[i] = chars[i]
            )
            (§ return (§ expr ret))
        )
        else if (coll.getClass().isArray())
        (§
            ISeq s = (seq(coll))
            Object[] ret = new Object[count(s)]
            for (int i = 0 i < ret.length i++, s = s.next())
            (§
                ret[i] = s.first()
            )
            (§ return (§ expr ret))
        )
        else
        (§
            throw Util.runtimeException("Unable to convert: " + coll.getClass() + " to Object[]")
        )
    )

    static public Object[] seqToArray(ISeq seq)
    (§
        int len = length(seq)
        Object[] ret = new Object[len]
        for (int i = 0 seq != nil ++i, seq = seq.next())
        (§
            ret[i] = seq.first()
        )
        (§ return (§ expr ret))
    )

    ;; supports java Collection.toArray(T[])
    static public Object[] seqToPassedArray(ISeq seq, Object[] passed)
    (§
        Object[] dest = passed
        int len = count(seq)
        if (len > dest.length)
        (§
            dest = (Object[]) Array.newInstance(passed.getClass().getComponentType(), len)
        )
        for (int i = 0 seq != nil ++i, seq = seq.next())
        (§
            dest[i] = seq.first()
        )
        if (len < passed.length)
        (§
            dest[len] = nil
        )
        (§ return (§ expr dest))
    )

    static public Object seqToTypedArray(ISeq seq)
    (§
        Class type = (seq != nil && seq.first() != nil) ? seq.first().getClass() :or Object.class
        (§ return (§ expr seqToTypedArray(type, seq)))
    )

    static public Object seqToTypedArray(Class type, ISeq seq)
    (§
        Object ret = Array.newInstance(type, length(seq))
        if (type == Integer.TYPE)
        (§
            for (int i = 0 seq != nil ++i, seq = seq.next())
            (§
                Array.set(ret, i, intCast(seq.first()))
            )
        )
        else if (type == Byte.TYPE)
        (§
            for (int i = 0 seq != nil ++i, seq = seq.next())
            (§
                Array.set(ret, i, byteCast(seq.first()))
            )
        )
        else if (type == Float.TYPE)
        (§
            for (int i = 0 seq != nil ++i, seq = seq.next())
            (§
                Array.set(ret, i, floatCast(seq.first()))
            )
        )
        else if (type == Short.TYPE)
        (§
            for (int i = 0 seq != nil ++i, seq = seq.next())
            (§
                Array.set(ret, i, shortCast(seq.first()))
            )
        )
        else if (type == Character.TYPE)
        (§
            for (int i = 0 seq != nil ++i, seq = seq.next())
            (§
                Array.set(ret, i, charCast(seq.first()))
            )
        )
        else
        (§
            for (int i = 0 seq != nil ++i, seq = seq.next())
            (§
                Array.set(ret, i, seq.first())
            )
        )
        (§ return (§ expr ret))
    )

    static public int length(ISeq list)
    (§
        int i = 0
        for (ISeq c = list c != nil c = c.next())
        (§
            i++
        )
        (§ return (§ expr i))
    )

    static public int boundedLength(ISeq list, int limit)
    (§
        int i = 0
        for (ISeq c = list c != nil && i <= limit c = c.next())
        (§
            i++
        )
        (§ return (§ expr i))
    )

    static Character readRet(int ret)
    (§
        if (ret == -1)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr box((char) ret)))
    )

    static public Character readChar(Reader r) throws IOException
    (§
        int ret = r.read()
        (§ return (§ expr readRet(ret)))
    )

    static public Character peekChar(Reader r) throws IOException
    (§
        int ret
        if (r instanceof PushbackReader)
        (§
            ret = r.read()
            ((PushbackReader) r).unread(ret)
        )
        else
        (§
            r.mark(1)
            ret = r.read()
            r.reset()
        )

        (§ return (§ expr readRet(ret)))
    )

    static public int getLineNumber(Reader r)
    (§
        if (r instanceof LineNumberingPushbackReader)
        (§
            (§ return (§ expr ((LineNumberingPushbackReader) r).getLineNumber()))
        )
        (§ return (§ expr 0))
    )

    static public int getColumnNumber(Reader r)
    (§
        if (r instanceof LineNumberingPushbackReader)
        (§
            (§ return (§ expr ((LineNumberingPushbackReader) r).getColumnNumber()))
        )
        (§ return (§ expr 0))
    )

    static public LineNumberingPushbackReader getLineNumberingReader(Reader r)
    (§
        if (isLineNumberingReader(r))
        (§
            (§ return (§ expr (LineNumberingPushbackReader) r))
        )
        (§ return (§ expr new LineNumberingPushbackReader(r)))
    )

    static public boolean isLineNumberingReader(Reader r)
    (§
        (§ return (§ expr (r instanceof LineNumberingPushbackReader)))
    )

    static public boolean isReduced(Object r)
    (§
        (§ return (§ expr (r instanceof Reduced)))
    )

    static public String resolveClassNameInContext(String className)
    (§
        ;; todo - look up in context var
        (§ return (§ expr className))
    )

    static public boolean suppressRead()
    (§
        (§ return (§ expr booleanCast(SUPPRESS_READ.deref())))
    )

    static public String printString(Object x)
    (§
        try
        (§
            StringWriter sw = new StringWriter()
            print(x, sw)
            (§ return (§ expr sw.toString()))
        )
        catch (Exception e)
        (§
            throw Util.sneakyThrow(e)
        )
    )

    static public Object readString(String s)
    (§
        (§ return (§ expr readString(s, nil)))
    )

    static public Object readString(String s, Object opts)
    (§
        PushbackReader r = new PushbackReader(new StringReader(s))
        (§ return (§ expr LispReader.read(r, opts)))
    )

    static public void print(Object x, Writer w) throws IOException
    (§
        ;; call multimethod
        if (PRINT_INITIALIZED.isBound() && RT.booleanCast(PRINT_INITIALIZED.deref()))
        (§
            PR_ON.invoke(x, w)
        )
        else
        (§
            boolean readably = booleanCast(PRINT_READABLY.deref())
            if (x instanceof Obj)
            (§
                Obj o = (Obj) x
                if (RT.count(o.meta()) > 0 && ((readably && booleanCast(PRINT_META.deref())) || booleanCast(PRINT_DUP.deref())))
                (§
                    IPersistentMap meta = o.meta()
                    w.write("#^")
                    if (meta.count() == 1 && meta.containsKey(TAG_KEY))
                    (§
                        print(meta.valAt(TAG_KEY), w)
                    )
                    else
                    (§
                        print(meta, w)
                    )
                    w.write(\space)
                )
            )
            if (x == nil)
            (§
                w.write("nil")
            )
            else if (x instanceof ISeq || x instanceof IPersistentList)
            (§
                w.write(\()
                printInnerSeq(seq(x), w)
                w.write(\))
            )
            else if (x instanceof String)
            (§
                String s = (String) x
                if (!readably)
                (§
                    w.write(s)
                )
                else
                (§
                    w.write(\") ;; oops! "
                    for (int i = 0 i < s.length() i++)
                    (§
                        char c = s.charAt(i)
                        switch (c)
                        (§
                            (§ case \newline)
                                w.write("\\n")
                                break
                            (§ case \tab)
                                w.write("\\t")
                                break
                            (§ case \return)
                                w.write("\\r")
                                break
                            (§ case \")
                                w.write("\\\"")
                                break
                            (§ case \\)
                                w.write("\\\\")
                                break
                            (§ case \formfeed)
                                w.write("\\f")
                                break
                            (§ case \backspace)
                                w.write("\\b")
                                break
                            (§ default)
                                w.write(c)
                                break
                        )
                    )
                    w.write(\") ;; oops! "
                )
            )
            else if (x instanceof IPersistentMap)
            (§
                w.write(\{)
                for (ISeq s = seq(x) s != nil s = s.next())
                (§
                    IMapEntry e = (IMapEntry) s.first()
                    print(e.key(), w)
                    w.write(\space)
                    print(e.val(), w)
                    if (s.next() != nil)
                    (§
                        w.write(", ")
                    )
                )
                w.write(\})
            )
            else if (x instanceof IPersistentVector)
            (§
                IPersistentVector a = (IPersistentVector) x
                w.write(\[)
                for (int i = 0 i < a.count() i++)
                (§
                    print(a.nth(i), w)
                    if (i < a.count() - 1)
                    (§
                        w.write(\space)
                    )
                )
                w.write(\])
            )
            else if (x instanceof IPersistentSet)
            (§
                w.write("#{")
                for (ISeq s = seq(x) s != nil s = s.next())
                (§
                    print(s.first(), w)
                    if (s.next() != nil)
                    (§
                        w.write(" ")
                    )
                )
                w.write(\})
            )
            else if (x instanceof Character)
            (§
                char c = ((Character) x).charValue()
                if (!readably)
                (§
                    w.write(c)
                )
                else
                (§
                    w.write(\\)
                    switch (c)
                    (§
                        (§ case \newline)
                            w.write("newline")
                            break
                        (§ case \tab)
                            w.write("tab")
                            break
                        (§ case \space)
                            w.write("space")
                            break
                        (§ case \backspace)
                            w.write("backspace")
                            break
                        (§ case \formfeed)
                            w.write("formfeed")
                            break
                        (§ case \return)
                            w.write("return")
                            break
                        (§ default)
                            w.write(c)
                            break
                    )
                )
            )
            else if (x instanceof Class)
            (§
                w.write("#=")
                w.write(((Class) x).getName())
            )
            else if (x instanceof BigDecimal && readably)
            (§
                w.write(x.toString())
                w.write(\M)
            )
            else if (x instanceof BigInt && readably)
            (§
                w.write(x.toString())
                w.write(\N)
            )
            else if (x instanceof BigInteger && readably)
            (§
                w.write(x.toString())
                w.write("BIGINT")
            )
            else if (x instanceof Var)
            (§
                Var v = (Var) x
                w.write("#=(var " + v.ns.name + "/" + v.sym + ")")
            )
            else if (x instanceof Pattern)
            (§
                Pattern p = (Pattern) x
                w.write("#\"" + p.pattern() + "\"")
            )
            else
            (§
                w.write(x.toString())
            )
        )
    )

    private static void printInnerSeq(ISeq x, Writer w) throws IOException
    (§
        for (ISeq s = x s != nil s = s.next())
        (§
            print(s.first(), w)
            if (s.next() != nil)
            (§
                w.write(\space)
            )
        )
    )

    static public void formatAesthetic(Writer w, Object obj) throws IOException
    (§
        if (obj == nil)
        (§
            w.write("nil")
        )
        else
        (§
            w.write(obj.toString())
        )
    )

    static public void formatStandard(Writer w, Object obj) throws IOException
    (§
        if (obj == nil)
        (§
            w.write("nil")
        )
        else if (obj instanceof String)
        (§
            w.write(\") ;; oops! "
            w.write((String) obj)
            w.write(\") ;; oops! "
        )
        else if (obj instanceof Character)
        (§
            w.write(\\)
            char c = ((Character) obj).charValue()
            switch (c)
            (§
                (§ case \newline)
                    w.write("newline")
                    break
                (§ case \tab)
                    w.write("tab")
                    break
                (§ case \space)
                    w.write("space")
                    break
                (§ case \backspace)
                    w.write("backspace")
                    break
                (§ case \formfeed)
                    w.write("formfeed")
                    break
                (§ default)
                    w.write(c)
                    break
            )
        )
        else
        (§
            w.write(obj.toString())
        )
    )

    static public Object format(Object o, String s, Object... args) throws IOException
    (§
        Writer w
        if (o == nil)
        (§
            w = new StringWriter()
        )
        else if (Util.equals(o, T))
        (§
            w = (Writer) OUT.deref()
        )
        else
        (§
            w = (Writer) o
        )
        doFormat(w, s, ArraySeq.create(args))
        if (o == nil)
        (§
            (§ return (§ expr w.toString()))
        )
        (§ return (§ expr nil))
    )

    static public ISeq doFormat(Writer w, String s, ISeq args) throws IOException
    (§
        for (int i = 0 i < s.length() )
        (§
            char c = s.charAt(i++)
            switch (Character.toLowerCase(c))
            (§
                (§ case \~)
                    char d = s.charAt(i++)
                    switch (Character.toLowerCase(d))
                    (§
                        (§ case \%)
                            w.write(\newline)
                            break
                        (§ case \t)
                            w.write(\tab)
                            break
                        (§ case \a)
                            if (args == nil)
                            (§
                                throw new IllegalArgumentException("Missing argument")
                            )
                            RT.formatAesthetic(w, RT.first(args))
                            args = RT.next(args)
                            break
                        (§ case \s)
                            if (args == nil)
                            (§
                                throw new IllegalArgumentException("Missing argument")
                            )
                            RT.formatStandard(w, RT.first(args))
                            args = RT.next(args)
                            break
                        (§ case \{)
                            int j = s.indexOf("~}", i) ;; note - does not nest
                            if (j == -1)
                            (§
                                throw new IllegalArgumentException("Missing ~}")
                            )
                            String subs = s.substring(i, j)
                            for (ISeq sargs = RT.seq(RT.first(args)) sargs != nil )
                            (§
                                sargs = doFormat(w, subs, sargs)
                            )
                            args = RT.next(args)
                            i = j + 2 ;; skip "~}"
                            break
                        (§ case \^)
                            if (args == nil)
                            (§
                                (§ return (§ expr nil))
                            )
                            break
                        (§ case \~)
                            w.write(\~)
                            break
                        (§ default)
                            throw new IllegalArgumentException("Unsupported ~ directive: " + d)
                    )
                    break
                (§ default)
                    w.write(c)
                    break
            )
        )
        (§ return (§ expr args))
    )

    static public Object[] setValues(Object... vals)
    (§
        if (vals.length > 0)
        (§
            (§ return (§ expr vals))
        )
        (§ return (§ expr nil))
    )

    static public ClassLoader makeClassLoader()
    (§
        (§ return (§ expr (ClassLoader) AccessController.doPrivileged(new PrivilegedAction()
        (§
            public Object run()
            (§
                try
                (§
                    Var.pushThreadBindings(RT.map(USE_CONTEXT_CLASSLOADER, RT.T))
                    (§ return (§ expr new DynamicClassLoader(baseLoader())))
                )
                finally
                (§
                    Var.popThreadBindings()
                )
            )
        ))))
    )

    static public ClassLoader baseLoader()
    (§
        if (Compiler.LOADER.isBound())
        (§
            (§ return (§ expr (ClassLoader) Compiler.LOADER.deref()))
        )
        else if (booleanCast(USE_CONTEXT_CLASSLOADER.deref()))
        (§
            (§ return (§ expr Thread.currentThread().getContextClassLoader()))
        )
        (§ return (§ expr Compiler.class.getClassLoader()))
    )

    static public InputStream resourceAsStream(ClassLoader loader, String name)
    (§
        if (loader == nil)
        (§
            (§ return (§ expr ClassLoader.getSystemResourceAsStream(name)))
        )
        else
        (§
            (§ return (§ expr loader.getResourceAsStream(name)))
        )
    )

    static public URL getResource(ClassLoader loader, String name)
    (§
        if (loader == nil)
        (§
            (§ return (§ expr ClassLoader.getSystemResource(name)))
        )
        else
        (§
            (§ return (§ expr loader.getResource(name)))
        )
    )

    static public Class classForName(String name, boolean load, ClassLoader loader)
    (§
        try
        (§
            Class c = nil
            if (!(loader instanceof DynamicClassLoader))
            (§
                c = DynamicClassLoader.findInMemoryClass(name)
            )
            if (c != nil)
            (§
                (§ return (§ expr c))
            )
            (§ return (§ expr Class.forName(name, load, loader)))
        )
        catch (ClassNotFoundException e)
        (§
            throw Util.sneakyThrow(e)
        )
    )

    static public Class classForName(String name)
    (§
        (§ return (§ expr classForName(name, true, baseLoader())))
    )

    static public Class classForNameNonLoading(String name)
    (§
        (§ return (§ expr classForName(name, false, baseLoader())))
    )

    static public Class loadClassForName(String name)
    (§
        try
        (§
            classForNameNonLoading(name)
        )
        catch (Exception e)
        (§
            if (e instanceof ClassNotFoundException)
            (§
                (§ return (§ expr nil))
            )
            else
            (§
                throw Util.sneakyThrow(e)
            )
        )
        (§ return (§ expr classForName(name)))
    )

    static public float aget(float[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public float aset(float[] xs, int i, float v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(float[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public float[] aclone(float[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )

    static public double aget(double[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public double aset(double[] xs, int i, double v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(double[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public double[] aclone(double[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )

    static public int aget(int[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public int aset(int[] xs, int i, int v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(int[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public int[] aclone(int[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )

    static public long aget(long[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public long aset(long[] xs, int i, long v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(long[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public long[] aclone(long[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )

    static public char aget(char[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public char aset(char[] xs, int i, char v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(char[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public char[] aclone(char[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )

    static public byte aget(byte[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public byte aset(byte[] xs, int i, byte v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(byte[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public byte[] aclone(byte[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )

    static public short aget(short[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public short aset(short[] xs, int i, short v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(short[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public short[] aclone(short[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )

    static public boolean aget(boolean[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public boolean aset(boolean[] xs, int i, boolean v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(boolean[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public boolean[] aclone(boolean[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )

    static public Object aget(Object[] xs, int i)
    (§
        (§ return (§ expr xs[i]))
    )

    static public Object aset(Object[] xs, int i, Object v)
    (§
        xs[i] = v
        (§ return (§ expr v))
    )

    static public int alength(Object[] xs)
    (§
        (§ return (§ expr xs.length))
    )

    static public Object[] aclone(Object[] xs)
    (§
        (§ return (§ expr xs.clone()))
    )
)
)

(java-ns cloiure.lang.Seqable

(§ interface public interface Seqable)
(§
    ISeq seq()
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(§ class public class SeqEnumeration implements Enumeration)
(§
    ISeq seq

    public SeqEnumeration(ISeq seq)
    (§
        this.seq = seq
    )

    public boolean hasMoreElements()
    (§
        (§ return (§ expr (seq != nil)))
    )

    public Object nextElement()
    (§
        Object ret = RT.first(seq)
        seq = RT.next(seq)
        (§ return (§ expr ret))
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(§ class public class SeqIterator implements Iterator)
(§
    static final Object START = new Object()

    Object seq
    Object next

    public SeqIterator(Object o)
    (§
        seq = START
        next = o
    )

    ;; preserved for binary compatibility
    public SeqIterator(ISeq o)
    (§
        seq = START
        next = o
    )

    public boolean hasNext()
    (§
        if (seq == START)
        (§
            seq = nil
            next = RT.seq(next)
        )
        else if (seq == next)
        (§
            next = RT.next(seq)
        )
        (§ return (§ expr (next != nil)))
    )

    public Object next() throws NoSuchElementException
    (§
        if (!hasNext())
        (§
            throw new NoSuchElementException()
        )
        seq = next
        (§ return (§ expr RT.first(next)))
    )

    public void remove()
    (§
        throw new UnsupportedOperationException()
    )
)
)

(java-ns cloiure.lang.Sequential

(§ interface public interface Sequential)
(§
)
)

(java-ns cloiure.lang.Settable

(§ interface public interface Settable)
(§
    Object doSet(Object val)
    Object doReset(Object val)
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(§ interface public interface Sorted)
(§
    Comparator comparator()

    Object entryKey(Object entry)

    ISeq seq(boolean ascending)

    ISeq seqFrom(Object key, boolean ascending)
)
)

(java-ns cloiure.lang.StringSeq

(§ class public class StringSeq extends ASeq implements IndexedSeq)
(§
    public final CharSequence s
    public final int i

    static public StringSeq create(CharSequence s)
    (§
        if (s.length() == 0)
        (§
            (§ return (§ expr nil))
        )
        (§ return (§ expr new StringSeq(nil, s, 0)))
    )

    StringSeq(IPersistentMap meta, CharSequence s, int i)
    (§
        super(meta)
        this.s = s
        this.i = i
    )

    public Obj withMeta(IPersistentMap meta)
    (§
        if (meta == meta())
        (§
            (§ return (§ expr this))
        )
        (§ return (§ expr new StringSeq(meta, s, i)))
    )

    public Object first()
    (§
        (§ return (§ expr Character.valueOf(s.charAt(i))))
    )

    public ISeq next()
    (§
        if (i + 1 < s.length())
        (§
            (§ return (§ expr new StringSeq(_meta, s, i + 1)))
        )
        (§ return (§ expr nil))
    )

    public int index()
    (§
        (§ return (§ expr i))
    )

    public int count()
    (§
        (§ return (§ expr s.length() - i))
    )
)
)

(java-ns cloiure.lang.Symbol

(§ import java.io.Serializable)
(§ import java.io.ObjectStreamException)

(§ class public class Symbol extends AFn implements IObj, Comparable, Named, Serializable, IHashEq)
(§
    final String ns
    final String name
    private int _hasheq
    final IPersistentMap _meta
    transient String _str

    public String toString()
    (§
        if (_str == nil)
        (§
            if (ns != nil)
            (§
                _str = (ns + "/" + name)
            )
            else
            (§
                _str = name
            )
        )
        (§ return (§ expr _str))
    )

    public String getNamespace()
    (§
        (§ return (§ expr ns))
    )

    public String getName()
    (§
        (§ return (§ expr name))
    )

    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    static public Symbol create(String ns, String name)
    (§
        (§ return (§ expr Symbol.intern(ns, name)))
    )

    static public Symbol create(String nsname)
    (§
        (§ return (§ expr Symbol.intern(nsname)))
    )

    static public Symbol intern(String ns, String name)
    (§
        (§ return (§ expr new Symbol(ns, name)))
    )

    static public Symbol intern(String nsname)
    (§
        int i = nsname.indexOf(\/)
        if (i == -1 || nsname.equals("/"))
        (§
            (§ return (§ expr new Symbol(nil, nsname)))
        )
        else
        (§
            (§ return (§ expr new Symbol(nsname.substring(0, i), nsname.substring(i + 1))))
        )
    )

    private Symbol(String ns_interned, String name_interned)
    (§
        this.name = name_interned
        this.ns = ns_interned
        this._meta = nil
    )

    public boolean equals(Object o)
    (§
        if (this == o)
        (§
            (§ return (§ expr true))
        )
        if (!(o instanceof Symbol))
        (§
            (§ return (§ expr false))
        )

        Symbol symbol = (Symbol) o

        (§ return (§ expr Util.equals(ns, symbol.ns) && name.equals(symbol.name)))
    )

    public int hashCode()
    (§
        (§ return (§ expr Util.hashCombine(name.hashCode(), Util.hash(ns))))
    )

    public int hasheq()
    (§
        if (_hasheq == 0)
        (§
            _hasheq = Util.hashCombine(Murmur3.hashUnencodedChars(name), Util.hash(ns))
        )
        (§ return (§ expr _hasheq))
    )

    public IObj withMeta(IPersistentMap meta)
    (§
        (§ return (§ expr new Symbol(meta, ns, name)))
    )

    private Symbol(IPersistentMap meta, String ns, String name)
    (§
        this.name = name
        this.ns = ns
        this._meta = meta
    )

    public int compareTo(Object o)
    (§
        Symbol s = (Symbol) o
        if (this.equals(o))
        (§
            (§ return (§ expr 0))
        )
        if (this.ns == nil && s.ns != nil)
        (§
            (§ return (§ expr -1))
        )
        if (this.ns != nil)
        (§
            if (s.ns == nil)
            (§
                (§ return (§ expr 1))
            )
            int nsc = this.ns.compareTo(s.ns)
            if (nsc != 0)
            (§
                (§ return (§ expr nsc))
            )
        )
        (§ return (§ expr this.name.compareTo(s.name)))
    )

    private Object readResolve() throws ObjectStreamException
    (§
        (§ return (§ expr intern(ns, name)))
    )

    public Object invoke(Object obj)
    (§
        (§ return (§ expr RT.get(obj, this)))
    )

    public Object invoke(Object obj, Object notFound)
    (§
        (§ return (§ expr RT.get(obj, this, notFound)))
    )

    public IPersistentMap meta()
    (§
        (§ return (§ expr _meta))
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(§ class public class TaggedLiteral implements ILookup)
(§
    public static final Keyword TAG_KW = Keyword.intern("tag")
    public static final Keyword FORM_KW = Keyword.intern("form")

    public final Symbol tag
    public final Object form

    public static TaggedLiteral create(Symbol tag, Object form)
    (§
        (§ return (§ expr new TaggedLiteral(tag, form)))
    )

    private TaggedLiteral(Symbol tag, Object form)
    (§
        this.tag = tag
        this.form = form
    )

    public Object valAt(Object key)
    (§
        (§ return (§ expr valAt(key, nil)))
    )

    public Object valAt(Object key, Object notFound)
    (§
        if (FORM_KW.equals(key))
        (§
            (§ return (§ expr this.form))
        )
        else if (TAG_KW.equals(key))
        (§
            (§ return (§ expr this.tag))
        )
        else
        (§
            (§ return (§ expr notFound))
        )
    )

    (§ anno @Override)
    public boolean equals(Object o)
    (§
        if (this == o)
        (§
            (§ return (§ expr true))
        )
        if (o == nil || getClass() != o.getClass())
        (§
            (§ return (§ expr false))
        )

        TaggedLiteral that = (TaggedLiteral) o

        if ((form != nil) ? !form.equals(that.form) :or that.form != nil)
        (§
            (§ return (§ expr false))
        )
        if ((tag != nil) ? !tag.equals(that.tag) :or that.tag != nil)
        (§
            (§ return (§ expr false))
        )

        (§ return (§ expr true))
    )

    (§ anno @Override)
    public int hashCode()
    (§
        int result = Util.hash(tag)
        result = 31 * result + Util.hash(form)
        (§ return (§ expr result))
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(§ class public class TransactionalHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>)
(§
    final Ref[] bins

    IPersistentMap mapAt(int bin)
    (§
        (§ return (§ expr (IPersistentMap) bins[bin].deref()))
    )

    final int binFor(Object k)
    (§
        ;; spread hashes, a la Cliff Click
        int h = k.hashCode()
        h ^= (h >>> 20) :xor (h >>> 12)
        h ^= (h >>> 7) :xor (h >>> 4)
        (§ return (§ expr h % bins.length))
    )

    Entry entryAt(Object k)
    (§
        (§ return (§ expr mapAt(binFor(k)).entryAt(k)))
    )

    public TransactionalHashMap()
    (§
        this(421)
    )

    public TransactionalHashMap(int nBins)
    (§
        bins = new Ref[nBins]
        for (int i = 0 i < nBins i++)
        (§
            bins[i] = new Ref(PersistentHashMap.EMPTY)
        )
    )

    public TransactionalHashMap(Map<? extends K, ? extends V> m)
    (§
        this(m.size())
        putAll(m)
    )

    public int size()
    (§
        int n = 0
        for (int i = 0 i < bins.length i++)
        (§
            n += mapAt(i).count()
        )
        (§ return (§ expr n))
    )

    public boolean isEmpty()
    (§
        (§ return (§ expr (size() == 0)))
    )

    public boolean containsKey(Object k)
    (§
        (§ return (§ expr (entryAt(k) != nil)))
    )

    public V get(Object k)
    (§
        Entry e = entryAt(k)
        if (e != nil)
        (§
            (§ return (§ expr (V) e.getValue()))
        )
        (§ return (§ expr nil))
    )

    public V put(K k, V v)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Object ret = map.valAt(k)
        r.set(map.assoc(k, v))
        (§ return (§ expr (V) ret))
    )

    public V remove(Object k)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Object ret = map.valAt(k)
        r.set(map.without(k))
        (§ return (§ expr (V) ret))
    )

    public void putAll(Map<? extends K, ? extends V> map)
    (§
        for (Iterator i = map.entrySet().iterator() i.hasNext() )
        (§
            Entry<K, V> e = (Entry) i.next()
            put(e.getKey(), e.getValue())
        )
    )

    public void clear()
    (§
        for (int i = 0 i < bins.length i++)
        (§
            Ref r = bins[i]
            IPersistentMap map = (IPersistentMap) r.deref()
            if (map.count() > 0)
            (§
                r.set(PersistentHashMap.EMPTY)
            )
        )
    )

    public Set<Entry<K, V>> entrySet()
    (§
        final ArrayList<Map.Entry<K, V>> entries = new ArrayList(bins.length)
        for (int i = 0 i < bins.length i++)
        (§
            IPersistentMap map = mapAt(i)
            if (map.count() > 0)
            (§
                entries.addAll((Collection) RT.seq(map))
            )
        )
        (§ return (§ expr new AbstractSet<Entry<K, V>>()
        (§
            public Iterator iterator()
            (§
                (§ return (§ expr Collections.unmodifiableList(entries).iterator()))
            )

            public int size()
            (§
                (§ return (§ expr entries.size()))
            )
        )))
    )

    public V putIfAbsent(K k, V v)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Entry e = map.entryAt(k)
        if (e == nil)
        (§
            r.set(map.assoc(k, v))
            (§ return (§ expr nil))
        )
        else
        (§
            (§ return (§ expr (V) e.getValue()))
        )
    )

    public boolean remove(Object k, Object v)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Entry e = map.entryAt(k)
        if (e != nil && e.getValue().equals(v))
        (§
            r.set(map.without(k))
            (§ return (§ expr true))
        )
        (§ return (§ expr false))
    )

    public boolean replace(K k, V oldv, V newv)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Entry e = map.entryAt(k)
        if (e != nil && e.getValue().equals(oldv))
        (§
            r.set(map.assoc(k, newv))
            (§ return (§ expr true))
        )
        (§ return (§ expr false))
    )

    public V replace(K k, V v)
    (§
        Ref r = bins[binFor(k)]
        IPersistentMap map = (IPersistentMap) r.deref()
        Entry e = map.entryAt(k)
        if (e != nil)
        (§
            r.set(map.assoc(k, v))
            (§ return (§ expr (V) e.getValue()))
        )
        (§ return (§ expr nil))
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

(§ class public class TransformerIterator implements Iterator)
(§
    private static final Buffer EMPTY = new Empty()
    private static final Object NONE = new Object()

    ;; Source
    private final Iterator sourceIter
    private final IFn xf
    private final boolean multi

    ;; Iteration state
    private volatile Buffer buffer = EMPTY
    private volatile Object next = NONE
    private volatile boolean completed = false

    private TransformerIterator(IFn xform, Iterator sourceIter, boolean multi)
    (§
        this.sourceIter = sourceIter
        this.xf = (IFn) xform.invoke(new AFn()
        (§
            public Object invoke()
            (§
                (§ return (§ expr nil))
            )

            public Object invoke(Object acc)
            (§
                (§ return (§ expr acc))
            )

            public Object invoke(Object acc, Object o)
            (§
                buffer = buffer.add(o)
                (§ return (§ expr acc))
            )
        ))
        this.multi = multi
    )

    public static Iterator create(IFn xform, Iterator source)
    (§
        (§ return (§ expr new TransformerIterator(xform, source, false)))
    )

    public static Iterator createMulti(IFn xform, List sources)
    (§
        Iterator[] iters = new Iterator[sources.size()]
        for (int i = 0 i < sources.size() i++)
        (§
            iters[i] = (Iterator)sources.get(i)
        )
        (§ return (§ expr new TransformerIterator(xform, new MultiIterator(iters), true)))
    )

    private boolean step()
    (§
        if (next != NONE)
        (§
            (§ return (§ expr true))
        )

        while (next == NONE)
        (§
            if (buffer.isEmpty())
            (§
                if (completed)
                (§
                    (§ return (§ expr false))
                )
                else if (sourceIter.hasNext())
                (§
                    Object iter = nil
                    if (multi)
                    (§
                        iter = xf.applyTo(RT.cons(nil, sourceIter.next()))
                    )
                    else
                    (§
                        iter = xf.invoke(nil, sourceIter.next())
                    )

                    if (RT.isReduced(iter))
                    (§
                        xf.invoke(nil)
                        completed = true
                    )
                )
                else
                (§
                    xf.invoke(nil)
                    completed = true
                )
            )
            else
            (§
                next = buffer.remove()
            )
        )
        (§ return (§ expr true))
    )

    public boolean hasNext()
    (§
        (§ return (§ expr step()))
    )

    public Object next()
    (§
        if (hasNext())
        (§
            Object ret = next
            next = NONE
            (§ return (§ expr ret))
        )
        throw new NoSuchElementException()
    )

    public void remove()
    (§
        throw new UnsupportedOperationException()
    )

    private static interface Buffer
    (§
        Buffer add(Object o)
        Object remove()
        boolean isEmpty()
    )

    private static class Empty implements Buffer
    (§
        public Buffer add(Object o)
        (§
            (§ return (§ expr new Single(o)))
        )

        public Object remove()
        (§
            throw new IllegalStateException("Removing object from empty buffer")
        )

        public boolean isEmpty()
        (§
            (§ return (§ expr true))
        )

        public String toString()
        (§
            (§ return (§ expr "Empty"))
        )
    )

    private static class Single implements Buffer
    (§
        private volatile Object val

        public Single(Object o)
        (§
            this.val = o
        )

        public Buffer add(Object o)
        (§
            if (val == NONE)
            (§
                val = o
                (§ return (§ expr this))
            )
            else
            (§
                (§ return (§ expr new Many(val, o)))
            )
        )

        public Object remove()
        (§
            if (val == NONE)
            (§
                throw new IllegalStateException("Removing object from empty buffer")
            )
            Object ret = val
            val = NONE
            (§ return (§ expr ret))
        )

        public boolean isEmpty()
        (§
            (§ return (§ expr (val == NONE)))
        )

        public String toString()
        (§
            (§ return (§ expr "Single: " + val))
        )
    )

    private static class Many implements Buffer
    (§
        private final Queue vals = new LinkedList()

        public Many(Object o1, Object o2)
        (§
            vals.add(o1)
            vals.add(o2)
        )

        public Buffer add(Object o)
        (§
            vals.add(o)
            (§ return (§ expr this))
        )

        public Object remove()
        (§
            (§ return (§ expr vals.remove()))
        )

        public boolean isEmpty()
        (§
            (§ return (§ expr vals.isEmpty()))
        )

        public String toString()
        (§
            (§ return (§ expr "Many: " + vals.toString()))
        )
    )

    private static class MultiIterator implements Iterator
    (§
        private final Iterator[] iters

        public MultiIterator(Iterator[] iters)
        (§
            this.iters = iters
        )

        public boolean hasNext()
        (§
            for (Iterator iter :in iters)
            (§
                if (!iter.hasNext())
                (§
                    (§ return (§ expr false))
                )
            )
            (§ return (§ expr true))
        )

        public Object next()
        (§
            Object[] nexts = new Object[iters.length]
            for (int i = 0 i < iters.length i++)
            (§
                nexts[i] = iters[i].next()
            )
            (§ return (§ expr new ArraySeq(nexts, 0)))
        )

        public void remove()
        (§
            throw new UnsupportedOperationException()
        )
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

(§ class public class Tuple)
(§
    static final int MAX_SIZE = 6

    public static IPersistentVector create()
    (§
        (§ return (§ expr PersistentVector.EMPTY))
    )

    public static IPersistentVector create(Object v0)
    (§
        (§ return (§ expr RT.vector(v0)))
    )

    public static IPersistentVector create(Object v0, Object v1)
    (§
        (§ return (§ expr RT.vector(v0, v1)))
    )

    public static IPersistentVector create(Object v0, Object v1, Object v2)
    (§
        (§ return (§ expr RT.vector(v0, v1, v2)))
    )

    public static IPersistentVector create(Object v0, Object v1, Object v2, Object v3)
    (§
        (§ return (§ expr RT.vector(v0, v1, v2, v3)))
    )

    public static IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4)
    (§
        (§ return (§ expr RT.vector(v0, v1, v2, v3, v4)))
    )

    public static IPersistentVector create(Object v0, Object v1, Object v2, Object v3, Object v4, Object v5)
    (§
        (§ return (§ expr RT.vector(v0, v1, v2, v3, v4, v5)))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(§ class public class Util)
(§
    static public boolean equiv(Object k1, Object k2)
    (§
        if (k1 == k2)
        (§
            (§ return (§ expr true))
        )
        if (k1 != nil)
        (§
            if (k1 instanceof Number && k2 instanceof Number)
            (§
                (§ return (§ expr Numbers.equal((Number)k1, (Number)k2)))
            )
            else if (k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
            (§
                (§ return (§ expr pcequiv(k1, k2)))
            )
            (§ return (§ expr k1.equals(k2)))
        )
        (§ return (§ expr false))
    )

    public interface EquivPred
    (§
        boolean equiv(Object k1, Object k2)
    )

    static EquivPred equivNull = new EquivPred()
    (§
        public boolean equiv(Object k1, Object k2)
        (§
            (§ return (§ expr (k2 == nil)))
        )
    )

    static EquivPred equivEquals = new EquivPred()
    (§
        public boolean equiv(Object k1, Object k2)
        (§
            (§ return (§ expr k1.equals(k2)))
        )
    )

    static EquivPred equivNumber = new EquivPred()
    (§
        public boolean equiv(Object k1, Object k2)
        (§
            if (k2 instanceof Number)
            (§
                (§ return (§ expr Numbers.equal((Number) k1, (Number) k2)))
            )
            (§ return (§ expr false))
        )
    )

    static EquivPred equivColl = new EquivPred()
    (§
        public boolean equiv(Object k1, Object k2)
        (§
            if (k1 instanceof IPersistentCollection || k2 instanceof IPersistentCollection)
            (§
                (§ return (§ expr pcequiv(k1, k2)))
            )
            (§ return (§ expr k1.equals(k2)))
        )
    )

    static public EquivPred equivPred(Object k1)
    (§
        if (k1 == nil)
        (§
            (§ return (§ expr equivNull))
        )
        else if (k1 instanceof Number)
        (§
            (§ return (§ expr equivNumber))
        )
        else if (k1 instanceof String || k1 instanceof Symbol)
        (§
            (§ return (§ expr equivEquals))
        )
        else if (k1 instanceof Collection || k1 instanceof Map)
        (§
            (§ return (§ expr equivColl))
        )
        (§ return (§ expr equivEquals))
    )

    static public boolean equiv(long k1, long k2)
    (§
        (§ return (§ expr (k1 == k2)))
    )

    static public boolean equiv(Object k1, long k2)
    (§
        (§ return (§ expr equiv(k1, (Object)k2)))
    )

    static public boolean equiv(long k1, Object k2)
    (§
        (§ return (§ expr equiv((Object)k1, k2)))
    )

    static public boolean equiv(double k1, double k2)
    (§
        (§ return (§ expr (k1 == k2)))
    )

    static public boolean equiv(Object k1, double k2)
    (§
        (§ return (§ expr equiv(k1, (Object)k2)))
    )

    static public boolean equiv(double k1, Object k2)
    (§
        (§ return (§ expr equiv((Object)k1, k2)))
    )

    static public boolean equiv(boolean k1, boolean k2)
    (§
        (§ return (§ expr (k1 == k2)))
    )

    static public boolean equiv(Object k1, boolean k2)
    (§
        (§ return (§ expr equiv(k1, (Object)k2)))
    )

    static public boolean equiv(boolean k1, Object k2)
    (§
        (§ return (§ expr equiv((Object)k1, k2)))
    )

    static public boolean equiv(char c1, char c2)
    (§
        (§ return (§ expr (c1 == c2)))
    )

    static public boolean pcequiv(Object k1, Object k2)
    (§
        if (k1 instanceof IPersistentCollection)
        (§
            (§ return (§ expr ((IPersistentCollection)k1).equiv(k2)))
        )
        (§ return (§ expr ((IPersistentCollection)k2).equiv(k1)))
    )

    static public boolean equals(Object k1, Object k2)
    (§
        if (k1 == k2)
        (§
            (§ return (§ expr true))
        )
        (§ return (§ expr (k1 != nil && k1.equals(k2))))
    )

    static public boolean identical(Object k1, Object k2)
    (§
        (§ return (§ expr (k1 == k2)))
    )

    static public Class classOf(Object x)
    (§
        if (x != nil)
        (§
            (§ return (§ expr x.getClass()))
        )
        (§ return (§ expr nil))
    )

    static public int compare(Object k1, Object k2)
    (§
        if (k1 == k2)
        (§
            (§ return (§ expr 0))
        )
        if (k1 != nil)
        (§
            if (k2 == nil)
            (§
                (§ return (§ expr 1))
            )
            if (k1 instanceof Number)
            (§
                (§ return (§ expr Numbers.compare((Number) k1, (Number) k2)))
            )
            (§ return (§ expr ((Comparable) k1).compareTo(k2)))
        )
        (§ return (§ expr -1))
    )

    static public int hash(Object o)
    (§
        if (o == nil)
        (§
            (§ return (§ expr 0))
        )
        (§ return (§ expr o.hashCode()))
    )

    public static int hasheq(Object o)
    (§
        if (o == nil)
        (§
            (§ return (§ expr 0))
        )
        if (o instanceof IHashEq)
        (§
            (§ return (§ expr dohasheq((IHashEq) o)))
        )
        if (o instanceof Number)
        (§
            (§ return (§ expr Numbers.hasheq((Number)o)))
        )
        if (o instanceof String)
        (§
            (§ return (§ expr Murmur3.hashInt(o.hashCode())))
        )
        (§ return (§ expr o.hashCode()))
    )

    private static int dohasheq(IHashEq o)
    (§
        (§ return (§ expr o.hasheq()))
    )

    static public int hashCombine(int seed, int hash)
    (§
        ;; a la boost
        seed ^= hash + 0x9e3779b9 + (seed << 6) + (seed >> 2)
        (§ return (§ expr seed))
    )

    static public boolean isPrimitive(Class c)
    (§
        (§ return (§ expr (c != nil && c.isPrimitive() && !(c == Void.TYPE))))
    )

    static public boolean isInteger(Object x)
    (§
        (§ return (§ expr (x instanceof Integer || x instanceof Long || x instanceof BigInt || x instanceof BigInteger)))
    )

    static public Object ret1(Object ret, Object nil)
    (§
        (§ return (§ expr ret))
    )

    static public ISeq ret1(ISeq ret, Object nil)
    (§
        (§ return (§ expr ret))
    )

    static public <K, V> void clearCache(ReferenceQueue rq, ConcurrentHashMap<K, Reference<V>> cache)
    (§
        ;; cleanup any dead entries
        if (rq.poll() != nil)
        (§
            while (rq.poll() != nil)
            (§
            )
            for (Map.Entry<K, Reference<V>> e :in cache.entrySet())
            (§
                Reference<V> val = e.getValue()
                if (val != nil && val.get() == nil)
                (§
                    cache.remove(e.getKey(), val)
                )
            )
        )
    )

    static public RuntimeException runtimeException(String s)
    (§
        (§ return (§ expr new RuntimeException(s)))
    )

    static public RuntimeException runtimeException(String s, Throwable e)
    (§
        (§ return (§ expr new RuntimeException(s, e)))
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    static public RuntimeException sneakyThrow(Throwable t)
    (§
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        if (t == nil)
        (§
            throw new NullPointerException()
        )
        Util.<RuntimeException>sneakyThrow0(t)
        (§ return (§ expr nil))
    )

    (§ anno @SuppressWarnings("unchecked"))
    static private <T extends Throwable> void sneakyThrow0(Throwable t) throws T
    (§
        throw (T) t
    )

    static public Object loadWithClass(String scriptbase, Class<?> loadFrom) throws IOException, ClassNotFoundException
    (§
        Var.pushThreadBindings(RT.map(new Object[] (§ Compiler.LOADER, loadFrom.getClassLoader() )))
        try
        (§
            (§ return (§ expr RT.var("cloiure.core", "load").invoke(scriptbase)))
        )
        finally
        (§
            Var.popThreadBindings()
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.io.ObjectStreamException)
(§ import java.io.Serializable)
(§ import java.util.concurrent.atomic.AtomicBoolean)

(§ class public final class Var extends ARef implements IFn, IRef, Settable, Serializable)
(§
    static class TBox
    (§
        volatile Object val
        final Thread thread

        public TBox(Thread t, Object val)
        (§
            this.thread = t
            this.val = val
        )
    )

    static public class Unbound extends AFn
    (§
        final public Var v

        public Unbound(Var v)
        (§
            this.v = v
        )

        public String toString()
        (§
            (§ return (§ expr "Unbound: " + v))
        )

        public Object throwArity(int n)
        (§
            throw new IllegalStateException("Attempting to call unbound fn: " + v)
        )
    )

    static class Frame
    (§
        final static Frame TOP = new Frame(PersistentHashMap.EMPTY, nil)
        ;; Var->TBox
        Associative bindings
        ;; Var->val
        Frame prev

        public Frame(Associative bindings, Frame prev)
        (§
            this.bindings = bindings
            this.prev = prev
        )

        protected Object clone()
        (§
            (§ return (§ expr new Frame(this.bindings, nil)))
        )
    )

    static final ThreadLocal<Frame> dvals = new ThreadLocal<Frame>()
    (§
        protected Frame initialValue()
        (§
            (§ return (§ expr Frame.TOP))
        )
    )

    static public volatile int rev = 0

    static Keyword privateKey = Keyword.intern(nil, "private")
    static IPersistentMap privateMeta = new PersistentArrayMap(new Object[] (§ privateKey, Boolean.TRUE ))
    static Keyword macroKey = Keyword.intern(nil, "macro")
    static Keyword nameKey = Keyword.intern(nil, "name")
    static Keyword nsKey = Keyword.intern(nil, "ns")

    volatile Object root

    volatile boolean dynamic = false
    transient final AtomicBoolean threadBound
    public final Symbol sym
    public final Namespace ns

    public static Object getThreadBindingFrame()
    (§
        (§ return (§ expr dvals.get()))
    )

    public static Object cloneThreadBindingFrame()
    (§
        (§ return (§ expr dvals.get().clone()))
    )

    public static void resetThreadBindingFrame(Object frame)
    (§
        dvals.set((Frame) frame)
    )

    public Var setDynamic()
    (§
        this.dynamic = true
        (§ return (§ expr this))
    )

    public Var setDynamic(boolean b)
    (§
        this.dynamic = b
        (§ return (§ expr this))
    )

    public final boolean isDynamic()
    (§
        (§ return (§ expr dynamic))
    )

    public static Var intern(Namespace ns, Symbol sym, Object root)
    (§
        (§ return (§ expr intern(ns, sym, root, true)))
    )

    public static Var intern(Namespace ns, Symbol sym, Object root, boolean replaceRoot)
    (§
        Var dvout = ns.intern(sym)
        if (!dvout.hasRoot() || replaceRoot)
        (§
            dvout.bindRoot(root)
        )
        (§ return (§ expr dvout))
    )

    public String toString()
    (§
        if (ns != nil)
        (§
            (§ return (§ expr "#'" + ns.name + "/" + sym))
        )
        (§ return (§ expr "#<Var: " + ((sym != nil) ? sym.toString() :or "--unnamed--") + ">"))
    )

    public static Var find(Symbol nsQualifiedSym)
    (§
        if (nsQualifiedSym.ns == nil)
        (§
            throw new IllegalArgumentException("Symbol must be namespace-qualified")
        )
        Namespace ns = Namespace.find(Symbol.intern(nsQualifiedSym.ns))
        if (ns == nil)
        (§
            throw new IllegalArgumentException("No such namespace: " + nsQualifiedSym.ns)
        )
        (§ return (§ expr ns.findInternedVar(Symbol.intern(nsQualifiedSym.name))))
    )

    public static Var intern(Symbol nsName, Symbol sym)
    (§
        Namespace ns = Namespace.findOrCreate(nsName)
        (§ return (§ expr intern(ns, sym)))
    )

    public static Var internPrivate(String nsName, String sym)
    (§
        Namespace ns = Namespace.findOrCreate(Symbol.intern(nsName))
        Var ret = intern(ns, Symbol.intern(sym))
        ret.setMeta(privateMeta)
        (§ return (§ expr ret))
    )

    public static Var intern(Namespace ns, Symbol sym)
    (§
        (§ return (§ expr ns.intern(sym)))
    )

    public static Var create()
    (§
        (§ return (§ expr new Var(nil, nil)))
    )

    public static Var create(Object root)
    (§
        (§ return (§ expr new Var(nil, nil, root)))
    )

    Var(Namespace ns, Symbol sym)
    (§
        this.ns = ns
        this.sym = sym
        this.threadBound = new AtomicBoolean(false)
        this.root = new Unbound(this)
        setMeta(PersistentHashMap.EMPTY)
    )

    Var(Namespace ns, Symbol sym, Object root)
    (§
        this(ns, sym)
        this.root = root
        ++rev
    )

    public boolean isBound()
    (§
        (§ return (§ expr (hasRoot() || (threadBound.get() && dvals.get().bindings.containsKey(this)))))
    )

    final public Object get()
    (§
        if (!threadBound.get())
        (§
            (§ return (§ expr root))
        )
        (§ return (§ expr deref()))
    )

    final public Object deref()
    (§
        TBox b = getThreadBinding()
        if (b != nil)
        (§
            (§ return (§ expr b.val))
        )
        (§ return (§ expr root))
    )

    public void setValidator(IFn vf)
    (§
        if (hasRoot())
        (§
            validate(vf, root)
        )
        validator = vf
    )

    public Object alter(IFn fn, ISeq args)
    (§
        set(fn.applyTo(RT.cons(deref(), args)))
        (§ return (§ expr this))
    )

    public Object set(Object val)
    (§
        validate(getValidator(), val)
        TBox b = getThreadBinding()
        if (b != nil)
        (§
            if (Thread.currentThread() != b.thread)
            (§
                throw new IllegalStateException(String.format("Can't set!: %s from non-binding thread", sym))
            )
            (§ return (§ expr (b.val = val)))
        )
        throw new IllegalStateException(String.format("Can't change/establish root binding of: %s with set", sym))
    )

    public Object doSet(Object val)
    (§
        (§ return (§ expr set(val)))
    )

    public Object doReset(Object val)
    (§
        bindRoot(val)
        (§ return (§ expr val))
    )

    public void setMeta(IPersistentMap m)
    (§
        ;; ensure these basis keys
        resetMeta(m.assoc(nameKey, sym).assoc(nsKey, ns))
    )

    public void setMacro()
    (§
        alterMeta(assoc, RT.list(macroKey, RT.T))
    )

    public boolean isMacro()
    (§
        (§ return (§ expr RT.booleanCast(meta().valAt(macroKey))))
    )

    public boolean isPublic()
    (§
        (§ return (§ expr !RT.booleanCast(meta().valAt(privateKey))))
    )

    final public Object getRawRoot()
    (§
        (§ return (§ expr root))
    )

    public Object getTag()
    (§
        (§ return (§ expr meta().valAt(RT.TAG_KEY)))
    )

    public void setTag(Symbol tag)
    (§
        alterMeta(assoc, RT.list(RT.TAG_KEY, tag))
    )

    final public boolean hasRoot()
    (§
        (§ return (§ expr !(root instanceof Unbound)))
    )

    ;; binding root always clears macro flag
    synchronized public void bindRoot(Object root)
    (§
        validate(getValidator(), root)
        Object oldroot = this.root
        this.root = root
        ++rev
        alterMeta(dissoc, RT.list(macroKey))
        notifyWatches(oldroot, this.root)
    )

    synchronized void swapRoot(Object root)
    (§
        validate(getValidator(), root)
        Object oldroot = this.root
        this.root = root
        ++rev
        notifyWatches(oldroot, root)
    )

    synchronized public void unbindRoot()
    (§
        this.root = new Unbound(this)
        ++rev
    )

    synchronized public void commuteRoot(IFn fn)
    (§
        Object newRoot = fn.invoke(root)
        validate(getValidator(), newRoot)
        Object oldroot = root
        this.root = newRoot
        ++rev
        notifyWatches(oldroot, newRoot)
    )

    synchronized public Object alterRoot(IFn fn, ISeq args)
    (§
        Object newRoot = fn.applyTo(RT.cons(root, args))
        validate(getValidator(), newRoot)
        Object oldroot = root
        this.root = newRoot
        ++rev
        notifyWatches(oldroot, newRoot)
        (§ return (§ expr newRoot))
    )

    public static void pushThreadBindings(Associative bindings)
    (§
        Frame f = dvals.get()
        Associative bmap = f.bindings
        for (ISeq bs = bindings.seq() bs != nil bs = bs.next())
        (§
            IMapEntry e = (IMapEntry) bs.first()
            Var v = (Var) e.key()
            if (!v.dynamic)
            (§
                throw new IllegalStateException(String.format("Can't dynamically bind non-dynamic var: %s/%s", v.ns, v.sym))
            )
            v.validate(v.getValidator(), e.val())
            v.threadBound.set(true)
            bmap = bmap.assoc(v, new TBox(Thread.currentThread(), e.val()))
        )
        dvals.set(new Frame(bmap, f))
    )

    public static void popThreadBindings()
    (§
        Frame f = dvals.get().prev
        if (f == nil)
        (§
            throw new IllegalStateException("Pop without matching push")
        )
        else if (f == Frame.TOP)
        (§
            dvals.remove()
        )
        else
        (§
            dvals.set(f)
        )
    )

    public static Associative getThreadBindings()
    (§
        Frame f = dvals.get()
        IPersistentMap ret = PersistentHashMap.EMPTY
        for (ISeq bs = f.bindings.seq() bs != nil bs = bs.next())
        (§
            IMapEntry e = (IMapEntry) bs.first()
            Var v = (Var) e.key()
            TBox b = (TBox) e.val()
            ret = ret.assoc(v, b.val)
        )
        (§ return (§ expr ret))
    )

    public final TBox getThreadBinding()
    (§
        if (threadBound.get())
        (§
            IMapEntry e = dvals.get().bindings.entryAt(this)
            if (e != nil)
            (§
                (§ return (§ expr (TBox) e.val()))
            )
        )
        (§ return (§ expr nil))
    )

    final public IFn fn()
    (§
        (§ return (§ expr (IFn) deref()))
    )

    public Object call()
    (§
        (§ return (§ expr invoke()))
    )

    public void run()
    (§
        invoke()
    )

    public Object invoke()
    (§
        (§ return (§ expr fn().invoke()))
    )

    public Object invoke(Object arg1)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil))))
    )

    public Object invoke(Object arg1, Object arg2)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil),
                Util.ret1(arg20, arg20 = nil))))
    )

    public Object invoke(Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7,
            Object arg8, Object arg9, Object arg10, Object arg11, Object arg12, Object arg13, Object arg14,
            Object arg15, Object arg16, Object arg17, Object arg18, Object arg19, Object arg20,
            Object... args)
    (§
        (§ return (§ expr fn().invoke(Util.ret1(arg1, arg1 = nil),
                Util.ret1(arg2, arg2 = nil),
                Util.ret1(arg3, arg3 = nil),
                Util.ret1(arg4, arg4 = nil),
                Util.ret1(arg5, arg5 = nil),
                Util.ret1(arg6, arg6 = nil),
                Util.ret1(arg7, arg7 = nil),
                Util.ret1(arg8, arg8 = nil),
                Util.ret1(arg9, arg9 = nil),
                Util.ret1(arg10, arg10 = nil),
                Util.ret1(arg11, arg11 = nil),
                Util.ret1(arg12, arg12 = nil),
                Util.ret1(arg13, arg13 = nil),
                Util.ret1(arg14, arg14 = nil),
                Util.ret1(arg15, arg15 = nil),
                Util.ret1(arg16, arg16 = nil),
                Util.ret1(arg17, arg17 = nil),
                Util.ret1(arg18, arg18 = nil),
                Util.ret1(arg19, arg19 = nil),
                Util.ret1(arg20, arg20 = nil),
                (Object[])Util.ret1(args, args = nil))))
    )

    public Object applyTo(ISeq arglist)
    (§
        (§ return (§ expr fn().applyTo(arglist)))
    )

    static IFn assoc = new AFn()
    (§
        (§ anno @Override)
        public Object invoke(Object m, Object k, Object v)
        (§
            (§ return (§ expr RT.assoc(m, k, v)))
        )
    )

    static IFn dissoc = new AFn()
    (§
        (§ anno @Override)
        public Object invoke(Object c, Object k)
        (§
            (§ return (§ expr RT.dissoc(c, k)))
        )
    )

    ;; Note - serialization only supports reconnecting the Var identity on the deserializing end
    ;; Neither the value in the var nor any of its properties are serialized

    private static class Serialized implements Serializable
    (§
        public Serialized(Symbol nsName, Symbol sym)
        (§
            this.nsName = nsName
            this.sym = sym
        )

        private Symbol nsName
        private Symbol sym

        private Object readResolve() throws ObjectStreamException
        (§
            (§ return (§ expr intern(nsName, sym)))
        )
    )

    private Object writeReplace() throws ObjectStreamException
    (§
        (§ return (§ expr new Serialized(ns.getName(), sym)))
    )
)
)

(java-ns cloiure.lang.Volatile

(§ class final public class Volatile implements IDeref)
(§
    volatile Object val

    public Volatile(Object val)
    (§
        this.val = val
    )

    public Object deref()
    (§
        (§ return (§ expr val))
    )

    public Object reset(Object newval)
    (§
        (§ return (§ expr this.val = newval))
    )
)
)

(java-ns cloiure.lang.WarnBoxedMath

(§ import java.lang.annotation.Retention)
(§ import java.lang.annotation.RetentionPolicy)
(§ import java.lang.annotation.ElementType)
(§ import java.lang.annotation.Target)

(§ anno @Retention(RetentionPolicy.RUNTIME))
(§ anno @Target(ElementType.METHOD))
(§ @interface public @interface WarnBoxedMath)
(§
    boolean value() default true
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

(§ class public class main)
(§
    final static private Symbol CLOIURE_MAIN = Symbol.intern("cloiure.main")
    final static private Var REQUIRE = RT.var("cloiure.core", "require")
    final static private Var MAIN = RT.var("cloiure.main", "main")

    public static void main(String[] args)
    (§
        REQUIRE.invoke(CLOIURE_MAIN)
        MAIN.applyTo(RT.seq(args))
    )
)
)
