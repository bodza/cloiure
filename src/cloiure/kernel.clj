(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(defmacro cond-let [x y & w]
    (let [x (if (vector? x) x [`_# x]) z (when (seq w) `(cond-let ~@w))]
        `(if-let ~x ~y ~z)))

(def % rem)
(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro cast' [_ x] #_(ensure symbol? _) `(do ~x))

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(import
    [java.io File FileInputStream FileNotFoundException FileOutputStream InputStreamReader IOException LineNumberReader OutputStreamWriter PrintWriter PushbackReader Reader #_StringReader StringWriter Writer]
  #_[java.lang Character Class Exception IllegalArgumentException IllegalStateException Integer Number NumberFormatException Object RuntimeException String StringBuilder Throwable UnsupportedOperationException]
    [java.lang.ref Reference ReferenceQueue SoftReference WeakReference]
    [java.lang.reflect Array Constructor Field InvocationHandler #_Method Modifier]
    [java.math BigDecimal BigInteger MathContext]
    [java.net JarURLConnection URL URLClassLoader URLConnection]
    [java.nio ByteBuffer]
    [java.nio.charset Charset]
    [java.security AccessController PrivilegedAction]
    [java.util ArrayList Arrays Collection Comparator HashMap HashSet IdentityHashMap Iterator LinkedList List Map Map$Entry NoSuchElementException Queue RandomAccess Set Stack TreeMap]
    [java.util.concurrent Callable ConcurrentHashMap ConcurrentMap CountDownLatch Executor ExecutorService Executors ThreadFactory TimeUnit]
    [java.util.concurrent.atomic AtomicBoolean AtomicInteger AtomicLong AtomicReference]
    [java.util.concurrent.locks ReentrantReadWriteLock]
    [java.util.regex Matcher Pattern]
    [cloiure.asm Attribute ByteVector ClassVisitor ClassWriter FieldVisitor Label MethodVisitor Opcodes Type]
    [cloiure.asm.commons GeneratorAdapter Method]
)

(declare AFn'''throwArity)
(declare APersistentVector'''rangedIterator)
(declare ATransientMap'''ensureEditable ATransientMap'''doAssoc ATransientMap'''doWithout ATransientMap'''doValAt ATransientMap'''doCount ATransientMap'''doPersistent)
(declare LiteralExpr'''val)
(declare ObjExpr'''emitStatics ObjExpr'''emitMethods ObjExpr'''supportsMeta)
(declare ObjMethod'''numParams ObjMethod'''getMethodName ObjMethod'''getReturnType ObjMethod'''getArgTypes)
(declare IObj'''withMeta)
(declare TNode'''left TNode'''right TNode'''addLeft TNode'''addRight TNode'''removeLeft TNode'''removeRight TNode'''blacken TNode'''redden TNode'''balanceLeft TNode'''balanceRight TNode'''replace)
(declare RestFn'''getRequiredArity RestFn'''doInvoke-2 RestFn'''doInvoke-3 RestFn'''doInvoke-4 RestFn'''doInvoke-5 RestFn'''doInvoke-6 RestFn'''doInvoke-7 RestFn'''doInvoke-8 RestFn'''doInvoke-9 RestFn'''doInvoke-10 RestFn'''doInvoke-11 RestFn'''doInvoke-12 RestFn'''doInvoke-13 RestFn'''doInvoke-14 RestFn'''doInvoke-15 RestFn'''doInvoke-16 RestFn'''doInvoke-17 RestFn'''doInvoke-18 RestFn'''doInvoke-19 RestFn'''doInvoke-20 RestFn'''doInvoke-21 RestFn'''doInvoke-22)

(declare AFn'new AFn'applyToHelper)
(declare AFunction'init AFunction'new)
(declare ActionQueue'init ActionQueue'new)
(declare AgentAction'init AgentAction'new AgentAction''execute AgentAction'doRun)
(declare Agent'sendThreadPoolCounter Agent'sendOffThreadPoolCounter Agent'createThreadFactory Agent'nested Agent'shutdown Agent'init Agent'new-1 Agent'new-2 Agent''setState Agent''getError Agent''setErrorMode Agent''getErrorMode Agent''setErrorHandler Agent''getErrorHandler Agent''restart Agent''dispatch Agent'dispatchAction Agent''enqueue Agent''getQueueCount Agent'releasePendingSends)
(declare AMapEntry'new AMapEntry''asVector AMapEntry''setValue)
(declare KeySeq'create KeySeq'createFromMap KeySeq'init KeySeq'new-2 KeySeq'new-3)
(declare ValSeq'create ValSeq'createFromMap ValSeq'init ValSeq'new-2 ValSeq'new-3)
(declare APersistentMap'init APersistentMap'new APersistentMap'mapEquals APersistentMap'mapHash APersistentMap'mapHasheq APersistentMap'MAKE_ENTRY APersistentMap'MAKE_KEY APersistentMap'MAKE_VAL APersistentMap''containsValue APersistentMap''keySet APersistentMap''values)
(declare APersistentSet'init APersistentSet'new APersistentSet'setEquals)
(declare VSeq'init VSeq'new-2 VSeq'new-3)
(declare RSeq'init RSeq'new-2 RSeq'new-3)
(declare SubVector'init SubVector'new)
(declare APersistentVector'init APersistentVector'new APersistentVector'doEquals APersistentVector'doEquiv)
(declare ARef'init ARef'new-0 ARef'new-1 ARef''validate ARef''validate ARef''notifyWatches)
(declare AReference'init AReference'new-0 AReference'new-1)
(declare ArityException'init ArityException'new-2 ArityException'new-3)
(declare ArrayChunk'init ArrayChunk'new-1 ArrayChunk'new-2 ArrayChunk'new-3)
(declare ArrayIter_int'init ArrayIter_int'new)
(declare ArrayIter_float'init ArrayIter_float'new)
(declare ArrayIter_double'init ArrayIter_double'new)
(declare ArrayIter_long'init ArrayIter_long'new)
(declare ArrayIter_byte'init ArrayIter_byte'new)
(declare ArrayIter_char'init ArrayIter_char'new)
(declare ArrayIter_short'init ArrayIter_short'new)
(declare ArrayIter_boolean'init ArrayIter_boolean'new)
(declare ArrayIter'EMPTY_ITERATOR ArrayIter'create-0 ArrayIter'create-1 ArrayIter'createFromObject ArrayIter'init ArrayIter'new)
(declare ArraySeq_int'init ArraySeq_int'new)
(declare ArraySeq_float'init ArraySeq_float'new)
(declare ArraySeq_double'init ArraySeq_double'new)
(declare ArraySeq_long'init ArraySeq_long'new)
(declare ArraySeq_byte'init ArraySeq_byte'new)
(declare ArraySeq_char'init ArraySeq_char'new)
(declare ArraySeq_short'init ArraySeq_short'new)
(declare ArraySeq_boolean'init ArraySeq_boolean'new)
(declare ArraySeq'create-0 ArraySeq'create-1 ArraySeq'createFromObject ArraySeq'init ArraySeq'new-2 ArraySeq'new-3)
(declare ASeq'init ASeq'new-1 ASeq'new-0)
(declare Atom'init Atom'new-1 Atom'new-2)
(declare ATransientMap'new ATransientMap''conj ATransientMap'NOT_FOUND)
(declare ATransientSet'init ATransientSet'new)
(declare BigInt'init BigInt'new BigInt'fromBigInteger BigInt'fromLong BigInt''toBigInteger BigInt''toBigDecimal BigInt''intValue BigInt''longValue BigInt''floatValue BigInt''doubleValue BigInt''byteValue BigInt''shortValue BigInt'valueOf BigInt''bitLength BigInt''add BigInt''multiply BigInt''quotient BigInt''remainder BigInt''lt)
(declare Binding'init Binding'new-1 Binding'new-2)
(declare Box'init Box'new)
(declare ChunkBuffer'init ChunkBuffer'new ChunkBuffer''add ChunkBuffer''chunk)
(declare ChunkedCons'init ChunkedCons'new-3 ChunkedCons'new-2)
(declare UntypedExpr'new)
(declare DefParser'new)
(declare DefExpr'bindRootMethod DefExpr'setTagMethod DefExpr'setMetaMethod DefExpr'setDynamicMethod DefExpr'internVar DefExpr'init DefExpr'new DefExpr''includesExplicitMetadata)
(declare AssignParser'new)
(declare AssignExpr'init AssignExpr'new)
(declare VarExpr'getMethod VarExpr'setMethod VarExpr'init VarExpr'new)
(declare TheVarParser'new)
(declare TheVarExpr'init TheVarExpr'new)
(declare KeywordExpr'init KeywordExpr'new)
(declare ImportParser'new)
(declare ImportExpr'forNameMethod ImportExpr'importClassMethod ImportExpr'derefMethod ImportExpr'init ImportExpr'new)
(declare LiteralExpr'new)
(declare HostParser'new)
(declare HostExpr'new HostExpr'BOOLEAN_TYPE HostExpr'CHAR_TYPE HostExpr'INTEGER_TYPE HostExpr'LONG_TYPE HostExpr'FLOAT_TYPE HostExpr'DOUBLE_TYPE HostExpr'SHORT_TYPE HostExpr'BYTE_TYPE HostExpr'NUMBER_TYPE HostExpr'charValueMethod HostExpr'booleanValueMethod HostExpr'charValueOfMethod HostExpr'intValueOfMethod HostExpr'longValueOfMethod HostExpr'floatValueOfMethod HostExpr'doubleValueOfMethod HostExpr'shortValueOfMethod HostExpr'byteValueOfMethod HostExpr'intValueMethod HostExpr'longValueMethod HostExpr'floatValueMethod HostExpr'doubleValueMethod HostExpr'byteValueMethod HostExpr'shortValueMethod HostExpr'fromIntMethod HostExpr'fromLongMethod HostExpr'fromDoubleMethod HostExpr'emitBoxReturn HostExpr'emitUnboxArg HostExpr'maybeClass HostExpr'maybeSpecialTag HostExpr'tagToClass)
(declare FieldExpr'new)
(declare InstanceFieldExpr'invokeNoArgInstanceMember InstanceFieldExpr'setInstanceFieldMethod InstanceFieldExpr'init InstanceFieldExpr'new)
(declare StaticFieldExpr'init StaticFieldExpr'new)
(declare MethodExpr'new MethodExpr'emitArgsAsArray MethodExpr'emitTypedArgs)
(declare InstanceMethodExpr'invokeInstanceMethodMethod InstanceMethodExpr'init InstanceMethodExpr'new)
(declare StaticMethodExpr'forNameMethod StaticMethodExpr'invokeStaticMethodMethod StaticMethodExpr'init StaticMethodExpr'new StaticMethodExpr''canEmitIntrinsicPredicate StaticMethodExpr''emitIntrinsicPredicate)
(declare UnresolvedVarExpr'init UnresolvedVarExpr'new)
(declare NumberExpr'init NumberExpr'new NumberExpr'parse)
(declare ConstantParser'new)
(declare ConstantExpr'init ConstantExpr'new)
(declare NilExpr'new)
(declare BooleanExpr'init BooleanExpr'new)
(declare StringExpr'init StringExpr'new)
(declare MonitorEnterParser'new)
(declare MonitorEnterExpr'init MonitorEnterExpr'new)
(declare MonitorExitParser'new)
(declare MonitorExitExpr'init MonitorExitExpr'new)
(declare CatchClause'init CatchClause'new)
(declare TryParser'new)
(declare TryExpr'init TryExpr'new)
(declare ThrowParser'new)
(declare ThrowExpr'init ThrowExpr'new)
(declare NewParser'new)
(declare NewExpr'invokeConstructorMethod NewExpr'forNameMethod NewExpr'init NewExpr'new)
(declare MetaExpr'IOBJ_TYPE MetaExpr'withMetaMethod MetaExpr'init MetaExpr'new)
(declare IfParser'new)
(declare IfExpr'init IfExpr'new IfExpr''doEmit)
(declare EmptyExpr'HASHMAP_TYPE EmptyExpr'HASHSET_TYPE EmptyExpr'VECTOR_TYPE EmptyExpr'IVECTOR_TYPE EmptyExpr'TUPLE_TYPE EmptyExpr'LIST_TYPE EmptyExpr'EMPTY_LIST_TYPE EmptyExpr'init EmptyExpr'new)
(declare ListExpr'arrayToListMethod ListExpr'init ListExpr'new)
(declare MapExpr'mapMethod MapExpr'mapUniqueKeysMethod MapExpr'init MapExpr'new MapExpr'parse)
(declare SetExpr'setMethod SetExpr'init SetExpr'new SetExpr'parse)
(declare VectorExpr'vectorMethod VectorExpr'init VectorExpr'new VectorExpr'parse)
(declare KeywordInvokeExpr'ILOOKUP_TYPE KeywordInvokeExpr'init KeywordInvokeExpr'new)
(declare InstanceOfExpr'init InstanceOfExpr'new)
(declare StaticInvokeExpr'init StaticInvokeExpr'new StaticInvokeExpr'parse)
(declare InvokeExpr'init InvokeExpr'new InvokeExpr''emitProto InvokeExpr''emitArgsAndCall InvokeExpr'parse)
(declare FnExpr'aFnType FnExpr'restFnType FnExpr'init FnExpr'new FnExpr'parse FnExpr''isVariadic FnExpr''emitForDefn)
(declare ObjExpr'CONST_PREFIX ObjExpr'voidctor ObjExpr'DYNAMIC_CLASSLOADER_TYPE ObjExpr'getClassMethod ObjExpr'getClassLoaderMethod ObjExpr'getConstantsMethod ObjExpr'readStringMethod ObjExpr'ILOOKUP_SITE_TYPE ObjExpr'ILOOKUP_THUNK_TYPE ObjExpr'KEYWORD_LOOKUPSITE_TYPE ObjExpr'init ObjExpr'new ObjExpr'trimGenID ObjExpr''ctorTypes ObjExpr''compile ObjExpr''emitKeywordCallsites ObjExpr''emitListAsObjectArray ObjExpr''emitValue ObjExpr''emitConstants ObjExpr''isMutable ObjExpr''isVolatile ObjExpr''isDeftype ObjExpr''emitClearCloses ObjExpr''getCompiledClass ObjExpr''emitLetFnInits ObjExpr''emitAssignLocal ObjExpr''emitLocal ObjExpr''emitUnboxedLocal ObjExpr''emitVar ObjExpr'varGetMethod ObjExpr'varGetRawMethod ObjExpr''emitVarValue ObjExpr''emitKeyword ObjExpr''emitConstant ObjExpr''constantName ObjExpr''siteName ObjExpr''siteNameStatic ObjExpr''thunkName ObjExpr''cachedClassName ObjExpr''cachedVarName ObjExpr''varCallsiteName ObjExpr''thunkNameStatic ObjExpr''constantType)
(declare PathNode'init PathNode'new)
(declare FnMethod'init FnMethod'new FnMethod'classChar FnMethod'primInterface FnMethod'parse FnMethod''doEmitStatic FnMethod''doEmitPrim FnMethod''doEmit FnMethod''isVariadic)
(declare ObjMethod'init ObjMethod'new ObjMethod'emitBody ObjMethod''emitClearLocals ObjMethod''emitClearLocalsOld ObjMethod''emitClearThis)
(declare LocalBinding'init LocalBinding'new LocalBinding''getPrimitiveType)
(declare LocalBindingExpr'init LocalBindingExpr'new)
(declare BodyParser'new)
(declare BodyExpr'init BodyExpr'new BodyExpr''lastExpr)
(declare BindingInit'init BindingInit'new)
(declare LetFnParser'new)
(declare LetFnExpr'init LetFnExpr'new)
(declare LetParser'new)
(declare LetExpr'init LetExpr'new LetExpr''doEmit)
(declare RecurParser'new)
(declare RecurExpr'init RecurExpr'new)
(declare CompilerException'init CompilerException'new)
(declare DeftypeParser'new)
(declare ReifyParser'new)
(declare NewInstanceExpr'init NewInstanceExpr'new NewInstanceExpr'build NewInstanceExpr'compileStub NewInstanceExpr'interfaceNames NewInstanceExpr'slashname NewInstanceExpr'msig NewInstanceExpr'considerMethod NewInstanceExpr'gatherMethods-2m NewInstanceExpr'gatherMethods-2s)
(declare NewInstanceMethod'init NewInstanceMethod'new NewInstanceMethod'msig NewInstanceMethod'parse NewInstanceMethod'findMethodsWithNameAndArity NewInstanceMethod'findMethodsWithName)
(declare MethodParamExpr'init MethodParamExpr'new)
(declare CaseParser'new)
(declare CaseExpr'NUMBER_TYPE CaseExpr'intValueMethod CaseExpr'hashMethod CaseExpr'hashCodeMethod CaseExpr'equivMethod CaseExpr'init CaseExpr'new CaseExpr''doEmit CaseExpr''isShiftMasked CaseExpr''emitShiftMask CaseExpr''emitExprForInts CaseExpr''emitThenForInts CaseExpr''emitExprForHashes CaseExpr''emitThenForHashes CaseExpr'emitExpr)
(declare Compiler'COMPILE_STUB_PREFIX Compiler'MAX_POSITIONAL_ARITY Compiler'CLASS_TYPE Compiler'OBJECT_TYPE Compiler'BOOLEAN_OBJECT_TYPE Compiler'THROWABLE_TYPE Compiler'KEYWORD_TYPE Compiler'VAR_TYPE Compiler'SYMBOL_TYPE Compiler'IFN_TYPE Compiler'AFUNCTION_TYPE Compiler'RT_TYPE Compiler'NUMBERS_TYPE Compiler'NS_TYPE Compiler'UTIL_TYPE Compiler'REFLECTOR_TYPE Compiler'IPERSISTENTMAP_TYPE Compiler'IOBJ_TYPE Compiler'TUPLE_TYPE Compiler'createTupleMethods Compiler'ARG_TYPES Compiler'EXCEPTION_TYPES Compiler'lineDeref Compiler'columnDeref Compiler'RECUR_CLASS Compiler'isSpecial Compiler'inTailCall Compiler'resolveSymbol Compiler'maybePrimitiveType Compiler'maybeJavaClass Compiler'subsumes Compiler'getTypeStringForArgs Compiler'getMatchingParams Compiler'DEMUNGE_MAP Compiler'DEMUNGE_PATTERN Compiler'munge Compiler'demunge Compiler'clearPathRoot Compiler'registerLocal Compiler'getAndIncLocalNum Compiler'analyze-2 Compiler'analyze-3 Compiler'isMacro Compiler'isInline Compiler'namesStaticMember Compiler'preserveTag Compiler'MACRO_CHECK Compiler'MACRO_CHECK_LOADING Compiler'MACRO_CHECK_LOCK Compiler'ensureMacroCheck Compiler'checkSpecs Compiler'macroexpand1 Compiler'macroexpand Compiler'analyzeSeq Compiler'eval-1 Compiler'eval-2 Compiler'registerConstant Compiler'registerKeyword Compiler'registerKeywordCallsite Compiler'registerProtocolCallsite Compiler'registerVarCallsite Compiler'fwdPath Compiler'commonPath Compiler'analyzeSymbol Compiler'destubClassName Compiler'getType Compiler'resolve-2 Compiler'resolve-1 Compiler'namespaceFor-1 Compiler'namespaceFor-2 Compiler'resolveIn Compiler'maybeResolveIn Compiler'lookupVar-3 Compiler'lookupVar-2 Compiler'registerVar Compiler'currentNS Compiler'closeOver Compiler'referenceLocal Compiler'tagOf Compiler'consumeWhitespaces Compiler'load Compiler'pushNS Compiler'pushNSandLoader Compiler'getLookupThunk Compiler'inty Compiler'retType Compiler'primClass-1s Compiler'tagClass Compiler'primClass-1c Compiler'boxClass Compiler'emptyVarCallSites)
(declare Cons'init Cons'new-2 Cons'new-3)
(declare Cycle'init Cycle'new-3 Cycle'new-5 Cycle'create Cycle''current)
(declare Delay'init Delay'new Delay'force)
(declare DynamicClassLoader'classCache DynamicClassLoader'RQ DynamicClassLoader'init DynamicClassLoader'new DynamicClassLoader'findInMemoryClass DynamicClassLoader''registerConstants DynamicClassLoader''getConstants)
(declare ExceptionInfo'init ExceptionInfo'new-2 ExceptionInfo'new-3)
(declare FnLoaderThunk'init FnLoaderThunk'new FnLoaderThunk''load)
(declare Intrinsics'oa)
(declare Iterate'UNREALIZED_SEED Iterate'init Iterate'new-3 Iterate'new-5 Iterate'create)
(declare IteratorSeqState'init IteratorSeqState'new)
(declare IteratorSeq'create IteratorSeq'init IteratorSeq'new-1 IteratorSeq'new-3)
(declare Keyword'TABLE Keyword'RQ Keyword'intern Keyword'init Keyword'new Keyword'find Keyword'find-2 Keyword'find-1 Keyword''throwArity)
(declare KeywordLookupSite'init KeywordLookupSite'new KeywordLookupSite''ilookupThunk KeywordLookupSite''install)
(declare LazilyPersistentVector'createOwning LazilyPersistentVector'fcount LazilyPersistentVector'create)
(declare LazySeq'init LazySeq'new-1 LazySeq'new-2 LazySeq''sval)
(declare LineNumberingPushbackReader'newline LineNumberingPushbackReader'init LineNumberingPushbackReader'new-1 LineNumberingPushbackReader'new-2 LineNumberingPushbackReader''getLineNumber LineNumberingPushbackReader''setLineNumber LineNumberingPushbackReader''getColumnNumber LineNumberingPushbackReader''readLine LineNumberingPushbackReader''atLineStart)
(declare LispReaderException'init LispReaderException'new)
(declare RegexReader'new)
(declare StringReader'new)
(declare CommentReader'new)
(declare DiscardReader'new)
(declare NamespaceMapReader'new)
(declare SymbolicValueReader'new)
(declare WrappingReader'init WrappingReader'new)
(declare VarReader'new)
(declare DispatchReader'new)
(declare FnReader'new)
(declare ArgReader'new)
(declare MetaReader'new)
(declare SyntaxQuoteReader'new SyntaxQuoteReader'syntaxQuote SyntaxQuoteReader'sqExpandList SyntaxQuoteReader'flattenMap)
(declare UnquoteReader'new)
(declare CharacterReader'new)
(declare ListReader'new)
(declare VectorReader'new)
(declare MapReader'new)
(declare SetReader'new)
(declare UnmatchedDelimiterReader'new)
(declare UnreadableReader'new)
(declare LispReader'macros LispReader'dispatchMacros LispReader'symbolPat LispReader'intPat LispReader'ratioPat LispReader'floatPat LispReader'isWhitespace LispReader'unread LispReader'read1 LispReader'read-1 LispReader'read-4 LispReader'read-5 LispReader'ensurePending LispReader'read-7 LispReader'readToken LispReader'readNumber LispReader'readUnicodeChar-4 LispReader'readUnicodeChar-5 LispReader'interpretToken LispReader'matchSymbol LispReader'matchNumber LispReader'getMacro LispReader'isMacro LispReader'isTerminatingMacro LispReader'garg LispReader'registerArg LispReader'isUnquoteSplicing LispReader'isUnquote LispReader'READ_EOF LispReader'READ_FINISHED LispReader'readDelimitedList)
(declare RetryEx'new)
(declare AbortException'new)
(declare LockingTransactionInfo'init LockingTransactionInfo'new LockingTransactionInfo''running)
(declare CFn'init CFn'new)
(declare Notify'init Notify'new)
(declare LockingTransaction'RETRY_LIMIT LockingTransaction'LOCK_WAIT_MSECS LockingTransaction'BARGE_WAIT_NANOS LockingTransaction'RUNNING LockingTransaction'COMMITTING LockingTransaction'RETRY LockingTransaction'KILLED LockingTransaction'COMMITTED LockingTransaction'transaction LockingTransaction'lastPoint LockingTransaction'init LockingTransaction'new LockingTransaction''getReadPoint LockingTransaction''getCommitPoint LockingTransaction''stop LockingTransaction''tryWriteLock LockingTransaction''lock LockingTransaction''blockAndBail LockingTransaction''releaseIfEnsured LockingTransaction''abort LockingTransaction''bargeTimeElapsed LockingTransaction''barge LockingTransaction'getEx LockingTransaction'isRunning LockingTransaction'getRunning LockingTransaction'runInTransaction LockingTransaction''run LockingTransaction''enqueue LockingTransaction''doGet LockingTransaction''doSet LockingTransaction''doEnsure LockingTransaction''doCommute)
(declare LongRangeIterator'init LongRangeIterator'new)
(declare LongChunk'init LongChunk'new LongChunk''first)
(declare LongRange'CHUNK_SIZE LongRange'positiveStep LongRange'negativeStep LongRange'init LongRange'new-4 LongRange'new-6 LongRange'new-7 LongRange'create-1 LongRange'create-2 LongRange'create-3 LongRange''forceChunk LongRange''steppingCount LongRange''rangeCount)
(declare MapEntry'create MapEntry'init MapEntry'new)
(declare Entry'init Entry'new)
(declare MethodImplCache'init MethodImplCache'new-2 MethodImplCache'new-5 MethodImplCache'new-3 MethodImplCache''fnFor MethodImplCache''findFnFor)
(declare MultiFn'init MultiFn'new MultiFn''reset MultiFn''addMethod MultiFn''removeMethod MultiFn''preferMethod MultiFn''prefers MultiFn''isA MultiFn''dominates MultiFn''resetCache MultiFn''getMethod MultiFn''getFn MultiFn''findAndCacheBestMethod)
(declare Murmur3'seed Murmur3'C1 Murmur3'C2 Murmur3'hashInt Murmur3'hashLong Murmur3'hashUnencodedChars Murmur3'mixCollHash Murmur3'hashOrdered Murmur3'hashUnordered Murmur3'mixK1 Murmur3'mixH1 Murmur3'fmix)
(declare Namespace'namespaces Namespace'init Namespace'new Namespace'all Namespace''getName Namespace''getMappings Namespace''warnOrFailOnReplace Namespace''intern Namespace''referenceVar Namespace'areDifferentInstancesOfSameClassName Namespace''referenceClass Namespace''unmap Namespace''importClass Namespace''importClass Namespace''refer Namespace'findOrCreate Namespace'remove Namespace'find Namespace''getMapping Namespace''findInternedVar Namespace''getAliases Namespace''lookupAlias Namespace''addAlias Namespace''removeAlias)
(declare OpsP'new)
(declare LongOps'new LongOps'gcd)
(declare DoubleOps'new)
(declare RatioOps'new RatioOps'normalizeRet)
(declare BigIntOps'new)
(declare BigDecimalOps'new)
(declare Numbers'isZero-1o Numbers'isPos-1o Numbers'isNeg-1o Numbers'minus-1o Numbers'minusP-1o Numbers'inc-1o Numbers'incP-1o Numbers'dec-1o Numbers'decP-1o Numbers'add-2oo Numbers'addP-2oo Numbers'minus-2oo Numbers'minusP-2oo Numbers'multiply-2oo Numbers'multiplyP-2oo Numbers'divide-2oo Numbers'quotient-2oo Numbers'remainder-2oo Numbers'quotient-2dd Numbers'remainder-2dd Numbers'equiv-2oo Numbers'equiv-2nn Numbers'equal Numbers'lt-2oo Numbers'lte-2oo Numbers'gt-2oo Numbers'gte-2oo Numbers'compare Numbers'toBigInt Numbers'toBigInteger Numbers'toBigDecimal Numbers'toRatio Numbers'rationalize Numbers'reduceBigInt Numbers'divide-2ii Numbers'shiftLeftInt Numbers'shiftLeft-2oo Numbers'shiftLeft-2ol Numbers'shiftLeft-2lo Numbers'shiftLeft-2ll Numbers'shiftRightInt Numbers'shiftRight-2oo Numbers'shiftRight-2ol Numbers'shiftRight-2lo Numbers'shiftRight-2ll Numbers'unsignedShiftRightInt Numbers'unsignedShiftRight-2oo Numbers'unsignedShiftRight-2ol Numbers'unsignedShiftRight-2lo Numbers'unsignedShiftRight-2ll Numbers'ops Numbers'hasheqFrom Numbers'hasheq Numbers'category Numbers'bitOpsCast Numbers'float_array-2 Numbers'float_array-1 Numbers'double_array-2 Numbers'double_array-1 Numbers'int_array-2 Numbers'int_array-1 Numbers'long_array-2 Numbers'long_array-1 Numbers'short_array-2 Numbers'short_array-1 Numbers'char_array-2 Numbers'char_array-1 Numbers'byte_array-2 Numbers'byte_array-1 Numbers'boolean_array-2 Numbers'boolean_array-1 Numbers'booleans Numbers'bytes Numbers'chars Numbers'shorts Numbers'floats Numbers'doubles Numbers'ints Numbers'longs Numbers'num-1o Numbers'num-1f Numbers'num-1d Numbers'add-2dd Numbers'addP-2dd Numbers'minus-2dd Numbers'minusP-2dd Numbers'minus-1d Numbers'minusP-1d Numbers'inc-1d Numbers'incP-1d Numbers'dec-1d Numbers'decP-1d Numbers'multiply-2dd Numbers'multiplyP-2dd Numbers'divide-2dd Numbers'equiv-2dd Numbers'lt-2dd Numbers'lte-2dd Numbers'gt-2dd Numbers'gte-2dd Numbers'isPos-1d Numbers'isNeg-1d Numbers'isZero-1d Numbers'throwIntOverflow Numbers'unchecked_int_add Numbers'unchecked_int_subtract Numbers'unchecked_int_negate Numbers'unchecked_int_inc Numbers'unchecked_int_dec Numbers'unchecked_int_multiply Numbers'not-1o Numbers'not-1l Numbers'and-2oo Numbers'and-2ol Numbers'and-2lo Numbers'and-2ll Numbers'or-2oo Numbers'or-2ol Numbers'or-2lo Numbers'or-2ll Numbers'xor-2oo Numbers'xor-2ol Numbers'xor-2lo Numbers'xor-2ll Numbers'andNot-2oo Numbers'andNot-2ol Numbers'andNot-2lo Numbers'andNot-2ll Numbers'clearBit-2oo Numbers'clearBit-2ol Numbers'clearBit-2lo Numbers'clearBit-2ll Numbers'setBit-2oo Numbers'setBit-2ol Numbers'setBit-2lo Numbers'setBit-2ll Numbers'flipBit-2oo Numbers'flipBit-2ol Numbers'flipBit-2lo Numbers'flipBit-2ll Numbers'testBit-2oo Numbers'testBit-2ol Numbers'testBit-2lo Numbers'testBit-2ll Numbers'unchecked_int_divide Numbers'unchecked_int_remainder Numbers'num-1l Numbers'unchecked_add-2ll Numbers'unchecked_minus-2ll Numbers'unchecked_multiply-2ll Numbers'unchecked_minus-1l Numbers'unchecked_inc-1l Numbers'unchecked_dec-1l Numbers'unchecked_add-2oo Numbers'unchecked_minus-2oo Numbers'unchecked_multiply-2oo Numbers'unchecked_minus-1o Numbers'unchecked_inc-1o Numbers'unchecked_dec-1o Numbers'unchecked_add-2dd Numbers'unchecked_minus-2dd Numbers'unchecked_multiply-2dd Numbers'unchecked_minus-1d Numbers'unchecked_inc-1d Numbers'unchecked_dec-1d Numbers'unchecked_add-2do Numbers'unchecked_minus-2do Numbers'unchecked_multiply-2do Numbers'unchecked_add-2od Numbers'unchecked_minus-2od Numbers'unchecked_multiply-2od Numbers'unchecked_add-2dl Numbers'unchecked_minus-2dl Numbers'unchecked_multiply-2dl Numbers'unchecked_add-2ld Numbers'unchecked_minus-2ld Numbers'unchecked_multiply-2ld Numbers'unchecked_add-2lo Numbers'unchecked_minus-2lo Numbers'unchecked_multiply-2lo Numbers'unchecked_add-2ol Numbers'unchecked_minus-2ol Numbers'unchecked_multiply-2ol Numbers'quotient-2do Numbers'quotient-2od Numbers'quotient-2lo Numbers'quotient-2ol Numbers'quotient-2dl Numbers'quotient-2ld Numbers'remainder-2do Numbers'remainder-2od Numbers'remainder-2lo Numbers'remainder-2ol Numbers'remainder-2dl Numbers'remainder-2ld Numbers'add-2ll Numbers'addP-2ll Numbers'minus-2ll Numbers'minusP-2ll Numbers'minus-1l Numbers'minusP-1l Numbers'inc-1l Numbers'dec-1l Numbers'incP-1l Numbers'decP-1l Numbers'multiply-2ll Numbers'multiplyP-2ll Numbers'quotient-2ll Numbers'remainder-2ll Numbers'equiv-2ll Numbers'lt-2ll Numbers'lte-2ll Numbers'gt-2ll Numbers'gte-2ll Numbers'isPos-1l Numbers'isNeg-1l Numbers'isZero-1l Numbers'add-2lo Numbers'add-2ol Numbers'addP-2lo Numbers'addP-2ol Numbers'add-2do Numbers'add-2od Numbers'add-2dl Numbers'add-2ld Numbers'addP-2do Numbers'addP-2od Numbers'addP-2dl Numbers'addP-2ld Numbers'minus-2lo Numbers'minus-2ol Numbers'minusP-2lo Numbers'minusP-2ol Numbers'minus-2do Numbers'minus-2od Numbers'minus-2dl Numbers'minus-2ld Numbers'minusP-2do Numbers'minusP-2od Numbers'minusP-2dl Numbers'minusP-2ld Numbers'multiply-2lo Numbers'multiply-2ol Numbers'multiplyP-2lo Numbers'multiplyP-2ol Numbers'multiply-2do Numbers'multiply-2od Numbers'multiply-2dl Numbers'multiply-2ld Numbers'multiplyP-2do Numbers'multiplyP-2od Numbers'multiplyP-2dl Numbers'multiplyP-2ld Numbers'divide-2lo Numbers'divide-2ol Numbers'divide-2do Numbers'divide-2od Numbers'divide-2dl Numbers'divide-2ld Numbers'divide-2ll Numbers'lt-2lo Numbers'lt-2ol Numbers'lt-2do Numbers'lt-2od Numbers'lt-2dl Numbers'lt-2ld Numbers'lte-2lo Numbers'lte-2ol Numbers'lte-2do Numbers'lte-2od Numbers'lte-2dl Numbers'lte-2ld Numbers'gt-2lo Numbers'gt-2ol Numbers'gt-2do Numbers'gt-2od Numbers'gt-2dl Numbers'gt-2ld Numbers'gte-2lo Numbers'gte-2ol Numbers'gte-2do Numbers'gte-2od Numbers'gte-2dl Numbers'gte-2ld Numbers'equiv-2lo Numbers'equiv-2ol Numbers'equiv-2do Numbers'equiv-2od Numbers'equiv-2dl Numbers'equiv-2ld Numbers'isNaN Numbers'max-2ll Numbers'max-2dd Numbers'max-2ld Numbers'max-2dl Numbers'max-2lo Numbers'max-2ol Numbers'max-2do Numbers'max-2od Numbers'max-2oo Numbers'min-2ll Numbers'min-2dd Numbers'min-2ld Numbers'min-2dl Numbers'min-2lo Numbers'min-2ol Numbers'min-2do Numbers'min-2od Numbers'min-2oo)
(declare Obj'init Obj'new-1 Obj'new-0)
(declare MSeq'init MSeq'new-2 MSeq'new-3)
(declare MIter'init MIter'new-2 MIter'new-3)
(declare TransientArrayMap'init TransientArrayMap'new TransientArrayMap''indexOf)
(declare PersistentArrayMap'HASHTABLE_THRESHOLD PersistentArrayMap'create PersistentArrayMap'init PersistentArrayMap'new-0 PersistentArrayMap''create PersistentArrayMap''createHT PersistentArrayMap'createWithCheck PersistentArrayMap'createAsIfByAssoc PersistentArrayMap'new-1 PersistentArrayMap'new-2 PersistentArrayMap''capacity PersistentArrayMap''indexOfObject PersistentArrayMap''indexOf PersistentArrayMap'equalKey)
(declare TransientHashMap'init TransientHashMap'new-1 TransientHashMap'new-5)
(declare HSeq'create-1 HSeq'create-4 HSeq'init HSeq'new)
(declare HIter'init HIter'new)
(declare ArrayNode'init ArrayNode'new ArrayNode'foldTasks ArrayNode''ensureEditable ArrayNode''editAndSet ArrayNode''pack)
(declare BitmapIndexedNode'init BitmapIndexedNode'new BitmapIndexedNode''index BitmapIndexedNode''ensureEditable BitmapIndexedNode''editAndSet BitmapIndexedNode''editAndSet BitmapIndexedNode''editAndRemovePair)
(declare HashCollisionNode'init HashCollisionNode'new HashCollisionNode''findIndex HashCollisionNode''ensureEditable HashCollisionNode''ensureEditable HashCollisionNode''editAndSet HashCollisionNode''editAndSet)
(declare NodeIter'NULL NodeIter'init NodeIter'new NodeIter''advance)
(declare NodeSeq'init NodeSeq'new-2 NodeSeq'create-1 NodeSeq'kvreduce NodeSeq'create-3 NodeSeq'new-4)
(declare PersistentHashMap'NOT_FOUND PersistentHashMap'create-1m PersistentHashMap'create-1a PersistentHashMap'createWithCheck-1a PersistentHashMap'create-1s PersistentHashMap'createWithCheck-1s PersistentHashMap'create-2 PersistentHashMap'init PersistentHashMap'new-4 PersistentHashMap'new-5 PersistentHashMap'hash PersistentHashMap'EMPTY_ITER PersistentHashMap''iterator PersistentHashMap''fold PersistentHashMap'mask PersistentHashMap'cloneAndSet-3 PersistentHashMap'cloneAndSet-5 PersistentHashMap'removePair PersistentHashMap'createNode-6 PersistentHashMap'createNode-7 PersistentHashMap'bitpos)
(declare TransientHashSet'new)
(declare PersistentHashSet'create-1a PersistentHashSet'create-1l PersistentHashSet'create-1s PersistentHashSet'createWithCheck-1a PersistentHashSet'createWithCheck-1l PersistentHashSet'createWithCheck-1s PersistentHashSet'init PersistentHashSet'new)
(declare Primordial'new Primordial'invokeStatic)
(declare EmptyList'new EmptyList'hasheq)
(declare PersistentList'init PersistentList'new-1 PersistentList'new-4 PersistentList'create)
(declare QSeq'init QSeq'new-2 QSeq'new-3)
(declare PersistentQueue'init PersistentQueue'new)
(declare TNode'init TNode'new)
(declare Black'new)
(declare BlackVal'init BlackVal'new)
(declare BlackBranch'init BlackBranch'new)
(declare BlackBranchVal'init BlackBranchVal'new)
(declare Red'new)
(declare RedVal'init RedVal'new)
(declare RedBranch'init RedBranch'new)
(declare RedBranchVal'init RedBranchVal'new)
(declare TSeq'init TSeq'new-2 TSeq'new-3 TSeq'new-4 TSeq'create TSeq'push)
(declare NodeIterator'init NodeIterator'new NodeIterator''push)
(declare KeyIterator'init KeyIterator'new)
(declare ValIterator'init ValIterator'new)
(declare PersistentTreeMap'create-1m PersistentTreeMap'init PersistentTreeMap'new-0 PersistentTreeMap'new-1 PersistentTreeMap'new-2 PersistentTreeMap'new-4m PersistentTreeMap'create-1s PersistentTreeMap'create-2 PersistentTreeMap''reverseIterator PersistentTreeMap''keys PersistentTreeMap''vals PersistentTreeMap''keys PersistentTreeMap''vals PersistentTreeMap''minKey PersistentTreeMap''min PersistentTreeMap''maxKey PersistentTreeMap''max PersistentTreeMap''depth PersistentTreeMap''depth PersistentTreeMap''capacity PersistentTreeMap''doCompare PersistentTreeMap''add PersistentTreeMap''remove PersistentTreeMap'append PersistentTreeMap'balanceLeftDel PersistentTreeMap'balanceRightDel PersistentTreeMap'leftBalance PersistentTreeMap'rightBalance PersistentTreeMap''replace PersistentTreeMap'new-4c PersistentTreeMap'red PersistentTreeMap'black)
(declare PersistentTreeSet'create-1 PersistentTreeSet'create-2 PersistentTreeSet'init PersistentTreeSet'new)
(declare VNode'init VNode'new-2 VNode'new-1)
(declare ChunkedSeq'init ChunkedSeq'new-3 ChunkedSeq'new-5 ChunkedSeq'new-4)
(declare TransientVector'init TransientVector'new-4 TransientVector'new-1 TransientVector''ensureEditable TransientVector''ensureEditable TransientVector'editableRoot TransientVector'editableTail TransientVector''pushTail TransientVector''tailoff TransientVector''arrayFor TransientVector''editableArrayFor TransientVector'NOT_FOUND TransientVector''doAssoc TransientVector''popTail)
(declare PersistentVector'NOEDIT PersistentVector'EMPTY_NODE PersistentVector'TRANSIENT_VECTOR_CONJ PersistentVector'adopt PersistentVector'create-1r PersistentVector'create-1s PersistentVector'create-1l PersistentVector'create-1i PersistentVector'create-1a PersistentVector'init PersistentVector'new-4 PersistentVector'new-5 PersistentVector''tailoff PersistentVector''arrayFor PersistentVector'doAssoc PersistentVector''pushTail PersistentVector'newPath PersistentVector''chunkedSeq PersistentVector''popTail)
(declare ProxyHandler'init ProxyHandler'new)
(declare RangeIterator'init RangeIterator'new)
(declare Range'CHUNK_SIZE Range'positiveStep Range'negativeStep Range'init Range'new-4 Range'new-6 Range'new-7 Range'create-1 Range'create-2 Range'create-3 Range''forceChunk)
(declare Ratio'init Ratio'new Ratio''intValue Ratio''longValue Ratio''floatValue Ratio''doubleValue Ratio''decimalValue Ratio''decimalValue Ratio''bigIntegerValue)
(declare RecordIterator'init RecordIterator'new)
(declare Reduced'init Reduced'new)
(declare RefTVal'init RefTVal'new-3 RefTVal'new-2)
(declare Ref'ids Ref'init Ref'new-1 Ref'new-2 Ref''getMinHistory Ref''setMinHistory Ref''getMaxHistory Ref''setMaxHistory Ref''currentVal Ref''set Ref''commute Ref''alter Ref''touch Ref''isBound Ref''trimHistory Ref''getHistoryCount Ref''histCount Ref''fn)
(declare Reflector'invokeInstanceMethod Reflector'getCauseOrElse Reflector'throwCauseOrElseException Reflector'noMethodReport Reflector'invokeMatchingMethod Reflector'getAsMethodOfPublicBase Reflector'isMatch Reflector'invokeConstructor Reflector'invokeStaticMethodVariadic Reflector'invokeStaticMethod-3s Reflector'invokeStaticMethod-3c Reflector'getStaticField-2s Reflector'getStaticField-2c Reflector'setStaticField-3s Reflector'setStaticField-3c Reflector'getInstanceField Reflector'setInstanceField Reflector'invokeNoArgInstanceMember Reflector'invokeInstanceMember-2 Reflector'invokeInstanceMember-3o Reflector'invokeInstanceMember-3a Reflector'getField Reflector'getMethods Reflector'boxArg Reflector'boxArgs Reflector'paramArgTypeMatch Reflector'isCongruent Reflector'prepRet)
(declare Repeat'INFINITE Repeat'init Repeat'new-2 Repeat'new-3 Repeat'create-1 Repeat'create-2)
(declare RestFn'new RestFn'ontoArrayPrepend RestFn'findKey)
(declare DefaultComparator'new)
(declare RT'T RT'F RT'LOADER_SUFFIX RT'UTF8 RT'inNamespace RT'bootNamespace RT'errPrintWriter RT'EMPTY_ARRAY RT'ID RT'CHECK_SPEC_ASSERTS RT'INSTRUMENT_MACROS RT'CHECK_SPECS RT'keyword RT'var RT'loadResourceScript RT'lastModified RT'load-1 RT'load-2 RT'nextID RT'CHUNK_SIZE RT'chunkIteratorSeq RT'seq RT'seqFrom RT'canSeq RT'iter RT'seqOrElse RT'keys RT'vals RT'meta RT'count RT'countFrom RT'conj RT'cons RT'first RT'second RT'third RT'fourth RT'next RT'more RT'peek RT'pop RT'get-2 RT'getFrom-2 RT'get-3 RT'getFrom-3 RT'assoc RT'contains RT'find RT'findKey RT'dissoc RT'nth-2 RT'nthFrom-2 RT'nth-3 RT'nthFrom-3 RT'assocN RT'hasTag RT'box-1o RT'box-1c RT'box-1z RT'box-1Z RT'box-1b RT'box-1s RT'box-1i RT'box-1l RT'box-1f RT'box-1d RT'charCast-1o RT'charCast-1b RT'charCast-1s RT'charCast-1c RT'charCast-1i RT'charCast-1l RT'charCast-1f RT'charCast-1d RT'booleanCast-1o RT'booleanCast-1b RT'byteCast-1o RT'byteCast-1b RT'byteCast-1s RT'byteCast-1i RT'byteCast-1l RT'byteCast-1f RT'byteCast-1d RT'shortCast-1o RT'shortCast-1b RT'shortCast-1s RT'shortCast-1i RT'shortCast-1l RT'shortCast-1f RT'shortCast-1d RT'intCast-1o RT'intCast-1b RT'intCast-1s RT'intCast-1c RT'intCast-1i RT'intCast-1l RT'intCast-1f RT'intCast-1d RT'longCast-1o RT'longCast-1b RT'longCast-1s RT'longCast-1i RT'longCast-1l RT'longCast-1f RT'longCast-1d RT'floatCast-1o RT'floatCast-1b RT'floatCast-1s RT'floatCast-1i RT'floatCast-1l RT'floatCast-1f RT'floatCast-1d RT'doubleCast-1o RT'doubleCast-1b RT'doubleCast-1s RT'doubleCast-1i RT'doubleCast-1l RT'doubleCast-1f RT'doubleCast-1d RT'uncheckedByteCast-1o RT'uncheckedByteCast-1b RT'uncheckedByteCast-1s RT'uncheckedByteCast-1i RT'uncheckedByteCast-1l RT'uncheckedByteCast-1f RT'uncheckedByteCast-1d RT'uncheckedShortCast-1o RT'uncheckedShortCast-1b RT'uncheckedShortCast-1s RT'uncheckedShortCast-1i RT'uncheckedShortCast-1l RT'uncheckedShortCast-1f RT'uncheckedShortCast-1d RT'uncheckedCharCast-1o RT'uncheckedCharCast-1b RT'uncheckedCharCast-1s RT'uncheckedCharCast-1c RT'uncheckedCharCast-1i RT'uncheckedCharCast-1l RT'uncheckedCharCast-1f RT'uncheckedCharCast-1d RT'uncheckedIntCast-1o RT'uncheckedIntCast-1b RT'uncheckedIntCast-1s RT'uncheckedIntCast-1c RT'uncheckedIntCast-1i RT'uncheckedIntCast-1l RT'uncheckedIntCast-1f RT'uncheckedIntCast-1d RT'uncheckedLongCast-1o RT'uncheckedLongCast-1b RT'uncheckedLongCast-1s RT'uncheckedLongCast-1i RT'uncheckedLongCast-1l RT'uncheckedLongCast-1f RT'uncheckedLongCast-1d RT'uncheckedFloatCast-1o RT'uncheckedFloatCast-1b RT'uncheckedFloatCast-1s RT'uncheckedFloatCast-1i RT'uncheckedFloatCast-1l RT'uncheckedFloatCast-1f RT'uncheckedFloatCast-1d RT'uncheckedDoubleCast-1o RT'uncheckedDoubleCast-1b RT'uncheckedDoubleCast-1s RT'uncheckedDoubleCast-1i RT'uncheckedDoubleCast-1l RT'uncheckedDoubleCast-1f RT'uncheckedDoubleCast-1d RT'map RT'mapUniqueKeys RT'set RT'vector RT'subvec RT'list-0 RT'list-1 RT'list-2 RT'list-3 RT'list-4 RT'list-5 RT'listStar-2 RT'listStar-3 RT'listStar-4 RT'listStar-5 RT'listStar-6 RT'arrayToList RT'object_array RT'toArray RT'seqToArray RT'seqToPassedArray RT'seqToTypedArray-1 RT'seqToTypedArray-2 RT'length RT'boundedLength RT'readRet RT'readChar RT'peekChar RT'getLineNumber RT'getColumnNumber RT'getLineNumberingReader RT'isLineNumberingReader RT'isReduced RT'printString RT'readString RT'print RT'printInnerSeq RT'makeClassLoader RT'baseLoader RT'resourceAsStream RT'getResource RT'classForName-3 RT'classForName-1 RT'classForNameNonLoading RT'loadClassForName RT'aget_boolean RT'aget_byte RT'aget_short RT'aget_char RT'aget_int RT'aget_long RT'aget_float RT'aget_double RT'aget_object RT'aset_boolean RT'aset_byte RT'aset_short RT'aset_char RT'aset_int RT'aset_long RT'aset_float RT'aset_double RT'aset_object RT'alength_boolean RT'alength_byte RT'alength_short RT'alength_char RT'alength_int RT'alength_long RT'alength_float RT'alength_double RT'alength_object RT'aclone_boolean RT'aclone_byte RT'aclone_short RT'aclone_char RT'aclone_int RT'aclone_long RT'aclone_float RT'aclone_double RT'aclone_object)
(declare SeqIterator'START SeqIterator'init SeqIterator'new)
(declare StringSeq'create StringSeq'init StringSeq'new)
(declare Symbol'create-2 Symbol'create-1 Symbol'intern Symbol'init Symbol'new-2 Symbol'new-3)
(declare TransactionalHashMap'init TransactionalHashMap'new-0 TransactionalHashMap'new-1i TransactionalHashMap'new-1m TransactionalHashMap''mapAt TransactionalHashMap''binFor)
(declare EmptyBuffer'new)
(declare SingleBuffer'init SingleBuffer'new)
(declare ManyBuffer'init ManyBuffer'new)
(declare MultiIterator'init MultiIterator'new)
(declare TransformerIterator'EMPTY TransformerIterator'NONE TransformerIterator'init TransformerIterator'new TransformerIterator'create TransformerIterator'createMulti TransformerIterator''step)
(declare Tuple'MAX_SIZE Tuple'create)
(declare Util'equiv-2oo Util'equivNull Util'equivEquals Util'equivNumber Util'equivColl Util'equivPred Util'equiv-2ll Util'equiv-2ol Util'equiv-2lo Util'equiv-2dd Util'equiv-2od Util'equiv-2do Util'equiv-2bb Util'equiv-2ob Util'equiv-2bo Util'equiv-2cc Util'pcequiv Util'equals Util'identical Util'classOf Util'compare Util'hash Util'hasheq Util'hashCombine Util'isPrimitive Util'isInteger Util'ret1 Util'clearCache Util'sneakyThrow0 Util'sneakyThrow)
(declare TBox'init TBox'new)
(declare Unbound'init Unbound'new)
(declare Frame'init Frame'new)
(declare Var'dvals Var'rev Var'getThreadBindingFrame Var'resetThreadBindingFrame Var'intern Var'internPrivate Var'find Var'create Var'init Var'new Var''setDynamic Var''setDynamic Var''isDynamic Var''isBound Var''get Var''alter Var''set Var''setMeta Var''setMacro Var''isMacro Var''isPublic Var''getRawRoot Var''getTag Var''setTag Var''hasRoot Var''bindRoot Var''swapRoot Var''unbindRoot Var''commuteRoot Var''alterRoot Var'pushThreadBindings Var'popThreadBindings Var'getThreadBindings Var''getThreadBinding Var''fn Var'assoc Var'dissoc)
(declare Volatile'init Volatile'new Volatile''reset)

(declare ActionQueue'EMPTY)
(declare Agent'CONTINUE Agent'FAIL Agent'pooledExecutor Agent'soloExecutor)
(declare BigInt'ZERO BigInt'ONE)
(declare ConstantParser'formKey)
(declare InvokeExpr'onKey InvokeExpr'methodMapKey)
(declare NewInstanceMethod'dummyThis)
(declare CaseExpr'compactKey CaseExpr'sparseKey CaseExpr'hashIdentityKey CaseExpr'hashEquivKey CaseExpr'intKey)
(declare Compiler'DEF Compiler'LOOP Compiler'RECUR Compiler'IF Compiler'LET Compiler'LETFN Compiler'DO Compiler'FN Compiler'FNONCE Compiler'QUOTE Compiler'THE_VAR Compiler'DOT Compiler'ASSIGN Compiler'TRY Compiler'CATCH Compiler'FINALLY Compiler'THROW Compiler'MONITOR_ENTER Compiler'MONITOR_EXIT Compiler'IMPORT Compiler'DEFTYPE Compiler'CASE Compiler'CLASS Compiler'NEW Compiler'THIS Compiler'REIFY Compiler'LIST Compiler'HASHMAP Compiler'VECTOR Compiler'IDENTITY Compiler'_AMP_ Compiler'ISEQ Compiler'loadNs Compiler'inlineKey Compiler'inlineAritiesKey Compiler'volatileKey Compiler'implementsKey Compiler'protocolKey Compiler'onKey Compiler'dynamicKey Compiler'redefKey Compiler'NS Compiler'IN_NS Compiler'specials Compiler'LOCAL_ENV Compiler'LOOP_LOCALS Compiler'LOOP_LABEL Compiler'CONSTANTS Compiler'CONSTANT_IDS Compiler'KEYWORD_CALLSITES Compiler'PROTOCOL_CALLSITES Compiler'VAR_CALLSITES Compiler'KEYWORDS Compiler'VARS Compiler'METHOD Compiler'IN_CATCH_FINALLY Compiler'METHOD_RETURN_CONTEXT Compiler'NO_RECUR Compiler'LOADER Compiler'INSTANCE Compiler'LINE Compiler'COLUMN Compiler'NEXT_LOCAL_NUM Compiler'RET_LOCAL_NUM Compiler'COMPILE_STUB_SYM Compiler'COMPILE_STUB_CLASS Compiler'CLEAR_PATH Compiler'CLEAR_ROOT Compiler'CLEAR_SITES Compiler'NIL_EXPR Compiler'TRUE_EXPR Compiler'FALSE_EXPR Compiler'CHAR_MAP)
(declare Intrinsics'ops Intrinsics'preds)
(declare RegexReader'stringrdr)
(declare SymbolicValueReader'specials)
(declare LispReader'QUOTE LispReader'THE_VAR LispReader'UNQUOTE LispReader'UNQUOTE_SPLICING LispReader'CONCAT LispReader'SEQ LispReader'LIST LispReader'APPLY LispReader'HASHMAP LispReader'HASHSET LispReader'VECTOR LispReader'WITH_META LispReader'META LispReader'DEREF LispReader'GENSYM_ENV LispReader'ARG_ENV LispReader'OPT_EOF LispReader'EOFTHROW)
(declare MultiFn'assoc MultiFn'dissoc MultiFn'isa MultiFn'parents)
(declare BigDecimalOps'MATH_CONTEXT)
(declare Numbers'LONG_OPS Numbers'DOUBLE_OPS Numbers'RATIO_OPS Numbers'BIGINT_OPS Numbers'BIGDECIMAL_OPS)
(declare PersistentArrayMap'EMPTY)
(declare BitmapIndexedNode'EMPTY)
(declare PersistentHashMap'EMPTY)
(declare PersistentHashSet'EMPTY)
(declare EmptyList'HASHEQ)
(declare PersistentList'creator PersistentList'EMPTY)
(declare PersistentQueue'EMPTY)
(declare PersistentTreeMap'EMPTY)
(declare PersistentTreeSet'EMPTY)
(declare PersistentVector'EMPTY)
(declare RT'DEFAULT_IMPORTS RT'CLOIURE_NS RT'IN RT'OUT RT'ERR RT'TAG_KEY RT'AGENT RT'ASSERT RT'MATH_CONTEXT RT'LINE_KEY RT'COLUMN_KEY RT'DECLARED_KEY RT'DOC_KEY RT'IN_NAMESPACE RT'NAMESPACE RT'IDENTICAL RT'CURRENT_NS RT'FLUSH_ON_NEWLINE RT'PRINT_READABLY RT'WARN_ON_REFLECTION RT'ALLOW_UNRESOLVED_VARS RT'IN_NS_VAR RT'NS_VAR RT'FN_LOADER_VAR RT'PRINT_INITIALIZED RT'PR_ON RT'DEFAULT_COMPARATOR)
(declare Frame'TOP)
(declare Var'privateKey Var'privateMeta Var'macroKey Var'nameKey Var'nsKey)
(declare main'CLOIURE_MAIN main'REQUIRE main'MAIN)

(java-ns cloiure.lang.Associative

(defprotocol Associative #_(§ extends IPersistentCollection, ILookup)
    #_abstract
    (#_"boolean" Associative'''containsKey [#_"Associative" this, #_"Object" key])
    #_abstract
    (#_"IMapEntry" Associative'''entryAt [#_"Associative" this, #_"Object" key])
    #_abstract
    (#_"Associative" Associative'''assoc [#_"Associative" this, #_"Object" key, #_"Object" val])
)
)

(java-ns cloiure.lang.Compiler

(defprotocol Expr
    #_abstract
    (#_"Object" Expr'''eval [#_"Expr" this])
    #_abstract
    (#_"void" Expr'''emit [#_"Expr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen])
    #_abstract
    (#_"boolean" Expr'''hasJavaClass [#_"Expr" this])
    #_abstract
    (#_"Class" Expr'''getJavaClass [#_"Expr" this])
)

(defprotocol IParser
    #_abstract
    (#_"Expr" IParser'''parse [#_"IParser" this, #_"Context" context, #_"Object" form])
)

(defprotocol AssignableExpr
    #_abstract
    (#_"Object" AssignableExpr'''evalAssign [#_"AssignableExpr" this, #_"Expr" val])
    #_abstract
    (#_"void" AssignableExpr'''emitAssign [#_"AssignableExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val])
)

(defprotocol MaybePrimitiveExpr #_(§ extends Expr)
    #_abstract
    (#_"boolean" MaybePrimitiveExpr'''canEmitPrimitive [#_"MaybePrimitiveExpr" this])
    #_abstract
    (#_"void" MaybePrimitiveExpr'''emitUnboxed [#_"MaybePrimitiveExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen])
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(defprotocol Counted
    #_abstract
    (#_"int" Counted'''count [#_"Counted" this])
)
)

(java-ns cloiure.lang.Fn

(defprotocol Fn
)
)

(java-ns cloiure.lang.IAtom

(defprotocol IAtom
    #_abstract
    (#_"Object" IAtom'''swap-2 [#_"IAtom" this, #_"IFn" f])
    #_abstract
    (#_"Object" IAtom'''swap-3 [#_"IAtom" this, #_"IFn" f, #_"Object" arg])
    #_abstract
    (#_"Object" IAtom'''swap-4 [#_"IAtom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"Object" IAtom'''swap-5 [#_"IAtom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args])
    #_abstract
    (#_"boolean" IAtom'''compareAndSet [#_"IAtom" this, #_"Object" oldv, #_"Object" newv])
    #_abstract
    (#_"Object" IAtom'''reset [#_"IAtom" this, #_"Object" newval])
)
)

(java-ns cloiure.lang.IAtom2

(defprotocol IAtom2 #_(§ extends IAtom)
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals-2 [#_"IAtom2" this, #_"IFn" f])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals-3 [#_"IAtom2" this, #_"IFn" f, #_"Object" arg])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals-4 [#_"IAtom2" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals-5 [#_"IAtom2" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args])
    #_abstract
    (#_"IPersistentVector" IAtom2'''resetVals [#_"IAtom2" this, #_"Object" newv])
)
)

(java-ns cloiure.lang.IBlockingDeref

(defprotocol IBlockingDeref
    #_abstract
    (#_"Object" IBlockingDeref'''deref [#_"IBlockingDeref" this, #_"long" ms, #_"Object" timeoutValue])
)
)

(java-ns cloiure.lang.IChunk

(defprotocol IChunk #_(§ extends Indexed)
    #_abstract
    (#_"IChunk" IChunk'''dropFirst [#_"IChunk" this])
    #_abstract
    (#_"Object" IChunk'''reduce [#_"IChunk" this, #_"IFn" f, #_"Object" start])
)
)

(java-ns cloiure.lang.IChunkedSeq

(defprotocol IChunkedSeq #_(§ extends ISeq, Sequential)
    #_abstract
    (#_"IChunk" IChunkedSeq'''chunkedFirst [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''chunkedNext [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''chunkedMore [#_"IChunkedSeq" this])
)
)

(java-ns cloiure.lang.IDeref

(defprotocol IDeref
    #_abstract
    (#_"Object" IDeref'''deref [#_"IDeref" this])
)
)

(java-ns cloiure.lang.IEditableCollection

(defprotocol IEditableCollection
    #_abstract
    (#_"ITransientCollection" IEditableCollection'''asTransient [#_"IEditableCollection" this])
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(defprotocol IExceptionInfo
    #_abstract
    (#_"IPersistentMap" IExceptionInfo'''getData [#_"IExceptionInfo" this])
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

(defprotocol L
    #_abstract
    (#_"long" L'''invokePrim [#_"L" this])
)

(defprotocol D
    #_abstract
    (#_"double" D'''invokePrim [#_"D" this])
)

(defprotocol OL
    #_abstract
    (#_"long" OL'''invokePrim [#_"OL" this, #_"Object" arg0])
)

(defprotocol OD
    #_abstract
    (#_"double" OD'''invokePrim [#_"OD" this, #_"Object" arg0])
)

(defprotocol LO
    #_abstract
    (#_"Object" LO'''invokePrim [#_"LO" this, #_"long" arg0])
)

(defprotocol LL
    #_abstract
    (#_"long" LL'''invokePrim [#_"LL" this, #_"long" arg0])
)

(defprotocol LD
    #_abstract
    (#_"double" LD'''invokePrim [#_"LD" this, #_"long" arg0])
)

(defprotocol DO
    #_abstract
    (#_"Object" DO'''invokePrim [#_"DO" this, #_"double" arg0])
)

(defprotocol DL
    #_abstract
    (#_"long" DL'''invokePrim [#_"DL" this, #_"double" arg0])
)

(defprotocol DD
    #_abstract
    (#_"double" DD'''invokePrim [#_"DD" this, #_"double" arg0])
)

(defprotocol OOL
    #_abstract
    (#_"long" OOL'''invokePrim [#_"OOL" this, #_"Object" arg0, #_"Object" arg1])
)

(defprotocol OOD
    #_abstract
    (#_"double" OOD'''invokePrim [#_"OOD" this, #_"Object" arg0, #_"Object" arg1])
)

(defprotocol OLO
    #_abstract
    (#_"Object" OLO'''invokePrim [#_"OLO" this, #_"Object" arg0, #_"long" arg1])
)

(defprotocol OLL
    #_abstract
    (#_"long" OLL'''invokePrim [#_"OLL" this, #_"Object" arg0, #_"long" arg1])
)

(defprotocol OLD
    #_abstract
    (#_"double" OLD'''invokePrim [#_"OLD" this, #_"Object" arg0, #_"long" arg1])
)

(defprotocol ODO
    #_abstract
    (#_"Object" ODO'''invokePrim [#_"ODO" this, #_"Object" arg0, #_"double" arg1])
)

(defprotocol ODL
    #_abstract
    (#_"long" ODL'''invokePrim [#_"ODL" this, #_"Object" arg0, #_"double" arg1])
)

(defprotocol ODD
    #_abstract
    (#_"double" ODD'''invokePrim [#_"ODD" this, #_"Object" arg0, #_"double" arg1])
)

(defprotocol LOO
    #_abstract
    (#_"Object" LOO'''invokePrim [#_"LOO" this, #_"long" arg0, #_"Object" arg1])
)

(defprotocol LOL
    #_abstract
    (#_"long" LOL'''invokePrim [#_"LOL" this, #_"long" arg0, #_"Object" arg1])
)

(defprotocol LOD
    #_abstract
    (#_"double" LOD'''invokePrim [#_"LOD" this, #_"long" arg0, #_"Object" arg1])
)

(defprotocol LLO
    #_abstract
    (#_"Object" LLO'''invokePrim [#_"LLO" this, #_"long" arg0, #_"long" arg1])
)

(defprotocol LLL
    #_abstract
    (#_"long" LLL'''invokePrim [#_"LLL" this, #_"long" arg0, #_"long" arg1])
)

(defprotocol LLD
    #_abstract
    (#_"double" LLD'''invokePrim [#_"LLD" this, #_"long" arg0, #_"long" arg1])
)

(defprotocol LDO
    #_abstract
    (#_"Object" LDO'''invokePrim [#_"LDO" this, #_"long" arg0, #_"double" arg1])
)

(defprotocol LDL
    #_abstract
    (#_"long" LDL'''invokePrim [#_"LDL" this, #_"long" arg0, #_"double" arg1])
)

(defprotocol LDD
    #_abstract
    (#_"double" LDD'''invokePrim [#_"LDD" this, #_"long" arg0, #_"double" arg1])
)

(defprotocol DOO
    #_abstract
    (#_"Object" DOO'''invokePrim [#_"DOO" this, #_"double" arg0, #_"Object" arg1])
)

(defprotocol DOL
    #_abstract
    (#_"long" DOL'''invokePrim [#_"DOL" this, #_"double" arg0, #_"Object" arg1])
)

(defprotocol DOD
    #_abstract
    (#_"double" DOD'''invokePrim [#_"DOD" this, #_"double" arg0, #_"Object" arg1])
)

(defprotocol DLO
    #_abstract
    (#_"Object" DLO'''invokePrim [#_"DLO" this, #_"double" arg0, #_"long" arg1])
)

(defprotocol DLL
    #_abstract
    (#_"long" DLL'''invokePrim [#_"DLL" this, #_"double" arg0, #_"long" arg1])
)

(defprotocol DLD
    #_abstract
    (#_"double" DLD'''invokePrim [#_"DLD" this, #_"double" arg0, #_"long" arg1])
)

(defprotocol DDO
    #_abstract
    (#_"Object" DDO'''invokePrim [#_"DDO" this, #_"double" arg0, #_"double" arg1])
)

(defprotocol DDL
    #_abstract
    (#_"long" DDL'''invokePrim [#_"DDL" this, #_"double" arg0, #_"double" arg1])
)

(defprotocol DDD
    #_abstract
    (#_"double" DDD'''invokePrim [#_"DDD" this, #_"double" arg0, #_"double" arg1])
)

(defprotocol OOOL
    #_abstract
    (#_"long" OOOL'''invokePrim [#_"OOOL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2])
)

(defprotocol OOOD
    #_abstract
    (#_"double" OOOD'''invokePrim [#_"OOOD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2])
)

(defprotocol OOLO
    #_abstract
    (#_"Object" OOLO'''invokePrim [#_"OOLO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol OOLL
    #_abstract
    (#_"long" OOLL'''invokePrim [#_"OOLL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol OOLD
    #_abstract
    (#_"double" OOLD'''invokePrim [#_"OOLD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol OODO
    #_abstract
    (#_"Object" OODO'''invokePrim [#_"OODO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol OODL
    #_abstract
    (#_"long" OODL'''invokePrim [#_"OODL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol OODD
    #_abstract
    (#_"double" OODD'''invokePrim [#_"OODD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol OLOO
    #_abstract
    (#_"Object" OLOO'''invokePrim [#_"OLOO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol OLOL
    #_abstract
    (#_"long" OLOL'''invokePrim [#_"OLOL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol OLOD
    #_abstract
    (#_"double" OLOD'''invokePrim [#_"OLOD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol OLLO
    #_abstract
    (#_"Object" OLLO'''invokePrim [#_"OLLO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol OLLL
    #_abstract
    (#_"long" OLLL'''invokePrim [#_"OLLL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol OLLD
    #_abstract
    (#_"double" OLLD'''invokePrim [#_"OLLD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol OLDO
    #_abstract
    (#_"Object" OLDO'''invokePrim [#_"OLDO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol OLDL
    #_abstract
    (#_"long" OLDL'''invokePrim [#_"OLDL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol OLDD
    #_abstract
    (#_"double" OLDD'''invokePrim [#_"OLDD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol ODOO
    #_abstract
    (#_"Object" ODOO'''invokePrim [#_"ODOO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol ODOL
    #_abstract
    (#_"long" ODOL'''invokePrim [#_"ODOL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol ODOD
    #_abstract
    (#_"double" ODOD'''invokePrim [#_"ODOD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol ODLO
    #_abstract
    (#_"Object" ODLO'''invokePrim [#_"ODLO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol ODLL
    #_abstract
    (#_"long" ODLL'''invokePrim [#_"ODLL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol ODLD
    #_abstract
    (#_"double" ODLD'''invokePrim [#_"ODLD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol ODDO
    #_abstract
    (#_"Object" ODDO'''invokePrim [#_"ODDO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol ODDL
    #_abstract
    (#_"long" ODDL'''invokePrim [#_"ODDL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol ODDD
    #_abstract
    (#_"double" ODDD'''invokePrim [#_"ODDD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol LOOO
    #_abstract
    (#_"Object" LOOO'''invokePrim [#_"LOOO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
)

(defprotocol LOOL
    #_abstract
    (#_"long" LOOL'''invokePrim [#_"LOOL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
)

(defprotocol LOOD
    #_abstract
    (#_"double" LOOD'''invokePrim [#_"LOOD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2])
)

(defprotocol LOLO
    #_abstract
    (#_"Object" LOLO'''invokePrim [#_"LOLO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol LOLL
    #_abstract
    (#_"long" LOLL'''invokePrim [#_"LOLL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol LOLD
    #_abstract
    (#_"double" LOLD'''invokePrim [#_"LOLD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol LODO
    #_abstract
    (#_"Object" LODO'''invokePrim [#_"LODO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol LODL
    #_abstract
    (#_"long" LODL'''invokePrim [#_"LODL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol LODD
    #_abstract
    (#_"double" LODD'''invokePrim [#_"LODD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol LLOO
    #_abstract
    (#_"Object" LLOO'''invokePrim [#_"LLOO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol LLOL
    #_abstract
    (#_"long" LLOL'''invokePrim [#_"LLOL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol LLOD
    #_abstract
    (#_"double" LLOD'''invokePrim [#_"LLOD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol LLLO
    #_abstract
    (#_"Object" LLLO'''invokePrim [#_"LLLO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol LLLL
    #_abstract
    (#_"long" LLLL'''invokePrim [#_"LLLL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol LLLD
    #_abstract
    (#_"double" LLLD'''invokePrim [#_"LLLD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol LLDO
    #_abstract
    (#_"Object" LLDO'''invokePrim [#_"LLDO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol LLDL
    #_abstract
    (#_"long" LLDL'''invokePrim [#_"LLDL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol LLDD
    #_abstract
    (#_"double" LLDD'''invokePrim [#_"LLDD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol LDOO
    #_abstract
    (#_"Object" LDOO'''invokePrim [#_"LDOO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol LDOL
    #_abstract
    (#_"long" LDOL'''invokePrim [#_"LDOL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol LDOD
    #_abstract
    (#_"double" LDOD'''invokePrim [#_"LDOD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol LDLO
    #_abstract
    (#_"Object" LDLO'''invokePrim [#_"LDLO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol LDLL
    #_abstract
    (#_"long" LDLL'''invokePrim [#_"LDLL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol LDLD
    #_abstract
    (#_"double" LDLD'''invokePrim [#_"LDLD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol LDDO
    #_abstract
    (#_"Object" LDDO'''invokePrim [#_"LDDO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol LDDL
    #_abstract
    (#_"long" LDDL'''invokePrim [#_"LDDL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol LDDD
    #_abstract
    (#_"double" LDDD'''invokePrim [#_"LDDD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol DOOO
    #_abstract
    (#_"Object" DOOO'''invokePrim [#_"DOOO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
)

(defprotocol DOOL
    #_abstract
    (#_"long" DOOL'''invokePrim [#_"DOOL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
)

(defprotocol DOOD
    #_abstract
    (#_"double" DOOD'''invokePrim [#_"DOOD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2])
)

(defprotocol DOLO
    #_abstract
    (#_"Object" DOLO'''invokePrim [#_"DOLO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol DOLL
    #_abstract
    (#_"long" DOLL'''invokePrim [#_"DOLL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol DOLD
    #_abstract
    (#_"double" DOLD'''invokePrim [#_"DOLD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2])
)

(defprotocol DODO
    #_abstract
    (#_"Object" DODO'''invokePrim [#_"DODO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol DODL
    #_abstract
    (#_"long" DODL'''invokePrim [#_"DODL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol DODD
    #_abstract
    (#_"double" DODD'''invokePrim [#_"DODD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2])
)

(defprotocol DLOO
    #_abstract
    (#_"Object" DLOO'''invokePrim [#_"DLOO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol DLOL
    #_abstract
    (#_"long" DLOL'''invokePrim [#_"DLOL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol DLOD
    #_abstract
    (#_"double" DLOD'''invokePrim [#_"DLOD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2])
)

(defprotocol DLLO
    #_abstract
    (#_"Object" DLLO'''invokePrim [#_"DLLO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol DLLL
    #_abstract
    (#_"long" DLLL'''invokePrim [#_"DLLL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol DLLD
    #_abstract
    (#_"double" DLLD'''invokePrim [#_"DLLD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2])
)

(defprotocol DLDO
    #_abstract
    (#_"Object" DLDO'''invokePrim [#_"DLDO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol DLDL
    #_abstract
    (#_"long" DLDL'''invokePrim [#_"DLDL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol DLDD
    #_abstract
    (#_"double" DLDD'''invokePrim [#_"DLDD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2])
)

(defprotocol DDOO
    #_abstract
    (#_"Object" DDOO'''invokePrim [#_"DDOO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol DDOL
    #_abstract
    (#_"long" DDOL'''invokePrim [#_"DDOL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol DDOD
    #_abstract
    (#_"double" DDOD'''invokePrim [#_"DDOD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2])
)

(defprotocol DDLO
    #_abstract
    (#_"Object" DDLO'''invokePrim [#_"DDLO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol DDLL
    #_abstract
    (#_"long" DDLL'''invokePrim [#_"DDLL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol DDLD
    #_abstract
    (#_"double" DDLD'''invokePrim [#_"DDLD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2])
)

(defprotocol DDDO
    #_abstract
    (#_"Object" DDDO'''invokePrim [#_"DDDO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol DDDL
    #_abstract
    (#_"long" DDDL'''invokePrim [#_"DDDL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol DDDD
    #_abstract
    (#_"double" DDDD'''invokePrim [#_"DDDD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2])
)

(defprotocol OOOOL
    #_abstract
    (#_"long" OOOOL'''invokePrim [#_"OOOOL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol OOOOD
    #_abstract
    (#_"double" OOOOD'''invokePrim [#_"OOOOD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol OOOLO
    #_abstract
    (#_"Object" OOOLO'''invokePrim [#_"OOOLO" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol OOOLL
    #_abstract
    (#_"long" OOOLL'''invokePrim [#_"OOOLL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol OOOLD
    #_abstract
    (#_"double" OOOLD'''invokePrim [#_"OOOLD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol OOODO
    #_abstract
    (#_"Object" OOODO'''invokePrim [#_"OOODO" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol OOODL
    #_abstract
    (#_"long" OOODL'''invokePrim [#_"OOODL" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol OOODD
    #_abstract
    (#_"double" OOODD'''invokePrim [#_"OOODD" this, #_"Object" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol OOLOO
    #_abstract
    (#_"Object" OOLOO'''invokePrim [#_"OOLOO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol OOLOL
    #_abstract
    (#_"long" OOLOL'''invokePrim [#_"OOLOL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol OOLOD
    #_abstract
    (#_"double" OOLOD'''invokePrim [#_"OOLOD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol OOLLO
    #_abstract
    (#_"Object" OOLLO'''invokePrim [#_"OOLLO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol OOLLL
    #_abstract
    (#_"long" OOLLL'''invokePrim [#_"OOLLL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol OOLLD
    #_abstract
    (#_"double" OOLLD'''invokePrim [#_"OOLLD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol OOLDO
    #_abstract
    (#_"Object" OOLDO'''invokePrim [#_"OOLDO" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol OOLDL
    #_abstract
    (#_"long" OOLDL'''invokePrim [#_"OOLDL" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol OOLDD
    #_abstract
    (#_"double" OOLDD'''invokePrim [#_"OOLDD" this, #_"Object" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol OODOO
    #_abstract
    (#_"Object" OODOO'''invokePrim [#_"OODOO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol OODOL
    #_abstract
    (#_"long" OODOL'''invokePrim [#_"OODOL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol OODOD
    #_abstract
    (#_"double" OODOD'''invokePrim [#_"OODOD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol OODLO
    #_abstract
    (#_"Object" OODLO'''invokePrim [#_"OODLO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol OODLL
    #_abstract
    (#_"long" OODLL'''invokePrim [#_"OODLL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol OODLD
    #_abstract
    (#_"double" OODLD'''invokePrim [#_"OODLD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol OODDO
    #_abstract
    (#_"Object" OODDO'''invokePrim [#_"OODDO" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol OODDL
    #_abstract
    (#_"long" OODDL'''invokePrim [#_"OODDL" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol OODDD
    #_abstract
    (#_"double" OODDD'''invokePrim [#_"OODDD" this, #_"Object" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol OLOOO
    #_abstract
    (#_"Object" OLOOO'''invokePrim [#_"OLOOO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol OLOOL
    #_abstract
    (#_"long" OLOOL'''invokePrim [#_"OLOOL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol OLOOD
    #_abstract
    (#_"double" OLOOD'''invokePrim [#_"OLOOD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol OLOLO
    #_abstract
    (#_"Object" OLOLO'''invokePrim [#_"OLOLO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol OLOLL
    #_abstract
    (#_"long" OLOLL'''invokePrim [#_"OLOLL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol OLOLD
    #_abstract
    (#_"double" OLOLD'''invokePrim [#_"OLOLD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol OLODO
    #_abstract
    (#_"Object" OLODO'''invokePrim [#_"OLODO" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol OLODL
    #_abstract
    (#_"long" OLODL'''invokePrim [#_"OLODL" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol OLODD
    #_abstract
    (#_"double" OLODD'''invokePrim [#_"OLODD" this, #_"Object" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol OLLOO
    #_abstract
    (#_"Object" OLLOO'''invokePrim [#_"OLLOO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol OLLOL
    #_abstract
    (#_"long" OLLOL'''invokePrim [#_"OLLOL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol OLLOD
    #_abstract
    (#_"double" OLLOD'''invokePrim [#_"OLLOD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol OLLLO
    #_abstract
    (#_"Object" OLLLO'''invokePrim [#_"OLLLO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol OLLLL
    #_abstract
    (#_"long" OLLLL'''invokePrim [#_"OLLLL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol OLLLD
    #_abstract
    (#_"double" OLLLD'''invokePrim [#_"OLLLD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol OLLDO
    #_abstract
    (#_"Object" OLLDO'''invokePrim [#_"OLLDO" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol OLLDL
    #_abstract
    (#_"long" OLLDL'''invokePrim [#_"OLLDL" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol OLLDD
    #_abstract
    (#_"double" OLLDD'''invokePrim [#_"OLLDD" this, #_"Object" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol OLDOO
    #_abstract
    (#_"Object" OLDOO'''invokePrim [#_"OLDOO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol OLDOL
    #_abstract
    (#_"long" OLDOL'''invokePrim [#_"OLDOL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol OLDOD
    #_abstract
    (#_"double" OLDOD'''invokePrim [#_"OLDOD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol OLDLO
    #_abstract
    (#_"Object" OLDLO'''invokePrim [#_"OLDLO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol OLDLL
    #_abstract
    (#_"long" OLDLL'''invokePrim [#_"OLDLL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol OLDLD
    #_abstract
    (#_"double" OLDLD'''invokePrim [#_"OLDLD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol OLDDO
    #_abstract
    (#_"Object" OLDDO'''invokePrim [#_"OLDDO" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol OLDDL
    #_abstract
    (#_"long" OLDDL'''invokePrim [#_"OLDDL" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol OLDDD
    #_abstract
    (#_"double" OLDDD'''invokePrim [#_"OLDDD" this, #_"Object" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol ODOOO
    #_abstract
    (#_"Object" ODOOO'''invokePrim [#_"ODOOO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol ODOOL
    #_abstract
    (#_"long" ODOOL'''invokePrim [#_"ODOOL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol ODOOD
    #_abstract
    (#_"double" ODOOD'''invokePrim [#_"ODOOD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol ODOLO
    #_abstract
    (#_"Object" ODOLO'''invokePrim [#_"ODOLO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol ODOLL
    #_abstract
    (#_"long" ODOLL'''invokePrim [#_"ODOLL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol ODOLD
    #_abstract
    (#_"double" ODOLD'''invokePrim [#_"ODOLD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol ODODO
    #_abstract
    (#_"Object" ODODO'''invokePrim [#_"ODODO" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol ODODL
    #_abstract
    (#_"long" ODODL'''invokePrim [#_"ODODL" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol ODODD
    #_abstract
    (#_"double" ODODD'''invokePrim [#_"ODODD" this, #_"Object" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol ODLOO
    #_abstract
    (#_"Object" ODLOO'''invokePrim [#_"ODLOO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol ODLOL
    #_abstract
    (#_"long" ODLOL'''invokePrim [#_"ODLOL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol ODLOD
    #_abstract
    (#_"double" ODLOD'''invokePrim [#_"ODLOD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol ODLLO
    #_abstract
    (#_"Object" ODLLO'''invokePrim [#_"ODLLO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol ODLLL
    #_abstract
    (#_"long" ODLLL'''invokePrim [#_"ODLLL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol ODLLD
    #_abstract
    (#_"double" ODLLD'''invokePrim [#_"ODLLD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol ODLDO
    #_abstract
    (#_"Object" ODLDO'''invokePrim [#_"ODLDO" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol ODLDL
    #_abstract
    (#_"long" ODLDL'''invokePrim [#_"ODLDL" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol ODLDD
    #_abstract
    (#_"double" ODLDD'''invokePrim [#_"ODLDD" this, #_"Object" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol ODDOO
    #_abstract
    (#_"Object" ODDOO'''invokePrim [#_"ODDOO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol ODDOL
    #_abstract
    (#_"long" ODDOL'''invokePrim [#_"ODDOL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol ODDOD
    #_abstract
    (#_"double" ODDOD'''invokePrim [#_"ODDOD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol ODDLO
    #_abstract
    (#_"Object" ODDLO'''invokePrim [#_"ODDLO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol ODDLL
    #_abstract
    (#_"long" ODDLL'''invokePrim [#_"ODDLL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol ODDLD
    #_abstract
    (#_"double" ODDLD'''invokePrim [#_"ODDLD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol ODDDO
    #_abstract
    (#_"Object" ODDDO'''invokePrim [#_"ODDDO" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol ODDDL
    #_abstract
    (#_"long" ODDDL'''invokePrim [#_"ODDDL" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol ODDDD
    #_abstract
    (#_"double" ODDDD'''invokePrim [#_"ODDDD" this, #_"Object" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LOOOO
    #_abstract
    (#_"Object" LOOOO'''invokePrim [#_"LOOOO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LOOOL
    #_abstract
    (#_"long" LOOOL'''invokePrim [#_"LOOOL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LOOOD
    #_abstract
    (#_"double" LOOOD'''invokePrim [#_"LOOOD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LOOLO
    #_abstract
    (#_"Object" LOOLO'''invokePrim [#_"LOOLO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LOOLL
    #_abstract
    (#_"long" LOOLL'''invokePrim [#_"LOOLL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LOOLD
    #_abstract
    (#_"double" LOOLD'''invokePrim [#_"LOOLD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LOODO
    #_abstract
    (#_"Object" LOODO'''invokePrim [#_"LOODO" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LOODL
    #_abstract
    (#_"long" LOODL'''invokePrim [#_"LOODL" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LOODD
    #_abstract
    (#_"double" LOODD'''invokePrim [#_"LOODD" this, #_"long" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LOLOO
    #_abstract
    (#_"Object" LOLOO'''invokePrim [#_"LOLOO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LOLOL
    #_abstract
    (#_"long" LOLOL'''invokePrim [#_"LOLOL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LOLOD
    #_abstract
    (#_"double" LOLOD'''invokePrim [#_"LOLOD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LOLLO
    #_abstract
    (#_"Object" LOLLO'''invokePrim [#_"LOLLO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LOLLL
    #_abstract
    (#_"long" LOLLL'''invokePrim [#_"LOLLL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LOLLD
    #_abstract
    (#_"double" LOLLD'''invokePrim [#_"LOLLD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LOLDO
    #_abstract
    (#_"Object" LOLDO'''invokePrim [#_"LOLDO" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LOLDL
    #_abstract
    (#_"long" LOLDL'''invokePrim [#_"LOLDL" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LOLDD
    #_abstract
    (#_"double" LOLDD'''invokePrim [#_"LOLDD" this, #_"long" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LODOO
    #_abstract
    (#_"Object" LODOO'''invokePrim [#_"LODOO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LODOL
    #_abstract
    (#_"long" LODOL'''invokePrim [#_"LODOL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LODOD
    #_abstract
    (#_"double" LODOD'''invokePrim [#_"LODOD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LODLO
    #_abstract
    (#_"Object" LODLO'''invokePrim [#_"LODLO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LODLL
    #_abstract
    (#_"long" LODLL'''invokePrim [#_"LODLL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LODLD
    #_abstract
    (#_"double" LODLD'''invokePrim [#_"LODLD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LODDO
    #_abstract
    (#_"Object" LODDO'''invokePrim [#_"LODDO" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LODDL
    #_abstract
    (#_"long" LODDL'''invokePrim [#_"LODDL" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LODDD
    #_abstract
    (#_"double" LODDD'''invokePrim [#_"LODDD" this, #_"long" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LLOOO
    #_abstract
    (#_"Object" LLOOO'''invokePrim [#_"LLOOO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LLOOL
    #_abstract
    (#_"long" LLOOL'''invokePrim [#_"LLOOL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LLOOD
    #_abstract
    (#_"double" LLOOD'''invokePrim [#_"LLOOD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LLOLO
    #_abstract
    (#_"Object" LLOLO'''invokePrim [#_"LLOLO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LLOLL
    #_abstract
    (#_"long" LLOLL'''invokePrim [#_"LLOLL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LLOLD
    #_abstract
    (#_"double" LLOLD'''invokePrim [#_"LLOLD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LLODO
    #_abstract
    (#_"Object" LLODO'''invokePrim [#_"LLODO" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LLODL
    #_abstract
    (#_"long" LLODL'''invokePrim [#_"LLODL" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LLODD
    #_abstract
    (#_"double" LLODD'''invokePrim [#_"LLODD" this, #_"long" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LLLOO
    #_abstract
    (#_"Object" LLLOO'''invokePrim [#_"LLLOO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LLLOL
    #_abstract
    (#_"long" LLLOL'''invokePrim [#_"LLLOL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LLLOD
    #_abstract
    (#_"double" LLLOD'''invokePrim [#_"LLLOD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LLLLO
    #_abstract
    (#_"Object" LLLLO'''invokePrim [#_"LLLLO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LLLLL
    #_abstract
    (#_"long" LLLLL'''invokePrim [#_"LLLLL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LLLLD
    #_abstract
    (#_"double" LLLLD'''invokePrim [#_"LLLLD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LLLDO
    #_abstract
    (#_"Object" LLLDO'''invokePrim [#_"LLLDO" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LLLDL
    #_abstract
    (#_"long" LLLDL'''invokePrim [#_"LLLDL" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LLLDD
    #_abstract
    (#_"double" LLLDD'''invokePrim [#_"LLLDD" this, #_"long" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LLDOO
    #_abstract
    (#_"Object" LLDOO'''invokePrim [#_"LLDOO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LLDOL
    #_abstract
    (#_"long" LLDOL'''invokePrim [#_"LLDOL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LLDOD
    #_abstract
    (#_"double" LLDOD'''invokePrim [#_"LLDOD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LLDLO
    #_abstract
    (#_"Object" LLDLO'''invokePrim [#_"LLDLO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LLDLL
    #_abstract
    (#_"long" LLDLL'''invokePrim [#_"LLDLL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LLDLD
    #_abstract
    (#_"double" LLDLD'''invokePrim [#_"LLDLD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LLDDO
    #_abstract
    (#_"Object" LLDDO'''invokePrim [#_"LLDDO" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LLDDL
    #_abstract
    (#_"long" LLDDL'''invokePrim [#_"LLDDL" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LLDDD
    #_abstract
    (#_"double" LLDDD'''invokePrim [#_"LLDDD" this, #_"long" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LDOOO
    #_abstract
    (#_"Object" LDOOO'''invokePrim [#_"LDOOO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LDOOL
    #_abstract
    (#_"long" LDOOL'''invokePrim [#_"LDOOL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LDOOD
    #_abstract
    (#_"double" LDOOD'''invokePrim [#_"LDOOD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol LDOLO
    #_abstract
    (#_"Object" LDOLO'''invokePrim [#_"LDOLO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LDOLL
    #_abstract
    (#_"long" LDOLL'''invokePrim [#_"LDOLL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LDOLD
    #_abstract
    (#_"double" LDOLD'''invokePrim [#_"LDOLD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol LDODO
    #_abstract
    (#_"Object" LDODO'''invokePrim [#_"LDODO" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LDODL
    #_abstract
    (#_"long" LDODL'''invokePrim [#_"LDODL" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LDODD
    #_abstract
    (#_"double" LDODD'''invokePrim [#_"LDODD" this, #_"long" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol LDLOO
    #_abstract
    (#_"Object" LDLOO'''invokePrim [#_"LDLOO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LDLOL
    #_abstract
    (#_"long" LDLOL'''invokePrim [#_"LDLOL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LDLOD
    #_abstract
    (#_"double" LDLOD'''invokePrim [#_"LDLOD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol LDLLO
    #_abstract
    (#_"Object" LDLLO'''invokePrim [#_"LDLLO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LDLLL
    #_abstract
    (#_"long" LDLLL'''invokePrim [#_"LDLLL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LDLLD
    #_abstract
    (#_"double" LDLLD'''invokePrim [#_"LDLLD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol LDLDO
    #_abstract
    (#_"Object" LDLDO'''invokePrim [#_"LDLDO" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LDLDL
    #_abstract
    (#_"long" LDLDL'''invokePrim [#_"LDLDL" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LDLDD
    #_abstract
    (#_"double" LDLDD'''invokePrim [#_"LDLDD" this, #_"long" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol LDDOO
    #_abstract
    (#_"Object" LDDOO'''invokePrim [#_"LDDOO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LDDOL
    #_abstract
    (#_"long" LDDOL'''invokePrim [#_"LDDOL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LDDOD
    #_abstract
    (#_"double" LDDOD'''invokePrim [#_"LDDOD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol LDDLO
    #_abstract
    (#_"Object" LDDLO'''invokePrim [#_"LDDLO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LDDLL
    #_abstract
    (#_"long" LDDLL'''invokePrim [#_"LDDLL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LDDLD
    #_abstract
    (#_"double" LDDLD'''invokePrim [#_"LDDLD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol LDDDO
    #_abstract
    (#_"Object" LDDDO'''invokePrim [#_"LDDDO" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LDDDL
    #_abstract
    (#_"long" LDDDL'''invokePrim [#_"LDDDL" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol LDDDD
    #_abstract
    (#_"double" LDDDD'''invokePrim [#_"LDDDD" this, #_"long" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DOOOO
    #_abstract
    (#_"Object" DOOOO'''invokePrim [#_"DOOOO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DOOOL
    #_abstract
    (#_"long" DOOOL'''invokePrim [#_"DOOOL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DOOOD
    #_abstract
    (#_"double" DOOOD'''invokePrim [#_"DOOOD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DOOLO
    #_abstract
    (#_"Object" DOOLO'''invokePrim [#_"DOOLO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DOOLL
    #_abstract
    (#_"long" DOOLL'''invokePrim [#_"DOOLL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DOOLD
    #_abstract
    (#_"double" DOOLD'''invokePrim [#_"DOOLD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DOODO
    #_abstract
    (#_"Object" DOODO'''invokePrim [#_"DOODO" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DOODL
    #_abstract
    (#_"long" DOODL'''invokePrim [#_"DOODL" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DOODD
    #_abstract
    (#_"double" DOODD'''invokePrim [#_"DOODD" this, #_"double" arg0, #_"Object" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DOLOO
    #_abstract
    (#_"Object" DOLOO'''invokePrim [#_"DOLOO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DOLOL
    #_abstract
    (#_"long" DOLOL'''invokePrim [#_"DOLOL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DOLOD
    #_abstract
    (#_"double" DOLOD'''invokePrim [#_"DOLOD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DOLLO
    #_abstract
    (#_"Object" DOLLO'''invokePrim [#_"DOLLO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DOLLL
    #_abstract
    (#_"long" DOLLL'''invokePrim [#_"DOLLL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DOLLD
    #_abstract
    (#_"double" DOLLD'''invokePrim [#_"DOLLD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DOLDO
    #_abstract
    (#_"Object" DOLDO'''invokePrim [#_"DOLDO" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DOLDL
    #_abstract
    (#_"long" DOLDL'''invokePrim [#_"DOLDL" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DOLDD
    #_abstract
    (#_"double" DOLDD'''invokePrim [#_"DOLDD" this, #_"double" arg0, #_"Object" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DODOO
    #_abstract
    (#_"Object" DODOO'''invokePrim [#_"DODOO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DODOL
    #_abstract
    (#_"long" DODOL'''invokePrim [#_"DODOL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DODOD
    #_abstract
    (#_"double" DODOD'''invokePrim [#_"DODOD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DODLO
    #_abstract
    (#_"Object" DODLO'''invokePrim [#_"DODLO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DODLL
    #_abstract
    (#_"long" DODLL'''invokePrim [#_"DODLL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DODLD
    #_abstract
    (#_"double" DODLD'''invokePrim [#_"DODLD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DODDO
    #_abstract
    (#_"Object" DODDO'''invokePrim [#_"DODDO" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DODDL
    #_abstract
    (#_"long" DODDL'''invokePrim [#_"DODDL" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DODDD
    #_abstract
    (#_"double" DODDD'''invokePrim [#_"DODDD" this, #_"double" arg0, #_"Object" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DLOOO
    #_abstract
    (#_"Object" DLOOO'''invokePrim [#_"DLOOO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DLOOL
    #_abstract
    (#_"long" DLOOL'''invokePrim [#_"DLOOL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DLOOD
    #_abstract
    (#_"double" DLOOD'''invokePrim [#_"DLOOD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DLOLO
    #_abstract
    (#_"Object" DLOLO'''invokePrim [#_"DLOLO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DLOLL
    #_abstract
    (#_"long" DLOLL'''invokePrim [#_"DLOLL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DLOLD
    #_abstract
    (#_"double" DLOLD'''invokePrim [#_"DLOLD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DLODO
    #_abstract
    (#_"Object" DLODO'''invokePrim [#_"DLODO" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DLODL
    #_abstract
    (#_"long" DLODL'''invokePrim [#_"DLODL" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DLODD
    #_abstract
    (#_"double" DLODD'''invokePrim [#_"DLODD" this, #_"double" arg0, #_"long" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DLLOO
    #_abstract
    (#_"Object" DLLOO'''invokePrim [#_"DLLOO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DLLOL
    #_abstract
    (#_"long" DLLOL'''invokePrim [#_"DLLOL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DLLOD
    #_abstract
    (#_"double" DLLOD'''invokePrim [#_"DLLOD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DLLLO
    #_abstract
    (#_"Object" DLLLO'''invokePrim [#_"DLLLO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DLLLL
    #_abstract
    (#_"long" DLLLL'''invokePrim [#_"DLLLL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DLLLD
    #_abstract
    (#_"double" DLLLD'''invokePrim [#_"DLLLD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DLLDO
    #_abstract
    (#_"Object" DLLDO'''invokePrim [#_"DLLDO" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DLLDL
    #_abstract
    (#_"long" DLLDL'''invokePrim [#_"DLLDL" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DLLDD
    #_abstract
    (#_"double" DLLDD'''invokePrim [#_"DLLDD" this, #_"double" arg0, #_"long" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DLDOO
    #_abstract
    (#_"Object" DLDOO'''invokePrim [#_"DLDOO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DLDOL
    #_abstract
    (#_"long" DLDOL'''invokePrim [#_"DLDOL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DLDOD
    #_abstract
    (#_"double" DLDOD'''invokePrim [#_"DLDOD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DLDLO
    #_abstract
    (#_"Object" DLDLO'''invokePrim [#_"DLDLO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DLDLL
    #_abstract
    (#_"long" DLDLL'''invokePrim [#_"DLDLL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DLDLD
    #_abstract
    (#_"double" DLDLD'''invokePrim [#_"DLDLD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DLDDO
    #_abstract
    (#_"Object" DLDDO'''invokePrim [#_"DLDDO" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DLDDL
    #_abstract
    (#_"long" DLDDL'''invokePrim [#_"DLDDL" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DLDDD
    #_abstract
    (#_"double" DLDDD'''invokePrim [#_"DLDDD" this, #_"double" arg0, #_"long" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DDOOO
    #_abstract
    (#_"Object" DDOOO'''invokePrim [#_"DDOOO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DDOOL
    #_abstract
    (#_"long" DDOOL'''invokePrim [#_"DDOOL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DDOOD
    #_abstract
    (#_"double" DDOOD'''invokePrim [#_"DDOOD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"Object" arg3])
)

(defprotocol DDOLO
    #_abstract
    (#_"Object" DDOLO'''invokePrim [#_"DDOLO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DDOLL
    #_abstract
    (#_"long" DDOLL'''invokePrim [#_"DDOLL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DDOLD
    #_abstract
    (#_"double" DDOLD'''invokePrim [#_"DDOLD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"long" arg3])
)

(defprotocol DDODO
    #_abstract
    (#_"Object" DDODO'''invokePrim [#_"DDODO" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DDODL
    #_abstract
    (#_"long" DDODL'''invokePrim [#_"DDODL" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DDODD
    #_abstract
    (#_"double" DDODD'''invokePrim [#_"DDODD" this, #_"double" arg0, #_"double" arg1, #_"Object" arg2, #_"double" arg3])
)

(defprotocol DDLOO
    #_abstract
    (#_"Object" DDLOO'''invokePrim [#_"DDLOO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DDLOL
    #_abstract
    (#_"long" DDLOL'''invokePrim [#_"DDLOL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DDLOD
    #_abstract
    (#_"double" DDLOD'''invokePrim [#_"DDLOD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"Object" arg3])
)

(defprotocol DDLLO
    #_abstract
    (#_"Object" DDLLO'''invokePrim [#_"DDLLO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DDLLL
    #_abstract
    (#_"long" DDLLL'''invokePrim [#_"DDLLL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DDLLD
    #_abstract
    (#_"double" DDLLD'''invokePrim [#_"DDLLD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"long" arg3])
)

(defprotocol DDLDO
    #_abstract
    (#_"Object" DDLDO'''invokePrim [#_"DDLDO" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DDLDL
    #_abstract
    (#_"long" DDLDL'''invokePrim [#_"DDLDL" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DDLDD
    #_abstract
    (#_"double" DDLDD'''invokePrim [#_"DDLDD" this, #_"double" arg0, #_"double" arg1, #_"long" arg2, #_"double" arg3])
)

(defprotocol DDDOO
    #_abstract
    (#_"Object" DDDOO'''invokePrim [#_"DDDOO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DDDOL
    #_abstract
    (#_"long" DDDOL'''invokePrim [#_"DDDOL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DDDOD
    #_abstract
    (#_"double" DDDOD'''invokePrim [#_"DDDOD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"Object" arg3])
)

(defprotocol DDDLO
    #_abstract
    (#_"Object" DDDLO'''invokePrim [#_"DDDLO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DDDLL
    #_abstract
    (#_"long" DDDLL'''invokePrim [#_"DDDLL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DDDLD
    #_abstract
    (#_"double" DDDLD'''invokePrim [#_"DDDLD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"long" arg3])
)

(defprotocol DDDDO
    #_abstract
    (#_"Object" DDDDO'''invokePrim [#_"DDDDO" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DDDDL
    #_abstract
    (#_"long" DDDDL'''invokePrim [#_"DDDDL" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

(defprotocol DDDDD
    #_abstract
    (#_"double" DDDDD'''invokePrim [#_"DDDDD" this, #_"double" arg0, #_"double" arg1, #_"double" arg2, #_"double" arg3])
)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(defprotocol IFn #_(§ extends Callable, Runnable)
    #_abstract
    (#_"Object" IFn'''invoke-1 [#_"IFn" this])
    #_abstract
    (#_"Object" IFn'''invoke-2 [#_"IFn" this, #_"Object" arg1])
    #_abstract
    (#_"Object" IFn'''invoke-3 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2])
    #_abstract
    (#_"Object" IFn'''invoke-4 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3])
    #_abstract
    (#_"Object" IFn'''invoke-5 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4])
    #_abstract
    (#_"Object" IFn'''invoke-6 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5])
    #_abstract
    (#_"Object" IFn'''invoke-7 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6])
    #_abstract
    (#_"Object" IFn'''invoke-8 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7])
    #_abstract
    (#_"Object" IFn'''invoke-9 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8])

    #_abstract
    (#_"Object" IFn'''invoke-10 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9])

    #_abstract
    (#_"Object" IFn'''invoke-11 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10])

    #_abstract
    (#_"Object" IFn'''invoke-12 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11])

    #_abstract
    (#_"Object" IFn'''invoke-13 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12])

    #_abstract
    (#_"Object" IFn'''invoke-14 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13])

    #_abstract
    (#_"Object" IFn'''invoke-15 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14])

    #_abstract
    (#_"Object" IFn'''invoke-16 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15])

    #_abstract
    (#_"Object" IFn'''invoke-17 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16])

    #_abstract
    (#_"Object" IFn'''invoke-18 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17])

    #_abstract
    (#_"Object" IFn'''invoke-19 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18])

    #_abstract
  #_(#_"Object" IFn'''invoke-20 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19])

    #_abstract
  #_(#_"Object" IFn'''invoke-21 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20])

    #_abstract
  #_(#_"Object" IFn'''invoke-22 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" #_arg19, #_"Object" #_arg20 & #_"Object..." args])

    #_abstract
    (#_"Object" IFn'''applyTo [#_"IFn" this, #_"ISeq" args])
)
)

(java-ns cloiure.lang.IHashEq

(defprotocol IHashEq
    #_abstract
    (#_"int" IHashEq'''hasheq [#_"IHashEq" this])
)
)

(java-ns cloiure.lang.IKeywordLookup

(defprotocol IKeywordLookup
    #_abstract
    (#_"ILookupThunk" IKeywordLookup'''getLookupThunk [#_"IKeywordLookup" this, #_"Keyword" k])
)
)

(java-ns cloiure.lang.IKVReduce

(defprotocol IKVReduce
    #_abstract
    (#_"Object" IKVReduce'''kvreduce [#_"IKVReduce" this, #_"IFn" f, #_"Object" r])
)
)

(java-ns cloiure.lang.ILookup

(defprotocol ILookup
    #_abstract
    (#_"Object" ILookup'''valAt-2 [#_"ILookup" this, #_"Object" key])
    #_abstract
    (#_"Object" ILookup'''valAt-3 [#_"ILookup" this, #_"Object" key, #_"Object" notFound])
)
)

(java-ns cloiure.lang.ILookupSite

(defprotocol ILookupSite
    #_abstract
    (#_"ILookupThunk" ILookupSite'''fault [#_"ILookupSite" this, #_"Object" target])
)
)

(java-ns cloiure.lang.ILookupThunk

(defprotocol ILookupThunk
    #_abstract
    (#_"Object" ILookupThunk'''get [#_"ILookupThunk" this, #_"Object" target])
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(defprotocol IMapEntry #_(§ extends Map$Entry)
    #_abstract
    (#_"Object" IMapEntry'''key [#_"IMapEntry" this])
    #_abstract
    (#_"Object" IMapEntry'''val [#_"IMapEntry" this])
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(defprotocol IMapIterable
    #_abstract
    (#_"Iterator" IMapIterable'''keyIterator [#_"IMapIterable" this])
    #_abstract
    (#_"Iterator" IMapIterable'''valIterator [#_"IMapIterable" this])
)
)

(java-ns cloiure.lang.IMeta

(defprotocol IMeta
    #_abstract
    (#_"IPersistentMap" IMeta'''meta [#_"IMeta" this])
)
)

(java-ns cloiure.lang.Indexed

(defprotocol Indexed #_(§ extends Counted)
    #_abstract
    (#_"Object" Indexed'''nth-2 [#_"Indexed" this, #_"int" i])
    #_abstract
    (#_"Object" Indexed'''nth-3 [#_"Indexed" this, #_"int" i, #_"Object" notFound])
)
)

(java-ns cloiure.lang.IndexedSeq

(defprotocol IndexedSeq #_(§ extends ISeq, Sequential, Counted)
    #_abstract
    (#_"int" IndexedSeq'''index [#_"IndexedSeq" this])
)
)

(java-ns cloiure.lang.IObj

(defprotocol IObj #_(§ extends IMeta)
    #_abstract
    (#_"IObj" IObj'''withMeta [#_"IObj" this, #_"IPersistentMap" meta])
)
)

(java-ns cloiure.lang.IPending

(defprotocol IPending
    #_abstract
    (#_"boolean" IPending'''isRealized [#_"IPending" this])
)
)

(java-ns cloiure.lang.IPersistentCollection

(defprotocol IPersistentCollection #_(§ extends Seqable)
    #_abstract
  #_(#_"int" #_"IPersistentCollection'''" Counted'''count [#_"IPersistentCollection" this])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''cons [#_"IPersistentCollection" this, #_"Object" o])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''empty [#_"IPersistentCollection" this])
    #_abstract
    (#_"boolean" IPersistentCollection'''equiv [#_"IPersistentCollection" this, #_"Object" o])
)
)

(java-ns cloiure.lang.IPersistentList

(defprotocol IPersistentList #_(§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(defprotocol IPersistentMap #_(§ extends Iterable, Associative, Counted)
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''assoc [#_"IPersistentMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''assocEx [#_"IPersistentMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''without [#_"IPersistentMap" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IPersistentSet

(defprotocol IPersistentSet #_(§ extends IPersistentCollection, Counted)
    #_abstract
    (#_"IPersistentSet" IPersistentSet'''disjoin [#_"IPersistentSet" this, #_"Object" key])
    #_abstract
    (#_"boolean" IPersistentSet'''contains [#_"IPersistentSet" this, #_"Object" key])
    #_abstract
    (#_"Object" IPersistentSet'''get [#_"IPersistentSet" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IPersistentStack

(defprotocol IPersistentStack #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" IPersistentStack'''peek [#_"IPersistentStack" this])
    #_abstract
    (#_"IPersistentStack" IPersistentStack'''pop [#_"IPersistentStack" this])
)
)

(java-ns cloiure.lang.IPersistentVector

(defprotocol IPersistentVector #_(§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    #_abstract
    (#_"int" IPersistentVector'''length [#_"IPersistentVector" this])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''assocN [#_"IPersistentVector" this, #_"int" i, #_"Object" val])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''cons [#_"IPersistentVector" this, #_"Object" o])
)
)

(java-ns cloiure.lang.IProxy

(defprotocol IProxy
    #_abstract
    (#_"void" IProxy'''__initCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" m])
    #_abstract
    (#_"void" IProxy'''__updateCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" m])
    #_abstract
    (#_"IPersistentMap" IProxy'''__getCloiureFnMappings [#_"IProxy" this])
)
)

(java-ns cloiure.lang.IRecord

(defprotocol IRecord
)
)

(java-ns cloiure.lang.IReduce

(defprotocol IReduce #_(§ extends IReduceInit)
    #_abstract
    (#_"Object" IReduce'''reduce [#_"IReduce" this, #_"IFn" f])
)
)

(java-ns cloiure.lang.IReduceInit

(defprotocol IReduceInit
    #_abstract
    (#_"Object" IReduceInit'''reduce [#_"IReduceInit" this, #_"IFn" f, #_"Object" start])
)
)

(java-ns cloiure.lang.IRef

(defprotocol IRef #_(§ extends IDeref)
    #_abstract
    (#_"void" IRef'''setValidator [#_"IRef" this, #_"IFn" vf])
    #_abstract
    (#_"IFn" IRef'''getValidator [#_"IRef" this])
    #_abstract
    (#_"IPersistentMap" IRef'''getWatches [#_"IRef" this])
    #_abstract
    (#_"IRef" IRef'''addWatch [#_"IRef" this, #_"Object" key, #_"IFn" callback])
    #_abstract
    (#_"IRef" IRef'''removeWatch [#_"IRef" this, #_"Object" key])
)
)

(java-ns cloiure.lang.IReference

(defprotocol IReference #_(§ extends IMeta)
    #_abstract
    (#_"IPersistentMap" IReference'''alterMeta [#_"IReference" this, #_"IFn" alter, #_"ISeq" args])
    #_abstract
    (#_"IPersistentMap" IReference'''resetMeta [#_"IReference" this, #_"IPersistentMap" m])
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(defprotocol ISeq #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" ISeq'''first [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''next [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''more [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''cons [#_"ISeq" this, #_"Object" o])
)
)

(java-ns cloiure.lang.ITransientAssociative

(defprotocol ITransientAssociative #_(§ extends ITransientCollection, ILookup)
    #_abstract
    (#_"ITransientAssociative" ITransientAssociative'''assoc [#_"ITransientAssociative" this, #_"Object" key, #_"Object" val])
)
)

(java-ns cloiure.lang.ITransientAssociative2

(defprotocol ITransientAssociative2 #_(§ extends ITransientAssociative)
    #_abstract
    (#_"boolean" ITransientAssociative2'''containsKey [#_"ITransientAssociative2" this, #_"Object" key])
    #_abstract
    (#_"IMapEntry" ITransientAssociative2'''entryAt [#_"ITransientAssociative2" this, #_"Object" key])
)
)

(java-ns cloiure.lang.ITransientCollection

(defprotocol ITransientCollection
    #_abstract
    (#_"ITransientCollection" ITransientCollection'''conj [#_"ITransientCollection" this, #_"Object" val])
    #_abstract
    (#_"IPersistentCollection" ITransientCollection'''persistent [#_"ITransientCollection" this])
)
)

(java-ns cloiure.lang.ITransientMap

(defprotocol ITransientMap #_(§ extends ITransientAssociative, Counted)
    #_abstract
    (#_"ITransientMap" ITransientMap'''assoc [#_"ITransientMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (#_"ITransientMap" ITransientMap'''without [#_"ITransientMap" this, #_"Object" key])
    #_abstract
    (#_"IPersistentMap" ITransientMap'''persistent [#_"ITransientMap" this])
)
)

(java-ns cloiure.lang.ITransientSet

(defprotocol ITransientSet #_(§ extends ITransientCollection, Counted)
    #_abstract
    (#_"ITransientSet" ITransientSet'''disjoin [#_"ITransientSet" this, #_"Object" key])
    #_abstract
    (#_"boolean" ITransientSet'''contains [#_"ITransientSet" this, #_"Object" key])
    #_abstract
    (#_"Object" ITransientSet'''get [#_"ITransientSet" this, #_"Object" key])
)
)

(java-ns cloiure.lang.ITransientVector

(defprotocol ITransientVector #_(§ extends ITransientAssociative, Indexed)
    #_abstract
    (#_"ITransientVector" ITransientVector'''assocN [#_"ITransientVector" this, #_"int" i, #_"Object" val])
    #_abstract
    (#_"ITransientVector" ITransientVector'''pop [#_"ITransientVector" this])
)
)

(java-ns cloiure.lang.IType

(defprotocol IType
)
)

(java-ns cloiure.lang.LongRange

#_private
(defprotocol LongRangeBoundsCheck
    #_abstract
    (#_"boolean" LongRangeBoundsCheck'''exceededBounds [#_"LongRangeBoundsCheck" this, #_"long" val])
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(defprotocol MapEquivalence
)
)

(java-ns cloiure.lang.Named

(defprotocol Named
    #_abstract
    (#_"String" Named'''getNamespace [#_"Named" this])
    #_abstract
    (#_"String" Named'''getName [#_"Named" this])
)
)

(java-ns cloiure.lang.Numbers

(defprotocol Ops
    #_abstract
    (#_"Ops" Ops'''combine [#_"Ops" this, #_"Ops" y])
    #_abstract
    (#_"Ops" Ops'''opsWithLong [#_"Ops" this, #_"LongOps" x])
    #_abstract
    (#_"Ops" Ops'''opsWithDouble [#_"Ops" this, #_"DoubleOps" x])
    #_abstract
    (#_"Ops" Ops'''opsWithRatio [#_"Ops" this, #_"RatioOps" x])
    #_abstract
    (#_"Ops" Ops'''opsWithBigInt [#_"Ops" this, #_"BigIntOps" x])
    #_abstract
    (#_"Ops" Ops'''opsWithBigDecimal [#_"Ops" this, #_"BigDecimalOps" x])
    #_abstract
    (#_"boolean" Ops'''isZero [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"boolean" Ops'''isPos [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"boolean" Ops'''isNeg [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''add [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''addP [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''multiply [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''multiplyP [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''divide [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''quotient [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''remainder [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"boolean" Ops'''equiv [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"boolean" Ops'''lt [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"boolean" Ops'''lte [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"boolean" Ops'''gte [#_"Ops" this, #_"Number" x, #_"Number" y])
    #_abstract
    (#_"Number" Ops'''negate [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''negateP [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''inc [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''incP [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''dec [#_"Ops" this, #_"Number" x])
    #_abstract
    (#_"Number" Ops'''decP [#_"Ops" this, #_"Number" x])
)
)

(java-ns cloiure.lang.PersistentHashMap

(defprotocol INode
    #_abstract
    (#_"INode" INode'''assoc-6 [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf])
    #_abstract
    (#_"INode" INode'''without-4 [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key])
    #_abstract
    (#_"IMapEntry" INode'''find-4 [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key])
    #_abstract
    (#_"Object" INode'''find-5 [#_"INode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound])
    #_abstract
    (#_"ISeq" INode'''nodeSeq [#_"INode" this])
    #_abstract
    (#_"INode" INode'''assoc-7 [#_"INode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf])
    #_abstract
    (#_"INode" INode'''without-6 [#_"INode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf])
    #_abstract
    (#_"Object" INode'''kvreduce [#_"INode" this, #_"IFn" f, #_"Object" r])
    #_abstract
    (#_"Object" INode'''fold [#_"INode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin])
    ;; returns the result of (f [k v]) for each iterated element
    #_abstract
    (#_"Iterator" INode'''iterator [#_"INode" this, #_"IFn" f])
)
)

(java-ns cloiure.lang.Range

#_private
(defprotocol RangeBoundsCheck
    #_abstract
    (#_"boolean" RangeBoundsCheck'''exceededBounds [#_"RangeBoundsCheck" this, #_"Object" val])
)
)

(java-ns cloiure.lang.Reversible

(defprotocol Reversible
    #_abstract
    (#_"ISeq" Reversible'''rseq [#_"Reversible" this])
)
)

(java-ns cloiure.lang.Seqable

(defprotocol Seqable
    #_abstract
    (#_"ISeq" Seqable'''seq [#_"Seqable" this])
)
)

(java-ns cloiure.lang.Sequential

(defprotocol Sequential
)
)

(java-ns cloiure.lang.Settable

(defprotocol Settable
    #_abstract
    (#_"Object" Settable'''doSet [#_"Settable" this, #_"Object" val])
    #_abstract
    (#_"Object" Settable'''doReset [#_"Settable" this, #_"Object" val])
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(defprotocol Sorted
    #_abstract
    (#_"Comparator" Sorted'''comparator [#_"Sorted" this])
    #_abstract
    (#_"Object" Sorted'''entryKey [#_"Sorted" this, #_"Object" entry])
    #_abstract
    (#_"ISeq" Sorted'''seq [#_"Sorted" this, #_"boolean" ascending])
    #_abstract
    (#_"ISeq" Sorted'''seqFrom [#_"Sorted" this, #_"Object" key, #_"boolean" ascending])
)
)

(java-ns cloiure.lang.TransformerIterator

#_private
(defprotocol Buffer
    #_abstract
    (#_"Buffer" Buffer'''add [#_"Buffer" this, #_"Object" o])
    #_abstract
    (#_"Object" Buffer'''remove [#_"Buffer" this])
    #_abstract
    (#_"boolean" Buffer'''isEmpty [#_"Buffer" this])
)
)

(java-ns cloiure.lang.Util

(defprotocol EquivPred
    #_abstract
    (#_"boolean" EquivPred'''equiv [#_"EquivPred" this, #_"Object" k1, #_"Object" k2])
)
)

(java-ns cloiure.lang.AFn

#_stateless
#_abstract
(class-ns AFn (§ implements IFn)
    #_protected
    (defn #_"AFn" AFn'new []
        (hash-map)
    )

    #_foreign
    (§ defn #_"Object" call [#_"AFn" this]
        (IFn'''invoke-1 this)
    )

    #_foreign
    (§ defn #_"void" run [#_"AFn" this]
        (IFn'''invoke-1 this)
        nil
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--AFn [#_"AFn" this]
        (AFn'''throwArity this, 0)
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--AFn [#_"AFn" this, #_"Object" arg1]
        (AFn'''throwArity this, 1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2]
        (AFn'''throwArity this, 2)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (AFn'''throwArity this, 3)
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (AFn'''throwArity this, 4)
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (AFn'''throwArity this, 5)
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (AFn'''throwArity this, 6)
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (AFn'''throwArity this, 7)
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (AFn'''throwArity this, 8)
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (AFn'''throwArity this, 9)
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (AFn'''throwArity this, 10)
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (AFn'''throwArity this, 11)
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (AFn'''throwArity this, 12)
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (AFn'''throwArity this, 13)
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (AFn'''throwArity this, 14)
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (AFn'''throwArity this, 15)
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (AFn'''throwArity this, 16)
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (AFn'''throwArity this, 17)
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (AFn'''throwArity this, 18)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (AFn'''throwArity this, 19)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (AFn'''throwArity this, 20)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--AFn [#_"AFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (AFn'''throwArity this, 21)
    )

    #_override
    (defn #_"Object" IFn'''applyTo--AFn [#_"AFn" this, #_"ISeq" args]
        (AFn'applyToHelper this, (Util'ret1 args, (§ ass args nil)))
    )

    (defn #_"Object" AFn'applyToHelper [#_"IFn" ifn, #_"ISeq" args]
        (case (RT'boundedLength args, 20)
            0
            (do
                (§ ass args nil)
                (IFn'''invoke-1 ifn)
            )
            1
            (do
                (IFn'''invoke-2 ifn, (Util'ret1 (.first args), (§ ass args nil)))
            )
            2
            (do
                (IFn'''invoke-3 ifn, (.first args),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            3
            (do
                (IFn'''invoke-4 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            4
            (do
                (IFn'''invoke-5 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            5
            (do
                (IFn'''invoke-6 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            6
            (do
                (IFn'''invoke-7 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            7
            (do
                (IFn'''invoke-8 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            8
            (do
                (IFn'''invoke-9 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            9
            (do
                (IFn'''invoke-10 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            10
            (do
                (IFn'''invoke-11 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            11
            (do
                (IFn'''invoke-12 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            12
            (do
                (IFn'''invoke-13 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            13
            (do
                (IFn'''invoke-14 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            14
            (do
                (IFn'''invoke-15 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            15
            (do
                (IFn'''invoke-16 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            16
            (do
                (IFn'''invoke-17 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            17
            (do
                (IFn'''invoke-18 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            18
            (do
                (IFn'''invoke-19 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            19
            (do
              #_(IFn'''invoke-20 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            20
            (do
              #_(IFn'''invoke-21 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (Util'ret1 (.first (§ ass args (.next args))), (§ ass args nil)))
            )
            #_else
            (do
              #_(IFn'''invoke-22 ifn, (.first args),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (.first (§ ass args (.next args))),
                        (RT'seqToArray (Util'ret1 (.next args), (§ ass args nil))))
            )
        )
    )

    #_abstract
    (defn #_"Object" AFn'''throwArity [#_"AFn" this, #_"int" n]
        (let [#_"String" name (.getSimpleName (.getClass this))]
            (throw (ArityException'new-2 n, (Compiler'demunge name)))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    (defn- #_"AFunction" AFunction'init []
        (hash-map
            #_volatile
            #_"MethodImplCache" :__methodImplCache nil
        )
    )

    #_protected
    (defn #_"AFunction" AFunction'new []
        (merge (AFn'new) (AFunction'init))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--AFunction [#_"AFunction" this]
        nil
    )

    #_override
    (defn #_"IObj" IObj'''withMeta--AFunction [#_"AFunction" this, #_"IPersistentMap" meta]
        (§ reify RestFn()
            #_protected
            #_override
            (defn #_"Object" RestFn'''doInvoke-2--RestFn [#_"RestFn" this, #_"Object" args]
                (IFn'''applyTo (§ this AFunction), (cast' ISeq args))
            )

            #_override
            (defn #_"IPersistentMap" IMeta'''meta--RestFn [#_"RestFn" this]
                meta
            )

            #_override
            (defn #_"IObj" IObj'''withMeta--RestFn [#_"RestFn" this, #_"IPersistentMap" meta]
                (IObj'''withMeta (§ this AFunction), meta)
            )

            #_override
            (defn #_"int" RestFn'''getRequiredArity--RestFn [#_"RestFn" this]
                0
            )
        )
    )

    #_foreign
    (§ defn #_"int" compare [#_"AFunction" this, #_"Object" o1, #_"Object" o2]
        (let [#_"Object" o (IFn'''invoke-3 this, o1, o2)]
            (if (instance? Boolean o)
                (cond (RT'booleanCast-1o o) -1 (RT'booleanCast-1o (IFn'''invoke-3 this, o2, o1)) 1 :else 0)
                (.intValue (cast Number o))
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns ActionQueue
    (§ def #_"ActionQueue" ActionQueue'EMPTY (ActionQueue'new PersistentQueue'EMPTY, nil))

    (defn- #_"ActionQueue" ActionQueue'init []
        (hash-map
            #_"IPersistentStack" :q nil
            #_"Throwable" :error nil ;; non-null indicates fail state
        )
    )

    (defn #_"ActionQueue" ActionQueue'new [#_"IPersistentStack" q, #_"Throwable" error]
        (let [this (ActionQueue'init)]
            (§ ass this (assoc this :q q))
            (§ ass this (assoc this :error error))
            this
        )
    )
)

(class-ns AgentAction (§ implements Runnable)
    (defn- #_"AgentAction" AgentAction'init []
        (hash-map
            #_"Agent" :agent nil
            #_"IFn" :fn nil
            #_"ISeq" :args nil
            #_"Executor" :exec nil
        )
    )

    (defn #_"AgentAction" AgentAction'new [#_"Agent" agent, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
        (let [this (AgentAction'init)]
            (§ ass this (assoc this :agent agent))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :fn fn))
            (§ ass this (assoc this :exec exec))
            this
        )
    )

    #_method
    (defn #_"void" AgentAction''execute [#_"AgentAction" this]
        (try
            (.execute (:exec this), this)
            (catch Throwable error
                (when (some? (:errorHandler (:agent this)))
                    (try
                        (IFn'''invoke-3 (:errorHandler (:agent this)), (:agent this), error)
                        (catch Throwable e
                            ;; ignore errorHandler errors
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" AgentAction'doRun [#_"AgentAction" action]
        (try
            (.set Agent'nested, PersistentVector'EMPTY)
            (let [#_"Throwable" error
                    (try
                        (let [#_"Object" oldval (:state (:agent action))
                              #_"Object" newval (IFn'''applyTo (:fn action), (RT'cons (:state (:agent action)), (:args action)))]
                            (Agent''setState (:agent action), newval)
                            (ARef''notifyWatches (:agent action), oldval, newval)
                            nil
                        )
                        (catch Throwable e
                            e
                        )
                    )]
                (when (some? error) => (Agent'releasePendingSends)
                    (.set Agent'nested, nil) ;; allow errorHandler to send
                    (when (some? (:errorHandler (:agent action)))
                        (try
                            (IFn'''invoke-3 (:errorHandler (:agent action)), (:agent action), error)
                            (catch Throwable e
                                ;; ignore errorHandler errors
                            )
                        )
                    )
                    (when (= (:errorMode (:agent action)) Agent'CONTINUE)
                        (§ ass error nil)
                    )
                )
                (let [#_"ActionQueue" next
                        (loop-when [next nil #_"boolean" popped false] (not popped) => next
                            (let [#_"ActionQueue" prior (.get (:aq (:agent action))) next (ActionQueue'new (IPersistentStack'''pop (:q prior)), error)]
                                (recur next (.compareAndSet (:aq (:agent action)), prior, next))
                            )
                        )]
                    (when (and (nil? error) (pos? (.count (:q next))))
                        (AgentAction''execute (cast' AgentAction (IPersistentStack'''peek (:q next))))
                    )
                )
            )
            (finally
                (.set Agent'nested, nil)
            )
        )
        nil
    )

    #_foreign
    (§ defn #_"void" run [#_"AgentAction" this]
        (AgentAction'doRun this)
        nil
    )
)

(class-ns Agent (§ extends ARef)
    (§ def #_"Keyword" Agent'CONTINUE (Keyword'intern (Symbol'intern nil, "continue")))
    (§ def #_"Keyword" Agent'FAIL (Keyword'intern (Symbol'intern nil, "fail")))

    (def- #_"AtomicLong" Agent'sendThreadPoolCounter (AtomicLong. 0))
    (def- #_"AtomicLong" Agent'sendOffThreadPoolCounter (AtomicLong. 0))

    (defn- #_"ThreadFactory" Agent'createThreadFactory [#_"String" format, #_"AtomicLong" threadPoolCounter]
        (§ reify ThreadFactory()
            #_foreign
            (§ defn #_"Thread" newThread [#_"ThreadFactory" this, #_"Runnable" runnable]
                (let [#_"Thread" thread (Thread. runnable)]
                    (.setName thread, (String/format format, (object-array [ (.getAndIncrement threadPoolCounter) ])))
                    thread
                )
            )
        )
    )

    #_volatile
    (§ def #_"ExecutorService" Agent'pooledExecutor (Executors/newFixedThreadPool (+ 2 (.availableProcessors (Runtime/getRuntime))), (Agent'createThreadFactory "cloiure-agent-send-pool-%d", Agent'sendThreadPoolCounter)))

    #_volatile
    (§ def #_"ExecutorService" Agent'soloExecutor (Executors/newCachedThreadPool (Agent'createThreadFactory "cloiure-agent-send-off-pool-%d", Agent'sendOffThreadPoolCounter)))

    (def #_"ThreadLocal<IPersistentVector>" Agent'nested (ThreadLocal.))

    (defn #_"void" Agent'shutdown []
        (.shutdown Agent'soloExecutor)
        (.shutdown Agent'pooledExecutor)
        nil
    )

    (defn- #_"Agent" Agent'init []
        (hash-map
            #_volatile
            #_"Object" :state nil
            #_"AtomicReference<ActionQueue>" :aq (AtomicReference. ActionQueue'EMPTY)

            #_volatile
            #_"Keyword" :errorMode Agent'CONTINUE
            #_volatile
            #_"IFn" :errorHandler nil
        )
    )

    (defn #_"Agent" Agent'new-1 [#_"Object" state]
        (Agent'new-2 state, nil)
    )

    (defn #_"Agent" Agent'new-2 [#_"Object" state, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Agent'init))]
            (Agent''setState this, state)
            this
        )
    )

    #_method
    (defn #_"boolean" Agent''setState [#_"Agent" this, #_"Object" newState]
        (ARef''validate this, newState)
        (let [#_"boolean" ret (not= (:state this) newState)]
            (§ ass this (assoc this :state newState))
            ret
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Agent [#_"Agent" this]
        (:state this)
    )

    #_method
    (defn #_"Throwable" Agent''getError [#_"Agent" this]
        (:error (.get (:aq this)))
    )

    #_method
    (defn #_"void" Agent''setErrorMode [#_"Agent" this, #_"Keyword" k]
        (§ ass this (assoc this :errorMode k))
        nil
    )

    #_method
    (defn #_"Keyword" Agent''getErrorMode [#_"Agent" this]
        (:errorMode this)
    )

    #_method
    (defn #_"void" Agent''setErrorHandler [#_"Agent" this, #_"IFn" f]
        (§ ass this (assoc this :errorHandler f))
        nil
    )

    #_method
    (defn #_"IFn" Agent''getErrorHandler [#_"Agent" this]
        (:errorHandler this)
    )

    #_method
    (defn #_"Object" Agent''restart [#_"Agent" this, #_"Object" newState, #_"boolean" clearActions]
        (§ sync this
            (when (some? (Agent''getError this)) => (throw (RuntimeException. "Agent does not need a restart"))
                (ARef''validate this, newState)
                (§ ass this (assoc this :state newState))
                (when-not clearActions => (.set (:aq this), ActionQueue'EMPTY)
                    (let [#_"ActionQueue" prior
                            (loop-when [prior nil #_"boolean" restarted false] (not restarted) => prior
                                (let [prior (.get (:aq this))]
                                    (recur prior (.compareAndSet (:aq this), prior, (ActionQueue'new (:q prior), nil)))
                                )
                            )]
                        (when (pos? (.count (:q prior)))
                            (AgentAction''execute (cast' AgentAction (IPersistentStack'''peek (:q prior))))
                        )
                    )
                )
                newState
            )
        )
    )

    #_method
    (defn #_"Object" Agent''dispatch [#_"Agent" this, #_"IFn" fn, #_"ISeq" args, #_"Executor" exec]
        (let-when [#_"Throwable" e (Agent''getError this)] (nil? e) => (throw (RuntimeException. "Agent is failed, needs restart", e))
            (let [#_"AgentAction" action (AgentAction'new this, fn, args, exec)]
                (Agent'dispatchAction action)
                this
            )
        )
    )

    (defn #_"void" Agent'dispatchAction [#_"AgentAction" action]
        (let [#_"LockingTransaction" trans (LockingTransaction'getRunning)]
            (cond
                (some? trans)               (LockingTransaction''enqueue trans, action)
                (some? (.get Agent'nested)) (.set Agent'nested, (IPersistentVector'''cons (.get Agent'nested), action))
                :else                       (Agent''enqueue (:agent action), action)
            )
        )
        nil
    )

    #_method
    (defn #_"void" Agent''enqueue [#_"Agent" this, #_"AgentAction" action]
        (let [#_"ActionQueue" prior
                (loop-when [prior nil #_"boolean" queued false] (not queued) => prior
                    (let [prior (.get (:aq this))]
                        (recur prior (.compareAndSet (:aq this), prior, (ActionQueue'new (cast' IPersistentStack (IPersistentCollection'''cons (:q prior), action)), (:error prior))))
                    )
                )]
            (when (and (zero? (.count (:q prior))) (nil? (:error prior)))
                (AgentAction''execute action)
            )
        )
        nil
    )

    #_method
    (defn #_"int" Agent''getQueueCount [#_"Agent" this]
        (.count (:q (.get (:aq this))))
    )

    (defn #_"int" Agent'releasePendingSends []
        (let-when [#_"IPersistentVector" sends (.get Agent'nested)] (some? sends) => 0
            (dotimes [#_"int" i (.count sends)]
                (let [#_"AgentAction" a (cast' AgentAction (ILookup'''valAt-2 sends, i))]
                    (Agent''enqueue (:agent a), a)
                )
            )
            (.set Agent'nested, PersistentVector'EMPTY)
            (.count sends)
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_stateless
#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_protected
    (defn #_"AMapEntry" AMapEntry'new []
        (APersistentVector'new)
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--AMapEntry [#_"AMapEntry" this, #_"int" i]
        (case i 0 (IMapEntry'''key this) 1 (IMapEntry'''val this) (throw (IndexOutOfBoundsException.)))
    )

    #_method
    (defn- #_"IPersistentVector" AMapEntry''asVector [#_"AMapEntry" this]
        (LazilyPersistentVector'createOwning (IMapEntry'''key this), (IMapEntry'''val this))
    )

    #_override
    (defn #_"IPersistentVector" IPersistentVector'''assocN--AMapEntry [#_"AMapEntry" this, #_"int" i, #_"Object" val]
        (IPersistentVector'''assocN (AMapEntry''asVector this), i, val)
    )

    #_override
    (defn #_"int" Counted'''count--AMapEntry [#_"AMapEntry" this]
        2
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--AMapEntry [#_"AMapEntry" this]
        (Seqable'''seq (AMapEntry''asVector this))
    )

    #_override
    (defn #_"IPersistentVector" IPersistentVector'''cons--AMapEntry [#_"AMapEntry" this, #_"Object" o]
        (IPersistentVector'''cons (AMapEntry''asVector this), o)
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--AMapEntry [#_"AMapEntry" this]
        nil
    )

    #_override
    (defn #_"IPersistentStack" IPersistentStack'''pop--AMapEntry [#_"AMapEntry" this]
        (LazilyPersistentVector'createOwning (IMapEntry'''key this))
    )

    #_method
    (defn #_"Object" AMapEntry''setValue [#_"AMapEntry" this, #_"Object" value]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

(class-ns KeySeq (§ extends ASeq)
    (defn #_"KeySeq" KeySeq'create [#_"ISeq" seq]
        (when (some? seq)
            (KeySeq'new-2 seq, nil)
        )
    )

    (defn #_"KeySeq" KeySeq'createFromMap [#_"IPersistentMap" map]
        (when (some? map)
            (let [#_"ISeq" seq (Seqable'''seq map)]
                (when (some? seq)
                    (KeySeq'new-2 seq, map)
                )
            )
        )
    )

    (defn- #_"KeySeq" KeySeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"KeySeq" KeySeq'new-2 [#_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new-0) (KeySeq'init))]
            (§ ass this (assoc this :seq seq))
            (§ ass this (assoc this :iterable iterable))
            this
        )
    )

    (defn- #_"KeySeq" KeySeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new-1 meta) (KeySeq'init))]
            (§ ass this (assoc this :seq seq))
            (§ ass this (assoc this :iterable iterable))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--KeySeq [#_"KeySeq" this]
        (.getKey (cast Map$Entry (.first (:seq this))))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--KeySeq [#_"KeySeq" this]
        (KeySeq'create this, (.next (:seq this)))
    )

    #_override
    (defn #_"KeySeq" IObj'''withMeta--KeySeq [#_"KeySeq" this, #_"IPersistentMap" meta]
        (KeySeq'new-3 meta, (:seq this), (:iterable this))
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"KeySeq" this]
        (cond
            (nil? (:iterable this))
                (.iterator (§ super ))
            (§ instance? IMapIterable (:iterable this))
                (IMapIterable'''keyIterator (cast' IMapIterable (:iterable this)))
            :else
                (let [#_"Iterator" mapIter (.iterator (:iterable this))]
                    (§ reify Iterator()
                        #_foreign
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (.hasNext mapIter)
                        )

                        #_foreign
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (.getKey (cast Map$Entry (.next mapIter)))
                        )

                        #_foreign
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
        )
    )
)

(class-ns ValSeq (§ extends ASeq)
    (defn #_"ValSeq" ValSeq'create [#_"ISeq" seq]
        (when (some? seq)
            (ValSeq'new-2 seq, nil)
        )
    )

    (defn #_"ValSeq" ValSeq'createFromMap [#_"IPersistentMap" map]
        (when (some? map)
            (let [#_"ISeq" seq (Seqable'''seq map)]
                (when (some? seq)
                    (ValSeq'new-2 seq, map)
                )
            )
        )
    )

    (defn- #_"ValSeq" ValSeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"ValSeq" ValSeq'new-2 [#_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new-0) (ValSeq'init))]
            (§ ass this (assoc this :seq seq))
            (§ ass this (assoc this :iterable iterable))
            this
        )
    )

    (defn- #_"ValSeq" ValSeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" seq, #_"Iterable" iterable]
        (let [this (merge (ASeq'new-1 meta) (ValSeq'init))]
            (§ ass this (assoc this :seq seq))
            (§ ass this (assoc this :iterable iterable))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ValSeq [#_"ValSeq" this]
        (.getValue (cast Map$Entry (.first (:seq this))))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ValSeq [#_"ValSeq" this]
        (ValSeq'create this, (.next (:seq this)))
    )

    #_override
    (defn #_"ValSeq" IObj'''withMeta--ValSeq [#_"ValSeq" this, #_"IPersistentMap" meta]
        (ValSeq'new-3 meta, (:seq this), (:iterable this))
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"ValSeq" this]
        (cond
            (nil? (:iterable this))
                (.iterator (§ super ))
            (§ instance? IMapIterable (:iterable this))
                (IMapIterable'''valIterator (cast' IMapIterable (:iterable this)))
            :else
                (let [#_"Iterator" mapIter (.iterator (:iterable this))]
                    (§ reify Iterator()
                        #_foreign
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (.hasNext mapIter)
                        )

                        #_foreign
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (.getValue (cast Map$Entry (.next mapIter)))
                        )

                        #_foreign
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
        )
    )
)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (defn- #_"APersistentMap" APersistentMap'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentMap" APersistentMap'new []
        (merge (AFn'new) (APersistentMap'init))
    )

    #_foreign
    (§ defn #_"String" toString [#_"APersistentMap" this]
        (RT'printString this)
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''cons--APersistentMap [#_"APersistentMap" this, #_"Object" o]
        (cond
            (instance? Map$Entry o)
                (let [#_"Map$Entry" e (cast Map$Entry o)]
                    (IPersistentMap'''assoc this, (.getKey e), (.getValue e))
                )
            (§ instance? IPersistentVector o)
                (let [#_"IPersistentVector" v (cast' IPersistentVector o)]
                    (when (= (.count v) 2) => (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                        (IPersistentMap'''assoc this, (Indexed'''nth-2 v, 0), (Indexed'''nth-2 v, 1))
                    )
                )
            :else
                (loop-when [#_"IPersistentMap" m this #_"ISeq" s (RT'seq o)] (some? s) => m
                    (let [#_"Map$Entry" e (cast Map$Entry (.first s))]
                        (recur (IPersistentMap'''assoc m, (.getKey e), (.getValue e)) (.next s))
                    )
                )
        )
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"APersistentMap" this, #_"Object" obj]
        (APersistentMap'mapEquals this, obj)
    )

    (defn #_"boolean" APersistentMap'mapEquals [#_"IPersistentMap" m1, #_"Object" obj]
        (cond
            (= m1 obj)
                true
            (not (instance? Map obj))
                false
            :else
                (let-when [#_"Map" m (cast Map obj)] (= (.size m) (.count m1)) => false
                    (loop-when [#_"ISeq" s (Seqable'''seq m1)] (some? s) => true
                        (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e)]
                            (and (.containsKey m, k) (Util'equals (.getValue e), (.get m, k))
                                (recur (.next s))
                            )
                        )
                    )
                )
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--APersistentMap [#_"APersistentMap" this, #_"Object" obj]
        (cond
            (not (instance? Map obj))
                false
            (and (§ instance? IPersistentMap obj) (not (§ instance? MapEquivalence obj)))
                false
            :else
                (let-when [#_"Map" m (cast Map obj)] (= (.size m) (.size this)) => false
                    (loop-when [#_"ISeq" s (Seqable'''seq this)] (some? s) => true
                        (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e)]
                            (and (.containsKey m, k) (Util'equiv-2oo (.getValue e), (.get m, k))
                                (recur (.next s))
                            )
                        )
                    )
                )
        )
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"APersistentMap" this]
        (let [#_"int" cached (:_hash this)]
            (when (zero? cached)
                (§ ass this (assoc this :_hash (§ ass cached (APersistentMap'mapHash this))))
            )
            cached
        )
    )

    (defn #_"int" APersistentMap'mapHash [#_"IPersistentMap" m]
        (loop-when [#_"int" hash 0 #_"ISeq" s (Seqable'''seq m)] (some? s) => hash
            (let [#_"Map$Entry" e (cast Map$Entry (.first s)) #_"Object" k (.getKey e) #_"Object" v (.getValue e)]
                (recur (+ hash (bit-xor (if (some? k) (.hashCode k) 0) (if (some? v) (.hashCode v) 0))) (.next s))
            )
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--APersistentMap [#_"APersistentMap" this]
        (let [#_"int" cached (:_hasheq this)]
            (when (zero? cached)
                (§ ass this (assoc this :_hasheq (§ ass cached (Murmur3'hashUnordered this))))
            )
            cached
        )
    )

    (defn #_"int" APersistentMap'mapHasheq [#_"IPersistentMap" m]
        (Murmur3'hashUnordered m)
    )

    (def #_"IFn" APersistentMap'MAKE_ENTRY
        (§ reify AFn()
            #_override
            (defn #_"Object" IFn'''invoke-3--AFn [#_"AFn" this, #_"Object" key, #_"Object" val]
                (MapEntry'create key, val)
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_KEY
        (§ reify AFn()
            #_override
            (defn #_"Object" IFn'''invoke-3--AFn [#_"AFn" this, #_"Object" key, #_"Object" val]
                key
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_VAL
        (§ reify AFn()
            #_override
            (defn #_"Object" IFn'''invoke-3--AFn [#_"AFn" this, #_"Object" key, #_"Object" val]
                val
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--APersistentMap [#_"APersistentMap" this, #_"Object" arg1]
        (ILookup'''valAt-2 this, arg1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--APersistentMap [#_"APersistentMap" this, #_"Object" arg1, #_"Object" notFound]
        (ILookup'''valAt-3 this, arg1, notFound)
    )

    #_foreign
    (§ defn #_"void" clear [#_"APersistentMap" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (defn #_"boolean" APersistentMap''containsValue [#_"APersistentMap" this, #_"Object" value]
        (.contains (APersistentMap''values this), value)
    )

    #_foreign
    (§ defn #_"Set" entrySet [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_foreign
            (§ defn #_"Iterator" iterator [#_"AbstractSet" this]
                (.iterator (§ this APersistentMap))
            )

            #_foreign
            (§ defn #_"int" size [#_"AbstractSet" this]
                (.count this)
            )

            #_foreign
            (§ defn #_"int" hashCode [#_"AbstractSet" this]
                (.hashCode (§ this APersistentMap))
            )

            #_foreign
            (§ defn #_"boolean" contains [#_"AbstractSet" this, #_"Object" o]
                (and (instance? Map$Entry o)
                    (let [#_"Map$Entry" e (cast Map$Entry o) #_"Map$Entry" found (.entryAt this, (.getKey e))]
                        (and (some? found) (Util'equals (.getValue found), (.getValue e)))
                    )
                )
            )
        )
    )

    #_foreign
    (§ defn #_"Object" get [#_"APersistentMap" this, #_"Object" key]
        (ILookup'''valAt-2 this, key)
    )

    #_foreign
    (§ defn #_"boolean" isEmpty [#_"APersistentMap" this]
        (zero? (.count this))
    )

    #_method
    (defn #_"Set" APersistentMap''keySet [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_foreign
            (§ defn #_"Iterator" iterator [#_"AbstractSet" this]
                (let [#_"Iterator" mi (.iterator (§ this APersistentMap))]
                    (§ reify Iterator()
                        #_foreign
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (.hasNext mi)
                        )

                        #_foreign
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [#_"Map$Entry" e (cast Map$Entry (.next mi))]
                                (.getKey e)
                            )
                        )

                        #_foreign
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_foreign
            (§ defn #_"int" size [#_"AbstractSet" this]
                (.count this)
            )

            #_foreign
            (§ defn #_"boolean" contains [#_"AbstractSet" this, #_"Object" o]
                (Associative'''containsKey (§ this APersistentMap), o)
            )
        )
    )

    #_foreign
    (§ defn #_"Object" put [#_"APersistentMap" this, #_"Object" key, #_"Object" value]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"void" putAll [#_"APersistentMap" this, #_"Map" t]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" remove [#_"APersistentMap" this, #_"Object" key]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"int" size [#_"APersistentMap" this]
        (.count this)
    )

    #_method
    (defn #_"Collection" APersistentMap''values [#_"APersistentMap" this]
        (§ reify AbstractCollection()
            #_foreign
            (§ defn #_"Iterator" iterator [#_"AbstractCollection" this]
                (let [#_"Iterator" mi (.iterator (§ this APersistentMap))]
                    (§ reify Iterator()
                        #_foreign
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (.hasNext mi)
                        )

                        #_foreign
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [#_"Map$Entry" e (cast Map$Entry (.next mi))]
                                (.getValue e)
                            )
                        )

                        #_foreign
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_foreign
            (§ defn #_"int" size [#_"AbstractCollection" this]
                (.count this)
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (defn- #_"APersistentSet" APersistentSet'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
            #_"IPersistentMap" :impl nil
        )
    )

    #_protected
    (defn #_"APersistentSet" APersistentSet'new [#_"IPersistentMap" impl]
        (let [this (merge (AFn'new) (APersistentSet'init))]
            (§ ass this (assoc this :impl impl))
            this
        )
    )

    #_foreign
    (§ defn #_"String" toString [#_"APersistentSet" this]
        (RT'printString this)
    )

    #_override
    (defn #_"boolean" IPersistentSet'''contains--APersistentSet [#_"APersistentSet" this, #_"Object" key]
        (Associative'''containsKey (:impl this), key)
    )

    #_override
    (defn #_"Object" IPersistentSet'''get--APersistentSet [#_"APersistentSet" this, #_"Object" key]
        (ILookup'''valAt-2 (:impl this), key)
    )

    #_override
    (defn #_"int" Counted'''count--APersistentSet [#_"APersistentSet" this]
        (.count (:impl this))
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--APersistentSet [#_"APersistentSet" this]
        (RT'keys (:impl this))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--APersistentSet [#_"APersistentSet" this, #_"Object" arg1]
        (IPersistentSet'''get this, arg1)
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"APersistentSet" this, #_"Object" obj]
        (APersistentSet'setEquals this, obj)
    )

    (defn #_"boolean" APersistentSet'setEquals [#_"IPersistentSet" s1, #_"Object" obj]
        (or (= s1 obj)
            (and (instance? Set obj)
                (let-when [#_"Set" m (cast Set obj)] (= (.size m) (.count s1)) => false
                    (loop-when [#_"Iterator" it (.iterator m)] (.hasNext it) => true
                        (and (IPersistentSet'''contains s1, (.next it)) (recur it))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--APersistentSet [#_"APersistentSet" this, #_"Object" obj]
        (and (instance? Set obj)
            (let-when [#_"Set" m (cast Set obj)] (= (.size m) (.size this)) => false
                (loop-when [#_"Iterator" it (.iterator m)] (.hasNext it) => true
                    (and (IPersistentSet'''contains this, (.next it)) (recur it))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"APersistentSet" this]
        (let [#_"int" hash (:_hash this)]
            (when (zero? hash)
                (loop-when-recur [#_"ISeq" s (Seqable'''seq this)] (some? s) [(.next s)]
                    (let [#_"Object" e (.first s)]
                        (§ ass hash (+ hash (Util'hash e)))
                    )
                )
                (§ ass this (assoc this :_hash hash))
            )
            hash
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--APersistentSet [#_"APersistentSet" this]
        (let [#_"int" cached (:_hasheq this)]
            (when (zero? cached)
                (§ ass this (assoc this :_hasheq (§ ass cached (Murmur3'hashUnordered this))))
            )
            cached
        )
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"APersistentSet" this]
        (RT'seqToArray (Seqable'''seq this))
    )

    #_foreign
    (§ defn #_"boolean" add [#_"APersistentSet" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" remove [#_"APersistentSet" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"void" clear [#_"APersistentSet" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" retainAll [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" removeAll [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" containsAll [#_"APersistentSet" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"APersistentSet" this, #_"Object[]" a]
        (RT'seqToPassedArray (Seqable'''seq this), a)
    )

    #_foreign
    (§ defn #_"int" size [#_"APersistentSet" this]
        (.count this)
    )

    #_foreign
    (§ defn #_"boolean" isEmpty [#_"APersistentSet" this]
        (zero? (.count this))
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"APersistentSet" this]
        (if (§ instance? IMapIterable (:impl this))
            (IMapIterable'''keyIterator (cast' IMapIterable (:impl this)))
            (§ reify Iterator()
                (§ init
                    (hash-map
                        #_"Iterator" :iter (.iterator (:impl this))
                    )
                )

                #_foreign
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (.hasNext (:iter this))
                )

                #_foreign
                (§ defn #_"Object" next [#_"Iterator" this]
                    (IMapEntry'''key (cast' IMapEntry (.next (:iter this))))
                )

                #_foreign
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

(class-ns VSeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"VSeq" VSeq'init []
        (hash-map
            ;; todo - something more efficient
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"VSeq" VSeq'new-2 [#_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new-0) (VSeq'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :i i))
            this
        )
    )

    (defn #_"VSeq" VSeq'new-3 [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (VSeq'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--VSeq [#_"VSeq" this]
        (Indexed'''nth-2 (:v this), (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--VSeq [#_"VSeq" this]
        (when (< (inc (:i this)) (.count (:v this)))
            (VSeq'new-2 (:v this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" IndexedSeq'''index--VSeq [#_"VSeq" this]
        (:i this)
    )

    #_override
    (defn #_"int" Counted'''count--VSeq [#_"VSeq" this]
        (- (.count (:v this)) (:i this))
    )

    #_override
    (defn #_"VSeq" IObj'''withMeta--VSeq [#_"VSeq" this, #_"IPersistentMap" meta]
        (VSeq'new-3 meta, (:v this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--VSeq [#_"VSeq" this, #_"IFn" f]
        (let [#_"IPersistentVector" v (:v this) #_"int" i (:i this) #_"int" n (.count v)]
            (loop-when [#_"Object" r (Indexed'''nth-2 v, i) i (inc i)] (< i n) => r
                (let-when [r (IFn'''invoke-3 f, r, (Indexed'''nth-2 v, i))] (RT'isReduced r) => (recur r (inc i))
                    (IDeref'''deref (cast' IDeref r))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--VSeq [#_"VSeq" this, #_"IFn" f, #_"Object" r]
        (let [#_"IPersistentVector" v (:v this) #_"int" i (:i this) #_"int" n (.count v)]
            (loop-when [r (IFn'''invoke-3 f, r, (Indexed'''nth-2 v, i)) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (when (RT'isReduced r) => (recur (IFn'''invoke-3 f, r, (Indexed'''nth-2 v, i)) (inc i))
                    (IDeref'''deref (cast' IDeref r))
                )
            )
        )
    )
)

(class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
    (defn- #_"RSeq" RSeq'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"RSeq" RSeq'new-2 [#_"IPersistentVector" vector, #_"int" i]
        (let [this (merge (ASeq'new-0) (RSeq'init))]
            (§ ass this (assoc this :v vector))
            (§ ass this (assoc this :i i))
            this
        )
    )

    (defn #_"RSeq" RSeq'new-3 [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (RSeq'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--RSeq [#_"RSeq" this]
        (Indexed'''nth-2 (:v this), (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--RSeq [#_"RSeq" this]
        (when (pos? (:i this))
            (RSeq'new-2 (:v this), (dec (:i this)))
        )
    )

    #_override
    (defn #_"int" IndexedSeq'''index--RSeq [#_"RSeq" this]
        (:i this)
    )

    #_override
    (defn #_"int" Counted'''count--RSeq [#_"RSeq" this]
        (inc (:i this))
    )

    #_override
    (defn #_"RSeq" IObj'''withMeta--RSeq [#_"RSeq" this, #_"IPersistentMap" meta]
        (RSeq'new-3 meta, (:v this), (:i this))
    )
)

(class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
    (defn- #_"SubVector" SubVector'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :start 0
            #_"int" :end 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"SubVector" SubVector'new [#_"IPersistentMap" meta, #_"IPersistentVector" v, #_"int" start, #_"int" end]
        (let [this (merge (APersistentVector'new) (SubVector'init))]
            (§ ass this (assoc this :_meta meta))

            (when (§ instance? SubVector v)
                (let [#_"SubVector" sv (cast' SubVector v)]
                    (§ ass start (+ start (:start sv)))
                    (§ ass end (+ end (:start sv)))
                    (§ ass v (:v sv))
                )
            )
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :end end))
            this
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"SubVector" this]
        (if (§ instance? APersistentVector (:v this))
            (APersistentVector'''rangedIterator (cast' APersistentVector (:v this)), (:start this), (:end this))
            (.iterator (§ super ))
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--SubVector [#_"SubVector" this, #_"int" i]
        (if (and (<= 0 i) (< (+ (:start this) i) (:end this)))
            (Indexed'''nth-2 (:v this), (+ (:start this) i))
            (throw (IndexOutOfBoundsException.))
        )
    )

    #_override
    (defn #_"IPersistentVector" IPersistentVector'''assocN--SubVector [#_"SubVector" this, #_"int" i, #_"Object" val]
        (cond
            (< (:end this) (+ (:start this) i)) (throw (IndexOutOfBoundsException.))
            (= (+ (:start this) i) (:end this)) (IPersistentVector'''cons this, val)
            :else (SubVector'new (:_meta this), (IPersistentVector'''assocN (:v this), (+ (:start this) i), val), (:start this), (:end this))
        )
    )

    #_override
    (defn #_"int" Counted'''count--SubVector [#_"SubVector" this]
        (- (:end this) (:start this))
    )

    #_override
    (defn #_"IPersistentVector" IPersistentVector'''cons--SubVector [#_"SubVector" this, #_"Object" o]
        (SubVector'new (:_meta this), (IPersistentVector'''assocN (:v this), (:end this), o), (:start this), (inc (:end this)))
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--SubVector [#_"SubVector" this]
        (IObj'''withMeta PersistentVector'EMPTY, (IMeta'''meta this))
    )

    #_override
    (defn #_"IPersistentStack" IPersistentStack'''pop--SubVector [#_"SubVector" this]
        (if (= (dec (:end this)) (:start this))
            PersistentVector'EMPTY
            (SubVector'new (:_meta this), (:v this), (:start this), (dec (:end this)))
        )
    )

    #_override
    (defn #_"SubVector" IObj'''withMeta--SubVector [#_"SubVector" this, #_"IPersistentMap" meta]
        (if (= meta (:_meta this))
            this
            (SubVector'new meta, (:v this), (:start this), (:end this))
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--SubVector [#_"SubVector" this]
        (:_meta this)
    )
)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (defn- #_"APersistentVector" APersistentVector'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentVector" APersistentVector'new []
        (merge (AFn'new) (APersistentVector'init))
    )

    #_foreign
    (§ defn #_"String" toString [#_"APersistentVector" this]
        (RT'printString this)
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--APersistentVector [#_"APersistentVector" this]
        (when (pos? (.count this))
            (VSeq'new-2 this, 0)
        )
    )

    #_override
    (defn #_"ISeq" Reversible'''rseq--APersistentVector [#_"APersistentVector" this]
        (when (pos? (.count this))
            (RSeq'new-2 this, (dec (.count this)))
        )
    )

    (defn #_"boolean" APersistentVector'doEquals [#_"IPersistentVector" v, #_"Object" obj]
        (cond
            (§ instance? IPersistentVector obj)
                (let-when [#_"IPersistentVector" ov (cast' IPersistentVector obj)] (= (.count ov) (.count v)) => false
                    (loop-when [#_"int" i 0] (< i (.count v)) => true
                        (recur-if (Util'equals (Indexed'''nth-2 v, i), (Indexed'''nth-2 ov, i)) [(inc i)] => false)
                    )
                )
            (instance? List obj)
                (let-when [#_"Collection" ma (cast Collection obj)] (and (= (.size ma) (.count v)) (= (.hashCode ma) (.hashCode v))) => false
                    (loop-when [#_"Iterator" i1 (.iterator (cast List v)) #_"Iterator" i2 (.iterator ma)] (.hasNext i1) => true
                        (recur-if (Util'equals (.next i1), (.next i2)) [i1 i2] => false)
                    )
                )
            :else
                (when (§ instance? Sequential obj) => false
                    (loop-when [#_"int" i 0 #_"ISeq" ms (RT'seq obj)] (< i (.count v)) => (nil? ms)
                        (recur-if (and (some? ms) (Util'equals (Indexed'''nth-2 v, i), (.first ms))) [(inc i) (.next ms)] => false)
                    )
                )
        )
    )

    (defn #_"boolean" APersistentVector'doEquiv [#_"IPersistentVector" v, #_"Object" obj]
        (cond
            (§ instance? IPersistentVector obj)
                (let-when [#_"IPersistentVector" ov (cast' IPersistentVector obj)] (= (.count ov) (.count v)) => false
                    (loop-when [#_"int" i 0] (< i (.count v)) => true
                        (recur-if (Util'equiv-2oo (Indexed'''nth-2 v, i), (Indexed'''nth-2 ov, i)) [(inc i)] => false)
                    )
                )
            (instance? List obj)
                (let-when [#_"Collection" ma (cast Collection obj)] (= (.size ma) (.count v)) => false
                    (loop-when [#_"Iterator" i1 (.iterator (cast List v)) #_"Iterator" i2 (.iterator ma)] (.hasNext i1) => true
                        (recur-if (Util'equiv-2oo (.next i1), (.next i2)) [i1 i2] => false)
                    )
                )
            :else
                (when (§ instance? Sequential obj) => false
                    (loop-when [#_"int" i 0 #_"ISeq" ms (RT'seq obj)] (< i (.count v)) => (nil? ms)
                        (recur-if (and (some? ms) (Util'equiv-2oo (Indexed'''nth-2 v, i), (.first ms))) [(inc i) (.next ms)] => false)
                    )
                )
        )
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"APersistentVector" this, #_"Object" obj]
        (or (= obj this) (APersistentVector'doEquals this, obj))
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--APersistentVector [#_"APersistentVector" this, #_"Object" obj]
        (or (= obj this) (APersistentVector'doEquiv this, obj))
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"APersistentVector" this]
        (let [#_"int" hash (:_hash this)]
            (when (zero? hash)
                (§ ass hash 1)
                (loop-when-recur [#_"int" i 0] (< i (.count this)) [(inc i)]
                    (let [#_"Object" obj (Indexed'''nth-2 this, i)]
                        (§ ass hash (+ (* 31 hash) (if (nil? obj) 0 (.hashCode obj))))
                    )
                )
                (§ ass this (assoc this :_hash hash))
            )
            hash
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--APersistentVector [#_"APersistentVector" this]
        (let [#_"int" hash (:_hasheq this)]
            (when (zero? hash)
                (§ let [#_"int" n]
                    (§ ass hash 1)

                    (loop-when-recur [n 0] (< n (.count this)) [(inc n)]
                        (§ ass hash (+ (* 31 hash) (Util'hasheq (Indexed'''nth-2 this, n))))
                    )

                    (§ ass this (assoc this :_hasheq (§ ass hash (Murmur3'mixCollHash hash, n))))
                )
            )
            hash
        )
    )

    #_foreign
    (§ defn #_"Object" get [#_"APersistentVector" this, #_"int" index]
        (Indexed'''nth-2 this, index)
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--APersistentVector [#_"APersistentVector" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (.count this)) (Indexed'''nth-2 this, i) notFound)
    )

    #_foreign
    (§ defn #_"Object" remove [#_"APersistentVector" this, #_"int" i]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"APersistentVector" this, #_"Object" o]
        (loop-when [#_"int" i 0] (< i (.count this)) => -1
            (if (Util'equiv-2oo (Indexed'''nth-2 this, i), o) i (recur (inc i)))
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"APersistentVector" this, #_"Object" o]
        (loop-when [#_"int" i (dec (.count this))] (<= 0 i) => -1
            (if (Util'equiv-2oo (Indexed'''nth-2 this, i), o) i (recur (dec i)))
        )
    )

    #_foreign
    (§ defn #_"ListIterator" listIterator [#_"APersistentVector" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"ListIterator" listIterator [#_"APersistentVector" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_abstract
    (defn #_"Iterator" APersistentVector'''rangedIterator [#_"APersistentVector" this, #_"int" start, #_"int" end]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i start
                )
            )

            #_foreign
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (< (:i this) end)
            )

            #_foreign
            (§ defn #_"Object" next [#_"Iterator" this]
                (if (< (:i this) end)
                    (let [_ (Indexed'''nth-2 this, (:i this))]
                        (§ ass (:i this) (inc (:i this)))
                        _
                    )
                    (throw (NoSuchElementException.))
                )
            )

            #_foreign
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_foreign
    (§ defn #_"List" subList [#_"APersistentVector" this, #_"int" fromIndex, #_"int" toIndex]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" set [#_"APersistentVector" this, #_"int" i, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"void" add [#_"APersistentVector" this, #_"int" i, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"APersistentVector" this, #_"int" i, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--APersistentVector [#_"APersistentVector" this, #_"Object" arg1]
        (if (Util'isInteger arg1)
            (Indexed'''nth-2 this, (.intValue (cast Number arg1)))
            (throw (IllegalArgumentException. "Key must be integer"))
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"APersistentVector" this]
        ;; todo - something more efficient
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i 0
                )
            )

            #_foreign
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (< (:i this) (.count this))
            )

            #_foreign
            (§ defn #_"Object" next [#_"Iterator" this]
                (if (< (:i this) (.count this))
                    (let [_ (Indexed'''nth-2 this, (:i this))]
                        (§ ass (:i this) (inc (:i this)))
                        _
                    )
                    (throw (NoSuchElementException.))
                )
            )

            #_foreign
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_override
    (defn #_"Object" IPersistentStack'''peek--APersistentVector [#_"APersistentVector" this]
        (when (pos? (.count this))
            (Indexed'''nth-2 this, (dec (.count this)))
        )
    )

    #_override
    (defn #_"boolean" Associative'''containsKey--APersistentVector [#_"APersistentVector" this, #_"Object" key]
        (and (Util'isInteger key) (< -1 (.intValue (cast Number key)) (.count this)))
    )

    #_override
    (defn #_"IMapEntry" Associative'''entryAt--APersistentVector [#_"APersistentVector" this, #_"Object" key]
        (when (Util'isInteger key)
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (.count this))
                (cast' IMapEntry (MapEntry'create key, (Indexed'''nth-2 this, i)))
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" Associative'''assoc--APersistentVector [#_"APersistentVector" this, #_"Object" key, #_"Object" val]
        (when (Util'isInteger key) => (throw (IllegalArgumentException. "Key must be integer"))
            (IPersistentVector'''assocN this, (.intValue (cast Number key)), val)
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--APersistentVector [#_"APersistentVector" this, #_"Object" key, #_"Object" notFound]
        (when (Util'isInteger key) => notFound
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (.count this)) => notFound
                (Indexed'''nth-2 this, i)
            )
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--APersistentVector [#_"APersistentVector" this, #_"Object" key]
        (ILookup'''valAt-3 this, key, nil)
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"APersistentVector" this]
        (let [#_"Object[]" a (make-array Object (.count this))]
            (dotimes [#_"int" i (.count this)]
                (aset a i (Indexed'''nth-2 this, i))
            )
            a
        )
    )

    #_foreign
    (§ defn #_"boolean" add [#_"APersistentVector" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" remove [#_"APersistentVector" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"void" clear [#_"APersistentVector" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" retainAll [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" removeAll [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" containsAll [#_"APersistentVector" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"APersistentVector" this, #_"Object[]" a]
        (RT'seqToPassedArray (Seqable'''seq this), a)
    )

    #_foreign
    (§ defn #_"int" size [#_"APersistentVector" this]
        (.count this)
    )

    #_foreign
    (§ defn #_"boolean" isEmpty [#_"APersistentVector" this]
        (zero? (.count this))
    )

    #_foreign
    (§ defn #_"boolean" contains [#_"APersistentVector" this, #_"Object" o]
        (loop-when [#_"ISeq" s (Seqable'''seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_override
    (defn #_"int" IPersistentVector'''length--APersistentVector [#_"APersistentVector" this]
        (.count this)
    )

    #_foreign
    (§ defn #_"int" compareTo [#_"APersistentVector" this, #_"Object" o]
        (let [#_"IPersistentVector" v (cast' IPersistentVector o) #_"int" n (.count this) #_"int" m (.count v)]
            (cond (< n m) -1 (< m n) 1
                :else
                    (loop-when [#_"int" i 0] (< i n) => 0
                        (let [#_"int" cmp (Util'compare (Indexed'''nth-2 this, i), (Indexed'''nth-2 v, i))]
                            (recur-if (zero? cmp) [(inc i)] => cmp)
                        )
                    )
            )
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    (defn- #_"ARef" ARef'init []
        (hash-map
            #_protected
            #_volatile
            #_"IFn" :validator nil
            #_volatile
            #_"IPersistentMap" :watches PersistentHashMap'EMPTY
        )
    )

    (defn #_"ARef" ARef'new-0 []
        (merge (AReference'new-0) (ARef'init))
    )

    (defn #_"ARef" ARef'new-1 [#_"IPersistentMap" meta]
        (merge (AReference'new-1 meta) (ARef'init))
    )

    #_method
    (defn #_"void" ARef''validate [#_"ARef" this, #_"IFn" vf, #_"Object" val]
        (try
            (when (and (some? vf) (not (RT'booleanCast-1o (IFn'''invoke-2 vf, val))))
                (throw (IllegalStateException. "Invalid reference state"))
            )
            (catch RuntimeException re
                (throw re)
            )
            (catch Exception e
                (throw (IllegalStateException. "Invalid reference state", e))
            )
        )
        nil
    )

    #_method
    (defn #_"void" ARef''validate [#_"ARef" this, #_"Object" val]
        (ARef''validate this, (:validator this), val)
        nil
    )

    #_override
    (defn #_"void" IRef'''setValidator--ARef [#_"ARef" this, #_"IFn" vf]
        (ARef''validate this, vf, (IDeref'''deref this))
        (§ ass this (assoc this :validator vf))
        nil
    )

    #_override
    (defn #_"IFn" IRef'''getValidator--ARef [#_"ARef" this]
        (:validator this)
    )

    #_override
    (defn #_"IPersistentMap" IRef'''getWatches--ARef [#_"ARef" this]
        (:watches this)
    )

    #_override
    (defn #_"IRef" IRef'''addWatch--ARef [#_"ARef" this, #_"Object" key, #_"IFn" callback]
        (§ sync this
            (§ ass this (assoc this :watches (IPersistentMap'''assoc (:watches this), key, callback)))
            this
        )
    )

    #_override
    (defn #_"IRef" IRef'''removeWatch--ARef [#_"ARef" this, #_"Object" key]
        (§ sync this
            (§ ass this (assoc this :watches (IPersistentMap'''without (:watches this), key)))
            this
        )
    )

    #_method
    (defn #_"void" ARef''notifyWatches [#_"ARef" this, #_"Object" oldval, #_"Object" newval]
        (let-when [#_"IPersistentMap" ws (:watches this)] (pos? (.count ws))
            (loop-when-recur [#_"ISeq" s (Seqable'''seq ws)] (some? s) [(.next s)]
                (let [#_"Map$Entry" e (cast Map$Entry (.first s))
                      #_"IFn" fn (cast' IFn (.getValue e))]
                    (when (some? fn)
                        (IFn'''invoke-5 fn, (.getKey e), this, oldval, newval)
                    )
                )
            )
        )
        nil
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (defn- #_"AReference" AReference'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"AReference" AReference'new-0 []
        (AReference'new-1 nil)
    )

    (defn #_"AReference" AReference'new-1 [#_"IPersistentMap" meta]
        (let [this (AReference'init)]
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--AReference [#_"AReference" this]
        (§ sync this
            (:_meta this)
        )
    )

    #_override
    (defn #_"IPersistentMap" IReference'''alterMeta--AReference [#_"AReference" this, #_"IFn" alter, #_"ISeq" args]
        (§ sync this
            (§ ass this (assoc this :_meta (cast' IPersistentMap (IFn'''applyTo alter, (Cons'new-2 (:_meta this), args)))))
            (:_meta this)
        )
    )

    #_override
    (defn #_"IPersistentMap" IReference'''resetMeta--AReference [#_"AReference" this, #_"IPersistentMap" m]
        (§ sync this
            (§ ass this (assoc this :_meta m))
            m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (defn- #_"ArityException" ArityException'init []
        (hash-map
            #_"int" :actual 0
            #_"String" :name nil
        )
    )

    (defn #_"ArityException" ArityException'new-2 [#_"int" actual, #_"String" name]
        (ArityException'new-3 actual, name, nil)
    )

    (defn #_"ArityException" ArityException'new-3 [#_"int" actual, #_"String" name, #_"Throwable" cause]
        (let [this (merge (§ foreign IllegalArgumentException'new (str "Wrong number of args (" actual ") passed to: " name), cause) (ArityException'init))]
            (§ ass this (assoc this :actual actual))
            (§ ass this (assoc this :name name))
            this
        )
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (defn- #_"ArrayChunk" ArrayChunk'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :off 0
            #_"int" :end 0
        )
    )

    (defn #_"ArrayChunk" ArrayChunk'new-1 [#_"Object[]" array]
        (ArrayChunk'new-3 array, 0, (alength array))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-2 [#_"Object[]" array, #_"int" off]
        (ArrayChunk'new-3 array, off, (alength array))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-3 [#_"Object[]" array, #_"int" off, #_"int" end]
        (let [this (ArrayChunk'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :off off))
            (§ ass this (assoc this :end end))
            this
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--ArrayChunk [#_"ArrayChunk" this, #_"int" i]
        (aget (:array this) (+ (:off this) i))
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--ArrayChunk [#_"ArrayChunk" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (.count this)) (Indexed'''nth-2 this, i) notFound)
    )

    #_override
    (defn #_"int" Counted'''count--ArrayChunk [#_"ArrayChunk" this]
        (- (:end this) (:off this))
    )

    #_override
    (defn #_"IChunk" IChunk'''dropFirst--ArrayChunk [#_"ArrayChunk" this]
        (when-not (= (:off this) (:end this)) => (throw (IllegalStateException. "dropFirst of empty chunk"))
            (ArrayChunk'new-3 (:array this), (inc (:off this)), (:end this))
        )
    )

    #_override
    (defn #_"Object" IChunk'''reduce--ArrayChunk [#_"ArrayChunk" this, #_"IFn" f, #_"Object" r]
        (let [r (IFn'''invoke-3 f, r, (aget (:array this) (:off this)))]
            (when-not (RT'isReduced r) => r
                (loop-when [#_"int" i (inc (:off this))] (< i (:end this)) => r
                    (let [r (IFn'''invoke-3 f, r, (aget (:array this) i))]
                        (when-not (RT'isReduced r) => r
                            (recur (inc i))
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns ArrayIter_int (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_int" ArrayIter_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_int" ArrayIter_int'new [#_"int[]" array, #_"int" i]
        (let [this (ArrayIter_int'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter_int" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Long" next [#_"ArrayIter_int" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Long/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter_int" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_float (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_float" ArrayIter_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_float" ArrayIter_float'new [#_"float[]" array, #_"int" i]
        (let [this (ArrayIter_float'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter_float" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Double" next [#_"ArrayIter_float" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Double/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter_float" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_double (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_double" ArrayIter_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_double" ArrayIter_double'new [#_"double[]" array, #_"int" i]
        (let [this (ArrayIter_double'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter_double" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Double" next [#_"ArrayIter_double" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (aget (:array this) (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter_double" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_long (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_long" ArrayIter_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_long" ArrayIter_long'new [#_"long[]" array, #_"int" i]
        (let [this (ArrayIter_long'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter_long" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Long" next [#_"ArrayIter_long" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Long/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter_long" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_byte (§ implements Iterator<Byte>)
    (defn- #_"ArrayIter_byte" ArrayIter_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_byte" ArrayIter_byte'new [#_"byte[]" array, #_"int" i]
        (let [this (ArrayIter_byte'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter_byte" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Byte" next [#_"ArrayIter_byte" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (aget (:array this) (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter_byte" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_char (§ implements Iterator<Character>)
    (defn- #_"ArrayIter_char" ArrayIter_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_char" ArrayIter_char'new [#_"char[]" array, #_"int" i]
        (let [this (ArrayIter_char'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter_char" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Character" next [#_"ArrayIter_char" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (aget (:array this) (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter_char" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_short (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_short" ArrayIter_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_short" ArrayIter_short'new [#_"short[]" array, #_"int" i]
        (let [this (ArrayIter_short'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter_short" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Long" next [#_"ArrayIter_short" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Long/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter_short" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
    (defn- #_"ArrayIter_boolean" ArrayIter_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_boolean" ArrayIter_boolean'new [#_"boolean[]" array, #_"int" i]
        (let [this (ArrayIter_boolean'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter_boolean" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Boolean" next [#_"ArrayIter_boolean" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (Boolean/valueOf (aget (:array this) (:i this)))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter_boolean" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter (§ implements Iterator)
    (def #_"Iterator" ArrayIter'EMPTY_ITERATOR
        (§ reify Iterator()
            #_foreign
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_foreign
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_foreign
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException. "remove() not supported"))
            )
        )
    )

    (defn #_"Iterator" ArrayIter'create-0 []
        ArrayIter'EMPTY_ITERATOR
    )

    (defn #_"Iterator" ArrayIter'create-1 [& #_"Object..." array]
        (if (and (some? array) (pos? (alength array)))
            (ArrayIter'new array, 0)
            ArrayIter'EMPTY_ITERATOR
        )
    )

    (defn #_"Iterator" ArrayIter'createFromObject [#_"Object" array]
        (when (and (some? array) (pos? (Array/getLength array))) => ArrayIter'EMPTY_ITERATOR
            (condp = (.getClass array)
                (§ class int[])     (ArrayIter_int'new     (§ cast int[]     array), 0)
                (§ class float[])   (ArrayIter_float'new   (§ cast float[]   array), 0)
                (§ class double[])  (ArrayIter_double'new  (§ cast double[]  array), 0)
                (§ class long[])    (ArrayIter_long'new    (§ cast long[]    array), 0)
                (§ class byte[])    (ArrayIter_byte'new    (§ cast byte[]    array), 0)
                (§ class char[])    (ArrayIter_char'new    (§ cast char[]    array), 0)
                (§ class short[])   (ArrayIter_short'new   (§ cast short[]   array), 0)
                (§ class boolean[]) (ArrayIter_boolean'new (§ cast boolean[] array), 0)
                                    (ArrayIter'new                           array,  0)
            )
        )
    )

    (defn- #_"ArrayIter" ArrayIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter" ArrayIter'new [#_"Object" array, #_"int" i]
        (let [this (ArrayIter'init)]
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :array (§ cast Object[] array)))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ArrayIter" this]
        (and (some? (:array this)) (< (:i this) (alength (:array this))))
    )

    #_foreign
    (§ defn #_"Object" next [#_"ArrayIter" this]
        (when (and (some? (:array this)) (< (:i this) (alength (:array this)))) => (throw (NoSuchElementException.))
            (let [_ (aget (:array this) (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (§ return _)
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"ArrayIter" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_int" ArraySeq_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_int" ArraySeq_int'new [#_"IPersistentMap" meta, #_"int[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_int'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_int [#_"ArraySeq_int" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_int [#_"ArraySeq_int" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_int'new (IMeta'''meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_int [#_"ArraySeq_int" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_int [#_"ArraySeq_int" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_int" IObj'''withMeta--ArraySeq_int [#_"ArraySeq_int" this, #_"IPersistentMap" meta]
        (ArraySeq_int'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_int [#_"ArraySeq_int" this, #_"IFn" f]
        (let [#_"int[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (IFn'''invoke-3 f, r, (aget a i))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_int [#_"ArraySeq_int" this, #_"IFn" f, #_"Object" r]
        (let [#_"int[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (IFn'''invoke-3 f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq_int" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"int" k (.intValue (cast Number o))]
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (= k (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_int" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"int" k (.intValue (cast Number o))]
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (= k (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_float" ArraySeq_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_float" ArraySeq_float'new [#_"IPersistentMap" meta, #_"float[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_float'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_float [#_"ArraySeq_float" this]
        (Numbers'num-1f (aget (:array this) (:i this)))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_float [#_"ArraySeq_float" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_float'new (IMeta'''meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_float [#_"ArraySeq_float" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_float [#_"ArraySeq_float" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_float" IObj'''withMeta--ArraySeq_float [#_"ArraySeq_float" this, #_"IPersistentMap" meta]
        (ArraySeq_float'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_float [#_"ArraySeq_float" this, #_"IFn" f]
        (let [#_"float[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (Numbers'num-1f (aget a i)) i (inc i)] (< i n) => r
                (let [r (IFn'''invoke-3 f, r, (Numbers'num-1f (aget a i)))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_float [#_"ArraySeq_float" this, #_"IFn" f, #_"Object" r]
        (let [#_"float[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (IFn'''invoke-3 f, r, (Numbers'num-1f (aget a i))) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (Numbers'num-1f (aget a i))) (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq_float" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"float" f (.floatValue (cast Number o))]
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (= f (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_float" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"float" f (.floatValue (cast Number o))]
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (= f (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_double" ArraySeq_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_double" ArraySeq_double'new [#_"IPersistentMap" meta, #_"double[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_double'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_double [#_"ArraySeq_double" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_double [#_"ArraySeq_double" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_double'new (IMeta'''meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_double [#_"ArraySeq_double" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_double [#_"ArraySeq_double" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_double" IObj'''withMeta--ArraySeq_double [#_"ArraySeq_double" this, #_"IPersistentMap" meta]
        (ArraySeq_double'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_double [#_"ArraySeq_double" this, #_"IFn" f]
        (let [#_"double[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (IFn'''invoke-3 f, r, (aget a i))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_double [#_"ArraySeq_double" this, #_"IFn" f, #_"Object" r]
        (let [#_"double[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (IFn'''invoke-3 f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq_double" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"double" d (.doubleValue (cast Number o))]
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (= d (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_double" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"double" d (.doubleValue (cast Number o))]
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (= d (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_long" ArraySeq_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_long" ArraySeq_long'new [#_"IPersistentMap" meta, #_"long[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_long'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_long [#_"ArraySeq_long" this]
        (Numbers'num-1l (aget (:array this) (:i this)))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_long [#_"ArraySeq_long" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_long'new (IMeta'''meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_long [#_"ArraySeq_long" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_long [#_"ArraySeq_long" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_long" IObj'''withMeta--ArraySeq_long [#_"ArraySeq_long" this, #_"IPersistentMap" meta]
        (ArraySeq_long'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_long [#_"ArraySeq_long" this, #_"IFn" f]
        (let [#_"long[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (Numbers'num-1l (aget a i)) i (inc i)] (< i n) => r
                (let [r (IFn'''invoke-3 f, r, (Numbers'num-1l (aget a i)))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_long [#_"ArraySeq_long" this, #_"IFn" f, #_"Object" r]
        (let [#_"long[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (IFn'''invoke-3 f, r, (Numbers'num-1l (aget a i))) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (Numbers'num-1l (aget a i))) (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq_long" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"long" l (.longValue (cast Number o))]
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (= l (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_long" this, #_"Object" o]
        (when (instance? Number o) => -1
            (let [#_"long" l (.longValue (cast Number o))]
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (= l (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_byte" ArraySeq_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_byte" ArraySeq_byte'new [#_"IPersistentMap" meta, #_"byte[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_byte'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_byte [#_"ArraySeq_byte" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_byte [#_"ArraySeq_byte" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_byte'new (IMeta'''meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_byte [#_"ArraySeq_byte" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_byte [#_"ArraySeq_byte" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_byte" IObj'''withMeta--ArraySeq_byte [#_"ArraySeq_byte" this, #_"IPersistentMap" meta]
        (ArraySeq_byte'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_byte [#_"ArraySeq_byte" this, #_"IFn" f]
        (let [#_"byte[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (IFn'''invoke-3 f, r, (aget a i))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_byte [#_"ArraySeq_byte" this, #_"IFn" f, #_"Object" r]
        (let [#_"byte[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (IFn'''invoke-3 f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq_byte" this, #_"Object" o]
        (or
            (when (instance? Byte o)
                (let [#_"byte" b (.byteValue (cast Byte o))]
                    (loop-when [#_"int" i (:i this)] (< i (alength (:array this)))
                        (if (= b (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_byte" this, #_"Object" o]
        (or
            (when (instance? Byte o)
                (let [#_"byte" b (.byteValue (cast Byte o))]
                    (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i)
                        (if (= b (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_char" ArraySeq_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_char" ArraySeq_char'new [#_"IPersistentMap" meta, #_"char[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_char'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_char [#_"ArraySeq_char" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_char [#_"ArraySeq_char" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_char'new (IMeta'''meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_char [#_"ArraySeq_char" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_char [#_"ArraySeq_char" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_char" IObj'''withMeta--ArraySeq_char [#_"ArraySeq_char" this, #_"IPersistentMap" meta]
        (ArraySeq_char'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_char [#_"ArraySeq_char" this, #_"IFn" f]
        (let [#_"char[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (IFn'''invoke-3 f, r, (aget a i))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_char [#_"ArraySeq_char" this, #_"IFn" f, #_"Object" r]
        (let [#_"char[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (IFn'''invoke-3 f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq_char" this, #_"Object" o]
        (or
            (when (instance? Character o)
                (let [#_"char" c (.charValue (cast Character o))]
                    (loop-when [#_"int" i (:i this)] (< i (alength (:array this)))
                        (if (= c (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_char" this, #_"Object" o]
        (or
            (when (instance? Character o)
                (let [#_"char" c (.charValue (cast Character o))]
                    (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i)
                        (if (= c (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_short" ArraySeq_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_short" ArraySeq_short'new [#_"IPersistentMap" meta, #_"short[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_short'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_short [#_"ArraySeq_short" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_short [#_"ArraySeq_short" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_short'new (IMeta'''meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_short [#_"ArraySeq_short" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_short [#_"ArraySeq_short" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_short" IObj'''withMeta--ArraySeq_short [#_"ArraySeq_short" this, #_"IPersistentMap" meta]
        (ArraySeq_short'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_short [#_"ArraySeq_short" this, #_"IFn" f]
        (let [#_"short[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (IFn'''invoke-3 f, r, (aget a i))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_short [#_"ArraySeq_short" this, #_"IFn" f, #_"Object" r]
        (let [#_"short[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (IFn'''invoke-3 f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq_short" this, #_"Object" o]
        (or
            (when (instance? Short o)
                (let [#_"short" s (.shortValue (cast Short o))]
                    (loop-when [#_"int" i (:i this)] (< i (alength (:array this)))
                        (if (= s (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_short" this, #_"Object" o]
        (or
            (when (instance? Short o)
                (let [#_"short" s (.shortValue (cast Short o))]
                    (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i)
                        (if (= s (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_boolean" ArraySeq_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_boolean" ArraySeq_boolean'new [#_"IPersistentMap" meta, #_"boolean[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq_boolean'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq_boolean [#_"ArraySeq_boolean" this]
        (aget (:array this) (:i this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq_boolean [#_"ArraySeq_boolean" this]
        (when (< (inc (:i this)) (alength (:array this)))
            (ArraySeq_boolean'new (IMeta'''meta this), (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq_boolean [#_"ArraySeq_boolean" this]
        (- (alength (:array this)) (:i this))
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq_boolean [#_"ArraySeq_boolean" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq_boolean" IObj'''withMeta--ArraySeq_boolean [#_"ArraySeq_boolean" this, #_"IPersistentMap" meta]
        (ArraySeq_boolean'new meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq_boolean [#_"ArraySeq_boolean" this, #_"IFn" f]
        (let [#_"boolean[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                (let [r (IFn'''invoke-3 f, r, (aget a i))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq_boolean [#_"ArraySeq_boolean" this, #_"IFn" f, #_"Object" r]
        (let [#_"boolean[]" a (:array this) #_"int" i (:i this) #_"int" n (alength a)]
            (loop-when [r (IFn'''invoke-3 f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (aget a i)) (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq_boolean" this, #_"Object" o]
        (or
            (when (instance? Boolean o)
                (let [#_"boolean" b (.booleanValue (cast Boolean o))]
                    (loop-when [#_"int" i (:i this)] (< i (alength (:array this)))
                        (if (= b (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_boolean" this, #_"Object" o]
        (or
            (when (instance? Boolean o)
                (let [#_"boolean" b (.booleanValue (cast Boolean o))]
                    (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i)
                        (if (= b (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                    )
                )
            )
            (when (some? o) => -1
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn #_"ArraySeq" ArraySeq'create-0 []
        nil
    )

    (defn #_"ArraySeq" ArraySeq'create-1 [& #_"Object..." array]
        (when (and (some? array) (pos? (alength array)))
            (ArraySeq'new-2 array, 0)
        )
    )

    (defn #_"ISeq" ArraySeq'createFromObject [#_"Object" array]
        (when (and (some? array) (pos? (Array/getLength array)))
            (condp = (.getClass array)
                (§ class int[])     (ArraySeq_int'new     nil, (§ cast int[]     array), 0)
                (§ class float[])   (ArraySeq_float'new   nil, (§ cast float[]   array), 0)
                (§ class double[])  (ArraySeq_double'new  nil, (§ cast double[]  array), 0)
                (§ class long[])    (ArraySeq_long'new    nil, (§ cast long[]    array), 0)
                (§ class byte[])    (ArraySeq_byte'new    nil, (§ cast byte[]    array), 0)
                (§ class char[])    (ArraySeq_char'new    nil, (§ cast char[]    array), 0)
                (§ class short[])   (ArraySeq_short'new   nil, (§ cast short[]   array), 0)
                (§ class boolean[]) (ArraySeq_boolean'new nil, (§ cast boolean[] array), 0)
                                    (ArraySeq'new-2                              array,  0)
            )
        )
    )

    (defn- #_"ArraySeq" ArraySeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-2 [#_"Object" array, #_"int" i]
        (let [this (merge (ASeq'new-0) (ArraySeq'init))]
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :array (§ cast Object[] array)))
            this
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-3 [#_"IPersistentMap" meta, #_"Object" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (ArraySeq'init))]
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :array (§ cast Object[] array)))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ArraySeq [#_"ArraySeq" this]
        (when (some? (:array this))
            (aget (:array this) (:i this))
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ArraySeq [#_"ArraySeq" this]
        (when (and (some? (:array this)) (< (inc (:i this)) (alength (:array this))))
            (ArraySeq'new-2 (:array this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" Counted'''count--ArraySeq [#_"ArraySeq" this]
        (if (some? (:array this)) (- (alength (:array this)) (:i this)) 0)
    )

    #_override
    (defn #_"int" IndexedSeq'''index--ArraySeq [#_"ArraySeq" this]
        (:i this)
    )

    #_override
    (defn #_"ArraySeq" IObj'''withMeta--ArraySeq [#_"ArraySeq" this, #_"IPersistentMap" meta]
        (ArraySeq'new-3 meta, (:array this), (:i this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--ArraySeq [#_"ArraySeq" this, #_"IFn" f]
        (when-let [#_"Object[]" a (:array this)]
            (let [#_"int" i (:i this) #_"int" n (alength a)]
                (loop-when [#_"Object" r (aget a i) i (inc i)] (< i n) => r
                    (let [r (IFn'''invoke-3 f, r, (aget a i))]
                        (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--ArraySeq [#_"ArraySeq" this, #_"IFn" f, #_"Object" r]
        (when-let [#_"Object[]" a (:array this)]
            (let [#_"int" i (:i this) #_"int" n (alength a)]
                (loop-when [r (IFn'''invoke-3 f, r, (aget a i)) i (inc i)] (< i n) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (aget a i)) (inc i)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ArraySeq" this, #_"Object" o]
        (when (some? (:array this)) => -1
            (loop-when [#_"int" i (:i this)] (< i (alength (:array this))) => -1
                (if (Util'equals o, (aget (:array this) i)) (- i (:i this)) (recur (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ArraySeq" this, #_"Object" o]
        (when (some? (:array this)) => -1
            (if (nil? o)
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (nil? (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
                (loop-when [#_"int" i (dec (alength (:array this)))] (<= (:i this) i) => -1
                    (if (.equals o, (aget (:array this) i)) (- i (:i this)) (recur (dec i)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    (defn- #_"ASeq" ASeq'init []
        (hash-map
            #_transient
            #_"int" :_hash 0
            #_transient
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"ASeq" ASeq'new-1 [#_"IPersistentMap" meta]
        (merge (Obj'new-1 meta) (ASeq'init))
    )

    #_protected
    (defn #_"ASeq" ASeq'new-0 []
        (merge (Obj'new-0) (ASeq'init))
    )

    #_foreign
    (§ defn #_"String" toString [#_"ASeq" this]
        (RT'printString this)
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--ASeq [#_"ASeq" this]
        PersistentList'EMPTY
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--ASeq [#_"ASeq" this, #_"Object" obj]
        (and (or (§ instance? Sequential obj) (instance? List obj))
            (let [#_"ISeq" ms (RT'seq obj)]
                (loop-when [#_"ISeq" s (Seqable'''seq this) ms ms] (some? s) => (nil? ms)
                    (and (some? ms) (Util'equiv-2oo (.first s), (.first ms)) (recur (.next s) (.next ms)))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"ASeq" this, #_"Object" obj]
        (or (= this obj)
            (and (or (§ instance? Sequential obj) (instance? List obj))
                (let [#_"ISeq" ms (RT'seq obj)]
                    (loop-when [#_"ISeq" s (Seqable'''seq this) ms ms] (some? s) => (nil? ms)
                        (and (some? ms) (Util'equals (.first s), (.first ms)) (recur (.next s) (.next ms)))
                    )
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"ASeq" this]
        (when (zero? (:_hash this))
            (let [#_"int" hash 1]
                (loop-when-recur [#_"ISeq" s (Seqable'''seq this)] (some? s) [(.next s)]
                    (§ ass hash (+ (* 31 hash) (if (nil? (.first s)) 0 (.hashCode (.first s)))))
                )
                (§ ass this (assoc this :_hash hash))
            )
        )
        (:_hash this)
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--ASeq [#_"ASeq" this]
        (when (zero? (:_hasheq this))
            (§ ass this (assoc this :_hasheq (Murmur3'hashOrdered this)))
        )
        (:_hasheq this)
    )

    #_override
    (defn #_"int" Counted'''count--ASeq [#_"ASeq" this]
        (loop-when [#_"ISeq" s (.next this) #_"int" i 1] (some? s) => i
            (if (§ instance? Counted s) (+ i (.count s)) (recur (.next s) (inc i)))
        )
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--ASeq [#_"ASeq" this]
        this
    )

    #_override
    (defn #_"ISeq" ISeq'''cons--ASeq [#_"ASeq" this, #_"Object" o]
        (Cons'new-2 o, this)
    )

    #_override
    (defn #_"ISeq" ISeq'''more--ASeq [#_"ASeq" this]
        (or (.next this) PersistentList'EMPTY)
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"ASeq" this]
        (RT'seqToArray (Seqable'''seq this))
    )

    #_foreign
    (§ defn #_"boolean" add [#_"ASeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" remove [#_"ASeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"void" clear [#_"ASeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" retainAll [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" removeAll [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" containsAll [#_"ASeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"ASeq" this, #_"Object[]" a]
        (RT'seqToPassedArray (Seqable'''seq this), a)
    )

    #_foreign
    (§ defn #_"int" size [#_"ASeq" this]
        (.count this)
    )

    #_foreign
    (§ defn #_"boolean" isEmpty [#_"ASeq" this]
        (nil? (Seqable'''seq this))
    )

    #_foreign
    (§ defn #_"boolean" contains [#_"ASeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (Seqable'''seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"ASeq" this]
        (SeqIterator'new this)
    )

    #_foreign
    (§ defn #_"List" subList [#_"ASeq" this, #_"int" fromIndex, #_"int" toIndex]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" set [#_"ASeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" remove [#_"ASeq" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"ASeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (Seqable'''seq this) #_"int" i 0] (some? s) => -1
            (if (Util'equiv-2oo (.first s), o) i (recur (.next s) (inc i)))
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"ASeq" this, #_"Object" o]
        (.lastIndexOf (ArrayList. this), o)
    )

    #_foreign
    (§ defn #_"ListIterator" listIterator [#_"ASeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"ListIterator" listIterator [#_"ASeq" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" get [#_"ASeq" this, #_"int" index]
        (RT'nth-2 this, index)
    )

    #_foreign
    (§ defn #_"void" add [#_"ASeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"ASeq" this, #_"int" index, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (defn- #_"Atom" Atom'init []
        (hash-map
            #_"AtomicReference" :state nil
        )
    )

    (defn #_"Atom" Atom'new-1 [#_"Object" state]
        (let [this (merge (ARef'new-0) (Atom'init))]
            (§ ass this (assoc this :state (AtomicReference. state)))
            this
        )
    )

    (defn #_"Atom" Atom'new-2 [#_"Object" state, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Atom'init))]
            (§ ass this (assoc this :state (AtomicReference. state)))
            this
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Atom [#_"Atom" this]
        (.get (:state this))
    )

    #_override
    (defn #_"Object" IAtom'''swap-2--Atom [#_"Atom" this, #_"IFn" f]
        (loop []
            (let [#_"Object" v (IDeref'''deref this) #_"Object" newv (IFn'''invoke-2 f, v)]
                (ARef''validate this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (ARef''notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_override
    (defn #_"Object" IAtom'''swap-3--Atom [#_"Atom" this, #_"IFn" f, #_"Object" arg]
        (loop []
            (let [#_"Object" v (IDeref'''deref this) #_"Object" newv (IFn'''invoke-3 f, v, arg)]
                (ARef''validate this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (ARef''notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_override
    (defn #_"Object" IAtom'''swap-4--Atom [#_"Atom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (loop []
            (let [#_"Object" v (IDeref'''deref this) #_"Object" newv (IFn'''invoke-4 f, v, arg1, arg2)]
                (ARef''validate this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (ARef''notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_override
    (defn #_"Object" IAtom'''swap-5--Atom [#_"Atom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (loop []
            (let [#_"Object" v (IDeref'''deref this) #_"Object" newv (IFn'''applyTo f, (RT'listStar-4 v, x, y, args))]
                (ARef''validate this, newv)
                (when (.compareAndSet (:state this), v, newv) => (recur)
                    (ARef''notifyWatches this, v, newv)
                    newv
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''swapVals-2--Atom [#_"Atom" this, #_"IFn" f]
        (loop []
            (let [#_"Object" oldv (IDeref'''deref this) #_"Object" newv (IFn'''invoke-2 f, oldv)]
                (ARef''validate this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''swapVals-3--Atom [#_"Atom" this, #_"IFn" f, #_"Object" arg]
        (loop []
            (let [#_"Object" oldv (IDeref'''deref this) #_"Object" newv (IFn'''invoke-3 f, oldv, arg)]
                (ARef''validate this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''swapVals-4--Atom [#_"Atom" this, #_"IFn" f, #_"Object" arg1, #_"Object" arg2]
        (loop []
            (let [#_"Object" oldv (IDeref'''deref this) #_"Object" newv (IFn'''invoke-4 f, oldv, arg1, arg2)]
                (ARef''validate this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''swapVals-5--Atom [#_"Atom" this, #_"IFn" f, #_"Object" x, #_"Object" y, #_"ISeq" args]
        (loop []
            (let [#_"Object" oldv (IDeref'''deref this) #_"Object" newv (IFn'''applyTo f, (RT'listStar-4 oldv, x, y, args))]
                (ARef''validate this, newv)
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )

    #_override
    (defn #_"boolean" IAtom'''compareAndSet--Atom [#_"Atom" this, #_"Object" oldv, #_"Object" newv]
        (ARef''validate this, newv)
        (let [#_"boolean" ret (.compareAndSet (:state this), oldv, newv)]
            (when ret
                (ARef''notifyWatches this, oldv, newv)
            )
            ret
        )
    )

    #_override
    (defn #_"Object" IAtom'''reset--Atom [#_"Atom" this, #_"Object" newval]
        (let [#_"Object" oldval (.get (:state this))]
            (ARef''validate this, newval)
            (.set (:state this), newval)
            (ARef''notifyWatches this, oldval, newval)
            newval
        )
    )

    #_override
    (defn #_"IPersistentVector" IAtom2'''resetVals--Atom [#_"Atom" this, #_"Object" newv]
        (ARef''validate this, newv)
        (loop []
            (let [#_"Object" oldv (IDeref'''deref this)]
                (when (.compareAndSet (:state this), oldv, newv) => (recur)
                    (ARef''notifyWatches this, oldv, newv)
                    (LazilyPersistentVector'createOwning oldv, newv)
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

#_stateless
#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    #_protected
    (defn #_"ATransientMap" ATransientMap'new []
        (AFn'new)
    )

    #_abstract
    (defn #_"void" ATransientMap'''ensureEditable [#_"ATransientMap" this])
    #_abstract
    (defn #_"ITransientMap" ATransientMap'''doAssoc [#_"ATransientMap" this, #_"Object" key, #_"Object" val])
    #_abstract
    (defn #_"ITransientMap" ATransientMap'''doWithout [#_"ATransientMap" this, #_"Object" key])
    #_abstract
    (defn #_"Object" ATransientMap'''doValAt [#_"ATransientMap" this, #_"Object" key, #_"Object" notFound])
    #_abstract
    (defn #_"int" ATransientMap'''doCount [#_"ATransientMap" this])
    #_abstract
    (defn #_"IPersistentMap" ATransientMap'''doPersistent [#_"ATransientMap" this])

    #_method
    (defn #_"ITransientMap" ATransientMap''conj [#_"ATransientMap" this, #_"Object" o]
        (ATransientMap'''ensureEditable this)
        (cond
            (instance? Map$Entry o)
                (let [#_"Map$Entry" e (cast Map$Entry o)]
                    (ITransientMap'''assoc this, (.getKey e), (.getValue e))
                )
            (§ instance? IPersistentVector o)
                (let [#_"IPersistentVector" v (cast' IPersistentVector o)]
                    (when (= (.count v) 2) => (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                        (ITransientMap'''assoc this, (Indexed'''nth-2 v, 0), (Indexed'''nth-2 v, 1))
                    )
                )
            :else
                (loop-when [#_"ITransientMap" m this #_"ISeq" s (RT'seq o)] (some? s) => m
                    (let [#_"Map$Entry" e (cast Map$Entry (.first s))]
                        (recur (ITransientMap'''assoc m, (.getKey e), (.getValue e)) (.next s))
                    )
                )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--ATransientMap [#_"ATransientMap" this, #_"Object" arg1]
        (ILookup'''valAt-2 this, arg1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--ATransientMap [#_"ATransientMap" this, #_"Object" arg1, #_"Object" notFound]
        (ILookup'''valAt-3 this, arg1, notFound)
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--ATransientMap [#_"ATransientMap" this, #_"Object" key]
        (ILookup'''valAt-3 this, key, nil)
    )

    #_override
    (defn #_"ITransientMap" ITransientMap'''assoc--ATransientMap [#_"ATransientMap" this, #_"Object" key, #_"Object" val]
        (ATransientMap'''ensureEditable this)
        (ATransientMap'''doAssoc this, key, val)
    )

    #_override
    (defn #_"ITransientMap" ITransientMap'''without--ATransientMap [#_"ATransientMap" this, #_"Object" key]
        (ATransientMap'''ensureEditable this)
        (ATransientMap'''doWithout this, key)
    )

    #_override
    (defn #_"IPersistentMap" ITransientMap'''persistent--ATransientMap [#_"ATransientMap" this]
        (ATransientMap'''ensureEditable this)
        (ATransientMap'''doPersistent this)
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--ATransientMap [#_"ATransientMap" this, #_"Object" key, #_"Object" notFound]
        (ATransientMap'''ensureEditable this)
        (ATransientMap'''doValAt this, key, notFound)
    )

    (def- #_"Object" ATransientMap'NOT_FOUND (Object.))

    #_override
    (defn #_"boolean" ITransientAssociative2'''containsKey--ATransientMap [#_"ATransientMap" this, #_"Object" key]
        (not= (ILookup'''valAt-3 this, key, ATransientMap'NOT_FOUND) ATransientMap'NOT_FOUND)
    )

    #_override
    (defn #_"IMapEntry" ITransientAssociative2'''entryAt--ATransientMap [#_"ATransientMap" this, #_"Object" key]
        (let [#_"Object" v (ILookup'''valAt-3 this, key, ATransientMap'NOT_FOUND)]
            (when-not (= v ATransientMap'NOT_FOUND)
                (MapEntry'create key, v)
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--ATransientMap [#_"ATransientMap" this]
        (ATransientMap'''ensureEditable this)
        (ATransientMap'''doCount this)
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    (defn- #_"ATransientSet" ATransientSet'init []
        (hash-map
            #_volatile
            #_"ITransientMap" :impl nil
        )
    )

    (defn #_"ATransientSet" ATransientSet'new [#_"ITransientMap" impl]
        (let [this (merge (AFn'new) (ATransientSet'init))]
            (§ ass this (assoc this :impl impl))
            this
        )
    )

    #_override
    (defn #_"int" Counted'''count--ATransientSet [#_"ATransientSet" this]
        (.count (:impl this))
    )

    #_override
    (defn #_"ITransientSet" ITransientCollection'''conj--ATransientSet [#_"ATransientSet" this, #_"Object" val]
        (let [#_"ITransientMap" m (ITransientMap'''assoc (:impl this), val, val)]
            (when-not (= m (:impl this))
                (§ ass this (assoc this :impl m))
            )
            this
        )
    )

    #_override
    (defn #_"boolean" ITransientSet'''contains--ATransientSet [#_"ATransientSet" this, #_"Object" key]
        (not= this (ILookup'''valAt-3 (:impl this), key, this))
    )

    #_override
    (defn #_"ITransientSet" ITransientSet'''disjoin--ATransientSet [#_"ATransientSet" this, #_"Object" key]
        (let [#_"ITransientMap" m (ITransientMap'''without (:impl this), key)]
            (when-not (= m (:impl this))
                (§ ass this (assoc this :impl m))
            )
            this
        )
    )

    #_override
    (defn #_"Object" ITransientSet'''get--ATransientSet [#_"ATransientSet" this, #_"Object" key]
        (ILookup'''valAt-2 (:impl this), key)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--ATransientSet [#_"ATransientSet" this, #_"Object" key, #_"Object" notFound]
        (ILookup'''valAt-3 (:impl this), key, notFound)
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--ATransientSet [#_"ATransientSet" this, #_"Object" key]
        (ILookup'''valAt-2 (:impl this), key)
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ def #_"BigInt" BigInt'ZERO (BigInt'new 0, nil))
    (§ def #_"BigInt" BigInt'ONE (BigInt'new 1, nil))

    (defn- #_"BigInt" BigInt'init []
        (hash-map
            #_"long" :lpart 0
            #_"BigInteger" :bipart nil
        )
    )

    (defn- #_"BigInt" BigInt'new [#_"long" lpart, #_"BigInteger" bipart]
        (let [this (merge (§ foreign Number'new) (BigInt'init))]
            (§ ass this (assoc this :lpart lpart))
            (§ ass this (assoc this :bipart bipart))
            this
        )
    )

    ;; must follow Long
    #_foreign
    (§ defn #_"int" hashCode [#_"BigInt" this]
        (if (nil? (:bipart this))
            (int (bit-xor (:lpart this) (>>> (:lpart this) 32)))
            (.hashCode (:bipart this))
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--BigInt [#_"BigInt" this]
        (if (nil? (:bipart this))
            (Murmur3'hashLong (:lpart this))
            (.hashCode (:bipart this))
        )
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"BigInt" this, #_"Object" obj]
        (cond
            (= this obj)
                true
            (§ instance? BigInt obj)
                (let [#_"BigInt" o (cast' BigInt obj)]
                    (if (nil? (:bipart this))
                        (and (nil? (:bipart o)) (= (:lpart this) (:lpart o)))
                        (and (some? (:bipart o)) (.equals (:bipart this), (:bipart o)))
                    )
                )
            :else
                false
        )
    )

    (defn #_"BigInt" BigInt'fromBigInteger [#_"BigInteger" val]
        (if (< (.bitLength val) 64)
            (BigInt'new (.longValue val), nil)
            (BigInt'new 0, val)
        )
    )

    (defn #_"BigInt" BigInt'fromLong [#_"long" val]
        (BigInt'new val, nil)
    )

    #_method
    (defn #_"BigInteger" BigInt''toBigInteger [#_"BigInt" this]
        (if (nil? (:bipart this))
            (BigInteger/valueOf (:lpart this))
            (:bipart this)
        )
    )

    #_method
    (defn #_"BigDecimal" BigInt''toBigDecimal [#_"BigInt" this]
        (if (nil? (:bipart this))
            (BigDecimal/valueOf (:lpart this))
            (BigDecimal. (:bipart this))
        )
    )

    #_method
    (defn #_"int" BigInt''intValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (int (:lpart this))
            (.intValue (:bipart this))
        )
    )

    #_method
    (defn #_"long" BigInt''longValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.longValue (:bipart this))
        )
    )

    #_method
    (defn #_"float" BigInt''floatValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.floatValue (:bipart this))
        )
    )

    #_method
    (defn #_"double" BigInt''doubleValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (:lpart this)
            (.doubleValue (:bipart this))
        )
    )

    #_method
    (defn #_"byte" BigInt''byteValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (byte (:lpart this))
            (.byteValue (:bipart this))
        )
    )

    #_method
    (defn #_"short" BigInt''shortValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (short (:lpart this))
            (.shortValue (:bipart this))
        )
    )

    (defn #_"BigInt" BigInt'valueOf [#_"long" val]
        (BigInt'new val, nil)
    )

    #_foreign
    (§ defn #_"String" toString [#_"BigInt" this]
        (if (nil? (:bipart this))
            (String/valueOf (:lpart this))
            (.toString (:bipart this))
        )
    )

    #_method
    (defn #_"int" BigInt''bitLength [#_"BigInt" this]
        (.bitLength (BigInt''toBigInteger this))
    )

    #_method
    (defn #_"BigInt" BigInt''add [#_"BigInt" this, #_"BigInt" y]
        (or
            (when (and (nil? (:bipart this)) (nil? (:bipart y)))
                (let [#_"long" ret (+ (:lpart this) (:lpart y))]
                    (when (or (<= 0 (bit-xor ret (:lpart this))) (<= 0 (bit-xor ret (:lpart y))))
                        (BigInt'valueOf ret)
                    )
                )
            )
            (BigInt'fromBigInteger (.add (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )

    #_method
    (defn #_"BigInt" BigInt''multiply [#_"BigInt" this, #_"BigInt" y]
        (or
            (when (and (nil? (:bipart this)) (nil? (:bipart y)))
                (let [#_"long" ret (* (:lpart this) (:lpart y))]
                    (when (or (zero? (:lpart y)) (and (= (/ ret (:lpart y)) (:lpart this)) (not= (:lpart this) Long/MIN_VALUE)))
                        (BigInt'valueOf ret)
                    )
                )
            )
            (BigInt'fromBigInteger (.multiply (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )

    #_method
    (defn #_"BigInt" BigInt''quotient [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (if (and (= (:lpart this) Long/MIN_VALUE) (= (:lpart y) -1))
                (BigInt'fromBigInteger (.negate (BigInt''toBigInteger this)))
                (BigInt'valueOf (/ (:lpart this) (:lpart y)))
            )
            (BigInt'fromBigInteger (.divide (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )

    #_method
    (defn #_"BigInt" BigInt''remainder [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (BigInt'valueOf (% (:lpart this) (:lpart y)))
            (BigInt'fromBigInteger (.remainder (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )

    #_method
    (defn #_"boolean" BigInt''lt [#_"BigInt" this, #_"BigInt" y]
        (if (and (nil? (:bipart this)) (nil? (:bipart y)))
            (< (:lpart this) (:lpart y))
            (neg? (.compareTo (BigInt''toBigInteger this), (BigInt''toBigInteger y)))
        )
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (defn- #_"Binding" Binding'init []
        (hash-map
            #_"T" :val nil
            #_"Binding" :rest nil
        )
    )

    (defn #_"Binding" Binding'new-1 [#_"T" val]
        (let [this (Binding'init)]
            (§ ass this (assoc this :val val))
            (§ ass this (assoc this :rest nil))
            this
        )
    )

    (defn #_"Binding" Binding'new-2 [#_"T" val, #_"Binding" rest]
        (let [this (Binding'init)]
            (§ ass this (assoc this :val val))
            (§ ass this (assoc this :rest rest))
            this
        )
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (defn- #_"Box" Box'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Box" Box'new [#_"Object" val]
        (let [this (Box'init)]
            (§ ass this (assoc this :val val))
            this
        )
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (defn- #_"ChunkBuffer" ChunkBuffer'init []
        (hash-map
            #_"Object[]" :buffer nil
            #_"int" :end 0
        )
    )

    (defn #_"ChunkBuffer" ChunkBuffer'new [#_"int" capacity]
        (let [this (ChunkBuffer'init)]
            (§ ass this (assoc this :buffer (make-array Object capacity)))
            (§ ass this (assoc this :end 0))
            this
        )
    )

    #_method
    (defn #_"void" ChunkBuffer''add [#_"ChunkBuffer" this, #_"Object" o]
        (aset (:buffer this) (:end this) o)
        (§ ass this (assoc this :end (inc (:end this))))
        nil
    )

    #_method
    (defn #_"IChunk" ChunkBuffer''chunk [#_"ChunkBuffer" this]
        (let [#_"ArrayChunk" ret (ArrayChunk'new-3 (:buffer this), 0, (:end this))]
            (§ ass this (assoc this :buffer nil))
            ret
        )
    )

    #_override
    (defn #_"int" Counted'''count--ChunkBuffer [#_"ChunkBuffer" this]
        (:end this)
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (defn- #_"ChunkedCons" ChunkedCons'init []
        (hash-map
            #_"IChunk" :chunk nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-3 [#_"IPersistentMap" meta, #_"IChunk" chunk, #_"ISeq" more]
        (let [this (merge (ASeq'new-1 meta) (ChunkedCons'init))]
            (§ ass this (assoc this :chunk chunk))
            (§ ass this (assoc this :_more more))
            this
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-2 [#_"IChunk" chunk, #_"ISeq" more]
        (ChunkedCons'new-3 nil, chunk, more)
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--ChunkedCons [#_"ChunkedCons" this, #_"IPersistentMap" meta]
        (if (= meta (:_meta this))
            this
            (ChunkedCons'new-3 meta, (:chunk this), (:_more this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ChunkedCons [#_"ChunkedCons" this]
        (Indexed'''nth-2 (:chunk this), 0)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ChunkedCons [#_"ChunkedCons" this]
        (if (< 1 (.count (:chunk this)))
            (ChunkedCons'new-2 (IChunk'''dropFirst (:chunk this)), (:_more this))
            (IChunkedSeq'''chunkedNext this)
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''more--ChunkedCons [#_"ChunkedCons" this]
        (if (< 1 (.count (:chunk this)))
            (ChunkedCons'new-2 (IChunk'''dropFirst (:chunk this)), (:_more this))
            (or (:_more this) PersistentList'EMPTY)
        )
    )

    #_override
    (defn #_"IChunk" IChunkedSeq'''chunkedFirst--ChunkedCons [#_"ChunkedCons" this]
        (:chunk this)
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedNext--ChunkedCons [#_"ChunkedCons" this]
        (Seqable'''seq (IChunkedSeq'''chunkedMore this))
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedMore--ChunkedCons [#_"ChunkedCons" this]
        (or (:_more this) PersistentList'EMPTY)
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(def Context'enum-set
    (hash-set
        :Context'STATEMENT ;; value ignored
        :Context'EXPRESSION ;; value required
        :Context'RETURN ;; tail position relative to enclosing recur frame
        :Context'EVAL
    )
)

#_private
#_stateless
(class-ns Recur
)

#_stateless
#_abstract
(class-ns UntypedExpr (§ implements Expr)
    #_protected
    (defn #_"UntypedExpr" UntypedExpr'new []
        (hash-map)
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--UntypedExpr [#_"UntypedExpr" this]
        (throw (IllegalArgumentException. "Has no Java class"))
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--UntypedExpr [#_"UntypedExpr" this]
        false
    )
)

#_closure
(class-ns DefParser (§ implements IParser)
    (defn #_"DefParser" DefParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--DefParser [#_"DefParser" this, #_"Context" context, #_"Object" form]
        ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
        (let [[#_"String" docstring form]
                (when (and (= (RT'count form) 4) (instance? String (RT'third form))) => [nil form]
                    [(cast String (RT'third form)) (RT'list-3 (RT'first form), (RT'second form), (RT'fourth form))]
                )]
            (cond
                (< 3 (RT'count form))                       (throw (RuntimeException. "Too many arguments to def"))
                (< (RT'count form) 2)                       (throw (RuntimeException. "Too few arguments to def"))
                (not (§ instance? Symbol (RT'second form))) (throw (RuntimeException. "First argument to def must be a Symbol"))
            )
            (let [#_"Symbol" sym (cast' Symbol (RT'second form)) #_"Var" v (Compiler'lookupVar-2 sym, true)]
                (when (some? v) => (throw (RuntimeException. "Can't refer to qualified var that doesn't exist"))
                    (let [[v #_"boolean" shadowsCoreMapping]
                            (when (not (.equals (:ns v), (Compiler'currentNS))) => [v false]
                                (when (nil? (:ns sym)) => (throw (RuntimeException. "Can't create defs outside of current ns"))
                                    (let [v (Namespace''intern (Compiler'currentNS), sym)]
                                        (Compiler'registerVar v)
                                        [v true]
                                    )
                                )
                            )
                          #_"IPersistentMap" mm (IMeta'''meta sym)
                          #_"boolean" isDynamic (RT'booleanCast-1o (RT'get-2 mm, Compiler'dynamicKey))]
                        (when isDynamic
                            (Var''setDynamic v)
                        )
                        (when (and (not isDynamic) (.startsWith (:name sym), "*") (.endsWith (:name sym), "*") (< 2 (.length (:name sym))))
                            (.format (RT'errPrintWriter), "Warning: %s not declared dynamic and thus is not dynamically rebindable, but its name suggests otherwise. Please either indicate ^:dynamic or change the name.\n", (object-array [ sym ]))
                        )
                        (let [mm (cast' IPersistentMap (-> mm (RT'assoc RT'LINE_KEY, (Var''get Compiler'LINE)) (IPersistentMap'''assoc RT'COLUMN_KEY, (Var''get Compiler'COLUMN))))
                              mm (if (some? docstring) (cast' IPersistentMap (RT'assoc mm, RT'DOC_KEY, docstring)) mm)
                              #_"Expr" meta (when (pos? (.count mm)) (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), mm))]
                            (DefExpr'new (Compiler'lineDeref), (Compiler'columnDeref), v, (Compiler'analyze-3 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'third form), (:name (:sym v))), meta, (= (RT'count form) 3), isDynamic, shadowsCoreMapping)
                        )
                    )
                )
            )
        )
    )
)

(class-ns DefExpr (§ implements Expr)
    (def #_"Method" DefExpr'bindRootMethod (Method/getMethod "void bindRoot(Object)"))
    (def #_"Method" DefExpr'setTagMethod (Method/getMethod "void setTag(cloiure.lang.Symbol)"))
    (def #_"Method" DefExpr'setMetaMethod (Method/getMethod "void setMeta(cloiure.lang.IPersistentMap)"))
    (def #_"Method" DefExpr'setDynamicMethod (Method/getMethod "cloiure.lang.Var setDynamic(boolean)"))
    (def #_"Method" DefExpr'internVar (Method/getMethod "cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

    (defn- #_"DefExpr" DefExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Expr" :init nil
            #_"Expr" :meta nil
            #_"boolean" :initProvided false
            #_"boolean" :isDynamic false
            #_"boolean" :shadowsCoreMapping false
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"DefExpr" DefExpr'new [#_"int" line, #_"int" column, #_"Var" var, #_"Expr" init, #_"Expr" meta, #_"boolean" initProvided, #_"boolean" isDynamic, #_"boolean" shadowsCoreMapping]
        (let [this (DefExpr'init)]
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :var var))
            (§ ass this (assoc this :init init))
            (§ ass this (assoc this :meta meta))
            (§ ass this (assoc this :isDynamic isDynamic))
            (§ ass this (assoc this :shadowsCoreMapping shadowsCoreMapping))
            (§ ass this (assoc this :initProvided initProvided))
            this
        )
    )

    #_method
    (defn- #_"boolean" DefExpr''includesExplicitMetadata [#_"DefExpr" this, #_"MapExpr" expr]
        (loop-when [#_"int" i 0] (< i (.count (:keyvals expr))) => false
            (let [#_"Keyword" k (:k (cast' KeywordExpr (Indexed'''nth-2 (:keyvals expr), i)))]
                (recur-if (any = k RT'DECLARED_KEY RT'LINE_KEY RT'COLUMN_KEY) [(+ i 2)] => true)
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--DefExpr [#_"DefExpr" this]
        (try
            (when (:initProvided this)
                (Var''bindRoot (:var this), (Expr'''eval (:init this)))
            )
            (when (some? (:meta this))
                (let [#_"IPersistentMap" metaMap (cast' IPersistentMap (Expr'''eval (:meta this)))]
                    (when (or (:initProvided this) true)
                        (Var''setMeta (:var this), metaMap)
                    )
                )
            )
            (Var''setDynamic (:var this), (:isDynamic this))
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--DefExpr [#_"DefExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitVar objx, gen, (:var this))
        (when (:shadowsCoreMapping this)
            (.dup gen)
            (.getField gen, Compiler'VAR_TYPE, "ns", Compiler'NS_TYPE)
            (.swap gen)
            (.dup gen)
            (.getField gen, Compiler'VAR_TYPE, "sym", Compiler'SYMBOL_TYPE)
            (.swap gen)
            (.invokeVirtual gen, Compiler'NS_TYPE, DefExpr'internVar)
        )
        (when (:isDynamic this)
            (.push gen, (:isDynamic this))
            (.invokeVirtual gen, Compiler'VAR_TYPE, DefExpr'setDynamicMethod)
        )
        (when (some? (:meta this))
            (.dup gen)
            (Expr'''emit (:meta this), :Context'EXPRESSION, objx, gen)
            (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
            (.invokeVirtual gen, Compiler'VAR_TYPE, DefExpr'setMetaMethod)
        )
        (when (:initProvided this)
            (.dup gen)
            (if (§ instance? FnExpr (:init this))
                (FnExpr''emitForDefn (cast' FnExpr (:init this)), objx, gen)
                (Expr'''emit (:init this), :Context'EXPRESSION, objx, gen)
            )
            (.invokeVirtual gen, Compiler'VAR_TYPE, DefExpr'bindRootMethod)
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--DefExpr [#_"DefExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--DefExpr [#_"DefExpr" this]
        (§ class Var)
    )
)

#_closure
(class-ns AssignParser (§ implements IParser)
    (defn #_"AssignParser" AssignParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--AssignParser [#_"AssignParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            (when-not (= (RT'length form) 3)
                (throw (IllegalArgumentException. "Malformed assignment, expecting (set! target val)"))
            )
            (let [#_"Expr" target (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form))]
                (when (not (§ instance? AssignableExpr target))
                    (throw (IllegalArgumentException. "Invalid assignment target"))
                )
                (AssignExpr'new (cast' AssignableExpr target), (Compiler'analyze-2 :Context'EXPRESSION, (RT'third form)))
            )
        )
    )
)

(class-ns AssignExpr (§ implements Expr)
    (defn- #_"AssignExpr" AssignExpr'init []
        (hash-map
            #_"AssignableExpr" :target nil
            #_"Expr" :val nil
        )
    )

    (defn #_"AssignExpr" AssignExpr'new [#_"AssignableExpr" target, #_"Expr" val]
        (let [this (AssignExpr'init)]
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--AssignExpr [#_"AssignExpr" this]
        (AssignableExpr'''evalAssign (:target this), (:val this))
    )

    #_override
    (defn #_"void" Expr'''emit--AssignExpr [#_"AssignExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (AssignableExpr'''emitAssign (:target this), context, objx, gen, (:val this))
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--AssignExpr [#_"AssignExpr" this]
        (Expr'''hasJavaClass (:val this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--AssignExpr [#_"AssignExpr" this]
        (Expr'''getJavaClass (:val this))
    )
)

(class-ns VarExpr (§ implements Expr, AssignableExpr)
    (def #_"Method" VarExpr'getMethod (Method/getMethod "Object get()"))
    (def #_"Method" VarExpr'setMethod (Method/getMethod "Object set(Object)"))

    (defn- #_"VarExpr" VarExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"VarExpr" VarExpr'new [#_"Var" var, #_"Symbol" tag]
        (let [this (VarExpr'init)]
            (§ ass this (assoc this :var var))
            (§ ass this (assoc this :tag (or tag (Var''getTag var))))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--VarExpr [#_"VarExpr" this]
        (IDeref'''deref (:var this))
    )

    #_override
    (defn #_"void" Expr'''emit--VarExpr [#_"VarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitVarValue objx, gen, (:var this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--VarExpr [#_"VarExpr" this]
        (some? (:tag this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--VarExpr [#_"VarExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (HostExpr'tagToClass (:tag this))))
        )
        (:jc this)
    )

    #_override
    (defn #_"Object" AssignableExpr'''evalAssign--VarExpr [#_"VarExpr" this, #_"Expr" val]
        (Var''set (:var this), (Expr'''eval val))
    )

    #_override
    (defn #_"void" AssignableExpr'''emitAssign--VarExpr [#_"VarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (ObjExpr''emitVar objx, gen, (:var this))
        (Expr'''emit val, :Context'EXPRESSION, objx, gen)
        (.invokeVirtual gen, Compiler'VAR_TYPE, VarExpr'setMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

#_closure
(class-ns TheVarParser (§ implements IParser)
    (defn #_"TheVarParser" TheVarParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--TheVarParser [#_"TheVarParser" this, #_"Context" context, #_"Object" form]
        (let [#_"Symbol" sym (cast' Symbol (RT'second form)) #_"Var" v (Compiler'lookupVar-2 sym, false)]
            (when (some? v) => (throw (RuntimeException. (str "Unable to resolve var: " sym " in this context")))
                (TheVarExpr'new v)
            )
        )
    )
)

(class-ns TheVarExpr (§ implements Expr)
    (defn- #_"TheVarExpr" TheVarExpr'init []
        (hash-map
            #_"Var" :var nil
        )
    )

    (defn #_"TheVarExpr" TheVarExpr'new [#_"Var" var]
        (let [this (TheVarExpr'init)]
            (§ ass this (assoc this :var var))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--TheVarExpr [#_"TheVarExpr" this]
        (:var this)
    )

    #_override
    (defn #_"void" Expr'''emit--TheVarExpr [#_"TheVarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitVar objx, gen, (:var this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--TheVarExpr [#_"TheVarExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--TheVarExpr [#_"TheVarExpr" this]
        (§ class Var)
    )
)

(class-ns KeywordExpr (§ extends LiteralExpr)
    (defn- #_"KeywordExpr" KeywordExpr'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordExpr" KeywordExpr'new [#_"Keyword" k]
        (let [this (merge (LiteralExpr'new) (KeywordExpr'init))]
            (§ ass this (assoc this :k k))
            this
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--KeywordExpr [#_"KeywordExpr" this]
        (:k this)
    )

    #_override
    (defn #_"Object" Expr'''eval--KeywordExpr [#_"KeywordExpr" this]
        (:k this)
    )

    #_override
    (defn #_"void" Expr'''emit--KeywordExpr [#_"KeywordExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitKeyword objx, gen, (:k this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--KeywordExpr [#_"KeywordExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--KeywordExpr [#_"KeywordExpr" this]
        (§ class Keyword)
    )
)

#_closure
(class-ns ImportParser (§ implements IParser)
    (defn #_"ImportParser" ImportParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--ImportParser [#_"ImportParser" this, #_"Context" context, #_"Object" form]
        (ImportExpr'new (cast String (RT'second form)))
    )
)

(class-ns ImportExpr (§ implements Expr)
    (def #_"Method" ImportExpr'forNameMethod (Method/getMethod "Class classForNameNonLoading(String)"))
    (def #_"Method" ImportExpr'importClassMethod (Method/getMethod "Class importClass(Class)"))
    (def #_"Method" ImportExpr'derefMethod (Method/getMethod "Object deref()"))

    (defn- #_"ImportExpr" ImportExpr'init []
        (hash-map
            #_"String" :c nil
        )
    )

    (defn #_"ImportExpr" ImportExpr'new [#_"String" c]
        (let [this (ImportExpr'init)]
            (§ ass this (assoc this :c c))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--ImportExpr [#_"ImportExpr" this]
        (let [#_"Namespace" ns (cast' Namespace (IDeref'''deref RT'CURRENT_NS))]
            (Namespace''importClass ns, (RT'classForNameNonLoading (:c this)))
            nil
        )
    )

    #_override
    (defn #_"void" Expr'''emit--ImportExpr [#_"ImportExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.getStatic gen, Compiler'RT_TYPE, "CURRENT_NS", Compiler'VAR_TYPE)
        (.invokeVirtual gen, Compiler'VAR_TYPE, ImportExpr'derefMethod)
        (.checkCast gen, Compiler'NS_TYPE)
        (.push gen, (:c this))
        (.invokeStatic gen, Compiler'RT_TYPE, ImportExpr'forNameMethod)
        (.invokeVirtual gen, Compiler'NS_TYPE, ImportExpr'importClassMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--ImportExpr [#_"ImportExpr" this]
        false
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--ImportExpr [#_"ImportExpr" this]
        (throw (IllegalArgumentException. "ImportExpr has no Java class"))
    )
)

#_stateless
#_abstract
(class-ns LiteralExpr (§ implements Expr)
    #_protected
    (defn #_"LiteralExpr" LiteralExpr'new []
        (hash-map)
    )

    #_abstract
    (defn #_"Object" LiteralExpr'''val [#_"LiteralExpr" this])

    #_override
    (defn #_"Object" Expr'''eval--LiteralExpr [#_"LiteralExpr" this]
        (LiteralExpr'''val this)
    )
)

#_closure
(class-ns HostParser (§ implements IParser)
    (defn #_"HostParser" HostParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--HostParser [#_"HostParser" this, #_"Context" context, #_"Object" frm]
        ;; (. x fieldname-sym) or
        ;; (. x 0-ary-method)
        ;; (. x methodname-sym args+)
        ;; (. x (methodname-sym args?))
        (let [#_"ISeq" form (cast' ISeq frm)]
            (when-not (< (RT'length form) 3) => (throw (IllegalArgumentException. "Malformed member expression, expecting (. target member ...)"))
                ;; determine static or instance
                ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
                (let [#_"int" line (Compiler'lineDeref) #_"int" column (Compiler'columnDeref) #_"Class" c (HostExpr'maybeClass (RT'second form), false)
                      ;; at this point c will be non-null if static
                      #_"Expr" instance (when (nil? c) (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'second form)))
                      #_"boolean" maybeField (and (= (RT'length form) 3) (§ instance? Symbol (RT'third form)))
                      maybeField
                        (when (and maybeField (not= (.charAt (:name (cast' Symbol (RT'third form))), 0) \-)) => maybeField
                            (let [#_"Symbol" sym (cast' Symbol (RT'third form))]
                                (cond
                                    (some? c)
                                        (zero? (.size (Reflector'getMethods c, 0, (Compiler'munge (:name sym)), true)))
                                    (and (some? instance) (Expr'''hasJavaClass instance) (some? (Expr'''getJavaClass instance)))
                                        (zero? (.size (Reflector'getMethods (Expr'''getJavaClass instance), 0, (Compiler'munge (:name sym)), false)))
                                    :else
                                        maybeField
                                )
                            )
                        )]
                    (if maybeField
                        (let [? (= (.charAt (:name (cast' Symbol (RT'third form))), 0) \-)
                              #_"Symbol" sym (if ? (Symbol'intern (.substring (:name (cast' Symbol (RT'third form))), 1)) (cast' Symbol (RT'third form)))
                              #_"Symbol" tag (Compiler'tagOf form)]
                            (if (some? c)
                                (StaticFieldExpr'new line, column, c, (Compiler'munge (:name sym)), tag)
                                (InstanceFieldExpr'new line, column, instance, (Compiler'munge (:name sym)), tag, ?)
                            )
                        )
                        (let [#_"ISeq" call (cast' ISeq (if (§ instance? ISeq (RT'third form)) (RT'third form) (RT'next (RT'next form))))]
                            (when (§ instance? Symbol (RT'first call)) => (throw (IllegalArgumentException. "Malformed member expression"))
                                (let [#_"Symbol" sym (cast' Symbol (RT'first call))
                                      #_"Symbol" tag (Compiler'tagOf form)
                                      #_"boolean" tailPosition (Compiler'inTailCall context)
                                      #_"PersistentVector" args
                                        (loop-when-recur [args PersistentVector'EMPTY #_"ISeq" s (RT'next call)]
                                                         (some? s)
                                                         [(IPersistentVector'''cons args, (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.first s))) (.next s)]
                                                      => args
                                        )]
                                    (if (some? c)
                                        (StaticMethodExpr'new line, column, tag, c, (Compiler'munge (:name sym)), args, tailPosition)
                                        (InstanceMethodExpr'new line, column, tag, instance, (Compiler'munge (:name sym)), args, tailPosition)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
#_abstract
(class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
    #_protected
    (defn #_"HostExpr" HostExpr'new []
        (hash-map)
    )

    (def #_"Type" HostExpr'BOOLEAN_TYPE (Type/getType Boolean))
    (def #_"Type" HostExpr'CHAR_TYPE (Type/getType Character))
    (def #_"Type" HostExpr'INTEGER_TYPE (Type/getType Integer))
    (def #_"Type" HostExpr'LONG_TYPE (Type/getType Long))
    (def #_"Type" HostExpr'FLOAT_TYPE (Type/getType Float))
    (def #_"Type" HostExpr'DOUBLE_TYPE (Type/getType Double))
    (def #_"Type" HostExpr'SHORT_TYPE (Type/getType Short))
    (def #_"Type" HostExpr'BYTE_TYPE (Type/getType Byte))
    (def #_"Type" HostExpr'NUMBER_TYPE (Type/getType Number))

    (def #_"Method" HostExpr'charValueMethod (Method/getMethod "char charValue()"))
    (def #_"Method" HostExpr'booleanValueMethod (Method/getMethod "boolean booleanValue()"))

    (def #_"Method" HostExpr'charValueOfMethod (Method/getMethod "Character valueOf(char)"))
    (def #_"Method" HostExpr'intValueOfMethod (Method/getMethod "Integer valueOf(int)"))
    (def #_"Method" HostExpr'longValueOfMethod (Method/getMethod "Long valueOf(long)"))
    (def #_"Method" HostExpr'floatValueOfMethod (Method/getMethod "Float valueOf(float)"))
    (def #_"Method" HostExpr'doubleValueOfMethod (Method/getMethod "Double valueOf(double)"))
    (def #_"Method" HostExpr'shortValueOfMethod (Method/getMethod "Short valueOf(short)"))
    (def #_"Method" HostExpr'byteValueOfMethod (Method/getMethod "Byte valueOf(byte)"))

    (def #_"Method" HostExpr'intValueMethod (Method/getMethod "int intValue()"))
    (def #_"Method" HostExpr'longValueMethod (Method/getMethod "long longValue()"))
    (def #_"Method" HostExpr'floatValueMethod (Method/getMethod "float floatValue()"))
    (def #_"Method" HostExpr'doubleValueMethod (Method/getMethod "double doubleValue()"))
    (def #_"Method" HostExpr'byteValueMethod (Method/getMethod "byte byteValue()"))
    (def #_"Method" HostExpr'shortValueMethod (Method/getMethod "short shortValue()"))

    (def #_"Method" HostExpr'fromIntMethod (Method/getMethod "cloiure.lang.Num from(int)"))
    (def #_"Method" HostExpr'fromLongMethod (Method/getMethod "cloiure.lang.Num from(long)"))
    (def #_"Method" HostExpr'fromDoubleMethod (Method/getMethod "cloiure.lang.Num from(double)"))

    (defn #_"void" HostExpr'emitBoxReturn [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" returnType]
        (when (.isPrimitive returnType)
            (condp = returnType
                Boolean/TYPE
                    (let [#_"Label" falseLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)]
                        (.ifZCmp gen, GeneratorAdapter/EQ, falseLabel)
                        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE)
                        (.goTo gen, endLabel)
                        (.mark gen, falseLabel)
                        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                        (.mark gen, endLabel)
                    )
                Void/TYPE      (Expr'''emit Compiler'NIL_EXPR, :Context'EXPRESSION, objx, gen)
                Character/TYPE (.invokeStatic gen, HostExpr'CHAR_TYPE, HostExpr'charValueOfMethod)
                Integer/TYPE   (.invokeStatic gen, HostExpr'INTEGER_TYPE, HostExpr'intValueOfMethod)
                Float/TYPE     (.invokeStatic gen, HostExpr'FLOAT_TYPE, HostExpr'floatValueOfMethod)
                Double/TYPE    (.invokeStatic gen, HostExpr'DOUBLE_TYPE, HostExpr'doubleValueOfMethod)
                Long/TYPE      (.invokeStatic gen, Compiler'NUMBERS_TYPE, (Method/getMethod "Number num(long)"))
                Byte/TYPE      (.invokeStatic gen, HostExpr'BYTE_TYPE, HostExpr'byteValueOfMethod)
                Short/TYPE     (.invokeStatic gen, HostExpr'SHORT_TYPE, HostExpr'shortValueOfMethod)
            )
        )
        nil
    )

    (defn #_"void" HostExpr'emitUnboxArg [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" paramType]
        (when (.isPrimitive paramType) => (.checkCast gen, (Type/getType paramType))
            (condp = paramType
                Boolean/TYPE
                (do
                    (.checkCast gen, HostExpr'BOOLEAN_TYPE)
                    (.invokeVirtual gen, HostExpr'BOOLEAN_TYPE, HostExpr'booleanValueMethod)
                )
                Character/TYPE
                (do
                    (.checkCast gen, HostExpr'CHAR_TYPE)
                    (.invokeVirtual gen, HostExpr'CHAR_TYPE, HostExpr'charValueMethod)
                )
                (do
                    (.checkCast gen, HostExpr'NUMBER_TYPE)
                    (let [#_"Method" m
                            (condp = paramType
                                Integer/TYPE (Method/getMethod "int intCast(Object)")
                                Float/TYPE   (Method/getMethod "float floatCast(Object)")
                                Double/TYPE  (Method/getMethod "double doubleCast(Object)")
                                Long/TYPE    (Method/getMethod "long longCast(Object)")
                                Byte/TYPE    (Method/getMethod "byte byteCast(Object)")
                                Short/TYPE   (Method/getMethod "short shortCast(Object)")
                                             nil
                            )]
                        (.invokeStatic gen, Compiler'RT_TYPE, m)
                    )
                )
            )
        )
        nil
    )

    (defn #_"Class" HostExpr'maybeClass [#_"Object" form, #_"boolean" stringOk]
        (cond
            (instance? Class form)
                (cast Class form)
            (§ instance? Symbol form)
                (let-when [#_"Symbol" sym (cast' Symbol form)] (nil? (:ns sym)) ;; if ns-qualified can't be classname
                    (cond
                        (Util'equals sym, (Var''get Compiler'COMPILE_STUB_SYM))
                            (cast Class (Var''get Compiler'COMPILE_STUB_CLASS))
                        (or (pos? (.indexOf (:name sym), \.)) (= (.charAt (:name sym), 0) \[))
                            (RT'classForNameNonLoading (:name sym))
                        :else
                            (let [#_"Object" o (Namespace''getMapping (Compiler'currentNS), sym)]
                                (cond
                                    (instance? Class o)
                                        (cast Class o)
                                    (and (some? (IDeref'''deref Compiler'LOCAL_ENV)) (.containsKey (cast java.util.Map (IDeref'''deref Compiler'LOCAL_ENV)), form))
                                        nil
                                    :else
                                        (try
                                            (RT'classForNameNonLoading (:name sym))
                                            (catch Exception _
                                                nil
                                            )
                                        )
                                )
                            )
                    )
                )
            (and stringOk (instance? String form))
                (RT'classForNameNonLoading (cast String form))
        )
    )

    (defn #_"Class" HostExpr'maybeSpecialTag [#_"Symbol" sym]
        (or (Compiler'primClass-1s sym)
            (case (:name sym)
                "objects"  (§ class Object[])
                "ints"     (§ class int[])
                "longs"    (§ class long[])
                "floats"   (§ class float[])
                "doubles"  (§ class double[])
                "chars"    (§ class char[])
                "shorts"   (§ class short[])
                "bytes"    (§ class byte[])
                "booleans" (§ class boolean[])
                           nil
            )
        )
    )

    (defn #_"Class" HostExpr'tagToClass [#_"Object" tag]
        (or
            (when (§ instance? Symbol tag)
                (let-when [#_"Symbol" sym (cast' Symbol tag)] (nil? (:ns sym)) ;; if ns-qualified can't be classname
                    (HostExpr'maybeSpecialTag sym)
                )
            )
            (HostExpr'maybeClass tag, true)
            (throw (IllegalArgumentException. (str "Unable to resolve classname: " tag)))
        )
    )
)

#_stateless
#_abstract
(class-ns FieldExpr (§ extends HostExpr)
    #_protected
    (defn #_"FieldExpr" FieldExpr'new []
        (HostExpr'new)
    )

)

(class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (def #_"Method" InstanceFieldExpr'invokeNoArgInstanceMember (Method/getMethod "Object invokeNoArgInstanceMember(Object, String, boolean)"))
    (def #_"Method" InstanceFieldExpr'setInstanceFieldMethod (Method/getMethod "Object setInstanceField(Object, String, Object)"))

    (defn- #_"InstanceFieldExpr" InstanceFieldExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"Class" :targetClass nil
            #_"java.lang.reflect.Field" :field nil
            #_"String" :fieldName nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :requireField false

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceFieldExpr" InstanceFieldExpr'new [#_"int" line, #_"int" column, #_"Expr" target, #_"String" fieldName, #_"Symbol" tag, #_"boolean" requireField]
        (let [this (merge (FieldExpr'new) (InstanceFieldExpr'init))]
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :targetClass (when (Expr'''hasJavaClass target) (Expr'''getJavaClass target))))
            (§ ass this (assoc this :field (when (some? (:targetClass this)) (Reflector'getField (:targetClass this), fieldName, false))))
            (§ ass this (assoc this :fieldName fieldName))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :requireField requireField))

            (when (and (nil? (:field this)) (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION)))
                (if (nil? (:targetClass this))
                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - reference to field %s can't be resolved.\n", (object-array [ line, column, fieldName ]))
                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - reference to field %s on %s can't be resolved.\n", (object-array [ line, column, fieldName, (.getName (:targetClass this)) ]))
                )
            )
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--InstanceFieldExpr [#_"InstanceFieldExpr" this]
        (Reflector'invokeNoArgInstanceMember (Expr'''eval (:target this)), (:fieldName this), (:requireField this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--InstanceFieldExpr [#_"InstanceFieldExpr" this]
        (and (some? (:targetClass this)) (some? (:field this)) (Util'isPrimitive (.getType (:field this))))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--InstanceFieldExpr [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (and (some? (:targetClass this)) (some? (:field this))) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
            (.visitLineNumber gen, (:line this), (.mark gen))
            (.checkCast gen, (Compiler'getType (:targetClass this)))
            (.getField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--InstanceFieldExpr [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.checkCast gen, (Compiler'getType (:targetClass this)))
                (.getField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
                (HostExpr'emitBoxReturn objx, gen, (.getType (:field this)))
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
            (do
                (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.push gen, (:fieldName this))
                (.push gen, (:requireField this))
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceFieldExpr'invokeNoArgInstanceMember)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--InstanceFieldExpr [#_"InstanceFieldExpr" this]
        (or (some? (:field this)) (some? (:tag this)))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--InstanceFieldExpr [#_"InstanceFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this)))))
        )
        (:jc this)
    )

    #_override
    (defn #_"Object" AssignableExpr'''evalAssign--InstanceFieldExpr [#_"InstanceFieldExpr" this, #_"Expr" val]
        (Reflector'setInstanceField (Expr'''eval (:target this)), (:fieldName this), (Expr'''eval val))
    )

    #_override
    (defn #_"void" AssignableExpr'''emitAssign--InstanceFieldExpr [#_"InstanceFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (if (and (some? (:targetClass this)) (some? (:field this)))
            (do
                (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, (Compiler'getType (:targetClass this)))
                (Expr'''emit val, :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.dupX1 gen)
                (HostExpr'emitUnboxArg objx, gen, (.getType (:field this)))
                (.putField gen, (Compiler'getType (:targetClass this)), (:fieldName this), (Type/getType (.getType (:field this))))
            )
            (do
                (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
                (.push gen, (:fieldName this))
                (Expr'''emit val, :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceFieldExpr'setInstanceFieldMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

(class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (defn- #_"StaticFieldExpr" StaticFieldExpr'init []
        (hash-map
            #_"String" :fieldName nil
            #_"Class" :c nil
            #_"java.lang.reflect.Field" :field nil
            #_"Symbol" :tag nil

            #_"int" :line 0
            #_"int" :column 0

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticFieldExpr" StaticFieldExpr'new [#_"int" line, #_"int" column, #_"Class" c, #_"String" fieldName, #_"Symbol" tag]
        (let [this (merge (FieldExpr'new) (StaticFieldExpr'init))]
            (§ ass this (assoc this :fieldName fieldName))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :c c))
            (try
                (§ ass this (assoc this :field (.getField c, fieldName)))
                (catch NoSuchFieldException e
                    (throw (Util'sneakyThrow e))
                )
            )
            (§ ass this (assoc this :tag tag))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--StaticFieldExpr [#_"StaticFieldExpr" this]
        (Reflector'getStaticField-2c (:c this), (:fieldName this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--StaticFieldExpr [#_"StaticFieldExpr" this]
        (Util'isPrimitive (.getType (:field this)))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--StaticFieldExpr [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitLineNumber gen, (:line this), (.mark gen))
        (.getStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--StaticFieldExpr [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitLineNumber gen, (:line this), (.mark gen))

        (.getStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        (HostExpr'emitBoxReturn objx, gen, (.getType (:field this)))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--StaticFieldExpr [#_"StaticFieldExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--StaticFieldExpr [#_"StaticFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (.getType (:field this)))))
        )
        (:jc this)
    )

    #_override
    (defn #_"Object" AssignableExpr'''evalAssign--StaticFieldExpr [#_"StaticFieldExpr" this, #_"Expr" val]
        (Reflector'setStaticField-3c (:c this), (:fieldName this), (Expr'''eval val))
    )

    #_override
    (defn #_"void" AssignableExpr'''emitAssign--StaticFieldExpr [#_"StaticFieldExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (Expr'''emit val, :Context'EXPRESSION, objx, gen)
        (.visitLineNumber gen, (:line this), (.mark gen))
        (.dup gen)
        (HostExpr'emitUnboxArg objx, gen, (.getType (:field this)))
        (.putStatic gen, (Type/getType (:c this)), (:fieldName this), (Type/getType (.getType (:field this))))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )
)

#_stateless
#_abstract
(class-ns MethodExpr (§ extends HostExpr)
    #_protected
    (defn #_"MethodExpr" MethodExpr'new []
        (HostExpr'new)
    )

    (defn #_"void" MethodExpr'emitArgsAsArray [#_"IPersistentVector" args, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.push gen, (.count args))
        (.newArray gen, Compiler'OBJECT_TYPE)
        (dotimes [#_"int" i (.count args)]
            (.dup gen)
            (.push gen, i)
            (Expr'''emit (cast' Expr (Indexed'''nth-2 args, i)), :Context'EXPRESSION, objx, gen)
            (.arrayStore gen, Compiler'OBJECT_TYPE)
        )
        nil
    )

    (defn #_"void" MethodExpr'emitTypedArgs [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class[]" parameterTypes, #_"IPersistentVector" args]
        (dotimes [#_"int" i (alength parameterTypes)]
            (let [#_"Expr" e (cast' Expr (Indexed'''nth-2 args, i))]
                (try
                    (let [#_"Class" primc (Compiler'maybePrimitiveType e)]
                        (cond
                            (= primc (aget parameterTypes i))
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (MaybePrimitiveExpr'''emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                )
                            (and (= primc Integer/TYPE) (= (aget parameterTypes i) Long/TYPE))
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (MaybePrimitiveExpr'''emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/I2L)
                                )
                            (and (= primc Long/TYPE) (= (aget parameterTypes i) Integer/TYPE))
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (MaybePrimitiveExpr'''emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                    (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                                )
                            (and (= primc Float/TYPE) (= (aget parameterTypes i) Double/TYPE))
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (MaybePrimitiveExpr'''emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/F2D)
                                )
                            (and (= primc Double/TYPE) (= (aget parameterTypes i) Float/TYPE))
                                (let [#_"MaybePrimitiveExpr" pe (cast' MaybePrimitiveExpr e)]
                                    (MaybePrimitiveExpr'''emitUnboxed pe, :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/D2F)
                                )
                            :else
                                (do
                                    (Expr'''emit e, :Context'EXPRESSION, objx, gen)
                                    (HostExpr'emitUnboxArg objx, gen, (aget parameterTypes i))
                                )
                        )
                    )
                    (catch Exception e1
                        (throw (Util'sneakyThrow e1))
                    )
                )
            )
        )
        nil
    )
)

(class-ns InstanceMethodExpr (§ extends MethodExpr)
    (def #_"Method" InstanceMethodExpr'invokeInstanceMethodMethod (Method/getMethod "Object invokeInstanceMethod(Object, String, Object[])"))

    (defn- #_"InstanceMethodExpr" InstanceMethodExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false
            #_"java.lang.reflect.Method" :method nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceMethodExpr" InstanceMethodExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" target, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [this (merge (MethodExpr'new) (InstanceMethodExpr'init))]
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :methodName methodName))
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :tailPosition tailPosition))
            (if (and (Expr'''hasJavaClass target) (some? (Expr'''getJavaClass target)))
                (let [#_"List" methods (Reflector'getMethods (Expr'''getJavaClass target), (.count args), methodName, false)]
                    (if (.isEmpty methods)
                        (do
                            (§ ass this (assoc this :method nil))
                            (when (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION))
                                (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s on %s can't be resolved (no such method).\n", (object-array [ line, column, methodName, (.getName (Expr'''getJavaClass target)) ]))
                            )
                        )
                        (let [#_"int" methodidx 0]
                            (when (< 1 (.size methods))
                                (let [#_"ArrayList<Class[]>" params (ArrayList.) #_"ArrayList<Class>" rets (ArrayList.)]
                                    (dotimes [#_"int" i (.size methods)]
                                        (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.get methods, i))]
                                            (.add params, (.getParameterTypes m))
                                            (.add rets, (.getReturnType m))
                                        )
                                    )
                                    (§ ass methodidx (Compiler'getMatchingParams methodName, params, args, rets))
                                )
                            )
                            (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (when (<= 0 methodidx) (.get methods, methodidx)))]
                                (when (and (some? m) (not (Modifier/isPublic (.getModifiers (.getDeclaringClass m)))))
                                    ;; public method of non-public class, try to find it in hierarchy
                                    (§ ass m (Reflector'getAsMethodOfPublicBase (.getDeclaringClass m), m))
                                )
                                (§ ass this (assoc this :method m))
                                (when (and (nil? (:method this)) (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION)))
                                    (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", (object-array [ line, column, methodName, (.getName (Expr'''getJavaClass target)), (Compiler'getTypeStringForArgs args) ]))
                                )
                            )
                        )
                    )
                )
                (do
                    (§ ass this (assoc this :method nil))
                    (when (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION))
                        (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to method %s can't be resolved (target class is unknown).\n", (object-array [ line, column, methodName ]))
                    )
                )
            )
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--InstanceMethodExpr [#_"InstanceMethodExpr" this]
        (try
            (let [#_"Object" target (Expr'''eval (:target this)) #_"Object[]" args (make-array Object (.count (:args this)))]
                (dotimes [#_"int" i (.count (:args this))]
                    (aset args i (Expr'''eval (cast' Expr (Indexed'''nth-2 (:args this), i))))
                )
                (if (some? (:method this))
                    (let [#_"LinkedList" ms (LinkedList.)]
                        (.add ms, (:method this))
                        (Reflector'invokeMatchingMethod (:methodName this), ms, target, args)
                    )
                    (Reflector'invokeInstanceMethod target, (:methodName this), args)
                )
            )
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--InstanceMethodExpr [#_"InstanceMethodExpr" this]
        (and (some? (:method this)) (Util'isPrimitive (.getReturnType (:method this))))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--InstanceMethodExpr [#_"InstanceMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (let [#_"Type" type (Type/getType (.getDeclaringClass (:method this)))]
                (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, type)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (and (:tailPosition this) (not (:canBeDirect objx)))
                    (ObjMethod''emitClearThis (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
                )
                (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                    (if (.isInterface (.getDeclaringClass (:method this)))
                        (.invokeInterface gen, type, m)
                        (.invokeVirtual gen, type, m)
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--InstanceMethodExpr [#_"InstanceMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:method this))
            (let [#_"Type" type (Type/getType (.getDeclaringClass (:method this)))]
                (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, type)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (ObjMethod''emitClearLocals (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
                )
                (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                    (if (.isInterface (.getDeclaringClass (:method this)))
                        (.invokeInterface gen, type, m)
                        (.invokeVirtual gen, type, m)
                    )
                    (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:method this)))
                )
            )
            (do
                (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
                (.push gen, (:methodName this))
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (ObjMethod''emitClearLocals (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
                )
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, InstanceMethodExpr'invokeInstanceMethodMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--InstanceMethodExpr [#_"InstanceMethodExpr" this]
        (or (some? (:method this)) (some? (:tag this)))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--InstanceMethodExpr [#_"InstanceMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (when (some? (:method this)) (.getReturnType (:method this))))))
        )
        (:jc this)
    )
)

(class-ns StaticMethodExpr (§ extends MethodExpr)
    (def #_"Method" StaticMethodExpr'forNameMethod (Method/getMethod "Class classForName(String)"))
    (def #_"Method" StaticMethodExpr'invokeStaticMethodMethod (Method/getMethod "Object invokeStaticMethod(Class, String, Object[])"))

    (defn- #_"StaticMethodExpr" StaticMethodExpr'init []
        (hash-map
            #_"Class" :c nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"java.lang.reflect.Method" :method nil
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticMethodExpr" StaticMethodExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Class" c, #_"String" methodName, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [this (merge (MethodExpr'new) (StaticMethodExpr'init))]
            (§ ass this (assoc this :c c))
            (§ ass this (assoc this :methodName methodName))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :tailPosition tailPosition))

            (let [#_"List" methods (Reflector'getMethods c, (.count args), methodName, true)]
                (when (.isEmpty methods)
                    (throw (IllegalArgumentException. (str "No matching method: " methodName)))
                )

                (let [#_"int" methodidx 0]
                    (when (< 1 (.size methods))
                        (let [#_"ArrayList<Class[]>" params (ArrayList.) #_"ArrayList<Class>" rets (ArrayList.)]
                            (dotimes [#_"int" i (.size methods)]
                                (let [#_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.get methods, i))]
                                    (.add params, (.getParameterTypes m))
                                    (.add rets, (.getReturnType m))
                                )
                            )
                            (§ ass methodidx (Compiler'getMatchingParams methodName, params, args, rets))
                        )
                    )
                    (§ ass this (assoc this :method (cast java.lang.reflect.Method (when (<= 0 methodidx) (.get methods, methodidx)))))
                    (when (and (nil? (:method this)) (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION)))
                        (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", (object-array [ line, column, methodName, (.getName c), (Compiler'getTypeStringForArgs args) ]))
                    )
                    this
                )
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--StaticMethodExpr [#_"StaticMethodExpr" this]
        (try
            (let [#_"Object[]" args (make-array Object (.count (:args this)))]
                (dotimes [#_"int" i (.count (:args this))]
                    (aset args i (Expr'''eval (cast' Expr (Indexed'''nth-2 (:args this), i))))
                )
                (if (some? (:method this))
                    (let [#_"LinkedList" ms (LinkedList.)]
                        (.add ms, (:method this))
                        (Reflector'invokeMatchingMethod (:methodName this), ms, nil, args)
                    )
                    (Reflector'invokeStaticMethod-3c (:c this), (:methodName this), args)
                )
            )
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--StaticMethodExpr [#_"StaticMethodExpr" this]
        (and (some? (:method this)) (Util'isPrimitive (.getReturnType (:method this))))
    )

    #_method
    (defn #_"boolean" StaticMethodExpr''canEmitIntrinsicPredicate [#_"StaticMethodExpr" this]
        (and (some? (:method this)) (some? (RT'get-2 Intrinsics'preds, (.toString (:method this)))))
    )

    #_method
    (defn #_"void" StaticMethodExpr''emitIntrinsicPredicate [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Label" falseLabel]
        (.visitLineNumber gen, (:line this), (.mark gen))
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
            (when (= context :Context'RETURN)
                (ObjMethod''emitClearLocals (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
            )
            (let [#_"Object[]" predOps (§ cast Object[] (RT'get-2 Intrinsics'preds, (.toString (:method this))))]
                (dotimes [#_"int" i (dec (§ unsure alength predOps))]
                    (.visitInsn gen, (cast Integer (§ unsure aget predOps i)))
                )
                (.visitJumpInsn gen, (cast Integer (§ unsure aget predOps (dec (alength predOps)))), falseLabel)
            )
        )
        nil
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--StaticMethodExpr [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (some? (:method this)) => (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
            (.visitLineNumber gen, (:line this), (.mark gen))
            (when (= context :Context'RETURN)
                (ObjMethod''emitClearLocals (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
            )
            (let [#_"Object" ops (RT'get-2 Intrinsics'ops, (.toString (:method this)))]
                (if (some? ops)
                    (if (§ instance? Object[] ops)
                        (doseq [#_"Object" op (§ cast Object[] ops)]
                            (.visitInsn gen, (cast Integer op))
                        )
                        (.visitInsn gen, (cast Integer ops))
                    )
                    (let [#_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (.invokeStatic gen, (Type/getType (:c this)), m)
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--StaticMethodExpr [#_"StaticMethodExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:method this))
            (do
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:method this)), (:args this))
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (and (:tailPosition this) (not (:canBeDirect objx)))
                    (ObjMethod''emitClearThis (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
                )
                (let [#_"Type" type (Type/getType (:c this))
                      #_"Method" m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                    (.invokeStatic gen, type, m)
                    (when (= context :Context'STATEMENT) => (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:method this)))
                        (let [#_"Class" rc (.getReturnType (:method this))]
                            (cond
                                (any = rc Long/TYPE Double/TYPE) (.pop2 gen)
                                (not (= rc Void/TYPE))           (.pop gen)
                            )
                        )
                    )
                )
            )
            (do
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.push gen, (.getName (:c this)))
                (.invokeStatic gen, Compiler'RT_TYPE, StaticMethodExpr'forNameMethod)
                (.push gen, (:methodName this))
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (when (= context :Context'RETURN)
                    (ObjMethod''emitClearLocals (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
                )
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, StaticMethodExpr'invokeStaticMethodMethod)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--StaticMethodExpr [#_"StaticMethodExpr" this]
        (or (some? (:method this)) (some? (:tag this)))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--StaticMethodExpr [#_"StaticMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (when (some? (:method this)) (.getReturnType (:method this))))))
        )
        (:jc this)
    )
)

(class-ns UnresolvedVarExpr (§ implements Expr)
    (defn- #_"UnresolvedVarExpr" UnresolvedVarExpr'init []
        (hash-map
            #_"Symbol" :symbol nil
        )
    )

    (defn #_"UnresolvedVarExpr" UnresolvedVarExpr'new [#_"Symbol" symbol]
        (let [this (UnresolvedVarExpr'init)]
            (§ ass this (assoc this :symbol symbol))
            this
        )
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--UnresolvedVarExpr [#_"UnresolvedVarExpr" this]
        false
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--UnresolvedVarExpr [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr has no Java class"))
    )

    #_override
    (defn #_"void" Expr'''emit--UnresolvedVarExpr [#_"UnresolvedVarExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        nil
    )

    #_override
    (defn #_"Object" Expr'''eval--UnresolvedVarExpr [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr cannot be evalled"))
    )
)

(class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
    (defn- #_"NumberExpr" NumberExpr'init []
        (hash-map
            #_"Number" :n nil
            #_"int" :id 0
        )
    )

    (defn #_"NumberExpr" NumberExpr'new [#_"Number" n]
        (let [this (merge (LiteralExpr'new) (NumberExpr'init))]
            (§ ass this (assoc this :n n))
            (§ ass this (assoc this :id (Compiler'registerConstant n)))
            this
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--NumberExpr [#_"NumberExpr" this]
        (:n this)
    )

    #_override
    (defn #_"void" Expr'''emit--NumberExpr [#_"NumberExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (ObjExpr''emitConstant objx, gen, (:id this))
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--NumberExpr [#_"NumberExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--NumberExpr [#_"NumberExpr" this]
        (cond
            (instance? Integer (:n this)) Long/TYPE
            (instance? Double (:n this))  Double/TYPE
            (instance? Long (:n this))    Long/TYPE
            :else                         (throw (IllegalStateException. (str "Unsupported Number type: " (.getName (.getClass (:n this))))))
        )
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--NumberExpr [#_"NumberExpr" this]
        true
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--NumberExpr [#_"NumberExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (cond
            (instance? Integer (:n this)) (.push gen, (.longValue (:n this)))
            (instance? Double (:n this))  (.push gen, (.doubleValue (:n this)))
            (instance? Long (:n this))    (.push gen, (.longValue (:n this)))
        )
        nil
    )

    (defn #_"Expr" NumberExpr'parse [#_"Number" form]
        (if (or (instance? Integer form) (instance? Double form) (instance? Long form))
            (NumberExpr'new form)
            (ConstantExpr'new form)
        )
    )
)

#_closure
(class-ns ConstantParser (§ implements IParser)
    (§ def #_"Keyword" ConstantParser'formKey (Keyword'intern (Symbol'intern "form")))

    (defn #_"ConstantParser" ConstantParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--ConstantParser [#_"ConstantParser" this, #_"Context" context, #_"Object" form]
        (let [#_"int" argCount (dec (RT'count form))]
            (if-not (= argCount 1)
                (let [#_"IPersistentMap" exData (PersistentArrayMap'new-1 (object-array [ ConstantParser'formKey, form ]))]
                    (throw (ExceptionInfo'new-2 (str "Wrong number of args (" argCount ") passed to quote"), exData))
                )
                (let [#_"Object" v (RT'second form)]
                    (cond
                        (nil? v)             Compiler'NIL_EXPR
                        (= v Boolean/TRUE)   Compiler'TRUE_EXPR
                        (= v Boolean/FALSE)  Compiler'FALSE_EXPR
                        (instance? Number v) (NumberExpr'parse (cast Number v))
                        (instance? String v) (StringExpr'new (cast String v))
                        (and (§ instance? IPersistentCollection v) (zero? (.count (cast' IPersistentCollection v)))) (EmptyExpr'new v)
                        :else                (ConstantExpr'new v)
                    )
                )
            )
        )
    )
)

(class-ns ConstantExpr (§ extends LiteralExpr)
    (defn- #_"ConstantExpr" ConstantExpr'init []
        (hash-map
            ;; stuff quoted vals in classloader at compile time, pull out at runtime
            ;; this won't work for static compilation...
            #_"Object" :v nil
            #_"int" :id 0
        )
    )

    (defn #_"ConstantExpr" ConstantExpr'new [#_"Object" v]
        (let [this (merge (LiteralExpr'new) (ConstantExpr'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :id (Compiler'registerConstant v)))
            this
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--ConstantExpr [#_"ConstantExpr" this]
        (:v this)
    )

    #_override
    (defn #_"void" Expr'''emit--ConstantExpr [#_"ConstantExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitConstant objx, gen, (:id this))
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--ConstantExpr [#_"ConstantExpr" this]
        (Modifier/isPublic (.getModifiers (.getClass (:v this))))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--ConstantExpr [#_"ConstantExpr" this]
        (cond
            (§ instance? APersistentMap (:v this))    (§ class APersistentMap)
            (§ instance? APersistentSet (:v this))    (§ class APersistentSet)
            (§ instance? APersistentVector (:v this)) (§ class APersistentVector)
            :else                                     (.getClass (:v this))
        )
    )
)

(class-ns NilExpr (§ extends LiteralExpr)
    (defn #_"NilExpr" NilExpr'new []
        (LiteralExpr'new)
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--NilExpr [#_"NilExpr" this]
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--NilExpr [#_"NilExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.visitInsn gen, Opcodes/ACONST_NULL)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--NilExpr [#_"NilExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--NilExpr [#_"NilExpr" this]
        nil
    )
)

(class-ns BooleanExpr (§ extends LiteralExpr)
    (defn- #_"BooleanExpr" BooleanExpr'init []
        (hash-map
            #_"boolean" :val false
        )
    )

    (defn #_"BooleanExpr" BooleanExpr'new [#_"boolean" val]
        (let [this (merge (LiteralExpr'new) (BooleanExpr'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--BooleanExpr [#_"BooleanExpr" this]
        (if (:val this) RT'T RT'F)
    )

    #_override
    (defn #_"void" Expr'''emit--BooleanExpr [#_"BooleanExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, (if (:val this) "TRUE" "FALSE"), Compiler'BOOLEAN_OBJECT_TYPE)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--BooleanExpr [#_"BooleanExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--BooleanExpr [#_"BooleanExpr" this]
        Boolean
    )
)

(class-ns StringExpr (§ extends LiteralExpr)
    (defn- #_"StringExpr" StringExpr'init []
        (hash-map
            #_"String" :str nil
        )
    )

    (defn #_"StringExpr" StringExpr'new [#_"String" str]
        (let [this (merge (LiteralExpr'new) (StringExpr'init))]
            (§ ass this (assoc this :str str))
            this
        )
    )

    #_override
    (defn #_"Object" LiteralExpr'''val--StringExpr [#_"StringExpr" this]
        (:str this)
    )

    #_override
    (defn #_"void" Expr'''emit--StringExpr [#_"StringExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (.push gen, (:str this))
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--StringExpr [#_"StringExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--StringExpr [#_"StringExpr" this]
        String
    )
)

#_closure
(class-ns MonitorEnterParser (§ implements IParser)
    (defn #_"MonitorEnterParser" MonitorEnterParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--MonitorEnterParser [#_"MonitorEnterParser" this, #_"Context" context, #_"Object" form]
        (MonitorEnterExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
    )
)

(class-ns MonitorEnterExpr (§ extends UntypedExpr)
    (defn- #_"MonitorEnterExpr" MonitorEnterExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorEnterExpr" MonitorEnterExpr'new [#_"Expr" target]
        (let [this (merge (UntypedExpr'new) (MonitorEnterExpr'init))]
            (§ ass this (assoc this :target target))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MonitorEnterExpr [#_"MonitorEnterExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-enter"))
    )

    #_override
    (defn #_"void" Expr'''emit--MonitorEnterExpr [#_"MonitorEnterExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
        (.monitorEnter gen)
        (Expr'''emit Compiler'NIL_EXPR, context, objx, gen)
        nil
    )
)

#_closure
(class-ns MonitorExitParser (§ implements IParser)
    (defn #_"MonitorExitParser" MonitorExitParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--MonitorExitParser [#_"MonitorExitParser" this, #_"Context" context, #_"Object" form]
        (MonitorExitExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
    )
)

(class-ns MonitorExitExpr (§ extends UntypedExpr)
    (defn- #_"MonitorExitExpr" MonitorExitExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorExitExpr" MonitorExitExpr'new [#_"Expr" target]
        (let [this (merge (UntypedExpr'new) (MonitorExitExpr'init))]
            (§ ass this (assoc this :target target))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MonitorExitExpr [#_"MonitorExitExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-exit"))
    )

    #_override
    (defn #_"void" Expr'''emit--MonitorExitExpr [#_"MonitorExitExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen)
        (.monitorExit gen)
        (Expr'''emit Compiler'NIL_EXPR, context, objx, gen)
        nil
    )
)

(class-ns CatchClause
    (defn- #_"CatchClause" CatchClause'init []
        (hash-map
            #_"Class" :c nil
            #_"LocalBinding" :lb nil
            #_"Expr" :handler nil
            #_"Label" :label nil
            #_"Label" :endLabel nil
        )
    )

    (defn #_"CatchClause" CatchClause'new [#_"Class" c, #_"LocalBinding" lb, #_"Expr" handler]
        (let [this (CatchClause'init)]
            (§ ass this (assoc this :c c))
            (§ ass this (assoc this :lb lb))
            (§ ass this (assoc this :handler handler))
            this
        )
    )
)

#_closure
(class-ns TryParser (§ implements IParser)
    (defn #_"TryParser" TryParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--TryParser [#_"TryParser" this, #_"Context" context, #_"Object" frm]
        ;; (try try-expr* catch-expr* finally-expr?)
        ;; catch-expr: (catch class sym expr*)
        ;; finally-expr: (finally expr*)
        (let [#_"ISeq" form (cast' ISeq frm)]
            (when (= context :Context'RETURN) => (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                (let [#_"PersistentVector" body PersistentVector'EMPTY #_"PersistentVector" catches PersistentVector'EMPTY
                      #_"Expr" bodyExpr nil #_"Expr" finallyExpr nil #_"boolean" caught false
                      #_"int" retLocal (Compiler'getAndIncLocalNum) #_"int" finallyLocal (Compiler'getAndIncLocalNum)]

                    (loop-when-recur [#_"ISeq" fs (.next form)] (some? fs) [(.next fs)]
                        (let [#_"Object" f (.first fs) #_"Object" op (when (§ instance? ISeq f) (.first (cast' ISeq f)))]
                            (if (and (not (Util'equals op, Compiler'CATCH)) (not (Util'equals op, Compiler'FINALLY)))
                                (do
                                    (when-not caught => (throw (RuntimeException. "Only catch or finally clause can follow catch in try expression"))
                                        (§ ass body (IPersistentVector'''cons body, f))
                                    )
                                )
                                (do
                                    (when (nil? bodyExpr)
                                        (try
                                            (Var'pushThreadBindings (RT'map
                                                (object-array [
                                                    Compiler'NO_RECUR              true
                                                    Compiler'METHOD_RETURN_CONTEXT nil
                                                ])
                                            ))
                                            (§ ass bodyExpr (IParser'''parse (BodyParser'new), context, (RT'seq body)))
                                            (finally
                                                (Var'popThreadBindings)
                                            )
                                        )
                                    )

                                    (cond (Util'equals op, Compiler'CATCH)
                                        (let [#_"Class" c (HostExpr'maybeClass (RT'second f), false)]
                                            (when (nil? c)
                                                (throw (IllegalArgumentException. (str "Unable to resolve classname: " (RT'second f))))
                                            )
                                            (when (not (§ instance? Symbol (RT'third f)))
                                                (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (RT'third f))))
                                            )
                                            (let [#_"Symbol" sym (cast' Symbol (RT'third f))]
                                                (when (some? (Named'''getNamespace sym))
                                                    (throw (RuntimeException. (str "Can't bind qualified name:" sym)))
                                                )
                                                (let [#_"IPersistentMap" dynamicBindings
                                                        (RT'map
                                                            (object-array [
                                                                Compiler'LOCAL_ENV        (IDeref'''deref Compiler'LOCAL_ENV)
                                                                Compiler'NEXT_LOCAL_NUM   (IDeref'''deref Compiler'NEXT_LOCAL_NUM)
                                                                Compiler'IN_CATCH_FINALLY RT'T
                                                            ])
                                                        )]
                                                    (try
                                                        (Var'pushThreadBindings dynamicBindings)
                                                        (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (cast' Symbol (when (§ instance? Symbol (RT'second f)) (RT'second f))), nil, false)
                                                              #_"Expr" handler (IParser'''parse (BodyParser'new), :Context'EXPRESSION, (RT'next (RT'next (RT'next f))))]
                                                            (§ ass catches (IPersistentVector'''cons catches, (CatchClause'new c, lb, handler)))
                                                        )
                                                        (finally
                                                            (Var'popThreadBindings)
                                                        )
                                                    )
                                                    (§ ass caught true)
                                                )
                                            )
                                        )
                                        :else ;; finally
                                        (do
                                            (when (some? (.next fs))
                                                (throw (RuntimeException. "finally clause must be last in try expression"))
                                            )
                                            (try
                                                (Var'pushThreadBindings (RT'map
                                                    (object-array [
                                                        Compiler'IN_CATCH_FINALLY RT'T
                                                    ])
                                                ))
                                                (§ ass finallyExpr (IParser'''parse (BodyParser'new), :Context'STATEMENT, (RT'next f)))
                                                (finally
                                                    (Var'popThreadBindings)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (nil? bodyExpr) => (TryExpr'new bodyExpr, catches, finallyExpr, retLocal, finallyLocal)
                        ;; when there is neither catch nor finally, e.g. (try (expr)) return a body expr directly
                        (try
                            (Var'pushThreadBindings (RT'map
                                (object-array [
                                    Compiler'NO_RECUR true
                                ])
                            ))
                            (IParser'''parse (BodyParser'new), context, (RT'seq body))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns TryExpr (§ implements Expr)
    (defn- #_"TryExpr" TryExpr'init []
        (hash-map
            #_"Expr" :tryExpr nil
            #_"Expr" :finallyExpr nil
            #_"PersistentVector" :catchExprs nil
            #_"int" :retLocal 0
            #_"int" :finallyLocal 0
        )
    )

    (defn #_"TryExpr" TryExpr'new [#_"Expr" tryExpr, #_"PersistentVector" catchExprs, #_"Expr" finallyExpr, #_"int" retLocal, #_"int" finallyLocal]
        (let [this (TryExpr'init)]
            (§ ass this (assoc this :tryExpr tryExpr))
            (§ ass this (assoc this :catchExprs catchExprs))
            (§ ass this (assoc this :finallyExpr finallyExpr))
            (§ ass this (assoc this :retLocal retLocal))
            (§ ass this (assoc this :finallyLocal finallyLocal))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--TryExpr [#_"TryExpr" this]
        (throw (UnsupportedOperationException. "Can't eval try"))
    )

    #_override
    (defn #_"void" Expr'''emit--TryExpr [#_"TryExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" startTry (.newLabel gen) #_"Label" endTry (.newLabel gen) #_"Label" end (.newLabel gen) #_"Label" ret (.newLabel gen) #_"Label" finallyLabel (.newLabel gen)]
            (loop-when-recur [#_"int" i 0] (< i (.count (:catchExprs this))) [(inc i)]
                (let [#_"CatchClause" clause (cast' CatchClause (Indexed'''nth-2 (:catchExprs this), i))]
                    (§ ass (:label clause) (.newLabel gen))
                    (§ ass (:endLabel clause) (.newLabel gen))
                )
            )

            (.mark gen, startTry)
            (Expr'''emit (:tryExpr this), context, objx, gen)
            (when (not= context :Context'STATEMENT)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:retLocal this))
            )
            (.mark gen, endTry)
            (when (some? (:finallyExpr this))
                (Expr'''emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
            )
            (.goTo gen, ret)

            (dotimes [#_"int" i (.count (:catchExprs this))]
                (let [#_"CatchClause" clause (cast' CatchClause (Indexed'''nth-2 (:catchExprs this), i))]
                    (.mark gen, (:label clause))
                    ;; exception should be on stack
                    ;; put in clause local
                    (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:lb clause)))
                    (Expr'''emit (:handler clause), context, objx, gen)
                    (when (not= context :Context'STATEMENT)
                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:retLocal this))
                    )
                    (.mark gen, (:endLabel clause))

                    (when (some? (:finallyExpr this))
                        (Expr'''emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
                    )
                    (.goTo gen, ret)
                )
            )
            (when (some? (:finallyExpr this))
                (.mark gen, finallyLabel)
                ;; exception should be on stack
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:finallyLocal this))
                (Expr'''emit (:finallyExpr this), :Context'STATEMENT, objx, gen)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:finallyLocal this))
                (.throwException gen)
            )
            (.mark gen, ret)
            (when (not= context :Context'STATEMENT)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:retLocal this))
            )
            (.mark gen, end)
            (dotimes [#_"int" i (.count (:catchExprs this))]
                (let [#_"CatchClause" clause (cast' CatchClause (Indexed'''nth-2 (:catchExprs this), i))]
                    (.visitTryCatchBlock gen, startTry, endTry, (:label clause), (.replace (.getName (:c clause)), \., \/))
                )
            )
            (when (some? (:finallyExpr this))
                (.visitTryCatchBlock gen, startTry, endTry, finallyLabel, nil)
                (dotimes [#_"int" i (.count (:catchExprs this))]
                    (let [#_"CatchClause" clause (cast' CatchClause (Indexed'''nth-2 (:catchExprs this), i))]
                        (.visitTryCatchBlock gen, (:label clause), (:endLabel clause), finallyLabel, nil)
                    )
                )
            )
            (dotimes [#_"int" i (.count (:catchExprs this))]
                (let [#_"CatchClause" clause (cast' CatchClause (Indexed'''nth-2 (:catchExprs this), i))]
                    (.visitLocalVariable gen, (:name (:lb clause)), "Ljava/lang/Object;", nil, (:label clause), (:endLabel clause), (:idx (:lb clause)))
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--TryExpr [#_"TryExpr" this]
        (Expr'''hasJavaClass (:tryExpr this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--TryExpr [#_"TryExpr" this]
        (Expr'''getJavaClass (:tryExpr this))
    )
)

#_closure
(class-ns ThrowParser (§ implements IParser)
    (defn #_"ThrowParser" ThrowParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--ThrowParser [#_"ThrowParser" this, #_"Context" context, #_"Object" form]
        (cond
            (= context :Context'EVAL) (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
            (= (RT'count form) 1)     (throw (RuntimeException. "Too few arguments to throw, throw expects a single Throwable instance"))
            (< 2 (RT'count form))     (throw (RuntimeException. "Too many arguments to throw, throw expects a single Throwable instance"))
            :else                     (ThrowExpr'new (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form)))
        )
    )
)

(class-ns ThrowExpr (§ extends UntypedExpr)
    (defn- #_"ThrowExpr" ThrowExpr'init []
        (hash-map
            #_"Expr" :excExpr nil
        )
    )

    (defn #_"ThrowExpr" ThrowExpr'new [#_"Expr" excExpr]
        (let [this (merge (UntypedExpr'new) (ThrowExpr'init))]
            (§ ass this (assoc this :excExpr excExpr))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--ThrowExpr [#_"ThrowExpr" this]
        (throw (RuntimeException. "Can't eval throw"))
    )

    #_override
    (defn #_"void" Expr'''emit--ThrowExpr [#_"ThrowExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (Expr'''emit (:excExpr this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, Compiler'THROWABLE_TYPE)
        (.throwException gen)
        nil
    )
)

#_closure
(class-ns NewParser (§ implements IParser)
    (defn #_"NewParser" NewParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--NewParser [#_"NewParser" this, #_"Context" context, #_"Object" frm]
        ;; (new Classname args...)
        (let [#_"int" line (Compiler'lineDeref) #_"int" column (Compiler'columnDeref) #_"ISeq" form (cast' ISeq frm)]
            (when (< 1 (.count form)) => (throw (RuntimeException. "wrong number of arguments, expecting: (new Classname args...)"))
                (let [#_"Class" c (HostExpr'maybeClass (RT'second form), false)]
                    (when (some? c) => (throw (IllegalArgumentException. (str "Unable to resolve classname: " (RT'second form))))
                        (let [#_"PersistentVector" args
                                (loop-when-recur [args PersistentVector'EMPTY #_"ISeq" s (RT'next (RT'next form))]
                                                 (some? s)
                                                 [(IPersistentVector'''cons args, (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.first s))) (.next s)]
                                              => args
                                )]
                            (NewExpr'new c, args, line, column)
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewExpr (§ implements Expr)
    (def #_"Method" NewExpr'invokeConstructorMethod (Method/getMethod "Object invokeConstructor(Class, Object[])"))
    (def #_"Method" NewExpr'forNameMethod (Method/getMethod "Class classForName(String)"))

    (defn- #_"NewExpr" NewExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"Constructor" :ctor nil
            #_"Class" :c nil
        )
    )

    (defn #_"NewExpr" NewExpr'new [#_"Class" c, #_"IPersistentVector" args, #_"int" line, #_"int" column]
        (let [this (NewExpr'init)]
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :c c))
            (let [#_"Constructor[]" allctors (.getConstructors c)
                  #_"ArrayList" ctors (ArrayList.) #_"ArrayList<Class[]>" params (ArrayList.) #_"ArrayList<Class>" rets (ArrayList.)]
                (dotimes [#_"int" i (alength allctors)]
                    (let [#_"Constructor" ctor (aget allctors i)]
                        (when (= (alength (.getParameterTypes ctor)) (.count args))
                            (.add ctors, ctor)
                            (.add params, (.getParameterTypes ctor))
                            (.add rets, c)
                        )
                    )
                )
                (when-not (.isEmpty ctors) => (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                    (let [#_"int" i (if (< 1 (.size ctors)) (Compiler'getMatchingParams (.getName c), params, args, rets) 0)
                          this (assoc this :ctor (when (<= 0 i) (cast Constructor (.get ctors, i))))]
                        (when (and (nil? (:ctor this)) (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION)))
                            (.format (RT'errPrintWriter), "Reflection warning, %d:%d - call to %s ctor can't be resolved.\n", (object-array [ line, column, (.getName c) ]))
                        )
                        this
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--NewExpr [#_"NewExpr" this]
        (let [#_"Object[]" args (make-array Object (.count (:args this)))]
            (dotimes [#_"int" i (.count (:args this))]
                (aset args i (Expr'''eval (cast' Expr (Indexed'''nth-2 (:args this), i))))
            )
            (when (some? (:ctor this)) => (Reflector'invokeConstructor (:c this), args)
                (try
                    (.newInstance (:ctor this), (Reflector'boxArgs (.getParameterTypes (:ctor this)), args))
                    (catch Exception e
                        (throw (Util'sneakyThrow e))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--NewExpr [#_"NewExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (some? (:ctor this))
            (let [#_"Type" type (Compiler'getType (:c this))]
                (.newInstance gen, type)
                (.dup gen)
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:ctor this)), (:args this))
                (.invokeConstructor gen, type, (Method. "<init>", (Type/getConstructorDescriptor (:ctor this))))
            )
            (do
                (.push gen, (Compiler'destubClassName (.getName (:c this))))
                (.invokeStatic gen, Compiler'RT_TYPE, NewExpr'forNameMethod)
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.invokeStatic gen, Compiler'REFLECTOR_TYPE, NewExpr'invokeConstructorMethod)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--NewExpr [#_"NewExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--NewExpr [#_"NewExpr" this]
        (:c this)
    )
)

(class-ns MetaExpr (§ implements Expr)
    (def #_"Type" MetaExpr'IOBJ_TYPE (§ unsure Type/getType (§ class IObj)))
    (def #_"Method" MetaExpr'withMetaMethod (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

    (defn- #_"MetaExpr" MetaExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Expr" :meta nil
        )
    )

    (defn #_"MetaExpr" MetaExpr'new [#_"Expr" expr, #_"Expr" meta]
        (let [this (MetaExpr'init)]
            (§ ass this (assoc this :expr expr))
            (§ ass this (assoc this :meta meta))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MetaExpr [#_"MetaExpr" this]
        (IObj'''withMeta (cast' IObj (Expr'''eval (:expr this))), (cast' IPersistentMap (Expr'''eval (:meta this))))
    )

    #_override
    (defn #_"void" Expr'''emit--MetaExpr [#_"MetaExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (Expr'''emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, MetaExpr'IOBJ_TYPE)
        (Expr'''emit (:meta this), :Context'EXPRESSION, objx, gen)
        (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
        (.invokeInterface gen, MetaExpr'IOBJ_TYPE, MetaExpr'withMetaMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--MetaExpr [#_"MetaExpr" this]
        (Expr'''hasJavaClass (:expr this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--MetaExpr [#_"MetaExpr" this]
        (Expr'''getJavaClass (:expr this))
    )
)

#_closure
(class-ns IfParser (§ implements IParser)
    (defn #_"IfParser" IfParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--IfParser [#_"IfParser" this, #_"Context" context, #_"Object" frm]
        ;; (if test then) or (if test then else)
        (let [#_"ISeq" form (cast' ISeq frm)]
            (cond
                (< 4 (.count form)) (throw (RuntimeException. "Too many arguments to if"))
                (< (.count form) 3) (throw (RuntimeException. "Too few arguments to if"))
            )
            (let [#_"PathNode" branch (PathNode'new :PathType'BRANCH, (cast' PathNode (Var''get Compiler'CLEAR_PATH)))
                  #_"Expr" testexpr (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (RT'second form))
                  #_"Expr" thenexpr
                    (try
                        (Var'pushThreadBindings (RT'map
                            (object-array [
                                Compiler'CLEAR_PATH (PathNode'new :PathType'PATH, branch)
                            ])
                        ))
                        (Compiler'analyze-2 context, (RT'third form))
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                  #_"Expr" elseexpr
                    (try
                        (Var'pushThreadBindings (RT'map
                            (object-array [
                                Compiler'CLEAR_PATH (PathNode'new :PathType'PATH, branch)
                            ])
                        ))
                        (Compiler'analyze-2 context, (RT'fourth form))
                        (finally
                            (Var'popThreadBindings)
                        )
                    )]
                (IfExpr'new (Compiler'lineDeref), (Compiler'columnDeref), testexpr, thenexpr, elseexpr)
            )
        )
    )
)

(class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"IfExpr" IfExpr'init []
        (hash-map
            #_"Expr" :testExpr nil
            #_"Expr" :thenExpr nil
            #_"Expr" :elseExpr nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"IfExpr" IfExpr'new [#_"int" line, #_"int" column, #_"Expr" testExpr, #_"Expr" thenExpr, #_"Expr" elseExpr]
        (let [this (IfExpr'init)]
            (§ ass this (assoc this :testExpr testExpr))
            (§ ass this (assoc this :thenExpr thenExpr))
            (§ ass this (assoc this :elseExpr elseExpr))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--IfExpr [#_"IfExpr" this]
        (let [#_"Object" t (Expr'''eval (:testExpr this))]
            (if (and (some? t) (not= t Boolean/FALSE))
                (Expr'''eval (:thenExpr this))
                (Expr'''eval (:elseExpr this))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--IfExpr [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (IfExpr''doEmit this, context, objx, gen, false)
        nil
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--IfExpr [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (IfExpr''doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (defn- #_"void" IfExpr''doEmit [#_"IfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"Label" nullLabel (.newLabel gen) #_"Label" falseLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)]
            (.visitLineNumber gen, (:line this), (.mark gen))

            (cond (and (§ instance? StaticMethodExpr (:testExpr this)) (StaticMethodExpr''canEmitIntrinsicPredicate (cast' StaticMethodExpr (:testExpr this))))
                (do
                    (StaticMethodExpr''emitIntrinsicPredicate (cast' StaticMethodExpr (:testExpr this)), :Context'EXPRESSION, objx, gen, falseLabel)
                )
                (= (Compiler'maybePrimitiveType (:testExpr this)) Boolean/TYPE)
                (do
                    (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr (:testExpr this)), :Context'EXPRESSION, objx, gen)
                    (.ifZCmp gen, GeneratorAdapter/EQ, falseLabel)
                )
                :else
                (do
                    (Expr'''emit (:testExpr this), :Context'EXPRESSION, objx, gen)
                    (.dup gen)
                    (.ifNull gen, nullLabel)
                    (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE)
                    (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, falseLabel)
                )
            )
            (if emitUnboxed
                (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr (:thenExpr this)), context, objx, gen)
                (Expr'''emit (:thenExpr this), context, objx, gen)
            )
            (.goTo gen, endLabel)
            (.mark gen, nullLabel)
            (.pop gen)
            (.mark gen, falseLabel)
            (if emitUnboxed
                (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr (:elseExpr this)), context, objx, gen)
                (Expr'''emit (:elseExpr this), context, objx, gen)
            )
            (.mark gen, endLabel)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--IfExpr [#_"IfExpr" this]
        (and (Expr'''hasJavaClass (:thenExpr this))
             (Expr'''hasJavaClass (:elseExpr this))
            (or (= (Expr'''getJavaClass (:thenExpr this)) (Expr'''getJavaClass (:elseExpr this)))
                (= (Expr'''getJavaClass (:thenExpr this)) Compiler'RECUR_CLASS)
                (= (Expr'''getJavaClass (:elseExpr this)) Compiler'RECUR_CLASS)
                (and (nil? (Expr'''getJavaClass (:thenExpr this))) (not (.isPrimitive (Expr'''getJavaClass (:elseExpr this)))))
                (and (nil? (Expr'''getJavaClass (:elseExpr this))) (not (.isPrimitive (Expr'''getJavaClass (:thenExpr this)))))))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--IfExpr [#_"IfExpr" this]
        (try
            (and (§ instance? MaybePrimitiveExpr (:thenExpr this))
                 (§ instance? MaybePrimitiveExpr (:elseExpr this))
                (or (= (Expr'''getJavaClass (:thenExpr this)) (Expr'''getJavaClass (:elseExpr this)))
                    (= (Expr'''getJavaClass (:thenExpr this)) Compiler'RECUR_CLASS)
                    (= (Expr'''getJavaClass (:elseExpr this)) Compiler'RECUR_CLASS))
                 (MaybePrimitiveExpr'''canEmitPrimitive (cast' MaybePrimitiveExpr (:thenExpr this)))
                 (MaybePrimitiveExpr'''canEmitPrimitive (cast' MaybePrimitiveExpr (:elseExpr this))))
            (catch Exception e
                false
            )
        )
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--IfExpr [#_"IfExpr" this]
        (let [#_"Class" thenClass (Expr'''getJavaClass (:thenExpr this))]
            (if (and (some? thenClass) (not= thenClass Compiler'RECUR_CLASS))
                thenClass
                (Expr'''getJavaClass (:elseExpr this))
            )
        )
    )
)

(class-ns EmptyExpr (§ implements Expr)
    (def #_"Type" EmptyExpr'HASHMAP_TYPE (§ unsure Type/getType (§ class PersistentArrayMap)))
    (def #_"Type" EmptyExpr'HASHSET_TYPE (§ unsure Type/getType (§ class PersistentHashSet)))
    (def #_"Type" EmptyExpr'VECTOR_TYPE (§ unsure Type/getType (§ class PersistentVector)))
    (def #_"Type" EmptyExpr'IVECTOR_TYPE (§ unsure Type/getType (§ class IPersistentVector)))
    (def #_"Type" EmptyExpr'TUPLE_TYPE (§ unsure Type/getType (§ class Tuple)))
    (def #_"Type" EmptyExpr'LIST_TYPE (§ unsure Type/getType (§ class PersistentList)))
    (def #_"Type" EmptyExpr'EMPTY_LIST_TYPE (§ unsure Type/getType (§ class EmptyList)))

    (defn- #_"EmptyExpr" EmptyExpr'init []
        (hash-map
            #_"Object" :coll nil
        )
    )

    (defn #_"EmptyExpr" EmptyExpr'new [#_"Object" coll]
        (let [this (EmptyExpr'init)]
            (§ ass this (assoc this :coll coll))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--EmptyExpr [#_"EmptyExpr" this]
        (:coll this)
    )

    #_override
    (defn #_"void" Expr'''emit--EmptyExpr [#_"EmptyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (cond
            (§ instance? IPersistentList (:coll this))   (.getStatic gen, EmptyExpr'LIST_TYPE,    "EMPTY", EmptyExpr'EMPTY_LIST_TYPE)
            (§ instance? IPersistentVector (:coll this)) (.getStatic gen, EmptyExpr'VECTOR_TYPE,  "EMPTY", EmptyExpr'VECTOR_TYPE)
            (§ instance? IPersistentMap (:coll this))    (.getStatic gen, EmptyExpr'HASHMAP_TYPE, "EMPTY", EmptyExpr'HASHMAP_TYPE)
            (§ instance? IPersistentSet (:coll this))    (.getStatic gen, EmptyExpr'HASHSET_TYPE, "EMPTY", EmptyExpr'HASHSET_TYPE)
            :else                                        (throw (UnsupportedOperationException. "Unknown collection type"))
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--EmptyExpr [#_"EmptyExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--EmptyExpr [#_"EmptyExpr" this]
        (cond
            (§ instance? IPersistentList (:coll this))   (§ class IPersistentList)
            (§ instance? IPersistentVector (:coll this)) (§ class IPersistentVector)
            (§ instance? IPersistentMap (:coll this))    (§ class IPersistentMap)
            (§ instance? IPersistentSet (:coll this))    (§ class IPersistentSet)
            :else                                        (throw (UnsupportedOperationException. "Unknown collection type"))
        )
    )
)

(class-ns ListExpr (§ implements Expr)
    (def #_"Method" ListExpr'arrayToListMethod (Method/getMethod "cloiure.lang.ISeq arrayToList(Object[])"))

    (defn- #_"ListExpr" ListExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"ListExpr" ListExpr'new [#_"IPersistentVector" args]
        (let [this (ListExpr'init)]
            (§ ass this (assoc this :args args))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--ListExpr [#_"ListExpr" this]
        (let [#_"IPersistentVector" ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                (§ ass ret (cast' IPersistentVector (IPersistentVector'''cons ret, (Expr'''eval (cast' Expr (Indexed'''nth-2 (:args this), i))))))
            )
            (Seqable'''seq ret)
        )
    )

    #_override
    (defn #_"void" Expr'''emit--ListExpr [#_"ListExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (MethodExpr'emitArgsAsArray (:args this), objx, gen)
        (.invokeStatic gen, Compiler'RT_TYPE, ListExpr'arrayToListMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--ListExpr [#_"ListExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--ListExpr [#_"ListExpr" this]
        (§ class IPersistentList)
    )
)

(class-ns MapExpr (§ implements Expr)
    (def #_"Method" MapExpr'mapMethod (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
    (def #_"Method" MapExpr'mapUniqueKeysMethod (Method/getMethod "cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

    (defn- #_"MapExpr" MapExpr'init []
        (hash-map
            #_"IPersistentVector" :keyvals nil
        )
    )

    (defn #_"MapExpr" MapExpr'new [#_"IPersistentVector" keyvals]
        (let [this (MapExpr'init)]
            (§ ass this (assoc this :keyvals keyvals))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MapExpr [#_"MapExpr" this]
        (let [#_"Object[]" a (make-array Object (.count (:keyvals this)))]
            (dotimes [#_"int" i (.count (:keyvals this))]
                (aset a i (Expr'''eval (cast' Expr (Indexed'''nth-2 (:keyvals this), i))))
            )
            (RT'map a)
        )
    )

    #_override
    (defn #_"void" Expr'''emit--MapExpr [#_"MapExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [[#_"boolean" allKeysConstant #_"boolean" allConstantKeysUnique]
                (loop-when [constant? true unique? true #_"IPersistentSet" keys PersistentHashSet'EMPTY #_"int" i 0] (< i (.count (:keyvals this))) => [constant? unique?]
                    (let [#_"Expr" k (cast' Expr (Indexed'''nth-2 (:keyvals this), i))
                          [constant? unique? keys]
                            (when (§ instance? LiteralExpr k) => [false unique? keys]
                                (let-when-not [#_"Object" v (Expr'''eval k)] (IPersistentSet'''contains keys, v) => [constant? false keys]
                                    [constant? unique? (cast' IPersistentSet (IPersistentCollection'''cons keys, v))]
                                )
                            )]
                        (recur constant? unique? keys (+ i 2))
                    )
                )]
            (MethodExpr'emitArgsAsArray (:keyvals this), objx, gen)
            (if (or (and allKeysConstant allConstantKeysUnique) (<= (.count (:keyvals this)) 2))
                (.invokeStatic gen, Compiler'RT_TYPE, MapExpr'mapUniqueKeysMethod)
                (.invokeStatic gen, Compiler'RT_TYPE, MapExpr'mapMethod)
            )
            (when (= context :Context'STATEMENT)
                (.pop gen)
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--MapExpr [#_"MapExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--MapExpr [#_"MapExpr" this]
        (§ class IPersistentMap)
    )

    (defn #_"Expr" MapExpr'parse [#_"Context" context, #_"IPersistentMap" form]
        (let [#_"IPersistentVector" keyvals PersistentVector'EMPTY
              #_"boolean" keysConstant true #_"boolean" valsConstant true #_"boolean" allConstantKeysUnique true
              #_"IPersistentSet" constantKeys PersistentHashSet'EMPTY]
            (loop-when-recur [#_"ISeq" s (RT'seq form)] (some? s) [(.next s)]
                (let [#_"IMapEntry" e (cast' IMapEntry (.first s))
                      #_"Expr" k (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (IMapEntry'''key e))
                      #_"Expr" v (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (IMapEntry'''val e))]
                    (§ ass keyvals (cast' IPersistentVector (IPersistentVector'''cons keyvals, k)))
                    (§ ass keyvals (cast' IPersistentVector (IPersistentVector'''cons keyvals, v)))
                    (if (§ instance? LiteralExpr k)
                        (let [#_"Object" kval (Expr'''eval k)]
                            (if (IPersistentSet'''contains constantKeys, kval)
                                (§ ass allConstantKeysUnique false)
                                (§ ass constantKeys (cast' IPersistentSet (IPersistentCollection'''cons constantKeys, kval)))
                            )
                        )
                        (§ ass keysConstant false)
                    )
                    (when (not (§ instance? LiteralExpr v))
                        (§ ass valsConstant false)
                    )
                )
            )

            (let [#_"Expr" e (MapExpr'new keyvals)]
                (cond
                    (and (§ instance? IObj form) (some? (IMeta'''meta (cast' IObj form))))
                        (MetaExpr'new e, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (IMeta'''meta (cast' IObj form))))
                    keysConstant
                        ;; TBD: Add more detail to exception thrown below.
                        (when allConstantKeysUnique => (throw (IllegalArgumentException. "Duplicate constant keys in map"))
                            (when valsConstant => e
                                (loop-when-recur [#_"IPersistentMap" m PersistentArrayMap'EMPTY #_"int" i 0]
                                                 (< i (IPersistentVector'''length keyvals))
                                                 [(IPersistentMap'''assoc m, (LiteralExpr'''val (cast' LiteralExpr (Indexed'''nth-2 keyvals, i))), (LiteralExpr'''val (cast' LiteralExpr (Indexed'''nth-2 keyvals, (inc i))))) (+ i 2)]
                                              => (ConstantExpr'new m)
                                )
                            )
                        )
                    :else
                        e
                )
            )
        )
    )
)

(class-ns SetExpr (§ implements Expr)
    (def #_"Method" SetExpr'setMethod (Method/getMethod "cloiure.lang.IPersistentSet set(Object[])"))

    (defn- #_"SetExpr" SetExpr'init []
        (hash-map
            #_"IPersistentVector" :keys nil
        )
    )

    (defn #_"SetExpr" SetExpr'new [#_"IPersistentVector" keys]
        (let [this (SetExpr'init)]
            (§ ass this (assoc this :keys keys))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--SetExpr [#_"SetExpr" this]
        (let [#_"Object[]" ret (make-array Object (.count (:keys this)))]
            (dotimes [#_"int" i (.count (:keys this))]
                (aset ret i (Expr'''eval (cast' Expr (Indexed'''nth-2 (:keys this), i))))
            )
            (RT'set ret)
        )
    )

    #_override
    (defn #_"void" Expr'''emit--SetExpr [#_"SetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (MethodExpr'emitArgsAsArray (:keys this), objx, gen)
        (.invokeStatic gen, Compiler'RT_TYPE, SetExpr'setMethod)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--SetExpr [#_"SetExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--SetExpr [#_"SetExpr" this]
        (§ class IPersistentSet)
    )

    (defn #_"Expr" SetExpr'parse [#_"Context" context, #_"IPersistentSet" form]
        (let [[#_"IPersistentVector" keys #_"boolean" constant?]
                (loop-when [keys PersistentVector'EMPTY constant? true #_"ISeq" s (RT'seq form)] (some? s) => [keys constant?]
                    (let [#_"Expr" e (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (.first s))]
                        (recur (cast' IPersistentVector (IPersistentVector'''cons keys, e)) (and constant? (§ instance? LiteralExpr e)) (.next s))
                    )
                )]
            (cond
                (and (§ instance? IObj form) (some? (IMeta'''meta (cast' IObj form))))
                    (MetaExpr'new (SetExpr'new keys), (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (IMeta'''meta (cast' IObj form))))
                constant?
                    (loop-when-recur [#_"IPersistentSet" s PersistentHashSet'EMPTY #_"int" i 0]
                                     (< i (.count keys))
                                     [(cast' IPersistentSet (IPersistentCollection'''cons s, (LiteralExpr'''val (cast' LiteralExpr (Indexed'''nth-2 keys, i))))) (inc i)]
                                  => (ConstantExpr'new s)
                    )
                :else
                    (SetExpr'new keys)
            )
        )
    )
)

(class-ns VectorExpr (§ implements Expr)
    (def #_"Method" VectorExpr'vectorMethod (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))

    (defn- #_"VectorExpr" VectorExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"VectorExpr" VectorExpr'new [#_"IPersistentVector" args]
        (let [this (VectorExpr'init)]
            (§ ass this (assoc this :args args))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--VectorExpr [#_"VectorExpr" this]
        (let [#_"IPersistentVector" ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" i 0] (< i (.count (:args this))) [(inc i)]
                (§ ass ret (cast' IPersistentVector (IPersistentVector'''cons ret, (Expr'''eval (cast' Expr (Indexed'''nth-2 (:args this), i))))))
            )
            ret
        )
    )

    #_override
    (defn #_"void" Expr'''emit--VectorExpr [#_"VectorExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (<= (.count (:args this)) Tuple'MAX_SIZE)
            (do
                (dotimes [#_"int" i (.count (:args this))]
                    (Expr'''emit (cast' Expr (Indexed'''nth-2 (:args this), i)), :Context'EXPRESSION, objx, gen)
                )
                (.invokeStatic gen, Compiler'TUPLE_TYPE, (aget Compiler'createTupleMethods (.count (:args this))))
            )
            (do
                (MethodExpr'emitArgsAsArray (:args this), objx, gen)
                (.invokeStatic gen, Compiler'RT_TYPE, VectorExpr'vectorMethod)
            )
        )

        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--VectorExpr [#_"VectorExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--VectorExpr [#_"VectorExpr" this]
        (§ class IPersistentVector)
    )

    (defn #_"Expr" VectorExpr'parse [#_"Context" context, #_"IPersistentVector" form]
        (let [[#_"IPersistentVector" args #_"boolean" constant?]
                (loop-when [args PersistentVector'EMPTY constant? true #_"int" i 0] (< i (.count form)) => [args constant?]
                    (let [#_"Expr" e (Compiler'analyze-2 (if (= context :Context'EVAL) context :Context'EXPRESSION), (Indexed'''nth-2 form, i))]
                        (recur (cast' IPersistentVector (IPersistentVector'''cons args, e)) (and constant? (§ instance? LiteralExpr e)) (inc i))
                    )
                )]
            (cond
                (and (§ instance? IObj form) (some? (IMeta'''meta (cast' IObj form))))
                    (MetaExpr'new (VectorExpr'new args), (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (IMeta'''meta (cast' IObj form))))
                constant?
                    (loop-when-recur [#_"IPersistentVector" v PersistentVector'EMPTY #_"int" i 0]
                                     (< i (.count args))
                                     [(IPersistentVector'''cons v, (LiteralExpr'''val (cast' LiteralExpr (Indexed'''nth-2 args, i)))) (inc i)]
                                  => (ConstantExpr'new v)
                    )
                :else
                    (VectorExpr'new args)
            )
        )
    )
)

(class-ns KeywordInvokeExpr (§ implements Expr)
    (def #_"Type" KeywordInvokeExpr'ILOOKUP_TYPE (§ unsure Type/getType (§ class ILookup)))

    (defn- #_"KeywordInvokeExpr" KeywordInvokeExpr'init []
        (hash-map
            #_"KeywordExpr" :kw nil
            #_"Object" :tag nil
            #_"Expr" :target nil
            #_"int" :line 0
            #_"int" :column 0
            #_"int" :siteIndex 0

            #_"Class" :jc nil
        )
    )

    (defn #_"KeywordInvokeExpr" KeywordInvokeExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"KeywordExpr" kw, #_"Expr" target]
        (let [this (KeywordInvokeExpr'init)]
            (§ ass this (assoc this :kw kw))
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :siteIndex (Compiler'registerKeywordCallsite (:k kw))))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--KeywordInvokeExpr [#_"KeywordInvokeExpr" this]
        (try
            (IFn'''invoke-2 (:k (:kw this)), (Expr'''eval (:target this)))
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--KeywordInvokeExpr [#_"KeywordInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" endLabel (.newLabel gen) #_"Label" faultLabel (.newLabel gen)]
            (.visitLineNumber gen, (:line this), (.mark gen))
            (.getStatic gen, (:objtype objx), (ObjExpr''thunkNameStatic objx, (:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE)
            (.dup gen) ;; thunk, thunk
            (Expr'''emit (:target this), :Context'EXPRESSION, objx, gen) ;; thunk, thunk, target
            (.visitLineNumber gen, (:line this), (.mark gen))
            (.dupX2 gen) ;; target, thunk, thunk, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_THUNK_TYPE, (Method/getMethod "Object get(Object)")) ;; target, thunk, result
            (.dupX2 gen) ;; result, target, thunk, result
            (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, faultLabel) ;; result, target
            (.pop gen) ;; result
            (.goTo gen, endLabel)

            (.mark gen, faultLabel) ;; result, target
            (.swap gen) ;; target, result
            (.pop gen) ;; target
            (.dup gen) ;; target, target
            (.getStatic gen, (:objtype objx), (ObjExpr''siteNameStatic objx, (:siteIndex this)), ObjExpr'KEYWORD_LOOKUPSITE_TYPE) ;; target, target, site
            (.swap gen) ;; target, site, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_SITE_TYPE, (Method/getMethod "cloiure.lang.ILookupThunk fault(Object)")) ;; target, new-thunk
            (.dup gen) ;; target, new-thunk, new-thunk
            (.putStatic gen, (:objtype objx), (ObjExpr''thunkNameStatic objx, (:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE) ;; target, new-thunk
            (.swap gen) ;; new-thunk, target
            (.invokeInterface gen, ObjExpr'ILOOKUP_THUNK_TYPE, (Method/getMethod "Object get(Object)")) ;; result

            (.mark gen, endLabel)
            (when (= context :Context'STATEMENT)
                (.pop gen)
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--KeywordInvokeExpr [#_"KeywordInvokeExpr" this]
        (some? (:tag this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--KeywordInvokeExpr [#_"KeywordInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (HostExpr'tagToClass (:tag this))))
        )
        (:jc this)
    )
)

(class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"InstanceOfExpr" InstanceOfExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Class" :c nil
        )
    )

    (defn #_"InstanceOfExpr" InstanceOfExpr'new [#_"Class" c, #_"Expr" expr]
        (let [this (InstanceOfExpr'init)]
            (§ ass this (assoc this :expr expr))
            (§ ass this (assoc this :c c))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--InstanceOfExpr [#_"InstanceOfExpr" this]
        (if (.isInstance (:c this), (Expr'''eval (:expr this))) RT'T RT'F)
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--InstanceOfExpr [#_"InstanceOfExpr" this]
        true
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--InstanceOfExpr [#_"InstanceOfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (Expr'''emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.instanceOf gen, (Compiler'getType (:c this)))
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--InstanceOfExpr [#_"InstanceOfExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (MaybePrimitiveExpr'''emitUnboxed this, context, objx, gen)
        (HostExpr'emitBoxReturn objx, gen, Boolean/TYPE)
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--InstanceOfExpr [#_"InstanceOfExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--InstanceOfExpr [#_"InstanceOfExpr" this]
        Boolean/TYPE
    )
)

(class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"StaticInvokeExpr" StaticInvokeExpr'init []
        (hash-map
            #_"Type" :target nil
            #_"Class" :retClass nil
            #_"Class[]" :paramclasses nil
            #_"Type[]" :paramtypes nil
            #_"IPersistentVector" :args nil
            #_"boolean" :variadic false
            #_"boolean" :tailPosition false
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticInvokeExpr" StaticInvokeExpr'new [#_"Type" target, #_"Class" retClass, #_"Class[]" paramclasses, #_"Type[]" paramtypes, #_"boolean" variadic, #_"IPersistentVector" args, #_"Object" tag, #_"boolean" tailPosition]
        (let [this (StaticInvokeExpr'init)]
            (§ ass this (assoc this :target target))
            (§ ass this (assoc this :retClass retClass))
            (§ ass this (assoc this :paramclasses paramclasses))
            (§ ass this (assoc this :paramtypes paramtypes))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :variadic variadic))
            (§ ass this (assoc this :tailPosition tailPosition))
            (§ ass this (assoc this :tag tag))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--StaticInvokeExpr [#_"StaticInvokeExpr" this]
        (throw (UnsupportedOperationException. "Can't eval StaticInvokeExpr"))
    )

    #_override
    (defn #_"void" Expr'''emit--StaticInvokeExpr [#_"StaticInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (MaybePrimitiveExpr'''emitUnboxed this, context, objx, gen)
        (when (not= context :Context'STATEMENT)
            (HostExpr'emitBoxReturn objx, gen, (:retClass this))
        )
        (when (= context :Context'STATEMENT)
            (if (or (= (:retClass this) Long/TYPE) (= (:retClass this) Double/TYPE))
                (.pop2 gen)
                (.pop gen)
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--StaticInvokeExpr [#_"StaticInvokeExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--StaticInvokeExpr [#_"StaticInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (Compiler'retType (when (some? (:tag this)) (HostExpr'tagToClass (:tag this))), (:retClass this))))
        )
        (:jc this)
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--StaticInvokeExpr [#_"StaticInvokeExpr" this]
        (.isPrimitive (:retClass this))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--StaticInvokeExpr [#_"StaticInvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Method" ms (Method. "invokeStatic", (Type/getType (:retClass this)), (:paramtypes this))]
            (when (:variadic this) => (MethodExpr'emitTypedArgs objx, gen, (:paramclasses this), (:args this))
                (dotimes [#_"int" i (dec (alength (:paramclasses this)))]
                    (let [#_"Expr" e (cast' Expr (Indexed'''nth-2 (:args this), i))]
                        (if (= (Compiler'maybePrimitiveType e) (aget (:paramclasses this) i))
                            (do
                                (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr e), :Context'EXPRESSION, objx, gen)
                            )
                            (do
                                (Expr'''emit e, :Context'EXPRESSION, objx, gen)
                                (HostExpr'emitUnboxArg objx, gen, (aget (:paramclasses this) i))
                            )
                        )
                    )
                )
                (let [#_"IPersistentVector" restArgs (RT'subvec (:args this), (dec (alength (:paramclasses this))), (.count (:args this)))]
                    (MethodExpr'emitArgsAsArray restArgs, objx, gen)
                    (.invokeStatic gen, (§ unsure Type/getType (§ class ArraySeq)), (Method/getMethod "cloiure.lang.ArraySeq create(Object[])"))
                )
            )

            (when (and (:tailPosition this) (not (:canBeDirect objx)))
                (ObjMethod''emitClearThis (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
            )

            (.invokeStatic gen, (:target this), ms)
        )
        nil
    )

    (defn #_"Expr" StaticInvokeExpr'parse [#_"Var" v, #_"ISeq" args, #_"Object" tag, #_"boolean" tailPosition]
        (when (and (Var''isBound v) (some? (Var''get v)))
            (let [#_"Class" c (.getClass (Var''get v)) #_"java.lang.reflect.Method[]" methods (.getMethods c) #_"int" argc (RT'count args)
                  [#_"java.lang.reflect.Method" method #_"boolean" variadic]
                    (loop-when [#_"int" i 0] (< i (alength methods)) => [nil false]
                        (let [#_"java.lang.reflect.Method" m (aget methods i)]
                            (or
                                (when (and (Modifier/isStatic (.getModifiers m)) (= (.getName m) "invokeStatic"))
                                    (let [#_"Class[]" types (.getParameterTypes m) #_"int" n (alength types)]
                                        (cond
                                            (= n argc)
                                                [m (and (pos? n) (= (aget types (dec n)) (§ class ISeq)))]
                                            (and (< 0 n argc) (= (aget types (dec n)) (§ class ISeq)))
                                                [m true]
                                        )
                                    )
                                )
                                (recur (inc i))
                            )
                        )
                    )]
                (when (some? method)
                    (let [#_"Class" retClass (.getReturnType method) #_"Class[]" paramClasses (.getParameterTypes method)
                          #_"Type[]" paramTypes (make-array Type (alength paramClasses))
                          _ (dotimes [#_"int" i (alength paramClasses)]
                                (aset paramTypes i (§ unsure Type/getType (aget paramClasses i)))
                            )
                          #_"Type" target (§ unsure Type/getType c)
                          #_"PersistentVector" argv
                            (loop-when-recur [argv PersistentVector'EMPTY #_"ISeq" s (RT'seq args)]
                                             (some? s)
                                             [(IPersistentVector'''cons argv, (Compiler'analyze-2 :Context'EXPRESSION, (.first s))) (.next s)]
                                          => argv
                            )]
                        (StaticInvokeExpr'new target, retClass, paramClasses, paramTypes, variadic, argv, tag, tailPosition)
                    )
                )
            )
        )
    )
)

(class-ns InvokeExpr (§ implements Expr)
    (§ def #_"Keyword" InvokeExpr'onKey (Keyword'intern (Symbol'intern "on")))
    (§ def #_"Keyword" InvokeExpr'methodMapKey (Keyword'intern (Symbol'intern "method-map")))

    (defn- #_"InvokeExpr" InvokeExpr'init []
        (hash-map
            #_"Expr" :fexpr nil
            #_"Object" :tag nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :tailPosition false

            #_"boolean" :isProtocol false
            #_"boolean" :isDirect false
            #_"int" :siteIndex -1
            #_"Class" :protocolOn nil
            #_"java.lang.reflect.Method" :onMethod nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InvokeExpr" InvokeExpr'new [#_"int" line, #_"int" column, #_"Symbol" tag, #_"Expr" fexpr, #_"IPersistentVector" args, #_"boolean" tailPosition]
        (let [this (InvokeExpr'init)]
            (§ ass this (assoc this :fexpr fexpr))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (§ ass this (assoc this :tailPosition tailPosition))

            (when (§ instance? VarExpr fexpr)
                (let [#_"Var" fvar (:var (cast' VarExpr fexpr)) #_"Var" pvar (cast' Var (RT'get-2 (IMeta'''meta fvar), Compiler'protocolKey))]
                    (when (and (some? pvar) (Var''isBound Compiler'PROTOCOL_CALLSITES))
                        (§ ass this (assoc this :isProtocol true))
                        (§ ass this (assoc this :siteIndex (Compiler'registerProtocolCallsite (:var (cast' VarExpr fexpr)))))
                        (let [#_"Object" pon (RT'get-2 (Var''get pvar), Compiler'onKey)]
                            (§ ass this (assoc this :protocolOn (HostExpr'maybeClass pon, false)))
                            (when (some? (:protocolOn this))
                                (let [#_"IPersistentMap" mmap (cast' IPersistentMap (RT'get-2 (Var''get pvar), InvokeExpr'methodMapKey))
                                      #_"Keyword" mmapVal (cast' Keyword (ILookup'''valAt-2 mmap, (Keyword'intern (:sym fvar))))]
                                    (when (nil? mmapVal)
                                        (throw (IllegalArgumentException. (str "No method of interface: " (.getName (:protocolOn this)) " found for function: " (:sym fvar) " of protocol: " (:sym pvar) " (The protocol method may have been defined before and removed.)")))
                                    )
                                    (let [#_"String" mname (Compiler'munge (.toString (:sym mmapVal)))
                                          #_"List" methods (Reflector'getMethods (:protocolOn this), (dec (.count args)), mname, false)]
                                        (when (not= (.size methods) 1)
                                            (throw (IllegalArgumentException. (str "No single method: " mname " of interface: " (.getName (:protocolOn this)) " found for function: " (:sym fvar) " of protocol: " (:sym pvar))))
                                        )
                                        (§ ass this (assoc this :onMethod (cast java.lang.reflect.Method (.get methods, 0))))
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (cond
                (some? tag)                 (assoc this :tag tag)
                (§ instance? VarExpr fexpr) (assoc this :tag (:tag (cast' VarExpr fexpr)))
                :else                       (assoc this :tag nil)
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--InvokeExpr [#_"InvokeExpr" this]
        (try
            (let [#_"IFn" fn (cast' IFn (Expr'''eval (:fexpr this)))
                  #_"PersistentVector" argvs
                    (loop-when-recur [argvs PersistentVector'EMPTY #_"int" i 0]
                                     (< i (.count (:args this)))
                                     [(IPersistentVector'''cons argvs, (Expr'''eval (cast' Expr (Indexed'''nth-2 (:args this), i)))) (inc i)]
                                  => argvs
                    )]
                (IFn'''applyTo fn, (RT'seq (Util'ret1 argvs, (§ ass argvs nil))))
            )
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (:line this), (:column this), e)))
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--InvokeExpr [#_"InvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (if (:isProtocol this)
            (do
                (.visitLineNumber gen, (:line this), (.mark gen))
                (InvokeExpr''emitProto this, context, objx, gen)
            )
            (do
                (Expr'''emit (:fexpr this), :Context'EXPRESSION, objx, gen)
                (.visitLineNumber gen, (:line this), (.mark gen))
                (.checkCast gen, Compiler'IFN_TYPE)
                (InvokeExpr''emitArgsAndCall this, 0, context, objx, gen)
            )
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_method
    (defn #_"void" InvokeExpr''emitProto [#_"InvokeExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let [#_"Label" onLabel (.newLabel gen) #_"Label" callLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)
              #_"Var" v (:var (cast' VarExpr (:fexpr this)))
              #_"Expr" e (cast' Expr (Indexed'''nth-2 (:args this), 0))]
            (Expr'''emit e, :Context'EXPRESSION, objx, gen)
            (.dup gen) ;; target, target
            (.invokeStatic gen, Compiler'UTIL_TYPE, (Method/getMethod "Class classOf(Object)")) ;; target, class
            (.getStatic gen, (:objtype objx), (ObjExpr''cachedClassName objx, (:siteIndex this)), Compiler'CLASS_TYPE) ;; target, class, cached-class
            (.visitJumpInsn gen, Opcodes/IF_ACMPEQ, callLabel) ;; target
            (when (some? (:protocolOn this))
                (.dup gen) ;; target, target
                (.instanceOf gen, (Type/getType (:protocolOn this)))
                (.ifZCmp gen, GeneratorAdapter/NE, onLabel)
            )

            (.dup gen) ;; target, target
            (.invokeStatic gen, Compiler'UTIL_TYPE, (Method/getMethod "Class classOf(Object)")) ;; target, class
            (.putStatic gen, (:objtype objx), (ObjExpr''cachedClassName objx, (:siteIndex this)), Compiler'CLASS_TYPE) ;; target

            (.mark gen, callLabel) ;; target
            (ObjExpr''emitVar objx, gen, v)
            (.invokeVirtual gen, Compiler'VAR_TYPE, (Method/getMethod "Object getRawRoot()")) ;; target, proto-fn
            (.swap gen)
            (InvokeExpr''emitArgsAndCall this, 1, context, objx, gen)
            (.goTo gen, endLabel)

            (.mark gen, onLabel) ;; target
            (when (some? (:protocolOn this))
                (.checkCast gen, (Type/getType (:protocolOn this)))
                (MethodExpr'emitTypedArgs objx, gen, (.getParameterTypes (:onMethod this)), (RT'subvec (:args this), 1, (.count (:args this))))
                (when (= context :Context'RETURN)
                    (ObjMethod''emitClearLocals (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
                )
                (let [#_"Method" m (Method. (.getName (:onMethod this)), (Type/getReturnType (:onMethod this)), (Type/getArgumentTypes (:onMethod this)))]
                    (.invokeInterface gen, (Type/getType (:protocolOn this)), m)
                    (HostExpr'emitBoxReturn objx, gen, (.getReturnType (:onMethod this)))
                )
            )
            (.mark gen, endLabel)
        )
        nil
    )

    #_method
    (defn #_"void" InvokeExpr''emitArgsAndCall [#_"InvokeExpr" this, #_"int" firstArgToEmit, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (loop-when-recur [#_"int" i firstArgToEmit] (< i (Math/min Compiler'MAX_POSITIONAL_ARITY, (.count (:args this)))) [(inc i)]
            (let [#_"Expr" e (cast' Expr (Indexed'''nth-2 (:args this), i))]
                (Expr'''emit e, :Context'EXPRESSION, objx, gen)
            )
        )
        (when (< Compiler'MAX_POSITIONAL_ARITY (.count (:args this)))
            (let [#_"PersistentVector" restArgs PersistentVector'EMPTY]
                (loop-when-recur [#_"int" i Compiler'MAX_POSITIONAL_ARITY] (< i (.count (:args this))) [(inc i)]
                    (§ ass restArgs (IPersistentVector'''cons restArgs, (Indexed'''nth-2 (:args this), i)))
                )
                (MethodExpr'emitArgsAsArray restArgs, objx, gen)
            )
        )
        (.visitLineNumber gen, (:line this), (.mark gen))

        (when (and (:tailPosition this) (not (:canBeDirect objx)))
            (ObjMethod''emitClearThis (cast' ObjMethod (IDeref'''deref Compiler'METHOD)), gen)
        )

        (.invokeInterface gen, Compiler'IFN_TYPE, (Method. "invoke", Compiler'OBJECT_TYPE, (aget Compiler'ARG_TYPES (Math/min (inc Compiler'MAX_POSITIONAL_ARITY), (.count (:args this))))))
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--InvokeExpr [#_"InvokeExpr" this]
        (some? (:tag this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--InvokeExpr [#_"InvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (HostExpr'tagToClass (:tag this))))
        )
        (:jc this)
    )

    (defn #_"Expr" InvokeExpr'parse [#_"Context" context, #_"ISeq" form]
        (let [#_"boolean" tailPosition (Compiler'inTailCall context) context (if (= context :Context'EVAL) context :Context'EXPRESSION)
              #_"Expr" fexpr (Compiler'analyze-2 context, (.first form))]
            (or
                (when (and (§ instance? VarExpr fexpr) (.equals (:var (cast' VarExpr fexpr)), Compiler'INSTANCE) (= (RT'count form) 3))
                    (let-when [#_"Expr" sexpr (Compiler'analyze-2 :Context'EXPRESSION, (RT'second form))] (§ instance? ConstantExpr sexpr)
                        (let-when [#_"Object" val (LiteralExpr'''val (cast' ConstantExpr sexpr))] (instance? Class val)
                            (InstanceOfExpr'new (cast Class val), (Compiler'analyze-2 context, (RT'third form)))
                        )
                    )
                )

                (when (and #_"direct-linking" false (§ instance? VarExpr fexpr) (not= context :Context'EVAL))
                    (let [#_"Var" v (:var (cast' VarExpr fexpr))]
                        (when (and (not (Var''isDynamic v)) (not (RT'booleanCast-1o (RT'get-3 (IMeta'''meta v), Compiler'redefKey, false))))
                            (let [#_"Symbol" formtag (Compiler'tagOf form) #_"Object" vtag (RT'get-2 (RT'meta v), RT'TAG_KEY)]
                                (StaticInvokeExpr'parse v, (RT'next form), (or formtag vtag), tailPosition)
                            )
                        )
                    )
                )

                (when (and (§ instance? KeywordExpr fexpr) (= (RT'count form) 2) (Var''isBound Compiler'KEYWORD_CALLSITES))
                    (let [#_"Expr" target (Compiler'analyze-2 context, (RT'second form))]
                        (KeywordInvokeExpr'new (Compiler'lineDeref), (Compiler'columnDeref), (Compiler'tagOf form), (cast' KeywordExpr fexpr), target)
                    )
                )

                (let [#_"PersistentVector" args PersistentVector'EMPTY
                      _ (loop-when-recur [#_"ISeq" s (RT'seq (.next form))] (some? s) [(.next s)]
                            (§ ass args (IPersistentVector'''cons args, (Compiler'analyze-2 context, (.first s))))
                        )]
                    (InvokeExpr'new (Compiler'lineDeref), (Compiler'columnDeref), (Compiler'tagOf form), fexpr, args, tailPosition)
                )
            )
        )
    )
)

(class-ns FnExpr (§ extends ObjExpr)
    (def #_"Type" FnExpr'aFnType (§ unsure Type/getType (§ class AFunction)))
    (def #_"Type" FnExpr'restFnType (§ unsure Type/getType (§ class RestFn)))

    (defn- #_"FnExpr" FnExpr'init []
        (hash-map
            ;; if there is a variadic overload (there can only be one) it is stored here
            #_"FnMethod" :variadicMethod nil
            #_"IPersistentCollection" :methods nil
            #_"boolean" :hasPrimSigs false
            #_"boolean" :hasMeta false
            #_"boolean" :hasEnclosingMethod false

            #_"Class" :jc nil
        )
    )

    (defn #_"FnExpr" FnExpr'new [#_"Object" tag]
        (merge (ObjExpr'new tag) (FnExpr'init))
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--FnExpr [#_"FnExpr" this]
        true
    )

    #_override
    (defn #_"boolean" ObjExpr'''supportsMeta--FnExpr [#_"FnExpr" this]
        (:hasMeta this)
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--FnExpr [#_"FnExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (§ class AFunction))))
        )
        (:jc this)
    )

    #_protected
    #_override
    (defn #_"void" ObjExpr'''emitMethods--FnExpr [#_"FnExpr" this, #_"ClassVisitor" cv]
        ;; override of invoke/doInvoke for each method
        (loop-when-recur [#_"ISeq" s (RT'seq (:methods this))] (some? s) [(.next s)]
            (§ unsure Expr'''emit (cast' ObjMethod (.first s)), this, cv)
        )

        (when (FnExpr''isVariadic this)
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, (Method/getMethod "int getRequiredArity()"), nil, nil, cv)]
                (.visitCode gen)
                (.push gen, (.count (:reqParms (:variadicMethod this))))
                (.returnValue gen)
                (.endMethod gen)
            )
        )
        nil
    )

    (defn #_"Expr" FnExpr'parse [#_"Context" context, #_"ISeq" form, #_"String" name]
        (let [#_"ISeq" origForm form
              #_"FnExpr" fn (FnExpr'new (Compiler'tagOf form))
              #_"Keyword" retkey (Keyword'intern (Symbol'intern nil, "rettag"))
              #_"Object" rettag (RT'get-2 (RT'meta form), retkey)
              _ (§ ass (:src fn) form)
              #_"ObjMethod" owner (cast' ObjMethod (IDeref'''deref Compiler'METHOD))
              _ (§ ass (:hasEnclosingMethod fn) (some? owner))
              _ (when (some? (IMeta'''meta (cast' IMeta (.first form))))
                    (§ ass (:onceOnly fn) (RT'booleanCast-1o (RT'get-2 (RT'meta (.first form)), (Keyword'intern (Symbol'intern nil, "once")))))
                )
              #_"String" basename (if (some? owner) (:name (:objx owner)) (Compiler'munge (:name (:name (Compiler'currentNS)))))
              [#_"Symbol" nm name]
                (if (§ instance? Symbol (RT'second form))
                    (let [nm (cast' Symbol (RT'second form))]
                        [nm (str (:name nm) "__" (RT'nextID))]
                    )
                    (cond
                        (nil? name)   [nil (str "fn__" (RT'nextID))]
                        (some? owner) [nil (str name "__"(RT'nextID))]
                        :else         [nil name]
                    )
                )
              _ (§ ass (:name fn) (str basename "$" (.replace (Compiler'munge name), ".", "_DOT_")))
              _ (§ ass (:internalName fn) (.replace (:name fn), \., \/))
              _ (§ ass (:objtype fn) (Type/getObjectType (:internalName fn)))
              #_"ArrayList<String>" prims (ArrayList.)]

            (try
                (Var'pushThreadBindings (RT'mapUniqueKeys
                    (object-array [
                        Compiler'CONSTANTS          PersistentVector'EMPTY
                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                        Compiler'VARS               PersistentHashMap'EMPTY
                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                        Compiler'VAR_CALLSITES      (Compiler'emptyVarCallSites)
                        Compiler'NO_RECUR           nil
                    ])
                ))

                ;; arglist might be preceded by symbol naming this fn
                (when (some? nm)
                    (§ ass (:thisName fn) (:name nm))
                    (§ ass form (RT'cons Compiler'FN, (RT'next (RT'next form))))
                )

                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                ;; turn former into latter
                (when (§ instance? IPersistentVector (RT'second form))
                    (§ ass form (RT'list-2 Compiler'FN, (RT'next form)))
                )
                (§ ass (:line fn) (Compiler'lineDeref))
                (§ ass (:column fn) (Compiler'columnDeref))
                (let [#_"FnMethod[]" methodArray (make-array #_"FnMethod" Object (inc Compiler'MAX_POSITIONAL_ARITY))
                      [#_"FnMethod" variadicMethod #_"boolean" usesThis]
                        (loop-when [variadicMethod nil usesThis false #_"ISeq" s (RT'next form)] (some? s) => [variadicMethod usesThis]
                            (let [#_"FnMethod" f (FnMethod'parse fn, (cast' ISeq (RT'first s)), rettag)
                                  usesThis (or usesThis (:usesThis f))
                                  variadicMethod
                                    (if (FnMethod''isVariadic f)
                                        (when (nil? variadicMethod) => (throw (RuntimeException. "Can't have more than 1 variadic overload"))
                                            f
                                        )
                                        (let [#_"int" n (.count (:reqParms f))]
                                            (when (nil? (aget methodArray n)) => (throw (RuntimeException. "Can't have 2 overloads with same arity"))
                                                (aset methodArray n f)
                                                variadicMethod
                                            )
                                        )
                                    )]
                                (when (some? (:prim f))
                                    (.add prims, (:prim f))
                                )
                                (recur variadicMethod usesThis (RT'next s))
                            )
                        )]
                    (when (some? variadicMethod)
                        (loop-when-recur [#_"int" i (inc (.count (:reqParms variadicMethod)))] (<= i Compiler'MAX_POSITIONAL_ARITY) [(inc i)]
                            (when (some? (aget methodArray i))
                                (throw (RuntimeException. "Can't have fixed arity function with more params than variadic function"))
                            )
                        )
                    )

                    (§ ass (:canBeDirect fn) (and (not (:hasEnclosingMethod fn)) (zero? (.count (:closes fn))) (not usesThis)))

                    (let [#_"IPersistentCollection" methods
                            (loop-when [methods nil #_"int" i 0] (< i (alength methodArray)) => methods
                                (let [methods (if (some? (aget methodArray i)) (RT'conj methods, (aget methodArray i)) methods)]
                                    (recur methods (inc i))
                                )
                            )
                          methods (if (some? variadicMethod) (RT'conj methods, variadicMethod) methods)]

                        (when (:canBeDirect fn)
                            (let [#_"Iterator" fmi (.iterator (cast Collection #_"<FnMethod>" methods))]
                                (while (.hasNext fmi)
                                    (let-when [#_"FnMethod" fm (.next fmi)] (some? (:locals fm))
                                        (let [#_"Iterator" lbi (.iterator (cast Collection #_"<LocalBinding>" (RT'keys (:locals fm))))]
                                            (while (.hasNext lbi)
                                                (let-when [#_"LocalBinding" lb (.next lbi)] (:isArg lb)
                                                    (§ ass (:idx lb) (dec (:idx lb)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )

                        (§ ass (:methods fn) methods)
                        (§ ass (:variadicMethod fn) variadicMethod)
                        (§ ass (:keywords fn) (cast' IPersistentMap (IDeref'''deref Compiler'KEYWORDS)))
                        (§ ass (:vars fn) (cast' IPersistentMap (IDeref'''deref Compiler'VARS)))
                        (§ ass (:constants fn) (cast' PersistentVector (IDeref'''deref Compiler'CONSTANTS)))
                        (§ ass (:keywordCallsites fn) (cast' IPersistentVector (IDeref'''deref Compiler'KEYWORD_CALLSITES)))
                        (§ ass (:protocolCallsites fn) (cast' IPersistentVector (IDeref'''deref Compiler'PROTOCOL_CALLSITES)))
                        (§ ass (:varCallsites fn) (cast' IPersistentSet (IDeref'''deref Compiler'VAR_CALLSITES)))

                        (§ ass (:constantsID fn) (RT'nextID))
                    )
                )
                (finally
                    (Var'popThreadBindings)
                )
            )

            (let [_ (§ ass (:hasPrimSigs fn) (pos? (.size prims)))
                  #_"IPersistentMap" fmeta (RT'meta origForm)
                  fmeta (when (some? fmeta) (-> fmeta (IPersistentMap'''without RT'LINE_KEY) (IPersistentMap'''without RT'COLUMN_KEY) (IPersistentMap'''without retkey)))
                  _ (§ ass (:hasMeta fn) (pos? (RT'count fmeta)))]
                (try
                    (ObjExpr''compile fn, (if (FnExpr''isVariadic fn) "cloiure/lang/RestFn" "cloiure/lang/AFunction"), (when (pos? (.size prims)) (.toArray prims, (make-array String (.size prims)))), (:onceOnly fn))
                    (catch IOException e
                        (throw (Util'sneakyThrow e))
                    )
                )
                (ObjExpr''getCompiledClass fn)
                (when (ObjExpr'''supportsMeta fn) => fn
                    (MetaExpr'new fn, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), fmeta))
                )
            )
        )
    )

    #_method
    (defn #_"boolean" FnExpr''isVariadic [#_"FnExpr" this]
        (some? (:variadicMethod this))
    )

    #_method
    (defn #_"void" FnExpr''emitForDefn [#_"FnExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (Expr'''emit this, :Context'EXPRESSION, objx, gen)
        nil
    )
)

(class-ns ObjExpr (§ implements Expr)
    (def #_"String" ObjExpr'CONST_PREFIX "const__")

    (def #_"Method" ObjExpr'voidctor (Method/getMethod "void <init>()"))

    (def #_"Type" ObjExpr'DYNAMIC_CLASSLOADER_TYPE (§ unsure Type/getType (§ class DynamicClassLoader)))
    (def #_"Method" ObjExpr'getClassMethod (Method/getMethod "Class getClass()"))
    (def #_"Method" ObjExpr'getClassLoaderMethod (Method/getMethod "ClassLoader getClassLoader()"))
    (def #_"Method" ObjExpr'getConstantsMethod (Method/getMethod "Object[] getConstants(int)"))
    (def #_"Method" ObjExpr'readStringMethod (Method/getMethod "Object readString(String)"))

    (def #_"Type" ObjExpr'ILOOKUP_SITE_TYPE (§ unsure Type/getType (§ class ILookupSite)))
    (def #_"Type" ObjExpr'ILOOKUP_THUNK_TYPE (§ unsure Type/getType (§ class ILookupThunk)))
    (def #_"Type" ObjExpr'KEYWORD_LOOKUPSITE_TYPE (§ unsure Type/getType (§ class KeywordLookupSite)))

    (defn- #_"ObjExpr" ObjExpr'init []
        (hash-map
            #_"String" :name nil
            #_"String" :internalName nil
            #_"String" :thisName nil
            #_"Type" :objtype nil
            #_"Object" :tag nil
            ;; localbinding->itself
            #_"IPersistentMap" :closes PersistentHashMap'EMPTY
            ;; localbndingexprs
            #_"IPersistentVector" :closesExprs PersistentVector'EMPTY
            ;; symbols
            #_"IPersistentSet" :volatiles PersistentHashSet'EMPTY

            ;; symbol->lb
            #_"IPersistentMap" :fields nil

            ;; hinted fields
            #_"IPersistentVector" :hintedFields PersistentVector'EMPTY

            ;; Keyword->KeywordExpr
            #_"IPersistentMap" :keywords PersistentHashMap'EMPTY
            #_"IPersistentMap" :vars PersistentHashMap'EMPTY
            #_"Class" :compiledClass nil
            #_"int" :line 0
            #_"int" :column 0
            #_"PersistentVector" :constants nil
            #_"IPersistentSet" :usedConstants PersistentHashSet'EMPTY

            #_"int" :constantsID 0
            #_"int" :altCtorDrops 0

            #_"IPersistentVector" :keywordCallsites nil
            #_"IPersistentVector" :protocolCallsites nil
            #_"IPersistentSet" :varCallsites nil
            #_"boolean" :onceOnly false

            #_"Object" :src nil

            #_"IPersistentMap" :opts PersistentHashMap'EMPTY

            #_protected
            #_"IPersistentMap" :classMeta nil
            #_protected
            #_"boolean" :canBeDirect false

            #_"DynamicClassLoader" :loader nil
            #_"byte[]" :bytecode nil

            #_"Class" :jc nil
        )
    )

    (defn #_"ObjExpr" ObjExpr'new [#_"Object" tag]
        (let [this (ObjExpr'init)]
            (§ ass this (assoc this :tag tag))
            this
        )
    )

    (defn #_"String" ObjExpr'trimGenID [#_"String" name]
        (let [#_"int" i (.lastIndexOf name, "__")]
            (if (= i -1) name (.substring name, 0, i))
        )
    )

    #_method
    (defn #_"Type[]" ObjExpr''ctorTypes [#_"ObjExpr" this]
        (let [#_"IPersistentVector" tv (if (not (ObjExpr'''supportsMeta this)) PersistentVector'EMPTY (RT'vector Compiler'IPERSISTENTMAP_TYPE))]
            (loop-when-recur [#_"ISeq" s (RT'keys (:closes this))] (some? s) [(.next s)]
                (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                    (§ ass tv (IPersistentVector'''cons tv, (if (some? (LocalBinding''getPrimitiveType lb)) (Type/getType (LocalBinding''getPrimitiveType lb)) Compiler'OBJECT_TYPE)))
                )
            )
            (let [#_"Type[]" ret (make-array Type (.count tv))]
                (dotimes [#_"int" i (.count tv)]
                    (aset ret i (cast Type (Indexed'''nth-2 tv, i)))
                )
                ret
            )
        )
    )

    #_method
    (defn #_"void" ObjExpr''compile [#_"ObjExpr" this, #_"String" superName, #_"String[]" interfaceNames, #_"boolean" oneTimeUse] #_(§ throws IOException)
        ;; create bytecode for a class
        ;; with name current_ns.defname[$letname]+
        ;; anonymous fns get names fn__id
        ;; derived from AFn'RestFn
        (let [#_"ClassWriter" cw (ClassWriter. ClassWriter/COMPUTE_MAXS) #_"ClassVisitor" cv cw]
            (.visit cv, Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER Opcodes/ACC_FINAL), (:internalName this), nil, superName, interfaceNames)
            (when (ObjExpr'''supportsMeta this)
                (.visitField cv, Opcodes/ACC_FINAL, "__meta", (.getDescriptor Compiler'IPERSISTENTMAP_TYPE), nil, nil)
            )
            ;; instance fields for closed-overs
            (loop-when-recur [#_"ISeq" s (RT'keys (:closes this))] (some? s) [(.next s)]
                (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))
                      #_"String" fd
                        (if (some? (LocalBinding''getPrimitiveType lb))
                            (.getDescriptor (Type/getType (LocalBinding''getPrimitiveType lb)))
                            ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                            (.getDescriptor Compiler'OBJECT_TYPE)
                        )]
                    (if (ObjExpr''isDeftype this)
                        (let [#_"int" access
                                (cond
                                    (ObjExpr''isVolatile this, lb) Opcodes/ACC_VOLATILE
                                    (ObjExpr''isMutable this, lb) 0
                                    :else (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL)
                                )]
                            (.visitField cv, access, (:name lb), fd, nil, nil)
                        )
                        ;; todo - only enable this non-private+writability for letfns where we need it
                        (let [#_"int" access
                                (if (some? (LocalBinding''getPrimitiveType lb))
                                    (if (ObjExpr''isVolatile this, lb) Opcodes/ACC_VOLATILE 0)
                                    0
                                )]
                            (.visitField cv, access, (:name lb), fd, nil, nil)
                        )
                    )
                )
            )

            ;; static fields for callsites and thunks
            (dotimes [#_"int" i (.count (:protocolCallsites this))]
                (.visitField cv, (+ Opcodes/ACC_PRIVATE Opcodes/ACC_STATIC), (ObjExpr''cachedClassName this, i), (.getDescriptor Compiler'CLASS_TYPE), nil, nil)
            )

            ;; ctor that takes closed-overs and inits base + fields
            (let [#_"Method" m (Method. "<init>", Type/VOID_TYPE, (ObjExpr''ctorTypes this))
                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, nil, cv)
                  #_"Label" start (.newLabel ctorgen) #_"Label" end (.newLabel ctorgen)]
                (.visitCode ctorgen)
                (.visitLineNumber ctorgen, (:line this), (.mark ctorgen))
                (.visitLabel ctorgen, start)
                (.loadThis ctorgen)
                (.invokeConstructor ctorgen, (Type/getObjectType superName), ObjExpr'voidctor)

                (when (ObjExpr'''supportsMeta this)
                    (.loadThis ctorgen)
                    (.visitVarInsn ctorgen, (.getOpcode Compiler'IPERSISTENTMAP_TYPE, Opcodes/ILOAD), 1)
                    (.putField ctorgen, (:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE)
                )

                (let [#_"int" a
                        (loop-when [a (if (ObjExpr'''supportsMeta this) 2 1) #_"ISeq" s (RT'keys (:closes this))] (some? s) => a
                            (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                                (.loadThis ctorgen)
                                (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)
                                      a (if (some? primc)
                                            (do
                                                (.visitVarInsn ctorgen, (.getOpcode (Type/getType primc), Opcodes/ILOAD), a)
                                                (.putField ctorgen, (:objtype this), (:name lb), (Type/getType primc))
                                                (if (any = primc Long/TYPE Double/TYPE) (inc a) a)
                                            )
                                            (do
                                                (.visitVarInsn ctorgen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), a)
                                                (.putField ctorgen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                                                a
                                            )
                                        )]
                                    (§ ass this (assoc this :closesExprs (IPersistentVector'''cons (:closesExprs this), (LocalBindingExpr'new lb, nil))))
                                )
                                (recur (inc a) (.next s))
                            )
                        )]

                    (.visitLabel ctorgen, end)
                    (.returnValue ctorgen)
                    (.endMethod ctorgen)

                    (when (pos? (:altCtorDrops this))
                        (let [#_"Type[]" ctorTypes (ObjExpr''ctorTypes this)]

                            ;; ctor that takes closed-overs and inits base + fields
                            (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) (:altCtorDrops this)))
                                  _ (dotimes [#_"int" i (alength altCtorTypes)]
                                        (aset altCtorTypes i (aget ctorTypes i))
                                    )
                                  #_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)
                                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                                (.visitCode ctorgen)
                                (.loadThis ctorgen)
                                (.loadArgs ctorgen)

                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __meta
                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __extmap
                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                (.returnValue ctorgen)
                                (.endMethod ctorgen)
                            )

                            ;; alt ctor no __hash, __hasheq
                            (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) 2))
                                  _ (dotimes [#_"int" i (alength altCtorTypes)]
                                        (aset altCtorTypes i (aget ctorTypes i))
                                    )
                                  #_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)
                                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                                (.visitCode ctorgen)
                                (.loadThis ctorgen)
                                (.loadArgs ctorgen)

                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                                (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                                (.returnValue ctorgen)
                                (.endMethod ctorgen)
                            )
                        )
                    )

                    (when (ObjExpr'''supportsMeta this)
                        (let [#_"Type[]" ctorTypes (ObjExpr''ctorTypes this)]

                            ;; ctor that takes closed-overs but not meta
                            (let [#_"Type[]" noMetaCtorTypes (make-array Type (dec (alength ctorTypes)))
                                  _ (loop-when-recur [#_"int" i 1] (< i (alength ctorTypes)) [(inc i)]
                                        (aset noMetaCtorTypes (dec i) (aget ctorTypes i))
                                    )
                                  #_"Method" alt (Method. "<init>", Type/VOID_TYPE, noMetaCtorTypes)
                                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                                (.visitCode ctorgen)
                                (.loadThis ctorgen)
                                (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; nil meta
                                (.loadArgs ctorgen)
                                (.invokeConstructor ctorgen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))
                                (.returnValue ctorgen)
                                (.endMethod ctorgen)
                            )

                            ;; meta()
                            (let [#_"Method" meth (Method/getMethod "cloiure.lang.IPersistentMap meta()")
                                  #_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, meth, nil, nil, cv)]
                                (.visitCode gen)
                                (.loadThis gen)
                                (.getField gen, (:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE)
                                (.returnValue gen)
                                (.endMethod gen)
                            )

                            ;; withMeta()
                            (let [#_"Method" meth (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")
                                  #_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, meth, nil, nil, cv)]
                                (.visitCode gen)
                                (.newInstance gen, (:objtype this))
                                (.dup gen)
                                (.loadArg gen, 0)
                                (loop-when-recur [a a #_"ISeq" s (RT'keys (:closes this))] (some? s) [(inc a) (.next s)]
                                    (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                                        (.loadThis gen)
                                        (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                                            (.getField gen, (:objtype this), (:name lb), (if (some? primc) (Type/getType primc) Compiler'OBJECT_TYPE))
                                        )
                                    )
                                )
                                (.invokeConstructor gen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, ctorTypes))
                                (.returnValue gen)
                                (.endMethod gen)
                            )
                        )
                    )

                    (ObjExpr'''emitStatics this, cv)
                    (ObjExpr'''emitMethods this, cv)

                    ;; static fields for constants
                    (dotimes [#_"int" i (.count (:constants this))]
                        (when (IPersistentSet'''contains (:usedConstants this), i)
                            (.visitField cv, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL Opcodes/ACC_STATIC), (ObjExpr''constantName this, i), (.getDescriptor (ObjExpr''constantType this, i)), nil, nil)
                        )
                    )

                    ;; static fields for lookup sites
                    (dotimes [#_"int" i (.count (:keywordCallsites this))]
                        (.visitField cv, (+ Opcodes/ACC_FINAL Opcodes/ACC_STATIC), (ObjExpr''siteNameStatic this, i), (.getDescriptor ObjExpr'KEYWORD_LOOKUPSITE_TYPE), nil, nil)
                        (.visitField cv, Opcodes/ACC_STATIC, (ObjExpr''thunkNameStatic this, i), (.getDescriptor ObjExpr'ILOOKUP_THUNK_TYPE), nil, nil)
                    )

                    ;; static init for constants, keywords and vars
                    (let [#_"GeneratorAdapter" clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, cv)]
                        (.visitCode clinitgen)
                        (.visitLineNumber clinitgen, (:line this), (.mark clinitgen))

                        (when (pos? (.count (:constants this)))
                            (ObjExpr''emitConstants this, clinitgen)
                        )

                        (when (pos? (.count (:keywordCallsites this)))
                            (ObjExpr''emitKeywordCallsites this, clinitgen)
                        )

                        (when (and (ObjExpr''isDeftype this) (RT'booleanCast-1o (RT'get-2 (:opts this), Compiler'loadNs)))
                            (let [#_"String" nsname (Named'''getNamespace (cast' Symbol (RT'second (:src this))))]
                                (when (not (= nsname "cloiure.core"))
                                    (.push clinitgen, "cloiure.core")
                                    (.push clinitgen, "require")
                                    (.invokeStatic clinitgen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Var var(String, String)"))
                                    (.invokeVirtual clinitgen, Compiler'VAR_TYPE, (Method/getMethod "Object getRawRoot()"))
                                    (.checkCast clinitgen, Compiler'IFN_TYPE)
                                    (.push clinitgen, nsname)
                                    (.invokeStatic clinitgen, Compiler'SYMBOL_TYPE, (Method/getMethod "cloiure.lang.Symbol create(String)"))
                                    (.invokeInterface clinitgen, Compiler'IFN_TYPE, (Method/getMethod "Object invoke(Object)"))
                                    (.pop clinitgen)
                                )
                            )
                        )

                        (.returnValue clinitgen)
                        (.endMethod clinitgen)
                        ;; end of class
                        (.visitEnd cv)

                        (§ ass this (assoc this :bytecode (.toByteArray cw)))
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"void" ObjExpr''emitKeywordCallsites [#_"ObjExpr" this, #_"GeneratorAdapter" clinitgen]
        (dotimes [#_"int" i (.count (:keywordCallsites this))]
            (let [#_"Keyword" k (cast' Keyword (Indexed'''nth-2 (:keywordCallsites this), i))]
                (.newInstance clinitgen, ObjExpr'KEYWORD_LOOKUPSITE_TYPE)
                (.dup clinitgen)
                (ObjExpr''emitValue this, k, clinitgen)
                (.invokeConstructor clinitgen, ObjExpr'KEYWORD_LOOKUPSITE_TYPE, (Method/getMethod "void <init>(cloiure.lang.Keyword)"))
                (.dup clinitgen)
                (.putStatic clinitgen, (:objtype this), (ObjExpr''siteNameStatic this, i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE)
                (.putStatic clinitgen, (:objtype this), (ObjExpr''thunkNameStatic this, i), ObjExpr'ILOOKUP_THUNK_TYPE)
            )
        )
        nil
    )

    #_protected
    #_abstract
    (defn #_"void" ObjExpr'''emitStatics [#_"ObjExpr" this, #_"ClassVisitor" gen]
        nil
    )

    #_protected
    #_abstract
    (defn #_"void" ObjExpr'''emitMethods [#_"ObjExpr" this, #_"ClassVisitor" gen]
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitListAsObjectArray [#_"ObjExpr" this, #_"Object" value, #_"GeneratorAdapter" gen]
        (.push gen, (.size (cast List value)))
        (.newArray gen, Compiler'OBJECT_TYPE)
        (loop-when-recur [#_"Iterator" it (.iterator (cast List value)) #_"int" i 0] (.hasNext it) [it (inc i)]
            (.dup gen)
            (.push gen, i)
            (ObjExpr''emitValue this, (.next it), gen)
            (.arrayStore gen, Compiler'OBJECT_TYPE)
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitValue [#_"ObjExpr" this, #_"Object" value, #_"GeneratorAdapter" gen]
        (let [#_"boolean" partial true]
            (cond (nil? value)
                (do
                    (.visitInsn gen, Opcodes/ACONST_NULL)
                )
                (instance? String value)
                (do
                    (.push gen, (cast String value))
                )
                (instance? Boolean value)
                (do
                    (.getStatic gen, Compiler'BOOLEAN_OBJECT_TYPE, (if (.booleanValue (cast Boolean value)) "TRUE" "FALSE"), Compiler'BOOLEAN_OBJECT_TYPE)
                )
                (instance? Integer value)
                (do
                    (.push gen, (.intValue (cast Integer value)))
                    (.invokeStatic gen, (Type/getType Integer), (Method/getMethod "Integer valueOf(int)"))
                )
                (instance? Long value)
                (do
                    (.push gen, (.longValue (cast Long value)))
                    (.invokeStatic gen, (Type/getType Long), (Method/getMethod "Long valueOf(long)"))
                )
                (instance? Double value)
                (do
                    (.push gen, (.doubleValue (cast Double value)))
                    (.invokeStatic gen, (Type/getType Double), (Method/getMethod "Double valueOf(double)"))
                )
                (instance? Character value)
                (do
                    (.push gen, (.charValue (cast Character value)))
                    (.invokeStatic gen, (Type/getType Character), (Method/getMethod "Character valueOf(char)"))
                )
                (instance? Class value)
                (let [#_"Class" cc (cast Class value)]
                    (if (.isPrimitive cc)
                        (let [#_"Type" bt
                                (condp = cc
                                    Boolean/TYPE   (Type/getType Boolean)
                                    Byte/TYPE      (Type/getType Byte)
                                    Character/TYPE (Type/getType Character)
                                    Double/TYPE    (Type/getType Double)
                                    Float/TYPE     (Type/getType Float)
                                    Integer/TYPE   (Type/getType Integer)
                                    Long/TYPE      (Type/getType Long)
                                    Short/TYPE     (Type/getType Short)
                                    (throw (RuntimeException. (str "Can't embed unknown primitive in code: " value)))
                                )]
                            (.getStatic gen, bt, "TYPE", (Type/getType Class))
                        )
                        (do
                            (.push gen, (Compiler'destubClassName (.getName cc)))
                            (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "Class classForName(String)"))
                        )
                    )
                )
                (§ instance? Symbol value)
                (do
                    (.push gen, (:ns (cast' Symbol value)))
                    (.push gen, (:name (cast' Symbol value)))
                    (.invokeStatic gen, (§ unsure Type/getType (§ class Symbol)), (Method/getMethod "cloiure.lang.Symbol intern(String, String)"))
                )
                (§ instance? Keyword value)
                (do
                    (.push gen, (:ns (:sym (cast' Keyword value))))
                    (.push gen, (:name (:sym (cast' Keyword value))))
                    (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Keyword keyword(String, String)"))
                )
                (§ instance? Var value)
                (let [#_"Var" var (cast' Var value)]
                    (.push gen, (.toString (:name (:ns var))))
                    (.push gen, (.toString (:sym var)))
                    (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.Var var(String, String)"))
                )
                (§ instance? IType value)
                (let [#_"Method" ctor (Method. "<init>", (Type/getConstructorDescriptor (aget (.getConstructors (.getClass value)) 0)))]
                    (.newInstance gen, (Type/getType (.getClass value)))
                    (.dup gen)
                    (let [#_"IPersistentVector" fields (cast' IPersistentVector (Reflector'invokeStaticMethod-3c (.getClass value), "getBasis", (object-array 0)))]
                        (loop-when-recur [#_"ISeq" s (RT'seq fields)] (some? s) [(.next s)]
                            (let [#_"Symbol" field (cast' Symbol (.first s))]
                                (ObjExpr''emitValue this, (Reflector'getInstanceField value, (Compiler'munge (:name field))), gen)
                                (let-when [#_"Class" k (Compiler'tagClass (Compiler'tagOf field))] (.isPrimitive k)
                                    (let [#_"Type" b (Type/getType (Compiler'boxClass k))]
                                        (.invokeVirtual gen, b, (Method. (str (.getName k) "Value"), (str "()" (.getDescriptor (Type/getType k)))))
                                    )
                                )
                            )
                        )
                        (.invokeConstructor gen, (Type/getType (.getClass value)), ctor)
                    )
                )
                (§ instance? IRecord value)
                (let [#_"Method" createMethod (Method/getMethod (str (.getName (.getClass value)) " create(cloiure.lang.IPersistentMap)"))]
                    (ObjExpr''emitValue this, (PersistentArrayMap'create (cast java.util.Map value)), gen)
                    (.invokeStatic gen, (Compiler'getType (.getClass value)), createMethod)
                )
                (§ instance? IPersistentMap value)
                (let [#_"List" entries (ArrayList.)]
                    (doseq [#_"Map$Entry" entry (cast Set #_"<Map$Entry>" (.entrySet (cast Map value)))]
                        (.add entries, (.getKey entry))
                        (.add entries, (.getValue entry))
                    )
                    (ObjExpr''emitListAsObjectArray this, entries, gen)
                    (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
                )
                (§ instance? IPersistentVector value)
                (let [#_"IPersistentVector" args (cast' IPersistentVector value)]
                    (if (<= (.count args) Tuple'MAX_SIZE)
                        (do
                            (dotimes [#_"int" i (.count args)]
                                (ObjExpr''emitValue this, (Indexed'''nth-2 args, i), gen)
                            )
                            (.invokeStatic gen, Compiler'TUPLE_TYPE, (aget Compiler'createTupleMethods (.count args)))
                        )
                        (do
                            (ObjExpr''emitListAsObjectArray this, value, gen)
                            (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))
                        )
                    )
                )
                (§ instance? PersistentHashSet value)
                (let [#_"ISeq" vs (RT'seq value)]
                    (if (nil? vs)
                        (do
                            (.getStatic gen, (§ unsure Type/getType (§ class PersistentHashSet)), "EMPTY", (§ unsure Type/getType (§ class PersistentHashSet)))
                        )
                        (do
                            (ObjExpr''emitListAsObjectArray this, vs, gen)
                            (.invokeStatic gen, (§ unsure Type/getType (§ class PersistentHashSet)), (Method/getMethod "cloiure.lang.PersistentHashSet create(Object[])"))
                        )
                    )
                )
                (or (§ instance? ISeq value) (§ instance? IPersistentList value))
                (do
                    (ObjExpr''emitListAsObjectArray this, value, gen)
                    (.invokeStatic gen, (Type/getType java.util.Arrays), (Method/getMethod "java.util.List asList(Object[])"))
                    (.invokeStatic gen, (§ unsure Type/getType (§ class PersistentList)), (Method/getMethod "cloiure.lang.IPersistentList create(java.util.List)"))
                )
                (instance? Pattern value)
                (do
                    (ObjExpr''emitValue this, (.toString value), gen)
                    (.invokeStatic gen, (Type/getType Pattern), (Method/getMethod "java.util.regex.Pattern compile(String)"))
                )
                :else
                (let [#_"String" cs nil]
                    (try
                        (§ ass cs (RT'printString value))
                        (catch Exception e
                            (throw (RuntimeException. (str "Can't embed object in code: " value)))
                        )
                    )
                    (when (zero? (.length cs))
                        (throw (RuntimeException. (str "Can't embed unreadable object in code: " value)))
                    )
                    (when (.startsWith cs, "#<")
                        (throw (RuntimeException. (str "Can't embed unreadable object in code: " cs)))
                    )

                    (.push gen, cs)
                    (.invokeStatic gen, Compiler'RT_TYPE, ObjExpr'readStringMethod)
                    (§ ass partial false)
                )
            )

            (when partial
                (when (and (§ instance? IObj value) (pos? (RT'count (IMeta'''meta (cast' IObj value)))))
                    (.checkCast gen, Compiler'IOBJ_TYPE)
                    (ObjExpr''emitValue this, (IMeta'''meta (cast' IObj value)), gen)
                    (.checkCast gen, Compiler'IPERSISTENTMAP_TYPE)
                    (.invokeInterface gen, Compiler'IOBJ_TYPE, (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitConstants [#_"ObjExpr" this, #_"GeneratorAdapter" clinitgen]
        (dotimes [#_"int" i (.count (:constants this))]
            (when (IPersistentSet'''contains (:usedConstants this), i)
                (ObjExpr''emitValue this, (Indexed'''nth-2 (:constants this), i), clinitgen)
                (.checkCast clinitgen, (ObjExpr''constantType this, i))
                (.putStatic clinitgen, (:objtype this), (ObjExpr''constantName this, i), (ObjExpr''constantType this, i))
            )
        )
        nil
    )

    #_method
    (defn #_"boolean" ObjExpr''isMutable [#_"ObjExpr" this, #_"LocalBinding" lb]
        (or (ObjExpr''isVolatile this, lb) (and (RT'booleanCast-1o (RT'contains (:fields this), (:sym lb))) (RT'booleanCast-1o (RT'get-2 (IMeta'''meta (:sym lb)), (Keyword'intern (Symbol'intern "unsynchronized-mutable"))))))
    )

    #_method
    (defn #_"boolean" ObjExpr''isVolatile [#_"ObjExpr" this, #_"LocalBinding" lb]
        (and (RT'booleanCast-1o (RT'contains (:fields this), (:sym lb))) (RT'booleanCast-1o (RT'get-2 (IMeta'''meta (:sym lb)), (Keyword'intern (Symbol'intern "volatile-mutable")))))
    )

    #_method
    (defn #_"boolean" ObjExpr''isDeftype [#_"ObjExpr" this]
        (some? (:fields this))
    )

    #_abstract
    (defn #_"boolean" ObjExpr'''supportsMeta [#_"ObjExpr" this]
        (not (ObjExpr''isDeftype this))
    )

    #_method
    (defn #_"void" ObjExpr''emitClearCloses [#_"ObjExpr" this, #_"GeneratorAdapter" gen]
        nil
    )

    #_method
    (defn #_"Class" ObjExpr''getCompiledClass [#_"ObjExpr" this]
        (§ sync this
            (when (nil? (:compiledClass this))
                (§ ass this (assoc this :loader (cast' DynamicClassLoader (IDeref'''deref Compiler'LOADER))))
                (§ ass this (assoc this :compiledClass (.defineClass (:loader this), (:name this), (:bytecode this), (:src this))))
            )
            (:compiledClass this)
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--ObjExpr [#_"ObjExpr" this]
        (when-not (ObjExpr''isDeftype this)
            (try
                (.newInstance (ObjExpr''getCompiledClass this))
                (catch Exception e
                    (throw (Util'sneakyThrow e))
                )
            )
        )
    )

    #_method
    (defn #_"void" ObjExpr''emitLetFnInits [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"ObjExpr" objx, #_"IPersistentSet" letFnLocals]
        ;; objx arg is enclosing objx, not this
        (.checkCast gen, (:objtype this))

        (loop-when-recur [#_"ISeq" s (RT'keys (:closes this))] (some? s) [(.next s)]
            (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))]
                (when (IPersistentSet'''contains letFnLocals, lb)
                    (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                        (.dup gen)
                        (if (some? primc)
                            (do
                                (ObjExpr''emitUnboxedLocal objx, gen, lb)
                                (.putField gen, (:objtype this), (:name lb), (Type/getType primc))
                            )
                            (do
                                (ObjExpr''emitLocal objx, gen, lb, false)
                                (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                            )
                        )
                    )
                )
            )
        )
        (.pop gen)
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--ObjExpr [#_"ObjExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
        ;; objx arg is enclosing objx, not this
        (when-not (ObjExpr''isDeftype this) => (.visitInsn gen, Opcodes/ACONST_NULL)
            (.newInstance gen, (:objtype this))
            (.dup gen)
            (when (ObjExpr'''supportsMeta this)
                (.visitInsn gen, Opcodes/ACONST_NULL)
            )
            (loop-when-recur [#_"ISeq" s (RT'seq (:closesExprs this))] (some? s) [(.next s)]
                (let [#_"LocalBindingExpr" lbe (cast' LocalBindingExpr (.first s)) #_"LocalBinding" lb (:lb lbe)]
                    (if (some? (LocalBinding''getPrimitiveType lb))
                        (ObjExpr''emitUnboxedLocal objx, gen, lb)
                        (ObjExpr''emitLocal objx, gen, lb, (:shouldClear lbe))
                    )
                )
            )
            (.invokeConstructor gen, (:objtype this), (Method. "<init>", Type/VOID_TYPE, (ObjExpr''ctorTypes this)))
        )
        (when (= context :Context'STATEMENT)
            (.pop gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--ObjExpr [#_"ObjExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--ObjExpr [#_"ObjExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (cond (some? (:compiledClass this)) (:compiledClass this) (some? (:tag this)) (HostExpr'tagToClass (:tag this)) :else (§ class IFn))))
        )
        (:jc this)
    )

    #_method
    (defn #_"void" ObjExpr''emitAssignLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"Expr" val]
        (when (ObjExpr''isMutable this, lb) => (throw (IllegalArgumentException. (str "Cannot assign to non-mutable: " (:name lb))))
            (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                (.loadThis gen)
                (if (some? primc)
                    (do
                        (when (not (and (§ instance? MaybePrimitiveExpr val) (MaybePrimitiveExpr'''canEmitPrimitive (cast' MaybePrimitiveExpr val))))
                            (throw (IllegalArgumentException. (str "Must assign primitive to primitive mutable: " (:name lb))))
                        )
                        (let [#_"MaybePrimitiveExpr" me (cast' MaybePrimitiveExpr val)]
                            (MaybePrimitiveExpr'''emitUnboxed me, :Context'EXPRESSION, this, gen)
                            (.putField gen, (:objtype this), (:name lb), (Type/getType primc))
                        )
                    )
                    (do
                        (Expr'''emit val, :Context'EXPRESSION, this, gen)
                        (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"void" ObjExpr''emitLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb, #_"boolean" clear]
        (if (Associative'''containsKey (:closes this), lb)
            (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                (.loadThis gen)
                (if (some? primc)
                    (do
                        (.getField gen, (:objtype this), (:name lb), (Type/getType primc))
                        (HostExpr'emitBoxReturn this, gen, primc)
                    )
                    (do
                        (.getField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                        (when (and (:onceOnly this) clear (:canBeCleared lb))
                            (.loadThis gen)
                            (.visitInsn gen, Opcodes/ACONST_NULL)
                            (.putField gen, (:objtype this), (:name lb), Compiler'OBJECT_TYPE)
                        )
                    )
                )
            )
            (let [#_"Class" primc (LocalBinding''getPrimitiveType lb)]
                (if (:isArg lb)
                    (let [#_"int" argoff (if (:canBeDirect this) 0 1)]
                        (.loadArg gen, (- (:idx lb) argoff))
                        (cond (some? primc)
                            (do
                                (HostExpr'emitBoxReturn this, gen, primc)
                            )
                            (and clear (:canBeCleared lb))
                            (do
                                (.visitInsn gen, Opcodes/ACONST_NULL)
                                (.storeArg gen, (- (:idx lb) argoff))
                            )
                        )
                    )
                    (if (some? primc)
                        (do
                            (.visitVarInsn gen, (.getOpcode (Type/getType primc), Opcodes/ILOAD), (:idx lb))
                            (HostExpr'emitBoxReturn this, gen, primc)
                        )
                        (do
                            (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:idx lb))
                            (when (and clear (:canBeCleared lb))
                                (.visitInsn gen, Opcodes/ACONST_NULL)
                                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx lb))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"void" ObjExpr''emitUnboxedLocal [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"LocalBinding" lb]
        (cond (Associative'''containsKey (:closes this), lb)
            (do
                (.loadThis gen)
                (.getField gen, (:objtype this), (:name lb), (Type/getType (LocalBinding''getPrimitiveType lb)))
            )
            (:isArg lb)
            (do
                (.loadArg gen, (- (:idx lb) (if (:canBeDirect this) 0 1)))
            )
            :else
            (do
                (.visitVarInsn gen, (.getOpcode (Type/getType (LocalBinding''getPrimitiveType lb)), Opcodes/ILOAD), (:idx lb))
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitVar [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Var" var]
        (let [#_"Integer" i (cast Integer (ILookup'''valAt-2 (:vars this), var))]
            (ObjExpr''emitConstant this, gen, i)
        )
        nil
    )

    (def #_"Method" ObjExpr'varGetMethod (Method/getMethod "Object get()"))
    (def #_"Method" ObjExpr'varGetRawMethod (Method/getMethod "Object getRawRoot()"))

    #_method
    (defn #_"void" ObjExpr''emitVarValue [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Var" v]
        (let [#_"Integer" i (cast Integer (ILookup'''valAt-2 (:vars this), v))]
            (if (not (Var''isDynamic v))
                (do
                    (ObjExpr''emitConstant this, gen, i)
                    (.invokeVirtual gen, Compiler'VAR_TYPE, ObjExpr'varGetRawMethod)
                )
                (do
                    (ObjExpr''emitConstant this, gen, i)
                    (.invokeVirtual gen, Compiler'VAR_TYPE, ObjExpr'varGetMethod)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitKeyword [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"Keyword" k]
        (let [#_"Integer" i (cast Integer (ILookup'''valAt-2 (:keywords this), k))]
            (ObjExpr''emitConstant this, gen, i)
        )
        nil
    )

    #_method
    (defn #_"void" ObjExpr''emitConstant [#_"ObjExpr" this, #_"GeneratorAdapter" gen, #_"int" id]
        (§ ass this (assoc this :usedConstants (cast' IPersistentSet (IPersistentCollection'''cons (:usedConstants this), id))))
        (.getStatic gen, (:objtype this), (ObjExpr''constantName this, id), (ObjExpr''constantType this, id))
        nil
    )

    #_method
    (defn #_"String" ObjExpr''constantName [#_"ObjExpr" this, #_"int" id]
        (str ObjExpr'CONST_PREFIX id)
    )

    #_method
    (defn #_"String" ObjExpr''siteName [#_"ObjExpr" this, #_"int" n]
        (str "__site__" n)
    )

    #_method
    (defn #_"String" ObjExpr''siteNameStatic [#_"ObjExpr" this, #_"int" n]
        (str (ObjExpr''siteName this, n) "__")
    )

    #_method
    (defn #_"String" ObjExpr''thunkName [#_"ObjExpr" this, #_"int" n]
        (str "__thunk__" n)
    )

    #_method
    (defn #_"String" ObjExpr''cachedClassName [#_"ObjExpr" this, #_"int" n]
        (str "__cached_class__" n)
    )

    #_method
    (defn #_"String" ObjExpr''cachedVarName [#_"ObjExpr" this, #_"int" n]
        (str "__cached_var__" n)
    )

    #_method
    (defn #_"String" ObjExpr''varCallsiteName [#_"ObjExpr" this, #_"int" n]
        (str "__var__callsite__" n)
    )

    #_method
    (defn #_"String" ObjExpr''thunkNameStatic [#_"ObjExpr" this, #_"int" n]
        (str (ObjExpr''thunkName this, n) "__")
    )

    #_method
    (defn #_"Type" ObjExpr''constantType [#_"ObjExpr" this, #_"int" id]
        (let [#_"Object" o (Indexed'''nth-2 (:constants this), id) #_"Class" c (Util'classOf o)]
            (or
                (when (and (some? c) (Modifier/isPublic (.getModifiers c)))
                    ;; can't emit derived fn types due to visibility
                    (cond
                        (.isAssignableFrom (§ class LazySeq), c) (§ unsure Type/getType (§ class ISeq))
                        (= c (§ class Keyword))                  (§ unsure Type/getType (§ class Keyword))
                        (.isAssignableFrom (§ class RestFn), c)  (§ unsure Type/getType (§ class RestFn))
                        (.isAssignableFrom (§ class AFn), c)     (§ unsure Type/getType (§ class AFn))
                        (= c (§ class Var))                      (§ unsure Type/getType (§ class Var))
                        (= c String)                             (Type/getType String)
                    )
                )
                Compiler'OBJECT_TYPE
            )
        )
    )
)

(def PathType'enum-set
    (hash-set
        :PathType'PATH
        :PathType'BRANCH
    )
)

(class-ns PathNode
    (defn- #_"PathNode" PathNode'init []
        (hash-map
            #_"PathType" :type nil
            #_"PathNode" :parent nil
        )
    )

    (defn #_"PathNode" PathNode'new [#_"PathType" type, #_"PathNode" parent]
        (let [this (PathNode'init)]
            (§ ass this (assoc this :type type))
            (§ ass this (assoc this :parent parent))
            this
        )
    )
)

(class-ns FnMethod (§ extends ObjMethod)
    (defn- #_"FnMethod" FnMethod'init []
        (hash-map
            ;; localbinding->localbinding
            #_"PersistentVector" :reqParms PersistentVector'EMPTY
            #_"LocalBinding" :restParm nil
            #_"Type[]" :argtypes nil
            #_"Class[]" :argclasses nil
            #_"Class" :retClass nil
            #_"String" :prim nil
        )
    )

    (defn #_"FnMethod" FnMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (merge (ObjMethod'new objx, parent) (FnMethod'init))
    )

    (defn #_"char" FnMethod'classChar [#_"Object" x]
        (let [#_"Class" c
                (cond
                    (instance? Class x)    (cast Class x)
                    (§ instance? Symbol x) (Compiler'primClass-1s (cast' Symbol x))
                )]
            (cond
                (or (nil? c) (not (.isPrimitive c))) \O
                (= c Long/TYPE)                      \L
                (= c Double/TYPE)                    \D
                :else
                    (throw (IllegalArgumentException. "Only long and double primitives are supported"))
            )
        )
    )

    (defn #_"String" FnMethod'primInterface [#_"IPersistentVector" args]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (dotimes [#_"int" i (.count args)]
                (.append sb, (FnMethod'classChar (Compiler'tagOf (Indexed'''nth-2 args, i))))
            )
            (.append sb, (FnMethod'classChar (Compiler'tagOf args)))
            (let [#_"String" s (.toString sb) #_"boolean" prim? (or (.contains s, "L") (.contains s, "D"))]
                (cond
                    (and prim? (< 4 (.count args))) (throw (IllegalArgumentException. "fns taking primitives support only 4 or fewer args"))
                    prim?                           (str "cloiure.lang.IFn$" s)
                )
            )
        )
    )

    (defn #_"FnMethod" FnMethod'parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Object" rettag]
        ;; ([args] body...)
        (let [#_"IPersistentVector" parms (cast' IPersistentVector (RT'first form))
              #_"ISeq" body (RT'next form)]
            (try
                (let [#_"FnMethod" method
                        (assoc (FnMethod'new objx, (cast' ObjMethod (IDeref'''deref Compiler'METHOD))) :line (Compiler'lineDeref) :column (Compiler'columnDeref))
                      ;; register as the current method and set up a new env frame
                      #_"PathNode" pnode (or (cast' PathNode (Var''get Compiler'CLEAR_PATH)) (PathNode'new :PathType'PATH, nil))]
                    (Var'pushThreadBindings (RT'mapUniqueKeys
                        (object-array [
                            Compiler'METHOD                method
                            Compiler'LOCAL_ENV             (IDeref'''deref Compiler'LOCAL_ENV)
                            Compiler'LOOP_LOCALS           nil
                            Compiler'NEXT_LOCAL_NUM        0
                            Compiler'CLEAR_PATH            pnode
                            Compiler'CLEAR_ROOT            pnode
                            Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                            Compiler'METHOD_RETURN_CONTEXT RT'T
                        ])
                    ))
                    (§ ass (:prim method) (FnMethod'primInterface parms))
                    (when (some? (:prim method))
                        (§ ass (:prim method) (.replace (:prim method), \., \/))
                    )
                    (let [rettag (if (instance? String rettag) (Symbol'intern nil, (cast String rettag)) rettag)
                          rettag (when (and (§ instance? Symbol rettag) (any = (Named'''getName (cast' Symbol rettag)) "long" "double")) rettag)]
                        (§ ass (:retClass method) (Compiler'tagClass (or (Compiler'tagOf parms) rettag)))
                        (if (.isPrimitive (:retClass method))
                            (when-not (any = (:retClass method) Double/TYPE Long/TYPE)
                                (throw (IllegalArgumentException. "Only long and double primitives are supported"))
                            )
                            (§ ass (:retClass method) Object)
                        )
                        ;; register 'this' as local 0
                        (if (some? (:thisName objx))
                            (Compiler'registerLocal (Symbol'intern (:thisName objx)), nil, nil, false)
                            (Compiler'getAndIncLocalNum)
                        )
                        (let [#_"ArrayList<Type>" argtypes (ArrayList.) #_"ArrayList<Class>" argclasses (ArrayList.)
                              #_"PersistentVector" argLocals
                                (loop-when [#_"boolean" rest? false argLocals PersistentVector'EMPTY #_"int" i 0] (< i (.count parms)) => argLocals
                                    (when (§ instance? Symbol (Indexed'''nth-2 parms, i)) => (throw (IllegalArgumentException. "fn params must be Symbols"))
                                        (let [#_"Symbol" p (cast' Symbol (Indexed'''nth-2 parms, i))]
                                            (cond
                                                (some? (Named'''getNamespace p))
                                                    (throw (RuntimeException. (str "Can't use qualified name as parameter: " p)))
                                                (.equals p, Compiler'_AMP_)
                                                    (when-not rest? => (throw (RuntimeException. "Invalid parameter list"))
                                                        (recur true argLocals (inc i))
                                                    )
                                                :else
                                                    (let [#_"Class" pc (Compiler'primClass-1c (Compiler'tagClass (Compiler'tagOf p)))]
                                                        (when (and (.isPrimitive pc) (not (any = pc Double/TYPE Long/TYPE)))
                                                            (throw (IllegalArgumentException. (str "Only long and double primitives are supported: " p)))
                                                        )
                                                        (when (and rest? (some? (Compiler'tagOf p)))
                                                            (throw (RuntimeException. "& arg cannot have type hint"))
                                                        )
                                                        (when (and rest? (some? (:prim method)))
                                                            (throw (RuntimeException. "fns taking primitives cannot be variadic"))
                                                        )
                                                        (let [pc (if rest? (§ class ISeq) pc)]
                                                            (.add argtypes, (Type/getType pc))
                                                            (.add argclasses, pc)
                                                            (let [#_"LocalBinding" lb
                                                                    (if (.isPrimitive pc)
                                                                        (Compiler'registerLocal p, nil, (MethodParamExpr'new pc), true)
                                                                        (Compiler'registerLocal p, (if rest? Compiler'ISEQ (Compiler'tagOf p)), nil, true)
                                                                    )]
                                                                (if-not rest?
                                                                    (§ ass (:reqParms method) (IPersistentVector'''cons (:reqParms method), lb))
                                                                    (§ ass (:restParm method) lb)
                                                                )
                                                                (IPersistentVector'''cons argLocals, lb)
                                                            )
                                                        )
                                                    )
                                            )
                                        )
                                    )
                                )]
                            (when (< Compiler'MAX_POSITIONAL_ARITY (.count (:reqParms method)))
                                (throw (RuntimeException. (str "Can't specify more than " Compiler'MAX_POSITIONAL_ARITY " params")))
                            )
                            (Var''set Compiler'LOOP_LOCALS, argLocals)
                            (§ ass (:argLocals method) argLocals)
                            (§ ass (:argtypes method) (.toArray argtypes, (make-array Type (.size argtypes))))
                            (§ ass (:argclasses method) (.toArray argclasses, (make-array Class (.size argtypes))))
                            (when (some? (:prim method))
                                (dotimes [#_"int" i (alength (:argclasses method))]
                                    (when (any = (aget (:argclasses method) i) Long/TYPE Double/TYPE)
                                        (Compiler'getAndIncLocalNum)
                                    )
                                )
                            )
                            (§ ass (:body method) (IParser'''parse (BodyParser'new), :Context'RETURN, body))
                            method
                        )
                    )
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    #_override
    (defn #_"void" Expr'''emit--FnMethod [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (cond
            (:canBeDirect fn)    (FnMethod''doEmitStatic this, fn, cv)
            (some? (:prim this)) (FnMethod''doEmitPrim this, fn, cv)
            :else                (FnMethod''doEmit this, fn, cv)
        )
        nil
    )

    #_method
    (defn #_"void" FnMethod''doEmitStatic [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Type" returnType (Type/getType (:retClass this))
              #_"Method" ms (Method. "invokeStatic", returnType, (:argtypes this))
              ;; todo don't hardwire EXCEPTION_TYPES
              #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ms, nil, Compiler'EXCEPTION_TYPES, cv)]
            (.visitCode gen)
            (let [#_"Label" loopLabel (.mark gen)]
                (.visitLineNumber gen, (:line this), loopLabel)
                (try
                    (Var'pushThreadBindings (RT'map
                        (object-array [
                            Compiler'LOOP_LABEL loopLabel
                            Compiler'METHOD     this
                        ])
                    ))
                    (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))
                    (let [#_"Label" end (.mark gen)]
                        (loop-when-recur [#_"ISeq" lbs (Seqable'''seq (:argLocals this))] (some? lbs) [(.next lbs)]
                            (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argtypes this) (:idx lb))), nil, loopLabel, end, (:idx lb))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
                (.returnValue gen)
                (.endMethod gen)
                ;; generate the regular invoke, calling the static method
                (let [#_"Method" m (Method. (ObjMethod'''getMethodName this), Compiler'OBJECT_TYPE, (ObjMethod'''getArgTypes this))
                      ;; todo don't hardwire EXCEPTION_TYPES
                      gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                    (.visitCode gen)
                    (dotimes [#_"int" i (alength (:argtypes this))]
                        (.loadArg gen, i)
                        (HostExpr'emitUnboxArg fn, gen, (aget (:argclasses this) i))
                        (when-not (.isPrimitive (aget (:argclasses this) i))
                            (.visitInsn gen, Opcodes/ACONST_NULL)
                            (.storeArg gen, i)
                        )
                    )
                    (let [#_"Label" callLabel (.mark gen)]
                        (.visitLineNumber gen, (:line this), callLabel)
                        (.invokeStatic gen, (:objtype (:objx this)), ms)
                        (.box gen, returnType)
                        (.returnValue gen)
                        (.endMethod gen)
                        ;; generate primInvoke if prim
                        (when (some? (:prim this))
                            (let [returnType (if (any = (:retClass this) Double/TYPE Long/TYPE) (ObjMethod'''getReturnType this) Compiler'OBJECT_TYPE)
                                  #_"Method" pm (Method. "invokePrim", returnType, (:argtypes this))
                                  ;; todo don't hardwire EXCEPTION_TYPES
                                  gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), pm, nil, Compiler'EXCEPTION_TYPES, cv)]
                                (.visitCode gen)
                                (dotimes [#_"int" i (alength (:argtypes this))]
                                    (.loadArg gen, i)
                                    (when-not (.isPrimitive (aget (:argclasses this) i))
                                        (.visitInsn gen, Opcodes/ACONST_NULL)
                                        (.storeArg gen, i)
                                    )
                                )
                                (.invokeStatic gen, (:objtype (:objx this)), ms)
                                (.returnValue gen)
                                (.endMethod gen)
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" FnMethod''doEmitPrim [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Type" returnType (if (any = (:retClass this) Double/TYPE Long/TYPE) (ObjMethod'''getReturnType this) Compiler'OBJECT_TYPE)
              #_"Method" ms (Method. "invokePrim", returnType, (:argtypes this))
              ;; todo don't hardwire EXCEPTION_TYPES
              #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ms, nil, Compiler'EXCEPTION_TYPES, cv)]
            (.visitCode gen)

            (let [#_"Label" loopLabel (.mark gen)]
                (.visitLineNumber gen, (:line this), loopLabel)
                (try
                    (Var'pushThreadBindings (RT'map
                        (object-array [
                            Compiler'LOOP_LABEL loopLabel
                            Compiler'METHOD     this
                        ])
                    ))
                    (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))

                    (let [#_"Label" end (.mark gen)]
                        (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                        (loop-when-recur [#_"ISeq" lbs (Seqable'''seq (:argLocals this))] (some? lbs) [(.next lbs)]
                            (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argtypes this) (dec (:idx lb)))), nil, loopLabel, end, (:idx lb))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )

                (.returnValue gen)
                (.endMethod gen)

                ;; generate the regular invoke, calling the prim method
                (let [#_"Method" m (Method. (ObjMethod'''getMethodName this), Compiler'OBJECT_TYPE, (ObjMethod'''getArgTypes this))]
                    ;; todo don't hardwire EXCEPTION_TYPES
                    (§ ass gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv))
                    (.visitCode gen)
                    (.loadThis gen)
                    (dotimes [#_"int" i (alength (:argtypes this))]
                        (.loadArg gen, i)
                        (HostExpr'emitUnboxArg fn, gen, (aget (:argclasses this) i))
                    )
                    (.invokeInterface gen, (Type/getType (str "L" (:prim this) ";")), ms)
                    (.box gen, (ObjMethod'''getReturnType this))

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"void" FnMethod''doEmit [#_"FnMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (ObjMethod'''getMethodName this), (ObjMethod'''getReturnType this), (ObjMethod'''getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                (.visitCode gen)

                (let [#_"Label" loopLabel (.mark gen)]
                    (.visitLineNumber gen, (:line this), loopLabel)
                    (try
                        (Var'pushThreadBindings (RT'map
                            (object-array [
                                Compiler'LOOP_LABEL loopLabel
                                Compiler'METHOD     this
                            ])
                        ))

                        (Expr'''emit (:body this), :Context'RETURN, fn, gen)
                        (let [#_"Label" end (.mark gen)]
                            (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                            (loop-when-recur [#_"ISeq" lbs (Seqable'''seq (:argLocals this))] (some? lbs) [(.next lbs)]
                                (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                    (.visitLocalVariable gen, (:name lb), "Ljava/lang/Object;", nil, loopLabel, end, (:idx lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"boolean" FnMethod''isVariadic [#_"FnMethod" this]
        (some? (:restParm this))
    )

    #_override
    (defn #_"int" ObjMethod'''numParams--FnMethod [#_"FnMethod" this]
        (+ (.count (:reqParms this)) (if (FnMethod''isVariadic this) 1 0))
    )

    #_override
    (defn #_"String" ObjMethod'''getMethodName--FnMethod [#_"FnMethod" this]
        (if (FnMethod''isVariadic this) "doInvoke" "invoke")
    )

    #_override
    (defn #_"Type" ObjMethod'''getReturnType--FnMethod [#_"FnMethod" this]
        (if (some? (:prim this))
            (Type/getType (:retClass this))
            Compiler'OBJECT_TYPE
        )
    )

    #_override
    (defn #_"Type[]" ObjMethod'''getArgTypes--FnMethod [#_"FnMethod" this]
        (if (and (FnMethod''isVariadic this) (= (.count (:reqParms this)) Compiler'MAX_POSITIONAL_ARITY))
            (let [#_"int" n (inc Compiler'MAX_POSITIONAL_ARITY) #_"Type[]" a (make-array Type n)]
                (dotimes [#_"int" i n]
                    (aset a i Compiler'OBJECT_TYPE)
                )
                a
            )
            (aget Compiler'ARG_TYPES (ObjMethod'''numParams this))
        )
    )
)

#_abstract
(class-ns ObjMethod
    (defn- #_"ObjMethod" ObjMethod'init []
        (hash-map
            ;; when closures are defined inside other closures,
            ;; the closed over locals need to be propagated to the enclosing objx
            #_"ObjMethod" :parent nil
            ;; localbinding->localbinding
            #_"IPersistentMap" :locals nil
            ;; num->localbinding
            #_"IPersistentMap" :indexlocals nil
            #_"Expr" :body nil
            #_"ObjExpr" :objx nil
            #_"PersistentVector" :argLocals nil
            #_"int" :maxLocal 0
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :usesThis false
            #_"PersistentHashSet" :localsUsedInCatchFinally PersistentHashSet'EMPTY
            #_protected
            #_"IPersistentMap" :methodMeta nil
        )
    )

    (defn #_"ObjMethod" ObjMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (let [this (ObjMethod'init)]
            (§ ass this (assoc this :parent parent))
            (§ ass this (assoc this :objx objx))
            this
        )
    )

    (defn #_"void" ObjMethod'emitBody [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Class" retClass, #_"Expr" body]
        (let [#_"MaybePrimitiveExpr" be (cast' MaybePrimitiveExpr body)]
            (if (and (Util'isPrimitive retClass) (MaybePrimitiveExpr'''canEmitPrimitive be))
                (let [#_"Class" bc (Compiler'maybePrimitiveType be)]
                    (cond (= bc retClass)
                        (do
                            (MaybePrimitiveExpr'''emitUnboxed be, :Context'RETURN, objx, gen)
                        )
                        (and (= retClass Long/TYPE) (= bc Integer/TYPE))
                        (do
                            (MaybePrimitiveExpr'''emitUnboxed be, :Context'RETURN, objx, gen)
                            (.visitInsn gen, Opcodes/I2L)
                        )
                        (and (= retClass Double/TYPE) (= bc Float/TYPE))
                        (do
                            (MaybePrimitiveExpr'''emitUnboxed be, :Context'RETURN, objx, gen)
                            (.visitInsn gen, Opcodes/F2D)
                        )
                        (and (= retClass Integer/TYPE) (= bc Long/TYPE))
                        (do
                            (MaybePrimitiveExpr'''emitUnboxed be, :Context'RETURN, objx, gen)
                            (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                        )
                        (and (= retClass Float/TYPE) (= bc Double/TYPE))
                        (do
                            (MaybePrimitiveExpr'''emitUnboxed be, :Context'RETURN, objx, gen)
                            (.visitInsn gen, Opcodes/D2F)
                        )
                        :else
                        (do
                            (throw (IllegalArgumentException. (str "Mismatched primitive return, expected: " retClass ", had: " (Expr'''getJavaClass be))))
                        )
                    )
                )
                (do
                    (Expr'''emit body, :Context'RETURN, objx, gen)
                    (if (= retClass Void/TYPE)
                        (.pop gen)
                        (.unbox gen, (Type/getType retClass))
                    )
                )
            )
        )
        nil
    )

    #_abstract
    (defn #_"int" ObjMethod'''numParams [#_"ObjMethod" this])
    #_abstract
    (defn #_"String" ObjMethod'''getMethodName [#_"ObjMethod" this])
    #_abstract
    (defn #_"Type" ObjMethod'''getReturnType [#_"ObjMethod" this])
    #_abstract
    (defn #_"Type[]" ObjMethod'''getArgTypes [#_"ObjMethod" this])

    #_override
    (defn #_"void" Expr'''emit--ObjMethod [#_"ObjMethod" this, #_"ObjExpr" fn, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (ObjMethod'''getMethodName this), (ObjMethod'''getReturnType this), (ObjMethod'''getArgTypes this))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, Compiler'EXCEPTION_TYPES, cv)]
                (.visitCode gen)

                (let [#_"Label" loopLabel (.mark gen)]
                    (.visitLineNumber gen, (:line this), loopLabel)
                    (try
                        (Var'pushThreadBindings (RT'map
                            (object-array [
                                Compiler'LOOP_LABEL loopLabel
                                Compiler'METHOD     this
                            ])
                        ))

                        (Expr'''emit (:body this), :Context'RETURN, fn, gen)
                        (let [#_"Label" end (.mark gen)]
                            (.visitLocalVariable gen, "this", "Ljava/lang/Object;", nil, loopLabel, end, 0)
                            (loop-when-recur [#_"ISeq" lbs (Seqable'''seq (:argLocals this))] (some? lbs) [(.next lbs)]
                                (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                    (.visitLocalVariable gen, (:name lb), "Ljava/lang/Object;", nil, loopLabel, end, (:idx lb))
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )

                    (.returnValue gen)
                    (.endMethod gen)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjMethod''emitClearLocals [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        nil
    )

    #_method
    (defn #_"void" ObjMethod''emitClearLocalsOld [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        (dotimes [#_"int" i (.count (:argLocals this))]
            (let [#_"LocalBinding" lb (cast' LocalBinding (Indexed'''nth-2 (:argLocals this), i))]
                (when (and (not (IPersistentSet'''contains (:localsUsedInCatchFinally this), (:idx lb))) (nil? (LocalBinding''getPrimitiveType lb)))
                    (.visitInsn gen, Opcodes/ACONST_NULL)
                    (.storeArg gen, (dec (:idx lb)))
                )
            )
        )
        (loop-when-recur [#_"int" i (inc (ObjMethod'''numParams this))] (< i (inc (:maxLocal this))) [(inc i)]
            (when (not (IPersistentSet'''contains (:localsUsedInCatchFinally this), i))
                (let [#_"LocalBinding" b (cast' LocalBinding (RT'get-2 (:indexlocals this), i))]
                    (when (or (nil? b) (nil? (Compiler'maybePrimitiveType (:init b))))
                        (.visitInsn gen, Opcodes/ACONST_NULL)
                        (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), i)
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" ObjMethod''emitClearThis [#_"ObjMethod" this, #_"GeneratorAdapter" gen]
        (.visitInsn gen, Opcodes/ACONST_NULL)
        (.visitVarInsn gen, Opcodes/ASTORE, 0)
        nil
    )
)

(class-ns LocalBinding
    (defn- #_"LocalBinding" LocalBinding'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"Symbol" :tag nil
            #_"Expr" :init nil
            #_"int" :idx 0
            #_"String" :name nil
            #_"boolean" :isArg false
            #_"PathNode" :clearPathRoot nil
            #_"boolean" :canBeCleared true
            #_"boolean" :recurMistmatch false
            #_"boolean" :used false

            #_"Boolean" :hjc nil

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBinding" LocalBinding'new [#_"int" num, #_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg, #_"PathNode" clearPathRoot]
        (let [this (LocalBinding'init)]
            (when (and (some? (Compiler'maybePrimitiveType init)) (some? tag))
                (throw (UnsupportedOperationException. "Can't type hint a local with a primitive initializer"))
            )
            (§ ass this (assoc this :idx num))
            (§ ass this (assoc this :sym sym))
            (§ ass this (assoc this :tag tag))
            (§ ass this (assoc this :init init))
            (§ ass this (assoc this :isArg isArg))
            (§ ass this (assoc this :clearPathRoot clearPathRoot))
            (§ ass this (assoc this :name (Compiler'munge (:name sym))))
            this
        )
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--LocalBinding [#_"LocalBinding" this]
        (when (nil? (:hjc this))
            (if (and (some? (:init this)) (Expr'''hasJavaClass (:init this)) (Util'isPrimitive (Expr'''getJavaClass (:init this))) (not (§ instance? MaybePrimitiveExpr (:init this))))
                (§ ass this (assoc this :hjc false))
                (§ ass this (assoc this :hjc (or (some? (:tag this)) (and (some? (:init this)) (Expr'''hasJavaClass (:init this))))))
            )
        )
        (:hjc this)
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--LocalBinding [#_"LocalBinding" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (Expr'''getJavaClass (:init this)))))
        )
        (:jc this)
    )

    #_method
    (defn #_"Class" LocalBinding''getPrimitiveType [#_"LocalBinding" this]
        (Compiler'maybePrimitiveType (:init this))
    )
)

(class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
    (defn- #_"LocalBindingExpr" LocalBindingExpr'init []
        (hash-map
            #_"LocalBinding" :lb nil
            #_"Symbol" :tag nil

            #_"PathNode" :clearPath nil
            #_"PathNode" :clearRoot nil
            #_"boolean" :shouldClear false

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBindingExpr" LocalBindingExpr'new [#_"LocalBinding" lb, #_"Symbol" tag]
        (let [this (LocalBindingExpr'init)]
            (when (and (some? (LocalBinding''getPrimitiveType lb)) (some? tag))
                (throw (UnsupportedOperationException. "Can't type hint a primitive local"))
            )
            (§ ass this (assoc this :lb lb))
            (§ ass this (assoc this :tag tag))

            (§ ass this (assoc this :clearPath (cast' PathNode (Var''get Compiler'CLEAR_PATH))))
            (§ ass this (assoc this :clearRoot (cast' PathNode (Var''get Compiler'CLEAR_ROOT))))
            (let [#_"IPersistentCollection" sites (cast' IPersistentCollection (RT'get-2 (Var''get Compiler'CLEAR_SITES), lb))]
                (§ ass (:used lb) true)

                (when (pos? (:idx lb))
                    (when (some? sites)
                        (loop-when-recur [#_"ISeq" s (Seqable'''seq sites)] (some? s) [(.next s)]
                            (let [#_"LocalBindingExpr" o (cast' LocalBindingExpr (.first s))
                                  #_"PathNode" common (Compiler'commonPath (:clearPath this), (:clearPath o))]
                                (when (and (some? common) (= (:type common) :PathType'PATH))
                                    (§ ass (:shouldClear o) false)
                                )
                            )
                        )
                    )

                    (when (= (:clearRoot this) (:clearPathRoot lb))
                        (§ ass this (assoc this :shouldClear true))
                        (§ ass sites (RT'conj sites, this))
                        (Var''set Compiler'CLEAR_SITES, (RT'assoc (Var''get Compiler'CLEAR_SITES), lb, sites))
                    )
                )
                this
            )
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--LocalBindingExpr [#_"LocalBindingExpr" this]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--LocalBindingExpr [#_"LocalBindingExpr" this]
        (some? (LocalBinding''getPrimitiveType (:lb this)))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--LocalBindingExpr [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (ObjExpr''emitUnboxedLocal objx, gen, (:lb this))
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--LocalBindingExpr [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (when (not= context :Context'STATEMENT)
            (ObjExpr''emitLocal objx, gen, (:lb this), (:shouldClear this))
        )
        nil
    )

    #_override
    (defn #_"Object" AssignableExpr'''evalAssign--LocalBindingExpr [#_"LocalBindingExpr" this, #_"Expr" val]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_override
    (defn #_"void" AssignableExpr'''emitAssign--LocalBindingExpr [#_"LocalBindingExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" val]
        (ObjExpr''emitAssignLocal objx, gen, (:lb this), val)
        (when (not= context :Context'STATEMENT)
            (ObjExpr''emitLocal objx, gen, (:lb this), false)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--LocalBindingExpr [#_"LocalBindingExpr" this]
        (or (some? (:tag this)) (Expr'''hasJavaClass (:lb this)))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--LocalBindingExpr [#_"LocalBindingExpr" this]
        (when (nil? (:jc this))
            (§ ass this (assoc this :jc (if (some? (:tag this)) (HostExpr'tagToClass (:tag this)) (Expr'''getJavaClass (:lb this)))))
        )
        (:jc this)
    )
)

#_closure
(class-ns BodyParser (§ implements IParser)
    (defn #_"BodyParser" BodyParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--BodyParser [#_"BodyParser" this, #_"Context" context, #_"Object" frms]
        (let [#_"ISeq" forms (cast' ISeq frms)]
            (when (Util'equals (RT'first forms), Compiler'DO)
                (§ ass forms (RT'next forms))
            )
            (let [#_"PersistentVector" v PersistentVector'EMPTY]
                (loop-when-recur [forms forms] (some? forms) [(.next forms)]
                    (let [#_"Expr" e (if (and (not= context :Context'EVAL) (or (= context :Context'STATEMENT) (some? (.next forms)))) (Compiler'analyze-2 :Context'STATEMENT, (.first forms)) (Compiler'analyze-2 context, (.first forms)))]
                        (§ ass v (IPersistentVector'''cons v, e))
                    )
                )
                (when (zero? (.count v))
                    (§ ass v (IPersistentVector'''cons v, Compiler'NIL_EXPR))
                )
                (BodyExpr'new v)
            )
        )
    )
)

(class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"BodyExpr" BodyExpr'init []
        (hash-map
            #_"PersistentVector" :exprs nil
        )
    )

    (defn #_"BodyExpr" BodyExpr'new [#_"PersistentVector" exprs]
        (let [this (BodyExpr'init)]
            (§ ass this (assoc this :exprs exprs))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--BodyExpr [#_"BodyExpr" this]
        (let [#_"Iterator" it (.iterator (:exprs this))]
            (loop-when-recur [#_"Object" ret nil] (.hasNext it) [(Expr'''eval (cast' Expr (.next it)))] => ret)
        )
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--BodyExpr [#_"BodyExpr" this]
        (and (§ instance? MaybePrimitiveExpr (BodyExpr''lastExpr this)) (MaybePrimitiveExpr'''canEmitPrimitive (cast' MaybePrimitiveExpr (BodyExpr''lastExpr this))))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--BodyExpr [#_"BodyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (dotimes [#_"int" i (dec (.count (:exprs this)))]
            (let [#_"Expr" e (cast' Expr (Indexed'''nth-2 (:exprs this), i))]
                (Expr'''emit e, :Context'STATEMENT, objx, gen)
            )
        )
        (let [#_"MaybePrimitiveExpr" last (cast' MaybePrimitiveExpr (Indexed'''nth-2 (:exprs this), (dec (.count (:exprs this)))))]
            (MaybePrimitiveExpr'''emitUnboxed last, context, objx, gen)
        )
        nil
    )

    #_override
    (defn #_"void" Expr'''emit--BodyExpr [#_"BodyExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (dotimes [#_"int" i (dec (.count (:exprs this)))]
            (let [#_"Expr" e (cast' Expr (Indexed'''nth-2 (:exprs this), i))]
                (Expr'''emit e, :Context'STATEMENT, objx, gen)
            )
        )
        (let [#_"Expr" last (cast' Expr (Indexed'''nth-2 (:exprs this), (dec (.count (:exprs this)))))]
            (Expr'''emit last, context, objx, gen)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--BodyExpr [#_"BodyExpr" this]
        (Expr'''hasJavaClass (BodyExpr''lastExpr this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--BodyExpr [#_"BodyExpr" this]
        (Expr'''getJavaClass (BodyExpr''lastExpr this))
    )

    #_method
    (defn- #_"Expr" BodyExpr''lastExpr [#_"BodyExpr" this]
        (cast' Expr (Indexed'''nth-2 (:exprs this), (dec (.count (:exprs this)))))
    )
)

(class-ns BindingInit
    (defn- #_"BindingInit" BindingInit'init []
        (hash-map
            #_"LocalBinding" :binding nil
            #_"Expr" :init nil
        )
    )

    (defn #_"BindingInit" BindingInit'new [#_"LocalBinding" binding, #_"Expr" init]
        (let [this (BindingInit'init)]
            (§ ass this (assoc this :binding binding))
            (§ ass this (assoc this :init init))
            this
        )
    )
)

#_closure
(class-ns LetFnParser (§ implements IParser)
    (defn #_"LetFnParser" LetFnParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--LetFnParser [#_"LetFnParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            ;; (letfns* [var (fn [args] body) ...] body...)
            (when (§ instance? IPersistentVector (RT'second form)) => (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                (let [#_"IPersistentVector" bindings (cast' IPersistentVector (RT'second form))]
                    (when (zero? (% (.count bindings) 2)) => (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                        (if (= context :Context'EVAL)
                            (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                            (try
                                (Var'pushThreadBindings (RT'map
                                    (object-array [
                                        Compiler'LOCAL_ENV      (IDeref'''deref Compiler'LOCAL_ENV)
                                        Compiler'NEXT_LOCAL_NUM (IDeref'''deref Compiler'NEXT_LOCAL_NUM)
                                    ])
                                ))
                                ;; pre-seed env (like Lisp labels)
                                (let [#_"PersistentVector" lbs PersistentVector'EMPTY
                                      _ (loop-when-recur [#_"int" i 0] (< i (.count bindings)) [(+ i 2)]
                                            (when (not (§ instance? Symbol (Indexed'''nth-2 bindings, i)))
                                                (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (Indexed'''nth-2 bindings, i))))
                                            )
                                            (let [#_"Symbol" sym (cast' Symbol (Indexed'''nth-2 bindings, i))]
                                                (when (some? (Named'''getNamespace sym))
                                                    (throw (RuntimeException. (str "Can't let qualified name: " sym)))
                                                )
                                                (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (Compiler'tagOf sym), nil, false)]
                                                    (§ ass (:canBeCleared lb) false)
                                                    (§ ass lbs (IPersistentVector'''cons lbs, lb))
                                                )
                                            )
                                        )
                                      #_"PersistentVector" bindingInits PersistentVector'EMPTY
                                      _ (loop-when-recur [#_"int" i 0] (< i (.count bindings)) [(+ i 2)]
                                            (let [#_"Symbol" sym (cast' Symbol (Indexed'''nth-2 bindings, i))
                                                  #_"Expr" init (Compiler'analyze-3 :Context'EXPRESSION, (Indexed'''nth-2 bindings, (inc i)), (:name sym))
                                                  #_"LocalBinding" lb (cast' LocalBinding (Indexed'''nth-2 lbs, (/ i 2)))]
                                                (§ ass (:init lb) init)
                                                (§ ass bindingInits (IPersistentVector'''cons bindingInits, (BindingInit'new lb, init)))
                                            )
                                        )]
                                    (LetFnExpr'new bindingInits, (IParser'''parse (BodyParser'new), context, (RT'next (RT'next form))))
                                )
                                (finally
                                    (Var'popThreadBindings)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetFnExpr (§ implements Expr)
    (defn- #_"LetFnExpr" LetFnExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
        )
    )

    (defn #_"LetFnExpr" LetFnExpr'new [#_"PersistentVector" bindingInits, #_"Expr" body]
        (let [this (LetFnExpr'init)]
            (§ ass this (assoc this :bindingInits bindingInits))
            (§ ass this (assoc this :body body))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--LetFnExpr [#_"LetFnExpr" this]
        (throw (UnsupportedOperationException. "Can't eval letfns"))
    )

    #_override
    (defn #_"void" Expr'''emit--LetFnExpr [#_"LetFnExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (dotimes [#_"int" i (.count (:bindingInits this))]
            (let [#_"BindingInit" bi (cast' BindingInit (Indexed'''nth-2 (:bindingInits this), i))]
                (.visitInsn gen, Opcodes/ACONST_NULL)
                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
            )
        )

        (let [#_"IPersistentSet" lbset PersistentHashSet'EMPTY]
            (loop-when-recur [#_"int" i 0] (< i (.count (:bindingInits this))) [(inc i)]
                (let [#_"BindingInit" bi (cast' BindingInit (Indexed'''nth-2 (:bindingInits this), i))]
                    (§ ass lbset (cast' IPersistentSet (IPersistentCollection'''cons lbset, (:binding bi))))
                    (Expr'''emit (:init bi), :Context'EXPRESSION, objx, gen)
                    (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
                )
            )

            (dotimes [#_"int" i (.count (:bindingInits this))]
                (let [#_"BindingInit" bi (cast' BindingInit (Indexed'''nth-2 (:bindingInits this), i))]
                    (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ILOAD), (:idx (:binding bi)))
                    (ObjExpr''emitLetFnInits (cast' ObjExpr (:init bi)), gen, objx, lbset)
                )
            )

            (let [#_"Label" loopLabel (.mark gen)]
                (Expr'''emit (:body this), context, objx, gen)

                (let [#_"Label" end (.mark gen)]
                    (loop-when-recur [#_"ISeq" bis (Seqable'''seq (:bindingInits this))] (some? bis) [(.next bis)]
                        (let [#_"BindingInit" bi (cast' BindingInit (.first bis))
                              #_"String" lname (:name (:binding bi))]
                            (when (.endsWith lname, "__auto__")
                                (§ ass lname (+ lname (RT'nextID)))
                            )
                            (let [#_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                                (.visitLocalVariable gen, lname, (if (some? primc) (Type/getDescriptor primc) "Ljava/lang/Object;"), nil, loopLabel, end, (:idx (:binding bi)))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--LetFnExpr [#_"LetFnExpr" this]
        (Expr'''hasJavaClass (:body this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--LetFnExpr [#_"LetFnExpr" this]
        (Expr'''getJavaClass (:body this))
    )
)

#_closure
(class-ns LetParser (§ implements IParser)
    (defn #_"LetParser" LetParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--LetParser [#_"LetParser" this, #_"Context" context, #_"Object" frm]
        ;; (let [var val var2 val2 ...] body...)
        (let [#_"ISeq" form (cast' ISeq frm) #_"boolean" isLoop (.equals (RT'first form), Compiler'LOOP)]
            (when (§ instance? IPersistentVector (RT'second form)) => (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                (let [#_"IPersistentVector" bindings (cast' IPersistentVector (RT'second form))]
                    (when (zero? (% (.count bindings) 2)) => (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                        (if (or (= context :Context'EVAL) (and (= context :Context'EXPRESSION) isLoop))
                            (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                            (let [#_"ISeq" body (RT'next (RT'next form))
                                  #_"ObjMethod" method (cast' ObjMethod (IDeref'''deref Compiler'METHOD))
                                  #_"IPersistentMap" backupMethodLocals (:locals method)
                                  #_"IPersistentMap" backupMethodIndexLocals (:indexlocals method)
                                  #_"IPersistentVector" recurMismatches PersistentVector'EMPTY
                                  _ (loop-when-recur [#_"int" i 0] (< i (/ (.count bindings) 2)) [(inc i)]
                                        (§ ass recurMismatches (IPersistentVector'''cons recurMismatches, RT'F))
                                    )]
                                ;; may repeat once for each binding with a mismatch, return breaks
                                (while true
                                    (let [#_"IPersistentMap" dynamicBindings
                                            (RT'map
                                                (object-array [
                                                    Compiler'LOCAL_ENV      (IDeref'''deref Compiler'LOCAL_ENV)
                                                    Compiler'NEXT_LOCAL_NUM (IDeref'''deref Compiler'NEXT_LOCAL_NUM)
                                                ])
                                            )
                                          _ (§ ass (:locals method) backupMethodLocals)
                                          _ (§ ass (:indexlocals method) backupMethodIndexLocals)
                                          #_"PathNode" looproot (PathNode'new :PathType'PATH, (cast' PathNode (Var''get Compiler'CLEAR_PATH)))
                                          #_"PathNode" clearroot (PathNode'new :PathType'PATH, looproot)
                                          #_"PathNode" clearpath (PathNode'new :PathType'PATH, looproot)]
                                        (when isLoop
                                            (§ ass dynamicBindings (IPersistentMap'''assoc dynamicBindings, Compiler'LOOP_LOCALS, nil))
                                        )
                                        (try
                                            (Var'pushThreadBindings dynamicBindings)
                                            (let [#_"PersistentVector" bindingInits PersistentVector'EMPTY
                                                  #_"PersistentVector" loopLocals PersistentVector'EMPTY
                                                  _ (loop-when-recur [#_"int" i 0] (< i (.count bindings)) [(+ i 2)]
                                                        (when (not (§ instance? Symbol (Indexed'''nth-2 bindings, i)))
                                                            (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (Indexed'''nth-2 bindings, i))))
                                                        )
                                                        (let [#_"Symbol" sym (cast' Symbol (Indexed'''nth-2 bindings, i))]
                                                            (when (some? (Named'''getNamespace sym))
                                                                (throw (RuntimeException. (str "Can't let qualified name: " sym)))
                                                            )
                                                            (let [#_"Expr" init (Compiler'analyze-3 :Context'EXPRESSION, (Indexed'''nth-2 bindings, (inc i)), (:name sym))]
                                                                (when isLoop
                                                                    (cond
                                                                        (and (some? recurMismatches) (RT'booleanCast-1o (Indexed'''nth-2 recurMismatches, (/ i 2))))
                                                                        (do
                                                                            (§ ass init (StaticMethodExpr'new 0, 0, nil, (§ class RT), "box", (RT'vector init), false))
                                                                            (when (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION))
                                                                                (.println (RT'errPrintWriter), (str "Auto-boxing loop arg: " sym))
                                                                            )
                                                                        )
                                                                        (= (Compiler'maybePrimitiveType init) Integer/TYPE)
                                                                            (§ ass init (StaticMethodExpr'new 0, 0, nil, (§ class RT), "longCast", (RT'vector init), false))
                                                                        (= (Compiler'maybePrimitiveType init) Float/TYPE)
                                                                            (§ ass init (StaticMethodExpr'new 0, 0, nil, (§ class RT), "doubleCast", (RT'vector init), false))
                                                                    )
                                                                )
                                                                ;; sequential enhancement of env (like Lisp let*)
                                                                (try
                                                                    (when isLoop
                                                                        (Var'pushThreadBindings (RT'map
                                                                            (object-array [
                                                                                Compiler'CLEAR_PATH clearpath
                                                                                Compiler'CLEAR_ROOT clearroot
                                                                                Compiler'NO_RECUR   nil
                                                                            ])
                                                                        ))
                                                                    )
                                                                    (let [#_"LocalBinding" lb (Compiler'registerLocal sym, (Compiler'tagOf sym), init, false)]
                                                                        (§ ass bindingInits (IPersistentVector'''cons bindingInits, (BindingInit'new lb, init)))
                                                                        (when isLoop
                                                                            (§ ass loopLocals (IPersistentVector'''cons loopLocals, lb))
                                                                        )
                                                                    )
                                                                    (finally
                                                                        (when isLoop
                                                                            (Var'popThreadBindings)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )]
                                                (when isLoop
                                                    (Var''set Compiler'LOOP_LOCALS, loopLocals)
                                                )
                                                (§ let [#_"Expr" bodyExpr]
                                                    (let [#_"boolean" moreMismatches false]
                                                        (try
                                                            (when isLoop
                                                                (Var'pushThreadBindings (RT'map
                                                                    (object-array [
                                                                        Compiler'CLEAR_PATH            clearpath
                                                                        Compiler'CLEAR_ROOT            clearroot
                                                                        Compiler'NO_RECUR              nil
                                                                        Compiler'METHOD_RETURN_CONTEXT (when (= context :Context'RETURN) (IDeref'''deref Compiler'METHOD_RETURN_CONTEXT))
                                                                    ])
                                                                ))
                                                            )
                                                            (§ ass bodyExpr (IParser'''parse (BodyParser'new), (if isLoop :Context'RETURN context), body))
                                                            (finally
                                                                (when isLoop
                                                                    (Var'popThreadBindings)
                                                                    (loop-when-recur [#_"int" i 0] (< i (.count loopLocals)) [(inc i)]
                                                                        (when (:recurMistmatch (cast' LocalBinding (Indexed'''nth-2 loopLocals, i)))
                                                                            (§ ass recurMismatches (cast' IPersistentVector (Associative'''assoc recurMismatches, i, RT'T)))
                                                                            (§ ass moreMismatches true)
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (when (not moreMismatches)
                                                            (§ return (LetExpr'new bindingInits, bodyExpr, isLoop))
                                                        )
                                                    )
                                                )
                                            )
                                            (finally
                                                (Var'popThreadBindings)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"LetExpr" LetExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
            #_"boolean" :isLoop false
        )
    )

    (defn #_"LetExpr" LetExpr'new [#_"PersistentVector" bindingInits, #_"Expr" body, #_"boolean" isLoop]
        (let [this (LetExpr'init)]
            (§ ass this (assoc this :bindingInits bindingInits))
            (§ ass this (assoc this :body body))
            (§ ass this (assoc this :isLoop isLoop))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--LetExpr [#_"LetExpr" this]
        (throw (UnsupportedOperationException. "Can't eval let/loop"))
    )

    #_override
    (defn #_"void" Expr'''emit--LetExpr [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (LetExpr''doEmit this, context, objx, gen, false)
        nil
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--LetExpr [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (LetExpr''doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (defn- #_"void" LetExpr''doEmit [#_"LetExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"HashMap<BindingInit, Label>" bindingLabels (HashMap.)]
            (dotimes [#_"int" i (.count (:bindingInits this))]
                (let [#_"BindingInit" bi (cast' BindingInit (Indexed'''nth-2 (:bindingInits this), i))
                      #_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                    (if (some? primc)
                        (do
                            (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr (:init bi)), :Context'EXPRESSION, objx, gen)
                            (.visitVarInsn gen, (.getOpcode (Type/getType primc), Opcodes/ISTORE), (:idx (:binding bi)))
                        )
                        (do
                            (Expr'''emit (:init bi), :Context'EXPRESSION, objx, gen)
                            (if (and (not (:used (:binding bi))) (:canBeCleared (:binding bi)))
                                (.pop gen)
                                (.visitVarInsn gen, (.getOpcode Compiler'OBJECT_TYPE, Opcodes/ISTORE), (:idx (:binding bi)))
                            )
                        )
                    )
                    (.put bindingLabels, bi, (.mark gen))
                )
            )
            (let [#_"Label" loopLabel (.mark gen)]
                (if (:isLoop this)
                    (try
                        (Var'pushThreadBindings (RT'map Compiler'LOOP_LABEL, loopLabel))
                        (if emitUnboxed
                            (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr (:body this)), context, objx, gen)
                            (Expr'''emit (:body this), context, objx, gen)
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                    (if emitUnboxed
                        (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr (:body this)), context, objx, gen)
                        (Expr'''emit (:body this), context, objx, gen)
                    )
                )
                (let [#_"Label" end (.mark gen)]
                    (loop-when-recur [#_"ISeq" bis (Seqable'''seq (:bindingInits this))] (some? bis) [(.next bis)]
                        (let [#_"BindingInit" bi (cast' BindingInit (.first bis))
                              #_"String" lname (:name (:binding bi))]
                            (when (.endsWith lname, "__auto__")
                                (§ ass lname (+ lname (RT'nextID)))
                            )
                            (let [#_"Class" primc (Compiler'maybePrimitiveType (:init bi))]
                                (if (some? primc)
                                    (.visitLocalVariable gen, lname, (Type/getDescriptor primc), nil, (.get bindingLabels, bi), end, (:idx (:binding bi)))
                                    (.visitLocalVariable gen, lname, "Ljava/lang/Object;", nil, (.get bindingLabels, bi), end, (:idx (:binding bi)))
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--LetExpr [#_"LetExpr" this]
        (Expr'''hasJavaClass (:body this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--LetExpr [#_"LetExpr" this]
        (Expr'''getJavaClass (:body this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--LetExpr [#_"LetExpr" this]
        (and (§ instance? MaybePrimitiveExpr (:body this)) (MaybePrimitiveExpr'''canEmitPrimitive (cast' MaybePrimitiveExpr (:body this))))
    )
)

#_closure
(class-ns RecurParser (§ implements IParser)
    (defn #_"RecurParser" RecurParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--RecurParser [#_"RecurParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"int" line (Compiler'lineDeref) #_"int" column (Compiler'columnDeref)
              #_"ISeq" form (cast' ISeq frm)
              #_"IPersistentVector" loopLocals (cast' IPersistentVector (IDeref'''deref Compiler'LOOP_LOCALS))]
            (when (or (not= context :Context'RETURN) (nil? loopLocals))
                (throw (UnsupportedOperationException. "Can only recur from tail position"))
            )
            (when (some? (IDeref'''deref Compiler'NO_RECUR))
                (throw (UnsupportedOperationException. "Cannot recur across try"))
            )
            (let [#_"PersistentVector" args
                    (loop-when-recur [args PersistentVector'EMPTY #_"ISeq" s (RT'seq (.next form))]
                                     (some? s)
                                     [(IPersistentVector'''cons args, (Compiler'analyze-2 :Context'EXPRESSION, (.first s))) (.next s)]
                                  => args
                    )]
                (when-not (= (.count args) (.count loopLocals))
                    (throw (IllegalArgumentException. (str "Mismatched argument count to recur, expected: " (.count loopLocals) " args, got: " (.count args))))
                )
                (dotimes [#_"int" i (.count loopLocals)]
                    (let [#_"LocalBinding" lb (cast' LocalBinding (Indexed'''nth-2 loopLocals, i)) #_"Class" primc (LocalBinding''getPrimitiveType lb)]
                        (when (some? primc)
                            (let [#_"Class" pc (Compiler'maybePrimitiveType (cast' Expr (Indexed'''nth-2 args, i)))
                                  #_"boolean" mismatch?
                                    (condp = primc
                                        Long/TYPE   (not (any = pc Long/TYPE Integer/TYPE Short/TYPE Character/TYPE Byte/TYPE))
                                        Double/TYPE (not (any = pc Double/TYPE Float/TYPE))
                                                    false
                                    )]
                                (when mismatch?
                                    (§ ass (:recurMistmatch lb) true)
                                    (when (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION))
                                        (.println (RT'errPrintWriter), (str "line " line ": recur arg for primitive local: " (:name lb) " is not matching primitive, had: " (if (some? pc) (.getName pc) "Object") ", needed: " (.getName primc)))
                                    )
                                )
                            )
                        )
                    )
                )
                (RecurExpr'new loopLocals, args, line, column)
            )
        )
    )
)

(class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"RecurExpr" RecurExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"IPersistentVector" :loopLocals nil

            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"RecurExpr" RecurExpr'new [#_"IPersistentVector" loopLocals, #_"IPersistentVector" args, #_"int" line, #_"int" column]
        (let [this (RecurExpr'init)]
            (§ ass this (assoc this :loopLocals loopLocals))
            (§ ass this (assoc this :args args))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--RecurExpr [#_"RecurExpr" this]
        (throw (UnsupportedOperationException. "Can't eval recur"))
    )

    #_override
    (defn #_"void" Expr'''emit--RecurExpr [#_"RecurExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (let-when [#_"Label" loopLabel (cast Label (IDeref'''deref Compiler'LOOP_LABEL))] (some? loopLabel) => (throw (IllegalStateException.))
            (dotimes [#_"int" i (.count (:loopLocals this))]
                (let [#_"LocalBinding" lb (cast' LocalBinding (Indexed'''nth-2 (:loopLocals this), i)) #_"Expr" arg (cast' Expr (Indexed'''nth-2 (:args this), i))]
                    (when (some? (LocalBinding''getPrimitiveType lb)) => (Expr'''emit arg, :Context'EXPRESSION, objx, gen)
                        (let [#_"Class" primc (LocalBinding''getPrimitiveType lb) #_"Class" pc (Compiler'maybePrimitiveType arg)]
                            (cond (= primc pc)
                                (do
                                    (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                )
                                (and (= primc Long/TYPE) (= pc Integer/TYPE))
                                (do
                                    (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/I2L)
                                )
                                (and (= primc Double/TYPE) (= pc Float/TYPE))
                                (do
                                    (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/F2D)
                                )
                                (and (= primc Integer/TYPE) (= pc Long/TYPE))
                                (do
                                    (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                    (.invokeStatic gen, Compiler'RT_TYPE, (Method/getMethod "int intCast(long)"))
                                )
                                (and (= primc Float/TYPE) (= pc Double/TYPE))
                                (do
                                    (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr arg), :Context'EXPRESSION, objx, gen)
                                    (.visitInsn gen, Opcodes/D2F)
                                )
                                :else
                                (do
                                    (throw (IllegalArgumentException. (str "recur arg for primitive local: " (:name lb) " is not matching primitive, had: " (if (Expr'''hasJavaClass arg) (.getName (Expr'''getJavaClass arg)) "Object") ", needed: " (.getName primc))))
                                )
                            )
                        )
                    )
                )
            )
            (loop-when-recur [#_"int" i (dec (.count (:loopLocals this)))] (<= 0 i) [(dec i)]
                (let [#_"LocalBinding" lb (cast' LocalBinding (Indexed'''nth-2 (:loopLocals this), i)) #_"Class" primc (LocalBinding''getPrimitiveType lb)]
                    (if (:isArg lb)
                        (.storeArg gen, (- (:idx lb) (if (:canBeDirect objx) 0 1)))
                        (.visitVarInsn gen, (.getOpcode (if (some? primc) (Type/getType primc) Compiler'OBJECT_TYPE), Opcodes/ISTORE), (:idx lb))
                    )
                )
            )
            (.goTo gen, loopLabel)
        )
        nil
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--RecurExpr [#_"RecurExpr" this]
        true
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--RecurExpr [#_"RecurExpr" this]
        Compiler'RECUR_CLASS
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--RecurExpr [#_"RecurExpr" this]
        true
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--RecurExpr [#_"RecurExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (Expr'''emit this, context, objx, gen)
        nil
    )
)

(class-ns CompilerException (§ extends RuntimeException)
    (defn- #_"CompilerException" CompilerException'init []
        (hash-map
            #_"int" :line 0
        )
    )

    (defn #_"CompilerException" CompilerException'new [#_"int" line, #_"int" column, #_"Throwable" cause]
        (let [this (merge (§ foreign RuntimeException'new (str cause ", compiling at (" line ":" column ")"), cause) (CompilerException'init))]
            (§ ass this (assoc this :line line))
            this
        )
    )

    #_foreign
    (§ defn #_"String" toString [#_"CompilerException" this]
        (.getMessage this)
    )
)

#_closure
(class-ns DeftypeParser (§ implements IParser)
    (defn #_"DeftypeParser" DeftypeParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--DeftypeParser [#_"DeftypeParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" rform (cast' ISeq frm)]
            ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
            (§ ass rform (RT'next rform))
            (let [#_"String" tagname (Named'''getName (cast' Symbol (.first rform)))]
                (§ ass rform (.next rform))
                (let [#_"Symbol" classname (cast' Symbol (.first rform))]
                    (§ ass rform (.next rform))
                    (let [#_"IPersistentVector" fields (cast' IPersistentVector (.first rform))]
                        (§ ass rform (.next rform))
                        (let [#_"IPersistentMap" opts PersistentHashMap'EMPTY]
                            (while (and (some? rform) (§ instance? Keyword (.first rform)))
                                (§ ass opts (IPersistentMap'''assoc opts, (.first rform), (RT'second rform)))
                                (§ ass rform (.next (.next rform)))
                            )

                            (let [#_"ObjExpr" ret (NewInstanceExpr'build (cast' IPersistentVector (RT'get-3 opts, Compiler'implementsKey, PersistentVector'EMPTY)), fields, nil, tagname, classname, (cast' Symbol (RT'get-2 opts, RT'TAG_KEY)), rform, frm, opts)]
                                ret
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ReifyParser (§ implements IParser)
    (defn #_"ReifyParser" ReifyParser'new []
        (hash-map)
    )

    #_override
    (defn #_"Expr" IParser'''parse--ReifyParser [#_"ReifyParser" this, #_"Context" context, #_"Object" form]
        ;; (reify this-name? [interfaces] (method-name [args] body)*)
        (let [#_"ISeq" s (cast' ISeq form)
              #_"ObjMethod" owner (cast' ObjMethod (IDeref'''deref Compiler'METHOD))
              #_"String" basename (if (some? owner) (ObjExpr'trimGenID (:name (:objx owner))) (Compiler'munge (:name (:name (Compiler'currentNS)))))
              #_"String" classname (str basename "$" "reify__" (RT'nextID))
              s (RT'next s)
              #_"IPersistentVector" ifaces (IPersistentVector'''cons (cast' IPersistentVector (RT'first s)), (Symbol'intern "cloiure.lang.IObj"))
              s (RT'next s)
              #_"ObjExpr" ret (NewInstanceExpr'build ifaces, nil, nil, classname, (Symbol'intern classname), nil, s, form, nil)]
            (when (and (§ instance? IObj form) (some? (IMeta'''meta (cast' IObj form)))) => ret
                (MetaExpr'new ret, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (IMeta'''meta (cast' IObj form))))
            )
        )
    )
)

(class-ns NewInstanceExpr (§ extends ObjExpr)
    (defn- #_"NewInstanceExpr" NewInstanceExpr'init []
        (hash-map
            #_"IPersistentCollection" :methods nil

            #_"Map<IPersistentVector, java.lang.reflect.Method>" :mmap nil
            #_"Map<IPersistentVector, Set<Class>>" :covariants nil
        )
    )

    (defn #_"NewInstanceExpr" NewInstanceExpr'new [#_"Object" tag]
        (merge (ObjExpr'new tag) (NewInstanceExpr'init))
    )

    (defn #_"ObjExpr" NewInstanceExpr'build [#_"IPersistentVector" interfaceSyms, #_"IPersistentVector" fieldSyms, #_"Symbol" thisSym, #_"String" tagName, #_"Symbol" className, #_"Symbol" typeTag, #_"ISeq" methodForms, #_"Object" frm, #_"IPersistentMap" opts]
        (let [#_"NewInstanceExpr" ret (NewInstanceExpr'new nil)
              _ (§ ass (:src ret) frm)
              _ (§ ass (:name ret) (.toString className))
              _ (§ ass (:classMeta ret) (RT'meta className))
              _ (§ ass (:internalName ret) (.replace (:name ret), \., \/))
              _ (§ ass (:objtype ret) (Type/getObjectType (:internalName ret)))
              _ (§ ass (:opts ret) opts)
              _ (when (some? thisSym)
                    (§ ass (:thisName ret) (:name thisSym))
                )]

            (when (some? fieldSyms)
                (let [#_"Object[]" closesvec (make-array Object (* 2 (.count fieldSyms)))
                      #_"IPersistentMap" fmap
                        (loop-when [fmap PersistentHashMap'EMPTY #_"int" i 0] (< i (.count fieldSyms)) => fmap
                            (let [#_"Symbol" sym (cast' Symbol (Indexed'''nth-2 fieldSyms, i))
                                  #_"LocalBinding" lb (LocalBinding'new -1, sym, nil, (MethodParamExpr'new (Compiler'tagClass (Compiler'tagOf sym))), false, nil)]
                                (aset closesvec (* i 2) lb)
                                (aset closesvec (inc (* i 2)) lb)
                                (recur (IPersistentMap'''assoc fmap, sym, lb) (inc i))
                            )
                        )]

                    ;; todo - inject __meta et al into closes - when?
                    ;; use array map to preserve ctor order
                    (§ ass (:closes ret) (PersistentArrayMap'new-1 closesvec))
                    (§ ass (:fields ret) fmap)
                    (loop-when-recur [#_"int" i (dec (.count fieldSyms))] (and (<= 0 i) (any = (:name (cast' Symbol (Indexed'''nth-2 fieldSyms, i))) "__meta" "__extmap" "__hash" "__hasheq")) [(dec i)]
                        (§ ass (:altCtorDrops ret) (inc (:altCtorDrops ret)))
                    )
                )
            )

            (let [#_"PersistentVector" ifaces
                    (loop-when [ifaces PersistentVector'EMPTY #_"ISeq" s (RT'seq interfaceSyms)] (some? s) => ifaces
                        (let [#_"Class" c (cast Class (Compiler'resolve-1 (cast' Symbol (.first s))))]
                            (when (.isInterface c) => (throw (IllegalArgumentException. (str "only interfaces are supported, had: " (.getName c))))
                                (recur (IPersistentVector'''cons ifaces, c) (.next s))
                            )
                        )
                    )
                  #_"Class" superClass Object
                  #_"Map[]" mc (NewInstanceExpr'gatherMethods-2s superClass, (RT'seq ifaces))
                  #_"Map" overrideables (aget mc 0) #_"Map" covariants (aget mc 1)
                  _ (§ ass (:mmap ret) overrideables)
                  _ (§ ass (:covariants ret) covariants)
                  #_"String[]" inames (NewInstanceExpr'interfaceNames ifaces)
                  #_"Class" stub (NewInstanceExpr'compileStub (NewInstanceExpr'slashname superClass), ret, inames, frm)
                  #_"Symbol" thistag (Symbol'intern nil, (.getName stub))]

                (try
                    (Var'pushThreadBindings (RT'mapUniqueKeys
                        (object-array [
                            Compiler'CONSTANTS          PersistentVector'EMPTY
                            Compiler'CONSTANT_IDS       (IdentityHashMap.)
                            Compiler'KEYWORDS           PersistentHashMap'EMPTY
                            Compiler'VARS               PersistentHashMap'EMPTY
                            Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                            Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                            Compiler'VAR_CALLSITES      (Compiler'emptyVarCallSites)
                            Compiler'NO_RECUR           nil
                        ])
                    ))
                    (when (ObjExpr''isDeftype ret)
                        (Var'pushThreadBindings (RT'mapUniqueKeys
                            (object-array [
                                Compiler'METHOD             nil
                                Compiler'LOCAL_ENV          (:fields ret)
                                Compiler'COMPILE_STUB_SYM   (Symbol'intern nil, tagName)
                                Compiler'COMPILE_STUB_CLASS stub
                            ])
                        ))
                        (§ ass (:hintedFields ret) (RT'subvec fieldSyms, 0, (- (.count fieldSyms) (:altCtorDrops ret))))
                    )

                    ;; now (methodname [args] body)*
                    (§ ass (:line ret) (Compiler'lineDeref))
                    (§ ass (:column ret) (Compiler'columnDeref))
                    (let [#_"IPersistentCollection" methods
                            (loop-when [methods nil #_"ISeq" s methodForms] (some? s) => methods
                                (let [#_"NewInstanceMethod" m (NewInstanceMethod'parse ret, (cast' ISeq (RT'first s)), thistag, overrideables)]
                                    (recur (RT'conj methods, m) (RT'next s))
                                )
                            )]
                        (§ ass (:methods ret) methods)
                        (§ ass (:keywords ret) (cast' IPersistentMap (IDeref'''deref Compiler'KEYWORDS)))
                        (§ ass (:vars ret) (cast' IPersistentMap (IDeref'''deref Compiler'VARS)))
                        (§ ass (:constants ret) (cast' PersistentVector (IDeref'''deref Compiler'CONSTANTS)))
                        (§ ass (:constantsID ret) (RT'nextID))
                        (§ ass (:keywordCallsites ret) (cast' IPersistentVector (IDeref'''deref Compiler'KEYWORD_CALLSITES)))
                        (§ ass (:protocolCallsites ret) (cast' IPersistentVector (IDeref'''deref Compiler'PROTOCOL_CALLSITES)))
                        (§ ass (:varCallsites ret) (cast' IPersistentSet (IDeref'''deref Compiler'VAR_CALLSITES)))
                    )
                    (finally
                        (when (ObjExpr''isDeftype ret)
                            (Var'popThreadBindings)
                        )
                        (Var'popThreadBindings)
                    )
                )

                (try
                    (ObjExpr''compile ret, (NewInstanceExpr'slashname superClass), inames, false)
                    (catch IOException e
                        (throw (Util'sneakyThrow e))
                    )
                )
                (ObjExpr''getCompiledClass ret)
                ret
            )
        )
    )

    ;;;
     ; Current host interop uses reflection, which requires pre-existing classes
     ; Work around this by:
     ; Generate a stub class that has the same interfaces and fields as the class we are generating.
     ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
     ; Unmunge the name (using a magic prefix) on any code gen for classes
     ;;
    (defn #_"Class" NewInstanceExpr'compileStub [#_"String" superName, #_"NewInstanceExpr" ret, #_"String[]" interfaceNames, #_"Object" frm]
        (let [#_"ClassWriter" cw (ClassWriter. ClassWriter/COMPUTE_MAXS) #_"ClassVisitor" cv cw]
            (.visit cv, Opcodes/V1_5, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_SUPER), (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret)), nil, superName, interfaceNames)

            ;; instance fields for closed-overs
            (loop-when-recur [#_"ISeq" s (RT'keys (:closes ret))] (some? s) [(.next s)]
                (let [#_"LocalBinding" lb (cast' LocalBinding (.first s))
                      #_"int" access (+ Opcodes/ACC_PUBLIC (if (ObjExpr''isVolatile ret, lb) Opcodes/ACC_VOLATILE (if (ObjExpr''isMutable ret, lb) 0 Opcodes/ACC_FINAL)))]
                    (if (some? (LocalBinding''getPrimitiveType lb))
                        (.visitField cv, access, (:name lb), (.getDescriptor (Type/getType (LocalBinding''getPrimitiveType lb))), nil, nil)
                        ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                        (.visitField cv, access, (:name lb), (.getDescriptor Compiler'OBJECT_TYPE), nil, nil)
                    )
                )
            )

            ;; ctor that takes closed-overs and does nothing
            (let [#_"Method" m (Method. "<init>", Type/VOID_TYPE, (ObjExpr''ctorTypes ret))
                  #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, nil, cv)]
                (.visitCode ctorgen)
                (.loadThis ctorgen)
                (.invokeConstructor ctorgen, (Type/getObjectType superName), ObjExpr'voidctor)
                (.returnValue ctorgen)
                (.endMethod ctorgen)
            )

            (when (pos? (:altCtorDrops ret))
                (let [#_"Type[]" ctorTypes (ObjExpr''ctorTypes ret)]

                    (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) (:altCtorDrops ret)))
                          _ (dotimes [#_"int" i (alength altCtorTypes)]
                                (aset altCtorTypes i (aget ctorTypes i))
                            )
                          #_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)
                          #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                        (.visitCode ctorgen)
                        (.loadThis ctorgen)
                        (.loadArgs ctorgen)

                        (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __meta
                        (.visitInsn ctorgen, Opcodes/ACONST_NULL) ;; __extmap
                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                        (.invokeConstructor ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret))), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                        (.returnValue ctorgen)
                        (.endMethod ctorgen)
                    )

                    ;; alt ctor no __hash, __hasheq
                    (let [#_"Type[]" altCtorTypes (make-array Type (- (alength ctorTypes) 2))
                          _ (dotimes [#_"int" i (alength altCtorTypes)]
                                (aset altCtorTypes i (aget ctorTypes i))
                            )
                          #_"Method" alt (Method. "<init>", Type/VOID_TYPE, altCtorTypes)
                          #_"GeneratorAdapter" ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, alt, nil, nil, cv)]
                        (.visitCode ctorgen)
                        (.loadThis ctorgen)
                        (.loadArgs ctorgen)

                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hash
                        (.visitInsn ctorgen, Opcodes/ICONST_0) ;; __hasheq

                        (.invokeConstructor ctorgen, (Type/getObjectType (str Compiler'COMPILE_STUB_PREFIX "/" (:internalName ret))), (Method. "<init>", Type/VOID_TYPE, ctorTypes))

                        (.returnValue ctorgen)
                        (.endMethod ctorgen)
                    )
                )
            )

            ;; end of class
            (.visitEnd cv)

            (let [#_"byte[]" bytecode (.toByteArray cw)
                  #_"DynamicClassLoader" loader (cast' DynamicClassLoader (IDeref'''deref Compiler'LOADER))]
                (.defineClass loader, (str Compiler'COMPILE_STUB_PREFIX "." (:name ret)), bytecode, frm)
            )
        )
    )

    (defn #_"String[]" NewInstanceExpr'interfaceNames [#_"IPersistentVector" interfaces]
        (let [#_"int" n (.count interfaces)
              #_"String[]" inames (when (pos? n) (make-array String n))]
            (dotimes [#_"int" i n]
                (aset inames i (NewInstanceExpr'slashname (cast Class (Indexed'''nth-2 interfaces, i))))
            )
            inames
        )
    )

    (defn #_"String" NewInstanceExpr'slashname [#_"Class" c]
        (.replace (.getName c), \., \/)
    )

    #_protected
    #_override
    (defn #_"void" ObjExpr'''emitStatics--NewInstanceExpr [#_"NewInstanceExpr" this, #_"ClassVisitor" cv]
        (when (ObjExpr''isDeftype this)
            ;; getBasis()
            (let [#_"Method" meth (Method/getMethod "cloiure.lang.IPersistentVector getBasis()")
                  #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), meth, nil, nil, cv)]
                (ObjExpr''emitValue this, (:hintedFields this), gen)
                (.returnValue gen)
                (.endMethod gen)

                (let-when [#_"int" n (.count (:hintedFields this))] (< n (.count (:fields this)))
                    ;; create(IPersistentMap)
                    (let [#_"String" className (.replace (:name this), \., \/)
                          #_"MethodVisitor" mv (.visitMethod cv, (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), "create", (str "(Lcloiure/lang/IPersistentMap;)L" className ";"), nil, nil)]
                        (.visitCode mv)

                        (loop-when-recur [#_"ISeq" s (RT'seq (:hintedFields this)) #_"int" i 1] (some? s) [(.next s) (inc i)]
                            (let [#_"String" bName (:name (cast' Symbol (.first s)))
                                  #_"Class" k (Compiler'tagClass (Compiler'tagOf (.first s)))]
                                (.visitVarInsn mv, Opcodes/ALOAD, 0)
                                (.visitLdcInsn mv, bName)
                                (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                (.visitInsn mv, Opcodes/ACONST_NULL)
                                (.visitMethodInsn mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
                                (when (.isPrimitive k)
                                    (.visitTypeInsn mv, Opcodes/CHECKCAST, (.getInternalName (Type/getType (Compiler'boxClass k))))
                                )
                                (.visitVarInsn mv, Opcodes/ASTORE, i)
                                (.visitVarInsn mv, Opcodes/ALOAD, 0)
                                (.visitLdcInsn mv, bName)
                                (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;")
                                (.visitMethodInsn mv, Opcodes/INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;")
                                (.visitVarInsn mv, Opcodes/ASTORE, 0)
                            )
                        )

                        (.visitTypeInsn mv, Opcodes/NEW, className)
                        (.visitInsn mv, Opcodes/DUP)

                        (let [#_"Method" ctor (Method. "<init>", Type/VOID_TYPE, (ObjExpr''ctorTypes this))]
                            (dotimes [#_"int" i n]
                                (.visitVarInsn mv, Opcodes/ALOAD, (inc i))
                                (let-when [#_"Class" k (Compiler'tagClass (Compiler'tagOf (Indexed'''nth-2 (:hintedFields this), i)))] (.isPrimitive k)
                                    (.visitMethodInsn mv, Opcodes/INVOKEVIRTUAL, (.getInternalName (Type/getType (Compiler'boxClass k))), (str (.getName k) "Value"), (str "()" (.getDescriptor (Type/getType k))))
                                )
                            )

                            (.visitInsn mv, Opcodes/ACONST_NULL) ;; __meta
                            (.visitVarInsn mv, Opcodes/ALOAD, 0) ;; __extmap
                            (.visitMethodInsn mv, Opcodes/INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;")
                            (.visitInsn mv, Opcodes/ICONST_0) ;; __hash
                            (.visitInsn mv, Opcodes/ICONST_0) ;; __hasheq
                            (.visitMethodInsn mv, Opcodes/INVOKESPECIAL, className, "<init>", (.getDescriptor ctor))
                            (.visitInsn mv, Opcodes/ARETURN)
                            (.visitMaxs mv, (+ 4 n), (+ 1 n))
                            (.visitEnd mv)
                        )
                    )
                )
            )
        )
        nil
    )

    #_protected
    #_override
    (defn #_"void" ObjExpr'''emitMethods--NewInstanceExpr [#_"NewInstanceExpr" this, #_"ClassVisitor" cv]
        (loop-when-recur [#_"ISeq" s (RT'seq (:methods this))] (some? s) [(.next s)]
            (§ unsure Expr'''emit (cast' ObjMethod (.first s)), this, cv)
        )
        ;; emit bridge methods
        (doseq [#_"Map$Entry<IPersistentVector, Set<Class>>" e (.entrySet (:covariants this))]
            (let [#_"java.lang.reflect.Method" m (.get (:mmap this), (.getKey e))
                  #_"Class[]" params (.getParameterTypes m)
                  #_"Type[]" argTypes (make-array Type (alength params))
                  _ (dotimes [#_"int" i (alength params)]
                        (aset argTypes i (§ unsure Type/getType (aget params i)))
                    )
                  #_"Method" target (Method. (.getName m), (Type/getType (.getReturnType m)), argTypes)]
                (doseq [#_"Class" retType (.getValue e)]
                    (let [#_"Method" meth (Method. (.getName m), (Type/getType retType), argTypes)
                          ;; todo don't hardwire EXCEPTION_TYPES
                          #_"GeneratorAdapter" gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_BRIDGE), meth, nil, Compiler'EXCEPTION_TYPES, cv)]
                        (.visitCode gen)
                        (.loadThis gen)
                        (.loadArgs gen)
                        (.invokeInterface gen, (Type/getType (.getDeclaringClass m)), target)
                        (.returnValue gen)
                        (.endMethod gen)
                    )
                )
            )
        )
        nil
    )

    (defn #_"IPersistentVector" NewInstanceExpr'msig [#_"java.lang.reflect.Method" m]
        (RT'vector (.getName m), (RT'seq (.getParameterTypes m)), (.getReturnType m))
    )

    (defn #_"void" NewInstanceExpr'considerMethod [#_"java.lang.reflect.Method" m, #_"Map" mm]
        (let [#_"IPersistentVector" mk (NewInstanceExpr'msig m) #_"int" mods (.getModifiers m)]
            (when (not (or (.containsKey mm, mk) (not (or (Modifier/isPublic mods) (Modifier/isProtected mods))) (Modifier/isStatic mods) (Modifier/isFinal mods)))
                (.put mm, mk, m)
            )
        )
        nil
    )

    (defn #_"void" NewInstanceExpr'gatherMethods-2m [#_"Class" c, #_"Map" mm]
        (loop-when-recur [c c] (some? c) [(.getSuperclass c)]
            (doseq [#_"java.lang.reflect.Method" m (.getDeclaredMethods c)]
                (NewInstanceExpr'considerMethod m, mm)
            )
            (doseq [#_"java.lang.reflect.Method" m (.getMethods c)]
                (NewInstanceExpr'considerMethod m, mm)
            )
        )
        nil
    )

    (defn #_"Map[]" NewInstanceExpr'gatherMethods-2s [#_"Class" sc, #_"ISeq" ifaces]
        (let [#_"Map" allm (HashMap.)
              _ (NewInstanceExpr'gatherMethods-2m sc, allm)
              _ (loop-when-recur ifaces (some? ifaces) [(.next ifaces)]
                    (NewInstanceExpr'gatherMethods-2m (cast Class (.first ifaces)), allm)
                )
              #_"Map<IPersistentVector, java.lang.reflect.Method>" methods (HashMap.)
              #_"Map<IPersistentVector, Set<Class>>" covariants (HashMap.)]
            (loop-when-recur [#_"Iterator" it (.iterator (.entrySet allm))] (.hasNext it) [it]
                (let [#_"Map$Entry" e (cast Map$Entry (.next it))
                      #_"IPersistentVector" mk (cast' IPersistentVector (IPersistentStack'''pop (cast' IPersistentVector (.getKey e))))
                      #_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                    (if (.containsKey methods, mk) ;; covariant return
                        (let [#_"Set<Class>" cvs
                                (or (.get covariants, mk)
                                    (let [cvs (HashSet.)]
                                        (.put covariants, mk, cvs)
                                        cvs
                                    )
                                )
                              #_"Class" tk (.getReturnType (.get methods, mk)) #_"Class" t (.getReturnType m)]
                            (when (.isAssignableFrom tk, t) => (.add cvs, t)
                                (.add cvs, tk)
                                (.put methods, mk, m)
                            )
                        )
                        (.put methods, mk, m)
                    )
                )
            )
            (§ new Map[] (object-array [ methods, covariants ]))
        )
    )
)

(class-ns NewInstanceMethod (§ extends ObjMethod)
    (§ def #_"Symbol" NewInstanceMethod'dummyThis (Symbol'intern nil, "dummy_this_dlskjsdfower"))

    (defn- #_"NewInstanceMethod" NewInstanceMethod'init []
        (hash-map
            #_"String" :name nil
            #_"Type[]" :argTypes nil
            #_"Type" :retType nil
            #_"Class" :retClass nil
            #_"Class[]" :exclasses nil

            #_"IPersistentVector" :parms nil
        )
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'new [#_"ObjExpr" objx, #_"ObjMethod" parent]
        (merge (ObjMethod'new objx, parent) (NewInstanceMethod'init))
    )

    #_override
    (defn #_"int" ObjMethod'''numParams--NewInstanceMethod [#_"NewInstanceMethod" this]
        (.count (:argLocals this))
    )

    #_override
    (defn #_"String" ObjMethod'''getMethodName--NewInstanceMethod [#_"NewInstanceMethod" this]
        (:name this)
    )

    #_override
    (defn #_"Type" ObjMethod'''getReturnType--NewInstanceMethod [#_"NewInstanceMethod" this]
        (:retType this)
    )

    #_override
    (defn #_"Type[]" ObjMethod'''getArgTypes--NewInstanceMethod [#_"NewInstanceMethod" this]
        (:argTypes this)
    )

    (defn #_"IPersistentVector" NewInstanceMethod'msig [#_"String" name, #_"Class[]" paramTypes]
        (RT'vector name, (RT'seq paramTypes))
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'parse [#_"ObjExpr" objx, #_"ISeq" form, #_"Symbol" thistag, #_"Map" overrideables]
        ;; (methodname [this-name args*] body...)
        ;; this-name might be nil
        (let [#_"NewInstanceMethod" method (NewInstanceMethod'new objx, (cast' ObjMethod (IDeref'''deref Compiler'METHOD)))
              #_"Symbol" dotname (cast' Symbol (RT'first form))
              #_"Symbol" name (cast' Symbol (IObj'''withMeta (Symbol'intern nil, (Compiler'munge (:name dotname))), (RT'meta dotname)))
              #_"IPersistentVector" parms (cast' IPersistentVector (RT'second form))]
            (when (pos? (.count parms)) => (throw (IllegalArgumentException. (str "Must supply at least one argument for 'this' in: " dotname)))
                (let [#_"Symbol" thisName (cast' Symbol (Indexed'''nth-2 parms, 0))
                      parms (RT'subvec parms, 1, (.count parms))
                      #_"ISeq" body (RT'next (RT'next form))]
                    (try
                        (let [_ (§ ass (:line method) (Compiler'lineDeref))
                              _ (§ ass (:column method) (Compiler'columnDeref))
                              ;; register as the current method and set up a new env frame
                              #_"PathNode" pnode (PathNode'new :PathType'PATH, (cast' PathNode (Var''get Compiler'CLEAR_PATH)))]
                            (Var'pushThreadBindings (RT'mapUniqueKeys
                                (object-array [
                                    Compiler'METHOD                method
                                    Compiler'LOCAL_ENV             (IDeref'''deref Compiler'LOCAL_ENV)
                                    Compiler'LOOP_LOCALS           nil
                                    Compiler'NEXT_LOCAL_NUM        0
                                    Compiler'CLEAR_PATH            pnode
                                    Compiler'CLEAR_ROOT            pnode
                                    Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                    Compiler'METHOD_RETURN_CONTEXT RT'T
                                ])
                            ))

                            ;; register 'this' as local 0
                            (if (some? thisName)
                                (Compiler'registerLocal (or thisName NewInstanceMethod'dummyThis), thistag, nil, false)
                                (Compiler'getAndIncLocalNum)
                            )

                            (let [_ (§ ass (:retClass method) (Compiler'tagClass (Compiler'tagOf name)))
                                  _ (§ ass (:argTypes method) (make-array Type (.count parms)))
                                  #_"Class[]" pclasses (make-array Class (.count parms))
                                  #_"Symbol[]" psyms (make-array #_"Symbol" Object (.count parms))
                                  #_"boolean" hinted
                                    (loop-when [hinted (some? (Compiler'tagOf name)) #_"int" i 0] (< i (.count parms)) => hinted
                                        (when (§ instance? Symbol (Indexed'''nth-2 parms, i)) => (throw (IllegalArgumentException. "params must be Symbols"))
                                            (let [#_"Symbol" p (cast' Symbol (Indexed'''nth-2 parms, i))
                                                  #_"Object" tag (Compiler'tagOf p)
                                                  hinted (or hinted (some? tag))
                                                  p (if (some? (Named'''getNamespace p)) (Symbol'intern (:name p)) p)]
                                                (aset pclasses i (Compiler'tagClass tag))
                                                (aset psyms i p)
                                                (recur hinted (inc i))
                                            )
                                        )
                                    )
                                  #_"Map" matches (NewInstanceMethod'findMethodsWithNameAndArity (:name name), (.count parms), overrideables)
                                  #_"Object" mk (NewInstanceMethod'msig (:name name), pclasses)
                                  #_"java.lang.reflect.Method" m
                                    (case (.size matches)
                                        0   (throw (IllegalArgumentException. (str "Can't define method not in interfaces: " (:name name))))
                                        1   (if hinted ;; validate match
                                                (let [m (cast java.lang.reflect.Method (.get matches, mk))]
                                                    (when (nil? m)
                                                        (throw (IllegalArgumentException. (str "Can't find matching method: " (:name name) ", leave off hints for auto match.")))
                                                    )
                                                    (when-not (= (.getReturnType m) (:retClass method))
                                                        (throw (IllegalArgumentException. (str "Mismatched return type: " (:name name) ", expected: " (.getName (.getReturnType m)) ", had: " (.getName (:retClass method)))))
                                                    )
                                                    m
                                                )
                                                ;; adopt found method sig
                                                (let [m (cast java.lang.reflect.Method (.next (.iterator (.values matches))))]
                                                    (§ ass (:retClass method) (.getReturnType m))
                                                    (§ ass pclasses (.getParameterTypes m))
                                                    m
                                                )
                                            )
                                            ;; must be hinted and match one method
                                            (when hinted => (throw (IllegalArgumentException. (str "Must hint overloaded method: " (:name name))))
                                                (let [m (cast java.lang.reflect.Method (.get matches, mk))]
                                                    (when (nil? m)
                                                        (throw (IllegalArgumentException. (str "Can't find matching overloaded method: " (:name name))))
                                                    )
                                                    (when-not (= (.getReturnType m) (:retClass method))
                                                        (throw (IllegalArgumentException. (str "Mismatched return type: " (:name name) ", expected: " (.getName (.getReturnType m)) ", had: " (.getName (:retClass method)))))
                                                    )
                                                    m
                                                )
                                            )
                                    )]

                                ;; validate unque name+arity among additional methods

                                (§ ass (:retType method) (Type/getType (:retClass method)))
                                (§ ass (:exclasses method) (.getExceptionTypes m))

                                (let [#_"PersistentVector" argLocals
                                        (loop-when [argLocals PersistentVector'EMPTY #_"int" i 0] (< i (.count parms)) => argLocals
                                            (let [#_"LocalBinding" lb (Compiler'registerLocal (aget psyms i), nil, (MethodParamExpr'new (aget pclasses i)), true)]
                                                (aset (:argTypes method) i (§ unsure Type/getType (aget pclasses i)))
                                                (recur (IPersistentVector'''assocN argLocals, i, lb) (inc i))
                                            )
                                        )]
                                    (dotimes [#_"int" i (.count parms)]
                                        (when (any = (aget pclasses i) Long/TYPE Double/TYPE)
                                            (Compiler'getAndIncLocalNum)
                                        )
                                    )
                                    (Var''set Compiler'LOOP_LOCALS, argLocals)
                                    (§ ass (:name method) (:name name))
                                    (§ ass (:methodMeta method) (RT'meta name))
                                    (§ ass (:parms method) parms)
                                    (§ ass (:argLocals method) argLocals)
                                    (§ ass (:body method) (IParser'''parse (BodyParser'new), :Context'RETURN, body))
                                    method
                                )
                            )
                        )
                        (finally
                            (Var'popThreadBindings)
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithNameAndArity [#_"String" name, #_"int" arity, #_"Map" mm]
        (let [#_"Map" found (HashMap.)]
            (doseq [#_"Object" o (.entrySet mm)]
                (let [#_"Map$Entry" e (cast Map$Entry o)
                      #_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                    (when (and (= name (.getName m)) (= (alength (.getParameterTypes m)) arity))
                        (.put found, (.getKey e), (.getValue e))
                    )
                )
            )
            found
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithName [#_"String" name, #_"Map" mm]
        (let [#_"Map" found (HashMap.)]
            (doseq [#_"Object" o (.entrySet mm)]
                (let [#_"Map$Entry" e (cast Map$Entry o)
                      #_"java.lang.reflect.Method" m (cast java.lang.reflect.Method (.getValue e))]
                    (when (= name (.getName m))
                        (.put found, (.getKey e), (.getValue e))
                    )
                )
            )
            found
        )
    )

    #_override
    (defn #_"void" Expr'''emit--NewInstanceMethod [#_"NewInstanceMethod" this, #_"ObjExpr" obj, #_"ClassVisitor" cv]
        (let [#_"Method" m (Method. (ObjMethod'''getMethodName this), (ObjMethod'''getReturnType this), (ObjMethod'''getArgTypes this))
              #_"Type[]" extypes
                (let-when [#_"int" n (alength (:exclasses this))] (pos? n)
                    (let [extypes (make-array Type n)]
                        (dotimes [#_"int" i n]
                            (aset extypes i (§ unsure Type/getType (aget (:exclasses this) i)))
                        )
                        extypes
                    )
                )
              #_"GeneratorAdapter" gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, m, nil, extypes, cv)]
            (.visitCode gen)

            (let [#_"Label" loopLabel (.mark gen)]
                (.visitLineNumber gen, (:line this), loopLabel)
                (try
                    (Var'pushThreadBindings (RT'map Compiler'LOOP_LABEL, loopLabel, Compiler'METHOD, this))

                    (ObjMethod'emitBody (:objx this), gen, (:retClass this), (:body this))
                    (let [#_"Label" end (.mark gen)]
                        (.visitLocalVariable gen, "this", (.getDescriptor (:objtype obj)), nil, loopLabel, end, 0)
                        (loop-when-recur [#_"ISeq" lbs (Seqable'''seq (:argLocals this))] (some? lbs) [(.next lbs)]
                            (let [#_"LocalBinding" lb (cast' LocalBinding (.first lbs))]
                                (.visitLocalVariable gen, (:name lb), (.getDescriptor (aget (:argTypes this) (dec (:idx lb)))), nil, loopLabel, end, (:idx lb))
                            )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )

                (.returnValue gen)
                (.endMethod gen)
            )
        )
        nil
    )
)

(class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"MethodParamExpr" MethodParamExpr'init []
        (hash-map
            #_"Class" :c nil
        )
    )

    (defn #_"MethodParamExpr" MethodParamExpr'new [#_"Class" c]
        (let [this (MethodParamExpr'init)]
            (§ ass this (assoc this :c c))
            this
        )
    )

    #_override
    (defn #_"Object" Expr'''eval--MethodParamExpr [#_"MethodParamExpr" this]
        (throw (RuntimeException. "Can't eval"))
    )

    #_override
    (defn #_"void" Expr'''emit--MethodParamExpr [#_"MethodParamExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (throw (RuntimeException. "Can't emit"))
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--MethodParamExpr [#_"MethodParamExpr" this]
        (some? (:c this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--MethodParamExpr [#_"MethodParamExpr" this]
        (:c this)
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--MethodParamExpr [#_"MethodParamExpr" this]
        (Util'isPrimitive (:c this))
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--MethodParamExpr [#_"MethodParamExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (throw (RuntimeException. "Can't emit"))
    )
)

#_closure
(class-ns CaseParser (§ implements IParser)
    (defn #_"CaseParser" CaseParser'new []
        (hash-map)
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    ;; prepared by case macro and presumed correct
    ;; case macro binds actual expr in let so expr is always a local,
    ;; no need to worry about multiple evaluation
    #_override
    (defn #_"Expr" IParser'''parse--CaseParser [#_"CaseParser" this, #_"Context" context, #_"Object" frm]
        (let [#_"ISeq" form (cast' ISeq frm)]
            (if (= context :Context'EVAL)
                (Compiler'analyze-2 context, (RT'list-1 (RT'list-3 Compiler'FNONCE, PersistentVector'EMPTY, form)))
                (let [#_"IPersistentVector" args (LazilyPersistentVector'create (.next form))
                      #_"Object" exprForm (Indexed'''nth-2 args, 0)
                      #_"int" shift (.intValue (cast Number (Indexed'''nth-2 args, 1)))
                      #_"int" mask (.intValue (cast Number (Indexed'''nth-2 args, 2)))
                      #_"Object" defaultForm (Indexed'''nth-2 args, 3)
                      #_"Map" caseMap (cast Map (Indexed'''nth-2 args, 4))
                      #_"Keyword" switchType (cast' Keyword (Indexed'''nth-2 args, 5))
                      #_"Keyword" testType (cast' Keyword (Indexed'''nth-2 args, 6))
                      #_"Set" skipCheck (when (< 7 (RT'count args)) (cast Set (Indexed'''nth-2 args, 7)))
                      #_"ISeq" keys (RT'keys caseMap)
                      #_"int" low (.intValue (cast Number (RT'first keys)))
                      #_"int" high (.intValue (cast Number (RT'nth-2 keys, (dec (RT'count keys)))))
                      #_"LocalBindingExpr" testexpr (cast' LocalBindingExpr (Compiler'analyze-2 :Context'EXPRESSION, exprForm))
                      _ (§ ass (:shouldClear testexpr) false)
                      #_"SortedMap<Integer, Expr>" tests (TreeMap.)
                      #_"HashMap<Integer, Expr>" thens (HashMap.)
                      #_"PathNode" branch (PathNode'new :PathType'BRANCH, (cast' PathNode (Var''get Compiler'CLEAR_PATH)))
                      _ (doseq [#_"Object" o (.entrySet caseMap)]
                            (let [#_"Map$Entry" e (cast Map$Entry o)
                                  #_"Integer" minhash (.intValue (cast Number (.getKey e)))
                                  #_"Object" pair (.getValue e) ;; [test-val then-expr]
                                  #_"Expr" testExpr
                                    (if (= testType CaseExpr'intKey)
                                        (NumberExpr'parse (.intValue (cast Number (RT'first pair))))
                                        (ConstantExpr'new (RT'first pair))
                                    )]
                                (.put tests, minhash, testExpr)
                                (let [#_"Expr" thenExpr
                                        (try
                                            (Var'pushThreadBindings (RT'map Compiler'CLEAR_PATH, (PathNode'new :PathType'PATH, branch)))
                                            (Compiler'analyze-2 context, (RT'second pair))
                                            (finally
                                                (Var'popThreadBindings)
                                            )
                                        )]
                                    (.put thens, minhash, thenExpr)
                                )
                            )
                        )
                      #_"Expr" defaultExpr
                        (try
                            (Var'pushThreadBindings (RT'map Compiler'CLEAR_PATH, (PathNode'new :PathType'PATH, branch)))
                            (Compiler'analyze-2 context, (Indexed'''nth-2 args, 3))
                            (finally
                                (Var'popThreadBindings)
                            )
                        )
                      #_"int" line (.intValue (cast Number (IDeref'''deref Compiler'LINE)))
                      #_"int" column (.intValue (cast Number (IDeref'''deref Compiler'COLUMN)))]
                    (CaseExpr'new line, column, testexpr, shift, mask, low, high, defaultExpr, tests, thens, switchType, testType, skipCheck)
                )
            )
        )
    )
)

(class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
    (def #_"Type" CaseExpr'NUMBER_TYPE (Type/getType Number))
    (def #_"Method" CaseExpr'intValueMethod (Method/getMethod "int intValue()"))

    (def #_"Method" CaseExpr'hashMethod (Method/getMethod "int hash(Object)"))
    (def #_"Method" CaseExpr'hashCodeMethod (Method/getMethod "int hashCode()"))
    (def #_"Method" CaseExpr'equivMethod (Method/getMethod "boolean equiv(Object, Object)"))
    (§ def #_"Keyword" CaseExpr'compactKey (Keyword'intern (Symbol'intern nil, "compact")))
    (§ def #_"Keyword" CaseExpr'sparseKey (Keyword'intern (Symbol'intern nil, "sparse")))
    (§ def #_"Keyword" CaseExpr'hashIdentityKey (Keyword'intern (Symbol'intern nil, "hash-identity")))
    (§ def #_"Keyword" CaseExpr'hashEquivKey (Keyword'intern (Symbol'intern nil, "hash-equiv")))
    (§ def #_"Keyword" CaseExpr'intKey (Keyword'intern (Symbol'intern nil, "int")))

    (defn- #_"CaseExpr" CaseExpr'init []
        (hash-map
            #_"LocalBindingExpr" :expr nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"int" :low 0
            #_"int" :high 0
            #_"Expr" :defaultExpr nil
            #_"SortedMap<Integer, Expr>" :tests nil
            #_"HashMap<Integer, Expr>" :thens nil
            #_"Keyword" :switchType nil
            #_"Keyword" :testType nil
            #_"Set<Integer>" :skipCheck nil
            #_"Class" :returnType nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    (defn #_"CaseExpr" CaseExpr'new [#_"int" line, #_"int" column, #_"LocalBindingExpr" expr, #_"int" shift, #_"int" mask, #_"int" low, #_"int" high, #_"Expr" defaultExpr, #_"SortedMap<Integer, Expr>" tests, #_"HashMap<Integer, Expr>" thens, #_"Keyword" switchType, #_"Keyword" testType, #_"Set<Integer>" skipCheck]
        (let [this (CaseExpr'init)]
            (§ ass this (assoc this :expr expr))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :mask mask))
            (§ ass this (assoc this :low low))
            (§ ass this (assoc this :high high))
            (§ ass this (assoc this :defaultExpr defaultExpr))
            (§ ass this (assoc this :tests tests))
            (§ ass this (assoc this :thens thens))
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            (when (and (not= switchType CaseExpr'compactKey) (not= switchType CaseExpr'sparseKey))
                (throw (IllegalArgumentException. (str "Unexpected switch type: " switchType)))
            )
            (§ ass this (assoc this :switchType switchType))
            (when (and (not= testType CaseExpr'intKey) (not= testType CaseExpr'hashEquivKey) (not= testType CaseExpr'hashIdentityKey))
                (throw (IllegalArgumentException. (str "Unexpected test type: " switchType)))
            )
            (§ ass this (assoc this :testType testType))
            (§ ass this (assoc this :skipCheck skipCheck))
            (let [#_"Collection<Expr>" returns (ArrayList. (.values thens))]
                (.add returns, defaultExpr)
                (§ ass this (assoc this :returnType (Compiler'maybeJavaClass returns)))
                (when (and (pos? (RT'count skipCheck)) (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION)))
                    (.format (RT'errPrintWriter), "Performance warning, %d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", (object-array [ line, column ]))
                )
                this
            )
        )
    )

    #_override
    (defn #_"boolean" Expr'''hasJavaClass--CaseExpr [#_"CaseExpr" this]
        (some? (:returnType this))
    )

    #_override
    (defn #_"boolean" MaybePrimitiveExpr'''canEmitPrimitive--CaseExpr [#_"CaseExpr" this]
        (Util'isPrimitive (:returnType this))
    )

    #_override
    (defn #_"Class" Expr'''getJavaClass--CaseExpr [#_"CaseExpr" this]
        (:returnType this)
    )

    #_override
    (defn #_"Object" Expr'''eval--CaseExpr [#_"CaseExpr" this]
        (throw (UnsupportedOperationException. "Can't eval case"))
    )

    #_override
    (defn #_"void" Expr'''emit--CaseExpr [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (CaseExpr''doEmit this, context, objx, gen, false)
        nil
    )

    #_override
    (defn #_"void" MaybePrimitiveExpr'''emitUnboxed--CaseExpr [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (CaseExpr''doEmit this, context, objx, gen, true)
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''doEmit [#_"CaseExpr" this, #_"Context" context, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"boolean" emitUnboxed]
        (let [#_"Label" defaultLabel (.newLabel gen) #_"Label" endLabel (.newLabel gen)
              #_"SortedMap<Integer, Label>" labels (TreeMap.) _ (doseq [#_"Integer" i (.keySet (:tests this))] (.put labels, i, (.newLabel gen)))]

            (.visitLineNumber gen, (:line this), (.mark gen))

            (let [#_"Class" primExprClass (Compiler'maybePrimitiveType (:expr this))
                  #_"Type" primExprType (when (some? primExprClass) (Type/getType primExprClass))]
                (if (= (:testType this) CaseExpr'intKey)
                    (CaseExpr''emitExprForInts this, objx, gen, primExprType, defaultLabel)
                    (CaseExpr''emitExprForHashes this, objx, gen)
                )

                (if (= (:switchType this) CaseExpr'sparseKey)
                    (let [#_"Label[]" la (make-array Label (.size labels))]
                        (§ ass la (.toArray (.values labels), la))
                        (let [#_"int[]" ints (Numbers'int_array-1 (.keySet (:tests this)))]
                            (.visitLookupSwitchInsn gen, defaultLabel, ints, la)
                        )
                    )
                    (let [#_"Label[]" la (make-array Label (inc (- (:high this) (:low this))))]
                        (loop-when-recur [#_"int" i (:low this)] (<= i (:high this)) [(inc i)]
                            (aset la (- i (:low this)) (if (.containsKey labels, i) (.get labels, i) defaultLabel))
                        )
                        (.visitTableSwitchInsn gen, (:low this), (:high this), defaultLabel, la)
                    )
                )

                (doseq [#_"Integer" i (.keySet labels)]
                    (.mark gen, (.get labels, i))
                    (cond
                        (= (:testType this) CaseExpr'intKey)
                            (CaseExpr''emitThenForInts this, objx, gen, primExprType, (.get (:tests this), i), (.get (:thens this), i), defaultLabel, emitUnboxed)
                        (= (RT'contains (:skipCheck this), i) RT'T)
                            (CaseExpr'emitExpr objx, gen, (.get (:thens this), i), emitUnboxed)
                        :else
                            (CaseExpr''emitThenForHashes this, objx, gen, (.get (:tests this), i), (.get (:thens this), i), defaultLabel, emitUnboxed)
                    )
                    (.goTo gen, endLabel)
                )

                (.mark gen, defaultLabel)
                (CaseExpr'emitExpr objx, gen, (:defaultExpr this), emitUnboxed)
                (.mark gen, endLabel)
                (when (= context :Context'STATEMENT)
                    (.pop gen)
                )
            )
        )
        nil
    )

    #_method
    (defn- #_"boolean" CaseExpr''isShiftMasked [#_"CaseExpr" this]
        (not= (:mask this) 0)
    )

    #_method
    (defn- #_"void" CaseExpr''emitShiftMask [#_"CaseExpr" this, #_"GeneratorAdapter" gen]
        (when (CaseExpr''isShiftMasked this)
            (.push gen, (:shift this))
            (.visitInsn gen, Opcodes/ISHR)
            (.push gen, (:mask this))
            (.visitInsn gen, Opcodes/IAND)
        )
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''emitExprForInts [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Label" defaultLabel]
        (cond (nil? exprType)
            (do
                (when (RT'booleanCast-1o (IDeref'''deref RT'WARN_ON_REFLECTION))
                    (.format (RT'errPrintWriter), "Performance warning, %d:%d - case has int tests, but tested expression is not primitive.\n", (object-array [ (:line this), (:column this) ]))
                )
                (Expr'''emit (:expr this), :Context'EXPRESSION, objx, gen)
                (.instanceOf gen, CaseExpr'NUMBER_TYPE)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
                (Expr'''emit (:expr this), :Context'EXPRESSION, objx, gen)
                (.checkCast gen, CaseExpr'NUMBER_TYPE)
                (.invokeVirtual gen, CaseExpr'NUMBER_TYPE, HostExpr'intValueMethod)
                (CaseExpr''emitShiftMask this, gen)
            )
            (or (= exprType Type/LONG_TYPE) (= exprType Type/INT_TYPE) (= exprType Type/SHORT_TYPE) (= exprType Type/BYTE_TYPE))
            (do
                (MaybePrimitiveExpr'''emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                (.cast gen, exprType, Type/INT_TYPE)
                (CaseExpr''emitShiftMask this, gen)
            )
            :else
            (do
                (.goTo gen, defaultLabel)
            )
        )
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''emitThenForInts [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Type" exprType, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
        (cond (nil? exprType)
            (do
                (Expr'''emit (:expr this), :Context'EXPRESSION, objx, gen)
                (Expr'''emit test, :Context'EXPRESSION, objx, gen)
                (.invokeStatic gen, Compiler'UTIL_TYPE, CaseExpr'equivMethod)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            (= exprType Type/LONG_TYPE)
            (do
                (MaybePrimitiveExpr'''emitUnboxed (cast' NumberExpr test), :Context'EXPRESSION, objx, gen)
                (MaybePrimitiveExpr'''emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                (.ifCmp gen, Type/LONG_TYPE, GeneratorAdapter/NE, defaultLabel)
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            (or (= exprType Type/INT_TYPE) (= exprType Type/SHORT_TYPE) (= exprType Type/BYTE_TYPE))
            (do
                (when (CaseExpr''isShiftMasked this)
                    (MaybePrimitiveExpr'''emitUnboxed (cast' NumberExpr test), :Context'EXPRESSION, objx, gen)
                    (MaybePrimitiveExpr'''emitUnboxed (:expr this), :Context'EXPRESSION, objx, gen)
                    (.cast gen, exprType, Type/LONG_TYPE)
                    (.ifCmp gen, Type/LONG_TYPE, GeneratorAdapter/NE, defaultLabel)
                )
                ;; else direct match
                (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
            )
            :else
            (do
                (.goTo gen, defaultLabel)
            )
        )
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''emitExprForHashes [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen]
        (Expr'''emit (:expr this), :Context'EXPRESSION, objx, gen)
        (.invokeStatic gen, Compiler'UTIL_TYPE, CaseExpr'hashMethod)
        (CaseExpr''emitShiftMask this, gen)
        nil
    )

    #_method
    (defn- #_"void" CaseExpr''emitThenForHashes [#_"CaseExpr" this, #_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" test, #_"Expr" then, #_"Label" defaultLabel, #_"boolean" emitUnboxed]
        (Expr'''emit (:expr this), :Context'EXPRESSION, objx, gen)
        (Expr'''emit test, :Context'EXPRESSION, objx, gen)
        (if (= (:testType this) CaseExpr'hashIdentityKey)
            (do
                (.visitJumpInsn gen, Opcodes/IF_ACMPNE, defaultLabel)
            )
            (do
                (.invokeStatic gen, Compiler'UTIL_TYPE, CaseExpr'equivMethod)
                (.ifZCmp gen, GeneratorAdapter/EQ, defaultLabel)
            )
        )
        (CaseExpr'emitExpr objx, gen, then, emitUnboxed)
        nil
    )

    (defn- #_"void" CaseExpr'emitExpr [#_"ObjExpr" objx, #_"GeneratorAdapter" gen, #_"Expr" expr, #_"boolean" emitUnboxed]
        (if (and emitUnboxed (§ instance? MaybePrimitiveExpr expr))
            (MaybePrimitiveExpr'''emitUnboxed (cast' MaybePrimitiveExpr expr), :Context'EXPRESSION, objx, gen)
            (Expr'''emit expr, :Context'EXPRESSION, objx, gen)
        )
        nil
    )
)

#_stateless
(class-ns Compiler (§ implements Opcodes)
    (§ def #_"Symbol" Compiler'DEF (Symbol'intern "def"))
    (§ def #_"Symbol" Compiler'LOOP (Symbol'intern "loop*"))
    (§ def #_"Symbol" Compiler'RECUR (Symbol'intern "recur"))
    (§ def #_"Symbol" Compiler'IF (Symbol'intern "if"))
    (§ def #_"Symbol" Compiler'LET (Symbol'intern "let*"))
    (§ def #_"Symbol" Compiler'LETFN (Symbol'intern "letfn*"))
    (§ def #_"Symbol" Compiler'DO (Symbol'intern "do"))
    (§ def #_"Symbol" Compiler'FN (Symbol'intern "fn*"))
    (§ def #_"Symbol" Compiler'FNONCE (cast' Symbol (IObj'''withMeta (Symbol'intern "fn*"), (RT'map (Keyword'intern (Symbol'intern nil, "once")), RT'T))))
    (§ def #_"Symbol" Compiler'QUOTE (Symbol'intern "quote"))
    (§ def #_"Symbol" Compiler'THE_VAR (Symbol'intern "var"))
    (§ def #_"Symbol" Compiler'DOT (Symbol'intern "."))
    (§ def #_"Symbol" Compiler'ASSIGN (Symbol'intern "set!"))
    (§ def #_"Symbol" Compiler'TRY (Symbol'intern "try"))
    (§ def #_"Symbol" Compiler'CATCH (Symbol'intern "catch"))
    (§ def #_"Symbol" Compiler'FINALLY (Symbol'intern "finally"))
    (§ def #_"Symbol" Compiler'THROW (Symbol'intern "throw"))
    (§ def #_"Symbol" Compiler'MONITOR_ENTER (Symbol'intern "monitor-enter"))
    (§ def #_"Symbol" Compiler'MONITOR_EXIT (Symbol'intern "monitor-exit"))
    (§ def #_"Symbol" Compiler'IMPORT (Symbol'intern "cloiure.core", "import*"))
    (§ def #_"Symbol" Compiler'DEFTYPE (Symbol'intern "deftype*"))
    (§ def #_"Symbol" Compiler'CASE (Symbol'intern "case*"))

    (§ def #_"Symbol" Compiler'CLASS (Symbol'intern "Class"))
    (§ def #_"Symbol" Compiler'NEW (Symbol'intern "new"))
    (§ def #_"Symbol" Compiler'THIS (Symbol'intern "this"))
    (§ def #_"Symbol" Compiler'REIFY (Symbol'intern "reify*"))
    (§ def #_"Symbol" Compiler'LIST (Symbol'intern "cloiure.core", "list"))
    (§ def #_"Symbol" Compiler'HASHMAP (Symbol'intern "cloiure.core", "hash-map"))
    (§ def #_"Symbol" Compiler'VECTOR (Symbol'intern "cloiure.core", "vector"))
    (§ def #_"Symbol" Compiler'IDENTITY (Symbol'intern "cloiure.core", "identity"))

    (§ def #_"Symbol" Compiler'_AMP_ (Symbol'intern "&"))
    (§ def #_"Symbol" Compiler'ISEQ (Symbol'intern "cloiure.lang.ISeq"))

    (§ def #_"Keyword" Compiler'loadNs (Keyword'intern (Symbol'intern nil, "load-ns")))
    (§ def #_"Keyword" Compiler'inlineKey (Keyword'intern (Symbol'intern nil, "inline")))
    (§ def #_"Keyword" Compiler'inlineAritiesKey (Keyword'intern (Symbol'intern nil, "inline-arities")))

    (§ def #_"Keyword" Compiler'volatileKey (Keyword'intern (Symbol'intern nil, "volatile")))
    (§ def #_"Keyword" Compiler'implementsKey (Keyword'intern (Symbol'intern nil, "implements")))
    (def #_"String" Compiler'COMPILE_STUB_PREFIX "compile__stub")

    (§ def #_"Keyword" Compiler'protocolKey (Keyword'intern (Symbol'intern nil, "protocol")))
    (§ def #_"Keyword" Compiler'onKey (Keyword'intern (Symbol'intern nil, "on")))
    (§ def #_"Keyword" Compiler'dynamicKey (Keyword'intern (Symbol'intern "dynamic")))
    (§ def #_"Keyword" Compiler'redefKey (Keyword'intern (Symbol'intern nil, "redef")))

    (§ def #_"Symbol" Compiler'NS (Symbol'intern "ns"))
    (§ def #_"Symbol" Compiler'IN_NS (Symbol'intern "in-ns"))

    (§ def #_"IPersistentMap" Compiler'specials (PersistentHashMap'create-1a
        (object-array [
            Compiler'DEF           (DefParser'new)
            Compiler'LOOP          (LetParser'new)
            Compiler'RECUR         (RecurParser'new)
            Compiler'IF            (IfParser'new)
            Compiler'CASE          (CaseParser'new)
            Compiler'LET           (LetParser'new)
            Compiler'LETFN         (LetFnParser'new)
            Compiler'DO            (BodyParser'new)
            Compiler'FN            nil
            Compiler'QUOTE         (ConstantParser'new)
            Compiler'THE_VAR       (TheVarParser'new)
            Compiler'IMPORT        (ImportParser'new)
            Compiler'DOT           (HostParser'new)
            Compiler'ASSIGN        (AssignParser'new)
            Compiler'DEFTYPE       (DeftypeParser'new)
            Compiler'REIFY         (ReifyParser'new)
            Compiler'TRY           (TryParser'new)
            Compiler'THROW         (ThrowParser'new)
            Compiler'MONITOR_ENTER (MonitorEnterParser'new)
            Compiler'MONITOR_EXIT  (MonitorExitParser'new)
            Compiler'CATCH         nil
            Compiler'FINALLY       nil
            Compiler'NEW           (NewParser'new)
            Compiler'_AMP_         nil
        ])
    ))

    (def- #_"int" Compiler'MAX_POSITIONAL_ARITY 20)

    (def #_"Type" Compiler'CLASS_TYPE (Type/getType Class))
    (def #_"Type" Compiler'OBJECT_TYPE (Type/getType Object))
    (def #_"Type" Compiler'BOOLEAN_OBJECT_TYPE (Type/getType Boolean))
    (def #_"Type" Compiler'THROWABLE_TYPE (Type/getType Throwable))

    (def- #_"Type" Compiler'KEYWORD_TYPE (§ unsure Type/getType (§ class Keyword)))
    (def- #_"Type" Compiler'VAR_TYPE (§ unsure Type/getType (§ class Var)))
    (def- #_"Type" Compiler'SYMBOL_TYPE (§ unsure Type/getType (§ class Symbol)))
    (def- #_"Type" Compiler'IFN_TYPE (§ unsure Type/getType (§ class IFn)))
    (def- #_"Type" Compiler'AFUNCTION_TYPE (§ unsure Type/getType (§ class AFunction)))
    (def- #_"Type" Compiler'RT_TYPE (§ unsure Type/getType (§ class RT)))
    (def- #_"Type" Compiler'NUMBERS_TYPE (§ unsure Type/getType (§ class Numbers)))

    (def #_"Type" Compiler'NS_TYPE (§ unsure Type/getType (§ class Namespace)))
    (def #_"Type" Compiler'UTIL_TYPE (§ unsure Type/getType (§ class Util)))
    (def #_"Type" Compiler'REFLECTOR_TYPE (§ unsure Type/getType (§ class Reflector)))
    (def #_"Type" Compiler'IPERSISTENTMAP_TYPE (§ unsure Type/getType (§ class IPersistentMap)))
    (def #_"Type" Compiler'IOBJ_TYPE (§ unsure Type/getType (§ class IObj)))
    (def #_"Type" Compiler'TUPLE_TYPE (§ unsure Type/getType (§ class Tuple)))

    (def #_"Method[]" Compiler'createTupleMethods
        (object-array [
            (Method/getMethod "cloiure.lang.IPersistentVector create()")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object)")
            (Method/getMethod "cloiure.lang.IPersistentVector create(Object, Object, Object, Object, Object, Object)")
        ])
    )

    (def- #_"Type[][]" Compiler'ARG_TYPES nil)
    (def- #_"Type[]" Compiler'EXCEPTION_TYPES (object-array 0))

    (§ static
        (§ ass Compiler'ARG_TYPES (§ new Type[(+ Compiler'MAX_POSITIONAL_ARITY 2)][]))
        (loop-when-recur [#_"int" i 0] (<= i Compiler'MAX_POSITIONAL_ARITY) [(inc i)]
            (let [#_"Type[]" a (make-array Type i)]
                (loop-when-recur [#_"int" j 0] (< j i) [(inc j)]
                    (aset a j Compiler'OBJECT_TYPE)
                )
                (aset Compiler'ARG_TYPES i a)
            )
        )
        (let [#_"Type[]" a (make-array Type (inc Compiler'MAX_POSITIONAL_ARITY))]
            (loop-when-recur [#_"int" j 0] (< j Compiler'MAX_POSITIONAL_ARITY) [(inc j)]
                (aset a j Compiler'OBJECT_TYPE)
            )
            (aset a Compiler'MAX_POSITIONAL_ARITY (Type/getType "[Ljava/lang/Object;"))
            (aset Compiler'ARG_TYPES (inc Compiler'MAX_POSITIONAL_ARITY) a)
        )
    )

    ;; symbol->localbinding
    (§ def #_"Var" Compiler'LOCAL_ENV (Var''setDynamic (Var'create nil)))

    ;; vector<localbinding>
    (§ def #_"Var" Compiler'LOOP_LOCALS (Var''setDynamic (Var'create)))

    ;; Label
    (§ def #_"Var" Compiler'LOOP_LABEL (Var''setDynamic (Var'create)))

    ;; vector<object>
    (§ def #_"Var" Compiler'CONSTANTS (Var''setDynamic (Var'create)))

    ;; IdentityHashMap
    (§ def #_"Var" Compiler'CONSTANT_IDS (Var''setDynamic (Var'create)))

    ;; vector<keyword>
    (§ def #_"Var" Compiler'KEYWORD_CALLSITES (Var''setDynamic (Var'create)))

    ;; vector<var>
    (§ def #_"Var" Compiler'PROTOCOL_CALLSITES (Var''setDynamic (Var'create)))

    ;; set<var>
    (§ def #_"Var" Compiler'VAR_CALLSITES (Var''setDynamic (Var'create)))

    ;; keyword->constid
    (§ def #_"Var" Compiler'KEYWORDS (Var''setDynamic (Var'create)))

    ;; var->constid
    (§ def #_"Var" Compiler'VARS (Var''setDynamic (Var'create)))

    ;; FnFrame
    (§ def #_"Var" Compiler'METHOD (Var''setDynamic (Var'create nil)))

    ;; nil or not
    (§ def #_"Var" Compiler'IN_CATCH_FINALLY (Var''setDynamic (Var'create nil)))

    (§ def #_"Var" Compiler'METHOD_RETURN_CONTEXT (Var''setDynamic (Var'create nil)))

    (§ def #_"Var" Compiler'NO_RECUR (Var''setDynamic (Var'create nil)))

    ;; DynamicClassLoader
    (§ def #_"Var" Compiler'LOADER (Var''setDynamic (Var'create)))

    (§ def #_"Var" Compiler'INSTANCE (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "instance?")))

    ;; Integer
    (§ def #_"Var" Compiler'LINE (Var''setDynamic (Var'create 0)))
    (§ def #_"Var" Compiler'COLUMN (Var''setDynamic (Var'create 0)))

    (defn #_"int" Compiler'lineDeref []
        (.intValue (cast Number (IDeref'''deref Compiler'LINE)))
    )

    (defn #_"int" Compiler'columnDeref []
        (.intValue (cast Number (IDeref'''deref Compiler'COLUMN)))
    )

    ;; Integer
    (§ def #_"Var" Compiler'NEXT_LOCAL_NUM (Var''setDynamic (Var'create 0)))

    ;; Integer
    (§ def #_"Var" Compiler'RET_LOCAL_NUM (Var''setDynamic (Var'create)))

    (§ def #_"Var" Compiler'COMPILE_STUB_SYM (Var''setDynamic (Var'create nil)))
    (§ def #_"Var" Compiler'COMPILE_STUB_CLASS (Var''setDynamic (Var'create nil)))

    ;; PathNode chain
    (§ def #_"Var" Compiler'CLEAR_PATH (Var''setDynamic (Var'create nil)))

    ;; tail of PathNode chain
    (§ def #_"Var" Compiler'CLEAR_ROOT (Var''setDynamic (Var'create nil)))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def #_"Var" Compiler'CLEAR_SITES (Var''setDynamic (Var'create nil)))

    (def #_"Class" Compiler'RECUR_CLASS (§ class Recur))

    (defn #_"boolean" Compiler'isSpecial [#_"Object" sym]
        (Associative'''containsKey Compiler'specials, sym)
    )

    (defn #_"boolean" Compiler'inTailCall [#_"Context" context]
        (and (= context :Context'RETURN) (some? (IDeref'''deref Compiler'METHOD_RETURN_CONTEXT)) (nil? (IDeref'''deref Compiler'IN_CATCH_FINALLY)))
    )

    (defn #_"Symbol" Compiler'resolveSymbol [#_"Symbol" sym]
        ;; already qualified or classname?
        (cond
            (pos? (.indexOf (:name sym), \.))
                sym
            (some? (:ns sym))
                (let [#_"Namespace" ns (Compiler'namespaceFor-1 sym)]
                    (if (and (some? ns) (not (and (some? (:name (:name ns))) (.equals (:name (:name ns)), (:ns sym)))))
                        (Symbol'intern (:name (:name ns)), (:name sym))
                        sym
                    )
                )
            :else
                (let [#_"Object" o (Namespace''getMapping (Compiler'currentNS), sym)]
                    (cond
                        (nil? o)            (Symbol'intern (:name (:name (Compiler'currentNS))), (:name sym))
                        (instance? Class o) (Symbol'intern nil, (.getName (cast Class o)))
                        (§ instance? Var o) (let [#_"Var" v (cast' Var o)] (Symbol'intern (:name (:name (:ns v))), (:name (:sym v))))
                    )
                )
        )
    )

    (defn #_"Class" Compiler'maybePrimitiveType [#_"Expr" e]
        (when (and (§ instance? MaybePrimitiveExpr e) (Expr'''hasJavaClass e) (MaybePrimitiveExpr'''canEmitPrimitive (cast' MaybePrimitiveExpr e)))
            (let [#_"Class" c (Expr'''getJavaClass e)]
                (when (Util'isPrimitive c)
                    c
                )
            )
        )
    )

    (defn #_"Class" Compiler'maybeJavaClass [#_"Collection<Expr>" exprs]
        (try
            (let [#_"Iterator" it (.iterator exprs)]
                (loop-when [#_"Class" match nil] (.hasNext it) => match
                    (let [#_"Expr" e (.next it)]
                        (cond
                            (§ instance? ThrowExpr e)
                                (recur match)
                            (Expr'''hasJavaClass e)
                                (let [#_"Class" c (Expr'''getJavaClass e)]
                                    (cond
                                        (nil? match) (recur c)
                                        (= match c) (recur match)
                                    )
                                )
                        )
                    )
                )
            )
            (catch Exception _
                nil
            )
        )
    )

    (§ def #_"NilExpr" Compiler'NIL_EXPR (NilExpr'new))

    (§ def #_"BooleanExpr" Compiler'TRUE_EXPR (BooleanExpr'new true))
    (§ def #_"BooleanExpr" Compiler'FALSE_EXPR (BooleanExpr'new false))

    (defn #_"boolean" Compiler'subsumes [#_"Class[]" c1, #_"Class[]" c2]
        ;; presumes matching lengths
        (loop-when [#_"boolean" better false #_"int" i 0] (< i (alength c1)) => better
            (when-not (= (aget c1 i) (aget c2 i)) => (recur better (inc i))
                (and (or (and (not (.isPrimitive (aget c1 i))) (.isPrimitive (aget c2 i))) (.isAssignableFrom (aget c2 i), (aget c1 i)))
                    (recur true (inc i))
                )
            )
        )
    )

    (defn #_"String" Compiler'getTypeStringForArgs [#_"IPersistentVector" args]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (dotimes [#_"int" i (.count args)]
                (let [#_"Expr" arg (cast' Expr (Indexed'''nth-2 args, i))]
                    (when (pos? i)
                        (.append sb, ", ")
                    )
                    (.append sb, (if (and (Expr'''hasJavaClass arg) (some? (Expr'''getJavaClass arg))) (.getName (Expr'''getJavaClass arg)) "unknown"))
                )
            )
            (.toString sb)
        )
    )

    (defn #_"int" Compiler'getMatchingParams [#_"String" methodName, #_"ArrayList<Class[]>" pars, #_"IPersistentVector" args, #_"List<Class>" rets]
        ;; presumes matching lengths
        (let [[#_"int" matchIdx #_"boolean" tied]
                (loop-when [matchIdx -1 tied false #_"boolean" foundExact false #_"int" i 0] (< i (.size pars)) => [matchIdx tied]
                    (let [[#_"int" exact #_"boolean" match]
                            (loop-when [exact 0 match true #_"int" p 0 #_"ISeq" s (Seqable'''seq args)] (and match (< p (.count args)) (some? s)) => [exact match]
                                (let [#_"Expr" arg (cast' Expr (.first s))
                                      #_"Class" aclass (if (Expr'''hasJavaClass arg) (Expr'''getJavaClass arg) Object) #_"Class" pclass (aget (.get pars, i) p)
                                      [exact match]
                                        (if (and (Expr'''hasJavaClass arg) (= aclass pclass))
                                            [(inc exact) match]
                                            [exact (Reflector'paramArgTypeMatch pclass, aclass)]
                                        )]
                                    (recur exact match (inc p) (.next s))
                                )
                            )
                          [matchIdx tied foundExact]
                            (cond (= exact (.count args))
                                (let [matchIdx
                                        (when (or (not foundExact) (= matchIdx -1) (.isAssignableFrom (.get rets, matchIdx), (.get rets, i))) => matchIdx
                                            i
                                        )]
                                    [matchIdx false true]
                                )
                                (and match (not foundExact))
                                (let [[matchIdx tied]
                                        (cond (= matchIdx -1)
                                            (do
                                                [i tied]
                                            )
                                            (Compiler'subsumes (.get pars, i), (.get pars, matchIdx))
                                            (do
                                                [i false]
                                            )
                                            (Arrays/equals (.get pars, matchIdx), (.get pars, i))
                                            (let [matchIdx
                                                    (when (.isAssignableFrom (.get rets, matchIdx), (.get rets, i)) => matchIdx
                                                        i
                                                    )]
                                                [matchIdx tied]
                                            )
                                            (not (Compiler'subsumes (.get pars, matchIdx), (.get pars, i)))
                                            (do
                                                [matchIdx true]
                                            )
                                            :else
                                            (do
                                                [matchIdx tied]
                                            )
                                        )]
                                    [matchIdx tied foundExact]
                                )
                                :else
                                (do
                                    [matchIdx tied foundExact]
                                )
                            )]
                        (recur matchIdx tied foundExact (inc i))
                    )
                )]
            (when tied
                (throw (IllegalArgumentException. (str "More than one matching method found: " methodName)))
            )
            matchIdx
        )
    )

    (§ def #_"IPersistentMap" Compiler'CHAR_MAP (PersistentHashMap'create-1a
        (object-array [
            \- "_"
            \: "_COLON_"
            \+ "_PLUS_"
            \> "_GT_"
            \< "_LT_"
            \= "_EQ_"
            \~ "_TILDE_"
            \! "_BANG_"
            \@ "_CIRCA_"
            \# "_SHARP_"
            \' "_SINGLEQUOTE_"
            \" "_DOUBLEQUOTE_" ;; oops! "
            \% "_PERCENT_"
            \^ "_CARET_"
            \& "_AMPERSAND_"
            \* "_STAR_"
            \| "_BAR_"
            \{ "_LBRACE_"
            \} "_RBRACE_"
            \[ "_LBRACK_"
            \] "_RBRACK_"
            \/ "_SLASH_"
            \\ "_BSLASH_"
            \? "_QMARK_"
        ])
    ))

    (def #_"IPersistentMap" Compiler'DEMUNGE_MAP nil)
    (def #_"Pattern" Compiler'DEMUNGE_PATTERN nil)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite direction that CHAR_MAP does, plus it maps "$" to '/'.
        (let [#_"IPersistentMap" m
                (loop-when [m (RT'map "$", \/) #_"ISeq" s (RT'seq Compiler'CHAR_MAP)] (some? s) => m
                    (let [#_"IMapEntry" e (cast' IMapEntry (.first s))]
                        (recur (IPersistentMap'''assoc m, (cast String (IMapEntry'''val e)), (cast Character (IMapEntry'''key e))) (.next s))
                    )
                )]
            (§ ass Compiler'DEMUNGE_MAP m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_" returns "_", but #"_COLON_|_" "_COLON_"
            ;; returns "_COLON_" as desired. Sorting string keys of DEMUNGE_MAP from longest to shortest ensures
            ;; correct matching behavior, even if some strings are prefixes of others.
            (let [#_"Object[]" a (RT'toArray (RT'keys m))]
                (Arrays/sort a,
                    (§ reify Comparator()
                        #_foreign
                        (§ defn #_"int" compare [#_"Comparator" this, #_"Object" s1, #_"Object" s2]
                            (- (.length (cast String s2)) (.length (cast String s1)))
                        )
                    )
                )
                (let [#_"StringBuilder" sb (StringBuilder.)]
                    (dotimes [#_"int" i (alength a)]
                        (when (pos? i)
                            (.append sb, "|")
                        )
                        (.append sb, "\\Q")
                        (.append sb, (cast String (aget a i)))
                        (.append sb, "\\E")
                    )
                    (§ ass Compiler'DEMUNGE_PATTERN (Pattern/compile (.toString sb)))
                )
            )
        )
    )

    (defn #_"String" Compiler'munge [#_"String" name]
        (let [#_"StringBuilder" sb (StringBuilder.)]
            (doseq [#_"char" c (.toCharArray name)]
                (.append sb, (or (cast String (ILookup'''valAt-2 Compiler'CHAR_MAP, c)) c))
            )
            (.toString sb)
        )
    )

    (defn #_"String" Compiler'demunge [#_"String" mungedName]
        (let [#_"StringBuilder" sb (StringBuilder.)
              #_"Matcher" m (.matcher Compiler'DEMUNGE_PATTERN, mungedName)
              #_"int" lastMatchEnd
                (loop-when [lastMatchEnd 0] (.find m) => lastMatchEnd
                    (let [#_"int" start (.start m) #_"int" end (.end m)]
                        ;; keep everything before the match
                        (.append sb, (.substring mungedName, lastMatchEnd, start))
                        ;; replace the match with DEMUNGE_MAP result
                        (.append sb, (cast Character (ILookup'''valAt-2 Compiler'DEMUNGE_MAP, (.group m))))
                        (recur end)
                    )
                )]
            ;; keep everything after the last match
            (.append sb, (.substring mungedName, lastMatchEnd))
            (.toString sb)
        )
    )

    (defn #_"PathNode" Compiler'clearPathRoot []
        (cast' PathNode (Var''get Compiler'CLEAR_ROOT))
    )

    (defn- #_"LocalBinding" Compiler'registerLocal [#_"Symbol" sym, #_"Symbol" tag, #_"Expr" init, #_"boolean" isArg]
        (let [#_"int" n (Compiler'getAndIncLocalNum)
              #_"LocalBinding" lb (LocalBinding'new n, sym, tag, init, isArg, (Compiler'clearPathRoot))]
            (Var''set Compiler'LOCAL_ENV, (RT'assoc (cast' IPersistentMap (IDeref'''deref Compiler'LOCAL_ENV)), (:sym lb), lb))
            (let [#_"ObjMethod" method (cast' ObjMethod (IDeref'''deref Compiler'METHOD))]
                (§ ass (:locals method) (cast' IPersistentMap (RT'assoc (:locals method), lb, lb)))
                (§ ass (:indexlocals method) (cast' IPersistentMap (RT'assoc (:indexlocals method), n, lb)))
                lb
            )
        )
    )

    (defn- #_"int" Compiler'getAndIncLocalNum []
        (let [#_"int" n (.intValue (cast Number (IDeref'''deref Compiler'NEXT_LOCAL_NUM)))
              #_"ObjMethod" m (cast' ObjMethod (IDeref'''deref Compiler'METHOD))]
            (when (< (:maxLocal m) n)
                (§ ass (:maxLocal m) n)
            )
            (Var''set Compiler'NEXT_LOCAL_NUM, (inc n))
            n
        )
    )

    (defn #_"Expr" Compiler'analyze-2 [#_"Context" context, #_"Object" form]
        (Compiler'analyze-3 context, form, nil)
    )

    (defn- #_"Expr" Compiler'analyze-3 [#_"Context" context, #_"Object" form, #_"String" name]
        ;; todo symbol macro expansion?
        (try
            (let [form
                    (when (§ instance? LazySeq form) => form
                        (IObj'''withMeta (cast' IObj (or (RT'seq form) PersistentList'EMPTY)), (RT'meta form))
                    )]
                (cond
                    (nil? form)            Compiler'NIL_EXPR
                    (= form Boolean/TRUE)  Compiler'TRUE_EXPR
                    (= form Boolean/FALSE) Compiler'FALSE_EXPR
                    :else
                        (let [#_"Class" c (.getClass form)]
                            (cond
                                (= c (§ class Symbol))               (Compiler'analyzeSymbol (cast' Symbol form))
                                (= c (§ class Keyword))              (Compiler'registerKeyword (cast' Keyword form))
                                (instance? Number form)              (NumberExpr'parse (cast Number form))
                                (= c String)                         (StringExpr'new (.intern (cast String form)))
                                (and (§ instance? IPersistentCollection form) (not (§ instance? IRecord form)) (not (§ instance? IType form)) (zero? (.count (cast' IPersistentCollection form))))
                                    (let-when [#_"Expr" e (EmptyExpr'new form)] (some? (RT'meta form)) => e
                                        (MetaExpr'new e, (MapExpr'parse (if (= context :Context'EVAL) context :Context'EXPRESSION), (IMeta'''meta (cast' IObj form))))
                                    )
                                (§ instance? ISeq form)              (Compiler'analyzeSeq context, (cast' ISeq form), name)
                                (§ instance? IPersistentVector form) (VectorExpr'parse context, (cast' IPersistentVector form))
                                (§ instance? IRecord form)           (ConstantExpr'new form)
                                (§ instance? IType form)             (ConstantExpr'new form)
                                (§ instance? IPersistentMap form)    (MapExpr'parse context, (cast' IPersistentMap form))
                                (§ instance? IPersistentSet form)    (SetExpr'parse context, (cast' IPersistentSet form))
                                :else                                (ConstantExpr'new form)
                            )
                        )
                )
            )
            (catch Throwable e
                (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e)))
            )
        )
    )

    (defn #_"Var" Compiler'isMacro [#_"Object" op]
        ;; no local macros for now
        (when-not (and (§ instance? Symbol op) (some? (Compiler'referenceLocal (cast' Symbol op))))
            (when (or (§ instance? Symbol op) (§ instance? Var op))
                (let [#_"Var" v (if (§ instance? Var op) (cast' Var op) (Compiler'lookupVar-3 (cast' Symbol op), false, false))]
                    (when (and (some? v) (Var''isMacro v))
                        (when (or (= (:ns v) (Compiler'currentNS)) (Var''isPublic v)) => (throw (IllegalStateException. (str "var: " v " is not public")))
                            v
                        )
                    )
                )
            )
        )
    )

    (defn #_"IFn" Compiler'isInline [#_"Object" op, #_"int" arity]
        ;; no local inlines for now
        (when-not (and (§ instance? Symbol op) (some? (Compiler'referenceLocal (cast' Symbol op))))
            (when (or (§ instance? Symbol op) (§ instance? Var op))
                (when-let [#_"Var" v (if (§ instance? Var op) (cast' Var op) (Compiler'lookupVar-2 (cast' Symbol op), false))]
                    (when (or (= (:ns v) (Compiler'currentNS)) (Var''isPublic v)) => (throw (IllegalStateException. (str "var: " v " is not public")))
                        (when-let [#_"IFn" f (cast' IFn (RT'get-2 (IMeta'''meta v), Compiler'inlineKey))]
                            (let [#_"IFn" arityPred (cast' IFn (RT'get-2 (IMeta'''meta v), Compiler'inlineAritiesKey))]
                                (when (or (nil? arityPred) (RT'booleanCast-1o (IFn'''invoke-2 arityPred, arity)))
                                    f
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean" Compiler'namesStaticMember [#_"Symbol" sym]
        (and (some? (:ns sym)) (nil? (Compiler'namespaceFor-1 sym)))
    )

    (defn #_"Object" Compiler'preserveTag [#_"ISeq" src, #_"Object" dst]
        (let-when [#_"Symbol" tag (Compiler'tagOf src)] (and (some? tag) (§ instance? IObj dst)) => dst
            (IObj'''withMeta (cast' IObj dst), (cast' IPersistentMap (RT'assoc (RT'meta dst), RT'TAG_KEY, tag)))
        )
    )

    #_volatile
    (def- #_"Var" Compiler'MACRO_CHECK nil)
    #_volatile
    (def- #_"boolean" Compiler'MACRO_CHECK_LOADING false)
    (def- #_"Object" Compiler'MACRO_CHECK_LOCK (Object.))

    (defn- #_"Var" Compiler'ensureMacroCheck [] #_(§ throws ClassNotFoundException, IOException)
        (or Compiler'MACRO_CHECK
            (§ sync Compiler'MACRO_CHECK_LOCK
                (or Compiler'MACRO_CHECK
                    (do
                        (§ ass Compiler'MACRO_CHECK_LOADING true)
                        (RT'load-1 "cloiure/spec/alpha")
                        (RT'load-1 "cloiure/core/specs/alpha")
                        (§ ass Compiler'MACRO_CHECK (Var'find (Symbol'intern "cloiure.spec.alpha", "macroexpand-check")))
                        (§ ass Compiler'MACRO_CHECK_LOADING false)
                        Compiler'MACRO_CHECK
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'checkSpecs [#_"Var" v, #_"ISeq" form]
        (when (and RT'CHECK_SPECS (not Compiler'MACRO_CHECK_LOADING))
            (try
                (IFn'''applyTo (Compiler'ensureMacroCheck), (RT'cons v, (RT'list-1 (.next form))))
                (catch Exception e
                    (throw (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e))
                )
            )
        )
        nil
    )

    (defn #_"Object" Compiler'macroexpand1 [#_"Object" x]
        (when (§ instance? ISeq x) => x
            (let [#_"ISeq" form (cast' ISeq x) #_"Object" op (RT'first form)]
                (when-not (Compiler'isSpecial op) => x
                    ;; macro expansion
                    (let [#_"Var" v (Compiler'isMacro op)]
                        (if (some? v)
                            (do
                                (Compiler'checkSpecs v, form)
                                (try
                                    (IFn'''applyTo v, (RT'cons form, (RT'cons (Var''get Compiler'LOCAL_ENV), (.next form))))
                                    (§ catch ArityException e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ArityException'new-2 (- (:actual e) 2), (:name e)))
                                    )
                                )
                            )
                            (when (§ instance? Symbol op) => x
                                (let [#_"Symbol" sym (cast' Symbol op) #_"String" sname (:name sym)]
                                    ;; (.substring s 2 5) => (. s substring 2 5)
                                    (cond
                                        (= (.charAt (:name sym), 0) \.)
                                            (when (< 1 (RT'length form)) => (throw (IllegalArgumentException. "Malformed member expression, expecting (.member target ...)"))
                                                (let [#_"Symbol" meth (Symbol'intern (.substring sname, 1))
                                                      #_"Object" target (RT'second form)
                                                      target
                                                        (when (some? (HostExpr'maybeClass target, false)) => target
                                                            (IObj'''withMeta (cast' IObj (RT'list-2 Compiler'IDENTITY, target)), (RT'map RT'TAG_KEY, Compiler'CLASS))
                                                        )]
                                                    (Compiler'preserveTag form, (RT'listStar-4 Compiler'DOT, target, meth, (.next (.next form))))
                                                )
                                            )
                                        (Compiler'namesStaticMember sym)
                                            (let-when [#_"Symbol" target (Symbol'intern (:ns sym))] (some? (HostExpr'maybeClass target, false)) => x
                                                (let [#_"Symbol" meth (Symbol'intern (:name sym))]
                                                    (Compiler'preserveTag form, (RT'listStar-4 Compiler'DOT, target, meth, (.next form)))
                                                )
                                            )
                                        :else
                                            ;; (s.substring ...) => (. s substring ...)
                                            ;; (package.class.name ...) => (. package.class name ...)
                                            ;; (StringBuilder. ...) => (new StringBuilder ...)
                                            (let-when [#_"int" i (.lastIndexOf sname, \.)] (= i (dec (.length sname))) => x
                                                (RT'listStar-3 Compiler'NEW, (Symbol'intern (.substring sname, 0, i)), (.next form))
                                            )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Compiler'macroexpand [#_"Object" form]
        (let [#_"Object" f (Compiler'macroexpand1 form)]
            (if (= f form) form (recur f))
        )
    )

    (defn- #_"Expr" Compiler'analyzeSeq [#_"Context" context, #_"ISeq" form, #_"String" name]
        (let [#_"IPersistentMap" meta (RT'meta form)
              #_"Object" line   (if (and (some? meta) (Associative'''containsKey meta, RT'LINE_KEY))   (ILookup'''valAt-2 meta, RT'LINE_KEY)   (Compiler'lineDeref))
              #_"Object" column (if (and (some? meta) (Associative'''containsKey meta, RT'COLUMN_KEY)) (ILookup'''valAt-2 meta, RT'COLUMN_KEY) (Compiler'columnDeref))]
            (Var'pushThreadBindings (RT'map Compiler'LINE, line, Compiler'COLUMN, column))
            (try
                (let-when [#_"Object" me (Compiler'macroexpand1 form)] (= me form) => (Compiler'analyze-3 context, me, name)
                    (let-when [#_"Object" op (RT'first form)] (some? op) => (throw (IllegalArgumentException. (str "Can't call nil, form: " form)))
                        (let [#_"IFn" inline (Compiler'isInline op, (RT'count (RT'next form)))]
                            (cond
                                (some? inline)
                                    (Compiler'analyze-2 context, (Compiler'preserveTag form, (IFn'''applyTo inline, (RT'next form))))
                                (.equals op, Compiler'FN)
                                    (FnExpr'parse context, form, name)
                                :else
                                    (let [#_"IParser" p (cast' IParser (ILookup'''valAt-2 Compiler'specials, op))]
                                        (if (some? p)
                                            (IParser'''parse p, context, form)
                                            (InvokeExpr'parse context, form)
                                        )
                                    )
                            )
                        )
                    )
                )
                (catch Throwable e
                    (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new (Compiler'lineDeref), (Compiler'columnDeref), e)))
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"Object" Compiler'eval-1 [#_"Object" form]
        (Compiler'eval-2 form, true)
    )

    (defn #_"Object" Compiler'eval-2 [#_"Object" form, #_"boolean" freshLoader]
        (Var'pushThreadBindings (RT'map Compiler'LOADER, (RT'makeClassLoader)))
        (try
            (let [#_"IPersistentMap" meta (RT'meta form)
                  #_"Object" line   (if (and (some? meta) (Associative'''containsKey meta, RT'LINE_KEY))   (ILookup'''valAt-2 meta, RT'LINE_KEY)   (Compiler'lineDeref))
                  #_"Object" column (if (and (some? meta) (Associative'''containsKey meta, RT'COLUMN_KEY)) (ILookup'''valAt-2 meta, RT'COLUMN_KEY) (Compiler'columnDeref))]
                (Var'pushThreadBindings (RT'map Compiler'LINE, line, Compiler'COLUMN, column))
                (try
                    (let [form (Compiler'macroexpand form)]
                        (cond
                            (and (§ instance? ISeq form) (Util'equals (RT'first form), Compiler'DO))
                                (loop-when-recur [#_"ISeq" s (RT'next form)] (some? (RT'next s)) [(RT'next s)] => (Compiler'eval-2 (RT'first s), false)
                                    (Compiler'eval-2 (RT'first s), false)
                                )
                            (or (§ instance? IType form) (and (§ instance? IPersistentCollection form) (not (and (§ instance? Symbol (RT'first form)) (.startsWith (:name (cast' Symbol (RT'first form))), "def")))))
                                (let [#_"ObjExpr" fexpr (cast' ObjExpr (Compiler'analyze-3 :Context'EXPRESSION, (RT'list-3 Compiler'FN, PersistentVector'EMPTY, form), (str "eval" (RT'nextID))))
                                      #_"IFn" fn (cast' IFn (Expr'''eval fexpr))]
                                    (IFn'''invoke-1 fn)
                                )
                            :else
                                (let [#_"Expr" expr (Compiler'analyze-2 :Context'EVAL, form)]
                                    (Expr'''eval expr)
                                )
                        )
                    )
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
            (finally
                (Var'popThreadBindings)
            )
        )
    )

    (defn- #_"int" Compiler'registerConstant [#_"Object" o]
        (when (Var''isBound Compiler'CONSTANTS) => -1
            (let [#_"PersistentVector" v (cast' PersistentVector (IDeref'''deref Compiler'CONSTANTS))
                  #_"IdentityHashMap<Object, Integer>" ids (cast IdentityHashMap #_"<Object, Integer>" (IDeref'''deref Compiler'CONSTANT_IDS))]
                (or (.get ids, o)
                    (do
                        (Var''set Compiler'CONSTANTS, (RT'conj v, o))
                        (.put ids, o, (.count v))
                        (.count v)
                    )
                )
            )
        )
    )

    (defn- #_"KeywordExpr" Compiler'registerKeyword [#_"Keyword" keyword]
        (when (Var''isBound Compiler'KEYWORDS) => (KeywordExpr'new keyword)
            (let [#_"IPersistentMap" keywordsMap (cast' IPersistentMap (IDeref'''deref Compiler'KEYWORDS))
                  #_"Object" id (RT'get-2 keywordsMap, keyword)]
                (when (nil? id)
                    (Var''set Compiler'KEYWORDS, (RT'assoc keywordsMap, keyword, (Compiler'registerConstant keyword)))
                )
                (KeywordExpr'new keyword)
            )
        )
    )

    (defn- #_"int" Compiler'registerKeywordCallsite [#_"Keyword" keyword]
        (when (Var''isBound Compiler'KEYWORD_CALLSITES) => (throw (IllegalAccessError. "KEYWORD_CALLSITES is not bound"))
            (let [#_"IPersistentVector" callsites (-> (cast' IPersistentVector (IDeref'''deref Compiler'KEYWORD_CALLSITES)) (IPersistentVector'''cons keyword))]
                (Var''set Compiler'KEYWORD_CALLSITES, callsites)
                (dec (.count callsites))
            )
        )
    )

    (defn- #_"int" Compiler'registerProtocolCallsite [#_"Var" v]
        (when (Var''isBound Compiler'PROTOCOL_CALLSITES) => (throw (IllegalAccessError. "PROTOCOL_CALLSITES is not bound"))
            (let [#_"IPersistentVector" callsites (-> (cast' IPersistentVector (IDeref'''deref Compiler'PROTOCOL_CALLSITES)) (IPersistentVector'''cons v))]
                (Var''set Compiler'PROTOCOL_CALLSITES, callsites)
                (dec (.count callsites))
            )
        )
    )

    (defn- #_"void" Compiler'registerVarCallsite [#_"Var" v]
        (when (Var''isBound Compiler'VAR_CALLSITES) => (throw (IllegalAccessError. "VAR_CALLSITES is not bound"))
            (let [#_"IPersistentCollection" callsites (-> (cast' IPersistentCollection (IDeref'''deref Compiler'VAR_CALLSITES)) (IPersistentCollection'''cons v))]
                (Var''set Compiler'VAR_CALLSITES, callsites)
            )
        )
        nil
    )

    (defn #_"ISeq" Compiler'fwdPath [#_"PathNode" p]
        (loop-when-recur [#_"ISeq" s nil p p] (some? p) [(RT'cons p, s) (:parent p)] => s)
    )

    (defn #_"PathNode" Compiler'commonPath [#_"PathNode" p1, #_"PathNode" p2]
        (let [#_"ISeq" s1 (Compiler'fwdPath p1) #_"ISeq" s2 (Compiler'fwdPath p2)]
            (when (= (RT'first s1) (RT'first s2))
                (loop-when-recur [s1 s1 s2 s2]
                                 (and (some? (RT'second s1)) (= (RT'second s1) (RT'second s2)))
                                 [(.next s1) (.next s2)]
                              => (cast' PathNode (RT'first s1))
                )
            )
        )
    )

    (defn- #_"Expr" Compiler'analyzeSymbol [#_"Symbol" sym]
        (let [#_"Symbol" tag (Compiler'tagOf sym)]
            (or
                (cond
                    (nil? (:ns sym)) ;; ns-qualified syms are always Vars
                        (when-let [#_"LocalBinding" b (Compiler'referenceLocal sym)]
                            (LocalBindingExpr'new b, tag)
                        )
                    (nil? (Compiler'namespaceFor-1 sym))
                        (when-let [#_"Class" c (HostExpr'maybeClass (Symbol'intern (:ns sym)), false)]
                            (if (some? (Reflector'getField c, (:name sym), true))
                                (StaticFieldExpr'new (Compiler'lineDeref), (Compiler'columnDeref), c, (:name sym), tag)
                                (throw (RuntimeException. (str "Unable to find static field: " (:name sym) " in " c)))
                            )
                        )
                )
                (let [#_"Object" o (Compiler'resolve-1 sym)]
                    (cond
                        (§ instance? Var o)
                            (let-when [#_"Var" v (cast' Var o)] (nil? (Compiler'isMacro v)) => (throw (RuntimeException. (str "Can't take value of a macro: " v)))
                                (Compiler'registerVar v)
                                (VarExpr'new v, tag)
                            )
                        (instance? Class o)
                            (ConstantExpr'new o)
                        (§ instance? Symbol o)
                            (UnresolvedVarExpr'new (cast' Symbol o))
                        :else
                            (throw (RuntimeException. (str "Unable to resolve symbol: " sym " in this context")))
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'destubClassName [#_"String" name]
        ;; skip over prefix + '.' or '/'
        (if (.startsWith name, Compiler'COMPILE_STUB_PREFIX)
            (.substring name, (inc (.length Compiler'COMPILE_STUB_PREFIX)))
            name
        )
    )

    (defn #_"Type" Compiler'getType [#_"Class" c]
        (let [#_"String" desc (.getDescriptor (Type/getType c))
              desc
                (when (.startsWith desc, "L") => desc
                    (str "L" (Compiler'destubClassName (.substring desc, 1)))
                )]
            (§ unsure Type/getType desc)
        )
    )

    (defn #_"Object" Compiler'resolve-2 [#_"Symbol" sym, #_"boolean" allowPrivate]
        (Compiler'resolveIn (Compiler'currentNS), sym, allowPrivate)
    )

    (defn #_"Object" Compiler'resolve-1 [#_"Symbol" sym]
        (Compiler'resolveIn (Compiler'currentNS), sym, false)
    )

    (defn #_"Namespace" Compiler'namespaceFor-1 [#_"Symbol" sym]
        (Compiler'namespaceFor-2 (Compiler'currentNS), sym)
    )

    (defn #_"Namespace" Compiler'namespaceFor-2 [#_"Namespace" inns, #_"Symbol" sym]
        ;; note, presumes non-nil sym.ns
        (let [#_"Symbol" nsSym (Symbol'intern (:ns sym))]
            ;; first check against currentNS' aliases, otherwise check the Namespaces map
            (or (Namespace''lookupAlias inns, nsSym) (Namespace'find nsSym))
        )
    )

    (defn #_"Object" Compiler'resolveIn [#_"Namespace" n, #_"Symbol" sym, #_"boolean" allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond
            (some? (:ns sym))
                (let-when [#_"Namespace" ns (Compiler'namespaceFor-2 n, sym)] (some? ns)               => (throw (RuntimeException. (str "No such namespace: " (:ns sym))))
                    (let-when [#_"Var" v (Namespace''findInternedVar ns, (Symbol'intern (:name sym)))] (some? v) => (throw (RuntimeException. (str "No such var: " sym)))
                        (when (or (= (:ns v) (Compiler'currentNS)) (Var''isPublic v) allowPrivate)         => (throw (IllegalStateException. (str "var: " sym " is not public")))
                            v
                        )
                    )
                )
            (or (pos? (.indexOf (:name sym), \.)) (= (.charAt (:name sym), 0) \[)) (RT'classForName-1 (:name sym))
            (.equals sym, Compiler'NS)                                             RT'NS_VAR
            (.equals sym, Compiler'IN_NS)                                          RT'IN_NS_VAR
            (Util'equals sym, (Var''get Compiler'COMPILE_STUB_SYM))                    (Var''get Compiler'COMPILE_STUB_CLASS)
            :else
                (or (Namespace''getMapping n, sym)
                    (when (RT'booleanCast-1o (IDeref'''deref RT'ALLOW_UNRESOLVED_VARS)) => (throw (RuntimeException. (str "Unable to resolve symbol: " sym " in this context")))
                        sym
                    )
                )
        )
    )

    (defn #_"Object" Compiler'maybeResolveIn [#_"Namespace" n, #_"Symbol" sym]
        ;; note - ns-qualified vars must already exist
        (cond
            (some? (:ns sym))
                (when-let [#_"Namespace" ns (Compiler'namespaceFor-2 n, sym)]
                    (when-let [#_"Var" v (Namespace''findInternedVar ns, (Symbol'intern (:name sym)))]
                        v
                    )
                )
            (or (and (pos? (.indexOf (:name sym), \.)) (not (.endsWith (:name sym), "."))) (= (.charAt (:name sym), 0) \[))
                (RT'classForName-1 (:name sym))
            (.equals sym, Compiler'NS)
                RT'NS_VAR
            (.equals sym, Compiler'IN_NS)
                RT'IN_NS_VAR
            :else
                (Namespace''getMapping n, sym)
        )
    )

    (defn #_"Var" Compiler'lookupVar-3 [#_"Symbol" sym, #_"boolean" internNew, #_"boolean" registerMacro]
        ;; note - ns-qualified vars in other namespaces must already exist
        (let [#_"Var" var
                (cond
                    (some? (:ns sym))
                        (when-let [#_"Namespace" ns (Compiler'namespaceFor-1 sym)]
                            (let [#_"Symbol" name (Symbol'intern (:name sym))]
                                (if (and internNew (= ns (Compiler'currentNS)))
                                    (Namespace''intern ns, name)
                                    (Namespace''findInternedVar ns, name)
                                )
                            )
                        )
                    (.equals sym, Compiler'NS)    RT'NS_VAR
                    (.equals sym, Compiler'IN_NS) RT'IN_NS_VAR
                    :else ;; is it mapped?
                        (let [#_"Object" o (Namespace''getMapping (Compiler'currentNS), sym)]
                            (cond
                                (nil? o) ;; introduce a new var in the current ns
                                    (when internNew
                                        (Namespace''intern (Compiler'currentNS), (Symbol'intern (:name sym)))
                                    )
                                (§ instance? Var o)
                                    (cast' Var o)
                                :else
                                    (throw (RuntimeException. (str "Expecting var, but " sym " is mapped to " o)))
                            )
                        )
                )]
            (when (and (some? var) (or (not (Var''isMacro var)) registerMacro))
                (Compiler'registerVar var)
            )
            var
        )
    )

    (defn #_"Var" Compiler'lookupVar-2 [#_"Symbol" sym, #_"boolean" internNew]
        (Compiler'lookupVar-3 sym, internNew, true)
    )

    (defn- #_"void" Compiler'registerVar [#_"Var" var]
        (when (Var''isBound Compiler'VARS)
            (let [#_"IPersistentMap" m (cast' IPersistentMap (IDeref'''deref Compiler'VARS))]
                (let-when [#_"Object" id (RT'get-2 m, var)] (nil? id)
                    (Var''set Compiler'VARS, (RT'assoc m, var, (Compiler'registerConstant var)))
                )
            )
        )
        nil
    )

    (defn #_"Namespace" Compiler'currentNS []
        (cast' Namespace (IDeref'''deref RT'CURRENT_NS))
    )

    (defn #_"void" Compiler'closeOver [#_"LocalBinding" b, #_"ObjMethod" method]
        (when (and (some? b) (some? method))
            (let [#_"LocalBinding" lb (cast' LocalBinding (RT'get-2 (:locals method), b))]
                (if (nil? lb)
                    (do
                        (§ ass (:closes (:objx method)) (cast' IPersistentMap (RT'assoc (:closes (:objx method)), b, b)))
                        (Compiler'closeOver b, (:parent method))
                    )
                    (do
                        (when (zero? (:idx lb))
                            (§ ass (:usesThis method) true)
                        )
                        (when (some? (IDeref'''deref Compiler'IN_CATCH_FINALLY))
                            (§ ass (:localsUsedInCatchFinally method) (cast' PersistentHashSet (IPersistentCollection'''cons (:localsUsedInCatchFinally method), (:idx b))))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"LocalBinding" Compiler'referenceLocal [#_"Symbol" sym]
        (when (Var''isBound Compiler'LOCAL_ENV)
            (when-let [#_"LocalBinding" b (cast' LocalBinding (RT'get-2 (IDeref'''deref Compiler'LOCAL_ENV), sym))]
                (let [#_"ObjMethod" method (cast' ObjMethod (IDeref'''deref Compiler'METHOD))]
                    (when (zero? (:idx b))
                        (§ ass (:usesThis method) true)
                    )
                    (Compiler'closeOver b, method)
                    b
                )
            )
        )
    )

    (defn- #_"Symbol" Compiler'tagOf [#_"Object" o]
        (let [#_"Object" tag (RT'get-2 (RT'meta o), RT'TAG_KEY)]
            (cond
                (§ instance? Symbol tag) (cast' Symbol tag)
                (instance? String tag)   (Symbol'intern nil, (cast String tag))
            )
        )
    )

    (defn #_"void" Compiler'consumeWhitespaces [#_"LineNumberingPushbackReader" pushbackReader]
        (loop-when-recur [#_"int" ch (LispReader'read1 pushbackReader)]
                         (LispReader'isWhitespace ch)
                         [(LispReader'read1 pushbackReader)]
                      => (LispReader'unread pushbackReader, ch)
        )
        nil
    )

    (defn #_"Object" Compiler'load [#_"Reader" reader]
        (let [#_"LineNumberingPushbackReader" r
                (if (§ instance? LineNumberingPushbackReader reader) (cast' LineNumberingPushbackReader reader) (LineNumberingPushbackReader'new-1 reader))]
            (Var'pushThreadBindings (RT'mapUniqueKeys
                (object-array [
                    Compiler'LOADER         (RT'makeClassLoader)
                    Compiler'METHOD         nil
                    Compiler'LOCAL_ENV      nil
                    Compiler'LOOP_LOCALS    nil
                    Compiler'NEXT_LOCAL_NUM 0
                    RT'CURRENT_NS           (IDeref'''deref RT'CURRENT_NS)
                    RT'WARN_ON_REFLECTION   (IDeref'''deref RT'WARN_ON_REFLECTION)
                ])
            ))
            (try
                (let [#_"Object" EOF (Object.)]
                    (loop [#_"Object" v nil]
                        (Compiler'consumeWhitespaces r)
                        (let-when [#_"Object" x (LispReader'read-4 r, false, EOF, false)] (not= x EOF) => v
                            (recur (Compiler'eval-2 x, false))
                        )
                    )
                )
                (§ catch LispReaderException e
                    (throw (CompilerException'new (:line e), (:column e), (.getCause e)))
                )
                (catch Throwable e
                    (throw (if (§ instance? CompilerException e) (cast' CompilerException e) (CompilerException'new 0, 0, e)))
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"void" Compiler'pushNS []
        (Var'pushThreadBindings (PersistentHashMap'create-1a
            (object-array [
                (Var''setDynamic (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "*ns*"))) nil
            ])
        ))
        nil
    )

    (defn #_"void" Compiler'pushNSandLoader [#_"ClassLoader" loader]
        (Var'pushThreadBindings (RT'map
            (object-array [
                (Var''setDynamic (Var'intern (Namespace'findOrCreate (Symbol'intern "cloiure.core")), (Symbol'intern "*ns*"))) nil
                RT'FN_LOADER_VAR loader
            ])
        ))
        nil
    )

    (defn #_"ILookupThunk" Compiler'getLookupThunk [#_"Object" target, #_"Keyword" k]
        nil
    )

    (defn #_"boolean" Compiler'inty [#_"Class" c] (any = c Integer/TYPE Short/TYPE Byte/TYPE Character/TYPE))

    (defn #_"Class" Compiler'retType [#_"Class" tc, #_"Class" ret]
        (cond
            (nil? tc)
                ret
            (nil? ret)
                tc
            (and (.isPrimitive ret) (.isPrimitive tc))
                (if (or (and (Compiler'inty ret) (Compiler'inty tc)) (= ret tc))
                    tc
                    (throw (UnsupportedOperationException. (str "Cannot coerce " ret " to " tc ", use a cast instead")))
                )
            :else
                tc
        )
    )

    (defn #_"Class" Compiler'primClass-1s [#_"Symbol" sym]
        (when (some? sym)
            (condp = (:name sym)
                "int"     Integer/TYPE
                "long"    Long/TYPE
                "float"   Float/TYPE
                "double"  Double/TYPE
                "char"    Character/TYPE
                "short"   Short/TYPE
                "byte"    Byte/TYPE
                "boolean" Boolean/TYPE
                "void"    Void/TYPE
                          nil
            )
        )
    )

    (defn #_"Class" Compiler'tagClass [#_"Object" tag]
        (when (some? tag) => Object
            (or
                (when (§ instance? Symbol tag)
                    (Compiler'primClass-1s (cast' Symbol tag))
                )
                (HostExpr'tagToClass tag)
            )
        )
    )

    (defn #_"Class" Compiler'primClass-1c [#_"Class" c]
        (if (.isPrimitive c) c Object)
    )

    (defn #_"Class" Compiler'boxClass [#_"Class" p]
        (when (.isPrimitive p) => p
            (condp = p
                Integer/TYPE   Integer
                Long/TYPE      Long
                Float/TYPE     Float
                Double/TYPE    Double
                Character/TYPE Character
                Short/TYPE     Short
                Byte/TYPE      Byte
                Boolean/TYPE   Boolean
                               nil
            )
        )
    )

    (defn #_"IPersistentCollection" Compiler'emptyVarCallSites []
        PersistentHashSet'EMPTY
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (defn- #_"Cons" Cons'init []
        (hash-map
            #_"Object" :_first nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"Cons" Cons'new-2 [#_"Object" _first, #_"ISeq" _more]
        (let [this (merge (ASeq'new-0) (Cons'init))]
            (§ ass this (assoc this :_first _first))
            (§ ass this (assoc this :_more _more))
            this
        )
    )

    (defn #_"Cons" Cons'new-3 [#_"IPersistentMap" meta, #_"Object" _first, #_"ISeq" _more]
        (let [this (merge (ASeq'new-1 meta) (Cons'init))]
            (§ ass this (assoc this :_first _first))
            (§ ass this (assoc this :_more _more))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--Cons [#_"Cons" this]
        (:_first this)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Cons [#_"Cons" this]
        (Seqable'''seq (ISeq'''more this))
    )

    #_override
    (defn #_"ISeq" ISeq'''more--Cons [#_"Cons" this]
        (or (:_more this) PersistentList'EMPTY)
    )

    #_override
    (defn #_"int" Counted'''count--Cons [#_"Cons" this]
        (inc (RT'count (:_more this)))
    )

    #_override
    (defn #_"Cons" IObj'''withMeta--Cons [#_"Cons" this, #_"IPersistentMap" meta]
        (Cons'new-3 meta, (:_first this), (:_more this))
    )
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (defn- #_"Cycle" Cycle'init []
        (hash-map
            #_"ISeq" :all nil ;; never nil
            #_"ISeq" :prev nil
            #_volatile
            #_"ISeq" :_current nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Cycle" Cycle'new-3 [#_"ISeq" all, #_"ISeq" prev, #_"ISeq" current]
        (let [this (merge (ASeq'new-0) (Cycle'init))]
            (§ ass this (assoc this :all all))
            (§ ass this (assoc this :prev prev))
            (§ ass this (assoc this :_current current))
            this
        )
    )

    (defn- #_"Cycle" Cycle'new-5 [#_"IPersistentMap" meta, #_"ISeq" all, #_"ISeq" prev, #_"ISeq" current, #_"ISeq" next]
        (let [this (merge (ASeq'new-1 meta) (Cycle'init))]
            (§ ass this (assoc this :all all))
            (§ ass this (assoc this :prev prev))
            (§ ass this (assoc this :_current current))
            (§ ass this (assoc this :_next next))
            this
        )
    )

    (defn #_"ISeq" Cycle'create [#_"ISeq" vals]
        (if (some? vals) (Cycle'new-3 vals, nil, vals) PersistentList'EMPTY)
    )

    ;; realization for use of current
    #_method
    (defn- #_"ISeq" Cycle''current [#_"Cycle" this]
        (when (nil? (:_current this))
            (let [#_"ISeq" current (.next (:prev this))]
                (§ ass this (assoc this :_current (or current (:all this))))
            )
        )
        (:_current this)
    )

    #_override
    (defn #_"boolean" IPending'''isRealized--Cycle [#_"Cycle" this]
        (some? (:_current this))
    )

    #_override
    (defn #_"Object" ISeq'''first--Cycle [#_"Cycle" this]
        (.first (Cycle''current this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Cycle [#_"Cycle" this]
        (when (nil? (:_next this))
            (§ ass this (assoc this :_next (Cycle'new-3 (:all this), (Cycle''current this), nil)))
        )
        (:_next this)
    )

    #_override
    (defn #_"Cycle" IObj'''withMeta--Cycle [#_"Cycle" this, #_"IPersistentMap" meta]
        (Cycle'new-5 meta, (:all this), (:prev this), (:_current this), (:_next this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--Cycle [#_"Cycle" this, #_"IFn" f]
        (loop [#_"ISeq" s (Cycle''current this) #_"Object" r (.first s)]
            (let [s (or (.next s) (:all this)) r (IFn'''invoke-3 f, r, (.first s))]
                (when-not (RT'isReduced r) => (IDeref'''deref (cast' IDeref r))
                    (recur s r)
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--Cycle [#_"Cycle" this, #_"IFn" f, #_"Object" r]
        (loop [#_"ISeq" s (Cycle''current this) r (IFn'''invoke-3 f, r, (.first s))]
            (when-not (RT'isReduced r) => (IDeref'''deref (cast' IDeref r))
                (let [s (or (.next s) (:all this))]
                    (recur s (IFn'''invoke-3 f, r, (.first s)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    (defn- #_"Delay" Delay'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Throwable" :exception nil
            #_volatile
            #_"IFn" :fn nil
        )
    )

    (defn #_"Delay" Delay'new [#_"IFn" fn]
        (let [this (Delay'init)]
            (§ ass this (assoc this :fn fn))
            (§ ass this (assoc this :val nil))
            (§ ass this (assoc this :exception nil))
            this
        )
    )

    (defn #_"Object" Delay'force [#_"Object" x]
        (if (§ instance? Delay x) (IDeref'''deref (cast' Delay x)) x)
    )

    #_override
    (defn #_"Object" IDeref'''deref--Delay [#_"Delay" this]
        (when (some? (:fn this))
            (§ sync this
                ;; double check
                (when (some? (:fn this))
                    (try
                        (§ ass this (assoc this :val (IFn'''invoke-1 (:fn this))))
                        (catch Throwable t
                            (§ ass this (assoc this :exception t))
                        )
                    )
                    (§ ass this (assoc this :fn nil))
                )
            )
        )
        (when (some? (:exception this))
            (throw (Util'sneakyThrow (:exception this)))
        )
        (:val this)
    )

    #_override
    (defn #_"boolean" IPending'''isRealized--Delay [#_"Delay" this]
        (§ sync this
            (nil? (:fn this))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (def #_"ConcurrentHashMap<String, Reference<Class>>" DynamicClassLoader'classCache (ConcurrentHashMap.))

    (def #_"ReferenceQueue" DynamicClassLoader'RQ (ReferenceQueue.))

    (defn- #_"DynamicClassLoader" DynamicClassLoader'init []
        (hash-map
            #_"HashMap<Integer, Object[]>" :constantVals (HashMap.)
        )
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new [#_"ClassLoader" parent]
        (merge (§ foreign URLClassLoader'new (make-array URL 0), parent) (DynamicClassLoader'init))
    )

    #_foreign
    (§ defn #_"Class" defineClass [#_"DynamicClassLoader" this, #_"String" name, #_"byte[]" bytes, #_"Object" srcForm]
        (Util'clearCache DynamicClassLoader'RQ, DynamicClassLoader'classCache)
        (let [#_"Class" c (.defineClass this, name, bytes, 0, (alength bytes))]
            (.put DynamicClassLoader'classCache, name, (SoftReference. c, DynamicClassLoader'RQ))
            c
        )
    )

    (defn #_"Class<?>" DynamicClassLoader'findInMemoryClass [#_"String" name]
        (when-let [#_"Reference<Class>" r (.get DynamicClassLoader'classCache, name)]
            (or (.get r) (do (.remove DynamicClassLoader'classCache, name, r) nil))
        )
    )

    #_protected
    #_foreign
    (§ defn #_"Class<?>" findClass [#_"DynamicClassLoader" this, #_"String" name] #_(§ throws ClassNotFoundException)
        (or (DynamicClassLoader'findInMemoryClass name) (.findClass (§ super ), name))
    )

    #_protected
    #_foreign
    (§ defn #_"Class<?>" loadClass [#_"DynamicClassLoader" this, #_"String" name, #_"boolean" resolve] #_(§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" c (.findLoadedClass this, name)]
                (when (nil? c)
                    (§ ass c (DynamicClassLoader'findInMemoryClass name))
                    (when (nil? c)
                        (§ ass c (.loadClass (§ super ), name, false))
                    )
                )
                (when resolve
                    (.resolveClass this, c)
                )
                c
            )
        )
    )

    #_method
    (defn #_"void" DynamicClassLoader''registerConstants [#_"DynamicClassLoader" this, #_"int" id, #_"Object[]" val]
        (.put (:constantVals this), id, val)
        nil
    )

    #_method
    (defn #_"Object[]" DynamicClassLoader''getConstants [#_"DynamicClassLoader" this, #_"int" id]
        (.get (:constantVals this), id)
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (defn- #_"ExceptionInfo" ExceptionInfo'init []
        (hash-map
            #_"IPersistentMap" :data nil
        )
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-2 [#_"String" s, #_"IPersistentMap" data]
        (ExceptionInfo'new-3 s, data, nil)
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-3 [#_"String" s, #_"IPersistentMap" data, #_"Throwable" throwable]
        (let [this (merge (§ foreign RuntimeException'new s, throwable) (ExceptionInfo'init))]
            ;; nil cause is equivalent to not passing a cause
            (when (some? data) => (throw (IllegalArgumentException. "Additional data must be non-nil."))
                (§ ass this (assoc this :data data))
            )
            this
        )
    )

    #_override
    (defn #_"IPersistentMap" IExceptionInfo'''getData--ExceptionInfo [#_"ExceptionInfo" this]
        (:data this)
    )

    #_foreign
    (§ defn #_"String" toString [#_"ExceptionInfo" this]
        (str "cloiure.lang.ExceptionInfo: " (.getMessage this) " " (:data this))
    )
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (defn- #_"FnLoaderThunk" FnLoaderThunk'init []
        (hash-map
            #_"Var" :v nil
            #_"ClassLoader" :loader nil
            #_"String" :fnClassName nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"FnLoaderThunk" FnLoaderThunk'new [#_"Var" v, #_"String" fnClassName]
        (let [this (merge (RestFn'new) (FnLoaderThunk'init))]
            (§ ass this (assoc this :v v))
            (§ ass this (assoc this :loader (cast ClassLoader (Var''get RT'FN_LOADER_VAR))))
            (§ ass this (assoc this :fnClassName fnClassName))
            (§ ass this (assoc this :fn nil))
            this
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--FnLoaderThunk [#_"FnLoaderThunk" this, #_"Object" arg1]
        (FnLoaderThunk''load this)
        (IFn'''invoke-2 (:fn this), arg1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--FnLoaderThunk [#_"FnLoaderThunk" this, #_"Object" arg1, #_"Object" arg2]
        (FnLoaderThunk''load this)
        (IFn'''invoke-3 (:fn this), arg1, arg2)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--FnLoaderThunk [#_"FnLoaderThunk" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (FnLoaderThunk''load this)
        (IFn'''invoke-4 (:fn this), arg1, arg2, arg3)
    )

    #_protected
    #_override
    (defn #_"Object" RestFn'''doInvoke-2--FnLoaderThunk [#_"FnLoaderThunk" this, #_"Object" args]
        (FnLoaderThunk''load this)
        (IFn'''applyTo (:fn this), (cast' ISeq args))
    )

    #_method
    (defn- #_"void" FnLoaderThunk''load [#_"FnLoaderThunk" this]
        (when (nil? (:fn this))
            (try
                (§ ass this (assoc this :fn (cast' IFn (.newInstance (Class/forName (:fnClassName this), true, (:loader this))))))
                (catch Exception e
                    (throw (Util'sneakyThrow e))
                )
            )
            (§ ass (:root (:v this)) (:fn this))
        )
        nil
    )

    #_override
    (defn #_"int" RestFn'''getRequiredArity--FnLoaderThunk [#_"FnLoaderThunk" this]
        0
    )

    #_override
    (defn #_"IObj" IObj'''withMeta--FnLoaderThunk [#_"FnLoaderThunk" this, #_"IPersistentMap" meta]
        this
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--FnLoaderThunk [#_"FnLoaderThunk" this]
        nil
    )
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

#_stateless
(class-ns Intrinsics (§ implements Opcodes)
    (defn- #_"Object[]" Intrinsics'oa [& #_"Object..." arr]
        arr
    )

    (§ def #_"IPersistentMap" Intrinsics'ops (RT'map
        (object-array [
            "public static double cloiure.lang.Numbers.add(double,double)"                Opcodes/DADD
            "public static long cloiure.lang.Numbers.and(long,long)"                      Opcodes/LAND
            "public static long cloiure.lang.Numbers.or(long,long)"                       Opcodes/LOR
            "public static long cloiure.lang.Numbers.xor(long,long)"                      Opcodes/LXOR
            "public static double cloiure.lang.Numbers.multiply(double,double)"           Opcodes/DMUL
            "public static double cloiure.lang.Numbers.divide(double,double)"             Opcodes/DDIV
            "public static long cloiure.lang.Numbers.remainder(long,long)"                Opcodes/LREM
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)"                (Intrinsics'oa Opcodes/L2I, Opcodes/LSHL)
            "public static long cloiure.lang.Numbers.shiftRight(long,long)"               (Intrinsics'oa Opcodes/L2I, Opcodes/LSHR)
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)"       (Intrinsics'oa Opcodes/L2I, Opcodes/LUSHR)
            "public static double cloiure.lang.Numbers.minus(double)"                     Opcodes/DNEG
            "public static double cloiure.lang.Numbers.minus(double,double)"              Opcodes/DSUB
            "public static double cloiure.lang.Numbers.inc(double)"                       (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DADD)
            "public static double cloiure.lang.Numbers.dec(double)"                       (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DSUB)
            "public static long cloiure.lang.Numbers.quotient(long,long)"                 Opcodes/LDIV
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)"                Opcodes/ISHL
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)"               Opcodes/ISHR
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)"       Opcodes/IUSHR
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)"           Opcodes/IADD
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)"      Opcodes/ISUB
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)"            Opcodes/INEG
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)"               (Intrinsics'oa Opcodes/ICONST_1, Opcodes/IADD)
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)"               (Intrinsics'oa Opcodes/ICONST_1, Opcodes/ISUB)
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)"      Opcodes/IMUL
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)"        Opcodes/IDIV
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)"     Opcodes/IREM
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)"            Opcodes/LADD
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)"      Opcodes/DADD
            "public static long cloiure.lang.Numbers.unchecked_minus(long)"               Opcodes/LNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double)"           Opcodes/DNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)"    Opcodes/DSUB
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)"          Opcodes/LSUB
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)"       Opcodes/LMUL
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)" Opcodes/DMUL
            "public static double cloiure.lang.Numbers.unchecked_inc(double)"             (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DADD)
            "public static long cloiure.lang.Numbers.unchecked_inc(long)"                 (Intrinsics'oa Opcodes/LCONST_1, Opcodes/LADD)
            "public static double cloiure.lang.Numbers.unchecked_dec(double)"             (Intrinsics'oa Opcodes/DCONST_1, Opcodes/DSUB)
            "public static long cloiure.lang.Numbers.unchecked_dec(long)"                 (Intrinsics'oa Opcodes/LCONST_1, Opcodes/LSUB)

            "public static boolean cloiure.lang.RT.aget_boolean(boolean[],int)"                  Opcodes/BALOAD
            "public static byte cloiure.lang.RT.aget_byte(byte[],int)"                           Opcodes/BALOAD
            "public static short cloiure.lang.RT.aget_short(short[],int)"                        Opcodes/SALOAD
            "public static char cloiure.lang.RT.aget_char(char[],int)"                           Opcodes/CALOAD
            "public static int cloiure.lang.RT.aget_int(int[],int)"                              Opcodes/IALOAD
            "public static long cloiure.lang.RT.aget_long(long[],int)"                           Opcodes/LALOAD
            "public static float cloiure.lang.RT.aget_float(float[],int)"                        Opcodes/FALOAD
            "public static double cloiure.lang.RT.aget_double(double[],int)"                     Opcodes/DALOAD
            "public static java.lang.Object cloiure.lang.RT.aget_object(java.lang.Object[],int)" Opcodes/AALOAD

            "public static int cloiure.lang.RT.alength_boolean(boolean[])"         Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_byte(byte[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_short(short[])"             Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_char(char[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_int(int[])"                 Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_long(long[])"               Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_float(float[])"             Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_double(double[])"           Opcodes/ARRAYLENGTH
            "public static int cloiure.lang.RT.alength_object(java.lang.Object[])" Opcodes/ARRAYLENGTH

            "public static double cloiure.lang.RT.doubleCast(long)"            Opcodes/L2D
            "public static double cloiure.lang.RT.doubleCast(double)"          Opcodes/NOP
            "public static double cloiure.lang.RT.doubleCast(float)"           Opcodes/F2D
            "public static double cloiure.lang.RT.doubleCast(int)"             Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(short)"           Opcodes/I2D
            "public static double cloiure.lang.RT.doubleCast(byte)"            Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)" Opcodes/NOP
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)"  Opcodes/F2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)"   Opcodes/L2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)"    Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)"  Opcodes/I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)"   Opcodes/I2D
            "public static long cloiure.lang.RT.longCast(long)"                Opcodes/NOP
            "public static long cloiure.lang.RT.longCast(short)"               Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(byte)"                Opcodes/I2L
            "public static long cloiure.lang.RT.longCast(int)"                 Opcodes/I2L
            "public static int cloiure.lang.RT.uncheckedIntCast(long)"         Opcodes/L2I
            "public static int cloiure.lang.RT.uncheckedIntCast(double)"       Opcodes/D2I
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(short)"        Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(char)"         Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(int)"          Opcodes/NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(float)"        Opcodes/F2I
            "public static long cloiure.lang.RT.uncheckedLongCast(short)"      Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(float)"      Opcodes/F2L
            "public static long cloiure.lang.RT.uncheckedLongCast(double)"     Opcodes/D2L
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)"       Opcodes/I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(long)"       Opcodes/NOP
            "public static long cloiure.lang.RT.uncheckedLongCast(int)"        Opcodes/I2L
        ])
    ))

    ;; map to instructions terminated with comparator for branch to false
    (§ def #_"IPersistentMap" Intrinsics'preds (RT'map
        (object-array [
            "public static boolean cloiure.lang.Numbers.lt(double,double)"    (Intrinsics'oa Opcodes/DCMPG, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.lt(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.equiv(double,double)" (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.equiv(long,long)"     (Intrinsics'oa Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.lte(double,double)"   (Intrinsics'oa Opcodes/DCMPG, Opcodes/IFGT)
            "public static boolean cloiure.lang.Numbers.lte(long,long)"       (Intrinsics'oa Opcodes/LCMP, Opcodes/IFGT)
            "public static boolean cloiure.lang.Numbers.gt(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.gt(double,double)"    (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.gte(long,long)"       (Intrinsics'oa Opcodes/LCMP, Opcodes/IFLT)
            "public static boolean cloiure.lang.Numbers.gte(double,double)"   (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFLT)
            "public static boolean cloiure.lang.Util.equiv(long,long)"        (Intrinsics'oa Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)"  (Intrinsics'oa Opcodes/IF_ICMPNE)
            "public static boolean cloiure.lang.Util.equiv(double,double)"    (Intrinsics'oa Opcodes/DCMPL, Opcodes/IFNE)

            "public static boolean cloiure.lang.Numbers.isZero(double)"       (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.isZero(long)"         (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFNE)
            "public static boolean cloiure.lang.Numbers.isPos(long)"          (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.isPos(double)"        (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPL, Opcodes/IFLE)
            "public static boolean cloiure.lang.Numbers.isNeg(long)"          (Intrinsics'oa Opcodes/LCONST_0, Opcodes/LCMP, Opcodes/IFGE)
            "public static boolean cloiure.lang.Numbers.isNeg(double)"        (Intrinsics'oa Opcodes/DCONST_0, Opcodes/DCMPG, Opcodes/IFGE)
        ])
    ))
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (def- #_"Object" Iterate'UNREALIZED_SEED (Object.))

    (defn- #_"Iterate" Iterate'init []
        (hash-map
            #_"IFn" :f nil ;; never nil
            #_"Object" :prevSeed nil
            #_volatile
            #_"Object" :_seed nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Iterate" Iterate'new-3 [#_"IFn" f, #_"Object" prevSeed, #_"Object" seed]
        (let [this (merge (ASeq'new-0) (Iterate'init))]
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :prevSeed prevSeed))
            (§ ass this (assoc this :_seed seed))
            this
        )
    )

    (defn- #_"Iterate" Iterate'new-5 [#_"IPersistentMap" meta, #_"IFn" f, #_"Object" prevSeed, #_"Object" seed, #_"ISeq" next]
        (let [this (merge (ASeq'new-1 meta) (Iterate'init))]
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :prevSeed prevSeed))
            (§ ass this (assoc this :_seed seed))
            (§ ass this (assoc this :_next next))
            this
        )
    )

    (defn #_"ISeq" Iterate'create [#_"IFn" f, #_"Object" seed]
        (Iterate'new-3 f, nil, seed)
    )

    #_override
    (defn #_"boolean" IPending'''isRealized--Iterate [#_"Iterate" this]
        (not= (:_seed this) Iterate'UNREALIZED_SEED)
    )

    #_override
    (defn #_"Object" ISeq'''first--Iterate [#_"Iterate" this]
        (when (= (:_seed this) Iterate'UNREALIZED_SEED)
            (§ ass this (assoc this :_seed (IFn'''invoke-2 (:f this), (:prevSeed this))))
        )
        (:_seed this)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Iterate [#_"Iterate" this]
        (when (nil? (:_next this))
            (§ ass this (assoc this :_next (Iterate'new-3 (:f this), (.first this), Iterate'UNREALIZED_SEED)))
        )
        (:_next this)
    )

    #_override
    (defn #_"Iterate" IObj'''withMeta--Iterate [#_"Iterate" this, #_"IPersistentMap" meta]
        (Iterate'new-5 meta, (:f this), (:prevSeed this), (:_seed this), (:_next this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--Iterate [#_"Iterate" this, #_"IFn" f]
        (loop [#_"Object" r (.first this) #_"Object" v (IFn'''invoke-2 (:f this), r)]
            (let [r (IFn'''invoke-3 f, r, v)]
                (when-not (RT'isReduced r) => (IDeref'''deref (cast' IDeref r))
                    (recur r (IFn'''invoke-2 (:f this), v))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--Iterate [#_"Iterate" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"Object" v (.first this)]
            (let [r (IFn'''invoke-3 f, r, v)]
                (when-not (RT'isReduced r) => (IDeref'''deref (cast' IDeref r))
                    (recur r (IFn'''invoke-2 (:f this), v))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeqState
    (defn- #_"IteratorSeqState" IteratorSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"IteratorSeqState" IteratorSeqState'new []
        (IteratorSeqState'init)
    )
)

(class-ns IteratorSeq (§ extends ASeq)
    (defn #_"IteratorSeq" IteratorSeq'create [#_"Iterator" iter]
        (when (.hasNext iter)
            (IteratorSeq'new-1 iter)
        )
    )

    (defn- #_"IteratorSeq" IteratorSeq'init []
        (hash-map
            #_"Iterator" :iter nil
            #_"IteratorSeqState" :state nil
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-1 [#_"Iterator" iter]
        (let [this (merge (ASeq'new-0) (IteratorSeq'init))]
            (§ ass this (assoc this :iter iter))
            (§ ass this (assoc this :state (IteratorSeqState'new)))
            (§ ass (:val (:state this)) (:state this))
            (§ ass (:_rest (:state this)) (:state this))
            this
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-3 [#_"IPersistentMap" meta, #_"Iterator" iter, #_"IteratorSeqState" state]
        (let [this (merge (ASeq'new-1 meta) (IteratorSeq'init))]
            (§ ass this (assoc this :iter iter))
            (§ ass this (assoc this :state state))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--IteratorSeq [#_"IteratorSeq" this]
        (when (= (:val (:state this)) (:state this))
            (§ sync (:state this)
                (when (= (:val (:state this)) (:state this))
                    (§ ass (:val (:state this)) (.next (:iter this)))
                )
            )
        )
        (:val (:state this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--IteratorSeq [#_"IteratorSeq" this]
        (when (= (:_rest (:state this)) (:state this))
            (§ sync (:state this)
                (when (= (:_rest (:state this)) (:state this))
                    (.first this)
                    (§ ass (:_rest (:state this)) (IteratorSeq'create (:iter this)))
                )
            )
        )
        (cast' ISeq (:_rest (:state this)))
    )

    #_override
    (defn #_"IteratorSeq" IObj'''withMeta--IteratorSeq [#_"IteratorSeq" this, #_"IPersistentMap" meta]
        (IteratorSeq'new-3 meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" Keyword'TABLE (ConcurrentHashMap.))

    (def #_"ReferenceQueue" Keyword'RQ (ReferenceQueue.))

    (defn #_"Keyword" Keyword'intern [#_"Symbol" sym]
        (let [#_"Reference<Keyword>" r (.get Keyword'TABLE, sym)
              [sym r #_"Keyword" k]
                (when (nil? r) => [sym r nil]
                    (Util'clearCache Keyword'RQ, Keyword'TABLE)
                    (let [sym
                            (when (some? (IMeta'''meta sym)) => sym
                                (cast' Symbol (IObj'''withMeta sym, nil))
                            )
                          k (Keyword'new sym)
                          r (.putIfAbsent Keyword'TABLE, sym, (WeakReference. #_"<Keyword>" k, Keyword'RQ))]
                        [sym r k]
                    )
                )]
            (when (some? r) => k
                (or (.get r)
                    (do ;; entry died in the interim, do over
                        (.remove Keyword'TABLE, sym, r)
                        (recur #_"Keyword'intern" sym)
                    )
                )
            )
        )
    )

    (defn- #_"Keyword" Keyword'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"int" :hasheq 0
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Keyword" Keyword'new [#_"Symbol" sym]
        (let [this (Keyword'init)]
            (§ ass this (assoc this :sym sym))
            (§ ass this (assoc this :hasheq (+ (IHashEq'''hasheq sym) 0x9e3779b9)))
            this
        )
    )

    (defn #_"Keyword" Keyword'find [#_"Symbol" sym]
        (let [#_"Reference<Keyword>" ref (.get Keyword'TABLE, sym)]
            (when (some? ref)
                (.get ref)
            )
        )
    )

    (defn #_"Keyword" Keyword'find-2 [#_"String" ns, #_"String" name]
        (Keyword'find (Symbol'intern ns, name))
    )

    (defn #_"Keyword" Keyword'find-1 [#_"String" nsname]
        (Keyword'find (Symbol'intern nsname))
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"Keyword" this]
        (+ (.hashCode (:sym this)) 0x9e3779b9)
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--Keyword [#_"Keyword" this]
        (:hasheq this)
    )

    #_foreign
    (§ defn #_"String" toString [#_"Keyword" this]
        (when (nil? (:_str this))
            (§ ass this (assoc this :_str (str ":" (:sym this))))
        )
        (:_str this)
    )

    #_method
    (defn #_"Object" Keyword''throwArity [#_"Keyword" this]
        (throw (IllegalArgumentException. (str "Wrong number of args passed to keyword: " this)))
    )

    #_foreign
    (§ defn #_"Object" call [#_"Keyword" this]
        (Keyword''throwArity this)
    )

    #_foreign
    (§ defn #_"void" run [#_"Keyword" this]
        (throw (UnsupportedOperationException.))
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--Keyword [#_"Keyword" this]
        (Keyword''throwArity this)
    )

    #_foreign
    (§ defn #_"int" compareTo [#_"Keyword" this, #_"Object" o]
        (.compareTo (:sym this), (:sym (cast' Keyword o)))
    )

    #_override
    (defn #_"String" Named'''getNamespace--Keyword [#_"Keyword" this]
        (Named'''getNamespace (:sym this))
    )

    #_override
    (defn #_"String" Named'''getName--Keyword [#_"Keyword" this]
        (Named'''getName (:sym this))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--Keyword [#_"Keyword" this, #_"Object" obj]
        (if (§ instance? ILookup obj)
            (ILookup'''valAt-2 (cast' ILookup obj), this)
            (RT'get-2 obj, this)
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--Keyword [#_"Keyword" this, #_"Object" obj, #_"Object" notFound]
        (if (§ instance? ILookup obj)
            (ILookup'''valAt-3 (cast' ILookup obj), this, notFound)
            (RT'get-3 obj, this, notFound)
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (Keyword''throwArity this)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (Keyword''throwArity this)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (Keyword''throwArity this)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--Keyword [#_"Keyword" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (Keyword''throwArity this)
    )

    #_override
    (defn #_"Object" IFn'''applyTo--Keyword [#_"Keyword" this, #_"ISeq" args]
        (AFn'applyToHelper this, args)
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (defn- #_"KeywordLookupSite" KeywordLookupSite'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordLookupSite" KeywordLookupSite'new [#_"Keyword" k]
        (let [this (KeywordLookupSite'init)]
            (§ ass this (assoc this :k k))
            this
        )
    )

    #_override
    (defn #_"ILookupThunk" ILookupSite'''fault--KeywordLookupSite [#_"KeywordLookupSite" this, #_"Object" target]
        (cond
            (§ instance? IKeywordLookup target) (KeywordLookupSite''install this, target)
            (§ instance? ILookup target)        (KeywordLookupSite''ilookupThunk this, (.getClass target))
            :else                               this
        )
    )

    #_override
    (defn #_"Object" ILookupThunk'''get--KeywordLookupSite [#_"KeywordLookupSite" this, #_"Object" target]
        (if (or (§ instance? IKeywordLookup target) (§ instance? ILookup target))
            this
            (RT'get-2 target, (:k this))
        )
    )

    #_method
    (defn- #_"ILookupThunk" KeywordLookupSite''ilookupThunk [#_"KeywordLookupSite" this, #_"Class" c]
        (§ reify ILookupThunk()
            #_override
            (defn #_"Object" ILookupThunk'''get--ILookupThunk [#_"ILookupThunk" this, #_"Object" target]
                (if (and (some? target) (= (.getClass target) c))
                    (ILookup'''valAt-2 (cast' ILookup target), (:k this))
                    this
                )
            )
        )
    )

    #_method
    (defn- #_"ILookupThunk" KeywordLookupSite''install [#_"KeywordLookupSite" this, #_"Object" target]
        (or (IKeywordLookup'''getLookupThunk (cast' IKeywordLookup target), (:k this)) (KeywordLookupSite''ilookupThunk this, (.getClass target)))
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns LazilyPersistentVector
    (defn #_"IPersistentVector" LazilyPersistentVector'createOwning [& #_"Object..." items]
        (if (<= (alength items) 32)
            (PersistentVector'new-4 (alength items), 5, PersistentVector'EMPTY_NODE, items)
            (PersistentVector'create-1a items)
        )
    )

    (defn #_"int" LazilyPersistentVector'fcount [#_"Object" c]
        (if (§ instance? Counted c)
            (.count (cast' Counted c))
            (.size (cast Collection c))
        )
    )

    (defn #_"IPersistentVector" LazilyPersistentVector'create [#_"Object" obj]
        (cond
            (§ instance? IReduceInit obj) (PersistentVector'create-1r (cast' IReduceInit obj))
            (§ instance? ISeq obj)        (PersistentVector'create-1s (RT'seq obj))
            (instance? Iterable obj)      (PersistentVector'create-1i (cast Iterable obj))
            :else                         (LazilyPersistentVector'createOwning (RT'toArray obj))
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (defn- #_"LazySeq" LazySeq'init []
        (hash-map
            #_"IFn" :fn nil
            #_"Object" :sv nil
            #_"ISeq" :s nil
        )
    )

    (defn #_"LazySeq" LazySeq'new-1 [#_"IFn" fn]
        (let [this (merge (Obj'new-0) (LazySeq'init))]
            (§ ass this (assoc this :fn fn))
            this
        )
    )

    (defn- #_"LazySeq" LazySeq'new-2 [#_"IPersistentMap" meta, #_"ISeq" s]
        (let [this (merge (Obj'new-1 meta) (LazySeq'init))]
            (§ ass this (assoc this :fn nil))
            (§ ass this (assoc this :s s))
            this
        )
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--LazySeq [#_"LazySeq" this, #_"IPersistentMap" meta]
        (LazySeq'new-2 meta, (Seqable'''seq this))
    )

    #_method
    (defn #_"Object" LazySeq''sval [#_"LazySeq" this]
        (§ sync this
            (when (some? (:fn this))
                (§ ass this (assoc this :sv (IFn'''invoke-1 (:fn this))))
                (§ ass this (assoc this :fn nil))
            )
            (or (:sv this) (:s this))
        )
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--LazySeq [#_"LazySeq" this]
        (§ sync this
            (LazySeq''sval this)
            (when (some? (:sv this))
                (let [#_"Object" ls (:sv this)]
                    (§ ass this (assoc this :sv nil))
                    (while (§ instance? LazySeq ls)
                        (§ ass ls (LazySeq''sval (cast' LazySeq ls)))
                    )
                    (§ ass this (assoc this :s (RT'seq ls)))
                )
            )
            (:s this)
        )
    )

    #_override
    (defn #_"int" Counted'''count--LazySeq [#_"LazySeq" this]
        (let [#_"int" c 0]
            (loop-when-recur [#_"ISeq" s (Seqable'''seq this)] (some? s) [(.next s)]
                (§ ass c (inc c))
            )
            c
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--LazySeq [#_"LazySeq" this]
        (Seqable'''seq this)
        (when (some? (:s this))
            (.first (:s this))
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''next--LazySeq [#_"LazySeq" this]
        (Seqable'''seq this)
        (when (some? (:s this))
            (.next (:s this))
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''more--LazySeq [#_"LazySeq" this]
        (Seqable'''seq this)
        (if (some? (:s this)) (ISeq'''more (:s this)) PersistentList'EMPTY)
    )

    #_override
    (defn #_"ISeq" ISeq'''cons--LazySeq [#_"LazySeq" this, #_"Object" o]
        (RT'cons o, (Seqable'''seq this))
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--LazySeq [#_"LazySeq" this]
        PersistentList'EMPTY
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--LazySeq [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (Seqable'''seq this)]
            (if (some? s)
                (IPersistentCollection'''equiv s, o)
                (and (or (§ instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
            )
        )
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"LazySeq" this]
        (let [#_"ISeq" s (Seqable'''seq this)]
            (if (some? s) (Util'hash s) 1)
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--LazySeq [#_"LazySeq" this]
        (Murmur3'hashOrdered this)
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"LazySeq" this, #_"Object" o]
        (let [#_"ISeq" s (Seqable'''seq this)]
            (if (some? s)
                (.equals s, o)
                (and (or (§ instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
            )
        )
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"LazySeq" this]
        (RT'seqToArray (Seqable'''seq this))
    )

    #_foreign
    (§ defn #_"boolean" add [#_"LazySeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" remove [#_"LazySeq" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"void" clear [#_"LazySeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" retainAll [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" removeAll [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" containsAll [#_"LazySeq" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"LazySeq" this, #_"Object[]" a]
        (RT'seqToPassedArray (Seqable'''seq this), a)
    )

    #_foreign
    (§ defn #_"int" size [#_"LazySeq" this]
        (.count this)
    )

    #_foreign
    (§ defn #_"boolean" isEmpty [#_"LazySeq" this]
        (nil? (Seqable'''seq this))
    )

    #_foreign
    (§ defn #_"boolean" contains [#_"LazySeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (Seqable'''seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"LazySeq" this]
        (SeqIterator'new this)
    )

    #_foreign
    (§ defn #_"List" subList [#_"LazySeq" this, #_"int" fromIndex, #_"int" toIndex]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" set [#_"LazySeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" remove [#_"LazySeq" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"LazySeq" this, #_"Object" o]
        (loop-when [#_"ISeq" s (Seqable'''seq this) #_"int" i 0] (some? s) => -1
            (if (Util'equiv-2oo (.first s), o) i (recur (.next s) (inc i)))
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"LazySeq" this, #_"Object" o]
        (.lastIndexOf (ArrayList. this), o)
    )

    #_foreign
    (§ defn #_"ListIterator" listIterator [#_"LazySeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"ListIterator" listIterator [#_"LazySeq" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" get [#_"LazySeq" this, #_"int" index]
        (RT'nth-2 this, index)
    )

    #_foreign
    (§ defn #_"void" add [#_"LazySeq" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"LazySeq" this, #_"int" index, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_override
    (defn #_"boolean" IPending'''isRealized--LazySeq [#_"LazySeq" this]
        (§ sync this
            (nil? (:fn this))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.
    (def- #_"int" LineNumberingPushbackReader'newline (int \newline))

    (defn- #_"LineNumberingPushbackReader" LineNumberingPushbackReader'init []
        (hash-map
            #_"boolean" :_atLineStart true
            #_"boolean" :_prev false
            #_"int" :_columnNumber 1
        )
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-1 [#_"Reader" r]
        (merge (§ foreign PushbackReader'new (LineNumberReader. r)) (LineNumberingPushbackReader'init))
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-2 [#_"Reader" r, #_"int" size]
        (merge (§ foreign PushbackReader'new (LineNumberReader. r, size)) (LineNumberingPushbackReader'init))
    )

    #_method
    (defn #_"int" LineNumberingPushbackReader''getLineNumber [#_"LineNumberingPushbackReader" this]
        (inc (.getLineNumber (cast LineNumberReader (§ foreign in))))
    )

    #_method
    (defn #_"void" LineNumberingPushbackReader''setLineNumber [#_"LineNumberingPushbackReader" this, #_"int" line]
        (.setLineNumber (cast LineNumberReader (§ foreign in)), (dec line))
        nil
    )

    #_method
    (defn #_"int" LineNumberingPushbackReader''getColumnNumber [#_"LineNumberingPushbackReader" this]
        (:_columnNumber this)
    )

    #_foreign
    (§ defn #_"int" read [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" c (.read (§ super ))]
            (§ ass this (assoc this :_prev (:_atLineStart this)))
            (if (or (= c LineNumberingPushbackReader'newline) (= c -1))
                (do
                    (§ ass this (assoc this :_atLineStart true))
                    (§ ass this (assoc this :_columnNumber 1))
                )
                (do
                    (§ ass this (assoc this :_atLineStart false))
                    (§ ass this (assoc this :_columnNumber (inc (:_columnNumber this))))
                )
            )
            c
        )
    )

    #_foreign
    (§ defn #_"void" unread [#_"LineNumberingPushbackReader" this, #_"int" c] #_(§ throws IOException)
        (.unread (§ super ), c)
        (§ ass this (assoc this :_atLineStart (:_prev this)))
        (§ ass this (assoc this :_columnNumber (dec (:_columnNumber this))))
        nil
    )

    #_method
    (defn #_"String" LineNumberingPushbackReader''readLine [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" c (.read this)]
            (condp = c -1 nil LineNumberingPushbackReader'newline ""
                (let [#_"String" s (String/valueOf (char c)) #_"String" z (.readLine (cast LineNumberReader (§ foreign in)))]
                    (§ ass this (assoc this :_prev false))
                    (§ ass this (assoc this :_atLineStart true))
                    (§ ass this (assoc this :_columnNumber 1))
                    (if (nil? z) s (str s z))
                )
            )
        )
    )

    #_method
    (defn #_"boolean" LineNumberingPushbackReader''atLineStart [#_"LineNumberingPushbackReader" this]
        (:_atLineStart this)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns LispReaderException (§ extends RuntimeException)
    (defn- #_"LispReaderException" LispReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"LispReaderException" LispReaderException'new [#_"int" line, #_"int" column, #_"Throwable" cause]
        (let [this (merge (§ foreign RuntimeException'new cause) (LispReaderException'init))]
            (§ ass this (assoc this :line line))
            (§ ass this (assoc this :column column))
            this
        )
    )
)

#_closure
(class-ns RegexReader (§ extends AFn)
    (defn #_"RegexReader" RegexReader'new []
        (AFn'new)
    )

    (§ def #_"StringReader" RegexReader'stringrdr (StringReader'new))

    #_override
    (defn #_"Object" IFn'''invoke-4--RegexReader [#_"RegexReader" this, #_"Object" reader, #_"Object" doublequote, #_"Object" pendingForms]
        (let [#_"Reader" r (cast Reader reader) #_"StringBuilder" sb (StringBuilder.)]
            (loop []
                (let-when [#_"int" ch (LispReader'read1 r)] (not= ch -1) => (throw (RuntimeException. "EOF while reading regex"))
                    (when-not (= ch \") ;; oops! "
                        (.append sb, (char ch))
                        (when (= ch \\) ;; escape
                            (let-when [ch (LispReader'read1 r)] (not= ch -1) => (throw (RuntimeException. "EOF while reading regex"))
                                (.append sb, (char ch))
                            )
                        )
                        (recur)
                    )
                )
            )
            (Pattern/compile (.toString sb))
        )
    )
)

#_closure
(class-ns StringReader (§ extends AFn)
    (defn #_"StringReader" StringReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--StringReader [#_"StringReader" this, #_"Object" reader, #_"Object" doublequote, #_"Object" pendingForms]
        (let [#_"StringBuilder" sb (StringBuilder.) #_"Reader" r (cast Reader reader)]
            (loop-when-recur [#_"int" ch (LispReader'read1 r)] (not= ch \") [(LispReader'read1 r)] ;; oops! "
                (when (not= ch -1) => (throw (RuntimeException. "EOF while reading string"))
                    (let [ch
                            (when (= ch \\) => ch
                                ;; escape
                                (let [ch (LispReader'read1 r)]
                                    (when (not= ch -1) => (throw (RuntimeException. "EOF while reading string"))
                                        (case ch
                                            \t  \tab
                                            \r  \return
                                            \n  \newline
                                            \\  ch
                                            \"  ch ;; oops! "
                                            \b  \backspace
                                            \f  \formfeed
                                            \u  (let [ch (LispReader'read1 r)]
                                                    (when (= (Character/digit ch, 16) -1)
                                                        (throw (RuntimeException. (str "Invalid unicode escape: \\u" (char ch))))
                                                    )
                                                    (LispReader'readUnicodeChar-5 (cast PushbackReader r), ch, 16, 4, true)
                                                )
                                            (when (Character/isDigit ch) => (throw (RuntimeException. (str "Unsupported escape character: \\" (char ch))))
                                                (let [ch (LispReader'readUnicodeChar-5 (cast PushbackReader r), ch, 8, 3, false)]
                                                    (when (< 0377 ch)
                                                        (throw (RuntimeException. "Octal escape sequence must be in range [0, 377]."))
                                                    )
                                                    ch
                                                )
                                            )
                                        )
                                    )
                                )
                            )]
                        (.append sb, (char ch))
                    )
                )
            )
            (.toString sb)
        )
    )
)

#_closure
(class-ns CommentReader (§ extends AFn)
    (defn #_"CommentReader" CommentReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--CommentReader [#_"CommentReader" this, #_"Object" reader, #_"Object" semicolon, #_"Object" pendingForms]
        (let [#_"Reader" r (cast Reader reader)]
            (§ let [#_"int" ch]
                (§ loop
                    (§ ass ch (LispReader'read1 r))
                    (§ recur-if (not (or (= ch -1) (= ch \newline) (= ch \return))))
                )
                r
            )
        )
    )
)

#_closure
(class-ns DiscardReader (§ extends AFn)
    (defn #_"DiscardReader" DiscardReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--DiscardReader [#_"DiscardReader" this, #_"Object" reader, #_"Object" underscore, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))
            r
        )
    )
)

;; :a.b{:c 1} => {:a.b/c 1}
;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
#_closure
(class-ns NamespaceMapReader (§ extends AFn)
    (defn #_"NamespaceMapReader" NamespaceMapReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--NamespaceMapReader [#_"NamespaceMapReader" this, #_"Object" reader, #_"Object" colon, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              #_"boolean" auto
                (let [#_"int" autoChar (LispReader'read1 r)]
                    (or (= autoChar \:)
                        (do (LispReader'unread r, autoChar) false)
                    )
                )
              #_"int" nextChar (LispReader'read1 r)
              [#_"Object" sym nextChar]
                (cond
                    (LispReader'isWhitespace nextChar) ;; the #:: { } case or an error
                    (if auto
                        (let [nextChar (loop-when-recur nextChar (LispReader'isWhitespace nextChar) (LispReader'read1 r) => nextChar)]
                            (when (not= nextChar \{)
                                (LispReader'unread r, nextChar)
                                (throw (RuntimeException. "Namespaced map must specify a namespace"))
                            )
                            [nil nextChar]
                        )
                        (do
                            (LispReader'unread r, nextChar)
                            (throw (RuntimeException. "Namespaced map must specify a namespace"))
                        )
                    )
                    (not= nextChar \{) ;; #:foo { } or #::foo { }
                    (do
                        (LispReader'unread r, nextChar)
                        (let [sym (LispReader'read-5 r, true, nil, false, pendingForms)
                              nextChar (LispReader'read1 r)
                              nextChar (loop-when-recur nextChar (LispReader'isWhitespace nextChar) (LispReader'read1 r) => nextChar)]
                            [sym nextChar]
                        )
                    )
                    :else
                    (do
                        [nil nextChar]
                    )
                )]
            (when (not= nextChar \{)
                (throw (RuntimeException. "Namespaced map must specify a map"))
            )

            ;; resolve autoresolved ns
            (let [#_"String" ns
                    (cond auto
                        (cond (nil? sym)
                            (do
                                (Named'''getName (Namespace''getName (Compiler'currentNS)))
                            )
                            (or (not (§ instance? Symbol sym)) (some? (Named'''getNamespace (cast' Symbol sym))))
                            (do
                                (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " sym)))
                            )
                            :else
                            (let [#_"Symbol" resolvedNS
                                    (when-let [#_"Namespace" rns (Namespace''lookupAlias (Compiler'currentNS), (cast' Symbol sym))]
                                        (Namespace''getName rns)
                                    )]
                                (when (some? resolvedNS) => (throw (RuntimeException. (str "Unknown auto-resolved namespace alias: " sym)))
                                    (Named'''getName resolvedNS)
                                )
                            )
                        )
                        (or (not (§ instance? Symbol sym)) (some? (Named'''getNamespace (cast' Symbol sym))))
                        (do
                            (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " sym)))
                        )
                        :else
                        (do
                            (Named'''getName (cast' Symbol sym))
                        )
                    )]

                ;; read map
                (let [#_"List" kvs (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms))]
                    (when (= (& (.size kvs) 1) 1)
                        (throw (RuntimeException. "Namespaced map literal must contain an even number of forms"))
                    )

                    ;; construct output map
                    (let [#_"Object[]" a (make-array Object (.size kvs)) #_"Iterator" it (.iterator kvs)]
                        (loop-when-recur [#_"int" i 0] (.hasNext it) [(+ i 2)]
                            (let [#_"Object" key (.next it) #_"Object" val (.next it)
                                  _ (cond
                                        (§ instance? Keyword key)
                                        (let [#_"Keyword" kw (cast' Keyword key)]
                                            (cond
                                                (nil? (Named'''getNamespace kw))  (Keyword'intern (Symbol'intern ns, (Named'''getName kw)))
                                                (= (Named'''getNamespace kw) "_") (Keyword'intern (Symbol'intern nil, (Named'''getName kw)))
                                            )
                                        )
                                        (§ instance? Symbol key)
                                        (let [#_"Symbol" s (cast' Symbol key)]
                                            (cond
                                                (nil? (Named'''getNamespace s))  (Symbol'intern ns, (Named'''getName s))
                                                (= (Named'''getNamespace s) "_") (Symbol'intern nil, (Named'''getName s))
                                            )
                                        )
                                    )]
                                (aset a i (or _ key))
                                (aset a (inc i) val)
                            )
                        )
                        (RT'map a)
                    )
                )
            )
        )
    )
)

#_closure
(class-ns SymbolicValueReader (§ extends AFn)
    (defn #_"SymbolicValueReader" SymbolicValueReader'new []
        (AFn'new)
    )

    (§ def #_"IPersistentMap" SymbolicValueReader'specials (PersistentHashMap'create-1a
        (object-array [
            (Symbol'intern "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern "NaN")  Double/NaN
        ])
    ))

    #_override
    (defn #_"Object" IFn'''invoke-4--SymbolicValueReader [#_"SymbolicValueReader" this, #_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              #_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
            (when-not (§ instance? Symbol o)
                (throw (RuntimeException. (str "Invalid token: ##" o)))
            )
            (when-not (Associative'''containsKey SymbolicValueReader'specials, o)
                (throw (RuntimeException. (str "Unknown symbolic value: ##" o)))
            )
            (ILookup'''valAt-2 SymbolicValueReader'specials, o)
        )
    )
)

(class-ns WrappingReader (§ extends AFn)
    (defn- #_"WrappingReader" WrappingReader'init []
        (hash-map
            #_"Symbol" :sym nil
        )
    )

    (defn #_"WrappingReader" WrappingReader'new [#_"Symbol" sym]
        (let [this (merge (AFn'new) (WrappingReader'init))]
            (§ ass this (assoc this :sym sym))
            this
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--WrappingReader [#_"WrappingReader" this, #_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              #_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
            (RT'list-2 (:sym this), o)
        )
    )
)

#_closure
(class-ns VarReader (§ extends AFn)
    (defn #_"VarReader" VarReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--VarReader [#_"VarReader" this, #_"Object" reader, #_"Object" quote, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              #_"Object" o (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
            (RT'list-2 LispReader'THE_VAR, o)
        )
    )
)

#_closure
(class-ns DispatchReader (§ extends AFn)
    (defn #_"DispatchReader" DispatchReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--DispatchReader [#_"DispatchReader" this, #_"Object" reader, #_"Object" hash, #_"Object" pendingForms]
        (let-when-not [#_"int" ch (LispReader'read1 (cast Reader reader))] (= ch -1) => (throw (RuntimeException. "EOF while reading character"))
            (let-when-not [#_"IFn" fn (aget LispReader'dispatchMacros ch)] (some? fn) => (IFn'''invoke-4 fn, reader, ch, pendingForms)
                (LispReader'unread (cast PushbackReader reader), ch)
                (throw (RuntimeException. (str "No dispatch macro for: " (char ch))))
            )
        )
    )
)

#_closure
(class-ns FnReader (§ extends AFn)
    (defn #_"FnReader" FnReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--FnReader [#_"FnReader" this, #_"Object" reader, #_"Object" lparen, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (when (some? (IDeref'''deref LispReader'ARG_ENV))
                (throw (IllegalStateException. "Nested #()s are not allowed"))
            )
            (try
                (Var'pushThreadBindings (RT'map LispReader'ARG_ENV, PersistentTreeMap'EMPTY))
                (LispReader'unread r, \()
                (let [#_"Object" form (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))
                      #_"PersistentVector" args PersistentVector'EMPTY
                      #_"PersistentTreeMap" argsyms (cast' PersistentTreeMap (IDeref'''deref LispReader'ARG_ENV))
                      args
                        (let-when [#_"ISeq" rargs (Reversible'''rseq argsyms)] (some? rargs) => args
                            (let [args
                                    (let-when [#_"int" higharg (cast Integer (.getKey (cast Map$Entry (.first rargs))))] (pos? higharg) => args
                                        (loop-when [args args #_"int" i 1] (<= i higharg) => args
                                            (let [#_"Object" sym (or (ILookup'''valAt-2 argsyms, i) (LispReader'garg i))]
                                                (recur (IPersistentVector'''cons args, sym) (inc i))
                                            )
                                        )
                                    )]
                                (let-when [#_"Object" restsym (ILookup'''valAt-2 argsyms, -1)] (some? restsym) => args
                                    (-> args (IPersistentVector'''cons Compiler'_AMP_) (IPersistentVector'''cons restsym))
                                )
                            )
                        )]
                    (RT'list-3 Compiler'FN, args, form)
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )
)

#_closure
(class-ns ArgReader (§ extends AFn)
    (defn #_"ArgReader" ArgReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--ArgReader [#_"ArgReader" this, #_"Object" reader, #_"Object" pct, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (when (some? (IDeref'''deref LispReader'ARG_ENV)) => (LispReader'interpretToken (LispReader'readToken r, \%))
                (let [#_"int" ch (LispReader'read1 r) _ (LispReader'unread r, ch)]
                    ;; % alone is first arg
                    (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isTerminatingMacro ch))
                        (LispReader'registerArg 1)
                        (let [#_"Object" n (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                            (cond
                                (.equals n, Compiler'_AMP_) (LispReader'registerArg -1)
                                (instance? Number n)        (LispReader'registerArg (.intValue (cast Number n)))
                                :else                       (throw (IllegalStateException. "arg literal must be %, %& or %integer"))
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns MetaReader (§ extends AFn)
    (defn #_"MetaReader" MetaReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--MetaReader [#_"MetaReader" this, #_"Object" reader, #_"Object" caret, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              [#_"int" line #_"int" column]
                (when (§ instance? LineNumberingPushbackReader r) => [-1 -1]
                    [(LineNumberingPushbackReader''getLineNumber (cast' LineNumberingPushbackReader r)) (dec (LineNumberingPushbackReader''getColumnNumber (cast' LineNumberingPushbackReader r)))]
                )
              pendingForms (LispReader'ensurePending pendingForms)
              #_"Object" meta (LispReader'read-5 r, true, nil, true, pendingForms)
              meta
                (cond
                    (or (§ instance? Symbol meta) (instance? String meta)) (RT'map RT'TAG_KEY, meta)
                    (§ instance? Keyword meta)                             (RT'map meta, RT'T)
                    (§ instance? IPersistentMap meta)                      meta
                    :else (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                )
              #_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
            (when (§ instance? IMeta o) => (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                (let [meta
                        (when (and (not= line -1) (§ instance? ISeq o)) => meta
                            (-> (cast' IPersistentMap meta) (IPersistentMap'''assoc RT'LINE_KEY, line) (IPersistentMap'''assoc RT'COLUMN_KEY, column))
                        )]
                    (if (§ instance? IReference o)
                        (do
                            (IReference'''resetMeta (cast' IReference o), (cast' IPersistentMap meta))
                            o
                        )
                        (let [#_"Object" ometa
                                (loop-when [ometa (RT'meta o) #_"ISeq" s (RT'seq meta)] (some? s) => ometa
                                    (let [#_"IMapEntry" kv (cast' IMapEntry (.first s))]
                                        (recur (RT'assoc ometa, (.getKey kv), (.getValue kv)) (.next s))
                                    )
                                )]
                            (IObj'''withMeta (cast' IObj o), (cast' IPersistentMap ometa))
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns SyntaxQuoteReader (§ extends AFn)
    (defn #_"SyntaxQuoteReader" SyntaxQuoteReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--SyntaxQuoteReader [#_"SyntaxQuoteReader" this, #_"Object" reader, #_"Object" backquote, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (try
                (Var'pushThreadBindings (RT'map LispReader'GENSYM_ENV, PersistentHashMap'EMPTY))
                (let [#_"Object" form (LispReader'read-5 r, true, nil, true, (LispReader'ensurePending pendingForms))]
                    (SyntaxQuoteReader'syntaxQuote form)
                )
                (finally
                    (Var'popThreadBindings)
                )
            )
        )
    )

    (defn #_"Object" SyntaxQuoteReader'syntaxQuote [#_"Object" form]
        (let [#_"Object" ret
                (cond
                    (Compiler'isSpecial form)
                        (§ ass ret (RT'list-2 Compiler'QUOTE, form))
                    (§ instance? Symbol form)
                        (let [#_"Symbol" sym (cast' Symbol form)]
                            (cond
                                (and (nil? (:ns sym)) (.endsWith (:name sym), "#"))
                                    (let [#_"IPersistentMap" gmap (cast' IPersistentMap (IDeref'''deref LispReader'GENSYM_ENV))]
                                        (when (some? gmap) => (throw (IllegalStateException. "Gensym literal not in syntax-quote"))
                                            (let [#_"Symbol" gs (cast' Symbol (ILookup'''valAt-2 gmap, sym))]
                                                (when (nil? gs)
                                                    (§ ass gs (Symbol'intern nil, (str (.substring (:name sym), 0, (dec (.length (:name sym)))) "__" (RT'nextID) "__auto__")))
                                                    (Var''set LispReader'GENSYM_ENV, (IPersistentMap'''assoc gmap, sym, gs))
                                                )
                                                (§ ass sym gs)
                                            )
                                        )
                                    )
                                (and (nil? (:ns sym)) (.endsWith (:name sym), "."))
                                    (let [#_"Symbol" csym (Symbol'intern nil, (.substring (:name sym), 0, (dec (.length (:name sym)))))]
                                        (§ ass sym (Symbol'intern nil, (.concat (:name (Compiler'resolveSymbol csym)), ".")))
                                    )
                                (and (nil? (:ns sym)) (.startsWith (:name sym), "."))
                                (do
                                    ;; Simply quote method names.
                                )
                                :else
                                    (let [#_"Object" maybeClass (when (some? (:ns sym)) (Namespace''getMapping (Compiler'currentNS), (Symbol'intern nil, (:ns sym))))]
                                        (if (instance? Class maybeClass) ;; Classname/foo -> package.qualified.Classname/foo
                                            (§ ass sym (Symbol'intern (.getName (cast Class maybeClass)), (:name sym)))
                                            (§ ass sym (Compiler'resolveSymbol sym))
                                        )
                                    )
                            )
                            (§ ass ret (RT'list-2 Compiler'QUOTE, sym))
                        )
                    (LispReader'isUnquote form)
                        (§ return (RT'second form))
                    (LispReader'isUnquoteSplicing form)
                        (throw (IllegalStateException. "splice not in list"))
                    (§ instance? IPersistentCollection form)
                        (cond
                            (§ instance? IRecord form)
                                (§ ass ret form)
                            (§ instance? IPersistentMap form)
                                (let [#_"IPersistentVector" keyvals (SyntaxQuoteReader'flattenMap form)]
                                    (§ ass ret (RT'list-3 LispReader'APPLY, LispReader'HASHMAP, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (Seqable'''seq keyvals))))))
                                )
                            (§ instance? IPersistentVector form)
                                (§ ass ret (RT'list-3 LispReader'APPLY, LispReader'VECTOR, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (Seqable'''seq (cast' IPersistentVector form)))))))
                            (§ instance? IPersistentSet form)
                                (§ ass ret (RT'list-3 LispReader'APPLY, LispReader'HASHSET, (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList (Seqable'''seq (cast' IPersistentSet form)))))))
                            (or (§ instance? ISeq form) (§ instance? IPersistentList form))
                                (let [#_"ISeq" seq (RT'seq form)]
                                    (§ ass ret (if (some? seq) (RT'list-2 LispReader'SEQ, (RT'cons LispReader'CONCAT, (SyntaxQuoteReader'sqExpandList seq))) (RT'cons LispReader'LIST, nil)))
                                )
                            :else
                                (throw (UnsupportedOperationException. "Unknown collection type"))
                        )
                    (or (§ instance? Keyword form) (instance? Number form) (instance? Character form) (instance? String form))
                        (§ ass ret form)
                    :else
                        (§ ass ret (RT'list-2 Compiler'QUOTE, form))
                )]
            (when (and (§ instance? IObj form) (some? (RT'meta form))) => ret
                ;; filter line and column numbers
                (when (pos? (.count (IPersistentMap'''without (IPersistentMap'''without (IMeta'''meta (cast' IObj form)), RT'LINE_KEY), RT'COLUMN_KEY))) => ret
                    (RT'list-3 LispReader'WITH_META, ret, (SyntaxQuoteReader'syntaxQuote (IMeta'''meta (cast' IObj form))))
                )
            )
        )
    )

    (defn- #_"ISeq" SyntaxQuoteReader'sqExpandList [#_"ISeq" seq]
        (loop-when [#_"PersistentVector" v PersistentVector'EMPTY seq seq] (some? seq) => (Seqable'''seq v)
            (let [#_"Object" item (.first seq)
                  v (cond
                        (LispReader'isUnquote item)         (IPersistentVector'''cons v, (RT'list-2 LispReader'LIST, (RT'second item)))
                        (LispReader'isUnquoteSplicing item) (IPersistentVector'''cons v, (RT'second item))
                        :else                               (IPersistentVector'''cons v, (RT'list-2 LispReader'LIST, (SyntaxQuoteReader'syntaxQuote item)))
                    )]
                (recur v (.next seq))
            )
        )
    )

    (defn- #_"IPersistentVector" SyntaxQuoteReader'flattenMap [#_"Object" form]
        (loop-when [#_"IPersistentVector" keyvals PersistentVector'EMPTY #_"ISeq" s (RT'seq form)] (some? s) => keyvals
            (let [#_"IMapEntry" e (cast' IMapEntry (.first s))
                  keyvals (cast' IPersistentVector (IPersistentVector'''cons keyvals, (IMapEntry'''key e)))
                  keyvals (cast' IPersistentVector (IPersistentVector'''cons keyvals, (IMapEntry'''val e)))]
                (recur keyvals (.next s))
            )
        )
    )
)

#_closure
(class-ns UnquoteReader (§ extends AFn)
    (defn #_"UnquoteReader" UnquoteReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--UnquoteReader [#_"UnquoteReader" this, #_"Object" reader, #_"Object" comma, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (let-when [#_"int" ch (LispReader'read1 r)] (not= ch -1) => (throw (RuntimeException. "EOF while reading character"))
                (let [pendingForms (LispReader'ensurePending pendingForms)]
                    (if (= ch \@)
                        (let [#_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
                            (RT'list-2 LispReader'UNQUOTE_SPLICING, o)
                        )
                        (do
                            (LispReader'unread r, ch)
                            (let [#_"Object" o (LispReader'read-5 r, true, nil, true, pendingForms)]
                                (RT'list-2 LispReader'UNQUOTE, o)
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns CharacterReader (§ extends AFn)
    (defn #_"CharacterReader" CharacterReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--CharacterReader [#_"CharacterReader" this, #_"Object" reader, #_"Object" backslash, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader) #_"int" ch (LispReader'read1 r)]
            (when-not (= ch -1) => (throw (RuntimeException. "EOF while reading character"))
                (let [#_"String" token (LispReader'readToken r, (char ch))]
                    (when-not (= (.length token) 1) => (Character/valueOf (.charAt token, 0))
                        (case token
                            "newline"   \newline
                            "space"     \space
                            "tab"       \tab
                            "backspace" \backspace
                            "formfeed"  \formfeed
                            "return"    \return
                            (cond
                                (.startsWith token, "u")
                                    (let [#_"char" c (char (LispReader'readUnicodeChar-4 token, 1, 4, 16))]
                                        (when (<= (§ char "\ud800") c (§ char "\udfff")) ;; surrogate code unit?
                                            (throw (RuntimeException. (str "Invalid character constant: \\u" (Integer/toString c, 16))))
                                        )
                                        c
                                    )
                                (.startsWith token, "o")
                                    (let [#_"int" len (dec (.length token))]
                                        (when (< 3 len)
                                            (throw (RuntimeException. (str "Invalid octal escape sequence length: " len)))
                                        )
                                        (let [#_"int" uc (LispReader'readUnicodeChar-4 token, 1, len, 8)]
                                            (when (< 0377 uc)
                                                (throw (RuntimeException. "Octal escape sequence must be in range [0, 377]."))
                                            )
                                            (char uc)
                                        )
                                    )
                                :else
                                    (throw (RuntimeException. (str "Unsupported character: \\" token)))
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ListReader (§ extends AFn)
    (defn #_"ListReader" ListReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--ListReader [#_"ListReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              [#_"int" line #_"int" column]
                (when (§ instance? LineNumberingPushbackReader r) => [-1 -1]
                    [(LineNumberingPushbackReader''getLineNumber (cast' LineNumberingPushbackReader r)) (dec (LineNumberingPushbackReader''getColumnNumber (cast' LineNumberingPushbackReader r)))]
                )
              #_"List" l (LispReader'readDelimitedList \), r, true, (LispReader'ensurePending pendingForms))]
            (when-not (.isEmpty l) => PersistentList'EMPTY
                (let [#_"IObj" s (cast' IObj (PersistentList'create l))]
                    (when-not (= line -1) => s
                        (IObj'''withMeta s, (RT'map
                            (object-array [
                                RT'LINE_KEY   line
                                RT'COLUMN_KEY column
                            ])
                        ))
                    )
                )
            )
        )
    )
)

#_closure
(class-ns VectorReader (§ extends AFn)
    (defn #_"VectorReader" VectorReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--VectorReader [#_"VectorReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (LazilyPersistentVector'create (LispReader'readDelimitedList \], r, true, (LispReader'ensurePending pendingForms)))
        )
    )
)

#_closure
(class-ns MapReader (§ extends AFn)
    (defn #_"MapReader" MapReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--MapReader [#_"MapReader" this, #_"Object" reader, #_"Object" leftparen, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)
              #_"Object[]" a (.toArray (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms)))]
            (when (= (& (alength a) 1) 1)
                (throw (RuntimeException. "Map literal must contain an even number of forms"))
            )
            (RT'map a)
        )
    )
)

#_closure
(class-ns SetReader (§ extends AFn)
    (defn #_"SetReader" SetReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--SetReader [#_"SetReader" this, #_"Object" reader, #_"Object" leftbracket, #_"Object" pendingForms]
        (let [#_"PushbackReader" r (cast PushbackReader reader)]
            (PersistentHashSet'createWithCheck-1l (LispReader'readDelimitedList \}, r, true, (LispReader'ensurePending pendingForms)))
        )
    )
)

#_closure
(class-ns UnmatchedDelimiterReader (§ extends AFn)
    (defn #_"UnmatchedDelimiterReader" UnmatchedDelimiterReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--UnmatchedDelimiterReader [#_"UnmatchedDelimiterReader" this, #_"Object" reader, #_"Object" rightdelim, #_"Object" pendingForms]
        (throw (RuntimeException. (str "Unmatched delimiter: " rightdelim)))
    )
)

#_closure
(class-ns UnreadableReader (§ extends AFn)
    (defn #_"UnreadableReader" UnreadableReader'new []
        (AFn'new)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--UnreadableReader [#_"UnreadableReader" this, #_"Object" reader, #_"Object" leftangle, #_"Object" pendingForms]
        (throw (RuntimeException. "Unreadable form"))
    )
)

#_stateless
(class-ns LispReader
    (§ def #_"Symbol" LispReader'QUOTE (Symbol'intern "quote"))
    (§ def #_"Symbol" LispReader'THE_VAR (Symbol'intern "var"))

    (§ def #_"Symbol" LispReader'UNQUOTE (Symbol'intern "cloiure.core", "unquote"))
    (§ def #_"Symbol" LispReader'UNQUOTE_SPLICING (Symbol'intern "cloiure.core", "unquote-splicing"))
    (§ def #_"Symbol" LispReader'CONCAT (Symbol'intern "cloiure.core", "concat"))
    (§ def #_"Symbol" LispReader'SEQ (Symbol'intern "cloiure.core", "seq"))
    (§ def #_"Symbol" LispReader'LIST (Symbol'intern "cloiure.core", "list"))
    (§ def #_"Symbol" LispReader'APPLY (Symbol'intern "cloiure.core", "apply"))
    (§ def #_"Symbol" LispReader'HASHMAP (Symbol'intern "cloiure.core", "hash-map"))
    (§ def #_"Symbol" LispReader'HASHSET (Symbol'intern "cloiure.core", "hash-set"))
    (§ def #_"Symbol" LispReader'VECTOR (Symbol'intern "cloiure.core", "vector"))
    (§ def #_"Symbol" LispReader'WITH_META (Symbol'intern "cloiure.core", "with-meta"))
    (§ def #_"Symbol" LispReader'META (Symbol'intern "cloiure.core", "meta"))
    (§ def #_"Symbol" LispReader'DEREF (Symbol'intern "cloiure.core", "deref"))

    (def #_"IFn[]" LispReader'macros (make-array #_"IFn" Object 256))
    (def #_"IFn[]" LispReader'dispatchMacros (make-array #_"IFn" Object 256))

    (def #_"Pattern" LispReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" LispReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" LispReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" LispReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    (§ def #_"Var" LispReader'GENSYM_ENV (Var''setDynamic (Var'create nil)))
    ;; sorted-map num->gensymbol
    (§ def #_"Var" LispReader'ARG_ENV (Var''setDynamic (Var'create nil)))

    (§ static
        (aset LispReader'macros \" (StringReader'new)) ;; oops! "
        (aset LispReader'macros \; (CommentReader'new))
        (aset LispReader'macros \' (WrappingReader'new LispReader'QUOTE))
        (aset LispReader'macros \@ (WrappingReader'new LispReader'DEREF))
        (aset LispReader'macros \^ (MetaReader'new))
        (aset LispReader'macros \` (SyntaxQuoteReader'new))
        (aset LispReader'macros \~ (UnquoteReader'new))
        (aset LispReader'macros \( (ListReader'new))
        (aset LispReader'macros \) (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \[ (VectorReader'new))
        (aset LispReader'macros \] (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \{ (MapReader'new))
        (aset LispReader'macros \} (UnmatchedDelimiterReader'new))
        (aset LispReader'macros \\ (CharacterReader'new))
        (aset LispReader'macros \% (ArgReader'new))
        (aset LispReader'macros \# (DispatchReader'new))

        (aset LispReader'dispatchMacros \^ (MetaReader'new))
        (aset LispReader'dispatchMacros \# (SymbolicValueReader'new))
        (aset LispReader'dispatchMacros \' (VarReader'new))
        (aset LispReader'dispatchMacros \" (RegexReader'new)) ;; oops! "
        (aset LispReader'dispatchMacros \( (FnReader'new))
        (aset LispReader'dispatchMacros \{ (SetReader'new))
        (aset LispReader'dispatchMacros \! (CommentReader'new))
        (aset LispReader'dispatchMacros \< (UnreadableReader'new))
        (aset LispReader'dispatchMacros \_ (DiscardReader'new))
        (aset LispReader'dispatchMacros \: (NamespaceMapReader'new))
    )

    (defn #_"boolean" LispReader'isWhitespace [#_"int" ch]
        (or (Character/isWhitespace ch) (= ch \,))
    )

    (defn #_"void" LispReader'unread [#_"PushbackReader" r, #_"int" ch]
        (when-not (= ch -1)
            (try
                (.unread r, ch)
                (catch IOException e
                    (throw (Util'sneakyThrow e))
                )
            )
        )
        nil
    )

    (defn #_"int" LispReader'read1 [#_"Reader" r]
        (try
            (.read r)
            (catch IOException e
                (throw (Util'sneakyThrow e))
            )
        )
    )

    ;; Reader opts
    (§ def #_"Keyword" LispReader'OPT_EOF (Keyword'intern (Symbol'intern nil, "eof")))

    ;; EOF special value to throw on eof
    (§ def #_"Keyword" LispReader'EOFTHROW (Keyword'intern (Symbol'intern nil, "eofthrow")))

    (defn #_"Object" LispReader'read-1 [#_"PushbackReader" r]
        (LispReader'read-4 r, true, nil, false)
    )

    (defn #_"Object" LispReader'read-4 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (LispReader'read-7 r, eofIsError, eofValue, nil, nil, isRecursive, nil)
    )

    (defn- #_"Object" LispReader'read-5 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"boolean" isRecursive, #_"Object" pendingForms]
        (LispReader'read-7 r, eofIsError, eofValue, nil, nil, isRecursive, (LispReader'ensurePending pendingForms))
    )

    (defn- #_"Object" LispReader'ensurePending [#_"Object" pendingForms]
        (or pendingForms (LinkedList.))
    )

    (defn- #_"Object" LispReader'read-7 [#_"PushbackReader" r, #_"boolean" eofIsError, #_"Object" eofValue, #_"Character" returnOn, #_"Object" returnOnValue, #_"boolean" isRecursive, #_"Object" pendingForms]
        (try
            (loop-when [] (or (not (instance? List pendingForms)) (.isEmpty (cast List pendingForms))) => (.remove (cast List pendingForms), 0)
                (let [#_"int" ch (loop-when-recur [ch (LispReader'read1 r)] (LispReader'isWhitespace ch) [(LispReader'read1 r)] => ch)]
                    (cond
                        (= ch -1)
                            (if eofIsError (throw (RuntimeException. "EOF while reading")) eofValue)
                        (and (some? returnOn) (= (.charValue returnOn) ch))
                            returnOnValue
                        (Character/isDigit ch)
                            (LispReader'readNumber r, (char ch))
                        :else
                            (let [#_"IFn" macroFn (LispReader'getMacro ch)]
                                (if (some? macroFn)
                                    (let [#_"Object" ret (IFn'''invoke-4 macroFn, r, (char ch), pendingForms)]
                                        ;; no op macros return the reader
                                        (recur-if (= ret r) [] => ret)
                                    )
                                    (do
                                        (when (any = ch \+ \-)
                                            (let [#_"int" ch2 (LispReader'read1 r)]
                                                (when (Character/isDigit ch2)
                                                    (LispReader'unread r, ch2)
                                                    (§ return (LispReader'readNumber r, (char ch)))
                                                )
                                                (LispReader'unread r, ch2)
                                            )
                                        )
                                        (LispReader'interpretToken (LispReader'readToken r, (char ch)))
                                    )
                                )
                            )
                    )
                )
            )
            (catch Exception e
                (when (and (not isRecursive) (§ instance? LineNumberingPushbackReader r)) => (throw (Util'sneakyThrow e))
                    (let [#_"LineNumberingPushbackReader" rdr (cast' LineNumberingPushbackReader r)]
                        (throw (LispReaderException'new (LineNumberingPushbackReader''getLineNumber rdr), (LineNumberingPushbackReader''getColumnNumber rdr), e))
                    )
                )
            )
        )
    )

    (defn- #_"String" LispReader'readToken [#_"PushbackReader" r, #_"char" ch]
        (let [#_"StringBuilder" sb (StringBuilder.) _ (.append sb, ch)]
            (loop []
                (let [ch (LispReader'read1 r)]
                    (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isTerminatingMacro ch))
                        (do
                            (LispReader'unread r, ch)
                            (.toString sb)
                        )
                        (do
                            (.append sb, (char ch))
                            (recur)
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'readNumber [#_"PushbackReader" r, #_"char" ch]
        (let [#_"String" s
                (let [#_"StringBuilder" sb (StringBuilder.) _ (.append sb, ch)]
                    (loop []
                        (let [ch (LispReader'read1 r)]
                            (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isMacro ch))
                                (do
                                    (LispReader'unread r, ch)
                                    (.toString sb)
                                )
                                (do
                                    (.append sb, (char ch))
                                    (recur)
                                )
                            )
                        )
                    )
                )]
            (or (LispReader'matchNumber s) (throw (NumberFormatException. (str "Invalid number: " s))))
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-4 [#_"String" token, #_"int" offset, #_"int" n, #_"int" base]
        (when (= (.length token) (+ offset n)) => (throw (IllegalArgumentException. (str "Invalid unicode character: \\" token)))
            (loop-when [#_"int" uc 0 #_"int" i offset] (< i (+ offset n)) => (char uc)
                (let [#_"int" d (Character/digit (.charAt token, i), base)]
                    (when-not (= d -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (.charAt token, i))))
                        (recur (+ (* uc base) d) (inc i))
                    )
                )
            )
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-5 [#_"PushbackReader" r, #_"int" ch, #_"int" base, #_"int" n, #_"boolean" exact?]
        (let-when-not [#_"int" uc (Character/digit ch, base)] (= uc -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (char ch))))
            (let [[uc #_"int" i]
                    (loop-when [uc uc i 1] (< i n) => [uc i]
                        (let [ch (LispReader'read1 r)]
                            (if (or (= ch -1) (LispReader'isWhitespace ch) (LispReader'isMacro ch))
                                (do
                                    (LispReader'unread r, ch)
                                    [uc i]
                                )
                                (let [#_"int" d (Character/digit ch, base)]
                                    (when-not (= d -1) => (throw (IllegalArgumentException. (str "Invalid digit: " (char ch))))
                                        (recur (+ (* uc base) d) (inc i))
                                    )
                                )
                            )
                        )
                    )]
                (when (or (= i n) (not exact?)) => (throw (IllegalArgumentException. (str "Invalid character length: " i ", should be: " n)))
                    uc
                )
            )
        )
    )

    (defn- #_"Object" LispReader'interpretToken [#_"String" s]
        (case s "nil" nil "true" RT'T "false" RT'F
            (or (LispReader'matchSymbol s) (throw (RuntimeException. (str "Invalid token: " s))))
        )
    )

    (defn- #_"Object" LispReader'matchSymbol [#_"String" s]
        (let-when [#_"Matcher" m (.matcher LispReader'symbolPat, s)] (.matches m)
            (let [#_"int" gc (.groupCount m) #_"String" ns (.group m, 1) #_"String" name (.group m, 2)]
                (cond
                    (or (and (some? ns) (.endsWith ns, ":/")) (.endsWith name, ":") (not= (.indexOf s, "::", 1) -1))
                        nil
                    (.startsWith s, "::")
                        (let [#_"Symbol" ks (Symbol'intern (.substring s, 2))
                              #_"Namespace" kns (if (some? (:ns ks)) (Namespace''lookupAlias (Compiler'currentNS), (Symbol'intern (:ns ks))) (Compiler'currentNS))]
                            ;; auto-resolving keyword
                            (when (some? kns)
                                (Keyword'intern (Symbol'intern (:name (:name kns)), (:name ks)))
                            )
                        )
                    :else
                        (let [#_"boolean" isKeyword (= (.charAt s, 0) \:) #_"Symbol" sym (Symbol'intern (.substring s, (if isKeyword 1 0)))]
                            (if isKeyword (Keyword'intern sym) sym)
                        )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'matchNumber [#_"String" s]
        (let [_ (or
                    (let-when [#_"Matcher" m (.matcher LispReader'intPat, s)] (.matches m)
                        (if (some? (.group m, 2))
                            (if (some? (.group m, 8))
                                BigInt'ZERO
                                (Numbers'num-1l 0)
                            )
                            (let [[#_"String" n #_"int" radix]
                                    (cond-let
                                        [n (.group m, 3)] [n 10]
                                        [n (.group m, 4)] [n 16]
                                        [n (.group m, 5)] [n 8]
                                        [n (.group m, 7)] [n (Integer/parseInt (.group m, 6))]
                                    )]
                                (when (some? n) => :nil
                                    (let [#_"BigInteger" bn (BigInteger. n, radix) bn (if (= (.group m, 1) "-") (.negate bn) bn)]
                                        (cond
                                            (some? (.group m, 8))  (BigInt'fromBigInteger bn)
                                            (< (.bitLength bn) 64) (Numbers'num-1l (.longValue bn))
                                            :else                  (BigInt'fromBigInteger bn)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (let-when [#_"Matcher" m (.matcher LispReader'floatPat, s)] (.matches m)
                        (if (some? (.group m, 4))
                            (§ unsure BigDecimal. (.group m, 1))
                            (Double/parseDouble s)
                        )
                    )
                    (let-when [#_"Matcher" m (.matcher LispReader'ratioPat, s)] (.matches m)
                        (let [#_"String" numerator (.group m, 1) numerator (if (.startsWith numerator, "+") (.substring numerator, 1) numerator)]
                            (Numbers'divide-2oo
                                (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. numerator))),
                                (Numbers'reduceBigInt (BigInt'fromBigInteger (BigInteger. (.group m, 2))))
                            )
                        )
                    )
                )]
            (when-not (= _ :nil) _)
        )
    )

    (defn- #_"IFn" LispReader'getMacro [#_"int" ch]
        (when (< ch (alength LispReader'macros))
            (aget LispReader'macros ch)
        )
    )

    (defn- #_"boolean" LispReader'isMacro [#_"int" ch]
        (and (< ch (alength LispReader'macros)) (some? (aget LispReader'macros ch)))
    )

    (defn- #_"boolean" LispReader'isTerminatingMacro [#_"int" ch]
        (and (not= ch \#) (not= ch \') (not= ch \%) (LispReader'isMacro ch))
    )

    (defn #_"Symbol" LispReader'garg [#_"int" n]
        (Symbol'intern nil, (str (if (= n -1) "rest" (str "p" n)) "__" (RT'nextID) "#"))
    )

    (defn #_"Symbol" LispReader'registerArg [#_"int" n]
        (let [#_"PersistentTreeMap" args (cast' PersistentTreeMap (IDeref'''deref LispReader'ARG_ENV))]
            (when (some? args) => (throw (IllegalStateException. "arg literal not in #()"))
                (or (cast' Symbol (ILookup'''valAt-2 args, n))
                    (let [#_"Symbol" sym (LispReader'garg n)]
                        (Var''set LispReader'ARG_ENV, (IPersistentMap'''assoc args, n, sym))
                        sym
                    )
                )
            )
        )
    )

    (defn #_"boolean" LispReader'isUnquoteSplicing [#_"Object" form]
        (and (§ instance? ISeq form) (Util'equals (RT'first form), LispReader'UNQUOTE_SPLICING))
    )

    (defn #_"boolean" LispReader'isUnquote [#_"Object" form]
        (and (§ instance? ISeq form) (Util'equals (RT'first form), LispReader'UNQUOTE))
    )

    ;; Sentinel values for reading lists
    (def- #_"Object" LispReader'READ_EOF (Object.))
    (def- #_"Object" LispReader'READ_FINISHED (Object.))

    (defn #_"List" LispReader'readDelimitedList [#_"char" delim, #_"PushbackReader" r, #_"boolean" isRecursive, #_"Object" pendingForms]
        (let [#_"int" firstline (if (§ instance? LineNumberingPushbackReader r) (LineNumberingPushbackReader''getLineNumber (cast' LineNumberingPushbackReader r)) -1)
              #_"ArrayList" a (ArrayList.)]
            (loop []
                (let [#_"Object" form (LispReader'read-7 r, false, LispReader'READ_EOF, delim, LispReader'READ_FINISHED, isRecursive, pendingForms)]
                    (condp = form
                        LispReader'READ_EOF
                            (if (neg? firstline)
                                (throw (RuntimeException. "EOF while reading"))
                                (throw (RuntimeException. (str "EOF while reading, starting at line " firstline)))
                            )
                        LispReader'READ_FINISHED
                            a
                        (do
                            (.add a, form)
                            (recur)
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(class-ns RetryEx (§ extends Error)
    (defn #_"RetryEx" RetryEx'new []
        (§ foreign Error'new)
    )
)

(class-ns AbortException (§ extends Exception)
    (defn #_"AbortException" AbortException'new []
        (§ foreign Exception'new)
    )
)

(class-ns LockingTransactionInfo
    (defn- #_"LockingTransactionInfo" LockingTransactionInfo'init []
        (hash-map
            #_"AtomicInteger" :status nil
            #_"long" :startPoint 0
            #_"CountDownLatch" :latch nil
        )
    )

    (defn #_"LockingTransactionInfo" LockingTransactionInfo'new [#_"int" status, #_"long" startPoint]
        (let [this (LockingTransactionInfo'init)]
            (§ ass this (assoc this :status (AtomicInteger. status)))
            (§ ass this (assoc this :startPoint startPoint))
            (§ ass this (assoc this :latch (CountDownLatch. 1)))
            this
        )
    )

    #_method
    (defn #_"boolean" LockingTransactionInfo''running [#_"LockingTransactionInfo" this]
        (let [#_"int" s (.get (:status this))]
            (or (= s LockingTransaction'RUNNING) (= s LockingTransaction'COMMITTING))
        )
    )
)

(class-ns CFn
    (defn- #_"CFn" CFn'init []
        (hash-map
            #_"IFn" :fn nil
            #_"ISeq" :args nil
        )
    )

    (defn #_"CFn" CFn'new [#_"IFn" fn, #_"ISeq" args]
        (let [this (CFn'init)]
            (§ ass this (assoc this :fn fn))
            (§ ass this (assoc this :args args))
            this
        )
    )
)

(class-ns Notify
    (defn- #_"Notify" Notify'init []
        (hash-map
            #_"Ref" :ref nil
            #_"Object" :oldval nil
            #_"Object" :newval nil
        )
    )

    (defn #_"Notify" Notify'new [#_"Ref" ref, #_"Object" oldval, #_"Object" newval]
        (let [this (Notify'init)]
            (§ ass this (assoc this :ref ref))
            (§ ass this (assoc this :oldval oldval))
            (§ ass this (assoc this :newval newval))
            this
        )
    )
)

(class-ns LockingTransaction
    (def #_"int" LockingTransaction'RETRY_LIMIT 10000)
    (def #_"int" LockingTransaction'LOCK_WAIT_MSECS 100)
    (def #_"long" LockingTransaction'BARGE_WAIT_NANOS (* 10 1000000))

    (def #_"int" LockingTransaction'RUNNING 0)
    (def #_"int" LockingTransaction'COMMITTING 1)
    (def #_"int" LockingTransaction'RETRY 2)
    (def #_"int" LockingTransaction'KILLED 3)
    (def #_"int" LockingTransaction'COMMITTED 4)

    (def #_"ThreadLocal<LockingTransaction>" LockingTransaction'transaction (ThreadLocal.))

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (def- #_"AtomicLong" LockingTransaction'lastPoint (AtomicLong.))

    (defn- #_"LockingTransaction" LockingTransaction'init []
        (hash-map
            #_"LockingTransactionInfo" :info nil
            #_"long" :readPoint 0
            #_"long" :startPoint 0
            #_"long" :startTime 0

            #_"RetryEx" :retryex (RetryEx'new)
            #_"ArrayList<AgentAction>" :actions (ArrayList.)
            #_"HashMap<Ref, Object>" :vals (HashMap.)
            #_"HashSet<Ref>" :sets (HashSet.)
            #_"TreeMap<Ref, ArrayList<CFn>>" :commutes (TreeMap.)

            #_"HashSet<Ref>" :ensures (HashSet.) ;; all hold readLock
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'new []
        (LockingTransaction'init)
    )

    #_method
    (defn #_"void" LockingTransaction''getReadPoint [#_"LockingTransaction" this]
        (§ ass this (assoc this :readPoint (.incrementAndGet LockingTransaction'lastPoint)))
        nil
    )

    #_method
    (defn #_"long" LockingTransaction''getCommitPoint [#_"LockingTransaction" this]
        (.incrementAndGet LockingTransaction'lastPoint)
    )

    #_method
    (defn #_"void" LockingTransaction''stop [#_"LockingTransaction" this, #_"int" status]
        (when (some? (:info this))
            (§ sync (:info this)
                (.set (:status (:info this)), status)
                (.countDown (:latch (:info this)))
            )
            (§ ass this (assoc this :info nil))
            (.clear (:vals this))
            (.clear (:sets this))
            (.clear (:commutes this))
        )
        nil
    )

    #_method
    (defn #_"void" LockingTransaction''tryWriteLock [#_"LockingTransaction" this, #_"Ref" ref]
        (try
            (when (not (.tryLock (.writeLock (:lock ref)), LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS))
                (throw (:retryex this))
            )
            (catch InterruptedException e
                (throw (:retryex this))
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (defn #_"Object" LockingTransaction''lock [#_"LockingTransaction" this, #_"Ref" ref]
        ;; can't upgrade readLock, so release it
        (LockingTransaction''releaseIfEnsured this, ref)

        (let [#_"boolean" unlocked true]
            (try
                (LockingTransaction''tryWriteLock this, ref)
                (§ ass unlocked false)

                (when-not (and (some? (:tvals ref)) (< (:readPoint this) (:point (:tvals ref)))) => (throw (:retryex this))
                    (let [#_"LockingTransactionInfo" refinfo (:tinfo ref)]
                        ;; write lock conflict
                        (if (and (some? refinfo) (not= refinfo (:info this)) (LockingTransactionInfo''running refinfo) (not (LockingTransaction''barge this, refinfo)))
                            (do
                                (.unlock (.writeLock (:lock ref)))
                                (§ ass unlocked true)
                                (LockingTransaction''blockAndBail this, refinfo)
                            )
                            (do
                                (§ ass (:tinfo ref) (:info this))
                                (when (some? (:tvals ref)) (:val (:tvals ref)))
                            )
                        )
                    )
                )
                (finally
                    (when-not unlocked
                        (.unlock (.writeLock (:lock ref)))
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"Object" LockingTransaction''blockAndBail [#_"LockingTransaction" this, #_"LockingTransactionInfo" refinfo]
        ;; stop prior to blocking
        (LockingTransaction''stop this, LockingTransaction'RETRY)
        (try
            (.await (:latch refinfo), LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS)
            (catch InterruptedException _
                ;; ignore
            )
        )
        (throw (:retryex this))
    )

    #_method
    (defn- #_"void" LockingTransaction''releaseIfEnsured [#_"LockingTransaction" this, #_"Ref" ref]
        (when (.contains (:ensures this), ref)
            (.remove (:ensures this), ref)
            (.unlock (.readLock (:lock ref)))
        )
        nil
    )

    #_method
    (defn #_"void" LockingTransaction''abort [#_"LockingTransaction" this] #_(§ throws AbortException)
        (LockingTransaction''stop this, LockingTransaction'KILLED)
        (throw (AbortException'new))
    )

    #_method
    (defn- #_"boolean" LockingTransaction''bargeTimeElapsed [#_"LockingTransaction" this]
        (< LockingTransaction'BARGE_WAIT_NANOS (- (System/nanoTime) (:startTime this)))
    )

    #_method
    (defn- #_"boolean" LockingTransaction''barge [#_"LockingTransaction" this, #_"LockingTransactionInfo" refinfo]
        (let [#_"boolean" barged false]
            ;; if this transaction is older, try to abort the other
            (when (and (LockingTransaction''bargeTimeElapsed this) (< (:startPoint this) (:startPoint refinfo)))
                (§ ass barged (.compareAndSet (:status refinfo), LockingTransaction'RUNNING, LockingTransaction'KILLED))
                (when barged
                    (.countDown (:latch refinfo))
                )
            )
            barged
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'getEx []
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (and (some? t) (some? (:info t))) => (throw (IllegalStateException. "No transaction running"))
                t
            )
        )
    )

    (defn #_"boolean" LockingTransaction'isRunning []
        (some? (LockingTransaction'getRunning))
    )

    (defn #_"LockingTransaction" LockingTransaction'getRunning []
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (and (some? t) (some? (:info t)))
                t
            )
        )
    )

    (defn #_"Object" LockingTransaction'runInTransaction [#_"Callable" fn] #_(§ throws Exception)
        (let [#_"LockingTransaction" t (.get LockingTransaction'transaction)]
            (when (nil? t) => (if (some? (:info t)) (.call fn) (LockingTransaction''run t, fn))
                (let [t (LockingTransaction'new)]
                    (.set LockingTransaction'transaction, t)
                    (try
                        (LockingTransaction''run t, fn)
                        (finally
                            (.remove LockingTransaction'transaction)
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"Object" LockingTransaction''run [#_"LockingTransaction" this, #_"Callable" fn] #_(§ throws Exception)
        (let [#_"ArrayList<Ref>" locked (ArrayList.) #_"ArrayList<Notify>" notify (ArrayList.)]
            (loop [#_"boolean" done false #_"Object" ret nil #_"int" i 0]
                (if (and (not done) (< i LockingTransaction'RETRY_LIMIT))
                    (let [[done ret]
                            (try
                                (LockingTransaction''getReadPoint this)
                                (when (zero? i)
                                    (§ ass this (assoc this :startPoint (:readPoint this)))
                                    (§ ass this (assoc this :startTime (System/nanoTime)))
                                )
                                (§ ass this (assoc this :info (LockingTransactionInfo'new LockingTransaction'RUNNING, (:startPoint this))))
                                (let [ret (.call fn)]
                                    ;; make sure no one has killed us before this point, and can't from now on
                                    (when (.compareAndSet (:status (:info this)), LockingTransaction'RUNNING, LockingTransaction'COMMITTING) => [false ret]
                                        (let [#_"Iterator" it (.iterator (.entrySet (:commutes this)))]
                                            (while (.hasNext it)
                                                (let [#_"Map$Entry<Ref, ArrayList<CFn>>" e (.next it) #_"Ref" ref (.getKey e)]
                                                    (when-not (.contains (:sets this), ref)
                                                        (let [#_"boolean" wasEnsured (.contains (:ensures this), ref)]
                                                            ;; can't upgrade readLock, so release it
                                                            (LockingTransaction''releaseIfEnsured this, ref)
                                                            (LockingTransaction''tryWriteLock this, ref)
                                                            (.add locked, ref)
                                                            (when (and wasEnsured (some? (:tvals ref)) (< (:readPoint this) (:point (:tvals ref))))
                                                                (throw (:retryex this))
                                                            )
                                                            (let [#_"LockingTransactionInfo" refinfo (:tinfo ref)]
                                                                (when (and (some? refinfo) (not= refinfo (:info this)) (LockingTransactionInfo''running refinfo) (not (LockingTransaction''barge this, refinfo)))
                                                                    (throw (:retryex this))
                                                                )
                                                                (let [#_"Object" val (when (some? (:tvals ref)) (:val (:tvals ref)))]
                                                                    (.put (:vals this), ref, val)
                                                                    (doseq [#_"CFn" f (.getValue e)]
                                                                        (.put (:vals this), ref, (IFn'''applyTo (:fn f), (RT'cons (.get (:vals this), ref), (:args f))))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (doseq [#_"Ref" ref (:sets this)]
                                            (LockingTransaction''tryWriteLock this, ref)
                                            (.add locked, ref)
                                        )
                                        ;; validate and enqueue notifications
                                        (doseq [#_"Map$Entry<Ref, Object>" e (.entrySet (:vals this))]
                                            (let [#_"Ref" ref (.getKey e)]
                                                (ARef''validate ref, (IRef'''getValidator ref), (.getValue e))
                                            )
                                        )
                                        ;; at this point, all values calced, all refs to be written locked
                                        ;; no more client code to be called
                                        (let [#_"long" commitPoint (LockingTransaction''getCommitPoint this) #_"Iterator" it (.iterator (.entrySet (:vals this)))]
                                            (while (.hasNext it)
                                                (let [#_"Map$Entry<Ref, Object>" e (.next it) #_"Ref" ref (.getKey e)
                                                      #_"Object" oldval (when (some? (:tvals ref)) (:val (:tvals ref))) #_"Object" newval (.getValue e)
                                                      #_"int" hcount (Ref''histCount ref)]
                                                    (cond
                                                        (nil? (:tvals ref))
                                                        (do
                                                            (§ ass (:tvals ref) (RefTVal'new-2 newval, commitPoint))
                                                        )
                                                        (or (and (pos? (.get (:faults ref))) (< hcount (:maxHistory ref))) (< hcount (:minHistory ref)))
                                                        (do
                                                            (§ ass (:tvals ref) (RefTVal'new-3 newval, commitPoint, (:tvals ref)))
                                                            (.set (:faults ref), 0)
                                                        )
                                                        :else
                                                        (do
                                                            (§ ass (:tvals ref) (:next (:tvals ref)))
                                                            (§ ass (:val (:tvals ref)) newval)
                                                            (§ ass (:point (:tvals ref)) commitPoint)
                                                        )
                                                    )
                                                    (when (pos? (.count (IRef'''getWatches ref)))
                                                        (.add notify, (Notify'new ref, oldval, newval))
                                                    )
                                                )
                                            )
                                            (.set (:status (:info this)), LockingTransaction'COMMITTED)
                                            [true ret]
                                        )
                                    )
                                )
                                (§ catch RetryEx _
                                    ;; eat this so we retry rather than fall out
                                    [false ret]
                                )
                                (finally
                                    (loop-when-recur [#_"int" k (dec (.size locked))] (<= 0 k) [(dec k)]
                                        (.unlock (.writeLock (:lock (.get locked, k))))
                                    )
                                    (.clear locked)
                                    (doseq [#_"Ref" r (:ensures this)]
                                        (.unlock (.readLock (:lock r)))
                                    )
                                    (.clear (:ensures this))
                                    (LockingTransaction''stop this, (if (§ naughty done) LockingTransaction'COMMITTED LockingTransaction'RETRY))
                                    (try
                                        (when (§ naughty done) ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" n notify]
                                                (ARef''notifyWatches (:ref n), (:oldval n), (:newval n))
                                            )
                                            (doseq [#_"AgentAction" action (:actions this)]
                                                (Agent'dispatchAction action)
                                            )
                                        )
                                        (finally
                                            (.clear notify)
                                            (.clear (:actions this))
                                        )
                                    )
                                )
                            )]
                        (recur done ret (inc i))
                    )
                    (when done => (throw (RuntimeException. "Transaction failed after reaching retry limit"))
                        ret
                    )
                )
            )
        )
    )

    #_method
    (defn #_"void" LockingTransaction''enqueue [#_"LockingTransaction" this, #_"AgentAction" action]
        (.add (:actions this), action)
        nil
    )

    #_method
    (defn #_"Object" LockingTransaction''doGet [#_"LockingTransaction" this, #_"Ref" ref]
        (when (LockingTransactionInfo''running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:vals this), ref) => (.get (:vals this), ref)
                (let [_ (try
                            (.lock (.readLock (:lock ref)))
                            (let-when [#_"RefTVal" ver (:tvals ref)] (some? ver) => (throw (IllegalStateException. (str ref " is unbound.")))
                                (loop-when [ver ver] (< (:readPoint this) (:point ver)) => (:val ver)
                                    (let-when [ver (:prior ver)] (not= ver (:tvals ref)) => :nil
                                        (recur ver)
                                    )
                                )
                            )
                            (finally
                                (.unlock (.readLock (:lock ref)))
                            )
                        )]
                    (when (= _ :nil) => _
                        ;; no version of val precedes the read point
                        (.incrementAndGet (:faults ref))
                        (throw (:retryex this))
                    )
                )
            )
        )
    )

    #_method
    (defn #_"Object" LockingTransaction''doSet [#_"LockingTransaction" this, #_"Ref" ref, #_"Object" val]
        (when (LockingTransactionInfo''running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:commutes this), ref) => (throw (IllegalStateException. "Can't set after commute"))
                (when-not (.contains (:sets this), ref)
                    (.add (:sets this), ref)
                    (LockingTransaction''lock this, ref)
                )
                (.put (:vals this), ref, val)
                val
            )
        )
    )

    #_method
    (defn #_"void" LockingTransaction''doEnsure [#_"LockingTransaction" this, #_"Ref" ref]
        (when (LockingTransactionInfo''running (:info this)) => (throw (:retryex this))
            (when-not (.contains (:ensures this), ref)
                (.lock (.readLock (:lock ref)))
                ;; someone completed a write after our snapshot
                (let-when [#_"RefTVal" ver (:tvals ref)] (and (some? ver) (< (:readPoint this) (:point ver)))
                    (.unlock (.readLock (:lock ref)))
                    (throw (:retryex this))
                )
                (let-when [#_"LockingTransactionInfo" refinfo (:tinfo ref)] (and (some? refinfo) (LockingTransactionInfo''running refinfo)) => (.add (:ensures this), ref)
                    ;; writer exists
                    (.unlock (.readLock (:lock ref)))
                    (when-not (= refinfo (:info this)) ;; not us, ensure is doomed
                        (LockingTransaction''blockAndBail this, refinfo)
                    )
                )
            )
        )
        nil
    )

    #_method
    (defn #_"Object" LockingTransaction''doCommute [#_"LockingTransaction" this, #_"Ref" ref, #_"IFn" fn, #_"ISeq" args]
        (when (LockingTransactionInfo''running (:info this)) => (throw (:retryex this))
            (when-not (.containsKey (:vals this), ref)
                (let [#_"Object" val
                        (try
                            (.lock (.readLock (:lock ref)))
                            (when (some? (:tvals ref)) (:val (:tvals ref)))
                            (finally
                                (.unlock (.readLock (:lock ref)))
                            )
                        )]
                    (.put (:vals this), ref, val)
                )
            )
            (let [#_"ArrayList<CFn>" fns (.get (:commutes this), ref)]
                (when (nil? fns)
                    (.put (:commutes this), ref, (§ ass fns (ArrayList.)))
                )
                (.add fns, (CFn'new fn, args))
                (let [#_"Object" ret (IFn'''applyTo fn, (RT'cons (.get (:vals this), ref), args))]
                    (.put (:vals this), ref, ret)
                    ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

#_non-static
(class-ns LongRangeIterator (§ implements Iterator)
    (defn- #_"LongRangeIterator" LongRangeIterator'init []
        (hash-map
            #_"long" :next 0
            #_"boolean" :hasNext false
        )
    )

    (defn #_"LongRangeIterator" LongRangeIterator'new []
        (let [this (LongRangeIterator'init)]
            (§ ass this (assoc this :next (:start this)))
            (§ ass this (assoc this :hasNext true))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"LongRangeIterator" this]
        (:hasNext this)
    )

    #_foreign
    (§ defn #_"Object" next [#_"LongRangeIterator" this]
        (when (:hasNext this) => (throw (NoSuchElementException.))
            (let [#_"long" ret (:next this)]
                (try
                    (§ ass this (assoc this :next (Numbers'add-2ll (:next this), (:step this))))
                    (§ ass this (assoc this :hasNext (not (LongRangeBoundsCheck'''exceededBounds (:boundsCheck this), (:next this)))))
                    (catch ArithmeticException e
                        (§ ass this (assoc this :hasNext false))
                    )
                )
                ret
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"LongRangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

#_private
(class-ns LongChunk (§ implements IChunk)
    (defn- #_"LongChunk" LongChunk'init []
        (hash-map
            #_"long" :start 0
            #_"long" :step 0
            #_"int" :count 0
        )
    )

    (defn #_"LongChunk" LongChunk'new [#_"long" start, #_"long" step, #_"int" count]
        (let [this (LongChunk'init)]
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :count count))
            this
        )
    )

    #_method
    (defn #_"long" LongChunk''first [#_"LongChunk" this]
        (:start this)
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--LongChunk [#_"LongChunk" this, #_"int" i]
        (+ (:start this) (* i (:step this)))
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--LongChunk [#_"LongChunk" this, #_"int" i, #_"Object" notFound]
        (if (< -1 i (:count this)) (+ (:start this) (* i (:step this))) notFound)
    )

    #_override
    (defn #_"int" Counted'''count--LongChunk [#_"LongChunk" this]
        (:count this)
    )

    #_override
    (defn #_"LongChunk" IChunk'''dropFirst--LongChunk [#_"LongChunk" this]
        (when (< 1 (:count this)) => (throw (IllegalStateException. "dropFirst of empty chunk"))
            (LongChunk'new (+ (:start this) (:step this)), (:step this), (dec (:count this)))
        )
    )

    #_override
    (defn #_"Object" IChunk'''reduce--LongChunk [#_"LongChunk" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"long" x (:start this) #_"int" i 0] (< i (:count this)) => r
            (let-when-not [r (IFn'''invoke-3 f, r, x)] (RT'isReduced r) => r
                (recur r (+ x (:step this)) (inc i))
            )
        )
    )
)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (def- #_"int" LongRange'CHUNK_SIZE 32)

    (defn- #_"LongRangeBoundsCheck" LongRange'positiveStep [#_"long" end]
        (§ reify LongRangeBoundsCheck()
            #_override
            (defn #_"boolean" LongRangeBoundsCheck'''exceededBounds--LongRangeBoundsCheck [#_"LongRangeBoundsCheck" this, #_"long" val]
                (<= end val)
            )
        )
    )

    (defn- #_"LongRangeBoundsCheck" LongRange'negativeStep [#_"long" end]
        (§ reify LongRangeBoundsCheck()
            #_override
            (defn #_"boolean" LongRangeBoundsCheck'''exceededBounds--LongRangeBoundsCheck [#_"LongRangeBoundsCheck" this, #_"long" val]
                (<= val end)
            )
        )
    )

    (defn- #_"LongRange" LongRange'init []
        (hash-map
            ;; Invariants guarantee this is never an empty or infinite seq
            #_"long" :start 0
            #_"long" :end 0
            #_"long" :step 0
            #_"LongRangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"LongChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"LongRange" LongRange'new-4 [#_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck]
        (let [this (merge (ASeq'new-0) (LongRange'init))]
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-6 [#_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new-0) (LongRange'init))]
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            (§ ass this (assoc this :_chunk chunk))
            (§ ass this (assoc this :_chunkNext chunkNext))
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-7 [#_"IPersistentMap" meta, #_"long" start, #_"long" end, #_"long" step, #_"LongRangeBoundsCheck" boundsCheck, #_"LongChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new-1 meta) (LongRange'init))]
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            (§ ass this (assoc this :_chunk chunk))
            (§ ass this (assoc this :_chunkNext chunkNext))
            this
        )
    )

    (defn #_"ISeq" LongRange'create-1 [#_"long" end]
        (if (< 0 end)
            (LongRange'new-4 0, end, 1, (LongRange'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" LongRange'create-2 [#_"long" start, #_"long" end]
        (if (< start end)
            (LongRange'new-4 start, end, 1, (LongRange'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" LongRange'create-3 [#_"long" start, #_"long" end, #_"long" step]
        (cond
            (pos? step) (if (< start end) (LongRange'new-4 start, end, step, (LongRange'positiveStep end)) PersistentList'EMPTY)
            (neg? step) (if (< end start) (LongRange'new-4 start, end, step, (LongRange'negativeStep end)) PersistentList'EMPTY)
            :else       (if (= start end) PersistentList'EMPTY (Repeat'create-1 start))
        )
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--LongRange [#_"LongRange" this, #_"IPersistentMap" meta]
        (if (= meta (:_meta this))
            this
            (LongRange'new-7 meta, (:start this), (:end this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--LongRange [#_"LongRange" this]
        (:start this)
    )

    #_method
    (defn #_"void" LongRange''forceChunk [#_"LongRange" this]
        (when (nil? (:_chunk this))
            (let [#_"long" n
                    (try
                        (LongRange''rangeCount this, (:start this), (:end this), (:step this))
                        (catch ArithmeticException e
                            ;; size of total range is > Long.MAX_VALUE, so must step to count
                            ;; this only happens in pathological range cases like:
                            ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                            (LongRange''steppingCount this, (:start this), (:end this), (:step this))
                        )
                    )]
                (if (< LongRange'CHUNK_SIZE n)
                    ;; not last chunk
                    (let [#_"long" nextStart (+ (:start this) (* (:step this) LongRange'CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (§ ass this (assoc this :_chunkNext (LongRange'new-4 nextStart, (:end this), (:step this), (:boundsCheck this))))
                        (§ ass this (assoc this :_chunk (LongChunk'new (:start this), (:step this), LongRange'CHUNK_SIZE)))
                    )
                    ;; last chunk
                    (§ ass this (assoc this :_chunk (LongChunk'new (:start this), (:step this), (int n)))) ;; n must be <= CHUNK_SIZE
                )
            )
        )
        nil
    )

    #_override
    (defn #_"ISeq" ISeq'''next--LongRange [#_"LongRange" this]
        (let-when [#_"ISeq" _next (:_next this)] (nil? _next) => _next
            (LongRange''forceChunk this)
            (when (< 1 (.count (:_chunk this))) => (IChunkedSeq'''chunkedNext this)
                (let [#_"LongChunk" _rest (IChunk'''dropFirst (:_chunk this))
                      _next (LongRange'new-6 (LongChunk''first _rest), (:end this), (:step this), (:boundsCheck this), _rest, (:_chunkNext this))]
                    (§ ass this (assoc this :_next _next))
                    _next
                )
            )
        )
    )

    #_override
    (defn #_"IChunk" IChunkedSeq'''chunkedFirst--LongRange [#_"LongRange" this]
        (LongRange''forceChunk this)
        (:_chunk this)
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedNext--LongRange [#_"LongRange" this]
        (Seqable'''seq (IChunkedSeq'''chunkedMore this))
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedMore--LongRange [#_"LongRange" this]
        (LongRange''forceChunk this)
        (or (:_chunkNext this) PersistentList'EMPTY)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (defn #_"long" LongRange''steppingCount [#_"LongRange" this, #_"long" start, #_"long" end, #_"long" step]
        (loop-when [#_"long" s start #_"long" n 1] (<= n LongRange'CHUNK_SIZE) => n
            (let [[s n]
                    (try
                        (let [s (Numbers'add-2ll s, step)]
                            (if (LongRangeBoundsCheck'''exceededBounds (:boundsCheck this), s)
                                [nil n]
                                [s (inc n)]
                            )
                        )
                        (catch ArithmeticException _
                            [nil n]
                        )
                    )]
                (recur-if (some? s) [s n] => n)
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (defn #_"long" LongRange''rangeCount [#_"LongRange" this, #_"long" start, #_"long" end, #_"long" step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (/ (Numbers'add-2ll (Numbers'add-2ll (Numbers'minus-2ll end, start), step), (if (pos? (:step this)) -1 1)) step)
    )

    #_override
    (defn #_"int" Counted'''count--LongRange [#_"LongRange" this]
        (try
            (let [#_"long" n (LongRange''rangeCount this, (:start this), (:end this), (:step this))]
                (when (<= n Integer/MAX_VALUE) => (Numbers'throwIntOverflow)
                    (int n)
                )
            )
            (catch ArithmeticException _
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"long" n
                        (loop-when-recur [#_"Iterator" it (.iterator this) n 0] (.hasNext it) [it (inc n)] => n
                            (.next it)
                        )]
                    (when (<= n Integer/MAX_VALUE) => (Numbers'throwIntOverflow)
                        (int n)
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduce'''reduce--LongRange [#_"LongRange" this, #_"IFn" f]
        (loop [#_"Object" r (:start this) #_"long" n r]
            (let-when-not [n (+ n (:step this))] (LongRangeBoundsCheck'''exceededBounds (:boundsCheck this), n) => r
                (let-when-not [r (IFn'''invoke-3 f, r, n)] (RT'isReduced r) => (IDeref'''deref (cast' Reduced r))
                    (recur r n)
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--LongRange [#_"LongRange" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"long" n (:start this)]
            (let-when-not [r (IFn'''invoke-3 f, r, n)] (RT'isReduced r) => (IDeref'''deref (cast' Reduced r))
                (let-when-not [n (+ n (:step this))] (LongRangeBoundsCheck'''exceededBounds (:boundsCheck this), n) => r
                    (recur r n)
                )
            )
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"LongRange" this]
        (LongRangeIterator'new)
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (defn #_"MapEntry" MapEntry'create [#_"Object" key, #_"Object" val]
        (MapEntry'new key, val)
    )

    (defn- #_"MapEntry" MapEntry'init []
        (hash-map
            #_"Object" :_key nil
            #_"Object" :_val nil
        )
    )

    (defn #_"MapEntry" MapEntry'new [#_"Object" key, #_"Object" val]
        (let [this (merge (AMapEntry'new) (MapEntry'init))]
            (§ ass this (assoc this :_key key))
            (§ ass this (assoc this :_val val))
            this
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''key--MapEntry [#_"MapEntry" this]
        (:_key this)
    )

    #_override
    (defn #_"Object" IMapEntry'''val--MapEntry [#_"MapEntry" this]
        (:_val this)
    )

    #_foreign
    (§ defn #_"Object" getKey [#_"MapEntry" this]
        (IMapEntry'''key this)
    )

    #_foreign
    (§ defn #_"Object" getValue [#_"MapEntry" this]
        (IMapEntry'''val this)
    )
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns Entry
    (defn- #_"Entry" Entry'init []
        (hash-map
            #_"Class" :c nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"Entry" Entry'new [#_"Class" c, #_"IFn" fn]
        (let [this (Entry'init)]
            (§ ass this (assoc this :c c))
            (§ ass this (assoc this :fn fn))
            this
        )
    )
)

(class-ns MethodImplCache
    (defn- #_"MethodImplCache" MethodImplCache'init []
        (hash-map
            #_"IPersistentMap" :protocol nil
            #_"Keyword" :methodk nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"Object[]" :table nil ;; [class, entry. class, entry ...]
            #_"Map" :map nil

            #_"Entry" :mre nil
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-2 [#_"IPersistentMap" protocol, #_"Keyword" methodk]
        (MethodImplCache'new-5 protocol, methodk, 0, 0, RT'EMPTY_ARRAY)
    )

    (defn #_"MethodImplCache" MethodImplCache'new-5 [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"int" shift, #_"int" mask, #_"Object[]" table]
        (let [this (MethodImplCache'init)]
            (§ ass this (assoc this :protocol protocol))
            (§ ass this (assoc this :methodk methodk))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :mask mask))
            (§ ass this (assoc this :table table))
            (§ ass this (assoc this :map nil))
            this
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-3 [#_"IPersistentMap" protocol, #_"Keyword" methodk, #_"Map" map]
        (let [this (MethodImplCache'init)]
            (§ ass this (assoc this :protocol protocol))
            (§ ass this (assoc this :methodk methodk))
            (§ ass this (assoc this :shift 0))
            (§ ass this (assoc this :mask 0))
            (§ ass this (assoc this :table nil))
            (§ ass this (assoc this :map map))
            this
        )
    )

    #_method
    (defn #_"IFn" MethodImplCache''fnFor [#_"MethodImplCache" this, #_"Class" c]
        (let [#_"Entry" last (:mre this)]
            (if (and (some? last) (= (:c last) c)) (:fn last) (MethodImplCache''findFnFor this, c))
        )
    )

    #_method
    (defn #_"IFn" MethodImplCache''findFnFor [#_"MethodImplCache" this, #_"Class" c]
        (if (some? (:map this))
            (let [#_"Entry" e (cast' Entry (.get (:map this), c))]
                (§ ass this (assoc this :mre e))
                (when (some? e) (:fn e))
            )
            (let [#_"int" idx (<< (& (>> (Util'hash c) (:shift this)) (:mask this)) 1)]
                (when (and (< idx (alength (:table this))) (= (aget (:table this) idx) c))
                    (let [#_"Entry" e (cast' Entry (aget (:table this) (inc idx)))]
                        (§ ass this (assoc this :mre e))
                        (when (some? e) (:fn e))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ def #_"Var" MultiFn'assoc (RT'var "cloiure.core", "assoc"))
    (§ def #_"Var" MultiFn'dissoc (RT'var "cloiure.core", "dissoc"))
    (§ def #_"Var" MultiFn'isa (RT'var "cloiure.core", "isa?"))
    (§ def #_"Var" MultiFn'parents (RT'var "cloiure.core", "parents"))

    (defn- #_"MultiFn" MultiFn'init []
        (hash-map
            #_"IFn" :dispatchFn nil
            #_"Object" :defaultDispatchVal nil
            #_"IRef" :hierarchy nil
            #_"String" :name nil
            #_"ReentrantReadWriteLock" :rw nil

            #_volatile
            #_"IPersistentMap" :methodTable nil
            #_volatile
            #_"IPersistentMap" :preferTable nil
            #_volatile
            #_"IPersistentMap" :methodCache nil
            #_volatile
            #_"Object" :cachedHierarchy nil
        )
    )

    (defn #_"MultiFn" MultiFn'new [#_"String" name, #_"IFn" dispatchFn, #_"Object" defaultDispatchVal, #_"IRef" hierarchy]
        (let [this (merge (AFn'new) (MultiFn'init))]
            (§ ass this (assoc this :rw (ReentrantReadWriteLock.)))
            (§ ass this (assoc this :name name))
            (§ ass this (assoc this :dispatchFn dispatchFn))
            (§ ass this (assoc this :defaultDispatchVal defaultDispatchVal))
            (§ ass this (assoc this :methodTable PersistentHashMap'EMPTY))
            (§ ass this (assoc this :methodCache (:methodTable this)))
            (§ ass this (assoc this :preferTable PersistentHashMap'EMPTY))
            (§ ass this (assoc this :hierarchy hierarchy))
            (§ ass this (assoc this :cachedHierarchy nil))
            this
        )
    )

    #_method
    (defn #_"MultiFn" MultiFn''reset [#_"MultiFn" this]
        (.lock (.writeLock (:rw this)))
        (try
            (§ ass this (assoc this :methodTable (§ ass this (assoc this :methodCache (§ ass this (assoc this :preferTable PersistentHashMap'EMPTY))))))
            (§ ass this (assoc this :cachedHierarchy nil))
            this
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn #_"MultiFn" MultiFn''addMethod [#_"MultiFn" this, #_"Object" dispatchVal, #_"IFn" method]
        (.lock (.writeLock (:rw this)))
        (try
            (§ ass this (assoc this :methodTable (IPersistentMap'''assoc (:methodTable this), dispatchVal, method)))
            (MultiFn''resetCache this)
            this
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn #_"MultiFn" MultiFn''removeMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (.lock (.writeLock (:rw this)))
        (try
            (§ ass this (assoc this :methodTable (IPersistentMap'''without (:methodTable this), dispatchVal)))
            (MultiFn''resetCache this)
            this
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn #_"MultiFn" MultiFn''preferMethod [#_"MultiFn" this, #_"Object" dispatchValX, #_"Object" dispatchValY]
        (.lock (.writeLock (:rw this)))
        (try
            (when (MultiFn''prefers this, dispatchValY, dispatchValX)
                (throw (IllegalStateException. (str "Preference conflict in multimethod '" (:name this) "': " dispatchValY " is already preferred to " dispatchValX)))
            )
            (§ ass this (assoc this :preferTable (IPersistentMap'''assoc (:preferTable this), dispatchValX, (RT'conj (cast' IPersistentCollection (RT'get-3 (:preferTable this), dispatchValX, PersistentHashSet'EMPTY)), dispatchValY))))
            (MultiFn''resetCache this)
            this
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn- #_"boolean" MultiFn''prefers [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (or
            (let [#_"IPersistentSet" xprefs (cast' IPersistentSet (ILookup'''valAt-2 (:preferTable this), x))]
                (and (some? xprefs) (IPersistentSet'''contains xprefs, y))
            )
            (loop-when [#_"ISeq" ps (RT'seq (IFn'''invoke-2 MultiFn'parents, y))] (some? ps) => false
                (or (MultiFn''prefers this, x, (.first ps)) (recur (.next ps)))
            )
            (loop-when [#_"ISeq" ps (RT'seq (IFn'''invoke-2 MultiFn'parents, x))] (some? ps) => false
                (or (MultiFn''prefers this, (.first ps), y) (recur (.next ps)))
            )
        )
    )

    #_method
    (defn- #_"boolean" MultiFn''isA [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (RT'booleanCast-1o (IFn'''invoke-4 MultiFn'isa, (IDeref'''deref (:hierarchy this)), x, y))
    )

    #_method
    (defn- #_"boolean" MultiFn''dominates [#_"MultiFn" this, #_"Object" x, #_"Object" y]
        (or (MultiFn''prefers this, x, y) (MultiFn''isA this, x, y))
    )

    #_method
    (defn- #_"IPersistentMap" MultiFn''resetCache [#_"MultiFn" this]
        (.lock (.writeLock (:rw this)))
        (try
            (§ ass this (assoc this :methodCache (:methodTable this)))
            (§ ass this (assoc this :cachedHierarchy (IDeref'''deref (:hierarchy this))))
            (:methodCache this)
            (finally
                (.unlock (.writeLock (:rw this)))
            )
        )
    )

    #_method
    (defn #_"IFn" MultiFn''getMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (when-not (= (:cachedHierarchy this) (IDeref'''deref (:hierarchy this)))
            (MultiFn''resetCache this)
        )
        (let [#_"IFn" targetFn (cast' IFn (ILookup'''valAt-2 (:methodCache this), dispatchVal))]
            (or targetFn (MultiFn''findAndCacheBestMethod this, dispatchVal))
        )
    )

    #_method
    (defn- #_"IFn" MultiFn''getFn [#_"MultiFn" this, #_"Object" dispatchVal]
        (let [#_"IFn" targetFn (MultiFn''getMethod this, dispatchVal)]
            (or targetFn (throw (IllegalArgumentException. (str "No method in multimethod '" (:name this) "' for dispatch value: " dispatchVal))))
        )
    )

    #_method
    (defn- #_"IFn" MultiFn''findAndCacheBestMethod [#_"MultiFn" this, #_"Object" dispatchVal]
        (.lock (.readLock (:rw this)))
        (let [#_"IPersistentMap" mt (:methodTable this) #_"IPersistentMap" pt (:preferTable this) #_"Object" ch (:cachedHierarchy this)
              #_"Object" bestValue
                (try
                    (let [#_"Iterator" it (.iterator (:methodTable this))
                            #_"Map$Entry" bestEntry
                            (loop-when [bestEntry nil] (.hasNext it) => bestEntry
                                (let-when [#_"Map$Entry" e (cast Map$Entry (.next it))] (MultiFn''isA this, dispatchVal, (.getKey e)) => (recur bestEntry)
                                    (let [bestEntry
                                            (when (or (nil? bestEntry) (MultiFn''dominates this, (.getKey e), (.getKey bestEntry))) => bestEntry
                                                e
                                            )]
                                        (when-not (MultiFn''dominates this, (.getKey bestEntry), (.getKey e))
                                            (throw (IllegalArgumentException. (str "Multiple methods in multimethod '" (:name this) "' match dispatch value: " dispatchVal " -> " (.getKey e) " and " (.getKey bestEntry) ", and neither is preferred")))
                                        )
                                        (recur bestEntry)
                                    )
                                )
                            )]
                        (if (some? bestEntry) (.getValue bestEntry) (ILookup'''valAt-2 (:methodTable this), (:defaultDispatchVal this)))
                    )
                    (finally
                        (.unlock (.readLock (:rw this)))
                    )
                )]
            (when (some? bestValue)
                ;; ensure basis has stayed stable throughout, else redo
                (.lock (.writeLock (:rw this)))
                (try
                    (if (and (= mt (:methodTable this)) (= pt (:preferTable this)) (= ch (:cachedHierarchy this)) (= (:cachedHierarchy this) (IDeref'''deref (:hierarchy this))))
                        (do
                            ;; place in cache
                            (§ ass this (assoc this :methodCache (IPersistentMap'''assoc (:methodCache this), dispatchVal, bestValue)))
                            (cast' IFn bestValue)
                        )
                        (do
                            (MultiFn''resetCache this)
                            (MultiFn''findAndCacheBestMethod this, dispatchVal)
                        )
                    )
                    (finally
                        (.unlock (.writeLock (:rw this)))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--MultiFn [#_"MultiFn" this]
        (IFn'''invoke-1 (MultiFn''getFn this, (IFn'''invoke-1 (:dispatchFn this))))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--MultiFn [#_"MultiFn" this, #_"Object" arg1]
        (IFn'''invoke-2 (MultiFn''getFn this, (IFn'''invoke-2 (:dispatchFn this), arg1)),
            (Util'ret1 arg1, (§ ass arg1 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2]
        (IFn'''invoke-3 (MultiFn''getFn this, (IFn'''invoke-3 (:dispatchFn this), arg1, arg2)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (IFn'''invoke-4 (MultiFn''getFn this, (IFn'''invoke-4 (:dispatchFn this), arg1, arg2, arg3)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (IFn'''invoke-5 (MultiFn''getFn this, (IFn'''invoke-5 (:dispatchFn this), arg1, arg2, arg3, arg4)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (IFn'''invoke-6 (MultiFn''getFn this, (IFn'''invoke-6 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (IFn'''invoke-7 (MultiFn''getFn this, (IFn'''invoke-7 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (IFn'''invoke-8 (MultiFn''getFn this, (IFn'''invoke-8 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (IFn'''invoke-9 (MultiFn''getFn this, (IFn'''invoke-9 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (IFn'''invoke-10 (MultiFn''getFn this, (IFn'''invoke-10 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (IFn'''invoke-11 (MultiFn''getFn this, (IFn'''invoke-11 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (IFn'''invoke-12 (MultiFn''getFn this, (IFn'''invoke-12 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (IFn'''invoke-13 (MultiFn''getFn this, (IFn'''invoke-13 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (IFn'''invoke-14 (MultiFn''getFn this, (IFn'''invoke-14 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (IFn'''invoke-15 (MultiFn''getFn this, (IFn'''invoke-15 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (IFn'''invoke-16 (MultiFn''getFn this, (IFn'''invoke-16 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (IFn'''invoke-17 (MultiFn''getFn this, (IFn'''invoke-17 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (IFn'''invoke-18 (MultiFn''getFn this, (IFn'''invoke-18 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (IFn'''invoke-19 (MultiFn''getFn this, (IFn'''invoke-19 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil))
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (IFn'''invoke-20 (MultiFn''getFn this, (IFn'''invoke-20 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil))
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (IFn'''invoke-21 (MultiFn''getFn this, (IFn'''invoke-21 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil)),
            (Util'ret1 arg20, (§ ass arg20 nil))
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--MultiFn [#_"MultiFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (IFn'''invoke-22 (MultiFn''getFn this, (IFn'''invoke-22 (:dispatchFn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, args)),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil)),
            (Util'ret1 arg20, (§ ass arg20 nil)),
            args
        )
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
#_stateless
(class-ns Murmur3
    (def- #_"int" Murmur3'seed 0)
    (def- #_"int" Murmur3'C1 0xcc9e2d51)
    (def- #_"int" Murmur3'C2 0x1b873593)

    (defn #_"int" Murmur3'hashInt [#_"int" input]
        (when-not (zero? input) => 0
            (let [#_"int" k1 (Murmur3'mixK1 input)
                  #_"int" h1 (Murmur3'mixH1 Murmur3'seed, k1)]
                (Murmur3'fmix h1, 4)
            )
        )
    )

    (defn #_"int" Murmur3'hashLong [#_"long" input]
        (when-not (zero? input) => 0
            (let [#_"int" low (int input)
                  #_"int" high (int (>>> input 32))
                  #_"int" k1 (Murmur3'mixK1 low)
                  #_"int" h1 (Murmur3'mixH1 Murmur3'seed, k1)
                  k1 (Murmur3'mixK1 high)
                  h1 (Murmur3'mixH1 h1, k1)]
                (Murmur3'fmix h1, 8)
            )
        )
    )

    (defn #_"int" Murmur3'hashUnencodedChars [#_"CharSequence" input]
        (let [#_"int" h1 Murmur3'seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [#_"int" i 1] (< i (.length input)) [(+ i 2)]
                (let [#_"int" k1 (| (.charAt input, (dec i)) (<< (.charAt input, i) 16))]
                    (§ ass k1 (Murmur3'mixK1 k1))
                    (§ ass h1 (Murmur3'mixH1 h1, k1))
                )
            )

            ;; deal with any remaining characters
            (when (= (& (.length input) 1) 1)
                (let [#_"int" k1 (.charAt input, (dec (.length input)))]
                    (§ ass k1 (Murmur3'mixK1 k1))
                    (§ ass h1 (bit-xor h1 k1))
                )
            )

            (Murmur3'fmix h1, (* 2 (.length input)))
        )
    )

    (defn #_"int" Murmur3'mixCollHash [#_"int" hash, #_"int" n]
        (Murmur3'fmix (Murmur3'mixH1 Murmur3'seed, (Murmur3'mixK1 hash)), n)
    )

    (defn #_"int" Murmur3'hashOrdered [#_"Iterable" xs]
        (let [#_"Iterator" it (.iterator xs)]
            (loop-when-recur [#_"int" hash 1 #_"int" n 0]
                             (.hasNext it)
                             [(+ (* 31 hash) (Util'hasheq (.next it))) (inc n)]
                          => (Murmur3'mixCollHash hash, n)
            )
        )
    )

    (defn #_"int" Murmur3'hashUnordered [#_"Iterable" xs]
        (let [#_"Iterator" it (.iterator xs)]
            (loop-when-recur [#_"int" hash 0 #_"int" n 0]
                             (.hasNext it)
                             [(+ hash (Util'hasheq (.next it))) (inc n)]
                          => (Murmur3'mixCollHash hash, n)
            )
        )
    )

    (defn- #_"int" Murmur3'mixK1 [#_"int" k1]
        (§ ass k1 (* k1 Murmur3'C1))
        (§ ass k1 (Integer/rotateLeft k1, 15))
        (§ ass k1 (* k1 Murmur3'C2))
        k1
    )

    (defn- #_"int" Murmur3'mixH1 [#_"int" h1, #_"int" k1]
        (§ ass h1 (bit-xor h1 k1))
        (§ ass h1 (Integer/rotateLeft h1, 13))
        (§ ass h1 (+ (* h1 5) 0xe6546b64))
        h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (defn- #_"int" Murmur3'fmix [#_"int" h1, #_"int" n]
        (§ ass h1 (bit-xor h1 n))
        (§ ass h1 (bit-xor h1 (>>> h1 16)))
        (§ ass h1 (* h1 0x85ebca6b))
        (§ ass h1 (bit-xor h1 (>>> h1 13)))
        (§ ass h1 (* h1 0xc2b2ae35))
        (§ ass h1 (bit-xor h1 (>>> h1 16)))
        h1
    )
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (def #_"ConcurrentHashMap<Symbol, Namespace>" Namespace'namespaces (ConcurrentHashMap.))

    (defn- #_"Namespace" Namespace'init []
        (hash-map
            #_"Symbol" :name nil

            #_transient
            #_"AtomicReference<IPersistentMap>" :mappings (AtomicReference.)
            #_transient
            #_"AtomicReference<IPersistentMap>" :aliases (AtomicReference.)
        )
    )

    (defn #_"Namespace" Namespace'new [#_"Symbol" name]
        (let [this (merge (AReference'new-1 (IMeta'''meta name)) (Namespace'init))]
            (§ ass this (assoc this :name name))
            (.set (:mappings this), RT'DEFAULT_IMPORTS)
            (.set (:aliases this), (RT'map))
            this
        )
    )

    #_foreign
    (§ defn #_"String" toString [#_"Namespace" this]
        (.toString (:name this))
    )

    (defn #_"ISeq" Namespace'all []
        (RT'seq (.values Namespace'namespaces))
    )

    #_method
    (defn #_"Symbol" Namespace''getName [#_"Namespace" this]
        (:name this)
    )

    #_method
    (defn #_"IPersistentMap" Namespace''getMappings [#_"Namespace" this]
        (.get (:mappings this))
    )

    #_method
    (defn- #_"void" Namespace''warnOrFailOnReplace [#_"Namespace" this, #_"Symbol" sym, #_"Object" o, #_"Var" var]
        (or
            (when (§ instance? Var o)
                (let [#_"Namespace" ns (:ns (cast' Var o))]
                    (when-not (or (= ns this) (= (:ns var) RT'CLOIURE_NS)) => :ok
                        (when-not (= ns RT'CLOIURE_NS)
                            (throw (IllegalStateException. (str sym " already refers to: " o " in namespace: " (:name this))))
                        )
                    )
                )
            )
            (.println (RT'errPrintWriter), (str "WARNING: " sym " already refers to: " o " in namespace: " (:name this) ", being replaced by: " var))
        )
        nil
    )

    #_method
    (defn #_"Var" Namespace''intern [#_"Namespace" this, #_"Symbol" sym]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [[#_"IPersistentMap" m #_"Object" o #_"Var" v]
                    (loop [v nil]
                        (let-when [m (Namespace''getMappings this) o (ILookup'''valAt-2 m, sym)] (nil? o) => [m o v]
                            (let [v (or v (Var'new this, sym))]
                                (.compareAndSet (:mappings this), m, (IPersistentMap'''assoc m, sym, v))
                                (recur v)
                            )
                        )
                    )]
                (when-not (and (§ instance? Var o) (= (:ns (cast' Var o)) this)) => (cast' Var o)
                    (let [v (or v (Var'new this, sym))]
                        (Namespace''warnOrFailOnReplace this, sym, o, v)
                        (loop-when-recur m (not (.compareAndSet (:mappings this), m, (IPersistentMap'''assoc m, sym, v))) (Namespace''getMappings this))
                        v
                    )
                )
            )
        )
    )

    #_method
    (defn #_"Var" Namespace''referenceVar [#_"Namespace" this, #_"Symbol" sym, #_"Var" var]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [[#_"IPersistentMap" m #_"Object" o]
                    (loop []
                        (let-when [m (Namespace''getMappings this) o (ILookup'''valAt-2 m, sym)] (nil? o) => [m o]
                            (.compareAndSet (:mappings this), m, (IPersistentMap'''assoc m, sym, var))
                            (recur)
                        )
                    )]
                (when-not (= o var)
                    (Namespace''warnOrFailOnReplace this, sym, o, var)
                    (loop-when-recur m (not (.compareAndSet (:mappings this), m, (IPersistentMap'''assoc m, sym, var))) (Namespace''getMappings this))
                )
                var
            )
        )
    )

    (defn #_"boolean" Namespace'areDifferentInstancesOfSameClassName [#_"Class" cls1, #_"Class" cls2]
        (and (not= cls1 cls2) (.equals (.getName cls1), (.getName cls2)))
    )

    #_method
    (defn #_"Class" Namespace''referenceClass [#_"Namespace" this, #_"Symbol" sym, #_"Class" cls]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
            (let [#_"Class" c
                    (loop []
                        (let [#_"IPersistentMap" m (Namespace''getMappings this) c (cast Class (ILookup'''valAt-2 m, sym))]
                            (when (or (nil? c) (Namespace'areDifferentInstancesOfSameClassName c, cls)) => c
                                (.compareAndSet (:mappings this), m, (IPersistentMap'''assoc m, sym, cls))
                                (recur)
                            )
                        )
                    )]
                (when (= c cls) => (throw (IllegalStateException. (str sym " already refers to: " c " in namespace: " (:name this))))
                    c
                )
            )
        )
    )

    #_method
    (defn #_"void" Namespace''unmap [#_"Namespace" this, #_"Symbol" sym]
        (when (nil? (:ns sym)) => (throw (IllegalArgumentException. "Can't unintern namespace-qualified symbol"))
            (loop-when-recur [#_"IPersistentMap" m (Namespace''getMappings this)] (Associative'''containsKey m, sym) [(Namespace''getMappings this)]
                (.compareAndSet (:mappings this), m, (IPersistentMap'''without m, sym))
            )
        )
        nil
    )

    #_method
    (defn #_"Class" Namespace''importClass [#_"Namespace" this, #_"Symbol" sym, #_"Class" cls]
        (Namespace''referenceClass this, sym, cls)
    )

    #_method
    (defn #_"Class" Namespace''importClass [#_"Namespace" this, #_"Class" cls]
        (let [#_"String" s (.getName cls)]
            (Namespace''importClass this, (Symbol'intern (.substring s, (inc (.lastIndexOf s, \.)))), cls)
        )
    )

    #_method
    (defn #_"Var" Namespace''refer [#_"Namespace" this, #_"Symbol" sym, #_"Var" var]
        (Namespace''referenceVar this, sym, var)
    )

    (defn #_"Namespace" Namespace'findOrCreate [#_"Symbol" name]
        (or (.get Namespace'namespaces, name)
            (let [#_"Namespace" ns (Namespace'new name)]
                (or (.putIfAbsent Namespace'namespaces, name, ns) ns)
            )
        )
    )

    (defn #_"Namespace" Namespace'remove [#_"Symbol" name]
        (when (.equals name, (:name RT'CLOIURE_NS))
            (throw (IllegalArgumentException. "Cannot remove cloiure namespace"))
        )
        (.remove Namespace'namespaces, name)
    )

    (defn #_"Namespace" Namespace'find [#_"Symbol" name]
        (.get Namespace'namespaces, name)
    )

    #_method
    (defn #_"Object" Namespace''getMapping [#_"Namespace" this, #_"Symbol" name]
        (ILookup'''valAt-2 (.get (:mappings this)), name)
    )

    #_method
    (defn #_"Var" Namespace''findInternedVar [#_"Namespace" this, #_"Symbol" symbol]
        (let [#_"Object" o (ILookup'''valAt-2 (.get (:mappings this)), symbol)]
            (when (and (some? o) (§ instance? Var o) (= (:ns (cast' Var o)) this))
                (cast' Var o)
            )
        )
    )

    #_method
    (defn #_"IPersistentMap" Namespace''getAliases [#_"Namespace" this]
        (.get (:aliases this))
    )

    #_method
    (defn #_"Namespace" Namespace''lookupAlias [#_"Namespace" this, #_"Symbol" alias]
        (cast' Namespace (ILookup'''valAt-2 (Namespace''getAliases this), alias))
    )

    #_method
    (defn #_"void" Namespace''addAlias [#_"Namespace" this, #_"Symbol" alias, #_"Namespace" ns]
        (when (and (some? alias) (some? ns)) => (throw (NullPointerException. "Expecting Symbol + Namespace"))
            (let [#_"IPersistentMap" m
                    (loop-when-recur [m (Namespace''getAliases this)] (not (Associative'''containsKey m, alias)) [(Namespace''getAliases this)] => m
                        (.compareAndSet (:aliases this), m, (IPersistentMap'''assoc m, alias, ns))
                    )]
                ;; you can rebind an alias, but only to the initially-aliased namespace
                (when-not (.equals (ILookup'''valAt-2 m, alias), ns)
                    (throw (IllegalStateException. (str "Alias " alias " already exists in namespace " (:name this) ", aliasing " (ILookup'''valAt-2 m, alias))))
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" Namespace''removeAlias [#_"Namespace" this, #_"Symbol" alias]
        (loop-when-recur [#_"IPersistentMap" m (Namespace''getAliases this)] (Associative'''containsKey m, alias) [(Namespace''getAliases this)]
            (.compareAndSet (:aliases this), m, (IPersistentMap'''without m, alias))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

#_stateless
#_abstract
(class-ns OpsP (§ implements Ops)
    #_protected
    (defn #_"OpsP" OpsP'new []
        (hash-map)
    )

    #_override
    (defn #_"Number" Ops'''addP--OpsP [#_"OpsP" this, #_"Number" x, #_"Number" y]
        (Ops'''add this, x, y)
    )

    #_override
    (defn #_"Number" Ops'''multiplyP--OpsP [#_"OpsP" this, #_"Number" x, #_"Number" y]
        (Ops'''multiply this, x, y)
    )

    #_override
    (defn #_"Number" Ops'''negateP--OpsP [#_"OpsP" this, #_"Number" x]
        (Ops'''negate this, x)
    )

    #_override
    (defn #_"Number" Ops'''incP--OpsP [#_"OpsP" this, #_"Number" x]
        (.inc this, x)
    )

    #_override
    (defn #_"Number" Ops'''decP--OpsP [#_"OpsP" this, #_"Number" x]
        (.dec this, x)
    )
)

(class-ns LongOps (§ implements Ops)
    (defn #_"LongOps" LongOps'new []
        (hash-map)
    )

    #_override
    (defn #_"Ops" Ops'''combine--LongOps [#_"LongOps" this, #_"Ops" y]
        (Ops'''opsWithLong y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--LongOps [#_"LongOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--LongOps [#_"LongOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--LongOps [#_"LongOps" this, #_"RatioOps" x]
        Numbers'RATIO_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--LongOps [#_"LongOps" this, #_"BigIntOps" x]
        Numbers'BIGINT_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--LongOps [#_"LongOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_override
    (defn #_"boolean" Ops'''isZero--LongOps [#_"LongOps" this, #_"Number" x]
        (zero? (.longValue x))
    )

    #_override
    (defn #_"boolean" Ops'''isPos--LongOps [#_"LongOps" this, #_"Number" x]
        (pos? (.longValue x))
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--LongOps [#_"LongOps" this, #_"Number" x]
        (neg? (.longValue x))
    )

    #_override
    (defn #_"Number" Ops'''add--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (Numbers'add-2ll (.longValue x), (.longValue y)))
    )

    #_override
    (defn #_"Number" Ops'''addP--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y) #_"long" lz (+ lx ly)]
            (if (and (neg? (bit-xor lz lx)) (neg? (bit-xor lz ly)))
                (Ops'''add Numbers'BIGINT_OPS, x, y)
                (Numbers'num-1l lz)
            )
        )
    )

    #_override
    (defn #_"Number" Ops'''multiply--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (Numbers'multiply-2ll (.longValue x), (.longValue y)))
    )

    #_override
    (defn #_"Number" Ops'''multiplyP--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y)]
            (if (and (= lx Long/MIN_VALUE) (neg? ly))
                (Ops'''multiply Numbers'BIGINT_OPS, x, y)
                (let [#_"long" lz (* lx ly)]
                    (if (and (not= ly 0) (not= (/ lz ly) lx))
                        (Ops'''multiply Numbers'BIGINT_OPS, x, y)
                        (Numbers'num-1l lz)
                    )
                )
            )
        )
    )

    (defn #_"long" LongOps'gcd [#_"long" u, #_"long" v] (if (zero? v) u (recur v (% u v))))

    #_override
    (defn #_"Number" Ops'''divide--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (let [#_"long" lx (.longValue x) #_"long" ly (.longValue y)]
            (let-when-not [#_"long" gcd (LongOps'gcd lx, ly)] (zero? gcd) => (Numbers'num-1l 0)
                (let-when-not [lx (/ lx gcd) ly (/ ly gcd)] (= ly 1) => (Numbers'num-1l lx)
                    (let [[lx ly]
                            (when (neg? ly) => [lx ly]
                                [(- lx) (- ly)]
                            )]
                        (Ratio'new (BigInteger/valueOf lx), (BigInteger/valueOf ly))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Number" Ops'''quotient--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (/ (.longValue x) (.longValue y)))
    )

    #_override
    (defn #_"Number" Ops'''remainder--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (Numbers'num-1l (% (.longValue x) (.longValue y)))
    )

    #_override
    (defn #_"boolean" Ops'''equiv--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (= (.longValue x) (.longValue y))
    )

    #_override
    (defn #_"boolean" Ops'''lt--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (< (.longValue x) (.longValue y))
    )

    #_override
    (defn #_"boolean" Ops'''lte--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (<= (.longValue x) (.longValue y))
    )

    #_override
    (defn #_"boolean" Ops'''gte--LongOps [#_"LongOps" this, #_"Number" x, #_"Number" y]
        (>= (.longValue x) (.longValue y))
    )

    #_override
    (defn #_"Number" Ops'''negate--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'minus-1l val))
        )
    )

    #_override
    (defn #_"Number" Ops'''negateP--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< Long/MIN_VALUE val)
                (Numbers'num-1l (- val))
                (BigInt'fromBigInteger (.negate (BigInteger/valueOf val)))
            )
        )
    )

    #_override
    (defn #_"Number" Ops'''inc--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'inc-1l val))
        )
    )

    #_override
    (defn #_"Number" Ops'''incP--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< val Long/MAX_VALUE)
                (Numbers'num-1l (inc val))
                (.inc Numbers'BIGINT_OPS, x)
            )
        )
    )

    #_override
    (defn #_"Number" Ops'''dec--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (Numbers'num-1l (Numbers'dec-1l val))
        )
    )

    #_override
    (defn #_"Number" Ops'''decP--LongOps [#_"LongOps" this, #_"Number" x]
        (let [#_"long" val (.longValue x)]
            (if (< Long/MIN_VALUE val)
                (Numbers'num-1l (dec val))
                (.dec Numbers'BIGINT_OPS, x)
            )
        )
    )
)

(class-ns DoubleOps (§ extends OpsP)
    (defn #_"DoubleOps" DoubleOps'new []
        (OpsP'new)
    )

    #_override
    (defn #_"Ops" Ops'''combine--DoubleOps [#_"DoubleOps" this, #_"Ops" y]
        (Ops'''opsWithDouble y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--DoubleOps [#_"DoubleOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--DoubleOps [#_"DoubleOps" this, #_"DoubleOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--DoubleOps [#_"DoubleOps" this, #_"RatioOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--DoubleOps [#_"DoubleOps" this, #_"BigIntOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--DoubleOps [#_"DoubleOps" this, #_"BigDecimalOps" x]
        this
    )

    #_override
    (defn #_"boolean" Ops'''isZero--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (zero? (.doubleValue x))
    )

    #_override
    (defn #_"boolean" Ops'''isPos--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (pos? (.doubleValue x))
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (neg? (.doubleValue x))
    )

    #_override
    (defn #_"Number" Ops'''add--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (+ (.doubleValue x) (.doubleValue y)))
    )

    #_override
    (defn #_"Number" Ops'''multiply--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (* (.doubleValue x) (.doubleValue y)))
    )

    #_override
    (defn #_"Number" Ops'''divide--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Double/valueOf (/ (.doubleValue x) (.doubleValue y)))
    )

    #_override
    (defn #_"Number" Ops'''quotient--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Numbers'quotient-2dd (.doubleValue x), (.doubleValue y))
    )

    #_override
    (defn #_"Number" Ops'''remainder--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (Numbers'remainder-2dd (.doubleValue x), (.doubleValue y))
    )

    #_override
    (defn #_"boolean" Ops'''equiv--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (= (.doubleValue x) (.doubleValue y))
    )

    #_override
    (defn #_"boolean" Ops'''lt--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (< (.doubleValue x) (.doubleValue y))
    )

    #_override
    (defn #_"boolean" Ops'''lte--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (<= (.doubleValue x) (.doubleValue y))
    )

    #_override
    (defn #_"boolean" Ops'''gte--DoubleOps [#_"DoubleOps" this, #_"Number" x, #_"Number" y]
        (>= (.doubleValue x) (.doubleValue y))
    )

    #_override
    (defn #_"Number" Ops'''negate--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (- (.doubleValue x)))
    )

    #_override
    (defn #_"Number" Ops'''inc--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (inc (.doubleValue x)))
    )

    #_override
    (defn #_"Number" Ops'''dec--DoubleOps [#_"DoubleOps" this, #_"Number" x]
        (Double/valueOf (dec (.doubleValue x)))
    )
)

(class-ns RatioOps (§ extends OpsP)
    (defn #_"RatioOps" RatioOps'new []
        (OpsP'new)
    )

    #_override
    (defn #_"Ops" Ops'''combine--RatioOps [#_"RatioOps" this, #_"Ops" y]
        (Ops'''opsWithRatio y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--RatioOps [#_"RatioOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--RatioOps [#_"RatioOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--RatioOps [#_"RatioOps" this, #_"RatioOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--RatioOps [#_"RatioOps" this, #_"BigIntOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--RatioOps [#_"RatioOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_override
    (defn #_"boolean" Ops'''isZero--RatioOps [#_"RatioOps" this, #_"Number" x]
        (zero? (.signum (:numerator (cast' Ratio x))))
    )

    #_override
    (defn #_"boolean" Ops'''isPos--RatioOps [#_"RatioOps" this, #_"Number" x]
        (pos? (.signum (:numerator (cast' Ratio x))))
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--RatioOps [#_"RatioOps" this, #_"Number" x]
        (neg? (.signum (:numerator (cast' Ratio x))))
    )

    (defn #_"Number" RatioOps'normalizeRet [#_"Number" ret, #_"Number" x, #_"Number" y]
        ret
    )

    #_override
    (defn #_"Number" Ops'''add--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"Number" ret (Ops'''divide this, (.add (.multiply (:numerator ry), (:denominator rx)), (.multiply (:numerator rx), (:denominator ry))), (.multiply (:denominator ry), (:denominator rx)))]
            (RatioOps'normalizeRet ret, x, y)
        )
    )

    #_override
    (defn #_"Number" Ops'''multiply--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"Number" ret (Ops'''divide this, (.multiply (:numerator ry), (:numerator rx)), (.multiply (:denominator ry), (:denominator rx)))]
            (RatioOps'normalizeRet ret, x, y)
        )
    )

    #_override
    (defn #_"Number" Ops'''divide--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"Number" ret (Ops'''divide this, (.multiply (:denominator ry), (:numerator rx)), (.multiply (:numerator ry), (:denominator rx)))]
            (RatioOps'normalizeRet ret, x, y)
        )
    )

    #_override
    (defn #_"Number" Ops'''quotient--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"BigInteger" q (.divide (.multiply (:numerator rx), (:denominator ry)), (.multiply (:denominator rx), (:numerator ry)))]
            (RatioOps'normalizeRet (BigInt'fromBigInteger q), x, y)
        )
    )

    #_override
    (defn #_"Number" Ops'''remainder--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)
              #_"BigInteger" q (.divide (.multiply (:numerator rx), (:denominator ry)), (.multiply (:denominator rx), (:numerator ry)))
              #_"Number" ret (Numbers'minus-2oo x, (Numbers'multiply-2oo q, y))]
            (RatioOps'normalizeRet ret, x, y)
        )
    )

    #_override
    (defn #_"boolean" Ops'''equiv--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)]
            (and (.equals (:numerator rx), (:numerator ry)) (.equals (:denominator rx), (:denominator ry)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''lt--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)]
            (Numbers'lt-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''lte--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)]
            (Numbers'lte-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''gte--RatioOps [#_"RatioOps" this, #_"Number" x, #_"Number" y]
        (let [#_"Ratio" rx (Numbers'toRatio x) #_"Ratio" ry (Numbers'toRatio y)]
            (Numbers'gte-2oo (.multiply (:numerator rx), (:denominator ry)), (.multiply (:numerator ry), (:denominator rx)))
        )
    )

    #_override
    (defn #_"Number" Ops'''negate--RatioOps [#_"RatioOps" this, #_"Number" x]
        (let [#_"Ratio" r (cast' Ratio x)]
            (Ratio'new (.negate (:numerator r)), (:denominator r))
        )
    )

    #_override
    (defn #_"Number" Ops'''inc--RatioOps [#_"RatioOps" this, #_"Number" x]
        (Numbers'add-2ol x, 1)
    )

    #_override
    (defn #_"Number" Ops'''dec--RatioOps [#_"RatioOps" this, #_"Number" x]
        (Numbers'add-2ol x, -1)
    )
)

(class-ns BigIntOps (§ extends OpsP)
    (defn #_"BigIntOps" BigIntOps'new []
        (OpsP'new)
    )

    #_override
    (defn #_"Ops" Ops'''combine--BigIntOps [#_"BigIntOps" this, #_"Ops" y]
        (Ops'''opsWithBigInt y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--BigIntOps [#_"BigIntOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--BigIntOps [#_"BigIntOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--BigIntOps [#_"BigIntOps" this, #_"RatioOps" x]
        Numbers'RATIO_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--BigIntOps [#_"BigIntOps" this, #_"BigIntOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--BigIntOps [#_"BigIntOps" this, #_"BigDecimalOps" x]
        Numbers'BIGDECIMAL_OPS
    )

    #_override
    (defn #_"boolean" Ops'''isZero--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (zero? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''isPos--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (pos? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (let [#_"BigInt" bx (Numbers'toBigInt x)]
            (neg? (if (some? (:bipart bx)) (.signum (:bipart bx)) (:lpart bx)))
        )
    )

    #_override
    (defn #_"Number" Ops'''add--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''add (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"Number" Ops'''multiply--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''multiply (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"Number" Ops'''divide--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (Numbers'divide-2ii (.toBigInteger this, x), (.toBigInteger this, y))
    )

    #_override
    (defn #_"Number" Ops'''quotient--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''quotient (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"Number" Ops'''remainder--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''remainder (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"boolean" Ops'''equiv--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (.equals (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"boolean" Ops'''lt--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (BigInt''lt (Numbers'toBigInt x), (Numbers'toBigInt y))
    )

    #_override
    (defn #_"boolean" Ops'''lte--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (<= (.compareTo (.toBigInteger this, x), (.toBigInteger this, y)) 0)
    )

    #_override
    (defn #_"boolean" Ops'''gte--BigIntOps [#_"BigIntOps" this, #_"Number" x, #_"Number" y]
        (>= (.compareTo (.toBigInteger this, x), (.toBigInteger this, y)) 0)
    )

    #_override
    (defn #_"Number" Ops'''negate--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (BigInt'fromBigInteger (.negate (.toBigInteger this, x)))
    )

    #_override
    (defn #_"Number" Ops'''inc--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (BigInt'fromBigInteger (.add (.toBigInteger this, x), BigInteger/ONE))
    )

    #_override
    (defn #_"Number" Ops'''dec--BigIntOps [#_"BigIntOps" this, #_"Number" x]
        (BigInt'fromBigInteger (.subtract (.toBigInteger this, x), BigInteger/ONE))
    )
)

(class-ns BigDecimalOps (§ extends OpsP)
    (§ def #_"Var" BigDecimalOps'MATH_CONTEXT RT'MATH_CONTEXT)

    (defn #_"BigDecimalOps" BigDecimalOps'new []
        (OpsP'new)
    )

    #_override
    (defn #_"Ops" Ops'''combine--BigDecimalOps [#_"BigDecimalOps" this, #_"Ops" y]
        (Ops'''opsWithBigDecimal y, this)
    )

    #_override
    (defn #_"Ops" Ops'''opsWithLong--BigDecimalOps [#_"BigDecimalOps" this, #_"LongOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithDouble--BigDecimalOps [#_"BigDecimalOps" this, #_"DoubleOps" x]
        Numbers'DOUBLE_OPS
    )

    #_override
    (defn #_"Ops" Ops'''opsWithRatio--BigDecimalOps [#_"BigDecimalOps" this, #_"RatioOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigInt--BigDecimalOps [#_"BigDecimalOps" this, #_"BigIntOps" x]
        this
    )

    #_override
    (defn #_"Ops" Ops'''opsWithBigDecimal--BigDecimalOps [#_"BigDecimalOps" this, #_"BigDecimalOps" x]
        this
    )

    #_override
    (defn #_"boolean" Ops'''isZero--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (zero? (.signum bx))
        )
    )

    #_override
    (defn #_"boolean" Ops'''isPos--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (pos? (.signum bx))
        )
    )

    #_override
    (defn #_"boolean" Ops'''isNeg--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"BigDecimal" bx (cast BigDecimal x)]
            (neg? (.signum bx))
        )
    )

    #_override
    (defn #_"Number" Ops'''add--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (IDeref'''deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.add (.toBigDecimal this, x), (.toBigDecimal this, y)) (.add (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''multiply--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (IDeref'''deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.multiply (.toBigDecimal this, x), (.toBigDecimal this, y)) (.multiply (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''divide--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (IDeref'''deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.divide (.toBigDecimal this, x), (.toBigDecimal this, y)) (.divide (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''quotient--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (IDeref'''deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.divideToIntegralValue (.toBigDecimal this, x), (.toBigDecimal this, y)) (.divideToIntegralValue (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''remainder--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (let [#_"MathContext" mc (cast MathContext (IDeref'''deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.remainder (.toBigDecimal this, x), (.toBigDecimal this, y)) (.remainder (.toBigDecimal this, x), (.toBigDecimal this, y), mc))
        )
    )

    #_override
    (defn #_"boolean" Ops'''equiv--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (zero? (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)))
    )

    #_override
    (defn #_"boolean" Ops'''lt--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (neg? (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)))
    )

    #_override
    (defn #_"boolean" Ops'''lte--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (<= (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)) 0)
    )

    #_override
    (defn #_"boolean" Ops'''gte--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x, #_"Number" y]
        (>= (.compareTo (.toBigDecimal this, x), (.toBigDecimal this, y)) 0)
    )

    #_override
    (defn #_"Number" Ops'''negate--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (IDeref'''deref BigDecimalOps'MATH_CONTEXT))]
            (if (nil? mc) (.negate (cast BigDecimal x)) (.negate (cast BigDecimal x), mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''inc--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (IDeref'''deref BigDecimalOps'MATH_CONTEXT))
              #_"BigDecimal" bx (cast BigDecimal x)]
            (if (nil? mc) (.add bx, BigDecimal/ONE) (.add bx, BigDecimal/ONE, mc))
        )
    )

    #_override
    (defn #_"Number" Ops'''dec--BigDecimalOps [#_"BigDecimalOps" this, #_"Number" x]
        (let [#_"MathContext" mc (cast MathContext (IDeref'''deref BigDecimalOps'MATH_CONTEXT))
              #_"BigDecimal" bx (cast BigDecimal x)]
            (if (nil? mc) (.subtract bx, BigDecimal/ONE) (.subtract bx, BigDecimal/ONE, mc))
        )
    )
)

(def Category'enum-set
    (hash-set
        :Category'INTEGER
        :Category'FLOATING
        :Category'DECIMAL
        :Category'RATIO
    )
)

#_stateless
(class-ns Numbers
    (defn #_"boolean" Numbers'isZero-1o [#_"Object" x]
        (Ops'''isZero (Numbers'ops x), (cast Number x))
    )

    (defn #_"boolean" Numbers'isPos-1o [#_"Object" x]
        (Ops'''isPos (Numbers'ops x), (cast Number x))
    )

    (defn #_"boolean" Numbers'isNeg-1o [#_"Object" x]
        (Ops'''isNeg (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'minus-1o [#_"Object" x]
        (Ops'''negate (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'minusP-1o [#_"Object" x]
        (Ops'''negateP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'inc-1o [#_"Object" x]
        (.inc (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'incP-1o [#_"Object" x]
        (Ops'''incP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'dec-1o [#_"Object" x]
        (.dec (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'decP-1o [#_"Object" x]
        (Ops'''decP (Numbers'ops x), (cast Number x))
    )

    (defn #_"Number" Numbers'add-2oo [#_"Object" x, #_"Object" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''add (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'addP-2oo [#_"Object" x, #_"Object" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''addP (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'minus-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (-> (Ops'''combine (Numbers'ops x), yops) (Ops'''add (cast Number x), (Ops'''negate yops, (cast Number y))))
        )
    )

    (defn #_"Number" Numbers'minusP-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)
              #_"Number" negativeY (Ops'''negateP yops, (cast Number y))
              #_"Ops" negativeYOps (Numbers'ops negativeY)]
            (-> (Ops'''combine (Numbers'ops x), negativeYOps) (Ops'''addP (cast Number x), negativeY))
        )
    )

    (defn #_"Number" Numbers'multiply-2oo [#_"Object" x, #_"Object" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''multiply (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'multiplyP-2oo [#_"Object" x, #_"Object" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''multiplyP (cast Number x), (cast Number y)))
    )

    (defn #_"Number" Numbers'divide-2oo [#_"Object" x, #_"Object" y]
        (cond
            (Numbers'isNaN x) (cast Number x)
            (Numbers'isNaN y) (cast Number y)
            :else
                (let [#_"Ops" yops (Numbers'ops y)]
                    (when (Ops'''isZero yops, (cast Number y))
                        (throw (ArithmeticException. "Divide by zero"))
                    )
                    (-> (Ops'''combine (Numbers'ops x), yops) (Ops'''divide (cast Number x), (cast Number y)))
                )
        )
    )

    (defn #_"Number" Numbers'quotient-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (when (Ops'''isZero yops, (cast Number y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (-> (Ops'''combine (Numbers'ops x), yops) (Ops'''quotient (cast Number x), (cast Number y)))
        )
    )

    (defn #_"Number" Numbers'remainder-2oo [#_"Object" x, #_"Object" y]
        (let [#_"Ops" yops (Numbers'ops y)]
            (when (Ops'''isZero yops, (cast Number y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (-> (Ops'''combine (Numbers'ops x), yops) (Ops'''remainder (cast Number x), (cast Number y)))
        )
    )

    (defn #_"double" Numbers'quotient-2dd [#_"double" n, #_"double" d]
        (when (zero? d)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" q (/ n d)]
            (cond (<= Long/MIN_VALUE q Long/MAX_VALUE)
                (do
                    (double (long q))
                )
                :else ;; bigint quotient
                (do
                    (.doubleValue (.toBigInteger (BigDecimal. q)))
                )
            )
        )
    )

    (defn #_"double" Numbers'remainder-2dd [#_"double" n, #_"double" d]
        (when (zero? d)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" q (/ n d)]
            (cond (<= Long/MIN_VALUE q Long/MAX_VALUE)
                (do
                    (- n (* (long q) d))
                )
                :else ;; bigint quotient
                (let [#_"Number" bq (.toBigInteger (BigDecimal. q))]
                    (- n (* (.doubleValue bq) d))
                )
            )
        )
    )

    (defn #_"boolean" Numbers'equiv-2oo [#_"Object" x, #_"Object" y]
        (Numbers'equiv-2nn (cast Number x), (cast Number y))
    )

    (defn #_"boolean" Numbers'equiv-2nn [#_"Number" x, #_"Number" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''equiv x, y))
    )

    (defn #_"boolean" Numbers'equal [#_"Number" x, #_"Number" y]
        (and (= (Numbers'category x) (Numbers'category y)) (Ops'''equiv (Ops'''combine (Numbers'ops x), (Numbers'ops y)), x, y))
    )

    (defn #_"boolean" Numbers'lt-2oo [#_"Object" x, #_"Object" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''lt (cast Number x), (cast Number y)))
    )

    (defn #_"boolean" Numbers'lte-2oo [#_"Object" x, #_"Object" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''lte (cast Number x), (cast Number y)))
    )

    (defn #_"boolean" Numbers'gt-2oo [#_"Object" x, #_"Object" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''lt (cast Number y), (cast Number x)))
    )

    (defn #_"boolean" Numbers'gte-2oo [#_"Object" x, #_"Object" y]
        (-> (Ops'''combine (Numbers'ops x), (Numbers'ops y)) (Ops'''gte (cast Number x), (cast Number y)))
    )

    (defn #_"int" Numbers'compare [#_"Number" x, #_"Number" y]
        (let [#_"Ops" ops (Ops'''combine (Numbers'ops x), (Numbers'ops y))]
            (cond (Ops'''lt ops, x, y) -1 (Ops'''lt ops, y, x) 1 :else 0)
        )
    )

    (defn #_"BigInt" Numbers'toBigInt [#_"Object" x]
        (cond
            (§ instance? BigInt x)   (cast' BigInt x)
            (instance? BigInteger x) (BigInt'fromBigInteger (cast BigInteger x))
            :else                    (BigInt'fromLong (.longValue (cast Number x)))
        )
    )

    (defn #_"BigInteger" Numbers'toBigInteger [#_"Object" x]
        (cond
            (instance? BigInteger x) (cast BigInteger x)
            (§ instance? BigInt x)   (BigInt''toBigInteger (cast' BigInt x))
            :else                    (BigInteger/valueOf (.longValue (cast Number x)))
        )
    )

    (defn #_"BigDecimal" Numbers'toBigDecimal [#_"Object" x]
        (cond
            (instance? BigDecimal x)
                (cast BigDecimal x)
            (§ instance? BigInt x)
                (let [#_"BigInt" bi (cast' BigInt x)]
                    (if (nil? (:bipart bi))
                        (BigDecimal/valueOf (:lpart bi))
                        (§ unsure BigDecimal. (:bipart bi))
                    )
                )
            (instance? BigInteger x)
                (§ unsure BigDecimal. (cast BigInteger x))
            (instance? Double x)
                (§ unsure BigDecimal. (.doubleValue (cast Number x)))
            (instance? Float x)
                (§ unsure BigDecimal. (.doubleValue (cast Number x)))
            (§ instance? Ratio x)
                (let [#_"Ratio" r (cast' Ratio x)]
                    (cast BigDecimal (Numbers'divide-2oo (§ unsure BigDecimal. (:numerator r)), (:denominator r)))
                )
            :else
                (BigDecimal/valueOf (.longValue (cast Number x)))
        )
    )

    (defn #_"Ratio" Numbers'toRatio [#_"Object" x]
        (cond
            (§ instance? Ratio x)
                (cast' Ratio x)
            (instance? BigDecimal x)
                (let [#_"BigDecimal" bx (cast BigDecimal x) #_"BigInteger" bv (.unscaledValue bx) #_"int" scale (.scale bx)]
                    (if (neg? scale)
                        (Ratio'new (.multiply bv, (.pow BigInteger/TEN, (- scale))), BigInteger/ONE)
                        (Ratio'new bv, (.pow BigInteger/TEN, scale))
                    )
                )
            :else
                (Ratio'new (Numbers'toBigInteger x), BigInteger/ONE)
        )
    )

    (defn #_"Number" Numbers'rationalize [#_"Number" x]
        (cond
            (or (instance? Float x) (instance? Double x))
                (Numbers'rationalize (BigDecimal/valueOf (.doubleValue x)))
            (instance? BigDecimal x)
                (let [#_"BigDecimal" bx (cast BigDecimal x) #_"BigInteger" bv (.unscaledValue bx) #_"int" scale (.scale bx)]
                    (if (neg? scale)
                        (BigInt'fromBigInteger (.multiply bv, (.pow BigInteger/TEN, (- scale))))
                        (Numbers'divide-2ii bv, (.pow BigInteger/TEN, scale))
                    )
                )
            :else
                x
        )
    )

    (defn #_"Number" Numbers'reduceBigInt [#_"BigInt" val]
        (or (:bipart val) (Numbers'num-1l (:lpart val)))
    )

    (defn #_"Number" Numbers'divide-2ii [#_"BigInteger" n, #_"BigInteger" d]
        (when-not (.equals d, BigInteger/ZERO) => (throw (ArithmeticException. "Divide by zero"))
            (let [#_"BigInteger" gcd (.gcd n, d)]
                (when-not (.equals gcd, BigInteger/ZERO) => BigInt'ZERO
                    (let [n (.divide n, gcd) d (.divide d, gcd)]
                        (cond
                            (.equals d, BigInteger/ONE)
                                (BigInt'fromBigInteger n)
                            (.equals d, (.negate BigInteger/ONE))
                                (BigInt'fromBigInteger (.negate n))
                            :else
                                (Ratio'new (if (neg? (.signum d)) (.negate n) n), (if (neg? (.signum d)) (.negate d) d))
                        )
                    )
                )
            )
        )
    )

    (defn #_"int" Numbers'shiftLeftInt [#_"int" x, #_"int" n]
        (<< x n)
    )

    (defn #_"long" Numbers'shiftLeft-2oo [#_"Object" x, #_"Object" y]
        (Numbers'shiftLeft-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftLeft-2ol [#_"Object" x, #_"long" y]
        (Numbers'shiftLeft-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'shiftLeft-2lo [#_"long" x, #_"Object" y]
        (Numbers'shiftLeft-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftLeft-2ll [#_"long" x, #_"long" n]
        (<< x n)
    )

    (defn #_"int" Numbers'shiftRightInt [#_"int" x, #_"int" n]
        (>> x n)
    )

    (defn #_"long" Numbers'shiftRight-2oo [#_"Object" x, #_"Object" y]
        (Numbers'shiftRight-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftRight-2ol [#_"Object" x, #_"long" y]
        (Numbers'shiftRight-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'shiftRight-2lo [#_"long" x, #_"Object" y]
        (Numbers'shiftRight-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'shiftRight-2ll [#_"long" x, #_"long" n]
        (>> x n)
    )

    (defn #_"int" Numbers'unsignedShiftRightInt [#_"int" x, #_"int" n]
        (>>> x n)
    )

    (defn #_"long" Numbers'unsignedShiftRight-2oo [#_"Object" x, #_"Object" y]
        (Numbers'unsignedShiftRight-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ol [#_"Object" x, #_"long" y]
        (Numbers'unsignedShiftRight-2ll (Numbers'bitOpsCast x), y)
    )
    (defn #_"long" Numbers'unsignedShiftRight-2lo [#_"long" x, #_"Object" y]
        (Numbers'unsignedShiftRight-2ll x, (Numbers'bitOpsCast y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ll [#_"long" x, #_"long" n]
        (>>> x n)
    )

    (§ def #_"LongOps"       Numbers'LONG_OPS       (LongOps'new)      )
    (§ def #_"DoubleOps"     Numbers'DOUBLE_OPS     (DoubleOps'new)    )
    (§ def #_"RatioOps"      Numbers'RATIO_OPS      (RatioOps'new)     )
    (§ def #_"BigIntOps"     Numbers'BIGINT_OPS     (BigIntOps'new)    )
    (§ def #_"BigDecimalOps" Numbers'BIGDECIMAL_OPS (BigDecimalOps'new))

    (defn #_"Ops" Numbers'ops [#_"Object" x]
        (condp = (.getClass x)
            Integer          Numbers'LONG_OPS
            Long             Numbers'LONG_OPS
            (§ class BigInt) Numbers'BIGINT_OPS
            BigInteger       Numbers'BIGINT_OPS
            (§ class Ratio)  Numbers'RATIO_OPS
            Float            Numbers'DOUBLE_OPS
            Double           Numbers'DOUBLE_OPS
            BigDecimal       Numbers'BIGDECIMAL_OPS
                             Numbers'LONG_OPS
        )
    )

    (defn #_"int" Numbers'hasheqFrom [#_"Number" x, #_"Class" xc]
        (cond
            (or (any = xc Integer Short Byte) (and (= xc BigInteger) (Numbers'lte-2ol x, Long/MAX_VALUE) (Numbers'gte-2ol x, Long/MIN_VALUE)))
                (Murmur3'hashLong (.longValue x))
            (= xc BigDecimal)
                ;; stripTrailingZeros() to make all numerically equal BigDecimal values come out the same before calling hashCode.
                ;; Special check for 0 because stripTrailingZeros() does not do anything to values equal to 0 with different scales.
                (.hashCode (if (Numbers'isZero-1o x) BigDecimal/ZERO (.stripTrailingZeros (cast BigDecimal x))))
            (and (= xc Float) (.equals x, (float -0.0)))
                0 ;; match 0.0f
            :else
                (.hashCode x)
        )
    )

    (defn #_"int" Numbers'hasheq [#_"Number" x]
        (let [#_"Class" xc (.getClass x)]
            (condp = xc
                Long
                    (Murmur3'hashLong (.longValue x))
                Double
                    (if (.equals x, -0.0)
                        0 ;; match 0.0
                        (.hashCode x)
                    )
                (Numbers'hasheqFrom x, xc)
            )
        )
    )

    (defn #_"Category" Numbers'category [#_"Object" x]
        (condp = (.getClass x)
            Integer          :Category'INTEGER
            Long             :Category'INTEGER
            (§ class BigInt) :Category'INTEGER
            (§ class Ratio)  :Category'RATIO
            Float            :Category'FLOATING
            Double           :Category'FLOATING
            BigDecimal       :Category'DECIMAL
                             :Category'INTEGER
        )
    )

    (defn #_"long" Numbers'bitOpsCast [#_"Object" x]
        (let [#_"Class" xc (.getClass x)]               ;; no bignums, no decimals
            (when (any = xc Long Integer Short Byte) => (throw (IllegalArgumentException. (str "bit operation not supported for: " xc)))
                (RT'longCast-1o x)
            )
        )
    )

    (defn #_"float[]" Numbers'float_array-2 [#_"int" size, #_"Object" init]
        (let [#_"float[]" ret (.float-array size)]
            (if (instance? Number init)
                (let [#_"float" f (.floatValue (cast Number init))]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i f)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.floatValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"float[]" Numbers'float_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.float-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"float[]" ret (.float-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.floatValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"double[]" Numbers'double_array-2 [#_"int" size, #_"Object" init]
        (let [#_"double[]" ret (.double-array size)]
            (if (instance? Number init)
                (let [#_"double" f (.doubleValue (cast Number init))]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i f)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.doubleValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"double[]" Numbers'double_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.double-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"double[]" ret (.double-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.doubleValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"int[]" Numbers'int_array-2 [#_"int" size, #_"Object" init]
        (let [#_"int[]" ret (.int-array size)]
            (if (instance? Number init)
                (let [#_"int" f (.intValue (cast Number init))]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i f)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.intValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"int[]" Numbers'int_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.int-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"int[]" ret (.int-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.intValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"long[]" Numbers'long_array-2 [#_"int" size, #_"Object" init]
        (let [#_"long[]" ret (.long-array size)]
            (if (instance? Number init)
                (let [#_"long" f (.longValue (cast Number init))]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i f)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.longValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"long[]" Numbers'long_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.long-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"long[]" ret (.long-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.longValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"short[]" Numbers'short_array-2 [#_"int" size, #_"Object" init]
        (let [#_"short[]" ret (.short-array size)]
            (if (instance? Short init)
                (let [#_"short" s (cast Short init)]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i s)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.shortValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"short[]" Numbers'short_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.short-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"short[]" ret (.short-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.shortValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"char[]" Numbers'char_array-2 [#_"int" size, #_"Object" init]
        (let [#_"char[]" ret (.char-array size)]
            (if (instance? Character init)
                (let [#_"char" c (cast Character init)]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i c)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (cast Character (.first s)))
                    )
                )
            )
            ret
        )
    )

    (defn #_"char[]" Numbers'char_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.char-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"char[]" ret (.char-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (cast Character (.first s)))
                )
                ret
            )
        )
    )

    (defn #_"byte[]" Numbers'byte_array-2 [#_"int" size, #_"Object" init]
        (let [#_"byte[]" ret (.byte-array size)]
            (if (instance? Byte init)
                (let [#_"byte" b (cast Byte init)]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i b)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (.byteValue (cast Number (.first s))))
                    )
                )
            )
            ret
        )
    )

    (defn #_"byte[]" Numbers'byte_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.byte-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"byte[]" ret (.byte-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (.byteValue (cast Number (.first s))))
                )
                ret
            )
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-2 [#_"int" size, #_"Object" init]
        (let [#_"boolean[]" ret (.boolean-array size)]
            (if (instance? Boolean init)
                (let [#_"boolean" b (cast Boolean init)]
                    (dotimes [#_"int" i (alength ret)]
                        (aset ret i b)
                    )
                )
                (let [#_"ISeq" s (RT'seq init)]
                    (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                        (aset ret i (cast Boolean (.first s)))
                    )
                )
            )
            ret
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-1 [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (.boolean-array (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq)
                  #_"int" size (RT'count s)
                  #_"boolean[]" ret (.boolean-array size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset ret i (cast Boolean (.first s)))
                )
                ret
            )
        )
    )

    (defn #_"boolean[]" Numbers'booleans [#_"Object" array]
        (.booleans array)
    )

    (defn #_"byte[]" Numbers'bytes [#_"Object" array]
        (.bytes array)
    )

    (defn #_"char[]" Numbers'chars [#_"Object" array]
        (.chars array)
    )

    (defn #_"short[]" Numbers'shorts [#_"Object" array]
        (.shorts array)
    )

    (defn #_"float[]" Numbers'floats [#_"Object" array]
        (.floats array)
    )

    (defn #_"double[]" Numbers'doubles [#_"Object" array]
        (.doubles array)
    )

    (defn #_"int[]" Numbers'ints [#_"Object" array]
        (.ints array)
    )

    (defn #_"long[]" Numbers'longs [#_"Object" array]
        (.longs array)
    )

    (defn #_"Number" Numbers'num-1o [#_"Object" x]
        (cast Number x)
    )

    (defn #_"Number" Numbers'num-1f [#_"float" x]
        (Float/valueOf x)
    )

    (defn #_"Number" Numbers'num-1d [#_"double" x]
        (Double/valueOf x)
    )

    (defn #_"double" Numbers'add-2dd [#_"double" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2dd [#_"double" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'minus-2dd [#_"double" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2dd [#_"double" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minus-1d [#_"double" x]
        (- x)
    )

    (defn #_"double" Numbers'minusP-1d [#_"double" x]
        (- x)
    )

    (defn #_"double" Numbers'inc-1d [#_"double" x]
        (inc x)
    )

    (defn #_"double" Numbers'incP-1d [#_"double" x]
        (inc x)
    )

    (defn #_"double" Numbers'dec-1d [#_"double" x]
        (dec x)
    )

    (defn #_"double" Numbers'decP-1d [#_"double" x]
        (dec x)
    )

    (defn #_"double" Numbers'multiply-2dd [#_"double" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2dd [#_"double" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'divide-2dd [#_"double" x, #_"double" y]
        (/ x y)
    )

    (defn #_"boolean" Numbers'equiv-2dd [#_"double" x, #_"double" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'lt-2dd [#_"double" x, #_"double" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2dd [#_"double" x, #_"double" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2dd [#_"double" x, #_"double" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2dd [#_"double" x, #_"double" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'isPos-1d [#_"double" x]
        (> x 0)
    )

    (defn #_"boolean" Numbers'isNeg-1d [#_"double" x]
        (< x 0)
    )

    (defn #_"boolean" Numbers'isZero-1d [#_"double" x]
        (zero? x)
    )

    (defn #_"int" Numbers'throwIntOverflow []
        (throw (ArithmeticException. "integer overflow"))
    )

    (defn #_"int" Numbers'unchecked_int_add [#_"int" x, #_"int" y]
        (+ x y)
    )

    (defn #_"int" Numbers'unchecked_int_subtract [#_"int" x, #_"int" y]
        (- x y)
    )

    (defn #_"int" Numbers'unchecked_int_negate [#_"int" x]
        (- x)
    )

    (defn #_"int" Numbers'unchecked_int_inc [#_"int" x]
        (inc x)
    )

    (defn #_"int" Numbers'unchecked_int_dec [#_"int" x]
        (dec x)
    )

    (defn #_"int" Numbers'unchecked_int_multiply [#_"int" x, #_"int" y]
        (* x y)
    )

    (defn #_"long" Numbers'not-1o [#_"Object" x]
        (Numbers'not-1l (Numbers'bitOpsCast x))
    )

    (defn #_"long" Numbers'not-1l [#_"long" x]
        (bit-not x)
    )

    (defn #_"long" Numbers'and-2oo [#_"Object" x, #_"Object" y]
        (Numbers'and-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'and-2ol [#_"Object" x, #_"long" y]
        (Numbers'and-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'and-2lo [#_"long" x, #_"Object" y]
        (Numbers'and-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'and-2ll [#_"long" x, #_"long" y]
        (& x y)
    )

    (defn #_"long" Numbers'or-2oo [#_"Object" x, #_"Object" y]
        (Numbers'or-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'or-2ol [#_"Object" x, #_"long" y]
        (Numbers'or-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'or-2lo [#_"long" x, #_"Object" y]
        (Numbers'or-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'or-2ll [#_"long" x, #_"long" y]
        (| x y)
    )

    (defn #_"long" Numbers'xor-2oo [#_"Object" x, #_"Object" y]
        (Numbers'xor-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'xor-2ol [#_"Object" x, #_"long" y]
        (Numbers'xor-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'xor-2lo [#_"long" x, #_"Object" y]
        (Numbers'xor-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'xor-2ll [#_"long" x, #_"long" y]
        (bit-xor x y)
    )

    (defn #_"long" Numbers'andNot-2oo [#_"Object" x, #_"Object" y]
        (Numbers'andNot-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'andNot-2ol [#_"Object" x, #_"long" y]
        (Numbers'andNot-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'andNot-2lo [#_"long" x, #_"Object" y]
        (Numbers'andNot-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'andNot-2ll [#_"long" x, #_"long" y]
        (& x (bit-not y))
    )

    (defn #_"long" Numbers'clearBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'clearBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'clearBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'clearBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'clearBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'clearBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'clearBit-2ll [#_"long" x, #_"long" n]
        (& x (bit-not (<< 1 n)))
    )

    (defn #_"long" Numbers'setBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'setBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'setBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'setBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'setBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'setBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'setBit-2ll [#_"long" x, #_"long" n]
        (| x (<< 1 n))
    )

    (defn #_"long" Numbers'flipBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'flipBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'flipBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'flipBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"long" Numbers'flipBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'flipBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"long" Numbers'flipBit-2ll [#_"long" x, #_"long" n]
        (bit-xor x (<< 1 n))
    )

    (defn #_"boolean" Numbers'testBit-2oo [#_"Object" x, #_"Object" y]
        (Numbers'testBit-2ll (Numbers'bitOpsCast x), (Numbers'bitOpsCast y))
    )

    (defn #_"boolean" Numbers'testBit-2ol [#_"Object" x, #_"long" y]
        (Numbers'testBit-2ll (Numbers'bitOpsCast x), y)
    )

    (defn #_"boolean" Numbers'testBit-2lo [#_"long" x, #_"Object" y]
        (Numbers'testBit-2ll x, (Numbers'bitOpsCast y))
    )

    (defn #_"boolean" Numbers'testBit-2ll [#_"long" x, #_"long" n]
        (not= (& x (<< 1 n)) 0)
    )

    (defn #_"int" Numbers'unchecked_int_divide [#_"int" x, #_"int" y]
        (/ x y)
    )

    (defn #_"int" Numbers'unchecked_int_remainder [#_"int" x, #_"int" y]
        (% x y)
    )

    (defn #_"Number" Numbers'num-1l [#_"long" x]
        (Long/valueOf x)
    )

    (defn #_"long" Numbers'unchecked_add-2ll [#_"long" x, #_"long" y]
        (+ x y)
    )

    (defn #_"long" Numbers'unchecked_minus-2ll [#_"long" x, #_"long" y]
        (- x y)
    )

    (defn #_"long" Numbers'unchecked_multiply-2ll [#_"long" x, #_"long" y]
        (* x y)
    )

    (defn #_"long" Numbers'unchecked_minus-1l [#_"long" x]
        (- x)
    )

    (defn #_"long" Numbers'unchecked_inc-1l [#_"long" x]
        (inc x)
    )

    (defn #_"long" Numbers'unchecked_dec-1l [#_"long" x]
        (dec x)
    )

    (defn #_"Number" Numbers'unchecked_add-2oo [#_"Object" x, #_"Object" y]
        (Numbers'add-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2oo [#_"Object" x, #_"Object" y]
        (Numbers'minus-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2oo [#_"Object" x, #_"Object" y]
        (Numbers'multiply-2oo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-1o [#_"Object" x]
        (Numbers'minus-1o x)
    )

    (defn #_"Number" Numbers'unchecked_inc-1o [#_"Object" x]
        (Numbers'inc-1o x)
    )

    (defn #_"Number" Numbers'unchecked_dec-1o [#_"Object" x]
        (Numbers'dec-1o x)
    )

    (defn #_"double" Numbers'unchecked_add-2dd [#_"double" x, #_"double" y]
        (Numbers'add-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dd [#_"double" x, #_"double" y]
        (Numbers'minus-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dd [#_"double" x, #_"double" y]
        (Numbers'multiply-2dd x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-1d [#_"double" x]
        (Numbers'minus-1d x)
    )

    (defn #_"double" Numbers'unchecked_inc-1d [#_"double" x]
        (Numbers'inc-1d x)
    )

    (defn #_"double" Numbers'unchecked_dec-1d [#_"double" x]
        (Numbers'dec-1d x)
    )

    (defn #_"double" Numbers'unchecked_add-2do [#_"double" x, #_"Object" y]
        (Numbers'add-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2do [#_"double" x, #_"Object" y]
        (Numbers'multiply-2do x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2od [#_"Object" x, #_"double" y]
        (Numbers'add-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2od [#_"Object" x, #_"double" y]
        (Numbers'multiply-2od x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2dl [#_"double" x, #_"long" y]
        (Numbers'add-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2dl [#_"double" x, #_"long" y]
        (Numbers'minus-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2dl [#_"double" x, #_"long" y]
        (Numbers'multiply-2dl x, y)
    )

    (defn #_"double" Numbers'unchecked_add-2ld [#_"long" x, #_"double" y]
        (Numbers'add-2ld x, y)
    )

    (defn #_"double" Numbers'unchecked_minus-2ld [#_"long" x, #_"double" y]
        (Numbers'minus-2ld x, y)
    )

    (defn #_"double" Numbers'unchecked_multiply-2ld [#_"long" x, #_"double" y]
        (Numbers'multiply-2ld x, y)
    )

    (defn #_"Number" Numbers'unchecked_add-2lo [#_"long" x, #_"Object" y]
        (Numbers'add-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2lo [#_"long" x, #_"Object" y]
        (Numbers'minus-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiply-2lo x, y)
    )

    (defn #_"Number" Numbers'unchecked_add-2ol [#_"Object" x, #_"long" y]
        (Numbers'add-2ol x, y)
    )

    (defn #_"Number" Numbers'unchecked_minus-2ol [#_"Object" x, #_"long" y]
        (Numbers'minus-2ol x, y)
    )

    (defn #_"Number" Numbers'unchecked_multiply-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiply-2ol x, y)
    )

    (defn #_"Number" Numbers'quotient-2do [#_"double" x, #_"Object" y]
        (Numbers'quotient-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'quotient-2od [#_"Object" x, #_"double" y]
        (Numbers'quotient-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'quotient-2lo [#_"long" x, #_"Object" y]
        (Numbers'quotient-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'quotient-2ol [#_"Object" x, #_"long" y]
        (Numbers'quotient-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'quotient-2dl [#_"double" x, #_"long" y]
        (Numbers'quotient-2dd x, (double y))
    )

    (defn #_"double" Numbers'quotient-2ld [#_"long" x, #_"double" y]
        (Numbers'quotient-2dd (double x), y)
    )

    (defn #_"Number" Numbers'remainder-2do [#_"double" x, #_"Object" y]
        (Numbers'remainder-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'remainder-2od [#_"Object" x, #_"double" y]
        (Numbers'remainder-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'remainder-2lo [#_"long" x, #_"Object" y]
        (Numbers'remainder-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'remainder-2ol [#_"Object" x, #_"long" y]
        (Numbers'remainder-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'remainder-2dl [#_"double" x, #_"long" y]
        (Numbers'remainder-2dd x, (double y))
    )

    (defn #_"double" Numbers'remainder-2ld [#_"long" x, #_"double" y]
        (Numbers'remainder-2dd (double x), y)
    )

    (defn #_"long" Numbers'add-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (+ x y)]
            (when-not (and (neg? (bit-xor ret x)) (neg? (bit-xor ret y))) => (Numbers'throwIntOverflow)
                ret
            )
        )
    )

    (defn #_"Number" Numbers'addP-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (+ x y)]
            (if (and (neg? (bit-xor ret x)) (neg? (bit-xor ret y)))
                (Numbers'addP-2oo (cast Number x), (cast Number y))
                (Numbers'num-1l ret)
            )
        )
    )

    (defn #_"long" Numbers'minus-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (- x y)]
            (when-not (and (neg? (bit-xor ret x)) (neg? (bit-xor ret (bit-not y)))) => (Numbers'throwIntOverflow)
                ret
            )
        )
    )

    (defn #_"Number" Numbers'minusP-2ll [#_"long" x, #_"long" y]
        (let [#_"long" ret (- x y)]
            (if (and (neg? (bit-xor ret x)) (neg? (bit-xor ret (bit-not y))))
                (Numbers'minusP-2oo (cast Number x), (cast Number y))
                (Numbers'num-1l ret)
            )
        )
    )

    (defn #_"long" Numbers'minus-1l [#_"long" x]
        (when-not (= x Long/MIN_VALUE) => (Numbers'throwIntOverflow)
            (- x)
        )
    )

    (defn #_"Number" Numbers'minusP-1l [#_"long" x]
        (if (= x Long/MIN_VALUE)
            (BigInt'fromBigInteger (.negate (BigInteger/valueOf x)))
            (Numbers'num-1l (- x))
        )
    )

    (defn #_"long" Numbers'inc-1l [#_"long" x] (if (= x Long/MAX_VALUE) (Numbers'throwIntOverflow) (inc x)))
    (defn #_"long" Numbers'dec-1l [#_"long" x] (if (= x Long/MIN_VALUE) (Numbers'throwIntOverflow) (dec x)))

    (defn #_"Number" Numbers'incP-1l [#_"long" x] (if (= x Long/MAX_VALUE) (.inc Numbers'BIGINT_OPS, x) (Numbers'num-1l (inc x))))
    (defn #_"Number" Numbers'decP-1l [#_"long" x] (if (= x Long/MIN_VALUE) (.dec Numbers'BIGINT_OPS, x) (Numbers'num-1l (dec x))))

    (defn #_"long" Numbers'multiply-2ll [#_"long" x, #_"long" y]
        (when-not (and (= x Long/MIN_VALUE) (neg? y)) => (Numbers'throwIntOverflow)
            (let [#_"long" ret (* x y)]
                (when (or (zero? y) (= (/ ret y) x)) => (Numbers'throwIntOverflow)
                    ret
                )
            )
        )
    )

    (defn #_"Number" Numbers'multiplyP-2ll [#_"long" x, #_"long" y]
        (when-not (and (= x Long/MIN_VALUE) (neg? y)) => (Numbers'multiplyP-2oo (cast Number x), (cast Number y))
            (let [#_"long" ret (* x y)]
                (when (or (zero? y) (= (/ ret y) x)) => (Numbers'multiplyP-2oo (cast Number x), (cast Number y))
                    (Numbers'num-1l ret)
                )
            )
        )
    )

    (defn #_"long" Numbers'quotient-2ll [#_"long" x, #_"long" y]
        (/ x y)
    )

    (defn #_"long" Numbers'remainder-2ll [#_"long" x, #_"long" y]
        (% x y)
    )

    (defn #_"boolean" Numbers'equiv-2ll [#_"long" x, #_"long" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'lt-2ll [#_"long" x, #_"long" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2ll [#_"long" x, #_"long" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2ll [#_"long" x, #_"long" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2ll [#_"long" x, #_"long" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'isPos-1l [#_"long" x]
        (> x 0)
    )

    (defn #_"boolean" Numbers'isNeg-1l [#_"long" x]
        (< x 0)
    )

    (defn #_"boolean" Numbers'isZero-1l [#_"long" x]
        (zero? x)
    )

    ;; overload resolution

    (defn #_"Number" Numbers'add-2lo [#_"long" x, #_"Object" y]
        (Numbers'add-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'add-2ol [#_"Object" x, #_"long" y]
        (Numbers'add-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'addP-2lo [#_"long" x, #_"Object" y]
        (Numbers'addP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'addP-2ol [#_"Object" x, #_"long" y]
        (Numbers'addP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'add-2do [#_"double" x, #_"Object" y]
        (Numbers'add-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'add-2od [#_"Object" x, #_"double" y]
        (Numbers'add-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'add-2dl [#_"double" x, #_"long" y]
        (+ x y)
    )

    (defn #_"double" Numbers'add-2ld [#_"long" x, #_"double" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2do [#_"double" x, #_"Object" y]
        (Numbers'addP-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'addP-2od [#_"Object" x, #_"double" y]
        (Numbers'addP-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'addP-2dl [#_"double" x, #_"long" y]
        (+ x y)
    )

    (defn #_"double" Numbers'addP-2ld [#_"long" x, #_"double" y]
        (+ x y)
    )

    (defn #_"Number" Numbers'minus-2lo [#_"long" x, #_"Object" y]
        (Numbers'minus-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'minus-2ol [#_"Object" x, #_"long" y]
        (Numbers'minus-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'minusP-2lo [#_"long" x, #_"Object" y]
        (Numbers'minusP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'minusP-2ol [#_"Object" x, #_"long" y]
        (Numbers'minusP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'minus-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'minus-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'minus-2dl [#_"double" x, #_"long" y]
        (- x y)
    )

    (defn #_"double" Numbers'minus-2ld [#_"long" x, #_"double" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2do [#_"double" x, #_"Object" y]
        (Numbers'minus-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'minusP-2od [#_"Object" x, #_"double" y]
        (Numbers'minus-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'minusP-2dl [#_"double" x, #_"long" y]
        (- x y)
    )

    (defn #_"double" Numbers'minusP-2ld [#_"long" x, #_"double" y]
        (- x y)
    )

    (defn #_"Number" Numbers'multiply-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiply-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'multiply-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiply-2oo x, (cast Object y))
    )

    (defn #_"Number" Numbers'multiplyP-2lo [#_"long" x, #_"Object" y]
        (Numbers'multiplyP-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'multiplyP-2ol [#_"Object" x, #_"long" y]
        (Numbers'multiplyP-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'multiply-2do [#_"double" x, #_"Object" y]
        (Numbers'multiply-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'multiply-2od [#_"Object" x, #_"double" y]
        (Numbers'multiply-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'multiply-2dl [#_"double" x, #_"long" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiply-2ld [#_"long" x, #_"double" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2do [#_"double" x, #_"Object" y]
        (Numbers'multiplyP-2dd x, (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'multiplyP-2od [#_"Object" x, #_"double" y]
        (Numbers'multiplyP-2dd (.doubleValue (cast Number x)), y)
    )

    (defn #_"double" Numbers'multiplyP-2dl [#_"double" x, #_"long" y]
        (* x y)
    )

    (defn #_"double" Numbers'multiplyP-2ld [#_"long" x, #_"double" y]
        (* x y)
    )

    (defn #_"Number" Numbers'divide-2lo [#_"long" x, #_"Object" y]
        (Numbers'divide-2oo (cast Object x), y)
    )

    (defn #_"Number" Numbers'divide-2ol [#_"Object" x, #_"long" y]
        (Numbers'divide-2oo x, (cast Object y))
    )

    (defn #_"double" Numbers'divide-2do [#_"double" x, #_"Object" y]
        (/ x (.doubleValue (cast Number y)))
    )

    (defn #_"double" Numbers'divide-2od [#_"Object" x, #_"double" y]
        (/ (.doubleValue (cast Number x)) y)
    )

    (defn #_"double" Numbers'divide-2dl [#_"double" x, #_"long" y]
        (/ x y)
    )

    (defn #_"double" Numbers'divide-2ld [#_"long" x, #_"double" y]
        (/ x y)
    )

    (defn #_"Number" Numbers'divide-2ll [#_"long" x, #_"long" y]
        (Numbers'divide-2oo (cast Number x), (cast Number y))
    )

    (defn #_"boolean" Numbers'lt-2lo [#_"long" x, #_"Object" y]
        (Numbers'lt-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'lt-2ol [#_"Object" x, #_"long" y]
        (Numbers'lt-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'lt-2do [#_"double" x, #_"Object" y]
        (< x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'lt-2od [#_"Object" x, #_"double" y]
        (< (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'lt-2dl [#_"double" x, #_"long" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lt-2ld [#_"long" x, #_"double" y]
        (< x y)
    )

    (defn #_"boolean" Numbers'lte-2lo [#_"long" x, #_"Object" y]
        (Numbers'lte-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'lte-2ol [#_"Object" x, #_"long" y]
        (Numbers'lte-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'lte-2do [#_"double" x, #_"Object" y]
        (<= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'lte-2od [#_"Object" x, #_"double" y]
        (<= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'lte-2dl [#_"double" x, #_"long" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'lte-2ld [#_"long" x, #_"double" y]
        (<= x y)
    )

    (defn #_"boolean" Numbers'gt-2lo [#_"long" x, #_"Object" y]
        (Numbers'gt-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'gt-2ol [#_"Object" x, #_"long" y]
        (Numbers'gt-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'gt-2do [#_"double" x, #_"Object" y]
        (> x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'gt-2od [#_"Object" x, #_"double" y]
        (> (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'gt-2dl [#_"double" x, #_"long" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gt-2ld [#_"long" x, #_"double" y]
        (> x y)
    )

    (defn #_"boolean" Numbers'gte-2lo [#_"long" x, #_"Object" y]
        (Numbers'gte-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'gte-2ol [#_"Object" x, #_"long" y]
        (Numbers'gte-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'gte-2do [#_"double" x, #_"Object" y]
        (>= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'gte-2od [#_"Object" x, #_"double" y]
        (>= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'gte-2dl [#_"double" x, #_"long" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'gte-2ld [#_"long" x, #_"double" y]
        (>= x y)
    )

    (defn #_"boolean" Numbers'equiv-2lo [#_"long" x, #_"Object" y]
        (Numbers'equiv-2oo (cast Object x), y)
    )

    (defn #_"boolean" Numbers'equiv-2ol [#_"Object" x, #_"long" y]
        (Numbers'equiv-2oo x, (cast Object y))
    )

    (defn #_"boolean" Numbers'equiv-2do [#_"double" x, #_"Object" y]
        (= x (.doubleValue (cast Number y)))
    )

    (defn #_"boolean" Numbers'equiv-2od [#_"Object" x, #_"double" y]
        (= (.doubleValue (cast Number x)) y)
    )

    (defn #_"boolean" Numbers'equiv-2dl [#_"double" x, #_"long" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'equiv-2ld [#_"long" x, #_"double" y]
        (= x y)
    )

    (defn #_"boolean" Numbers'isNaN [#_"Object" x]
        (or (and (instance? Double x) (.isNaN (cast Double x))) (and (instance? Float x) (.isNaN (cast Float x))))
    )

    (defn #_"long" Numbers'max-2ll [#_"long" x, #_"long" y]
        (if (> x y) x y)
    )

    (defn #_"double" Numbers'max-2dd [#_"double" x, #_"double" y]
        (Math/max x, y)
    )

    (defn #_"Object" Numbers'max-2ld [#_"long" x, #_"double" y] (cond (Double/isNaN y) y (> x y) x :else y))
    (defn #_"Object" Numbers'max-2dl [#_"double" x, #_"long" y] (cond (Double/isNaN x) x (> x y) x :else y))

    (defn #_"Object" Numbers'max-2lo [#_"long" x, #_"Object" y] (cond (Numbers'isNaN y) y (Numbers'gt-2lo x, y) x :else y))
    (defn #_"Object" Numbers'max-2ol [#_"Object" x, #_"long" y] (cond (Numbers'isNaN x) x (Numbers'gt-2ol x, y) x :else y))

    (defn #_"Object" Numbers'max-2do [#_"double" x, #_"Object" y]
        (cond (Double/isNaN x) x (Numbers'isNaN y) y (> x (.doubleValue (cast Number y))) x :else y)
    )

    (defn #_"Object" Numbers'max-2od [#_"Object" x, #_"double" y]
        (cond (Numbers'isNaN x) x (Double/isNaN y) y (< y (.doubleValue (cast Number x))) x :else y)
    )

    (defn #_"Object" Numbers'max-2oo [#_"Object" x, #_"Object" y]
        (cond (Numbers'isNaN x) x (Numbers'isNaN y) y (Numbers'gt-2oo x, y) x :else y)
    )

    (defn #_"long" Numbers'min-2ll [#_"long" x, #_"long" y]
        (if (< x y) x y)
    )

    (defn #_"double" Numbers'min-2dd [#_"double" x, #_"double" y]
        (Math/min x, y)
    )

    (defn #_"Object" Numbers'min-2ld [#_"long" x, #_"double" y] (cond (Double/isNaN y) y (< x y) x :else y))
    (defn #_"Object" Numbers'min-2dl [#_"double" x, #_"long" y] (cond (Double/isNaN x) x (< x y) x :else y))

    (defn #_"Object" Numbers'min-2lo [#_"long" x, #_"Object" y] (cond (Numbers'isNaN y) y (Numbers'lt-2lo x, y) x :else y))
    (defn #_"Object" Numbers'min-2ol [#_"Object" x, #_"long" y] (cond (Numbers'isNaN x) x (Numbers'lt-2ol x, y) x :else y))

    (defn #_"Object" Numbers'min-2do [#_"double" x, #_"Object" y]
        (cond (Double/isNaN x) x (Numbers'isNaN y) y (< x (.doubleValue (cast Number y))) x :else y)
    )

    (defn #_"Object" Numbers'min-2od [#_"Object" x, #_"double" y]
        (cond (Numbers'isNaN x) x (Double/isNaN y) y (< (.doubleValue (cast Number x)) y) x :else y)
    )

    (defn #_"Object" Numbers'min-2oo [#_"Object" x, #_"Object" y]
        (cond (Numbers'isNaN x) x (Numbers'isNaN y) y (Numbers'lt-2oo x, y) x :else y)
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (defn- #_"Obj" Obj'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"Obj" Obj'new-1 [#_"IPersistentMap" meta]
        (let [this (Obj'init)]
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    (defn #_"Obj" Obj'new-0 []
        (let [this (Obj'init)]
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--Obj [#_"Obj" this]
        (:_meta this)
    )

    #_abstract
    (defn #_"Obj" IObj'''withMeta [#_"Obj" this, #_"IPersistentMap" meta])
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

(class-ns MSeq (§ extends ASeq) (§ implements Counted)
    (defn- #_"MSeq" MSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"MSeq" MSeq'new-2 [#_"Object[]" array, #_"int" i]
        (let [this (merge (ASeq'new-0) (MSeq'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    (defn #_"MSeq" MSeq'new-3 [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (MSeq'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--MSeq [#_"MSeq" this]
        (MapEntry'create (aget (:array this) (:i this)), (aget (:array this) (inc (:i this))))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--MSeq [#_"MSeq" this]
        (when (< (+ (:i this) 2) (alength (:array this)))
            (MSeq'new-2 (:array this), (+ (:i this) 2))
        )
    )

    #_override
    (defn #_"int" Counted'''count--MSeq [#_"MSeq" this]
        (/ (- (alength (:array this)) (:i this)) 2)
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--MSeq [#_"MSeq" this, #_"IPersistentMap" meta]
        (MSeq'new-3 meta, (:array this), (:i this))
    )
)

(class-ns MIter (§ implements Iterator)
    (defn- #_"MIter" MIter'init []
        (hash-map
            #_"IFn" :f nil
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    ;; for iterator
    (defn #_"MIter" MIter'new-2 [#_"Object[]" array, #_"IFn" f]
        (MIter'new-3 array, -2, f)
    )

    ;; for entryAt
    (defn #_"MIter" MIter'new-3 [#_"Object[]" array, #_"int" i, #_"IFn" f]
        (let [this (MIter'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :f f))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"MIter" this]
        (< (:i this) (- (alength (:array this)) 2))
    )

    #_foreign
    (§ defn #_"Object" next [#_"MIter" this]
        (try
            (§ ass this (assoc this :i (+ (:i this) 2)))
            (IFn'''invoke-3 (:f this), (aget (:array this) (:i this)), (aget (:array this) (inc (:i this))))
            (catch IndexOutOfBoundsException e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"MIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransientArrayMap (§ extends ATransientMap)
    (defn- #_"TransientArrayMap" TransientArrayMap'init []
        (hash-map
            #_volatile
            #_"int" :len 0
            #_"Object[]" :array nil
            #_volatile
            #_"Thread" :owner nil
        )
    )

    (defn #_"TransientArrayMap" TransientArrayMap'new [#_"Object[]" array]
        (let [this (merge (ATransientMap'new) (TransientArrayMap'init))]
            (§ ass this (assoc this :owner (Thread/currentThread)))
            (§ ass this (assoc this :array (make-array Object (Math/max PersistentArrayMap'HASHTABLE_THRESHOLD, (alength array)))))
            (System/arraycopy array, 0, (:array this), 0, (alength array))
            (§ ass this (assoc this :len (alength array)))
            this
        )
    )

    #_method
    (defn- #_"int" TransientArrayMap''indexOf [#_"TransientArrayMap" this, #_"Object" key]
        (loop-when [#_"int" i 0] (< i (:len this)) => -1
            (if (PersistentArrayMap'equalKey (aget (:array this) i), key) i (recur (+ i 2)))
        )
    )

    #_override
    (defn #_"ITransientMap" ATransientMap'''doAssoc--TransientArrayMap [#_"TransientArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (TransientArrayMap''indexOf this, key)]
            (cond (<= 0 i) ;; already have key,
                (do
                    (when-not (= (aget (:array this) (inc i)) val) ;; no change, no op
                        (aset (:array this) (inc i) val)
                    )
                    this
                )
                :else ;; didn't have key, grow
                (if (< (:len this) (alength (:array this)))
                    (do
                        (aset (:array this) (:len this) key)
                        (§ ass this (assoc this :len (inc (:len this))))
                        (aset (:array this) (:len this) val)
                        (§ ass this (assoc this :len (inc (:len this))))
                        this
                    )
                    (-> (PersistentHashMap'create-1a (:array this)) (IEditableCollection'''asTransient) (ITransientMap'''assoc key, val))
                )
            )
        )
    )

    #_override
    (defn #_"ITransientMap" ATransientMap'''doWithout--TransientArrayMap [#_"TransientArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (TransientArrayMap''indexOf this, key)] (<= 0 i) => this
            ;; have key, will remove
            (when (<= 2 (:len this))
                (aset (:array this) i (aget (:array this) (- (:len this) 2)))
                (aset (:array this) (inc i) (aget (:array this) (- (:len this) 1)))
            )
            (§ ass this (assoc this :len (- (:len this) 2)))
            this
        )
    )

    #_override
    (defn #_"Object" ATransientMap'''doValAt--TransientArrayMap [#_"TransientArrayMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (TransientArrayMap''indexOf this, key)]
            (if (<= 0 i) (aget (:array this) (inc i)) notFound)
        )
    )

    #_override
    (defn #_"int" ATransientMap'''doCount--TransientArrayMap [#_"TransientArrayMap" this]
        (/ (:len this) 2)
    )

    #_override
    (defn #_"IPersistentMap" ATransientMap'''doPersistent--TransientArrayMap [#_"TransientArrayMap" this]
        (ATransientMap'''ensureEditable this)
        (§ ass this (assoc this :owner nil))
        (let [#_"Object[]" a (make-array Object (:len this))]
            (System/arraycopy (:array this), 0, a, 0, (:len this))
            (PersistentArrayMap'new-1 a)
        )
    )

    #_override
    (defn #_"void" ATransientMap'''ensureEditable--TransientArrayMap [#_"TransientArrayMap" this]
        (when (nil? (:owner this))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ def #_"PersistentArrayMap" PersistentArrayMap'EMPTY (PersistentArrayMap'new-0))
    (def #_"int" PersistentArrayMap'HASHTABLE_THRESHOLD 16)

    (defn #_"IPersistentMap" PersistentArrayMap'create [#_"Map" other]
        (let [#_"Iterator" it (.iterator (.entrySet other))]
            (loop-when [#_"ITransientMap" ret (IEditableCollection'''asTransient PersistentArrayMap'EMPTY)] (.hasNext it) => (ITransientMap'''persistent ret)
                (let [#_"Map$Entry" e (cast Map$Entry (.next it))]
                    (recur (ITransientMap'''assoc ret, (.getKey e), (.getValue e)))
                )
            )
        )
    )

    (defn- #_"PersistentArrayMap" PersistentArrayMap'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IPersistentMap" :_meta nil
        )
    )

    #_protected
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-0 []
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass this (assoc this :array (make-array Object 0)))
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    #_override
    (defn #_"PersistentArrayMap" IObj'''withMeta--PersistentArrayMap [#_"PersistentArrayMap" this, #_"IPersistentMap" meta]
        (PersistentArrayMap'new-2 meta, (:array this))
    )

    #_method
    (defn #_"PersistentArrayMap" PersistentArrayMap''create [#_"PersistentArrayMap" this & #_"Object..." init]
        (PersistentArrayMap'new-2 (IMeta'''meta this), init)
    )

    #_method
    (defn #_"IPersistentMap" PersistentArrayMap''createHT [#_"PersistentArrayMap" this, #_"Object[]" init]
        (PersistentHashMap'create-2 (IMeta'''meta this), init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createWithCheck [#_"Object[]" init]
        (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
            (loop-when-recur [#_"int" j (+ i 2)] (< j (alength init)) [(+ j 2)]
                (when (PersistentArrayMap'equalKey (aget init i), (aget init j))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (aget init i))))
                )
            )
        )
        (PersistentArrayMap'new-1 init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createAsIfByAssoc [#_"Object[]" init]
        (when (= (& (alength init) 1) 1)
            (throw (IllegalArgumentException. (str "No value supplied for key: " (aget init (dec (alength init))))))
        )
        ;; If this looks like it is doing busy-work, it is because it is achieving these goals: O(n^2) run time
        ;; like createWithCheck(), never modify init arg, and only allocate memory if there are duplicate keys.
        (let [#_"int" n
                (loop-when [n 0 #_"int" i 0] (< i (alength init)) => n
                    (let [#_"boolean" dup?
                            (loop-when [dup? false #_"int" j 0] (< j i) => dup?
                                (or (PersistentArrayMap'equalKey (aget init i), (aget init j))
                                    (recur dup? (+ j 2))
                                )
                            )]
                        (recur (if dup? n (+ n 2)) (+ i 2))
                    )
                )
              init
                (when (< n (alength init)) => init
                    ;; Create a new shorter array with unique keys, and the last value associated with each key.
                    ;; To behave like assoc, the first occurrence of each key must be used, since its metadata
                    ;; may be different than later equal keys.
                    (let [#_"Object[]" nodups (make-array Object n)
                          #_"int" m
                            (loop-when [m 0 #_"int" i 0] (< i (alength init)) => m
                                (let [#_"boolean" dup?
                                        (loop-when [dup? false #_"int" j 0] (< j m) => dup?
                                            (or (PersistentArrayMap'equalKey (aget init i), (aget nodups j))
                                                (recur dup? (+ j 2))
                                            )
                                        )
                                      m (when-not dup? => m
                                            (let [#_"int" j
                                                    (loop-when [j (- (alength init) 2)] (<= i j) => j
                                                        (if (PersistentArrayMap'equalKey (aget init i), (aget init j))
                                                            j
                                                            (recur (- j 2))
                                                        )
                                                    )]
                                                (aset nodups m (aget init i))
                                                (aset nodups (inc m) (aget init (inc j)))
                                                (+ m 2)
                                            )
                                        )]
                                    (recur m (+ i 2))
                                )
                            )]
                        (when (= m n) => (throw (IllegalArgumentException. (str "Internal error: m=" m)))
                            nodups
                        )
                    )
                )]
            (PersistentArrayMap'new-1 init)
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-1 [#_"Object[]" init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass this (assoc this :array init))
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'new-2 [#_"IPersistentMap" meta, #_"Object[]" init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :array init))
            this
        )
    )

    #_override
    (defn #_"int" Counted'''count--PersistentArrayMap [#_"PersistentArrayMap" this]
        (/ (alength (:array this)) 2)
    )

    #_override
    (defn #_"boolean" Associative'''containsKey--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key]
        (<= 0 (PersistentArrayMap''indexOf this, key))
    )

    #_override
    (defn #_"IMapEntry" Associative'''entryAt--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (PersistentArrayMap''indexOf this, key)] (<= 0 i)
            (cast' IMapEntry (MapEntry'create (aget (:array this) i), (aget (:array this) (inc i))))
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''assocEx--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (PersistentArrayMap''indexOf this, key)]
            (when-not (<= 0 i) => (throw (RuntimeException. "Key already present"))
                ;; didn't have key, grow
                (if (< PersistentArrayMap'HASHTABLE_THRESHOLD (alength (:array this)))
                    (IPersistentMap'''assocEx (PersistentArrayMap''createHT this, (:array this)), key, val)
                    (let [#_"int" n (alength (:array this)) #_"Object[]" newArray (make-array Object (+ n 2))]
                        (when (pos? n)
                            (System/arraycopy (:array this), 0, newArray, 2, n)
                        )
                        (aset newArray 0 key)
                        (aset newArray 1 val)
                        (PersistentArrayMap''create this, newArray)
                    )
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''assoc--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" val]
        (let [#_"int" i (PersistentArrayMap''indexOf this, key)]
            (if (<= 0 i) ;; already have key, same-sized replacement
                (if (= (aget (:array this) (inc i)) val) ;; no change, no op
                    this
                    (let [#_"Object[]" newArray (.clone (:array this))]
                        (aset newArray (inc i) val)
                        (PersistentArrayMap''create this, newArray)
                    )
                )
                ;; didn't have key, grow
                (if (< PersistentArrayMap'HASHTABLE_THRESHOLD (alength (:array this)))
                    (IPersistentMap'''assoc (PersistentArrayMap''createHT this, (:array this)), key, val)
                    (let [#_"int" n (alength (:array this)) #_"Object[]" newArray (make-array Object (+ n 2))]
                        (when (pos? n)
                            (System/arraycopy (:array this), 0, newArray, 0, n)
                        )
                        (aset newArray n key)
                        (aset newArray (inc n) val)
                        (PersistentArrayMap''create this, newArray)
                    )
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''without--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key]
        (let-when [#_"int" i (PersistentArrayMap''indexOf this, key)] (<= 0 i) => this ;; don't have key, no op
            ;; have key, will remove
            (let-when [#_"int" n (- (alength (:array this)) 2)] (pos? n) => (IPersistentCollection'''empty this)
                (let [#_"Object[]" a (make-array Object n)]
                    (System/arraycopy (:array this), 0, a, 0, i)
                    (System/arraycopy (:array this), (+ i 2), a, i, (- n i))
                    (PersistentArrayMap''create this, a)
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentCollection'''empty--PersistentArrayMap [#_"PersistentArrayMap" this]
        (cast' IPersistentMap (IObj'''withMeta PersistentArrayMap'EMPTY, (IMeta'''meta this)))
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (PersistentArrayMap''indexOf this, key)]
            (if (<= 0 i) (aget (:array this) (inc i)) notFound)
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--PersistentArrayMap [#_"PersistentArrayMap" this, #_"Object" key]
        (ILookup'''valAt-3 this, key, nil)
    )

    #_method
    (defn #_"int" PersistentArrayMap''capacity [#_"PersistentArrayMap" this]
        (.count this)
    )

    #_method
    (defn- #_"int" PersistentArrayMap''indexOfObject [#_"PersistentArrayMap" this, #_"Object" key]
        (let [#_"EquivPred" ep (Util'equivPred key)]
            (loop-when [#_"int" i 0] (< i (alength (:array this))) => -1
                (if (EquivPred'''equiv ep, key, (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    #_method
    (defn- #_"int" PersistentArrayMap''indexOf [#_"PersistentArrayMap" this, #_"Object" key]
        (when (§ instance? Keyword key) => (PersistentArrayMap''indexOfObject this, key)
            (loop-when [#_"int" i 0] (< i (alength (:array this))) => -1
                (if (= key (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    (defn #_"boolean" PersistentArrayMap'equalKey [#_"Object" k1, #_"Object" k2]
        (if (§ instance? Keyword k1) (= k1 k2) (Util'equiv-2oo k1, k2))
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_ENTRY)
    )

    #_override
    (defn #_"Iterator" IMapIterable'''keyIterator--PersistentArrayMap [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_KEY)
    )

    #_override
    (defn #_"Iterator" IMapIterable'''valIterator--PersistentArrayMap [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_VAL)
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentArrayMap [#_"PersistentArrayMap" this]
        (when (pos? (alength (:array this)))
            (MSeq'new-2 (:array this), 0)
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentArrayMap [#_"PersistentArrayMap" this]
        (:_meta this)
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--PersistentArrayMap [#_"PersistentArrayMap" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (alength (:array this))) => r
            (let [r (IFn'''invoke-4 f, r, (aget (:array this) i), (aget (:array this) (inc i)))]
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (+ i 2)))
            )
        )
    )

    #_override
    (defn #_"ITransientMap" IEditableCollection'''asTransient--PersistentArrayMap [#_"PersistentArrayMap" this]
        (TransientArrayMap'new (:array this))
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns TransientHashMap (§ extends ATransientMap)
    (defn- #_"TransientHashMap" TransientHashMap'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_volatile
            #_"INode" :root nil
            #_volatile
            #_"int" :count 0
            #_volatile
            #_"boolean" :hasNull false
            #_volatile
            #_"Object" :nullValue nil
            #_"Box" :leafFlag (Box'new nil)
        )
    )

    (defn #_"TransientHashMap" TransientHashMap'new-1 [#_"PersistentHashMap" m]
        (TransientHashMap'new-5 (AtomicReference. (Thread/currentThread)), (:root m), (:count m), (:hasNull m), (:nullValue m))
    )

    (defn #_"TransientHashMap" TransientHashMap'new-5 [#_"AtomicReference<Thread>" edit, #_"INode" root, #_"int" count, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (ATransientMap'new) (TransientHashMap'init))]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :hasNull hasNull))
            (§ ass this (assoc this :nullValue nullValue))
            this
        )
    )

    #_override
    (defn #_"ITransientMap" ATransientMap'''doAssoc--TransientHashMap [#_"TransientHashMap" this, #_"Object" key, #_"Object" val]
        (if (nil? key)
            (do
                (when-not (= (:nullValue this) val)
                    (§ ass this (assoc this :nullValue val))
                )
                (when (not (:hasNull this))
                    (§ ass this (assoc this :count (inc (:count this))))
                    (§ ass this (assoc this :hasNull true))
                )
                this
            )
            (let [_ (§ ass (:val (:leafFlag this)) nil)
                  #_"INode" n (INode'''assoc-7 (or (:root this) BitmapIndexedNode'EMPTY), (:edit this), 0, (PersistentHashMap'hash key), key, val, (:leafFlag this))]
                (when (not= n (:root this))
                    (§ ass this (assoc this :root n))
                )
                (when (some? (:val (:leafFlag this)))
                    (§ ass this (assoc this :count (inc (:count this))))
                )
                this
            )
        )
    )

    #_override
    (defn #_"ITransientMap" ATransientMap'''doWithout--TransientHashMap [#_"TransientHashMap" this, #_"Object" key]
        (if (nil? key)
            (when (:hasNull this) => this
                (§ ass this (assoc this :hasNull false))
                (§ ass this (assoc this :nullValue nil))
                (§ ass this (assoc this :count (dec (:count this))))
                this
            )
            (when (some? (:root this)) => this
                (let [_ (§ ass (:val (:leafFlag this)) nil)
                      #_"INode" n (INode'''without-6 (:root this), (:edit this), 0, (PersistentHashMap'hash key), key, (:leafFlag this))]
                    (when (not= n (:root this))
                        (§ ass this (assoc this :root n))
                    )
                    (when (some? (:val (:leafFlag this)))
                        (§ ass this (assoc this :count (dec (:count this))))
                    )
                    this
                )
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" ATransientMap'''doPersistent--TransientHashMap [#_"TransientHashMap" this]
        (.set (:edit this), nil)
        (PersistentHashMap'new-4 (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_override
    (defn #_"Object" ATransientMap'''doValAt--TransientHashMap [#_"TransientHashMap" this, #_"Object" key, #_"Object" notFound]
        (if (nil? key)
            (when (:hasNull this) => notFound
                (:nullValue this)
            )
            (when (some? (:root this)) => notFound
                (INode'''find-5 (:root this), 0, (PersistentHashMap'hash key), key, notFound)
            )
        )
    )

    #_override
    (defn #_"int" ATransientMap'''doCount--TransientHashMap [#_"TransientHashMap" this]
        (:count this)
    )

    #_override
    (defn #_"void" ATransientMap'''ensureEditable--TransientHashMap [#_"TransientHashMap" this]
        (when (nil? (.get (:edit this)))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

(class-ns HSeq (§ extends ASeq)
    (defn #_"ISeq" HSeq'create-1 [#_"INode[]" nodes]
        (HSeq'create-4 nil, nodes, 0, nil)
    )

    (defn- #_"ISeq" HSeq'create-4 [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
        (when (nil? s) => (HSeq'new meta, nodes, i, s)
            (loop-when i (< i (alength nodes))
                (let-when [#_"INode" ai (aget nodes i)] (some? ai) => (recur (inc i))
                    (let-when [s (INode'''nodeSeq ai)] (some? s) => (recur (inc i))
                        (HSeq'new meta, nodes, (inc i), s)
                    )
                )
            )
        )
    )

    (defn- #_"HSeq" HSeq'init []
        (hash-map
            #_"INode[]" :nodes nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn- #_"HSeq" HSeq'new [#_"IPersistentMap" meta, #_"INode[]" nodes, #_"int" i, #_"ISeq" s]
        (let [this (merge (ASeq'new-1 meta) (HSeq'init))]
            (§ ass this (assoc this :nodes nodes))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :s s))
            this
        )
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--HSeq [#_"HSeq" this, #_"IPersistentMap" meta]
        (HSeq'new meta, (:nodes this), (:i this), (:s this))
    )

    #_override
    (defn #_"Object" ISeq'''first--HSeq [#_"HSeq" this]
        (.first (:s this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--HSeq [#_"HSeq" this]
        (HSeq'create-4 nil, (:nodes this), (:i this), (.next (:s this)))
    )
)

(class-ns HIter (§ implements Iterator)
    (defn- #_"HIter" HIter'init []
        (hash-map
            #_"INode[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Iterator" :nestedIter nil
        )
    )

    (defn- #_"HIter" HIter'new [#_"INode[]" array, #_"IFn" f]
        (let [this (HIter'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :f f))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"HIter" this]
        (loop []
            (when (some? (:nestedIter this))
                (if (.hasNext (:nestedIter this))
                    (§ return true)
                    (§ ass this (assoc this :nestedIter nil))
                )
            )
            (when (< (:i this) (alength (:array this))) => false
                (let [#_"INode" ai (aget (:array this) (:i this))]
                    (§ ass this (assoc this :i (inc (:i this))))
                    (when (some? ai)
                        (§ ass this (assoc this :nestedIter (INode'''iterator ai, (:f this))))
                    )
                    (recur)
                )
            )
        )
    )

    #_foreign
    (§ defn #_"Object" next [#_"HIter" this]
        (when (.hasNext this) => (throw (NoSuchElementException.))
            (.next (:nestedIter this))
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"HIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ArrayNode (§ implements INode)
    (defn- #_"ArrayNode" ArrayNode'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_"int" :count 0
            #_"INode[]" :array nil
        )
    )

    (defn #_"ArrayNode" ArrayNode'new [#_"AtomicReference<Thread>" edit, #_"int" count, #_"INode[]" array]
        (let [this (ArrayNode'init)]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :array array))
            this
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-6--ArrayNode [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)]
            (if (some? ai)
                (let [#_"INode" node (INode'''assoc-6 ai, (+ shift 5), hash, key, val, addedLeaf)]
                    (when-not (= node ai) => this
                        (ArrayNode'new nil, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                    )
                )
                (let [#_"INode" node (INode'''assoc-6 BitmapIndexedNode'EMPTY, (+ shift 5), hash, key, val, addedLeaf)]
                    (ArrayNode'new nil, (inc (:count this)), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                )
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-4--ArrayNode [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)] (some? ai) => this
            (let-when-not [#_"INode" node (INode'''without-4 ai, (+ shift 5), hash, key)] (= node ai) => this
                (cond
                    (some? node)         (ArrayNode'new nil, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                    (<= (:count this) 8) (ArrayNode''pack this, nil, i) ;; shrink
                    :else                (ArrayNode'new nil, (dec (:count this)), (PersistentHashMap'cloneAndSet-3 (:array this), i, node))
                )
            )
        )
    )

    #_override
    (defn #_"IMapEntry" INode'''find-4--ArrayNode [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" node (aget (:array this) i)]
            (when (some? node)
                (INode'''find-4 node, (+ shift 5), hash, key)
            )
        )
    )

    #_override
    (defn #_"Object" INode'''find-5--ArrayNode [#_"ArrayNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" node (aget (:array this) i)]
            (when (some? node) => notFound
                (INode'''find-5 node, (+ shift 5), hash, key, notFound)
            )
        )
    )

    #_override
    (defn #_"ISeq" INode'''nodeSeq--ArrayNode [#_"ArrayNode" this]
        (HSeq'create-1 (:array this))
    )

    #_override
    (defn #_"Iterator" INode'''iterator--ArrayNode [#_"ArrayNode" this, #_"IFn" f]
        (HIter'new (:array this), f)
    )

    #_override
    (defn #_"Object" INode'''kvreduce--ArrayNode [#_"ArrayNode" this, #_"IFn" f, #_"Object" r]
        (let [#_"INode[]" a (:array this)]
            (loop-when [r r #_"int" i 0] (< i (alength a)) => r
                (let-when [#_"INode" node (aget a i)] (some? node) => (recur r (inc i))
                    (let [r (INode'''kvreduce node, f, r)]
                        (when-not (RT'isReduced r) => r
                            (recur r (inc i))
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" INode'''fold--ArrayNode [#_"ArrayNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (let [#_"List<Callable>" tasks (ArrayList.)]
            (doseq [#_"INode" node (:array this)]
                (when (some? node)
                    (.add tasks,
                        (§ reify Callable()
                            #_foreign
                            (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                                (INode'''fold node, combinef, reducef, fjtask, fjfork, fjjoin)
                            )
                        )
                    )
                )
            )
            (ArrayNode'foldTasks tasks, combinef, fjtask, fjfork, fjjoin)
        )
    )

    (defn #_"Object" ArrayNode'foldTasks [#_"List<Callable>" tasks, #_"IFn" combinef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (cond
            (.isEmpty tasks)
                (IFn'''invoke-1 combinef)
            (= (.size tasks) 1)
                (try
                    (.call (.get tasks, 0))
                    (catch Exception e
                        (throw (Util'sneakyThrow e))
                    )
                )
            :else
                (let [#_"int" n (.size tasks)
                      #_"List<Callable>" t1 (.subList tasks, 0, (/ n 2)) #_"List<Callable>" t2 (.subList tasks, (/ n 2), n)
                      #_"Object" forked
                        (IFn'''invoke-2 fjfork, (IFn'''invoke-2 fjtask,
                            (§ reify Callable()
                                #_foreign
                                (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                                    (ArrayNode'foldTasks t2, combinef, fjtask, fjfork, fjjoin)
                                )
                            )
                        ))]
                    (IFn'''invoke-3 combinef, (ArrayNode'foldTasks t1, combinef, fjtask, fjfork, fjjoin), (IFn'''invoke-2 fjjoin, forked))
                )
        )
    )

    #_method
    (defn- #_"ArrayNode" ArrayNode''ensureEditable [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit]
        (if (= (:edit this) edit)
            this
            (ArrayNode'new edit, (:count this), (.clone (:array this)))
        )
    )

    #_method
    (defn- #_"ArrayNode" ArrayNode''editAndSet [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"INode" node]
        (let [#_"ArrayNode" e (ArrayNode''ensureEditable this, edit)]
            (aset (:array e) i node)
            e
        )
    )

    #_method
    (defn- #_"INode" ArrayNode''pack [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" idx]
        (let [#_"Object[]" a (make-array Object (* 2 (dec (:count this))))
              [#_"int" bitmap #_"int" j]
                (loop-when [bitmap 0 j 1 #_"int" i 0] (< i idx) => [bitmap j]
                    (let [[bitmap j]
                            (when (some? (aget (:array this) i)) => [bitmap j]
                                (aset a j (aget (:array this) i))
                                [(| bitmap (<< 1 i)) (+ j 2)]
                            )]
                        (recur bitmap j (inc i))
                    )
                )
              bitmap
                (loop-when [bitmap bitmap j j #_"int" i (inc idx)] (< i (alength (:array this))) => bitmap
                    (let [[bitmap j]
                            (when (some? (aget (:array this) i)) => [bitmap j]
                                (aset a j (aget (:array this) i))
                                [(| bitmap (<< 1 i)) (+ j 2)]
                            )]
                        (recur bitmap j (inc i))
                    )
                )]
            (BitmapIndexedNode'new edit, bitmap, a)
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-7--ArrayNode [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)]
            (if (some? ai)
                (let [#_"INode" node (INode'''assoc-7 ai, edit, (+ shift 5), hash, key, val, addedLeaf)]
                    (when-not (= node ai) => this
                        (ArrayNode''editAndSet this, edit, i, node)
                    )
                )
                (let [#_"ArrayNode" e (ArrayNode''editAndSet this, edit, i, (INode'''assoc-7 BitmapIndexedNode'EMPTY, edit, (+ shift 5), hash, key, val, addedLeaf))]
                    (§ ass (:count e) (inc (:count e)))
                    e
                )
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-6--ArrayNode [#_"ArrayNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when [#_"int" i (PersistentHashMap'mask hash, shift) #_"INode" ai (aget (:array this) i)] (some? ai) => this
            (let-when-not [#_"INode" node (INode'''without-6 ai, edit, (+ shift 5), hash, key, removedLeaf)] (= node ai) => this
                (cond
                    (some? node)         (ArrayNode''editAndSet this, edit, i, node)
                    (<= (:count this) 8) (ArrayNode''pack this, edit, i) ;; shrink
                    :else
                        (let [#_"ArrayNode" e (ArrayNode''editAndSet this, edit, i, node)]
                            (§ ass (:count e) (dec (:count e)))
                            e
                        )
                )
            )
        )
    )
)

(class-ns BitmapIndexedNode (§ implements INode)
    (§ def #_"BitmapIndexedNode" BitmapIndexedNode'EMPTY (BitmapIndexedNode'new nil, 0, (object-array 0)))

    (defn- #_"BitmapIndexedNode" BitmapIndexedNode'init []
        (hash-map
            #_"int" :bitmap 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"BitmapIndexedNode" BitmapIndexedNode'new [#_"AtomicReference<Thread>" edit, #_"int" bitmap, #_"Object[]" array]
        (let [this (BitmapIndexedNode'init)]
            (§ ass this (assoc this :bitmap bitmap))
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :edit edit))
            this
        )
    )

    #_method
    (defn #_"int" BitmapIndexedNode''index [#_"BitmapIndexedNode" this, #_"int" bit]
        (Integer/bitCount (& (:bitmap this) (dec bit)))
    )

    #_override
    (defn #_"INode" INode'''assoc-6--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" bit (PersistentHashMap'bitpos hash, shift) #_"int" idx (BitmapIndexedNode''index this, bit)]
            (if-not (zero? (& (:bitmap this) bit))
                (let [#_"Object" keyOrNull (aget (:array this) (* 2 idx))
                      #_"Object" valOrNode (aget (:array this) (inc (* 2 idx)))
                      _ (cond
                            (nil? keyOrNull)
                                (let [#_"INode" n (INode'''assoc-6 (cast' INode valOrNode), (+ shift 5), hash, key, val, addedLeaf)]
                                    (when-not (= n valOrNode)
                                        (PersistentHashMap'cloneAndSet-3 (:array this), (inc (* 2 idx)), n)
                                    )
                                )
                            (Util'equiv-2oo key, keyOrNull)
                                (when-not (= val valOrNode)
                                    (PersistentHashMap'cloneAndSet-3 (:array this), (inc (* 2 idx)), val)
                                )
                            :else
                                (let [_ (§ ass (:val addedLeaf) addedLeaf)]
                                    (PersistentHashMap'cloneAndSet-5 (:array this), (* 2 idx), nil, (inc (* 2 idx)), (PersistentHashMap'createNode-6 (+ shift 5), keyOrNull, valOrNode, hash, key, val))
                                )
                        )]
                    (if (some? _) (BitmapIndexedNode'new nil, (:bitmap this), _) this)
                )
                (let [#_"int" n (Integer/bitCount (:bitmap this))]
                    (if (<= 16 n)
                        (let [#_"INode[]" nodes (make-array #_"INode" Object 32) #_"int" jdx (PersistentHashMap'mask hash, shift)]
                            (aset nodes jdx (INode'''assoc-6 BitmapIndexedNode'EMPTY, (+ shift 5), hash, key, val, addedLeaf))
                            (loop-when [#_"int" j 0 #_"int" i 0] (< i 32)
                                (when-not (= (& (>>> (:bitmap this) i) 1) 0) => (recur j (inc i))
                                    (if (some? (aget (:array this) j))
                                        (aset nodes i (INode'''assoc-6 BitmapIndexedNode'EMPTY, (+ shift 5), (PersistentHashMap'hash (aget (:array this) j)), (aget (:array this) j), (aget (:array this) (inc j)), addedLeaf))
                                        (aset nodes i (cast' INode (aget (:array this) (inc j))))
                                    )
                                    (recur (+ j 2) (inc i))
                                )
                            )
                            (ArrayNode'new nil, (inc n), nodes)
                        )
                        (let [#_"Object[]" a (make-array Object (* 2 (inc n)))]
                            (System/arraycopy (:array this), 0, a, 0, (* 2 idx))
                            (aset a (* 2 idx) key)
                            (§ ass (:val addedLeaf) addedLeaf)
                            (aset a (inc (* 2 idx)) val)
                            (System/arraycopy (:array this), (* 2 idx), a, (* 2 (inc idx)), (* 2 (- n idx)))
                            (BitmapIndexedNode'new nil, (| (:bitmap this) bit), a)
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-4--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => this
            (let [#_"int" i (BitmapIndexedNode''index this, bit) #_"int" ii (* 2 i)
                  #_"Object" keyOrNull (aget (:array this) ii)
                  #_"Object" valOrNode (aget (:array this) (inc ii))]
                (if (some? keyOrNull)
                    (when (Util'equiv-2oo key, keyOrNull) => this
                        ;; TODO: collapse
                        (BitmapIndexedNode'new nil, (bit-xor (:bitmap this) bit), (PersistentHashMap'removePair (:array this), i))
                    )
                    (let [#_"INode" n (INode'''without-4 (cast' INode valOrNode), (+ shift 5), hash, key)]
                        (cond
                            (= n valOrNode)
                                this
                            (some? n)
                                (BitmapIndexedNode'new nil, (:bitmap this), (PersistentHashMap'cloneAndSet-3 (:array this), (inc ii), n))
                            (= (:bitmap this) bit)
                                nil
                            :else
                                (BitmapIndexedNode'new nil, (bit-xor (:bitmap this) bit), (PersistentHashMap'removePair (:array this), i))
                        )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"IMapEntry" INode'''find-4--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit))
            (let [#_"int" i (BitmapIndexedNode''index this, bit)
                  #_"Object" keyOrNull (aget (:array this) (* 2 i))
                  #_"Object" valOrNode (aget (:array this) (inc (* 2 i)))]
                (cond
                    (nil? keyOrNull)                (INode'''find-4 (cast' INode valOrNode), (+ shift 5), hash, key)
                    (Util'equiv-2oo key, keyOrNull) (cast' IMapEntry (MapEntry'create keyOrNull, valOrNode))
                )
            )
        )
    )

    #_override
    (defn #_"Object" INode'''find-5--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => notFound
            (let [#_"int" i (BitmapIndexedNode''index this, bit)
                  #_"Object" keyOrNull (aget (:array this) (* 2 i))
                  #_"Object" valOrNode (aget (:array this) (inc (* 2 i)))]
                (cond
                    (nil? keyOrNull)                (INode'''find-5 (cast' INode valOrNode), (+ shift 5), hash, key, notFound)
                    (Util'equiv-2oo key, keyOrNull) valOrNode
                    :else                           notFound
                )
            )
        )
    )

    #_override
    (defn #_"ISeq" INode'''nodeSeq--BitmapIndexedNode [#_"BitmapIndexedNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_override
    (defn #_"Iterator" INode'''iterator--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"IFn" f]
        (NodeIter'new (:array this), f)
    )

    #_override
    (defn #_"Object" INode'''kvreduce--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"IFn" f, #_"Object" r]
        (NodeSeq'kvreduce (:array this), f, r)
    )

    #_override
    (defn #_"Object" INode'''fold--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (NodeSeq'kvreduce (:array this), reducef, (IFn'''invoke-1 combinef))
    )

    #_method
    (defn- #_"BitmapIndexedNode" BitmapIndexedNode''ensureEditable [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit]
        (when-not (= (:edit this) edit) => this
            (let [#_"int" n (Integer/bitCount (:bitmap this)) #_"Object[]" a (make-array Object (* 2 (inc n)))] ;; make room for next assoc
                (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                (BitmapIndexedNode'new edit, (:bitmap this), a)
            )
        )
    )

    #_method
    (defn- #_"BitmapIndexedNode" BitmapIndexedNode''editAndSet [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" x]
        (let [#_"BitmapIndexedNode" e (BitmapIndexedNode''ensureEditable this, edit)]
            (aset (:array e) i x)
            e
        )
    )

    #_method
    (defn- #_"BitmapIndexedNode" BitmapIndexedNode''editAndSet [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" x, #_"int" j, #_"Object" y]
        (let [#_"BitmapIndexedNode" e (BitmapIndexedNode''ensureEditable this, edit)]
            (aset (:array e) i x)
            (aset (:array e) j y)
            e
        )
    )

    #_method
    (defn- #_"BitmapIndexedNode" BitmapIndexedNode''editAndRemovePair [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" bit, #_"int" i]
        (when-not (= (:bitmap this) bit)
            (let [#_"BitmapIndexedNode" e (BitmapIndexedNode''ensureEditable this, edit) #_"Object[]" a (:array e) #_"int" n (alength a)]
                (§ ass (:bitmap e) (bit-xor (:bitmap e) bit))
                (System/arraycopy a, (* 2 (inc i)), a, (* 2 i), (- n (* 2 (inc i))))
                (aset a (- n 2) nil)
                (aset a (- n 1) nil)
                e
            )
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-7--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (let [#_"int" bit (PersistentHashMap'bitpos hash, shift) #_"int" idx (BitmapIndexedNode''index this, bit)]
            (if-not (zero? (& (:bitmap this) bit))
                (let [#_"Object" keyOrNull (aget (:array this) (* 2 idx))
                      #_"Object" valOrNode (aget (:array this) (inc (* 2 idx)))]
                    (cond
                        (nil? keyOrNull)
                            (let [#_"INode" n (INode'''assoc-7 (cast' INode valOrNode), edit, (+ shift 5), hash, key, val, addedLeaf)]
                                (when-not (= n valOrNode) => this
                                    (BitmapIndexedNode''editAndSet this, edit, (inc (* 2 idx)), n)
                                )
                            )
                        (Util'equiv-2oo key, keyOrNull)
                            (when-not (= val valOrNode) => this
                                (BitmapIndexedNode''editAndSet this, edit, (inc (* 2 idx)), val)
                            )
                        :else
                            (let [_ (§ ass (:val addedLeaf) addedLeaf)]
                                (BitmapIndexedNode''editAndSet this, edit, (* 2 idx), nil, (inc (* 2 idx)), (PersistentHashMap'createNode-7 edit, (+ shift 5), keyOrNull, valOrNode, hash, key, val))
                            )
                    )
                )
                (let [#_"int" n (Integer/bitCount (:bitmap this))]
                    (cond
                        (< (* n 2) (alength (:array this)))
                            (let [_ (§ ass (:val addedLeaf) addedLeaf)
                                  #_"BitmapIndexedNode" e (BitmapIndexedNode''ensureEditable this, edit)]
                                (System/arraycopy (:array e), (* 2 idx), (:array e), (* 2 (inc idx)), (* 2 (- n idx)))
                                (aset (:array e) (* 2 idx) key)
                                (aset (:array e) (inc (* 2 idx)) val)
                                (§ ass (:bitmap e) (| (:bitmap e) bit))
                                e
                            )
                        (<= 16 n)
                            (let [#_"INode[]" nodes (make-array #_"INode" Object 32) #_"int" jdx (PersistentHashMap'mask hash, shift)]
                                (aset nodes jdx (INode'''assoc-7 BitmapIndexedNode'EMPTY, edit, (+ shift 5), hash, key, val, addedLeaf))
                                (loop-when [#_"int" j 0 #_"int" i 0] (< i 32)
                                    (when-not (= (& (>>> (:bitmap this) i) 1) 0) => (recur j (inc i))
                                        (if (some? (aget (:array this) j))
                                            (aset nodes i (INode'''assoc-7 BitmapIndexedNode'EMPTY, edit, (+ shift 5), (PersistentHashMap'hash (aget (:array this) j)), (aget (:array this) j), (aget (:array this) (inc j)), addedLeaf))
                                            (aset nodes i (cast' INode (aget (:array this) (inc j))))
                                        )
                                        (recur (+ j 2) (inc i))
                                    )
                                )
                                (ArrayNode'new edit, (inc n), nodes)
                            )
                        :else
                            (let [#_"Object[]" a (make-array Object (* 2 (+ n 4)))]
                                (System/arraycopy (:array this), 0, a, 0, (* 2 idx))
                                (aset a (* 2 idx) key)
                                (§ ass (:val addedLeaf) addedLeaf)
                                (aset a (inc (* 2 idx)) val)
                                (System/arraycopy (:array this), (* 2 idx), a, (* 2 (inc idx)), (* 2 (- n idx)))
                                (let [#_"BitmapIndexedNode" e (BitmapIndexedNode''ensureEditable this, edit)]
                                    (§ ass (:array e) a)
                                    (§ ass (:bitmap e) (| (:bitmap e) bit))
                                    e
                                )
                            )
                    )
                )
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-6--BitmapIndexedNode [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when-not [#_"int" bit (PersistentHashMap'bitpos hash, shift)] (zero? (& (:bitmap this) bit)) => this
            (let [#_"int" i (BitmapIndexedNode''index this, bit) #_"int" ii (* 2 i)
                  #_"Object" keyOrNull (aget (:array this) ii)
                  #_"Object" valOrNode (aget (:array this) (inc ii))]
                (if (some? keyOrNull)
                    (when (Util'equiv-2oo key, keyOrNull) => this
                        (§ ass (:val removedLeaf) removedLeaf)
                        ;; TODO: collapse
                        (BitmapIndexedNode''editAndRemovePair this, edit, bit, i)
                    )
                    (let [#_"INode" n (INode'''without-6 (cast' INode valOrNode), edit, (+ shift 5), hash, key, removedLeaf)]
                        (cond
                            (= n valOrNode)
                                this
                            (some? n)
                                (BitmapIndexedNode''editAndSet this, edit, (inc ii), n)
                            (= (:bitmap this) bit)
                                nil
                            :else
                                (BitmapIndexedNode''editAndRemovePair this, edit, bit, i)
                        )
                    )
                )
            )
        )
    )
)

(class-ns HashCollisionNode (§ implements INode)
    (defn- #_"HashCollisionNode" HashCollisionNode'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_"int" :hash 0
            #_"int" :count 0
            #_"Object[]" :array nil
        )
    )

    (defn #_"HashCollisionNode" HashCollisionNode'new [#_"AtomicReference<Thread>" edit, #_"int" hash, #_"int" count & #_"Object..." array]
        (let [this (HashCollisionNode'init)]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :hash hash))
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :array array))
            this
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-6--HashCollisionNode [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (if (= hash (:hash this))
            (let [#_"int" i (HashCollisionNode''findIndex this, key)]
                (if (<= 0 i)
                    (when-not (= (aget (:array this) (inc i)) val) => this
                        (HashCollisionNode'new nil, hash, (:count this), (PersistentHashMap'cloneAndSet-3 (:array this), (inc i), val))
                    )
                    (let [#_"int" n (:count this) #_"Object[]" a (make-array Object (* 2 (inc n)))]
                        (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                        (aset a (* 2 n) key)
                        (aset a (inc (* 2 n)) val)
                        (§ ass (:val addedLeaf) addedLeaf)
                        (HashCollisionNode'new (:edit this), hash, (inc n), a)
                    )
                )
            )
            ;; nest it in a bitmap node
            (let [#_"BitmapIndexedNode" node (BitmapIndexedNode'new nil, (PersistentHashMap'bitpos (:hash this), shift), (object-array [ nil, this ]))]
                (INode'''assoc-6 node, shift, hash, key, val, addedLeaf)
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-4--HashCollisionNode [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (HashCollisionNode''findIndex this, key)] (<= 0 i) => this
            (let-when [#_"int" n (:count this)] (< 1 n)
                (HashCollisionNode'new nil, hash, (dec n), (PersistentHashMap'removePair (:array this), (/ i 2)))
            )
        )
    )

    #_override
    (defn #_"IMapEntry" INode'''find-4--HashCollisionNode [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key]
        (let-when [#_"int" i (HashCollisionNode''findIndex this, key)] (<= 0 i)
            (let-when [#_"Object" ai (aget (:array this) i)] (Util'equiv-2oo key, ai)
                (cast' IMapEntry (MapEntry'create ai, (aget (:array this) (inc i))))
            )
        )
    )

    #_override
    (defn #_"Object" INode'''find-5--HashCollisionNode [#_"HashCollisionNode" this, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" notFound]
        (let-when [#_"int" i (HashCollisionNode''findIndex this, key)] (<= 0 i) => notFound
            (when (Util'equiv-2oo key, (aget (:array this) i)) => notFound
                (aget (:array this) (inc i))
            )
        )
    )

    #_override
    (defn #_"ISeq" INode'''nodeSeq--HashCollisionNode [#_"HashCollisionNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_override
    (defn #_"Iterator" INode'''iterator--HashCollisionNode [#_"HashCollisionNode" this, #_"IFn" f]
        (NodeIter'new (:array this), f)
    )

    #_override
    (defn #_"Object" INode'''kvreduce--HashCollisionNode [#_"HashCollisionNode" this, #_"IFn" f, #_"Object" r]
        (NodeSeq'kvreduce (:array this), f, r)
    )

    #_override
    (defn #_"Object" INode'''fold--HashCollisionNode [#_"HashCollisionNode" this, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        (NodeSeq'kvreduce (:array this), reducef, (IFn'''invoke-1 combinef))
    )

    #_method
    (defn #_"int" HashCollisionNode''findIndex [#_"HashCollisionNode" this, #_"Object" key]
        (let [#_"int" n (* 2 (:count this))]
            (loop-when [#_"int" i 0] (< i n) => -1
                (if (Util'equiv-2oo key, (aget (:array this) i)) i (recur (+ i 2)))
            )
        )
    )

    #_method
    (defn- #_"HashCollisionNode" HashCollisionNode''ensureEditable [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit]
        (when-not (= (:edit this) edit) => this
            (let [#_"int" n (:count this) #_"Object[]" a (make-array Object (* 2 (inc n)))] ;; make room for next assoc
                (System/arraycopy (:array this), 0, a, 0, (* 2 n))
                (HashCollisionNode'new edit, (:hash this), n, a)
            )
        )
    )

    #_method
    (defn- #_"HashCollisionNode" HashCollisionNode''ensureEditable [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" count, #_"Object[]" array]
        (if (= (:edit this) edit)
            (assoc this :array array :count count)
            (HashCollisionNode'new edit, (:hash this), count, array)
        )
    )

    #_method
    (defn- #_"HashCollisionNode" HashCollisionNode''editAndSet [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a]
        (let [#_"HashCollisionNode" e (HashCollisionNode''ensureEditable this, edit)]
            (aset (:array e) i a)
            e
        )
    )

    #_method
    (defn- #_"HashCollisionNode" HashCollisionNode''editAndSet [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" i, #_"Object" a, #_"int" j, #_"Object" b]
        (let [#_"HashCollisionNode" e (HashCollisionNode''ensureEditable this, edit)]
            (aset (:array e) i a)
            (aset (:array e) j b)
            e
        )
    )

    #_override
    (defn #_"INode" INode'''assoc-7--HashCollisionNode [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Object" val, #_"Box" addedLeaf]
        (if (= hash (:hash this))
            (let [#_"int" i (HashCollisionNode''findIndex this, key)]
                (if (<= 0 i)
                    (when-not (= (aget (:array this) (inc i)) val) => this
                        (HashCollisionNode''editAndSet this, edit, (inc i), val)
                    )
                    (let [#_"int" n (:count this) #_"int" m (alength (:array this))]
                        (if (< (* 2 n) m)
                            (let [_ (§ ass (:val addedLeaf) addedLeaf)
                                  #_"HashCollisionNode" e (HashCollisionNode''editAndSet this, edit, (* 2 n), key, (inc (* 2 n)), val)]
                                (§ ass (:count e) (inc (:count e)))
                                e
                            )
                            (let [#_"Object[]" a (make-array Object (+ m 2))]
                                (System/arraycopy (:array this), 0, a, 0, m)
                                (aset a m key)
                                (aset a (inc m) val)
                                (§ ass (:val addedLeaf) addedLeaf)
                                (HashCollisionNode''ensureEditable this, edit, (inc n), a)
                            )
                        )
                    )
                )
            )
            ;; nest it in a bitmap node
            (let [#_"BitmapIndexedNode" node (BitmapIndexedNode'new edit, (PersistentHashMap'bitpos (:hash this), shift), (object-array [ nil, this, nil, nil ]))]
                (INode'''assoc-7 node, edit, shift, hash, key, val, addedLeaf)
            )
        )
    )

    #_override
    (defn #_"INode" INode'''without-6--HashCollisionNode [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" edit, #_"int" shift, #_"int" hash, #_"Object" key, #_"Box" removedLeaf]
        (let-when [#_"int" i (HashCollisionNode''findIndex this, key)] (<= 0 i) => this
            (§ ass (:val removedLeaf) removedLeaf)
            (let-when [#_"int" n (:count this)] (< 1 n)
                (let [#_"HashCollisionNode" e (HashCollisionNode''ensureEditable this, edit) #_"int" m (* 2 n)]
                    (aset (:array e) i (aget (:array e) (- m 2)))
                    (aset (:array e) (inc i) (aget (:array e) (- m 1)))
                    (aset (:array e) (- m 2) nil)
                    (aset (:array e) (- m 1) nil)
                    (§ ass (:count e) (dec (:count e)))
                    e
                )
            )
        )
    )
)

(class-ns NodeIter (§ implements Iterator)
    (def- #_"Object" NodeIter'NULL (Object.))

    (defn- #_"NodeIter" NodeIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Object" :nextEntry NodeIter'NULL
            #_"Iterator" :nextIter nil
        )
    )

    (defn #_"NodeIter" NodeIter'new [#_"Object[]" array, #_"IFn" f]
        (let [this (NodeIter'init)]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :f f))
            this
        )
    )

    #_method
    (defn- #_"boolean" NodeIter''advance [#_"NodeIter" this]
        (loop-when [] (< (:i this) (alength (:array this))) => false
            (let [#_"Object" key (aget (:array this) (:i this))
                  #_"Object" nodeOrVal (aget (:array this) (inc (:i this)))
                  _ (§ ass this (assoc this :i (+ (:i this) 2)))]
                (cond
                    (some? key)
                        (do
                            (§ ass this (assoc this :nextEntry (IFn'''invoke-3 (:f this), key, nodeOrVal)))
                            true
                        )
                    (some? nodeOrVal)
                        (let [#_"Iterator" it (INode'''iterator (cast' INode nodeOrVal), (:f this))]
                            (when (and (some? it) (.hasNext it)) => (recur)
                                (§ ass this (assoc this :nextIter it))
                                true
                            )
                        )
                    :else
                        (recur)
                )
            )
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"NodeIter" this]
        (or (not= (:nextEntry this) NodeIter'NULL) (some? (:nextIter this)) (NodeIter''advance this))
    )

    #_foreign
    (§ defn #_"Object" next [#_"NodeIter" this]
        (let [#_"Object" e (:nextEntry this)]
            (cond
                (not= e NodeIter'NULL)
                    (let [_ (§ ass this (assoc this :nextEntry NodeIter'NULL))]
                        e
                    )
                (some? (:nextIter this))
                    (let [_ (§ ass e (.next (:nextIter this)))
                          _ (when-not (.hasNext (:nextIter this))
                                (§ ass this (assoc this :nextIter nil))
                            )]
                        e
                    )
                (NodeIter''advance this)
                    (.next this)
                :else
                    (throw (NoSuchElementException.))
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"NodeIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns NodeSeq (§ extends ASeq)
    (defn- #_"NodeSeq" NodeSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-2 [#_"Object[]" array, #_"int" i]
        (NodeSeq'new-4 nil, array, i, nil)
    )

    (defn #_"ISeq" NodeSeq'create-1 [#_"Object[]" array]
        (NodeSeq'create-3 array, 0, nil)
    )

    (defn #_"Object" NodeSeq'kvreduce [#_"Object[]" array, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (alength array)) => r
            (let [r (if (some? (aget array i))
                        (IFn'''invoke-4 f, r, (aget array i), (aget array (inc i)))
                        (let-when [#_"INode" node (cast' INode (aget array (inc i)))] (some? node) => r
                            (INode'''kvreduce node, f, r)
                        )
                    )]
                (when-not (RT'isReduced r) => r
                    (recur r (+ i 2))
                )
            )
        )
    )

    (defn- #_"ISeq" NodeSeq'create-3 [#_"Object[]" array, #_"int" i, #_"ISeq" s]
        (when (nil? s) => (NodeSeq'new-4 nil, array, i, s)
            (loop-when i (< i (alength array))
                (when (nil? (aget array i)) => (NodeSeq'new-4 nil, array, i, nil)
                    (or
                        (when-let [#_"INode" node (cast' INode (aget array (inc i)))]
                            (when-let [s (INode'''nodeSeq node)]
                                (NodeSeq'new-4 nil, array, (+ i 2), s)
                            )
                        )
                        (recur (+ i 2))
                    )
                )
            )
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-4 [#_"IPersistentMap" meta, #_"Object[]" array, #_"int" i, #_"ISeq" s]
        (let [this (merge (ASeq'new-1 meta) (NodeSeq'init))]
            (§ ass this (assoc this :array array))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :s s))
            this
        )
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--NodeSeq [#_"NodeSeq" this, #_"IPersistentMap" meta]
        (NodeSeq'new-4 meta, (:array this), (:i this), (:s this))
    )

    #_override
    (defn #_"Object" ISeq'''first--NodeSeq [#_"NodeSeq" this]
        (if (some? (:s this))
            (.first (:s this))
            (MapEntry'create (aget (:array this) (:i this)), (aget (:array this) (inc (:i this))))
        )
    )

    #_override
    (defn #_"ISeq" ISeq'''next--NodeSeq [#_"NodeSeq" this]
        (if (some? (:s this))
            (NodeSeq'create-3 (:array this), (:i this), (.next (:s this)))
            (NodeSeq'create-3 (:array this), (+ (:i this) 2), nil)
        )
    )
)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ def #_"PersistentHashMap" PersistentHashMap'EMPTY (PersistentHashMap'new-4 0, nil, false, nil))
    (def- #_"Object" PersistentHashMap'NOT_FOUND (Object.))

    (defn #_"IPersistentMap" PersistentHashMap'create-1m [#_"Map" other]
        (let [#_"Iterator" it (.iterator (.entrySet other))]
            (loop-when [#_"ITransientMap" ret (IEditableCollection'''asTransient PersistentHashMap'EMPTY)] (.hasNext it) => (ITransientMap'''persistent ret)
                (let [#_"Map$Entry" e (cast Map$Entry (.next it))]
                    (recur (ITransientMap'''assoc ret, (.getKey e), (.getValue e)))
                )
            )
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-1a [& #_"Object..." init]
        (let [#_"ITransientMap" ret (IEditableCollection'''asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
                (§ ass ret (ITransientMap'''assoc ret, (aget init i), (aget init (inc i))))
            )
            (cast' PersistentHashMap (ITransientMap'''persistent ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1a [& #_"Object..." init]
        (let [#_"ITransientMap" ret (IEditableCollection'''asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [#_"int" i 0] (< i (alength init)) [(+ i 2)]
                (§ ass ret (ITransientMap'''assoc ret, (aget init i), (aget init (inc i))))
                (when (not= (.count ret) (inc (/ i 2)))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (aget init i))))
                )
            )
            (cast' PersistentHashMap (ITransientMap'''persistent ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'create-1s [#_"ISeq" items]
        (let [#_"ITransientMap" ret (IEditableCollection'''asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [items items] (some? items) [(.next (.next items))]
                (when (nil? (.next items))
                    (throw (IllegalArgumentException. (str "No value supplied for key: " (.first items))))
                )
                (§ ass ret (ITransientMap'''assoc ret, (.first items), (RT'second items)))
            )
            (cast' PersistentHashMap (ITransientMap'''persistent ret))
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1s [#_"ISeq" items]
        (let [#_"ITransientMap" ret (IEditableCollection'''asTransient PersistentHashMap'EMPTY)]
            (loop-when-recur [items items #_"int" i 0] (some? items) [(.next (.next items)) (inc i)]
                (when (nil? (.next items))
                    (throw (IllegalArgumentException. (str "No value supplied for key: " (.first items))))
                )
                (§ ass ret (ITransientMap'''assoc ret, (.first items), (RT'second items)))
                (when-not (= (.count ret) (inc i))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (.first items))))
                )
            )
            (cast' PersistentHashMap (ITransientMap'''persistent ret))
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-2 [#_"IPersistentMap" meta & #_"Object..." init]
        (-> (PersistentHashMap'create-1a init) (IObj'''withMeta meta))
    )

    (defn- #_"PersistentHashMap" PersistentHashMap'init []
        (hash-map
            #_"int" :count 0
            #_"INode" :root nil
            #_"boolean" :hasNull false
            #_"Object" :nullValue nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-4 [#_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :hasNull hasNull))
            (§ ass this (assoc this :nullValue nullValue))
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-5 [#_"IPersistentMap" meta, #_"int" count, #_"INode" root, #_"boolean" hasNull, #_"Object" nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :hasNull hasNull))
            (§ ass this (assoc this :nullValue nullValue))
            this
        )
    )

    (defn #_"int" PersistentHashMap'hash [#_"Object" k]
        (Util'hasheq k)
    )

    #_override
    (defn #_"boolean" Associative'''containsKey--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key]
        (if (nil? key)
            (:hasNull this)
            (and (some? (:root this))
                 (not= (INode'''find-5 (:root this), 0, (PersistentHashMap'hash key), key, PersistentHashMap'NOT_FOUND) PersistentHashMap'NOT_FOUND)
            )
        )
    )

    #_override
    (defn #_"IMapEntry" Associative'''entryAt--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key]
        (if (nil? key)
            (when (:hasNull this) (cast' IMapEntry (MapEntry'create nil, (:nullValue this))))
            (when (some? (:root this)) (INode'''find-4 (:root this), 0, (PersistentHashMap'hash key), key))
        )
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''assoc--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key, #_"Object" val]
        (if (nil? key)
            (when-not (and (:hasNull this) (= val (:nullValue this))) => this
                (PersistentHashMap'new-5 (IMeta'''meta this), (+ (:count this) (if (:hasNull this) 0 1)), (:root this), true, val)
            )
            (let [#_"Box" addedLeaf (Box'new nil)
                  #_"INode" newroot (INode'''assoc-6 (or (:root this) BitmapIndexedNode'EMPTY), 0, (PersistentHashMap'hash key), key, val, addedLeaf)]
                (when-not (= newroot (:root this)) => this
                    (PersistentHashMap'new-5 (IMeta'''meta this), (+ (:count this) (if (some? (:val addedLeaf)) 1 0)), newroot, (:hasNull this), (:nullValue this))
                )
            )
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key, #_"Object" notFound]
        (if (nil? key)
            (if (:hasNull this) (:nullValue this) notFound)
            (if (some? (:root this)) (INode'''find-5 (:root this), 0, (PersistentHashMap'hash key), key, notFound) notFound)
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key]
        (ILookup'''valAt-3 this, key, nil)
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''assocEx--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key, #_"Object" val]
        (when (Associative'''containsKey this, key)
            (throw (RuntimeException. "Key already present"))
        )
        (IPersistentMap'''assoc this, key, val)
    )

    #_override
    (defn #_"IPersistentMap" IPersistentMap'''without--PersistentHashMap [#_"PersistentHashMap" this, #_"Object" key]
        (cond
            (nil? key)
                (if (:hasNull this) (PersistentHashMap'new-5 (IMeta'''meta this), (dec (:count this)), (:root this), false, nil) this)
            (nil? (:root this))
                this
            :else
                (let [#_"INode" newroot (INode'''without-4 (:root this), 0, (PersistentHashMap'hash key), key)]
                    (when-not (= newroot (:root this)) => this
                        (PersistentHashMap'new-5 (IMeta'''meta this), (dec (:count this)), newroot, (:hasNull this), (:nullValue this))
                    )
                )
        )
    )

    (def #_"Iterator" PersistentHashMap'EMPTY_ITER
        (§ reify Iterator()
            #_foreign
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_foreign
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_foreign
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (defn- #_"Iterator" PersistentHashMap''iterator [#_"PersistentHashMap" this, #_"IFn" f]
        (let [#_"Iterator" rootIter (if (some? (:root this)) (INode'''iterator (:root this), f) PersistentHashMap'EMPTY_ITER)]
            (when (:hasNull this) => rootIter
                (§ reify Iterator()
                    (§ init
                        (hash-map
                            #_"boolean" :seen false
                        )
                    )

                    #_foreign
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        (or (not (:seen this)) (.hasNext rootIter))
                    )

                    #_foreign
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (when (not (:seen this)) => (.next rootIter)
                            (§ ass this (assoc this :seen true))
                            (IFn'''invoke-3 f, nil, (:nullValue this))
                        )
                    )

                    #_foreign
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"PersistentHashMap" this]
        (PersistentHashMap''iterator this, APersistentMap'MAKE_ENTRY)
    )

    #_override
    (defn #_"Iterator" IMapIterable'''keyIterator--PersistentHashMap [#_"PersistentHashMap" this]
        (PersistentHashMap''iterator this, APersistentMap'MAKE_KEY)
    )

    #_override
    (defn #_"Iterator" IMapIterable'''valIterator--PersistentHashMap [#_"PersistentHashMap" this]
        (PersistentHashMap''iterator this, APersistentMap'MAKE_VAL)
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--PersistentHashMap [#_"PersistentHashMap" this, #_"IFn" f, #_"Object" r]
        (let [r (if (:hasNull this) (IFn'''invoke-4 f, r, nil, (:nullValue this)) r)]
            (when-not (RT'isReduced r) => (IDeref'''deref (cast' IDeref r))
                (when (some? (:root this)) => r
                    (let [r (INode'''kvreduce (:root this), f, r)]
                        (when-not (RT'isReduced r) => (IDeref'''deref (cast' IDeref r))
                            r
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"Object" PersistentHashMap''fold [#_"PersistentHashMap" this, #_"long" n, #_"IFn" combinef, #_"IFn" reducef, #_"IFn" fjinvoke, #_"IFn" fjtask, #_"IFn" fjfork, #_"IFn" fjjoin]
        ;; we are ignoring n for now
        (let [#_"Callable" top
                (§ reify Callable()
                    #_foreign
                    (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                        (let [#_"Object" ret (IFn'''invoke-1 combinef)]
                            (when (some? (:root this))
                                (§ ass ret (IFn'''invoke-3 combinef, ret, (INode'''fold (:root this), combinef, reducef, fjtask, fjfork, fjjoin)))
                            )
                            (if (:hasNull this) (IFn'''invoke-3 combinef, ret, (IFn'''invoke-4 reducef, (IFn'''invoke-1 combinef), nil, (:nullValue this))) ret)
                        )
                    )
                )]
            (IFn'''invoke-2 fjinvoke, top)
        )
    )

    #_override
    (defn #_"int" Counted'''count--PersistentHashMap [#_"PersistentHashMap" this]
        (:count this)
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentHashMap [#_"PersistentHashMap" this]
        (let [#_"ISeq" s (when (some? (:root this)) (INode'''nodeSeq (:root this)))]
            (if (:hasNull this) (Cons'new-2 (MapEntry'create nil, (:nullValue this)), s) s)
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentHashMap [#_"PersistentHashMap" this]
        (IObj'''withMeta PersistentHashMap'EMPTY, (IMeta'''meta this))
    )

    (defn #_"int" PersistentHashMap'mask [#_"int" hash, #_"int" shift]
        (& (>>> hash shift) 0x01f)
    )

    #_override
    (defn #_"PersistentHashMap" IObj'''withMeta--PersistentHashMap [#_"PersistentHashMap" this, #_"IPersistentMap" meta]
        (PersistentHashMap'new-5 meta, (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_override
    (defn #_"TransientHashMap" IEditableCollection'''asTransient--PersistentHashMap [#_"PersistentHashMap" this]
        (TransientHashMap'new-1 this)
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentHashMap [#_"PersistentHashMap" this]
        (:_meta this)
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-3 [#_"Object[]" array, #_"int" i, #_"Object" x]
        (let [#_"Object[]" a (.clone array)]
            (aset a i x)
            a
        )
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-5 [#_"Object[]" array, #_"int" i, #_"Object" x, #_"int" j, #_"Object" y]
        (let [#_"Object[]" a (.clone array)]
            (aset a i x)
            (aset a j y)
            a
        )
    )

    (defn- #_"Object[]" PersistentHashMap'removePair [#_"Object[]" array, #_"int" i]
        (let [#_"Object[]" a (make-array Object (- (alength array) 2))]
            (System/arraycopy array, 0, a, 0, (* 2 i))
            (System/arraycopy array, (* 2 (inc i)), a, (* 2 i), (- (alength a) (* 2 i)))
            a
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-6 [#_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (PersistentHashMap'hash key1)]
            (when-not (= key1hash key2hash) => (HashCollisionNode'new nil, key1hash, 2, (object-array [ key1, val1, key2, val2 ]))
                (let [#_"Box" addedLeaf (Box'new nil) #_"AtomicReference<Thread>" edit (AtomicReference.)]
                    (-> BitmapIndexedNode'EMPTY
                        (INode'''assoc-7 edit, shift, key1hash, key1, val1, addedLeaf)
                        (INode'''assoc-7 edit, shift, key2hash, key2, val2, addedLeaf)
                    )
                )
            )
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-7 [#_"AtomicReference<Thread>" edit, #_"int" shift, #_"Object" key1, #_"Object" val1, #_"int" key2hash, #_"Object" key2, #_"Object" val2]
        (let [#_"int" key1hash (PersistentHashMap'hash key1)]
            (when-not (= key1hash key2hash) => (HashCollisionNode'new nil, key1hash, 2, (object-array [ key1, val1, key2, val2 ]))
                (let [#_"Box" addedLeaf (Box'new nil)]
                    (-> BitmapIndexedNode'EMPTY
                        (INode'''assoc-7 edit, shift, key1hash, key1, val1, addedLeaf)
                        (INode'''assoc-7 edit, shift, key2hash, key2, val2, addedLeaf)
                    )
                )
            )
        )
    )

    (defn- #_"int" PersistentHashMap'bitpos [#_"int" hash, #_"int" shift]
        (<< 1 (PersistentHashMap'mask hash, shift))
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

#_stateless
(class-ns TransientHashSet (§ extends ATransientSet)
    (defn #_"TransientHashSet" TransientHashSet'new [#_"ITransientMap" impl]
        (ATransientSet'new impl)
    )

    #_override
    (defn #_"IPersistentCollection" ITransientCollection'''persistent--TransientHashSet [#_"TransientHashSet" this]
        (PersistentHashSet'new nil, (ITransientMap'''persistent (:impl this)))
    )
)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def #_"PersistentHashSet" PersistentHashSet'EMPTY (PersistentHashSet'new nil, PersistentHashMap'EMPTY))

    (defn #_"PersistentHashSet" PersistentHashSet'create-1a [& #_"Object..." items]
        (let [#_"ITransientSet" ret (cast' ITransientSet (IEditableCollection'''asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [#_"int" i 0] (< i (alength items)) [(inc i)]
                (§ ass ret (cast' ITransientSet (ITransientCollection'''conj ret, (aget items i))))
            )
            (cast' PersistentHashSet (ITransientCollection'''persistent ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1l [#_"List" items]
        (let [#_"ITransientSet" ret (cast' ITransientSet (IEditableCollection'''asTransient PersistentHashSet'EMPTY))
              #_"Iterator" it (.iterator items)]
            (loop-when-recur [] (.hasNext it) [] => (cast' PersistentHashSet (ITransientCollection'''persistent ret))
                (§ ass ret (cast' ITransientSet (ITransientCollection'''conj ret, (.next it))))
            )
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1s [#_"ISeq" items]
        (let [#_"ITransientSet" ret (cast' ITransientSet (IEditableCollection'''asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [items items] (some? items) [(.next items)]
                (§ ass ret (cast' ITransientSet (ITransientCollection'''conj ret, (.first items))))
            )
            (cast' PersistentHashSet (ITransientCollection'''persistent ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1a [& #_"Object..." items]
        (let [#_"ITransientSet" ret (cast' ITransientSet (IEditableCollection'''asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [#_"int" i 0] (< i (alength items)) [(inc i)]
                (§ ass ret (cast' ITransientSet (ITransientCollection'''conj ret, (aget items i))))
                (when-not (= (.count ret) (inc i))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (aget items i))))
                )
            )
            (cast' PersistentHashSet (ITransientCollection'''persistent ret))
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1l [#_"List" items]
        (let [#_"ITransientSet" ret (cast' ITransientSet (IEditableCollection'''asTransient PersistentHashSet'EMPTY))
              #_"Iterator" it (.iterator items)]
            (loop-when-recur [#_"int" i 0] (.hasNext it) [(inc i)] => (cast' PersistentHashSet (ITransientCollection'''persistent ret))
                (let [#_"Object" key (.next it)]
                    (§ ass ret (cast' ITransientSet (ITransientCollection'''conj ret, key)))
                    (when-not (= (.count ret) (inc i))
                        (throw (IllegalArgumentException. (str "Duplicate key: " key)))
                    )
                )
            )
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1s [#_"ISeq" items]
        (let [#_"ITransientSet" ret (cast' ITransientSet (IEditableCollection'''asTransient PersistentHashSet'EMPTY))]
            (loop-when-recur [items items #_"int" i 0] (some? items) [(.next items) (inc i)]
                (§ ass ret (cast' ITransientSet (ITransientCollection'''conj ret, (.first items))))
                (when-not (= (.count ret) (inc i))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (.first items))))
                )
            )
            (cast' PersistentHashSet (ITransientCollection'''persistent ret))
        )
    )

    (defn- #_"PersistentHashSet" PersistentHashSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'new [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (let [this (merge (APersistentSet'new impl) (PersistentHashSet'init))]
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    #_override
    (defn #_"IPersistentSet" IPersistentSet'''disjoin--PersistentHashSet [#_"PersistentHashSet" this, #_"Object" key]
        (if (IPersistentSet'''contains this, key)
            (PersistentHashSet'new (IMeta'''meta this), (IPersistentMap'''without (:impl this), key))
            this
        )
    )

    #_override
    (defn #_"IPersistentSet" IPersistentCollection'''cons--PersistentHashSet [#_"PersistentHashSet" this, #_"Object" o]
        (if (IPersistentSet'''contains this, o)
            this
            (PersistentHashSet'new (IMeta'''meta this), (IPersistentMap'''assoc (:impl this), o, o))
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentHashSet [#_"PersistentHashSet" this]
        (IObj'''withMeta PersistentHashSet'EMPTY, (IMeta'''meta this))
    )

    #_override
    (defn #_"PersistentHashSet" IObj'''withMeta--PersistentHashSet [#_"PersistentHashSet" this, #_"IPersistentMap" meta]
        (PersistentHashSet'new meta, (:impl this))
    )

    #_override
    (defn #_"ITransientCollection" IEditableCollection'''asTransient--PersistentHashSet [#_"PersistentHashSet" this]
        (TransientHashSet'new (IEditableCollection'''asTransient (cast' PersistentHashMap (:impl this))))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentHashSet [#_"PersistentHashSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns Primordial (§ extends RestFn)
    (defn #_"Primordial" Primordial'new []
        (RestFn'new)
    )

    #_override
    (defn #_"int" RestFn'''getRequiredArity--Primordial [#_"Primordial" this]
        0
    )

    #_protected
    #_override
    (defn #_"Object" RestFn'''doInvoke-2--Primordial [#_"Primordial" this, #_"Object" args]
        (if (§ instance? ArraySeq args)
            (let [#_"Object[]" a (:array (cast' ArraySeq args))]
                (loop-when-recur [#_"IPersistentList" l PersistentList'EMPTY #_"int" i (dec (alength a))]
                                 (<= (:i (cast' ArraySeq args)) i)
                                 [(cast' IPersistentList (IPersistentCollection'''cons l, (aget a i))) (dec i)]
                              => l
                )
            )
            (let [#_"LinkedList" l (LinkedList.)]
                (loop-when-recur [#_"ISeq" s (RT'seq args)] (some? s) [(.next s)]
                    (.add l, (.first s))
                )
                (PersistentList'create l)
            )
        )
    )

    (defn #_"Object" Primordial'invokeStatic [#_"ISeq" args]
        (if (§ instance? ArraySeq args)
            (let [#_"Object[]" a (:array (cast' ArraySeq args))]
                (loop-when-recur [#_"IPersistentList" l PersistentList'EMPTY #_"int" i (dec (alength a))]
                                 (<= 0 i)
                                 [(cast' IPersistentList (IPersistentCollection'''cons l, (aget a i))) (dec i)]
                              => l
                )
            )
            (let [#_"LinkedList" l (LinkedList.)]
                (loop-when-recur [#_"ISeq" s (RT'seq args)] (some? s) [(.next s)]
                    (.add l, (.first s))
                )
                (PersistentList'create l)
            )
        )
    )

    #_override
    (defn #_"IObj" IObj'''withMeta--Primordial [#_"Primordial" this, #_"IPersistentMap" meta]
        (throw (UnsupportedOperationException.))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--Primordial [#_"Primordial" this]
        nil
    )
)

#_stateless
(class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
    (§ def #_"int" EmptyList'HASHEQ (Murmur3'hashOrdered Collections/EMPTY_LIST))

    (defn #_"EmptyList" EmptyList'new [#_"IPersistentMap" meta]
        (Obj'new-1 meta)
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"EmptyList" this]
        1
    )

    #_method
    (defn #_"int" EmptyList'hasheq [#_"EmptyList" this]
        EmptyList'HASHEQ
    )

    #_foreign
    (§ defn #_"String" toString [#_"EmptyList" this]
        "()"
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"EmptyList" this, #_"Object" o]
        (and (or (§ instance? Sequential o) (instance? List o)) (nil? (RT'seq o)))
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--EmptyList [#_"EmptyList" this, #_"Object" o]
        (.equals this, o)
    )

    #_override
    (defn #_"Object" ISeq'''first--EmptyList [#_"EmptyList" this]
        nil
    )

    #_override
    (defn #_"ISeq" ISeq'''next--EmptyList [#_"EmptyList" this]
        nil
    )

    #_override
    (defn #_"ISeq" ISeq'''more--EmptyList [#_"EmptyList" this]
        this
    )

    #_override
    (defn #_"PersistentList" IPersistentCollection'''cons--EmptyList [#_"EmptyList" this, #_"Object" o]
        (PersistentList'new-4 (IMeta'''meta this), o, nil, 1)
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--EmptyList [#_"EmptyList" this]
        this
    )

    #_override
    (defn #_"EmptyList" IObj'''withMeta--EmptyList [#_"EmptyList" this, #_"IPersistentMap" meta]
        (if (= meta (IMeta'''meta this))
            this
            (EmptyList'new meta)
        )
    )

    #_override
    (defn #_"Object" IPersistentStack'''peek--EmptyList [#_"EmptyList" this]
        nil
    )

    #_override
    (defn #_"IPersistentList" IPersistentStack'''pop--EmptyList [#_"EmptyList" this]
        (throw (IllegalStateException. "Can't pop empty list"))
    )

    #_override
    (defn #_"int" Counted'''count--EmptyList [#_"EmptyList" this]
        0
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--EmptyList [#_"EmptyList" this]
        nil
    )

    #_foreign
    (§ defn #_"int" size [#_"EmptyList" this]
        0
    )

    #_foreign
    (§ defn #_"boolean" isEmpty [#_"EmptyList" this]
        true
    )

    #_foreign
    (§ defn #_"boolean" contains [#_"EmptyList" this, #_"Object" o]
        false
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"EmptyList" this]
        (§ reify Iterator()
            #_foreign
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_foreign
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_foreign
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"EmptyList" this]
        RT'EMPTY_ARRAY
    )

    #_foreign
    (§ defn #_"boolean" add [#_"EmptyList" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" remove [#_"EmptyList" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"EmptyList" this, #_"Collection" collection]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"void" clear [#_"EmptyList" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" retainAll [#_"EmptyList" this, #_"Collection" collection]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" removeAll [#_"EmptyList" this, #_"Collection" collection]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" containsAll [#_"EmptyList" this, #_"Collection" collection]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"EmptyList" this, #_"Object[]" objects]
        (when (pos? (alength objects))
            (aset objects 0 nil)
        )
        objects
    )

    #_foreign
    (§ defn #_"List" subList [#_"EmptyList" this, #_"int" fromIndex, #_"int" toIndex]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" set [#_"EmptyList" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" remove [#_"EmptyList" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"int" indexOf [#_"EmptyList" this, #_"Object" o]
        (loop-when [#_"ISeq" s (Seqable'''seq this) #_"int" i 0] (some? s) => -1
            (if (Util'equiv-2oo (.first s), o) i (recur (.next s) (inc i)))
        )
    )

    #_foreign
    (§ defn #_"int" lastIndexOf [#_"EmptyList" this, #_"Object" o]
        (.lastIndexOf (ArrayList. this), o)
    )

    #_foreign
    (§ defn #_"ListIterator" listIterator [#_"EmptyList" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"ListIterator" listIterator [#_"EmptyList" this, #_"int" index]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object" get [#_"EmptyList" this, #_"int" index]
        (RT'nth-2 this, index)
    )

    #_foreign
    (§ defn #_"void" add [#_"EmptyList" this, #_"int" index, #_"Object" element]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"EmptyList" this, #_"int" index, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ def #_"IFn" PersistentList'creator (Primordial'new))

    (§ def #_"EmptyList" PersistentList'EMPTY (EmptyList'new nil))

    (defn- #_"PersistentList" PersistentList'init []
        (hash-map
            #_"Object" :_first nil
            #_"IPersistentList" :_rest nil
            #_"int" :_count 0
        )
    )

    (defn #_"PersistentList" PersistentList'new-1 [#_"Object" _first]
        (let [this (merge (ASeq'new-0) (PersistentList'init))]
            (§ ass this (assoc this :_first _first))
            (§ ass this (assoc this :_rest nil))
            (§ ass this (assoc this :_count 1))
            this
        )
    )

    (defn #_"PersistentList" PersistentList'new-4 [#_"IPersistentMap" meta, #_"Object" _first, #_"IPersistentList" _rest, #_"int" _count]
        (let [this (merge (ASeq'new-1 meta) (PersistentList'init))]
            (§ ass this (assoc this :_first _first))
            (§ ass this (assoc this :_rest _rest))
            (§ ass this (assoc this :_count _count))
            this
        )
    )

    (defn #_"IPersistentList" PersistentList'create [#_"List" items]
        (let [#_"ListIterator" it (.listIterator items, (.size items))]
            (loop-when-recur [#_"IPersistentList" ret PersistentList'EMPTY] (.hasPrevious it) [(cast' IPersistentList (IPersistentCollection'''cons ret, (.previous it)))] => ret)
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--PersistentList [#_"PersistentList" this]
        (:_first this)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--PersistentList [#_"PersistentList" this]
        (when-not (= (:_count this) 1)
            (cast' ISeq (:_rest this))
        )
    )

    #_override
    (defn #_"Object" IPersistentStack'''peek--PersistentList [#_"PersistentList" this]
        (.first this)
    )

    #_override
    (defn #_"IPersistentList" IPersistentStack'''pop--PersistentList [#_"PersistentList" this]
        (or (:_rest this) (IObj'''withMeta PersistentList'EMPTY, (:_meta this)))
    )

    #_override
    (defn #_"int" Counted'''count--PersistentList [#_"PersistentList" this]
        (:_count this)
    )

    #_override
    (defn #_"PersistentList" IPersistentCollection'''cons--PersistentList [#_"PersistentList" this, #_"Object" o]
        (PersistentList'new-4 (IMeta'''meta this), o, this, (inc (:_count this)))
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentList [#_"PersistentList" this]
        (IObj'''withMeta PersistentList'EMPTY, (IMeta'''meta this))
    )

    #_override
    (defn #_"PersistentList" IObj'''withMeta--PersistentList [#_"PersistentList" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (PersistentList'new-4 meta, (:_first this), (:_rest this), (:_count this))
        )
    )

    #_override
    (defn #_"Object" IReduce'''reduce--PersistentList [#_"PersistentList" this, #_"IFn" f]
        (loop-when [#_"Object" r (.first this) #_"ISeq" s (.next this)] (some? s) => r
            (let [r (IFn'''invoke-3 f, r, (.first s))]
                (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (.next s)))
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--PersistentList [#_"PersistentList" this, #_"IFn" f, #_"Object" r]
        (loop-when [r (IFn'''invoke-3 f, r, (.first this)) #_"ISeq" s (.next this)] (some? s) => (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
            (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur (IFn'''invoke-3 f, r, (.first s)) (.next s)))
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns QSeq (§ extends ASeq)
    (defn- #_"QSeq" QSeq'init []
        (hash-map
            #_"ISeq" :f nil
            #_"ISeq" :rseq nil
        )
    )

    (defn #_"QSeq" QSeq'new-2 [#_"ISeq" f, #_"ISeq" rseq]
        (let [this (merge (ASeq'new-0) (QSeq'init))]
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :rseq rseq))
            this
        )
    )

    (defn #_"QSeq" QSeq'new-3 [#_"IPersistentMap" meta, #_"ISeq" f, #_"ISeq" rseq]
        (let [this (merge (ASeq'new-1 meta) (QSeq'init))]
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :rseq rseq))
            this
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--QSeq [#_"QSeq" this]
        (.first (:f this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--QSeq [#_"QSeq" this]
        (let [#_"ISeq" f (.next (:f this)) #_"ISeq" r (:rseq this)]
            (cond
                (some? f) (QSeq'new-2 f, r)
                (some? r) (QSeq'new-2 r, nil)
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--QSeq [#_"QSeq" this]
        (+ (RT'count (:f this)) (RT'count (:rseq this)))
    )

    #_override
    (defn #_"QSeq" IObj'''withMeta--QSeq [#_"QSeq" this, #_"IPersistentMap" meta]
        (QSeq'new-3 meta, (:f this), (:rseq this))
    )
)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def #_"PersistentQueue" PersistentQueue'EMPTY (PersistentQueue'new nil, 0, nil, nil))

    (defn- #_"PersistentQueue" PersistentQueue'init []
        (hash-map
            #_"int" :cnt 0
            #_"ISeq" :f nil
            #_"PersistentVector" :r nil
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    (defn #_"PersistentQueue" PersistentQueue'new [#_"IPersistentMap" meta, #_"int" cnt, #_"ISeq" f, #_"PersistentVector" r]
        (let [this (merge (Obj'new-1 meta) (PersistentQueue'init))]
            (§ ass this (assoc this :cnt cnt))
            (§ ass this (assoc this :f f))
            (§ ass this (assoc this :r r))
            this
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--PersistentQueue [#_"PersistentQueue" this, #_"Object" obj]
        (and (§ instance? Sequential obj)
            (loop-when [#_"ISeq" s (Seqable'''seq this) #_"ISeq" ms (RT'seq obj)] (some? s) => (nil? ms)
                (and (some? ms) (Util'equiv-2oo (.first s), (.first ms))
                    (recur (.next s) (.next ms))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"PersistentQueue" this, #_"Object" obj]
        (and (§ instance? Sequential obj)
            (loop-when [#_"ISeq" s (Seqable'''seq this) #_"ISeq" ms (RT'seq obj)] (some? s) => (nil? ms)
                (and (some? ms) (Util'equals (.first s), (.first ms))
                    (recur (.next s) (.next ms))
                )
            )
        )
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"PersistentQueue" this]
        (let [#_"int" hash (:_hash this)]
            (when (zero? hash)
                (§ ass hash 1)
                (loop-when-recur [#_"ISeq" s (Seqable'''seq this)] (some? s) [(.next s)]
                    (§ ass hash (+ (* 31 hash) (if (nil? (.first s)) 0 (.hashCode (.first s)))))
                )
                (§ ass this (assoc this :_hash hash))
            )
            hash
        )
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--PersistentQueue [#_"PersistentQueue" this]
        (let [#_"int" cached (:_hasheq this)]
            (when (zero? cached)
                (§ ass this (assoc this :_hasheq (§ ass cached (Murmur3'hashOrdered this))))
            )
            cached
        )
    )

    #_override
    (defn #_"Object" IPersistentStack'''peek--PersistentQueue [#_"PersistentQueue" this]
        (RT'first (:f this))
    )

    #_override
    (defn #_"PersistentQueue" IPersistentStack'''pop--PersistentQueue [#_"PersistentQueue" this]
        (when (some? (:f this)) => this ;; hmmm... pop of empty queue -> empty queue?
            (let [#_"ISeq" f (.next (:f this)) #_"PersistentVector" r (:r this)
                  [f r]
                    (when (nil? f) => [f r]
                        [(RT'seq r) nil]
                    )]
                (PersistentQueue'new (IMeta'''meta this), (dec (:cnt this)), f, r)
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--PersistentQueue [#_"PersistentQueue" this]
        (:cnt this)
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentQueue [#_"PersistentQueue" this]
        (when (some? (:f this))
            (QSeq'new-2 (:f this), (RT'seq (:r this)))
        )
    )

    #_override
    (defn #_"PersistentQueue" IPersistentCollection'''cons--PersistentQueue [#_"PersistentQueue" this, #_"Object" o]
        (let [[#_"ISeq" f #_"PersistentVector" r]
                (if (nil? (:f this)) ;; empty
                    [(RT'list-1 o) nil]
                    [(:f this) (IPersistentVector'''cons (or (:r this) PersistentVector'EMPTY), o)]
                )]
            (PersistentQueue'new (IMeta'''meta this), (inc (:cnt this)), f, r)
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentQueue [#_"PersistentQueue" this]
        (IObj'''withMeta PersistentQueue'EMPTY, (IMeta'''meta this))
    )

    #_override
    (defn #_"PersistentQueue" IObj'''withMeta--PersistentQueue [#_"PersistentQueue" this, #_"IPersistentMap" meta]
        (PersistentQueue'new meta, (:cnt this), (:f this), (:r this))
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"PersistentQueue" this]
        (RT'seqToArray (Seqable'''seq this))
    )

    #_foreign
    (§ defn #_"boolean" add [#_"PersistentQueue" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" remove [#_"PersistentQueue" this, #_"Object" o]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" addAll [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"void" clear [#_"PersistentQueue" this]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" retainAll [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" removeAll [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"boolean" containsAll [#_"PersistentQueue" this, #_"Collection" c]
        (throw (UnsupportedOperationException.))
    )

    #_foreign
    (§ defn #_"Object[]" toArray [#_"PersistentQueue" this, #_"Object[]" a]
        (RT'seqToPassedArray (Seqable'''seq this), a)
    )

    #_foreign
    (§ defn #_"int" size [#_"PersistentQueue" this]
        (.count this)
    )

    #_foreign
    (§ defn #_"boolean" isEmpty [#_"PersistentQueue" this]
        (zero? (.count this))
    )

    #_foreign
    (§ defn #_"boolean" contains [#_"PersistentQueue" this, #_"Object" o]
        (loop-when [#_"ISeq" s (Seqable'''seq this)] (some? s) => false
            (or (Util'equiv-2oo (.first s), o) (recur (.next s)))
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"PersistentQueue" this]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"ISeq" :fseq (:f this)
                    #_"Iterator" :riter (when (some? (:r this)) (.iterator (:r this)))
                )
            )

            #_foreign
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (or (and (some? (:fseq this)) (some? (Seqable'''seq (:fseq this)))) (and (some? (:riter this)) (.hasNext (:riter this))))
            )

            #_foreign
            (§ defn #_"Object" next [#_"Iterator" this]
                (cond (some? (:fseq this))
                    (let [#_"Object" ret (.first (:fseq this))]
                        (§ ass this (assoc this :fseq (.next (:fseq this))))
                        ret
                    )
                    (and (some? (:riter this)) (.hasNext (:riter this)))
                    (do
                        (.next (:riter this))
                    )
                    :else
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_foreign
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

#_abstract
(class-ns TNode (§ extends AMapEntry)
    (defn- #_"TNode" TNode'init []
        (hash-map
            #_"Object" :key nil
        )
    )

    (defn #_"TNode" TNode'new [#_"Object" key]
        (let [this (merge (AMapEntry'new) (TNode'init))]
            (§ ass this (assoc this :key key))
            this
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''key--TNode [#_"TNode" this]
        (:key this)
    )

    #_override
    (defn #_"Object" IMapEntry'''val--TNode [#_"TNode" this]
        nil
    )

    #_foreign
    (§ defn #_"Object" getKey [#_"TNode" this]
        (IMapEntry'''key this)
    )

    #_foreign
    (§ defn #_"Object" getValue [#_"TNode" this]
        (IMapEntry'''val this)
    )

    #_abstract
    (defn #_"TNode" TNode'''left [#_"TNode" this]
        nil
    )

    #_abstract
    (defn #_"TNode" TNode'''right [#_"TNode" this]
        nil
    )

    #_abstract
    (defn #_"TNode" TNode'''addLeft [#_"TNode" this, #_"TNode" ins])
    #_abstract
    (defn #_"TNode" TNode'''addRight [#_"TNode" this, #_"TNode" ins])
    #_abstract
    (defn #_"TNode" TNode'''removeLeft [#_"TNode" this, #_"TNode" del])
    #_abstract
    (defn #_"TNode" TNode'''removeRight [#_"TNode" this, #_"TNode" del])
    #_abstract
    (defn #_"TNode" TNode'''blacken [#_"TNode" this])
    #_abstract
    (defn #_"TNode" TNode'''redden [#_"TNode" this])

    #_abstract
    (defn #_"TNode" TNode'''balanceLeft [#_"TNode" this, #_"TNode" parent]
        (PersistentTreeMap'black (:key parent), (IMapEntry'''val parent), this, (TNode'''right parent))
    )

    #_abstract
    (defn #_"TNode" TNode'''balanceRight [#_"TNode" this, #_"TNode" parent]
        (PersistentTreeMap'black (:key parent), (IMapEntry'''val parent), (TNode'''left parent), this)
    )

    #_abstract
    (defn #_"TNode" TNode'''replace [#_"TNode" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right])

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--TNode [#_"TNode" this, #_"IFn" f, #_"Object" r]
        (or
            (when (some? (TNode'''left this))
                (let [r (IKVReduce'''kvreduce (TNode'''left this), f, r)]
                    (when (RT'isReduced r)
                        r
                    )
                )
            )
            (let [r (IFn'''invoke-4 f, r, (IMapEntry'''key this), (IMapEntry'''val this))]
                (cond
                    (RT'isReduced r)      r
                    (some? (TNode'''right this)) (IKVReduce'''kvreduce (TNode'''right this), f, r)
                    :else                 r
                )
            )
        )
    )
)

#_stateless
(class-ns Black (§ extends TNode)
    (defn #_"Black" Black'new [#_"Object" key]
        (TNode'new key)
    )

    #_override
    (defn #_"TNode" TNode'''addLeft--Black [#_"Black" this, #_"TNode" ins]
        (TNode'''balanceLeft ins, this)
    )

    #_override
    (defn #_"TNode" TNode'''addRight--Black [#_"Black" this, #_"TNode" ins]
        (TNode'''balanceRight ins, this)
    )

    #_override
    (defn #_"TNode" TNode'''removeLeft--Black [#_"Black" this, #_"TNode" del]
        (PersistentTreeMap'balanceLeftDel (:key this), (IMapEntry'''val this), del, (TNode'''right this))
    )

    #_override
    (defn #_"TNode" TNode'''removeRight--Black [#_"Black" this, #_"TNode" del]
        (PersistentTreeMap'balanceRightDel (:key this), (IMapEntry'''val this), (TNode'''left this), del)
    )

    #_override
    (defn #_"TNode" TNode'''blacken--Black [#_"Black" this]
        this
    )

    #_override
    (defn #_"TNode" TNode'''redden--Black [#_"Black" this]
        (Red'new (:key this))
    )

    #_override
    (defn #_"TNode" TNode'''replace--Black [#_"Black" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (PersistentTreeMap'black key, val, left, right)
    )
)

(class-ns BlackVal (§ extends Black)
    (defn- #_"BlackVal" BlackVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackVal" BlackVal'new [#_"Object" key, #_"Object" val]
        (let [this (merge (Black'new key) (BlackVal'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''val--BlackVal [#_"BlackVal" this]
        (:val this)
    )

    #_override
    (defn #_"TNode" TNode'''redden--BlackVal [#_"BlackVal" this]
        (RedVal'new (:key this), (:val this))
    )
)

(class-ns BlackBranch (§ extends Black)
    (defn- #_"BlackBranch" BlackBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"BlackBranch" BlackBranch'new [#_"Object" key, #_"TNode" left, #_"TNode" right]
        (let [this (merge (Black'new key) (BlackBranch'init))]
            (§ ass this (assoc this :left left))
            (§ ass this (assoc this :right right))
            this
        )
    )

    #_override
    (defn #_"TNode" TNode'''left--BlackBranch [#_"BlackBranch" this]
        (:left this)
    )

    #_override
    (defn #_"TNode" TNode'''right--BlackBranch [#_"BlackBranch" this]
        (:right this)
    )

    #_override
    (defn #_"TNode" TNode'''redden--BlackBranch [#_"BlackBranch" this]
        (RedBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns BlackBranchVal (§ extends BlackBranch)
    (defn- #_"BlackBranchVal" BlackBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackBranchVal" BlackBranchVal'new [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (let [this (merge (BlackBranch'new key, left, right) (BlackBranchVal'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''val--BlackBranchVal [#_"BlackBranchVal" this]
        (:val this)
    )

    #_override
    (defn #_"TNode" TNode'''redden--BlackBranchVal [#_"BlackBranchVal" this]
        (RedBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

#_stateless
(class-ns Red (§ extends TNode)
    (defn #_"Red" Red'new [#_"Object" key]
        (TNode'new key)
    )

    #_override
    (defn #_"TNode" TNode'''addLeft--Red [#_"Red" this, #_"TNode" ins]
        (PersistentTreeMap'red (:key this), (IMapEntry'''val this), ins, (TNode'''right this))
    )

    #_override
    (defn #_"TNode" TNode'''addRight--Red [#_"Red" this, #_"TNode" ins]
        (PersistentTreeMap'red (:key this), (IMapEntry'''val this), (TNode'''left this), ins)
    )

    #_override
    (defn #_"TNode" TNode'''removeLeft--Red [#_"Red" this, #_"TNode" del]
        (PersistentTreeMap'red (:key this), (IMapEntry'''val this), del, (TNode'''right this))
    )

    #_override
    (defn #_"TNode" TNode'''removeRight--Red [#_"Red" this, #_"TNode" del]
        (PersistentTreeMap'red (:key this), (IMapEntry'''val this), (TNode'''left this), del)
    )

    #_override
    (defn #_"TNode" TNode'''blacken--Red [#_"Red" this]
        (Black'new (:key this))
    )

    #_override
    (defn #_"TNode" TNode'''redden--Red [#_"Red" this]
        (throw (UnsupportedOperationException. "Invariant violation"))
    )

    #_override
    (defn #_"TNode" TNode'''replace--Red [#_"Red" this, #_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (PersistentTreeMap'red key, val, left, right)
    )
)

(class-ns RedVal (§ extends Red)
    (defn- #_"RedVal" RedVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedVal" RedVal'new [#_"Object" key, #_"Object" val]
        (let [this (merge (Red'new key) (RedVal'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''val--RedVal [#_"RedVal" this]
        (:val this)
    )

    #_override
    (defn #_"TNode" TNode'''blacken--RedVal [#_"RedVal" this]
        (BlackVal'new (:key this), (:val this))
    )
)

(class-ns RedBranch (§ extends Red)
    (defn- #_"RedBranch" RedBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"RedBranch" RedBranch'new [#_"Object" key, #_"TNode" left, #_"TNode" right]
        (let [this (merge (Red'new key) (RedBranch'init))]
            (§ ass this (assoc this :left left))
            (§ ass this (assoc this :right right))
            this
        )
    )

    #_override
    (defn #_"TNode" TNode'''left--RedBranch [#_"RedBranch" this]
        (:left this)
    )

    #_override
    (defn #_"TNode" TNode'''right--RedBranch [#_"RedBranch" this]
        (:right this)
    )

    #_override
    (defn #_"TNode" TNode'''balanceLeft--RedBranch [#_"RedBranch" this, #_"TNode" parent]
        (cond (§ instance? Red (:left this))
            (do
                (PersistentTreeMap'red (:key this), (IMapEntry'''val this), (TNode'''blacken (:left this)), (PersistentTreeMap'black (:key parent), (IMapEntry'''val parent), (:right this), (TNode'''right parent)))
            )
            (§ instance? Red (:right this))
            (do
                (PersistentTreeMap'red (:key (:right this)), (IMapEntry'''val (:right this)), (PersistentTreeMap'black (:key this), (IMapEntry'''val this), (:left this), (TNode'''left (:right this))), (PersistentTreeMap'black (:key parent), (IMapEntry'''val parent), (TNode'''right (:right this)), (TNode'''right parent)))
            )
            :else
            (do
                (TNode'''balanceLeft (§ super ), parent)
            )
        )
    )

    #_override
    (defn #_"TNode" TNode'''balanceRight--RedBranch [#_"RedBranch" this, #_"TNode" parent]
        (cond (§ instance? Red (:right this))
            (do
                (PersistentTreeMap'red (:key this), (IMapEntry'''val this), (PersistentTreeMap'black (:key parent), (IMapEntry'''val parent), (TNode'''left parent), (:left this)), (TNode'''blacken (:right this)))
            )
            (§ instance? Red (:left this))
            (do
                (PersistentTreeMap'red (:key (:left this)), (IMapEntry'''val (:left this)), (PersistentTreeMap'black (:key parent), (IMapEntry'''val parent), (TNode'''left parent), (TNode'''left (:left this))), (PersistentTreeMap'black (:key this), (IMapEntry'''val this), (TNode'''right (:left this)), (:right this)))
            )
            :else
            (do
                (TNode'''balanceRight (§ super ), parent)
            )
        )
    )

    #_override
    (defn #_"TNode" TNode'''blacken--RedBranch [#_"RedBranch" this]
        (BlackBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns RedBranchVal (§ extends RedBranch)
    (defn- #_"RedBranchVal" RedBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedBranchVal" RedBranchVal'new [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (let [this (merge (RedBranch'new key, left, right) (RedBranchVal'init))]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_override
    (defn #_"Object" IMapEntry'''val--RedBranchVal [#_"RedBranchVal" this]
        (:val this)
    )

    #_override
    (defn #_"TNode" TNode'''blacken--RedBranchVal [#_"RedBranchVal" this]
        (BlackBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

(class-ns TSeq (§ extends ASeq)
    (defn- #_"TSeq" TSeq'init []
        (hash-map
            #_"ISeq" :stack nil
            #_"boolean" :asc false
            #_"int" :cnt 0
        )
    )

    (defn #_"TSeq" TSeq'new-2 [#_"ISeq" stack, #_"boolean" asc]
        (let [this (merge (ASeq'new-0) (TSeq'init))]
            (§ ass this (assoc this :stack stack))
            (§ ass this (assoc this :asc asc))
            (§ ass this (assoc this :cnt -1))
            this
        )
    )

    (defn #_"TSeq" TSeq'new-3 [#_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
        (let [this (merge (ASeq'new-0) (TSeq'init))]
            (§ ass this (assoc this :stack stack))
            (§ ass this (assoc this :asc asc))
            (§ ass this (assoc this :cnt cnt))
            this
        )
    )

    (defn #_"TSeq" TSeq'new-4 [#_"IPersistentMap" meta, #_"ISeq" stack, #_"boolean" asc, #_"int" cnt]
        (let [this (merge (ASeq'new-1 meta) (TSeq'init))]
            (§ ass this (assoc this :stack stack))
            (§ ass this (assoc this :asc asc))
            (§ ass this (assoc this :cnt cnt))
            this
        )
    )

    (defn #_"TSeq" TSeq'create [#_"TNode" t, #_"boolean" asc, #_"int" cnt]
        (TSeq'new-3 (TSeq'push t, nil, asc), asc, cnt)
    )

    (defn #_"ISeq" TSeq'push [#_"TNode" t, #_"ISeq" stack, #_"boolean" asc]
        (while (some? t)
            (§ ass stack (RT'cons t, stack))
            (§ ass t (if asc (TNode'''left t) (TNode'''right t)))
        )
        stack
    )

    #_override
    (defn #_"Object" ISeq'''first--TSeq [#_"TSeq" this]
        (.first (:stack this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--TSeq [#_"TSeq" this]
        (let [#_"TNode" t (cast' TNode (.first (:stack this)))
              #_"ISeq" nextstack (TSeq'push (if (:asc this) (TNode'''right t) (TNode'''left t)), (.next (:stack this)), (:asc this))]
            (when (some? nextstack)
                (TSeq'new-3 nextstack, (:asc this), (dec (:cnt this)))
            )
        )
    )

    #_override
    (defn #_"int" Counted'''count--TSeq [#_"TSeq" this]
        (when (neg? (:cnt this)) => (:cnt this)
            (.count (§ super ))
        )
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--TSeq [#_"TSeq" this, #_"IPersistentMap" meta]
        (TSeq'new-4 meta, (:stack this), (:asc this), (:cnt this))
    )
)

(class-ns NodeIterator (§ implements Iterator)
    (defn- #_"NodeIterator" NodeIterator'init []
        (hash-map
            #_"Stack" :stack (Stack.)
            #_"boolean" :asc false
        )
    )

    (defn #_"NodeIterator" NodeIterator'new [#_"TNode" t, #_"boolean" asc]
        (let [this (NodeIterator'init)]
            (§ ass this (assoc this :asc asc))
            (NodeIterator''push this, t)
            this
        )
    )

    #_method
    (defn #_"void" NodeIterator''push [#_"NodeIterator" this, #_"TNode" t]
        (while (some? t)
            (.push (:stack this), t)
            (§ ass t (if (:asc this) (TNode'''left t) (TNode'''right t)))
        )
        nil
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"NodeIterator" this]
        (not (.isEmpty (:stack this)))
    )

    #_foreign
    (§ defn #_"Object" next [#_"NodeIterator" this]
        (try
            (let [#_"TNode" t (cast' TNode (.pop (:stack this)))]
                (NodeIterator''push this, (if (:asc this) (TNode'''right t) (TNode'''left t)))
                t
            )
            (catch EmptyStackException e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"NodeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns KeyIterator (§ implements Iterator)
    (defn- #_"KeyIterator" KeyIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"KeyIterator" KeyIterator'new [#_"NodeIterator" it]
        (let [this (KeyIterator'init)]
            (§ ass this (assoc this :it it))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"KeyIterator" this]
        (.hasNext (:it this))
    )

    #_foreign
    (§ defn #_"Object" next [#_"KeyIterator" this]
        (:key (cast' TNode (.next (:it this))))
    )

    #_foreign
    (§ defn #_"void" remove [#_"KeyIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ValIterator (§ implements Iterator)
    (defn- #_"ValIterator" ValIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"ValIterator" ValIterator'new [#_"NodeIterator" it]
        (let [this (ValIterator'init)]
            (§ ass this (assoc this :it it))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"ValIterator" this]
        (.hasNext (:it this))
    )

    #_foreign
    (§ defn #_"Object" next [#_"ValIterator" this]
        (IMapEntry'''val (cast' TNode (.next (:it this))))
    )

    #_foreign
    (§ defn #_"void" remove [#_"ValIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ def #_"PersistentTreeMap" PersistentTreeMap'EMPTY (PersistentTreeMap'new-0))

    (defn #_"IPersistentMap" PersistentTreeMap'create-1m [#_"Map" other]
        (let [#_"Iterator" it (.iterator (.entrySet other))]
            (loop-when [#_"IPersistentMap" ret PersistentTreeMap'EMPTY] (.hasNext it) => ret
                (let [#_"Map$Entry" e (cast Map$Entry (.next it))]
                    (recur (IPersistentMap'''assoc ret, (.getKey e), (.getValue e)))
                )
            )
        )
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'init []
        (hash-map
            #_"Comparator" :comp nil
            #_"TNode" :tree nil
            #_"int" :_count 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-0 []
        (PersistentTreeMap'new-1 RT'DEFAULT_COMPARATOR)
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'new-1 [#_"Comparator" comp]
        (PersistentTreeMap'new-2 nil, comp)
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-2 [#_"IPersistentMap" meta, #_"Comparator" comp]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass this (assoc this :comp comp))
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :tree nil))
            (§ ass this (assoc this :_count 0))
            this
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4m [#_"IPersistentMap" meta, #_"Comparator" comp, #_"TNode" tree, #_"int" _count]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :comp comp))
            (§ ass this (assoc this :tree tree))
            (§ ass this (assoc this :_count _count))
            this
        )
    )

    #_override
    (defn #_"PersistentTreeMap" IObj'''withMeta--PersistentTreeMap [#_"PersistentTreeMap" this, #_"IPersistentMap" meta]
        (PersistentTreeMap'new-4m meta, (:comp this), (:tree this), (:_count this))
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-1s [#_"ISeq" items]
        (let [#_"IPersistentMap" ret PersistentTreeMap'EMPTY]
            (loop-when-recur [items items] (some? items) [(.next (.next items))]
                (when (nil? (.next items))
                    (throw (IllegalArgumentException. (str "No value supplied for key: " (.first items))))
                )
                (§ ass ret (IPersistentMap'''assoc ret, (.first items), (RT'second items)))
            )
            (cast' PersistentTreeMap ret)
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-2 [#_"Comparator" comp, #_"ISeq" items]
        (let [#_"IPersistentMap" ret (PersistentTreeMap'new-1 comp)]
            (loop-when-recur [items items] (some? items) [(.next (.next items))]
                (when (nil? (.next items))
                    (throw (IllegalArgumentException. (str "No value supplied for key: " (.first items))))
                )
                (§ ass ret (IPersistentMap'''assoc ret, (.first items), (RT'second items)))
            )
            (cast' PersistentTreeMap ret)
        )
    )

    #_override
    (defn #_"boolean" Associative'''containsKey--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key]
        (some? (Associative'''entryAt this, key))
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"PersistentTreeMap" this, #_"Object" obj]
        (try
            (.equals (§ super ), obj)
            (catch ClassCastException e
                false
            )
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" obj]
        (try
            (IPersistentCollection'''equiv (§ super ), obj)
            (catch ClassCastException e
                false
            )
        )
    )

    #_override
    (defn #_"PersistentTreeMap" IPersistentMap'''assocEx--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (PersistentTreeMap''add this, (:tree this), key, val, found)]
            (when (nil? t) ;; nil == already contains key
                (throw (RuntimeException. "Key already present"))
            )
            (PersistentTreeMap'new-4c (:comp this), (TNode'''blacken t), (inc (:_count this)), (IMeta'''meta this))
        )
    )

    #_override
    (defn #_"PersistentTreeMap" IPersistentMap'''assoc--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" val]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (PersistentTreeMap''add this, (:tree this), key, val, found)]
            (if (nil? t) ;; nil == already contains key
                (if (= (IMapEntry'''val (cast' TNode (:val found))) val) ;; note only get same collection on identity of val, not equals()
                    this
                    (PersistentTreeMap'new-4c (:comp this), (PersistentTreeMap''replace this, (:tree this), key, val), (:_count this), (IMeta'''meta this))
                )
                (PersistentTreeMap'new-4c (:comp this), (TNode'''blacken t), (inc (:_count this)), (IMeta'''meta this))
            )
        )
    )

    #_override
    (defn #_"PersistentTreeMap" IPersistentMap'''without--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key]
        (let [#_"Box" found (Box'new nil) #_"TNode" t (PersistentTreeMap''remove this, (:tree this), key, found)]
            (if (nil? t)
                (if (nil? (:val found)) ;; nil == doesn't contain key
                    this
                    (PersistentTreeMap'new-2 (IMeta'''meta this), (:comp this)) ;; empty
                )
                (PersistentTreeMap'new-4c (:comp this), (TNode'''blacken t), (dec (:_count this)), (IMeta'''meta this))
            )
        )
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentTreeMap [#_"PersistentTreeMap" this]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), true, (:_count this))
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentTreeMap [#_"PersistentTreeMap" this]
        (PersistentTreeMap'new-2 (IMeta'''meta this), (:comp this))
    )

    #_override
    (defn #_"ISeq" Reversible'''rseq--PersistentTreeMap [#_"PersistentTreeMap" this]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), false, (:_count this))
        )
    )

    #_override
    (defn #_"Comparator" Sorted'''comparator--PersistentTreeMap [#_"PersistentTreeMap" this]
        (:comp this)
    )

    #_override
    (defn #_"Object" Sorted'''entryKey--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" entry]
        (IMapEntry'''key (cast' IMapEntry entry))
    )

    #_override
    (defn #_"ISeq" Sorted'''seq--PersistentTreeMap [#_"PersistentTreeMap" this, #_"boolean" ascending]
        (when (pos? (:_count this))
            (TSeq'create (:tree this), ascending, (:_count this))
        )
    )

    #_override
    (defn #_"ISeq" Sorted'''seqFrom--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key, #_"boolean" ascending]
        (when (pos? (:_count this))
            (loop-when [#_"ISeq" s nil #_"TNode" t (:tree this)] (some? t) => (when (some? s) (TSeq'new-2 s, ascending))
                (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
                    (cond
                        (zero? cmp) (TSeq'new-2 (RT'cons t, s), ascending)
                        ascending   (if (neg? cmp) (recur (RT'cons t, s) (TNode'''left t)) (recur s (TNode'''right t)))
                        :else       (if (pos? cmp) (recur (RT'cons t, s) (TNode'''right t)) (recur s (TNode'''left t)))
                    )
                )
            )
        )
    )

    #_foreign
    (§ defn #_"NodeIterator" iterator [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), true)
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--PersistentTreeMap [#_"PersistentTreeMap" this, #_"IFn" f, #_"Object" r]
        (let [r (if (some? (:tree this)) (IKVReduce'''kvreduce (:tree this), f, r) r)]
            (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) r)
        )
    )

    #_method
    (defn #_"NodeIterator" PersistentTreeMap''reverseIterator [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), false)
    )

    #_method
    (defn #_"Iterator" PersistentTreeMap''keys [#_"PersistentTreeMap" this]
        (PersistentTreeMap''keys this, (.iterator this))
    )

    #_method
    (defn #_"Iterator" PersistentTreeMap''vals [#_"PersistentTreeMap" this]
        (PersistentTreeMap''vals this, (.iterator this))
    )

    #_method
    (defn #_"Iterator" PersistentTreeMap''keys [#_"PersistentTreeMap" this, #_"NodeIterator" it]
        (KeyIterator'new it)
    )

    #_method
    (defn #_"Iterator" PersistentTreeMap''vals [#_"PersistentTreeMap" this, #_"NodeIterator" it]
        (ValIterator'new it)
    )

    #_method
    (defn #_"Object" PersistentTreeMap''minKey [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (PersistentTreeMap''min this)]
            (when (some? t) (:key t))
        )
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''min [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (:tree this)]
            (when (some? t)
                (while (some? (TNode'''left t))
                    (§ ass t (TNode'''left t))
                )
            )
            t
        )
    )

    #_method
    (defn #_"Object" PersistentTreeMap''maxKey [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (PersistentTreeMap''max this)]
            (when (some? t) (:key t))
        )
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''max [#_"PersistentTreeMap" this]
        (let [#_"TNode" t (:tree this)]
            (when (some? t)
                (while (some? (TNode'''right t))
                    (§ ass t (TNode'''right t))
                )
            )
            t
        )
    )

    #_method
    (defn #_"int" PersistentTreeMap''depth [#_"PersistentTreeMap" this]
        (PersistentTreeMap''depth this, (:tree this))
    )

    #_method
    (defn #_"int" PersistentTreeMap''depth [#_"PersistentTreeMap" this, #_"TNode" t]
        (when (some? t) => 0
            (inc (Math/max (PersistentTreeMap''depth this, (TNode'''left t)), (PersistentTreeMap''depth this, (TNode'''right t))))
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key, #_"Object" notFound]
        (let [#_"TNode" n (Associative'''entryAt this, key)]
            (if (some? n) (IMapEntry'''val n) notFound)
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key]
        (ILookup'''valAt-3 this, key, nil)
    )

    #_method
    (defn #_"int" PersistentTreeMap''capacity [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_override
    (defn #_"int" Counted'''count--PersistentTreeMap [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_override
    (defn #_"TNode" Associative'''entryAt--PersistentTreeMap [#_"PersistentTreeMap" this, #_"Object" key]
        (loop-when [#_"TNode" t (:tree this)] (some? t) => t
            (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
                (cond
                    (neg? cmp) (recur (TNode'''left t))
                    (pos? cmp) (recur (TNode'''right t))
                    :else      t
                )
            )
        )
    )

    #_method
    (defn #_"int" PersistentTreeMap''doCompare [#_"PersistentTreeMap" this, #_"Object" k1, #_"Object" k2]
        (.compare (:comp this), k1, k2)
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''add [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Object" val, #_"Box" found]
        (if (nil? t)
            (if (nil? val)
                (Red'new key)
                (RedVal'new key, val)
            )
            (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
                (if (zero? cmp)
                    (do
                        (§ ass (:val found) t)
                        nil
                    )
                    (let [#_"TNode" ins (if (neg? cmp) (PersistentTreeMap''add this, (TNode'''left t), key, val, found) (PersistentTreeMap''add this, (TNode'''right t), key, val, found))]
                        (cond
                            (nil? ins) nil ;; found below
                            (neg? cmp) (TNode'''addLeft t, ins)
                            :else      (TNode'''addRight t, ins)
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''remove [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Box" found]
        (when (some? t) => nil ;; not found indicator
            (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
                (if (zero? cmp)
                    (do
                        (§ ass (:val found) t)
                        (PersistentTreeMap'append (TNode'''left t), (TNode'''right t))
                    )
                    (let [#_"TNode" del (if (neg? cmp) (PersistentTreeMap''remove this, (TNode'''left t), key, found) (PersistentTreeMap''remove this, (TNode'''right t), key, found))]
                        (when (or (some? del) (some? (:val found))) => nil ;; not found below
                            (if (neg? cmp)
                                (if (§ instance? Black (TNode'''left t))
                                    (PersistentTreeMap'balanceLeftDel (:key t), (IMapEntry'''val t), del, (TNode'''right t))
                                    (PersistentTreeMap'red (:key t), (IMapEntry'''val t), del, (TNode'''right t))
                                )
                                (if (§ instance? Black (TNode'''right t))
                                    (PersistentTreeMap'balanceRightDel (:key t), (IMapEntry'''val t), (TNode'''left t), del)
                                    (PersistentTreeMap'red (:key t), (IMapEntry'''val t), (TNode'''left t), del)
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'append [#_"TNode" left, #_"TNode" right]
        (cond
            (nil? left)
                right
            (nil? right)
                left
            (§ instance? Red left)
                (if (§ instance? Red right)
                    (let [#_"TNode" app (PersistentTreeMap'append (TNode'''right left), (TNode'''left right))]
                        (if (§ instance? Red app)
                            (PersistentTreeMap'red (:key app), (IMapEntry'''val app), (PersistentTreeMap'red (:key left), (IMapEntry'''val left), (TNode'''left left), (TNode'''left app)), (PersistentTreeMap'red (:key right), (IMapEntry'''val right), (TNode'''right app), (TNode'''right right)))
                            (PersistentTreeMap'red (:key left), (IMapEntry'''val left), (TNode'''left left), (PersistentTreeMap'red (:key right), (IMapEntry'''val right), app, (TNode'''right right)))
                        )
                    )
                    (PersistentTreeMap'red (:key left), (IMapEntry'''val left), (TNode'''left left), (PersistentTreeMap'append (TNode'''right left), right))
                )
            (§ instance? Red right)
                (PersistentTreeMap'red (:key right), (IMapEntry'''val right), (PersistentTreeMap'append left, (TNode'''left right)), (TNode'''right right))
            :else ;; black/black
                (let [#_"TNode" app (PersistentTreeMap'append (TNode'''right left), (TNode'''left right))]
                    (if (§ instance? Red app)
                        (PersistentTreeMap'red (:key app), (IMapEntry'''val app), (PersistentTreeMap'black (:key left), (IMapEntry'''val left), (TNode'''left left), (TNode'''left app)), (PersistentTreeMap'black (:key right), (IMapEntry'''val right), (TNode'''right app), (TNode'''right right)))
                        (PersistentTreeMap'balanceLeftDel (:key left), (IMapEntry'''val left), (TNode'''left left), (PersistentTreeMap'black (:key right), (IMapEntry'''val right), app, (TNode'''right right)))
                    )
                )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceLeftDel [#_"Object" key, #_"Object" val, #_"TNode" del, #_"TNode" right]
        (cond
            (§ instance? Red del)
                (PersistentTreeMap'red key, val, (TNode'''blacken del), right)
            (§ instance? Black right)
                (PersistentTreeMap'rightBalance key, val, del, (TNode'''redden right))
            (and (§ instance? Red right) (§ instance? Black (TNode'''left right)))
                (PersistentTreeMap'red (:key (TNode'''left right)), (IMapEntry'''val (TNode'''left right)), (PersistentTreeMap'black key, val, del, (TNode'''left (TNode'''left right))), (PersistentTreeMap'rightBalance (:key right), (IMapEntry'''val right), (TNode'''right (TNode'''left right)), (TNode'''redden (TNode'''right right))))
            :else
                (throw (UnsupportedOperationException. "Invariant violation"))
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceRightDel [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" del]
        (cond
            (§ instance? Red del)
                (PersistentTreeMap'red key, val, left, (TNode'''blacken del))
            (§ instance? Black left)
                (PersistentTreeMap'leftBalance key, val, (TNode'''redden left), del)
            (and (§ instance? Red left) (§ instance? Black (TNode'''right left)))
                (PersistentTreeMap'red (:key (TNode'''right left)), (IMapEntry'''val (TNode'''right left)), (PersistentTreeMap'leftBalance (:key left), (IMapEntry'''val left), (TNode'''redden (TNode'''left left)), (TNode'''left (TNode'''right left))), (PersistentTreeMap'black key, val, (TNode'''right (TNode'''right left)), del))
            :else
                (throw (UnsupportedOperationException. "Invariant violation"))
        )
    )

    (defn #_"TNode" PersistentTreeMap'leftBalance [#_"Object" key, #_"Object" val, #_"TNode" ins, #_"TNode" right]
        (cond
            (and (§ instance? Red ins) (§ instance? Red (TNode'''left ins)))
                (PersistentTreeMap'red (:key ins), (IMapEntry'''val ins), (TNode'''blacken (TNode'''left ins)), (PersistentTreeMap'black key, val, (TNode'''right ins), right))
            (and (§ instance? Red ins) (§ instance? Red (TNode'''right ins)))
                (PersistentTreeMap'red (:key (TNode'''right ins)), (IMapEntry'''val (TNode'''right ins)), (PersistentTreeMap'black (:key ins), (IMapEntry'''val ins), (TNode'''left ins), (TNode'''left (TNode'''right ins))), (PersistentTreeMap'black key, val, (TNode'''right (TNode'''right ins)), right))
            :else
                (PersistentTreeMap'black key, val, ins, right)
        )
    )

    (defn #_"TNode" PersistentTreeMap'rightBalance [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" ins]
        (cond
            (and (§ instance? Red ins) (§ instance? Red (TNode'''right ins)))
                (PersistentTreeMap'red (:key ins), (IMapEntry'''val ins), (PersistentTreeMap'black key, val, left, (TNode'''left ins)), (TNode'''blacken (TNode'''right ins)))
            (and (§ instance? Red ins) (§ instance? Red (TNode'''left ins)))
                (PersistentTreeMap'red (:key (TNode'''left ins)), (IMapEntry'''val (TNode'''left ins)), (PersistentTreeMap'black key, val, left, (TNode'''left (TNode'''left ins))), (PersistentTreeMap'black (:key ins), (IMapEntry'''val ins), (TNode'''right (TNode'''left ins)), (TNode'''right ins)))
            :else
                (PersistentTreeMap'black key, val, left, ins)
        )
    )

    #_method
    (defn #_"TNode" PersistentTreeMap''replace [#_"PersistentTreeMap" this, #_"TNode" t, #_"Object" key, #_"Object" val]
        (let [#_"int" cmp (PersistentTreeMap''doCompare this, key, (:key t))]
            (TNode'''replace t, (:key t), (if (zero? cmp) val (IMapEntry'''val t)), (if (neg? cmp) (PersistentTreeMap''replace this, (TNode'''left t), key, val) (TNode'''left t)), (if (pos? cmp) (PersistentTreeMap''replace this, (TNode'''right t), key, val) (TNode'''right t)))
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4c [#_"Comparator" comp, #_"TNode" tree, #_"int" count, #_"IPersistentMap" meta]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :comp comp))
            (§ ass this (assoc this :tree tree))
            (§ ass this (assoc this :_count count))
            this
        )
    )

    (defn #_"Red" PersistentTreeMap'red [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (if (and (nil? left) (nil? right))
            (if (nil? val)
                (Red'new key)
                (RedVal'new key, val)
            )
            (if (nil? val)
                (RedBranch'new key, left, right)
                (RedBranchVal'new key, val, left, right)
            )
        )
    )

    (defn #_"Black" PersistentTreeMap'black [#_"Object" key, #_"Object" val, #_"TNode" left, #_"TNode" right]
        (if (and (nil? left) (nil? right))
            (if (nil? val)
                (Black'new key)
                (BlackVal'new key, val)
            )
            (if (nil? val)
                (BlackBranch'new key, left, right)
                (BlackBranchVal'new key, val, left, right)
            )
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentTreeMap [#_"PersistentTreeMap" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def #_"PersistentTreeSet" PersistentTreeSet'EMPTY (PersistentTreeSet'new nil, PersistentTreeMap'EMPTY))

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-1 [#_"ISeq" s]
        (loop-when-recur [#_"PersistentTreeSet" t PersistentTreeSet'EMPTY s s]
                         (some? s)
                         [(cast' PersistentTreeSet (IPersistentCollection'''cons t, (.first s))) (.next s)]
                      => t
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-2 [#_"Comparator" comp, #_"ISeq" s]
        (loop-when-recur [#_"PersistentTreeSet" t (PersistentTreeSet'new nil, (PersistentTreeMap'new-2 nil, comp)) s s]
                         (some? s)
                         [(cast' PersistentTreeSet (IPersistentCollection'''cons t, (.first s))) (.next s)]
                      => t
        )
    )

    (defn- #_"PersistentTreeSet" PersistentTreeSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'new [#_"IPersistentMap" meta, #_"IPersistentMap" impl]
        (let [this (merge (APersistentSet'new impl) (PersistentTreeSet'init))]
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"PersistentTreeSet" this, #_"Object" obj]
        (try
            (.equals (§ super ), obj)
            (catch ClassCastException _
                false
            )
        )
    )

    #_override
    (defn #_"boolean" IPersistentCollection'''equiv--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" obj]
        (try
            (IPersistentCollection'''equiv (§ super ), obj)
            (catch ClassCastException _
                false
            )
        )
    )

    #_override
    (defn #_"IPersistentSet" IPersistentSet'''disjoin--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" key]
        (if (IPersistentSet'''contains this, key)
            (PersistentTreeSet'new (IMeta'''meta this), (IPersistentMap'''without (:impl this), key))
            this
        )
    )

    #_override
    (defn #_"IPersistentSet" IPersistentCollection'''cons--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" o]
        (if (IPersistentSet'''contains this, o)
            this
            (PersistentTreeSet'new (IMeta'''meta this), (IPersistentMap'''assoc (:impl this), o, o))
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentTreeSet [#_"PersistentTreeSet" this]
        (PersistentTreeSet'new (IMeta'''meta this), (cast' PersistentTreeMap (IPersistentCollection'''empty (:impl this))))
    )

    #_override
    (defn #_"ISeq" Reversible'''rseq--PersistentTreeSet [#_"PersistentTreeSet" this]
        (KeySeq'create (Reversible'''rseq (cast' Reversible (:impl this))))
    )

    #_override
    (defn #_"PersistentTreeSet" IObj'''withMeta--PersistentTreeSet [#_"PersistentTreeSet" this, #_"IPersistentMap" meta]
        (PersistentTreeSet'new meta, (:impl this))
    )

    #_override
    (defn #_"Comparator" Sorted'''comparator--PersistentTreeSet [#_"PersistentTreeSet" this]
        (Sorted'''comparator (cast' Sorted (:impl this)))
    )

    #_override
    (defn #_"Object" Sorted'''entryKey--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" entry]
        entry
    )

    #_override
    (defn #_"ISeq" Sorted'''seq--PersistentTreeSet [#_"PersistentTreeSet" this, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (cast' PersistentTreeMap (:impl this))]
            (RT'keys (Sorted'''seq m, ascending))
        )
    )

    #_override
    (defn #_"ISeq" Sorted'''seqFrom--PersistentTreeSet [#_"PersistentTreeSet" this, #_"Object" key, #_"boolean" ascending]
        (let [#_"PersistentTreeMap" m (cast' PersistentTreeMap (:impl this))]
            (RT'keys (Sorted'''seqFrom m, key, ascending))
        )
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentTreeSet [#_"PersistentTreeSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns VNode
    (defn- #_"VNode" VNode'init []
        (hash-map
            #_transient
            #_"AtomicReference<Thread>" :edit nil
            #_"Object[]" :array nil
        )
    )

    (defn #_"VNode" VNode'new-2 [#_"AtomicReference<Thread>" edit, #_"Object[]" array]
        (let [this (VNode'init)]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :array array))
            this
        )
    )

    (defn #_"VNode" VNode'new-1 [#_"AtomicReference<Thread>" edit]
        (let [this (VNode'init)]
            (§ ass this (assoc this :edit edit))
            (§ ass this (assoc this :array (make-array Object 32)))
            this
        )
    )
)

(class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
    (defn- #_"ChunkedSeq" ChunkedSeq'init []
        (hash-map
            #_"PersistentVector" :vec nil
            #_"Object[]" :node nil
            #_"int" :i 0
            #_"int" :offset 0
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-3 [#_"PersistentVector" vec, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new-0) (ChunkedSeq'init))]
            (§ ass this (assoc this :vec vec))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :offset offset))
            (§ ass this (assoc this :node (PersistentVector''arrayFor vec, i)))
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-5 [#_"IPersistentMap" meta, #_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new-1 meta) (ChunkedSeq'init))]
            (§ ass this (assoc this :vec vec))
            (§ ass this (assoc this :node node))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :offset offset))
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-4 [#_"PersistentVector" vec, #_"Object[]" node, #_"int" i, #_"int" offset]
        (let [this (merge (ASeq'new-0) (ChunkedSeq'init))]
            (§ ass this (assoc this :vec vec))
            (§ ass this (assoc this :node node))
            (§ ass this (assoc this :i i))
            (§ ass this (assoc this :offset offset))
            this
        )
    )

    #_override
    (defn #_"IChunk" IChunkedSeq'''chunkedFirst--ChunkedSeq [#_"ChunkedSeq" this]
        (ArrayChunk'new-2 (:node this), (:offset this))
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedNext--ChunkedSeq [#_"ChunkedSeq" this]
        (when (< (+ (:i this) (alength (:node this))) (:cnt (:vec this)))
            (ChunkedSeq'new-3 (:vec this), (+ (:i this) (alength (:node this))), 0)
        )
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedMore--ChunkedSeq [#_"ChunkedSeq" this]
        (or (IChunkedSeq'''chunkedNext this) PersistentList'EMPTY)
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--ChunkedSeq [#_"ChunkedSeq" this, #_"IPersistentMap" meta]
        (when-not (= meta (:_meta this)) => this
            (ChunkedSeq'new-5 meta, (:vec this), (:node this), (:i this), (:offset this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--ChunkedSeq [#_"ChunkedSeq" this]
        (aget (:node this) (:offset this))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--ChunkedSeq [#_"ChunkedSeq" this]
        (if (< (inc (:offset this)) (alength (:node this)))
            (ChunkedSeq'new-4 (:vec this), (:node this), (:i this), (inc (:offset this)))
            (IChunkedSeq'''chunkedNext this)
        )
    )

    #_override
    (defn #_"int" Counted'''count--ChunkedSeq [#_"ChunkedSeq" this]
        (- (:cnt (:vec this)) (+ (:i this) (:offset this)))
    )
)

(class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
    (defn- #_"TransientVector" TransientVector'init []
        (hash-map
            #_volatile
            #_"int" :cnt 0
            #_volatile
            #_"int" :shift 0
            #_volatile
            #_"VNode" :root nil
            #_volatile
            #_"Object[]" :tail nil
        )
    )

    (defn #_"TransientVector" TransientVector'new-4 [#_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (AFn'new) (TransientVector'init))]
            (§ ass this (assoc this :cnt cnt))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :tail tail))
            this
        )
    )

    (defn #_"TransientVector" TransientVector'new-1 [#_"PersistentVector" v]
        (TransientVector'new-4 (:cnt v), (:shift v), (.editableRoot (:root v)), (.editableTail (:tail v)))
    )

    #_override
    (defn #_"int" Counted'''count--TransientVector [#_"TransientVector" this]
        (TransientVector''ensureEditable this)
        (:cnt this)
    )

    #_method
    (defn #_"VNode" TransientVector''ensureEditable [#_"TransientVector" this, #_"VNode" node]
        (if (= (:edit node) (:edit (:root this)))
            node
            (VNode'new-2 (:edit (:root this)), (.clone (:array node)))
        )
    )

    #_method
    (defn #_"void" TransientVector''ensureEditable [#_"TransientVector" this]
        (when (nil? (.get (:edit (:root this))))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )

    (defn #_"VNode" TransientVector'editableRoot [#_"VNode" node]
        (VNode'new-2 (AtomicReference. (Thread/currentThread)), (.clone (:array node)))
    )

    #_override
    (defn #_"PersistentVector" ITransientCollection'''persistent--TransientVector [#_"TransientVector" this]
        (TransientVector''ensureEditable this)
        (.set (:edit (:root this)), nil)
        (let [#_"Object[]" trimmedTail (make-array Object (- (:cnt this) (TransientVector''tailoff this)))]
            (System/arraycopy (:tail this), 0, trimmedTail, 0, (alength trimmedTail))
            (PersistentVector'new-4 (:cnt this), (:shift this), (:root this), trimmedTail)
        )
    )

    (defn #_"Object[]" TransientVector'editableTail [#_"Object[]" tl]
        (let [#_"Object[]" ret (make-array Object 32)]
            (System/arraycopy tl, 0, ret, 0, (alength tl))
            ret
        )
    )

    #_override
    (defn #_"TransientVector" ITransientCollection'''conj--TransientVector [#_"TransientVector" this, #_"Object" val]
        (TransientVector''ensureEditable this)
        (let [#_"int" n (:cnt this)]
            (if (< (- n (TransientVector''tailoff this)) 32) ;; room in tail?
                (do
                    (aset (:tail this) (& n 0x01f) val)
                    (§ ass this (assoc this :cnt (inc (:cnt this))))
                    this
                )
                ;; full tail, push into tree
                (let [#_"VNode" tailnode (VNode'new-2 (:edit (:root this)), (:tail this))]
                    (§ ass this (assoc this :tail (make-array Object 32)))
                    (aset (:tail this) 0 val)
                    (let [#_"int" shift (:shift this)
                          [#_"VNode" root shift]
                            (if (< (<< 1 shift) (>>> n 5)) ;; overflow root?
                                (let [root (VNode'new-1 (:edit (:root this)))]
                                    (aset (:array root) 0 (:root this))
                                    (aset (:array root) 1 (PersistentVector'newPath (:edit (:root this)), shift, tailnode))
                                    [root (+ shift 5)]
                                )
                                [(TransientVector''pushTail this, shift, (:root this), tailnode) shift]
                            )]
                        (§ ass this (assoc this :root root))
                        (§ ass this (assoc this :shift shift))
                        (§ ass this (assoc this :cnt (inc (:cnt this))))
                        this
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"VNode" TransientVector''pushTail [#_"TransientVector" this, #_"int" level, #_"VNode" parent, #_"VNode" tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in parent
        (let [parent (TransientVector''ensureEditable this, parent)
              #_"int" i (& (>>> (dec (:cnt this)) level) 0x01f)
              #_"VNode" nodeToInsert
                (when-not (= level 5) => tailnode
                    (let [#_"VNode" child (cast' VNode (aget (:array parent) i))]
                        (if (some? child)
                            (TransientVector''pushTail this, (- level 5), child, tailnode)
                            (PersistentVector'newPath (:edit (:root this)), (- level 5), tailnode)
                        )
                    )
                )]
            (aset (:array parent) i nodeToInsert)
            parent
        )
    )

    #_method
    (defn- #_"int" TransientVector''tailoff [#_"TransientVector" this]
        (if (< (:cnt this) 32) 0 (<< (>>> (dec (:cnt this)) 5) 5))
    )

    #_method
    (defn- #_"Object[]" TransientVector''arrayFor [#_"TransientVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (TransientVector''tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(cast' VNode (aget (:array node) (& (>>> i level) 0x01f))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_method
    (defn- #_"Object[]" TransientVector''editableArrayFor [#_"TransientVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (TransientVector''tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(TransientVector''ensureEditable this, (cast' VNode (aget (:array node) (& (>>> i level) 0x01f)))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_override
    (defn #_"Object" ILookup'''valAt-2--TransientVector [#_"TransientVector" this, #_"Object" key]
        ;; note - relies on ensureEditable in 2-arg valAt
        (ILookup'''valAt-3 this, key, nil)
    )

    #_override
    (defn #_"Object" ILookup'''valAt-3--TransientVector [#_"TransientVector" this, #_"Object" key, #_"Object" notFound]
        (TransientVector''ensureEditable this)
        (when (Util'isInteger key) => notFound
            (let-when [#_"int" i (.intValue (cast Number key))] (< -1 i (:cnt this)) => notFound
                (Indexed'''nth-2 this, i)
            )
        )
    )

    (def- #_"Object" TransientVector'NOT_FOUND (Object.))

    #_override
    (defn #_"boolean" ITransientAssociative2'''containsKey--TransientVector [#_"TransientVector" this, #_"Object" key]
        (not= (ILookup'''valAt-3 this, key, TransientVector'NOT_FOUND) TransientVector'NOT_FOUND)
    )

    #_override
    (defn #_"IMapEntry" ITransientAssociative2'''entryAt--TransientVector [#_"TransientVector" this, #_"Object" key]
        (let [#_"Object" v (ILookup'''valAt-3 this, key, TransientVector'NOT_FOUND)]
            (when-not (= v TransientVector'NOT_FOUND)
                (MapEntry'create key, v)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--TransientVector [#_"TransientVector" this, #_"Object" arg1]
        ;; note - relies on ensureEditable in nth
        (when (Util'isInteger arg1) => (throw (IllegalArgumentException. "Key must be integer"))
            (Indexed'''nth-2 this, (.intValue (cast Number arg1)))
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--TransientVector [#_"TransientVector" this, #_"int" i]
        (TransientVector''ensureEditable this)
        (let [#_"Object[]" node (TransientVector''arrayFor this, i)]
            (aget node (& i 0x01f))
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--TransientVector [#_"TransientVector" this, #_"int" i, #_"Object" notFound]
        (when (< -1 i (.count this)) => notFound
            (Indexed'''nth-2 this, i)
        )
    )

    #_override
    (defn #_"TransientVector" ITransientVector'''assocN--TransientVector [#_"TransientVector" this, #_"int" i, #_"Object" val]
        (TransientVector''ensureEditable this)
        (if (< -1 i (:cnt this))
            (if (<= (TransientVector''tailoff this) i)
                (do
                    (aset (:tail this) (& i 0x01f) val)
                    this
                )
                (do
                    (§ ass this (assoc this :root (TransientVector''doAssoc this, (:shift this), (:root this), i, val)))
                    this
                )
            )
            (when (= i (:cnt this)) => (throw (IndexOutOfBoundsException.))
                (ITransientCollection'''conj this, val)
            )
        )
    )

    #_override
    (defn #_"TransientVector" ITransientAssociative'''assoc--TransientVector [#_"TransientVector" this, #_"Object" key, #_"Object" val]
        ;; note - relies on ensureEditable in assocN
        (when (Util'isInteger key) => (throw (IllegalArgumentException. "Key must be integer"))
            (ITransientVector'''assocN this, (.intValue (cast Number key)), val)
        )
    )

    #_method
    (defn- #_"VNode" TransientVector''doAssoc [#_"TransientVector" this, #_"int" level, #_"VNode" node, #_"int" i, #_"Object" val]
        (let [node (TransientVector''ensureEditable this, node)]
            (if (zero? level)
                (aset (:array node) (& i 0x01f) val)
                (let [#_"int" si (& (>>> i level) 0x01f)]
                    (aset (:array node) si (TransientVector''doAssoc this, (- level 5), (cast' VNode (aget (:array node) si)), i, val))
                )
            )
            node
        )
    )

    #_override
    (defn #_"TransientVector" ITransientVector'''pop--TransientVector [#_"TransientVector" this]
        (TransientVector''ensureEditable this)
        (let [#_"int" n (:cnt this)]
            (when-not (zero? n) => (throw (IllegalStateException. "Can't pop empty vector"))
                (when (and (not= n 1) (zero? (& (dec n) 0x01f))) => (assoc this :cnt (dec n))
                    (let [#_"Object[]" tail (TransientVector''editableArrayFor this, (- n 2))
                          #_"int" shift (:shift this) #_"VNode" root (:root this)
                          root (or (TransientVector''popTail this, shift, root) (VNode'new-1 (:edit root)))
                          [shift root]
                            (when (and (< 5 shift) (nil? (aget (:array root) 1))) => [shift root]
                                [(- shift 5) (TransientVector''ensureEditable this, (cast' VNode (aget (:array root) 0)))]
                            )]
                        (assoc this :cnt (dec n), :shift shift, :root root, :tail tail)
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"VNode" TransientVector''popTail [#_"TransientVector" this, #_"int" level, #_"VNode" node]
        (let [node (TransientVector''ensureEditable this, node)
              #_"int" i (& (>>> (- (:cnt this) 2) level) 0x01f)]
            (cond
                (< 5 level)
                    (let [#_"VNode" child (TransientVector''popTail this, (- level 5), (cast' VNode (aget (:array node) i)))]
                        (when-not (and (nil? child) (zero? i))
                            (aset (:array node) i child)
                            node
                        )
                    )
                (pos? i)
                    (do
                        (aset (:array node) i nil)
                        node
                    )
            )
        )
    )
)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (def #_"AtomicReference<Thread>" PersistentVector'NOEDIT (AtomicReference. nil))
    (def #_"VNode" PersistentVector'EMPTY_NODE (VNode'new-2 PersistentVector'NOEDIT, (object-array 32)))

    (§ def #_"PersistentVector" PersistentVector'EMPTY (PersistentVector'new-4 0, 5, PersistentVector'EMPTY_NODE, (object-array 0)))

    (def- #_"IFn" PersistentVector'TRANSIENT_VECTOR_CONJ
        (§ reify AFn()
            #_override
            (defn #_"Object" IFn'''invoke-3--AFn [#_"AFn" this, #_"Object" coll, #_"Object" val]
                (ITransientCollection'''conj (cast' ITransientVector coll), val)
            )
            #_override
            (defn #_"Object" IFn'''invoke-2--AFn [#_"AFn" this, #_"Object" coll]
                coll
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'adopt [#_"Object[]" items]
        (PersistentVector'new-4 (alength items), 5, PersistentVector'EMPTY_NODE, items)
    )

    (defn #_"PersistentVector" PersistentVector'create-1r [#_"IReduceInit" items]
        (let [#_"TransientVector" ret (IEditableCollection'''asTransient PersistentVector'EMPTY)]
            (IReduceInit'''reduce items, PersistentVector'TRANSIENT_VECTOR_CONJ, ret)
            (ITransientCollection'''persistent ret)
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1s [#_"ISeq" items]
        (let [#_"Object[]" a (make-array Object 32)
              #_"int" i
                (loop-when-recur [items items i 0] (and (some? items) (< i 32)) [(.next items) (inc i)] => i
                    (aset a i (.first items))
                )]
            (cond
                (some? items) ;; >32, construct with array directly
                    (let [#_"PersistentVector" v0 (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, a)]
                        (loop-when-recur [#_"TransientVector" v (IEditableCollection'''asTransient v0) items items]
                                         (some? items)
                                         [(ITransientCollection'''conj v, (.first items)) (.next items)]
                                      => (ITransientCollection'''persistent v)
                        )
                    )
                (= i 32) ;; exactly 32, skip copy
                    (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, a)
                :else ;; <32, copy to minimum array and construct
                    (let [#_"Object[]" b (make-array Object i)]
                        (System/arraycopy a, 0, b, 0, i)
                        (PersistentVector'new-4 i, 5, PersistentVector'EMPTY_NODE, b)
                    )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1l [#_"List" items]
        (let-when [#_"int" n (.size items)] (< 32 n) => (PersistentVector'new-4 n, 5, PersistentVector'EMPTY_NODE, (.toArray items))
            (loop-when-recur [#_"TransientVector" v (IEditableCollection'''asTransient PersistentVector'EMPTY) #_"int" i 0]
                             (< i n)
                             [(ITransientCollection'''conj v, (.get items, i)) (inc i)]
                          => (ITransientCollection'''persistent v)
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1i [#_"Iterable" items]
        (when-not (instance? ArrayList items) => (PersistentVector'create-1l (cast ArrayList items)) ;; optimize common case
            (let [#_"Iterator" it (.iterator items)]
                (loop-when-recur [#_"TransientVector" v (IEditableCollection'''asTransient PersistentVector'EMPTY)]
                                 (.hasNext it)
                                 [(ITransientCollection'''conj v, (.next it))]
                              => (ITransientCollection'''persistent v)
                )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1a [& #_"Object..." items]
        (loop-when-recur [#_"TransientVector" v (IEditableCollection'''asTransient PersistentVector'EMPTY) #_"int" i 0]
                         (< i (alength items))
                         [(ITransientCollection'''conj v, (aget items i)) (inc i)]
                      => (ITransientCollection'''persistent v)
        )
    )

    (defn- #_"PersistentVector" PersistentVector'init []
        (hash-map
            #_"int" :cnt 0
            #_"int" :shift 0
            #_"VNode" :root nil
            #_"Object[]" :tail nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-4 [#_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass this (assoc this :_meta nil))
            (§ ass this (assoc this :cnt cnt))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :tail tail))
            this
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-5 [#_"IPersistentMap" meta, #_"int" cnt, #_"int" shift, #_"VNode" root, #_"Object[]" tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass this (assoc this :_meta meta))
            (§ ass this (assoc this :cnt cnt))
            (§ ass this (assoc this :shift shift))
            (§ ass this (assoc this :root root))
            (§ ass this (assoc this :tail tail))
            this
        )
    )

    #_override
    (defn #_"TransientVector" IEditableCollection'''asTransient--PersistentVector [#_"PersistentVector" this]
        (TransientVector'new-1 this)
    )

    #_method
    (defn #_"int" PersistentVector''tailoff [#_"PersistentVector" this]
        (if (< (:cnt this) 32) 0 (<< (>>> (dec (:cnt this)) 5) 5))
    )

    #_method
    (defn #_"Object[]" PersistentVector''arrayFor [#_"PersistentVector" this, #_"int" i]
        (when (< -1 i (:cnt this)) => (throw (IndexOutOfBoundsException.))
            (when (< i (PersistentVector''tailoff this)) => (:tail this)
                (loop-when-recur [#_"VNode" node (:root this) #_"int" level (:shift this)]
                                 (< 0 level)
                                 [(cast' VNode (aget (:array node) (& (>>> i level) 0x01f))) (- level 5)]
                              => (:array node)
                )
            )
        )
    )

    #_override
    (defn #_"Object" Indexed'''nth-2--PersistentVector [#_"PersistentVector" this, #_"int" i]
        (aget (PersistentVector''arrayFor this, i) (& i 0x01f))
    )

    #_override
    (defn #_"Object" Indexed'''nth-3--PersistentVector [#_"PersistentVector" this, #_"int" i, #_"Object" notFound]
        (when (< -1 i (:cnt this)) => notFound
            (Indexed'''nth-2 this, i)
        )
    )

    #_override
    (defn #_"PersistentVector" IPersistentVector'''assocN--PersistentVector [#_"PersistentVector" this, #_"int" i, #_"Object" val]
        (if (< -1 i (:cnt this))
            (if (<= (PersistentVector''tailoff this) i)
                (let [#_"Object[]" tail (make-array Object (alength (:tail this)))]
                    (System/arraycopy (:tail this), 0, tail, 0, (alength (:tail this)))
                    (aset tail (& i 0x01f) val)
                    (PersistentVector'new-5 (IMeta'''meta this), (:cnt this), (:shift this), (:root this), tail)
                )
                (PersistentVector'new-5 (IMeta'''meta this), (:cnt this), (:shift this), (PersistentVector'doAssoc (:shift this), (:root this), i, val), (:tail this))
            )
            (when (= i (:cnt this)) => (throw (IndexOutOfBoundsException.))
                (IPersistentVector'''cons this, val)
            )
        )
    )

    (defn- #_"VNode" PersistentVector'doAssoc [#_"int" level, #_"VNode" node, #_"int" i, #_"Object" val]
        (let [#_"VNode" ret (VNode'new-2 (:edit node), (.clone (:array node)))]
            (if (zero? level)
                (aset (:array ret) (& i 0x01f) val)
                (let [#_"int" si (& (>>> i level) 0x01f)]
                    (aset (:array ret) si (PersistentVector'doAssoc (- level 5), (cast' VNode (aget (:array node) si)), i, val))
                )
            )
            ret
        )
    )

    #_override
    (defn #_"int" Counted'''count--PersistentVector [#_"PersistentVector" this]
        (:cnt this)
    )

    #_override
    (defn #_"PersistentVector" IObj'''withMeta--PersistentVector [#_"PersistentVector" this, #_"IPersistentMap" meta]
        (PersistentVector'new-5 meta, (:cnt this), (:shift this), (:root this), (:tail this))
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--PersistentVector [#_"PersistentVector" this]
        (:_meta this)
    )

    #_override
    (defn #_"PersistentVector" IPersistentVector'''cons--PersistentVector [#_"PersistentVector" this, #_"Object" val]
        (let [#_"int" n (:cnt this)]
            (if (< (- n (PersistentVector''tailoff this)) 32) ;; room in tail?
                (let [#_"int" e (alength (:tail this))  #_"Object[]" tail (make-array Object (inc e))]
                    (System/arraycopy (:tail this), 0, tail, 0, e)
                    (aset tail e val)
                    (PersistentVector'new-5 (IMeta'''meta this), (inc n), (:shift this), (:root this), tail)
                )
                ;; full tail, push into tree
                (let [#_"VNode" tailnode (VNode'new-2 (:edit (:root this)), (:tail this))
                      #_"int" shift (:shift this)
                      [#_"VNode" root shift]
                        (if (< (<< 1 shift) (>>> n 5)) ;; overflow root?
                            (let [root (VNode'new-1 (:edit (:root this)))]
                                (aset (:array root) 0 (:root this))
                                (aset (:array root) 1 (PersistentVector'newPath (:edit (:root this)), shift, tailnode))
                                [root (+ shift 5)]
                            )
                            [(PersistentVector''pushTail this, shift, (:root this), tailnode) shift]
                        )]
                    (PersistentVector'new-5 (IMeta'''meta this), (inc n), shift, root, (object-array [ val ]))
                )
            )
        )
    )

    #_method
    (defn- #_"VNode" PersistentVector''pushTail [#_"PersistentVector" this, #_"int" level, #_"VNode" parent, #_"VNode" tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" i (& (>>> (dec (:cnt this)) level) 0x01f)
              #_"VNode" ret (VNode'new-2 (:edit parent), (.clone (:array parent)))
              #_"VNode" nodeToInsert
                (when-not (= level 5) => tailnode
                    (let [#_"VNode" child (cast' VNode (aget (:array parent) i))]
                        (if (some? child)
                            (PersistentVector''pushTail this, (- level 5), child, tailnode)
                            (PersistentVector'newPath (:edit (:root this)), (- level 5), tailnode)
                        )
                    )
                )]
            (aset (:array ret) i nodeToInsert)
            ret
        )
    )

    (defn- #_"VNode" PersistentVector'newPath [#_"AtomicReference<Thread>" edit, #_"int" level, #_"VNode" node]
        (when-not (zero? level) => node
            (let [#_"VNode" ret (VNode'new-1 edit)]
                (aset (:array ret) 0 (PersistentVector'newPath edit, (- level 5), node))
                ret
            )
        )
    )

    #_method
    (defn #_"IChunkedSeq" PersistentVector''chunkedSeq [#_"PersistentVector" this]
        (when (pos? (.count this))
            (ChunkedSeq'new-3 this, 0, 0)
        )
    )

    #_override
    (defn #_"ISeq" Seqable'''seq--PersistentVector [#_"PersistentVector" this]
        (PersistentVector''chunkedSeq this)
    )

    #_override
    (defn #_"Iterator" APersistentVector'''rangedIterator--PersistentVector [#_"PersistentVector" this, #_"int" start, #_"int" end]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i start
                    #_"int" :base (- (:i this) (% (:i this) 32))
                    #_"Object[]" :array (when (< start (.count this)) (PersistentVector''arrayFor this, (:i this)))
                )
            )

            #_foreign
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (< (:i this) end)
            )

            #_foreign
            (§ defn #_"Object" next [#_"Iterator" this]
                (when (< (:i this) end) => (throw (NoSuchElementException.))
                    (when (= (- (:i this) (:base this)) 32)
                        (§ ass this (assoc this :array (PersistentVector''arrayFor this, (:i this))))
                        (§ ass this (assoc this :base (+ (:base this) 32)))
                    )
                    (let [_ (aget (:array this) (& (:i this) 0x01f))]
                        (§ ass this (assoc this :i (inc (:i this))))
                        _
                    )
                )
            )

            #_foreign
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"PersistentVector" this]
        (APersistentVector'''rangedIterator this, 0, (.count this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--PersistentVector [#_"PersistentVector" this, #_"IFn" f]
        (when (pos? (:cnt this)) => (IFn'''invoke-1 f)
            (loop-when [#_"Object" r (aget (PersistentVector''arrayFor this, 0) 0) #_"int" i 0] (< i (:cnt this)) => r
                (let [#_"Object[]" a (PersistentVector''arrayFor this, i)
                      r (loop-when [r r #_"int" j (if (zero? i) 1 0)] (< j (alength a)) => r
                            (let [r (IFn'''invoke-3 f, r, (aget a j))]
                                (when-not (RT'isReduced r) => (§ return (IDeref'''deref (cast' IDeref r)))
                                    (recur r (inc j))
                                )
                            )
                        )]
                    (recur r (+ i (alength a)))
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--PersistentVector [#_"PersistentVector" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (:cnt this)) => r
            (let [#_"Object[]" a (PersistentVector''arrayFor this, i)
                  r (loop-when [r r #_"int" j 0] (< j (alength a)) => r
                        (let [r (IFn'''invoke-3 f, r, (aget a j))]
                            (when-not (RT'isReduced r) => (§ return (IDeref'''deref (cast' IDeref r)))
                                (recur r (inc j))
                            )
                        )
                    )]
                (recur r (+ i (alength a)))
            )
        )
    )

    #_override
    (defn #_"Object" IKVReduce'''kvreduce--PersistentVector [#_"PersistentVector" this, #_"IFn" f, #_"Object" r]
        (loop-when [r r #_"int" i 0] (< i (:cnt this)) => r
            (let [#_"Object[]" a (PersistentVector''arrayFor this, i)
                  r (loop-when [r r #_"int" j 0] (< j (alength a)) => r
                        (let [r (IFn'''invoke-4 f, r, (+ j i), (aget a j))]
                            (when-not (RT'isReduced r) => (§ return (IDeref'''deref (cast' IDeref r)))
                                (recur r (inc j))
                            )
                        )
                    )]
                (recur r (+ i (alength a)))
            )
        )
    )

    #_override
    (defn #_"IPersistentCollection" IPersistentCollection'''empty--PersistentVector [#_"PersistentVector" this]
        (IObj'''withMeta PersistentVector'EMPTY, (IMeta'''meta this))
    )

    #_override
    (defn #_"PersistentVector" IPersistentStack'''pop--PersistentVector [#_"PersistentVector" this]
        (cond
            (zero? (:cnt this))
                (throw (IllegalStateException. "Can't pop empty vector"))
            (= (:cnt this) 1)
                (IObj'''withMeta PersistentVector'EMPTY, (IMeta'''meta this))
            (< 1 (- (:cnt this) (PersistentVector''tailoff this)))
                (let [#_"Object[]" tail (make-array Object (dec (alength (:tail this))))]
                    (System/arraycopy (:tail this), 0, tail, 0, (alength tail))
                    (PersistentVector'new-5 (IMeta'''meta this), (dec (:cnt this)), (:shift this), (:root this), tail)
                )
            :else
                (let [#_"Object[]" tail (PersistentVector''arrayFor this, (- (:cnt this) 2))
                      #_"int" shift (:shift this)
                      #_"VNode" root (or (PersistentVector''popTail this, shift, (:root this)) PersistentVector'EMPTY_NODE)
                      [shift root]
                        (when (and (< 5 shift) (nil? (aget (:array root) 1))) => [shift root]
                            [(- shift 5) (cast' VNode (aget (:array root) 0))]
                        )]
                    (PersistentVector'new-5 (IMeta'''meta this), (dec (:cnt this)), shift, root, tail)
                )
        )
    )

    #_method
    (defn- #_"VNode" PersistentVector''popTail [#_"PersistentVector" this, #_"int" level, #_"VNode" node]
        (let [#_"int" i (& (>>> (- (:cnt this) 2) level) 0x01f)]
            (cond
                (< 5 level)
                    (let [#_"VNode" child (PersistentVector''popTail this, (- level 5), (cast' VNode (aget (:array node) i)))]
                        (when-not (and (nil? child) (zero? i))
                            (let [#_"VNode" ret (VNode'new-2 (:edit (:root this)), (.clone (:array node)))]
                                (aset (:array ret) i child)
                                ret
                            )
                        )
                    )
                (pos? i)
                    (let [#_"VNode" ret (VNode'new-2 (:edit (:root this)), (.clone (:array node)))]
                        (aset (:array ret) i nil)
                        ret
                    )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    (defn- #_"ProxyHandler" ProxyHandler'init []
        (hash-map
            ;; method-name-string->fn
            #_"IPersistentMap" :fns nil
        )
    )

    (defn #_"ProxyHandler" ProxyHandler'new [#_"IPersistentMap" fns]
        (let [this (ProxyHandler'init)]
            (§ ass this (assoc this :fns fns))
            this
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--ProxyHandler [#_"ProxyHandler" this, #_"Object" proxy, #_"java.lang.reflect.Method" method, #_"Object[]" args] #_(§ throws Throwable)
        (let [#_"IFn" fn (cast' IFn (ILookup'''valAt-2 (:fns this), (.getName method))) #_"Class" rt (.getReturnType method)]
            (if (nil? fn)
                (cond
                    (= rt Void/TYPE)                 nil
                    (= (.getName method) "equals")   (= proxy (aget args 0))
                    (= (.getName method) "hashCode") (System/identityHashCode proxy)
                    (= (.getName method) "toString") (str "Proxy: " (System/identityHashCode proxy))
                    :else                            (throw (UnsupportedOperationException.))
                )
                (let [#_"Object" ret (IFn'''applyTo fn, (ArraySeq'create-1 args))]
                    (cond
                        (= rt Void/TYPE) nil
                        (.isPrimitive rt)
                            (cond
                                (= rt Character/TYPE) ret
                                (= rt Integer/TYPE)   (.intValue (cast Number ret))
                                (= rt Long/TYPE)      (.longValue (cast Number ret))
                                (= rt Float/TYPE)     (.floatValue (cast Number ret))
                                (= rt Double/TYPE)    (.doubleValue (cast Number ret))
                                (and (= rt Boolean/TYPE) (not (instance? Boolean ret))) (if (nil? ret) Boolean/FALSE Boolean/TRUE)
                                (= rt Byte/TYPE)      (byte (.intValue (cast Number ret)))
                                (= rt Short/TYPE)     (short (.intValue (cast Number ret)))
                                :else ret
                            )
                        :else ret
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

#_private
#_non-static
(class-ns RangeIterator (§ implements Iterator)
    (defn- #_"RangeIterator" RangeIterator'init []
        (hash-map
            #_"Object" :next nil
        )
    )

    (defn #_"RangeIterator" RangeIterator'new []
        (let [this (RangeIterator'init)]
            (§ ass this (assoc this :next (:start this)))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"RangeIterator" this]
        (not (RangeBoundsCheck'''exceededBounds (:boundsCheck this), (:next this)))
    )

    #_foreign
    (§ defn #_"Object" next [#_"RangeIterator" this]
        (when (.hasNext this) => (throw (NoSuchElementException.))
            (let [#_"Object" ret (:next this)]
                (§ ass this (assoc this :next (Numbers'addP-2oo (:next this), (:step this))))
                ret
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"RangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (def- #_"int" Range'CHUNK_SIZE 32)

    (defn- #_"RangeBoundsCheck" Range'positiveStep [#_"Object" end]
        (§ reify RangeBoundsCheck()
            #_override
            (defn #_"boolean" RangeBoundsCheck'''exceededBounds--RangeBoundsCheck [#_"RangeBoundsCheck" this, #_"Object" val]
                (Numbers'gte-2oo val, end)
            )
        )
    )

    (defn- #_"RangeBoundsCheck" Range'negativeStep [#_"Object" end]
        (§ reify RangeBoundsCheck()
            #_override
            (defn #_"boolean" RangeBoundsCheck'''exceededBounds--RangeBoundsCheck [#_"RangeBoundsCheck" this, #_"Object" val]
                (Numbers'lte-2oo val, end)
            )
        )
    )

    (defn- #_"Range" Range'init []
        (hash-map
            ;; Invariants guarantee this is never an "empty" seq
            #_"Object" :end nil
            #_"Object" :start nil
            #_"Object" :step nil
            #_"RangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"IChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Range" Range'new-4 [#_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck]
        (let [this (merge (ASeq'new-0) (Range'init))]
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            this
        )
    )

    (defn- #_"Range" Range'new-6 [#_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new-0) (Range'init))]
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            (§ ass this (assoc this :_chunk chunk))
            (§ ass this (assoc this :_chunkNext chunkNext))
            this
        )
    )

    (defn- #_"Range" Range'new-7 [#_"IPersistentMap" meta, #_"Object" start, #_"Object" end, #_"Object" step, #_"RangeBoundsCheck" boundsCheck, #_"IChunk" chunk, #_"ISeq" chunkNext]
        (let [this (merge (ASeq'new-1 meta) (Range'init))]
            (§ ass this (assoc this :end end))
            (§ ass this (assoc this :start start))
            (§ ass this (assoc this :step step))
            (§ ass this (assoc this :boundsCheck boundsCheck))
            (§ ass this (assoc this :_chunk chunk))
            (§ ass this (assoc this :_chunkNext chunkNext))
            this
        )
    )

    (defn #_"ISeq" Range'create-1 [#_"Object" end]
        (if (Numbers'isPos-1o end)
            (Range'new-4 0, end, 1, (Range'positiveStep end))
            PersistentList'EMPTY
        )
    )

    (defn #_"ISeq" Range'create-2 [#_"Object" start, #_"Object" end]
        (Range'create-3 start, end, 1)
    )

    (defn #_"ISeq" Range'create-3 [#_"Object" start, #_"Object" end, #_"Object" step]
        (cond
            (or (and (Numbers'isPos-1o step) (Numbers'gt-2oo start, end))
                (and (Numbers'isNeg-1o step) (Numbers'gt-2oo end, start))
                (Numbers'equiv-2oo start, end)
            )
                PersistentList'EMPTY
            (Numbers'isZero-1o step)
                (Repeat'create-1 start)
            :else
                (Range'new-4 start, end, step, (if (Numbers'isPos-1o step) (Range'positiveStep end) (Range'negativeStep end)))
        )
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--Range [#_"Range" this, #_"IPersistentMap" meta]
        (if (= meta (:_meta this))
            this
            (Range'new-7 meta, (:end this), (:start this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--Range [#_"Range" this]
        (:start this)
    )

    #_method
    (defn #_"void" Range''forceChunk [#_"Range" this]
        (when (nil? (:_chunk this))
            (let [#_"Object[]" a (make-array Object Range'CHUNK_SIZE)]
                (loop [#_"Object" n (:start this) #_"int" i 0]
                    (if (< i Range'CHUNK_SIZE)
                        (do
                            (aset a i n)
                            (let-when [n (Numbers'addP-2oo n, (:step this))] (RangeBoundsCheck'''exceededBounds (:boundsCheck this), n) => (recur n (inc i))
                                ;; partial last chunk
                                (§ ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, (inc i))))
                            )
                        )
                        (if (RangeBoundsCheck'''exceededBounds (:boundsCheck this), n)
                            (do
                                ;; full last chunk
                                (§ ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, Range'CHUNK_SIZE)))
                            )
                            (do
                                ;; full intermediate chunk
                                (§ ass this (assoc this :_chunk (ArrayChunk'new-3 a, 0, Range'CHUNK_SIZE)))
                                (§ ass this (assoc this :_chunkNext (Range'new-4 n, (:end this), (:step this), (:boundsCheck this))))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Range [#_"Range" this]
        (let-when [#_"Range" _next (:_next this)] (nil? _next) => _next
            (Range''forceChunk this)
            (when (< 1 (.count (:_chunk this))) => (IChunkedSeq'''chunkedNext this)
                (let [#_"IChunk" _rest (IChunk'''dropFirst (:_chunk this))
                      _next (Range'new-6 (Indexed'''nth-2 _rest, 0), (:end this), (:step this), (:boundsCheck this), _rest, (:_chunkNext this))]
                    (§ ass this (assoc this :_next _next))
                    _next
                )
            )
        )
    )

    #_override
    (defn #_"IChunk" IChunkedSeq'''chunkedFirst--Range [#_"Range" this]
        (Range''forceChunk this)
        (:_chunk this)
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedNext--Range [#_"Range" this]
        (Seqable'''seq (IChunkedSeq'''chunkedMore this))
    )

    #_override
    (defn #_"ISeq" IChunkedSeq'''chunkedMore--Range [#_"Range" this]
        (Range''forceChunk this)
        (or (:_chunkNext this) PersistentList'EMPTY)
    )

    #_override
    (defn #_"Object" IReduce'''reduce--Range [#_"Range" this, #_"IFn" f]
        (loop [#_"Object" r (:start this) #_"Number" n r]
            (let-when-not [n (Numbers'addP-2oo n, (:step this))] (RangeBoundsCheck'''exceededBounds (:boundsCheck this), n) => r
                (let-when-not [r (IFn'''invoke-3 f, r, n)] (RT'isReduced r) => (IDeref'''deref (cast' Reduced r))
                    (recur r n)
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--Range [#_"Range" this, #_"IFn" f, #_"Object" r]
        (loop [r r #_"Object" n (:start this)]
            (let-when-not [r (IFn'''invoke-3 f, r, n)] (RT'isReduced r) => (IDeref'''deref (cast' Reduced r))
                (let-when-not [n (Numbers'addP-2oo n, (:step this))] (RangeBoundsCheck'''exceededBounds (:boundsCheck this), n) => r
                    (recur r n)
                )
            )
        )
    )

    #_foreign
    (§ defn #_"Iterator" iterator [#_"Range" this]
        (RangeIterator'new)
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (defn- #_"Ratio" Ratio'init []
        (hash-map
            #_"BigInteger" :numerator nil
            #_"BigInteger" :denominator nil
        )
    )

    (defn #_"Ratio" Ratio'new [#_"BigInteger" numerator, #_"BigInteger" denominator]
        (let [this (merge (§ foreign Number'new) (Ratio'init))]
            (§ ass this (assoc this :numerator numerator))
            (§ ass this (assoc this :denominator denominator))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"Ratio" this, #_"Object" arg0]
        (and (some? arg0) (§ instance? Ratio arg0) (.equals (:numerator (cast' Ratio arg0)), (:numerator this)) (.equals (:denominator (cast' Ratio arg0)), (:denominator this)))
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"Ratio" this]
        (bit-xor (.hashCode (:numerator this)) (.hashCode (:denominator this)))
    )

    #_foreign
    (§ defn #_"String" toString [#_"Ratio" this]
        (str (:numerator this) "/" (:denominator this))
    )

    #_method
    (defn #_"int" Ratio''intValue [#_"Ratio" this]
        (int (Ratio''doubleValue this))
    )

    #_method
    (defn #_"long" Ratio''longValue [#_"Ratio" this]
        (.longValue (Ratio''bigIntegerValue this))
    )

    #_method
    (defn #_"float" Ratio''floatValue [#_"Ratio" this]
        (float (Ratio''doubleValue this))
    )

    #_method
    (defn #_"double" Ratio''doubleValue [#_"Ratio" this]
        (.doubleValue (Ratio''decimalValue this, MathContext/DECIMAL64))
    )

    #_method
    (defn #_"BigDecimal" Ratio''decimalValue [#_"Ratio" this]
        (Ratio''decimalValue this, MathContext/UNLIMITED)
    )

    #_method
    (defn #_"BigDecimal" Ratio''decimalValue [#_"Ratio" this, #_"MathContext" mc]
        (let [#_"BigDecimal" numerator (§ unsure BigDecimal. (:numerator this))
              #_"BigDecimal" denominator (§ unsure BigDecimal. (:denominator this))]
            (.divide numerator, denominator, mc)
        )
    )

    #_method
    (defn #_"BigInteger" Ratio''bigIntegerValue [#_"Ratio" this]
        (.divide (:numerator this), (:denominator this))
    )

    #_foreign
    (§ defn #_"int" compareTo [#_"Ratio" this, #_"Object" o]
        (Numbers'compare this, (cast Number o))
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (defn- #_"RecordIterator" RecordIterator'init []
        (hash-map
            #_"int" :i 0
            #_"int" :basecnt 0
            #_"ILookup" :rec nil
            #_"IPersistentVector" :basefields nil
            #_"Iterator" :extmap nil
        )
    )

    (defn #_"RecordIterator" RecordIterator'new [#_"ILookup" rec, #_"IPersistentVector" basefields, #_"Iterator" extmap]
        (let [this (RecordIterator'init)]
            (§ ass this (assoc this :rec rec))
            (§ ass this (assoc this :basefields basefields))
            (§ ass this (assoc this :basecnt (.count basefields)))
            (§ ass this (assoc this :extmap extmap))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"RecordIterator" this]
        (or (< (:i this) (:basecnt this)) (.hasNext (:extmap this)))
    )

    #_foreign
    (§ defn #_"Object" next [#_"RecordIterator" this]
        (when (< (:i this) (:basecnt this)) => (.next (:extmap this))
            (let [#_"Object" k (Indexed'''nth-2 (:basefields this), (:i this))]
                (§ ass this (assoc this :i (inc (:i this))))
                (MapEntry'create k, (ILookup'''valAt-2 (:rec this), k))
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"RecordIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (defn- #_"Reduced" Reduced'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Reduced" Reduced'new [#_"Object" val]
        (let [this (Reduced'init)]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Reduced [#_"Reduced" this]
        (:val this)
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns RefTVal
    (defn- #_"RefTVal" RefTVal'init []
        (hash-map
            #_"Object" :val nil
            #_"long" :point 0
            #_"RefTVal" :prior nil
            #_"RefTVal" :next nil
        )
    )

    (defn #_"RefTVal" RefTVal'new-3 [#_"Object" val, #_"long" point, #_"RefTVal" prior]
        (let [this (RefTVal'init)]
            (§ ass this (assoc this :val val))
            (§ ass this (assoc this :point point))
            (§ ass this (assoc this :prior prior))
            (§ ass this (assoc this :next (:next prior)))
            (§ ass (:next (:prior this)) this)
            (§ ass (:prior (:next this)) this)
            this
        )
    )

    (defn #_"RefTVal" RefTVal'new-2 [#_"Object" val, #_"long" point]
        (let [this (RefTVal'init)]
            (§ ass this (assoc this :val val))
            (§ ass this (assoc this :point point))
            (§ ass this (assoc this :next this))
            (§ ass this (assoc this :prior this))
            this
        )
    )
)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (def #_"AtomicLong" Ref'ids (AtomicLong.))

    (defn- #_"Ref" Ref'init []
        (hash-map
            #_"RefTVal" :tvals nil
            #_"AtomicInteger" :faults nil
            #_"ReentrantReadWriteLock" :lock nil
            #_"LockingTransactionInfo" :tinfo nil
            #_"long" :id 0

            #_volatile
            #_"int" :minHistory 0
            #_volatile
            #_"int" :maxHistory 10
        )
    )

    (defn #_"Ref" Ref'new-1 [#_"Object" initVal]
        (Ref'new-2 initVal, nil)
    )

    (defn #_"Ref" Ref'new-2 [#_"Object" initVal, #_"IPersistentMap" meta]
        (let [this (merge (ARef'new-1 meta) (Ref'init))]
            (§ ass this (assoc this :id (.getAndIncrement Ref'ids)))
            (§ ass this (assoc this :faults (AtomicInteger.)))
            (§ ass this (assoc this :lock (ReentrantReadWriteLock.)))
            (§ ass this (assoc this :tvals (RefTVal'new-2 initVal, 0)))
            this
        )
    )

    #_foreign
    (§ defn #_"int" compareTo [#_"Ref" this, #_"Ref" ref]
        (let [a (:id this) b (:id ref)]
            (cond (< a b) -1 (> a b) 1 :else 0)
        )
    )

    #_method
    (defn #_"int" Ref''getMinHistory [#_"Ref" this]
        (:minHistory this)
    )

    #_method
    (defn #_"Ref" Ref''setMinHistory [#_"Ref" this, #_"int" minHistory]
        (§ ass this (assoc this :minHistory minHistory))
        this
    )

    #_method
    (defn #_"int" Ref''getMaxHistory [#_"Ref" this]
        (:maxHistory this)
    )

    #_method
    (defn #_"Ref" Ref''setMaxHistory [#_"Ref" this, #_"int" maxHistory]
        (§ ass this (assoc this :maxHistory maxHistory))
        this
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (defn #_"Object" Ref''currentVal [#_"Ref" this]
        (try
            (.lock (.readLock (:lock this)))
            (when (some? (:tvals this)) => (throw (IllegalStateException. (str this " is unbound.")))
                (:val (:tvals this))
            )
            (finally
                (.unlock (.readLock (:lock this)))
            )
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Ref [#_"Ref" this]
        (let [#_"LockingTransaction" t (LockingTransaction'getRunning)]
            (if (some? t) (LockingTransaction''doGet t, this) (Ref''currentVal this))
        )
    )

    #_method
    (defn #_"Object" Ref''set [#_"Ref" this, #_"Object" val]
        (LockingTransaction''doSet (LockingTransaction'getEx), this, val)
    )

    #_method
    (defn #_"Object" Ref''commute [#_"Ref" this, #_"IFn" fn, #_"ISeq" args]
        (LockingTransaction''doCommute (LockingTransaction'getEx), this, fn, args)
    )

    #_method
    (defn #_"Object" Ref''alter [#_"Ref" this, #_"IFn" fn, #_"ISeq" args]
        (let [#_"LockingTransaction" t (LockingTransaction'getEx)]
            (LockingTransaction''doSet t, this, (IFn'''applyTo fn, (RT'cons (LockingTransaction''doGet t, this), args)))
        )
    )

    #_method
    (defn #_"void" Ref''touch [#_"Ref" this]
        (LockingTransaction''doEnsure (LockingTransaction'getEx), this)
        nil
    )

    #_method
    (defn #_"boolean" Ref''isBound [#_"Ref" this]
        (try
            (.lock (.readLock (:lock this)))
            (some? (:tvals this))
            (finally
                (.unlock (.readLock (:lock this)))
            )
        )
    )

    #_method
    (defn #_"void" Ref''trimHistory [#_"Ref" this]
        (try
            (.lock (.writeLock (:lock this)))
            (when (some? (:tvals this))
                (§ ass (:next (:tvals this)) (:tvals this))
                (§ ass (:prior (:tvals this)) (:tvals this))
            )
            (finally
                (.unlock (.writeLock (:lock this)))
            )
        )
        nil
    )

    #_method
    (defn #_"int" Ref''getHistoryCount [#_"Ref" this]
        (try
            (.lock (.writeLock (:lock this)))
            (Ref''histCount this)
            (finally
                (.unlock (.writeLock (:lock this)))
            )
        )
    )

    #_method
    (defn #_"int" Ref''histCount [#_"Ref" this]
        (when (some? (:tvals this)) => 0
            (loop-when-recur [#_"int" n 0 #_"RefTVal" tv (:next (:tvals this))] (not= tv (:tvals this)) [(inc n) (:next tv)] => n)
        )
    )

    #_method
    (defn #_"IFn" Ref''fn [#_"Ref" this]
        (cast' IFn (IDeref'''deref this))
    )

    #_foreign
    (§ defn #_"Object" call [#_"Ref" this]
        (IFn'''invoke-1 this)
    )

    #_foreign
    (§ defn #_"void" run [#_"Ref" this]
        (IFn'''invoke-1 this)
        nil
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--Ref [#_"Ref" this]
        (IFn'''invoke-1 (Ref''fn this))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--Ref [#_"Ref" this, #_"Object" arg1]
        (IFn'''invoke-2 (Ref''fn this), arg1)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2]
        (IFn'''invoke-3 (Ref''fn this), arg1, arg2)
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (IFn'''invoke-4 (Ref''fn this), arg1, arg2, arg3)
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (IFn'''invoke-5 (Ref''fn this), arg1, arg2, arg3, arg4)
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (IFn'''invoke-6 (Ref''fn this), arg1, arg2, arg3, arg4, arg5)
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (IFn'''invoke-7 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6)
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (IFn'''invoke-8 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (IFn'''invoke-9 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (IFn'''invoke-10 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (IFn'''invoke-11 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (IFn'''invoke-12 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (IFn'''invoke-13 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (IFn'''invoke-14 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (IFn'''invoke-15 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (IFn'''invoke-16 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15)
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (IFn'''invoke-17 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16)
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (IFn'''invoke-18 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17)
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (IFn'''invoke-19 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (IFn'''invoke-20 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (IFn'''invoke-21 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20)
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--Ref [#_"Ref" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (IFn'''invoke-22 (Ref''fn this), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15,
                arg16, arg17, arg18, arg19, arg20, args)
    )

    #_override
    (defn #_"Object" IFn'''applyTo--Ref [#_"Ref" this, #_"ISeq" args]
        (AFn'applyToHelper this, args)
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

#_stateless
(class-ns Reflector
    (defn #_"Object" Reflector'invokeInstanceMethod [#_"Object" target, #_"String" methodName, #_"Object[]" args]
        (let [#_"List" methods (Reflector'getMethods (.getClass target), (alength args), methodName, false)]
            (Reflector'invokeMatchingMethod methodName, methods, target, args)
        )
    )

    (defn- #_"Throwable" Reflector'getCauseOrElse [#_"Exception" e]
        (or (.getCause e) e)
    )

    (defn- #_"RuntimeException" Reflector'throwCauseOrElseException [#_"Exception" e]
        (throw (Util'sneakyThrow (or (.getCause e) e)))
    )

    (defn- #_"String" Reflector'noMethodReport [#_"String" methodName, #_"Object" target]
        (str "No matching method found: " methodName (when (some? target) (str " for " (.getClass target))))
    )

    (defn #_"Object" Reflector'invokeMatchingMethod [#_"String" methodName, #_"List" methods, #_"Object" target, #_"Object[]" args]
        (let-when [#_"int" n (.size methods)] (pos? n) => (throw (§ unsure IllegalArgumentException. (Reflector'noMethodReport methodName, target)))
            (let [[#_"java.lang.reflect.Method" m #_"Object[]" boxedArgs]
                    (if (= n 1)
                        (let [m (cast java.lang.reflect.Method (.get methods, 0))]
                            [m (Reflector'boxArgs (.getParameterTypes m), args)]
                        )
                        ;; overloaded w/same arity
                        (let [#_"Iterator" it (.iterator methods)]
                            (loop-when [#_"java.lang.reflect.Method" found nil boxedArgs nil] (.hasNext it) => [found boxedArgs]
                                (let [m (cast java.lang.reflect.Method (.next it)) #_"Class[]" params (.getParameterTypes m)
                                    [found boxedArgs]
                                        (if (and (Reflector'isCongruent params, args) (or (nil? found) (Compiler'subsumes params, (.getParameterTypes found))))
                                            [m (Reflector'boxArgs params, args)]
                                            [found boxedArgs]
                                        )]
                                    (recur found boxedArgs)
                                )
                            )
                        )
                    )]
                (when (some? m) => (throw (§ unsure IllegalArgumentException. (Reflector'noMethodReport methodName, target)))
                    (let [m (when-not (Modifier/isPublic (.getModifiers (.getDeclaringClass m))) => m
                                ;; public method of non-public class, try to find it in hierarchy
                                (or (Reflector'getAsMethodOfPublicBase (.getClass target), m)
                                    (throw (IllegalArgumentException. (str "Can't call public method of non-public class: " m)))
                                )
                            )]
                        (try
                            (Reflector'prepRet (.getReturnType m), (IFn'''invoke-3 m, target, boxedArgs))
                            (catch Exception e
                                (throw (Util'sneakyThrow (Reflector'getCauseOrElse e)))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"java.lang.reflect.Method" Reflector'getAsMethodOfPublicBase [#_"Class" c, #_"java.lang.reflect.Method" m]
        (or
            (let [#_"Class[]" ifaces (.getInterfaces c)]
                (loop-when [#_"int" j 0] (< j (alength ifaces))
                    (let [#_"java.lang.reflect.Method[]" methods (.getMethods (aget ifaces j))]
                        (or
                            (loop-when [#_"int" i 0] (< i (alength methods))
                                (let-when [#_"java.lang.reflect.Method" im (aget methods i)] (Reflector'isMatch im, m) => (recur (inc i))
                                    im
                                )
                            )
                            (recur (inc j))
                        )
                    )
                )
            )
            (when-let [#_"Class" sc (.getSuperclass c)]
                (let [#_"java.lang.reflect.Method[]" methods (.getMethods sc)]
                    (loop-when [#_"int" i 0] (< i (alength methods)) => (Reflector'getAsMethodOfPublicBase sc, m)
                        (let-when [#_"java.lang.reflect.Method" scm (aget methods i)] (Reflector'isMatch scm, m) => (recur (inc i))
                            scm
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean" Reflector'isMatch [#_"java.lang.reflect.Method" lhs, #_"java.lang.reflect.Method" rhs]
        (and (.equals (.getName lhs), (.getName rhs)) (Modifier/isPublic (.getModifiers (.getDeclaringClass lhs)))
            (let [#_"Class[]" types1 (.getParameterTypes lhs) #_"Class[]" types2 (.getParameterTypes rhs)]
                (and (= (alength types1) (alength types2))
                    (loop-when [#_"int" i 0] (< i (alength types1)) => true
                        (and (.isAssignableFrom (aget types1 i), (aget types2 i))
                            (recur (inc i))
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeConstructor [#_"Class" c, #_"Object[]" args]
        (try
            (let [#_"Constructor[]" allctors (.getConstructors c) #_"ArrayList" ctors (ArrayList.)]
                (dotimes [#_"int" i (alength allctors)]
                    (let-when [#_"Constructor" ctor (aget allctors i)] (= (alength (.getParameterTypes ctor)) (alength args))
                        (.add ctors, ctor)
                    )
                )
                (condp = (.size ctors)
                    0   (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                    1   (let [#_"Constructor" ctor (cast Constructor (.get ctors, 0))]
                            (.newInstance ctor, (Reflector'boxArgs (.getParameterTypes ctor), args))
                        )
                    (or ;; overloaded w/same arity
                        (loop-when-recur [#_"Iterator" it (.iterator ctors)] (.hasNext it) [it]
                            (let [#_"Constructor" ctor (cast Constructor (.next it))]
                                (let-when [#_"Class[]" params (.getParameterTypes ctor)] (Reflector'isCongruent params, args)
                                    (.newInstance ctor, (Reflector'boxArgs params, args))
                                )
                            )
                        )
                        (throw (IllegalArgumentException. (str "No matching ctor found for " c)))
                    )
                )
            )
            (catch Exception e
                (throw (Util'sneakyThrow (Reflector'getCauseOrElse e)))
            )
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethodVariadic [#_"String" className, #_"String" methodName & #_"Object..." args]
        (Reflector'invokeStaticMethod-3s className, methodName, args)
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3s [#_"String" className, #_"String" methodName, #_"Object[]" args]
        (Reflector'invokeStaticMethod-3c (RT'classForName-1 className), methodName, args)
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3c [#_"Class" c, #_"String" methodName, #_"Object[]" args]
        (if (= methodName "new")
            (Reflector'invokeConstructor c, args)
            (let [#_"List" methods (Reflector'getMethods c, (alength args), methodName, true)]
                (Reflector'invokeMatchingMethod methodName, methods, nil, args)
            )
        )
    )

    (defn #_"Object" Reflector'getStaticField-2s [#_"String" className, #_"String" fieldName]
        (let [#_"Class" c (RT'classForName-1 className)]
            (Reflector'getStaticField-2c c, fieldName)
        )
    )

    (defn #_"Object" Reflector'getStaticField-2c [#_"Class" c, #_"String" fieldName]
        (let [#_"Field" f (Reflector'getField c, fieldName, true)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (try
                    (Reflector'prepRet (.getType f), (.get f, nil))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'setStaticField-3s [#_"String" className, #_"String" fieldName, #_"Object" val]
        (Reflector'setStaticField-3c (RT'classForName-1 className), fieldName, val)
    )

    (defn #_"Object" Reflector'setStaticField-3c [#_"Class" c, #_"String" fieldName, #_"Object" val]
        (let [#_"Field" f (Reflector'getField c, fieldName, true)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (try
                    (.set f, nil, (Reflector'boxArg (.getType f), val))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
                val
            )
        )
    )

    (defn #_"Object" Reflector'getInstanceField [#_"Object" target, #_"String" fieldName]
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, fieldName, false)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " c)))
                (try
                    (Reflector'prepRet (.getType f), (.get f, target))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'setInstanceField [#_"Object" target, #_"String" fieldName, #_"Object" val]
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, fieldName, false)]
            (when (some? f) => (throw (IllegalArgumentException. (str "No matching field found: " fieldName " for " (.getClass target))))
                (try
                    (.set f, target, (Reflector'boxArg (.getType f), val))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
                val
            )
        )
    )

    (defn #_"Object" Reflector'invokeNoArgInstanceMember [#_"Object" target, #_"String" name, #_"boolean" requireField]
        (let [#_"Class" c (.getClass target)]
            (if requireField
                (let [#_"Field" f (Reflector'getField c, name, false)]
                    (if (some? f)
                        (Reflector'getInstanceField target, name)
                        (throw (IllegalArgumentException. (str "No matching field found: " name " for " (.getClass target))))
                    )
                )
                (let [#_"List" meths (Reflector'getMethods c, 0, name, false)]
                    (if (pos? (.size meths))
                        (Reflector'invokeMatchingMethod name, meths, target, RT'EMPTY_ARRAY)
                        (Reflector'getInstanceField target, name)
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-2 [#_"Object" target, #_"String" name]
        ;; check for field first
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, name, false)]
            (when (some? f) => (Reflector'invokeInstanceMethod target, name, RT'EMPTY_ARRAY)
                (try ;; field get
                    (Reflector'prepRet (.getType f), (.get f, target))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3o [#_"String" name, #_"Object" target, #_"Object" arg1]
        ;; check for field first
        (let [#_"Class" c (.getClass target) #_"Field" f (Reflector'getField c, name, false)]
            (when (some? f) => (Reflector'invokeInstanceMethod target, name, (object-array [ arg1 ]))
                (try ;; field set
                    (.set f, target, (Reflector'boxArg (.getType f), arg1))
                    (catch IllegalAccessException e
                        (throw (Util'sneakyThrow e))
                    )
                )
                arg1
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3a [#_"String" name, #_"Object" target & #_"Object..." args]
        (Reflector'invokeInstanceMethod target, name, args)
    )

    (defn #_"Field" Reflector'getField [#_"Class" c, #_"String" name, #_"boolean" getStatics]
        (let [#_"Field[]" allfields (.getFields c)]
            (loop-when [#_"int" i 0] (< i (alength allfields))
                (let [#_"Field" f (aget allfields i)]
                    (if (and (.equals name, (.getName f)) (= (Modifier/isStatic (.getModifiers f)) getStatics))
                        f
                        (recur (inc i))
                    )
                )
            )
        )
    )

    (defn #_"List" Reflector'getMethods [#_"Class" c, #_"int" arity, #_"String" name, #_"boolean" getStatics]
        (let [#_"java.lang.reflect.Method[]" allmethods (.getMethods c)
              #_"ArrayList" methods (ArrayList.) #_"ArrayList" bridgeMethods (ArrayList.)]
            (dotimes [#_"int" i (alength allmethods)]
                (let [#_"java.lang.reflect.Method" m (aget allmethods i)]
                    (when (and (.equals name, (.getName m)) (= (Modifier/isStatic (.getModifiers m)) getStatics) (= (alength (.getParameterTypes m)) arity))
                        (try
                            (if (and (.isBridge m) (.equals (.getMethod c, (.getName m), (.getParameterTypes m)), m))
                                (.add bridgeMethods, m)
                                (.add methods, m)
                            )
                            (catch NoSuchMethodException _
                            )
                        )
                    )
                )
            )
            (when (.isEmpty methods)
                (.addAll methods, bridgeMethods)
            )
            (when (and (not getStatics) (.isInterface c))
                (let [allmethods (.getMethods Object)]
                    (dotimes [#_"int" i (alength allmethods)]
                        (let [#_"java.lang.reflect.Method" m (aget allmethods i)]
                            (when (and (.equals name, (.getName m)) (= (Modifier/isStatic (.getModifiers m)) getStatics) (= (alength (.getParameterTypes m)) arity))
                                (.add methods, m)
                            )
                        )
                    )
                )
            )
            methods
        )
    )

    (defn #_"Object" Reflector'boxArg [#_"Class" paramType, #_"Object" arg]
        (let [unexpected! #(throw (IllegalArgumentException. (str "Unexpected param type, expected: " paramType ", given: " (.getName (.getClass arg)))))]
            (cond
                (not (.isPrimitive paramType)) (.cast paramType, arg)
                (= paramType Boolean/TYPE)     (.cast Boolean, arg)
                (= paramType Character/TYPE)   (.cast Character, arg)
                (instance? Number arg)
                    (let [#_"Number" n (cast Number arg)]
                        (condp = paramType
                            Integer/TYPE (.intValue n)
                            Float/TYPE   (.floatValue n)
                            Double/TYPE  (.doubleValue n)
                            Long/TYPE    (.longValue n)
                            Short/TYPE   (.shortValue n)
                            Byte/TYPE    (.byteValue n)
                                         (unexpected!)
                        )
                    )
                :else
                    (unexpected!)
            )
        )
    )

    (defn #_"Object[]" Reflector'boxArgs [#_"Class[]" params, #_"Object[]" args]
        (when (pos? (alength params))
            (let [#_"Object[]" a (make-array Object (alength params))]
                (dotimes [#_"int" i (alength params)]
                    (aset a i (Reflector'boxArg (aget params i), (aget args i)))
                )
                a
            )
        )
    )

    (defn #_"boolean" Reflector'paramArgTypeMatch [#_"Class" paramType, #_"Class" argType]
        (cond
            (nil? argType)
                (not (.isPrimitive paramType))
            (or (= paramType argType) (.isAssignableFrom paramType, argType))
                true
            :else
                (condp = paramType
                    Integer/TYPE   (any = argType Integer Long/TYPE Long Short/TYPE Byte/TYPE)
                    Float/TYPE     (any = argType Float Double/TYPE)
                    Double/TYPE    (any = argType Double Float/TYPE)
                    Long/TYPE      (any = argType Long Integer/TYPE Short/TYPE Byte/TYPE)
                    Character/TYPE (= argType Character)
                    Short/TYPE     (= argType Short)
                    Byte/TYPE      (= argType Byte)
                    Boolean/TYPE   (= argType Boolean)
                                   false
                )
        )
    )

    (defn #_"boolean" Reflector'isCongruent [#_"Class[]" params, #_"Object[]" args]
        (when (some? args) => (zero? (alength params))
            (and (= (alength params) (alength args))
                (loop-when [#_"boolean" ? true #_"int" i 0] (and ? (< i (alength params)))
                    (let [#_"Object" arg (aget args i)]
                        (recur (Reflector'paramArgTypeMatch (aget params i), (when (some? arg) (.getClass arg))) (inc i))
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'prepRet [#_"Class" c, #_"Object" x]
        (cond
            (not (or (.isPrimitive c) (= c Boolean))) x
            (instance? Boolean x)                     (if (cast Boolean x) Boolean/TRUE Boolean/FALSE)
            :else                                     x
        )
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (def- #_"long" Repeat'INFINITE -1)

    (defn- #_"Repeat" Repeat'init []
        (hash-map
            #_"long" :count 0 ;; always INFINITE or >0
            #_"Object" :val nil
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Repeat" Repeat'new-2 [#_"long" count, #_"Object" val]
        (let [this (merge (ASeq'new-0) (Repeat'init))]
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :val val))
            this
        )
    )

    (defn- #_"Repeat" Repeat'new-3 [#_"IPersistentMap" meta, #_"long" count, #_"Object" val]
        (let [this (merge (ASeq'new-1 meta) (Repeat'init))]
            (§ ass this (assoc this :count count))
            (§ ass this (assoc this :val val))
            this
        )
    )

    (defn #_"Repeat" Repeat'create-1 [#_"Object" val]
        (Repeat'new-2 Repeat'INFINITE, val)
    )

    (defn #_"ISeq" Repeat'create-2 [#_"long" count, #_"Object" val]
        (if (pos? count) (Repeat'new-2 count, val) PersistentList'EMPTY)
    )

    #_override
    (defn #_"Object" ISeq'''first--Repeat [#_"Repeat" this]
        (:val this)
    )

    #_override
    (defn #_"ISeq" ISeq'''next--Repeat [#_"Repeat" this]
        (when (nil? (:_next this))
            (cond (< 1 (:count this))
                (do
                    (§ ass this (assoc this :_next (Repeat'new-2 (dec (:count this)), (:val this))))
                )
                (= (:count this) Repeat'INFINITE)
                (do
                    (§ ass this (assoc this :_next this))
                )
            )
        )
        (:_next this)
    )

    #_override
    (defn #_"Repeat" IObj'''withMeta--Repeat [#_"Repeat" this, #_"IPersistentMap" meta]
        (Repeat'new-3 meta, (:count this), (:val this))
    )

    #_override
    (defn #_"Object" IReduce'''reduce--Repeat [#_"Repeat" this, #_"IFn" f]
        (let [#_"Object" r (:val this)]
            (if (= (:count this) Repeat'INFINITE)
                (loop [r r]
                    (let [r (IFn'''invoke-3 f, r, (:val this))]
                        (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r))
                    )
                )
                (loop-when [r r #_"long" i 1] (< i (:count this)) => r
                    (let [r (IFn'''invoke-3 f, r, (:val this))]
                        (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                    )
                )
            )
        )
    )

    #_override
    (defn #_"Object" IReduceInit'''reduce--Repeat [#_"Repeat" this, #_"IFn" f, #_"Object" r]
        (if (= (:count this) Repeat'INFINITE)
            (loop [r r]
                (let [r (IFn'''invoke-3 f, r, (:val this))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r))
                )
            )
            (loop-when [r r #_"long" i 0] (< i (:count this)) => r
                (let [r (IFn'''invoke-3 f, r, (:val this))]
                    (if (RT'isReduced r) (IDeref'''deref (cast' IDeref r)) (recur r (inc i)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_stateless
#_abstract
(class-ns RestFn (§ extends AFunction)
    #_protected
    (defn #_"RestFn" RestFn'new []
        (AFunction'new)
    )

    #_abstract
    (defn #_"int" RestFn'''getRequiredArity [#_"RestFn" this])

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-2 [#_"RestFn" this, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-3 [#_"RestFn" this, #_"Object" arg1, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-4 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-5 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-6 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-7 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-8 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-9 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-10 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-11 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-12 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-13 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-14 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-15 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-16 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-17 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-18 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-19 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
    (defn #_"Object" RestFn'''doInvoke-20 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
  #_(defn #_"Object" RestFn'''doInvoke-21 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" args]
        nil
    )

    #_protected
    #_abstract
  #_(defn #_"Object" RestFn'''doInvoke-22 [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20, #_"Object" args]
        nil
    )

    #_override
    (defn #_"Object" IFn'''applyTo--RestFn [#_"RestFn" this, #_"ISeq" args]
        (when (<= (RT'boundedLength args, (RestFn'''getRequiredArity this)) (RestFn'''getRequiredArity this))
            (§ return (AFn'applyToHelper this, (Util'ret1 args, (§ ass args nil))))
        )
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this, (Util'ret1 args, (§ ass args nil)))
            1
                (RestFn'''doInvoke-3 this, (.first args),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            2
                (RestFn'''doInvoke-4 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            3
                (RestFn'''doInvoke-5 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            4
                (RestFn'''doInvoke-6 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            5
                (RestFn'''doInvoke-7 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            6
                (RestFn'''doInvoke-8 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            7
                (RestFn'''doInvoke-9 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            8
                (RestFn'''doInvoke-10 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            9
                (RestFn'''doInvoke-11 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            10
                (RestFn'''doInvoke-12 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            11
                (RestFn'''doInvoke-13 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            12
                (RestFn'''doInvoke-14 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            13
                (RestFn'''doInvoke-15 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            14
                (RestFn'''doInvoke-16 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            15
                (RestFn'''doInvoke-17 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            16
                (RestFn'''doInvoke-18 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            17
                (RestFn'''doInvoke-19 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            18
                (RestFn'''doInvoke-20 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            19
                (RestFn'''doInvoke-21 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            20
                (RestFn'''doInvoke-22 this, (.first args),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (.first (§ ass args (.next args))),
                    (Util'ret1 (.next args), (§ ass args nil))
                )
            (AFn'''throwArity this, -1)
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--RestFn [#_"RestFn" this]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this, nil)
            (do
                (AFn'''throwArity this, 0)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--RestFn [#_"RestFn" this, #_"Object" arg1]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this, (ArraySeq'create-1 (Util'ret1 arg1, (§ ass arg1 nil))))
            1
                (RestFn'''doInvoke-3 this, (Util'ret1 arg1, (§ ass arg1 nil)), nil)
            (do
                (AFn'''throwArity this, 1)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)), nil)
            (do
                (AFn'''throwArity this, 2)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg3, (§ ass arg3 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)), nil)
            (do
                (AFn'''throwArity this, 3)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg4, (§ ass arg4 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)), nil)
            (do
                (AFn'''throwArity this, 4)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)), nil)
            (do
                (AFn'''throwArity this, 5)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)), nil)
            (do
                (AFn'''throwArity this, 6)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)), nil)
            (do
                (AFn'''throwArity this, 7)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)), nil)
            (do
                (AFn'''throwArity this, 8)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)), nil)
            (do
                (AFn'''throwArity this, 9)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (ArraySeq'create-1
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)), nil)
            (do
                (AFn'''throwArity this, 10)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)), nil)
            (do
                (AFn'''throwArity this, 11)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)), nil)
            (do
                (AFn'''throwArity this, 12)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)), nil)
            (do
                (AFn'''throwArity this, 13)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil))))
            14
                (RestFn'''doInvoke-16 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)), nil)
            (do
                (AFn'''throwArity this, 14)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            14
                (RestFn'''doInvoke-16 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil))))
            15
                (RestFn'''doInvoke-17 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)), nil)
            (do
                (AFn'''throwArity this, 15)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            14
                (RestFn'''doInvoke-16 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            15
                (RestFn'''doInvoke-17 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil))))
            16
                (RestFn'''doInvoke-18 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)), nil)
            (do
                (AFn'''throwArity this, 16)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            14
                (RestFn'''doInvoke-16 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            15
                (RestFn'''doInvoke-17 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            16
                (RestFn'''doInvoke-18 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg17, (§ ass arg17 nil))))
            17
                (RestFn'''doInvoke-19 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)), nil)
            (do
                (AFn'''throwArity this, 17)
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil)),
                        (Util'ret1 arg18, (§ ass arg18 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            14
                (RestFn'''doInvoke-16 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            15
                (RestFn'''doInvoke-17 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            16
                (RestFn'''doInvoke-18 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            17
                (RestFn'''doInvoke-19 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg18, (§ ass arg18 nil))))
            18
                (RestFn'''doInvoke-20 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)), nil)
            (do
                (AFn'''throwArity this, 18)
            )
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil)),
                        (Util'ret1 arg18, (§ ass arg18 nil)),
                        (Util'ret1 arg19, (§ ass arg19 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            14
                (RestFn'''doInvoke-16 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            15
                (RestFn'''doInvoke-17 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            16
                (RestFn'''doInvoke-18 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            17
                (RestFn'''doInvoke-19 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            18
                (RestFn'''doInvoke-20 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg19, (§ ass arg19 nil))))
            19
                (RestFn'''doInvoke-21 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)), nil)
            (do
                (AFn'''throwArity this, 19)
            )
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (ArraySeq'create-1
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil)),
                        (Util'ret1 arg18, (§ ass arg18 nil)),
                        (Util'ret1 arg19, (§ ass arg19 nil)),
                        (Util'ret1 arg20, (§ ass arg20 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            14
                (RestFn'''doInvoke-16 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            15
                (RestFn'''doInvoke-17 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            16
                (RestFn'''doInvoke-18 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            17
                (RestFn'''doInvoke-19 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            18
                (RestFn'''doInvoke-20 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            19
                (RestFn'''doInvoke-21 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)),
                        (ArraySeq'create-1
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            20
                (RestFn'''doInvoke-22 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)),
                    (Util'ret1 arg20, (§ ass arg20 nil)), nil)
            (do
                (AFn'''throwArity this, 20)
            )
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--RestFn [#_"RestFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (case (RestFn'''getRequiredArity this)
            0
                (RestFn'''doInvoke-2 this,
                    (RestFn'ontoArrayPrepend args,
                        (Util'ret1 arg1, (§ ass arg1 nil)),
                        (Util'ret1 arg2, (§ ass arg2 nil)),
                        (Util'ret1 arg3, (§ ass arg3 nil)),
                        (Util'ret1 arg4, (§ ass arg4 nil)),
                        (Util'ret1 arg5, (§ ass arg5 nil)),
                        (Util'ret1 arg6, (§ ass arg6 nil)),
                        (Util'ret1 arg7, (§ ass arg7 nil)),
                        (Util'ret1 arg8, (§ ass arg8 nil)),
                        (Util'ret1 arg9, (§ ass arg9 nil)),
                        (Util'ret1 arg10, (§ ass arg10 nil)),
                        (Util'ret1 arg11, (§ ass arg11 nil)),
                        (Util'ret1 arg12, (§ ass arg12 nil)),
                        (Util'ret1 arg13, (§ ass arg13 nil)),
                        (Util'ret1 arg14, (§ ass arg14 nil)),
                        (Util'ret1 arg15, (§ ass arg15 nil)),
                        (Util'ret1 arg16, (§ ass arg16 nil)),
                        (Util'ret1 arg17, (§ ass arg17 nil)),
                        (Util'ret1 arg18, (§ ass arg18 nil)),
                        (Util'ret1 arg19, (§ ass arg19 nil)),
                        (Util'ret1 arg20, (§ ass arg20 nil))))
            1
                (RestFn'''doInvoke-3 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg2, (§ ass arg2 nil)),
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            2
                (RestFn'''doInvoke-4 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg3, (§ ass arg3 nil)),
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            3
                (RestFn'''doInvoke-5 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg4, (§ ass arg4 nil)),
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            4
                (RestFn'''doInvoke-6 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg5, (§ ass arg5 nil)),
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            5
                (RestFn'''doInvoke-7 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg6, (§ ass arg6 nil)),
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            6
                (RestFn'''doInvoke-8 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg7, (§ ass arg7 nil)),
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            7
                (RestFn'''doInvoke-9 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg8, (§ ass arg8 nil)),
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            8
                (RestFn'''doInvoke-10 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg9, (§ ass arg9 nil)),
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            9
                (RestFn'''doInvoke-11 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg10, (§ ass arg10 nil)),
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            10
                (RestFn'''doInvoke-12 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg11, (§ ass arg11 nil)),
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            11
                (RestFn'''doInvoke-13 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg12, (§ ass arg12 nil)),
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            12
                (RestFn'''doInvoke-14 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg13, (§ ass arg13 nil)),
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            13
                (RestFn'''doInvoke-15 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg14, (§ ass arg14 nil)),
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            14
                (RestFn'''doInvoke-16 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg15, (§ ass arg15 nil)),
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            15
                (RestFn'''doInvoke-17 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg16, (§ ass arg16 nil)),
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            16
                (RestFn'''doInvoke-18 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg17, (§ ass arg17 nil)),
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            17
                (RestFn'''doInvoke-19 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg18, (§ ass arg18 nil)),
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            18
                (RestFn'''doInvoke-20 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg19, (§ ass arg19 nil)),
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            19
                (RestFn'''doInvoke-21 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)),
                        (RestFn'ontoArrayPrepend args,
                            (Util'ret1 arg20, (§ ass arg20 nil))))
            20
                (RestFn'''doInvoke-22 this,
                    (Util'ret1 arg1, (§ ass arg1 nil)),
                    (Util'ret1 arg2, (§ ass arg2 nil)),
                    (Util'ret1 arg3, (§ ass arg3 nil)),
                    (Util'ret1 arg4, (§ ass arg4 nil)),
                    (Util'ret1 arg5, (§ ass arg5 nil)),
                    (Util'ret1 arg6, (§ ass arg6 nil)),
                    (Util'ret1 arg7, (§ ass arg7 nil)),
                    (Util'ret1 arg8, (§ ass arg8 nil)),
                    (Util'ret1 arg9, (§ ass arg9 nil)),
                    (Util'ret1 arg10, (§ ass arg10 nil)),
                    (Util'ret1 arg11, (§ ass arg11 nil)),
                    (Util'ret1 arg12, (§ ass arg12 nil)),
                    (Util'ret1 arg13, (§ ass arg13 nil)),
                    (Util'ret1 arg14, (§ ass arg14 nil)),
                    (Util'ret1 arg15, (§ ass arg15 nil)),
                    (Util'ret1 arg16, (§ ass arg16 nil)),
                    (Util'ret1 arg17, (§ ass arg17 nil)),
                    (Util'ret1 arg18, (§ ass arg18 nil)),
                    (Util'ret1 arg19, (§ ass arg19 nil)),
                    (Util'ret1 arg20, (§ ass arg20 nil)),
                        (ArraySeq'create-1 args))
            (do
                (AFn'''throwArity this, 21)
            )
        )
    )

    #_protected
    (defn #_"ISeq" RestFn'ontoArrayPrepend [#_"Object[]" array & #_"Object..." args]
        (loop-when-recur [#_"ISeq" s (ArraySeq'create-1 array) #_"int" i (dec (alength args))] (<= 0 i) [(RT'cons (aget args i), s) (dec i)] => s)
    )

    #_protected
    (defn #_"ISeq" RestFn'findKey [#_"Object" key, #_"ISeq" args]
        (loop-when args (some? args)
            (if (= key (.first args)) (.next args) (recur (RT'next (RT'next args))))
        )
    )
)
)

(java-ns cloiure.lang.RT

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

#_private
#_closure
(class-ns DefaultComparator (§ implements Comparator)
    (defn #_"DefaultComparator" DefaultComparator'new []
        (hash-map)
    )

    #_foreign
    (§ defn #_"int" compare [#_"DefaultComparator" this, #_"Object" o1, #_"Object" o2]
        (Util'compare o1, o2)
    )
)

#_stateless
(class-ns RT
    (def #_"Boolean" RT'T Boolean/TRUE)
    (def #_"Boolean" RT'F Boolean/FALSE)
    (def #_"String" RT'LOADER_SUFFIX "__init")

    ;; simple-symbol->class
    (§ def #_"IPersistentMap" RT'DEFAULT_IMPORTS (RT'map
        (object-array [
            (Symbol'intern "Boolean")                         Boolean
            (Symbol'intern "Byte")                            Byte
            (Symbol'intern "Character")                       Character
            (Symbol'intern "Class")                           Class
            (Symbol'intern "ClassLoader")                     ClassLoader
            (Symbol'intern "Compiler")                        Compiler
            (Symbol'intern "Double")                          Double
            (Symbol'intern "Enum")                            Enum
            (Symbol'intern "Float")                           Float
            (Symbol'intern "InheritableThreadLocal")          InheritableThreadLocal
            (Symbol'intern "Integer")                         Integer
            (Symbol'intern "Long")                            Long
            (Symbol'intern "Math")                            Math
            (Symbol'intern "Number")                          Number
            (Symbol'intern "Object")                          Object
            (Symbol'intern "Package")                         Package
            (Symbol'intern "Process")                         Process
            (Symbol'intern "ProcessBuilder")                  ProcessBuilder
            (Symbol'intern "Runtime")                         Runtime
            (Symbol'intern "RuntimePermission")               RuntimePermission
            (Symbol'intern "SecurityManager")                 SecurityManager
            (Symbol'intern "Short")                           Short
            (Symbol'intern "StackTraceElement")               StackTraceElement
            (Symbol'intern "StrictMath")                      StrictMath
            (Symbol'intern "String")                          String
            (Symbol'intern "StringBuffer")                    StringBuffer
            (Symbol'intern "StringBuilder")                   StringBuilder
            (Symbol'intern "System")                          System
            (Symbol'intern "Thread")                          Thread
            (Symbol'intern "ThreadGroup")                     ThreadGroup
            (Symbol'intern "ThreadLocal")                     ThreadLocal
            (Symbol'intern "Throwable")                       Throwable
            (Symbol'intern "Void")                            Void
            (Symbol'intern "Appendable")                      Appendable
            (Symbol'intern "CharSequence")                    CharSequence
            (Symbol'intern "Cloneable")                       Cloneable
            (Symbol'intern "Comparable")                      Comparable
            (Symbol'intern "Iterable")                        Iterable
            (Symbol'intern "Readable")                        Readable
            (Symbol'intern "Runnable")                        Runnable
            (Symbol'intern "Callable")                        Callable
            (Symbol'intern "BigInteger")                      BigInteger
            (Symbol'intern "BigDecimal")                      BigDecimal
            (Symbol'intern "ArithmeticException")             ArithmeticException
            (Symbol'intern "ArrayIndexOutOfBoundsException")  ArrayIndexOutOfBoundsException
            (Symbol'intern "ArrayStoreException")             ArrayStoreException
            (Symbol'intern "ClassCastException")              ClassCastException
            (Symbol'intern "ClassNotFoundException")          ClassNotFoundException
            (Symbol'intern "CloneNotSupportedException")      CloneNotSupportedException
            (Symbol'intern "EnumConstantNotPresentException") EnumConstantNotPresentException
            (Symbol'intern "Exception")                       Exception
            (Symbol'intern "IllegalAccessException")          IllegalAccessException
            (Symbol'intern "IllegalArgumentException")        IllegalArgumentException
            (Symbol'intern "IllegalMonitorStateException")    IllegalMonitorStateException
            (Symbol'intern "IllegalStateException")           IllegalStateException
            (Symbol'intern "IllegalThreadStateException")     IllegalThreadStateException
            (Symbol'intern "IndexOutOfBoundsException")       IndexOutOfBoundsException
            (Symbol'intern "InstantiationException")          InstantiationException
            (Symbol'intern "InterruptedException")            InterruptedException
            (Symbol'intern "NegativeArraySizeException")      NegativeArraySizeException
            (Symbol'intern "NoSuchFieldException")            NoSuchFieldException
            (Symbol'intern "NoSuchMethodException")           NoSuchMethodException
            (Symbol'intern "NullPointerException")            NullPointerException
            (Symbol'intern "NumberFormatException")           NumberFormatException
            (Symbol'intern "RuntimeException")                RuntimeException
            (Symbol'intern "SecurityException")               SecurityException
            (Symbol'intern "StringIndexOutOfBoundsException") StringIndexOutOfBoundsException
            (Symbol'intern "TypeNotPresentException")         TypeNotPresentException
            (Symbol'intern "UnsupportedOperationException")   UnsupportedOperationException
            (Symbol'intern "AbstractMethodError")             AbstractMethodError
            (Symbol'intern "AssertionError")                  AssertionError
            (Symbol'intern "ClassCircularityError")           ClassCircularityError
            (Symbol'intern "ClassFormatError")                ClassFormatError
            (Symbol'intern "Error")                           Error
            (Symbol'intern "ExceptionInInitializerError")     ExceptionInInitializerError
            (Symbol'intern "IllegalAccessError")              IllegalAccessError
            (Symbol'intern "IncompatibleClassChangeError")    IncompatibleClassChangeError
            (Symbol'intern "InstantiationError")              InstantiationError
            (Symbol'intern "InternalError")                   InternalError
            (Symbol'intern "LinkageError")                    LinkageError
            (Symbol'intern "NoClassDefFoundError")            NoClassDefFoundError
            (Symbol'intern "NoSuchFieldError")                NoSuchFieldError
            (Symbol'intern "NoSuchMethodError")               NoSuchMethodError
            (Symbol'intern "OutOfMemoryError")                OutOfMemoryError
            (Symbol'intern "StackOverflowError")              StackOverflowError
            (Symbol'intern "ThreadDeath")                     ThreadDeath
            (Symbol'intern "UnknownError")                    UnknownError
            (Symbol'intern "UnsatisfiedLinkError")            UnsatisfiedLinkError
            (Symbol'intern "UnsupportedClassVersionError")    UnsupportedClassVersionError
            (Symbol'intern "VerifyError")                     VerifyError
            (Symbol'intern "VirtualMachineError")             VirtualMachineError
            (Symbol'intern "Thread$UncaughtExceptionHandler") Thread$UncaughtExceptionHandler
            (Symbol'intern "Thread$State")                    Thread$State
            (Symbol'intern "Deprecated")                      Deprecated
            (Symbol'intern "Override")                        Override
            (Symbol'intern "SuppressWarnings")                SuppressWarnings
        ])
    ))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (def #_"Charset" RT'UTF8 (Charset/forName "UTF-8"))

    (§ def #_"Namespace" RT'CLOIURE_NS (Namespace'findOrCreate (Symbol'intern "cloiure.core")))

    (§ def #_"Var" RT'IN (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*in*"), (LineNumberingPushbackReader'new-1 (InputStreamReader. System/in)))))
    (§ def #_"Var" RT'OUT (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*out*"), (OutputStreamWriter. System/out))))
    (§ def #_"Var" RT'ERR (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*err*"), (PrintWriter. (OutputStreamWriter. System/err), true))))

    (§ def #_"Keyword" RT'TAG_KEY (Keyword'intern (Symbol'intern nil, "tag")))

    (§ def #_"Var" RT'AGENT (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*agent*"), nil)))

    (§ def #_"Var" RT'ASSERT (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*assert*"), RT'T)))
    (§ def #_"Var" RT'MATH_CONTEXT (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*math-context*"), nil)))

    (§ def #_"Keyword" RT'LINE_KEY (Keyword'intern (Symbol'intern nil, "line")))
    (§ def #_"Keyword" RT'COLUMN_KEY (Keyword'intern (Symbol'intern nil, "column")))
    (§ def #_"Keyword" RT'DECLARED_KEY (Keyword'intern (Symbol'intern nil, "declared")))
    (§ def #_"Keyword" RT'DOC_KEY (Keyword'intern (Symbol'intern nil, "doc")))

    (§ def #_"Symbol" RT'IN_NAMESPACE (Symbol'intern "in-ns"))
    (§ def #_"Symbol" RT'NAMESPACE (Symbol'intern "ns"))
    (§ def #_"Symbol" RT'IDENTICAL (Symbol'intern "identical?"))

    (§ def #_"Var" RT'CURRENT_NS (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*ns*"), RT'CLOIURE_NS)))

    (§ def #_"Var" RT'FLUSH_ON_NEWLINE (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*flush-on-newline*"), RT'T)))
    (§ def #_"Var" RT'PRINT_READABLY (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*print-readably*"), RT'T)))
    (§ def #_"Var" RT'WARN_ON_REFLECTION (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*warn-on-reflection*"), RT'F)))
    (§ def #_"Var" RT'ALLOW_UNRESOLVED_VARS (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*allow-unresolved-vars*"), RT'F)))

    (§ def #_"Var" RT'IN_NS_VAR (Var'intern RT'CLOIURE_NS, (Symbol'intern "in-ns"), RT'F))
    (§ def #_"Var" RT'NS_VAR (Var'intern RT'CLOIURE_NS, (Symbol'intern "ns"), RT'F))
    (§ def #_"Var" RT'FN_LOADER_VAR (Var''setDynamic (Var'intern RT'CLOIURE_NS, (Symbol'intern "*fn-loader*"), nil)))
    (§ def #_"Var" RT'PRINT_INITIALIZED (Var'intern RT'CLOIURE_NS, (Symbol'intern "print-initialized")))
    (§ def #_"Var" RT'PR_ON (Var'intern RT'CLOIURE_NS, (Symbol'intern "pr-on")))

    (def #_"IFn" RT'inNamespace
        (§ reify AFn()
            #_override
            (defn #_"Object" IFn'''invoke-2--AFn [#_"AFn" this, #_"Object" arg1]
                (let [#_"Namespace" ns (Namespace'findOrCreate (cast' Symbol arg1))]
                    (Var''set RT'CURRENT_NS, ns)
                    ns
                )
            )
        )
    )

    (def #_"IFn" RT'bootNamespace
        (§ reify AFn()
            #_override
            (defn #_"Object" IFn'''invoke-4--AFn [#_"AFn" this, #_"Object" __form, #_"Object" __env, #_"Object" arg1]
                (let [#_"Namespace" ns (Namespace'findOrCreate (cast' Symbol arg1))]
                    (Var''set RT'CURRENT_NS, ns)
                    ns
                )
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (defn #_"PrintWriter" RT'errPrintWriter []
        (let [#_"Writer" w (cast Writer (IDeref'''deref RT'ERR))]
            (if (instance? PrintWriter w) (cast PrintWriter w) (PrintWriter. w))
        )
    )

    (def #_"Object[]" RT'EMPTY_ARRAY (make-array Object 0))
    (§ def #_"Comparator" RT'DEFAULT_COMPARATOR (DefaultComparator'new))

    (def #_"AtomicInteger" RT'ID (AtomicInteger. 1))

    (def #_"boolean" RT'CHECK_SPEC_ASSERTS false #_"cloiure.spec.check-asserts")
    (def #_"boolean" RT'INSTRUMENT_MACROS true #_"cloiure.spec.skip-macros")
    #_volatile
    (def #_"boolean" RT'CHECK_SPECS false)

    (§ static
        (Var''setTag RT'OUT, (Symbol'intern "java.io.Writer"))
        (Var''setTag RT'CURRENT_NS, (Symbol'intern "cloiure.lang.Namespace"))
        (Var''setMeta RT'AGENT, (RT'map RT'DOC_KEY, "The agent currently running an action on this thread, else nil."))
        (Var''setTag RT'AGENT, (Symbol'intern "cloiure.lang.Agent"))
        (Var''setTag RT'MATH_CONTEXT, (Symbol'intern "java.math.MathContext"))
        (let [#_"Var" v (Var'intern RT'CLOIURE_NS, RT'NAMESPACE, bootNamespace)
              _ (Var''setMacro v)
              v (Var'intern RT'CLOIURE_NS, RT'IN_NAMESPACE, inNamespace)
              _ (Var''setMeta v, (RT'map RT'DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed."))]
            (try
                (RT'load-1 "cloiure/core")
                (catch Exception e
                    (throw (Util'sneakyThrow e))
                )
            )
            (§ ass RT'CHECK_SPECS RT'INSTRUMENT_MACROS)
        )
    )

    (defn #_"Keyword" RT'keyword [#_"String" ns, #_"String" name]
        (Keyword'intern (Symbol'intern ns, name))
    )

    (defn #_"Var" RT'var
        ([#_"String" ns, #_"String" name]
            (Var'intern (Namespace'findOrCreate (Symbol'intern nil, ns)), (Symbol'intern nil, name))
        )
        ([#_"String" ns, #_"String" name, #_"Object" init]
            (Var'intern (Namespace'findOrCreate (Symbol'intern nil, ns)), (Symbol'intern nil, name), init)
        )
    )

    (defn #_"void" RT'loadResourceScript [#_"String" name, #_"boolean" failIfNotFound] #_(§ throws IOException)
        (let [#_"InputStream" ins (RT'resourceAsStream (RT'baseLoader), name)]
            (cond (some? ins)
                (try
                    (Compiler'load (InputStreamReader. ins, RT'UTF8))
                    (finally
                        (.close ins)
                    )
                )
                failIfNotFound
                    (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " name)))
            )
        )
        nil
    )

    (defn #_"long" RT'lastModified [#_"URL" url, #_"String" libfile] #_(§ throws IOException)
        (let [#_"URLConnection" connection (.openConnection url)]
            (try
                (if (= (.getProtocol url) "jar")
                    (.getTime (.getEntry (.getJarFile (cast JarURLConnection connection)), libfile))
                    (.getLastModified connection)
                )
                (finally
                    (let [#_"InputStream" ins (.getInputStream connection)]
                        (when (some? ins)
                            (.close ins)
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'load-1 [#_"String" scriptbase] #_(§ throws IOException, ClassNotFoundException)
        (RT'load-2 scriptbase, true)
        nil
    )

    (defn #_"void" RT'load-2 [#_"String" scriptbase, #_"boolean" failIfNotFound] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"String" classfile (str scriptbase RT'LOADER_SUFFIX ".class") #_"String" cljfile (str scriptbase ".cli")
              #_"URL" classURL (RT'getResource (RT'baseLoader), classfile) #_"URL" cljURL (RT'getResource (RT'baseLoader), cljfile)
              #_"boolean" loaded false]
            (when (or (and (some? classURL) (or (nil? cljURL) (< (RT'lastModified cljURL, cljfile) (RT'lastModified classURL, classfile)))) (nil? classURL))
                (try
                    (Var'pushThreadBindings (RT'mapUniqueKeys
                        (object-array [
                            RT'CURRENT_NS         (IDeref'''deref RT'CURRENT_NS)
                            RT'WARN_ON_REFLECTION (IDeref'''deref RT'WARN_ON_REFLECTION)
                        ])
                    ))
                    (§ ass loaded (some? (RT'loadClassForName (str (.replace scriptbase, \/, \.) RT'LOADER_SUFFIX))))
                    (finally
                        (Var'popThreadBindings)
                    )
                )
            )
            (cond (and (not loaded) (some? cljURL))
                (RT'loadResourceScript cljfile, true)
                (and (not loaded) failIfNotFound)
                    (throw (FileNotFoundException. (str "Could not locate " classfile " or " cljfile " on classpath." (when (.contains scriptbase, "_") " Please check that namespaces with dashes use underscores in the Cloiure file name."))))
            )
        )
        nil
    )

    (defn #_"int" RT'nextID []
        (.getAndIncrement RT'ID)
    )

    (def- #_"int" RT'CHUNK_SIZE 32)

    (defn #_"ISeq" RT'chunkIteratorSeq [#_"Iterator" it]
        (when (.hasNext it)
            (LazySeq'new-1
                (§ reify AFn()
                    #_override
                    (defn #_"Object" IFn'''invoke-1--AFn [#_"AFn" this]
                        (let [#_"Object[]" a (make-array Object RT'CHUNK_SIZE)
                              #_"int" n
                                (loop-when-recur [n 0] (and (.hasNext it) (< n RT'CHUNK_SIZE)) [(inc n)] => n
                                    (aset a n (.next it))
                                )]
                            (ChunkedCons'new-2 (ArrayChunk'new-3 a, 0, n), (RT'chunkIteratorSeq it))
                        )
                    )
                )
            )
        )
    )

    (defn #_"ISeq" RT'seq [#_"Object" coll]
        (cond
            (§ instance? ASeq coll)    (cast' ASeq coll)
            (§ instance? LazySeq coll) (Seqable'''seq (cast' LazySeq coll))
            :else                      (RT'seqFrom coll)
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (defn #_"ISeq" RT'seqFrom [#_"Object" coll]
        (cond
            (§ instance? Seqable coll)    (Seqable'''seq (cast' Seqable coll))
            (nil? coll)                   nil
            (instance? Iterable coll)     (RT'chunkIteratorSeq (.iterator (cast Iterable coll)))
            (.isArray (.getClass coll))   (ArraySeq'createFromObject coll)
            (instance? CharSequence coll) (StringSeq'create (cast CharSequence coll))
            (instance? Map coll)          (RT'seq (.entrySet (cast Map coll)))
            :else (throw (IllegalArgumentException. (str "Don't know how to create ISeq from: " (.getName (.getClass coll)))))
        )
    )

    (defn #_"boolean" RT'canSeq [#_"Object" coll]
        (or
            (§ instance? ISeq coll)
            (§ instance? Seqable coll)
            (nil? coll)
            (instance? Iterable coll)
            (.isArray (.getClass coll))
            (instance? CharSequence coll)
            (instance? Map coll)
        )
    )

    (defn #_"Iterator" RT'iter [#_"Object" coll]
        (cond
            (instance? Iterable coll)
                (.iterator (cast Iterable coll))
            (nil? coll)
                (§ reify Iterator()
                    #_foreign
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        false
                    )

                    #_foreign
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (throw (NoSuchElementException.))
                    )

                    #_foreign
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            (instance? Map coll)
                (.iterator (.entrySet (cast Map coll)))
            (instance? String coll)
                (let [#_"String" s (cast String coll)]
                    (§ reify Iterator()
                        (§ init
                            (hash-map
                                #_"int" :i 0
                            )
                        )

                        #_foreign
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (< (:i this) (.length s))
                        )

                        #_foreign
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [_ (.charAt s, (:i this))]
                                (§ ass (:i this) (inc (:i this)))
                                _
                            )
                        )

                        #_foreign
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            (.isArray (.getClass coll))
                (ArrayIter'createFromObject coll)
            :else
                (RT'iter (RT'seq coll))
        )
    )

    (defn #_"Object" RT'seqOrElse [#_"Object" o]
        (when (some? (RT'seq o))
            o
        )
    )

    (defn #_"ISeq" RT'keys [#_"Object" coll]
        (if (§ instance? IPersistentMap coll)
            (KeySeq'createFromMap (cast' IPersistentMap coll))
            (KeySeq'create (RT'seq coll))
        )
    )

    (defn #_"ISeq" RT'vals [#_"Object" coll]
        (if (§ instance? IPersistentMap coll)
            (ValSeq'createFromMap (cast' IPersistentMap coll))
            (ValSeq'create (RT'seq coll))
        )
    )

    (defn #_"IPersistentMap" RT'meta [#_"Object" x]
        (when (§ instance? IMeta x)
            (IMeta'''meta (cast' IMeta x))
        )
    )

    (defn #_"int" RT'count [#_"Object" o]
        (if (§ instance? Counted o)
            (.count (cast' Counted o))
            (RT'countFrom (Util'ret1 o, (§ ass o nil)))
        )
    )

    (defn #_"int" RT'countFrom [#_"Object" o]
        (cond
            (nil? o)
                0
            (§ instance? IPersistentCollection o)
                (let [#_"ISeq" s (RT'seq o) _ (§ ass o nil)]
                    (loop-when [#_"int" i 0 s s] (some? s) => i
                        (if (§ instance? Counted s)
                            (+ i (.count s))
                            (recur (inc i) (.next s))
                        )
                    )
                )
            (instance? CharSequence o)
                (.length (cast CharSequence o))
            (instance? Collection o)
                (.size (cast Collection o))
            (instance? Map o)
                (.size (cast Map o))
            (instance? Map$Entry o)
                2
            (.isArray (.getClass o))
                (Array/getLength o)
            :else
                (throw (UnsupportedOperationException. (str "count not supported on this type: " (.getSimpleName (.getClass o)))))
        )
    )

    (defn #_"IPersistentCollection" RT'conj [#_"IPersistentCollection" coll, #_"Object" x]
        (if (some? coll) (IPersistentCollection'''cons coll, x) (PersistentList'new-1 x))
    )

    (defn #_"ISeq" RT'cons [#_"Object" x, #_"Object" coll]
        (cond
            (nil? coll)             (PersistentList'new-1 x)
            (§ instance? ISeq coll) (Cons'new-2 x, (cast' ISeq coll))
            :else                   (Cons'new-2 x, (RT'seq coll))
        )
    )

    (defn #_"Object" RT'first [#_"Object" x]
        (if (§ instance? ISeq x)
            (.first (cast' ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (when (some? s)
                    (.first s)
                )
            )
        )
    )

    (defn #_"Object" RT'second [#_"Object" x]
        (RT'first (RT'next x))
    )

    (defn #_"Object" RT'third [#_"Object" x]
        (RT'first (RT'next (RT'next x)))
    )

    (defn #_"Object" RT'fourth [#_"Object" x]
        (RT'first (RT'next (RT'next (RT'next x))))
    )

    (defn #_"ISeq" RT'next [#_"Object" x]
        (if (§ instance? ISeq x)
            (.next (cast' ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (when (some? s)
                    (.next s)
                )
            )
        )
    )

    (defn #_"ISeq" RT'more [#_"Object" x]
        (if (§ instance? ISeq x)
            (ISeq'''more (cast' ISeq x))
            (let [#_"ISeq" s (RT'seq x)]
                (if (some? s) (ISeq'''more s) PersistentList'EMPTY)
            )
        )
    )

    (defn #_"Object" RT'peek [#_"Object" x]
        (when (some? x)
            (IPersistentStack'''peek (cast' IPersistentStack x))
        )
    )

    (defn #_"Object" RT'pop [#_"Object" x]
        (when (some? x)
            (IPersistentStack'''pop (cast' IPersistentStack x))
        )
    )

    (defn #_"Object" RT'get-2 [#_"Object" coll, #_"Object" key]
        (if (§ instance? ILookup coll)
            (ILookup'''valAt-2 (cast' ILookup coll), key)
            (RT'getFrom-2 coll, key)
        )
    )

    (defn #_"Object" RT'getFrom-2 [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                nil
            (instance? Map coll)
                (.get (cast Map coll), key)
            (§ instance? IPersistentSet coll)
                (IPersistentSet'''get (cast' IPersistentSet coll), key)
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let-when [#_"int" n (.intValue (cast Number key))] (< -1 n (RT'count coll))
                    (RT'nth-2 coll, n)
                )
            (§ instance? ITransientSet coll)
                (ITransientSet'''get (cast' ITransientSet coll), key)
        )
    )

    (defn #_"Object" RT'get-3 [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (if (§ instance? ILookup coll)
            (ILookup'''valAt-3 (cast' ILookup coll), key, notFound)
            (RT'getFrom-3 coll, key, notFound)
        )
    )

    (defn #_"Object" RT'getFrom-3 [#_"Object" coll, #_"Object" key, #_"Object" notFound]
        (cond
            (nil? coll)
                notFound
            (instance? Map coll)
                (let [#_"Map" m (cast Map coll)]
                    (if (.containsKey m, key) (.get m, key) notFound)
                )
            (§ instance? IPersistentSet coll)
                (let [#_"IPersistentSet" s (cast' IPersistentSet coll)]
                    (if (IPersistentSet'''contains s, key) (IPersistentSet'''get s, key) notFound)
                )
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let [#_"int" n (.intValue (cast Number key))]
                    (if (< -1 n (RT'count coll)) (RT'nth-2 coll, n) notFound)
                )
            (§ instance? ITransientSet coll)
                (let [#_"ITransientSet" s (cast' ITransientSet coll)]
                    (if (ITransientSet'''contains s, key) (ITransientSet'''get s, key) notFound)
                )
            :else
                notFound
        )
    )

    (defn #_"Associative" RT'assoc [#_"Object" coll, #_"Object" key, #_"Object" val]
        (if (some? coll)
            (Associative'''assoc (cast' Associative coll), key, val)
            (PersistentArrayMap'new-1 (object-array [ key, val ]))
        )
    )

    (defn #_"Object" RT'contains [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                RT'F
            (§ instance? Associative coll)
                (if (Associative'''containsKey (cast' Associative coll), key) RT'T RT'F)
            (§ instance? IPersistentSet coll)
                (if (IPersistentSet'''contains (cast' IPersistentSet coll), key) RT'T RT'F)
            (instance? Map coll)
                (if (.containsKey (cast Map coll), key) RT'T RT'F)
            (instance? Set coll)
                (if (.contains (cast Set coll), key) RT'T RT'F)
            (and (instance? Number key) (or (instance? String coll) (.isArray (.getClass coll))))
                (let [#_"int" n (.intValue (cast Number key))]
                    (if (< -1 n (RT'count coll)) RT'T RT'F)
                )
            (§ instance? ITransientSet coll)
                (if (ITransientSet'''contains (cast' ITransientSet coll), key) RT'T RT'F)
            (§ instance? ITransientAssociative2 coll)
                (if (ITransientAssociative2'''containsKey (cast' ITransientAssociative2 coll), key) RT'T RT'F)
            :else
                (throw (IllegalArgumentException. (str "contains? not supported on type: " (.getName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'find [#_"Object" coll, #_"Object" key]
        (cond
            (nil? coll)
                nil
            (§ instance? Associative coll)
                (Associative'''entryAt (cast' Associative coll), key)
            (instance? Map coll)
                (let-when [#_"Map" m (cast Map coll)] (.containsKey m, key)
                    (MapEntry'create key, (.get m, key))
                )
            (§ instance? ITransientAssociative2 coll)
                (ITransientAssociative2'''entryAt (cast' ITransientAssociative2 coll), key)
            :else
                (throw (IllegalArgumentException. (str "find not supported on type: " (.getName (.getClass coll)))))
        )
    )

    ;; takes a seq of key, val, key, val
    ;; returns tail starting at val of matching key if found, else nil

    (defn #_"ISeq" RT'findKey [#_"Keyword" key, #_"ISeq" keyvals]
        (loop-when keyvals (some? keyvals)
            (let-when [#_"ISeq" r (.next keyvals)] (some? r) => (throw (RuntimeException. "Malformed keyword argslist"))
                (when-not (= (.first keyvals) key) => r
                    (recur (.next r))
                )
            )
        )
    )

    (defn #_"Object" RT'dissoc [#_"Object" coll, #_"Object" key]
        (when (some? coll)
            (IPersistentMap'''without (cast' IPersistentMap coll), key)
        )
    )

    (defn #_"Object" RT'nth-2 [#_"Object" coll, #_"int" n]
        (if (§ instance? Indexed coll)
            (Indexed'''nth-2 (cast' Indexed coll), n)
            (RT'nthFrom-2 (Util'ret1 coll, (§ ass coll nil)), n)
        )
    )

    (defn #_"Object" RT'nthFrom-2 [#_"Object" coll, #_"int" n]
        (cond
            (nil? coll)
                nil
            (instance? CharSequence coll)
                (Character/valueOf (.charAt (cast CharSequence coll), n))
            (.isArray (.getClass coll))
                (Reflector'prepRet (.getComponentType (.getClass coll)), (Array/get coll, n))
            (instance? RandomAccess coll)
                (.get (cast List coll), n)
            (instance? Matcher coll)
                (.group (cast Matcher coll), n)
            (instance? Map$Entry coll)
                (let [#_"Map$Entry" e (cast Map$Entry coll)]
                    (cond
                        (zero? n) (.getKey e)
                        (= n 1)   (.getValue e)
                        :else     (throw (IndexOutOfBoundsException.))
                    )
                )
            (§ instance? Sequential coll)
                (let [#_"ISeq" s (RT'seq coll) _ (§ ass coll nil)]
                    (loop-when [#_"int" i 0 s s] (and (<= i n) (some? s)) => (throw (IndexOutOfBoundsException.))
                        (if (= i n)
                            (.first s)
                            (recur (inc i) (.next s))
                        )
                    )
                )
            :else
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'nth-3 [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (if (§ instance? Indexed coll)
            (Indexed'''nth-3 (cast' Indexed coll), n, notFound)
            (RT'nthFrom-3 coll, n, notFound)
        )
    )

    (defn #_"Object" RT'nthFrom-3 [#_"Object" coll, #_"int" n, #_"Object" notFound]
        (cond
            (nil? coll)
                notFound
            (neg? n)
                notFound
            (instance? CharSequence coll)
                (let [#_"CharSequence" s (cast CharSequence coll)]
                    (if (< n (.length s)) (Character/valueOf (.charAt s, n)) notFound)
                )
            (.isArray (.getClass coll))
                (if (< n (Array/getLength coll))
                    (Reflector'prepRet (.getComponentType (.getClass coll)), (Array/get coll, n))
                    notFound
                )
            (instance? RandomAccess coll)
                (let [#_"List" l (cast List coll)]
                    (if (< n (.size l)) (.get l, n) notFound)
                )
            (instance? Matcher coll)
                (let [#_"Matcher" m (cast Matcher coll)]
                    (if (< n (.groupCount m)) (.group m, n) notFound)
                )
            (instance? Map$Entry coll)
                (let [#_"Map$Entry" e (cast Map$Entry coll)]
                    (cond
                        (zero? n) (.getKey e)
                        (= n 1)   (.getValue e)
                        :else     notFound
                    )
                )
            (§ instance? Sequential coll)
                (let [#_"ISeq" s (RT'seq coll) _ (§ ass coll nil)]
                    (loop-when [#_"int" i 0 s s] (and (<= i n) (some? s)) => notFound
                        (if (= i n)
                            (.first s)
                            (recur (inc i) (.next s))
                        )
                    )
                )
            :else
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (.getSimpleName (.getClass coll)))))
        )
    )

    (defn #_"Object" RT'assocN [#_"int" n, #_"Object" val, #_"Object" coll]
        (cond
            (nil? coll)
                nil
            (§ instance? IPersistentVector coll)
                (IPersistentVector'''assocN (cast' IPersistentVector coll), n, val)
            (§ instance? Object[] coll)
                ;; hmm... this is not persistent
                (let [#_"Object[]" array (§ cast Object[] coll)]
                    (aset array n val)
                    array
                )
        )
    )

    (defn #_"boolean" RT'hasTag [#_"Object" o, #_"Object" tag]
        (Util'equals tag, (RT'get-2 (RT'meta o), RT'TAG_KEY))
    )

    (defn #_"Object"    RT'box-1o [#_"Object"  x] x)
    (defn #_"Character" RT'box-1c [#_"char"    x] (Character/valueOf x))
    (defn #_"Object"    RT'box-1z [#_"boolean" x] (if x RT'T RT'F))
    (defn #_"Object"    RT'box-1Z [#_"Boolean" x] x)
    (defn #_"Number"    RT'box-1b [#_"byte"    x] x)
    (defn #_"Number"    RT'box-1s [#_"short"   x] x)
    (defn #_"Number"    RT'box-1i [#_"int"     x] x)
    (defn #_"Number"    RT'box-1l [#_"long"    x] x)
    (defn #_"Number"    RT'box-1f [#_"float"   x] x)
    (defn #_"Number"    RT'box-1d [#_"double"  x] x)

    (defn #_"char" RT'charCast-1o [#_"Object" x]
        (if (instance? Character x)
            (.charValue (cast Character x))
            (let [#_"long" n (.longValue (cast Number x))]
                (when (<= Character/MIN_VALUE n Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                    (char n)
                )
            )
        )
    )

    (defn #_"char" RT'charCast-1b [#_"byte" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1s [#_"short" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1c [#_"char" x]
        x
    )

    (defn #_"char" RT'charCast-1i [#_"int" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1l [#_"long" x]
        (let [#_"char" i (char x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
                i
            )
        )
    )

    (defn #_"char" RT'charCast-1f [#_"float" x]
        (when (<= Character/MIN_VALUE x Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
            (char x)
        )
    )

    (defn #_"char" RT'charCast-1d [#_"double" x]
        (when (<= Character/MIN_VALUE x Character/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for char: " x)))
            (char x)
        )
    )

    (defn #_"boolean" RT'booleanCast-1o [#_"Object" x]
        (if (instance? Boolean x) (.booleanValue (cast Boolean x)) (some? x))
    )

    (defn #_"boolean" RT'booleanCast-1b [#_"boolean" x]
        x
    )

    (defn #_"byte" RT'byteCast-1o [#_"Object" x]
        (if (instance? Byte x)
            (.byteValue (cast Byte x))
            (let [#_"long" n (RT'longCast-1o x)]
                (when (<= Byte/MIN_VALUE n Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                    (byte n)
                )
            )
        )
    )

    (defn #_"byte" RT'byteCast-1b [#_"byte" x]
        x
    )

    (defn #_"byte" RT'byteCast-1s [#_"short" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1i [#_"int" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1l [#_"long" x]
        (let [#_"byte" i (byte x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
                i
            )
        )
    )

    (defn #_"byte" RT'byteCast-1f [#_"float" x]
        (when (<= Byte/MIN_VALUE x Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
            (byte x)
        )
    )

    (defn #_"byte" RT'byteCast-1d [#_"double" x]
        (when (<= Byte/MIN_VALUE x Byte/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for byte: " x)))
            (byte x)
        )
    )

    (defn #_"short" RT'shortCast-1o [#_"Object" x]
        (if (instance? Short x)
            (.shortValue (cast Short x))
            (let [#_"long" n (RT'longCast-1o x)]
                (when (<= Short/MIN_VALUE n Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                    (short n)
                )
            )
        )
    )

    (defn #_"short" RT'shortCast-1b [#_"byte"  x] x)
    (defn #_"short" RT'shortCast-1s [#_"short" x] x)

    (defn #_"short" RT'shortCast-1i [#_"int" x]
        (let [#_"short" i (short x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                i
            )
        )
    )

    (defn #_"short" RT'shortCast-1l [#_"long" x]
        (let [#_"short" i (short x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
                i
            )
        )
    )

    (defn #_"short" RT'shortCast-1f [#_"float" x]
        (when (<= Short/MIN_VALUE x Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
            (short x)
        )
    )

    (defn #_"short" RT'shortCast-1d [#_"double" x]
        (when (<= Short/MIN_VALUE x Short/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for short: " x)))
            (short x)
        )
    )

    (defn #_"int" RT'intCast-1o [#_"Object" x]
        (cond
            (instance? Integer x) (.intValue (cast Integer x))
            (instance? Number x)  (RT'intCast-1l (RT'longCast-1o x))
            :else                 (.charValue (cast Character x))
        )
    )

    (defn #_"int" RT'intCast-1b [#_"byte"  x] x)
    (defn #_"int" RT'intCast-1s [#_"short" x] x)
    (defn #_"int" RT'intCast-1c [#_"char"  x] x)
    (defn #_"int" RT'intCast-1i [#_"int"   x] x)

    (defn #_"int" RT'intCast-1l [#_"long" x]
        (let [#_"int" i (int x)]
            (when (= i x) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
                i
            )
        )
    )

    (defn #_"int" RT'intCast-1f [#_"float" x]
        (when (<= Integer/MIN_VALUE x Integer/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
            (int x)
        )
    )

    (defn #_"int" RT'intCast-1d [#_"double" x]
        (when (<= Integer/MIN_VALUE x Integer/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for int: " x)))
            (int x)
        )
    )

    (defn #_"long" RT'longCast-1o [#_"Object" x]
        (cond
            (or (instance? Integer x) (instance? Long x))
                (.longValue (cast Number x))
            (§ instance? BigInt x)
                (let [#_"BigInt" bi (cast' BigInt x)]
                    (when (nil? (:bipart bi)) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
                        (:lpart bi)
                    )
                )
            (instance? BigInteger x)
                (let [#_"BigInteger" bi (cast BigInteger x)]
                    (when (< (.bitLength bi) 64) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
                        (.longValue bi)
                    )
                )
            (or (instance? Byte x) (instance? Short x))
                (.longValue (cast Number x))
            (§ instance? Ratio x)
                (RT'longCast-1o (Ratio''bigIntegerValue (cast' Ratio x)))
            (instance? Character x)
                (RT'longCast-1l (.charValue (cast Character x)))
            :else
                (RT'longCast-1d (.doubleValue (cast Number x)))
        )
    )

    (defn #_"long" RT'longCast-1b [#_"byte"  x] x)
    (defn #_"long" RT'longCast-1s [#_"short" x] x)
    (defn #_"long" RT'longCast-1i [#_"int"   x] x)
    (defn #_"long" RT'longCast-1l [#_"long"  x] x)

    (defn #_"long" RT'longCast-1f [#_"float" x]
        (when (<= Long/MIN_VALUE x Long/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
            (long x)
        )
    )

    (defn #_"long" RT'longCast-1d [#_"double" x]
        (when (<= Long/MIN_VALUE x Long/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for long: " x)))
            (long x)
        )
    )

    (defn #_"float" RT'floatCast-1o [#_"Object" x]
        (if (instance? Float x)
            (.floatValue (cast Float x))
            (let [#_"double" n (.doubleValue (cast Number x))]
                (when (<= (- Float/MAX_VALUE) n Float/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for float: " x)))
                    (float n)
                )
            )
        )
    )

    (defn #_"float" RT'floatCast-1b [#_"byte"  x] x)
    (defn #_"float" RT'floatCast-1s [#_"short" x] x)
    (defn #_"float" RT'floatCast-1i [#_"int"   x] x)
    (defn #_"float" RT'floatCast-1l [#_"long"  x] x)
    (defn #_"float" RT'floatCast-1f [#_"float" x] x)

    (defn #_"float" RT'floatCast-1d [#_"double" x]
        (when (<= (- Float/MAX_VALUE) x Float/MAX_VALUE) => (throw (IllegalArgumentException. (str "Value out of range for float: " x)))
            (float x)
        )
    )

    (defn #_"double" RT'doubleCast-1o [#_"Object" x]
        (.doubleValue (cast Number x))
    )

    (defn #_"double" RT'doubleCast-1b [#_"byte"   x] x)
    (defn #_"double" RT'doubleCast-1s [#_"short"  x] x)
    (defn #_"double" RT'doubleCast-1i [#_"int"    x] x)
    (defn #_"double" RT'doubleCast-1l [#_"long"   x] x)
    (defn #_"double" RT'doubleCast-1f [#_"float"  x] x)
    (defn #_"double" RT'doubleCast-1d [#_"double" x] x)

    (defn #_"byte" RT'uncheckedByteCast-1o [#_"Object" x]
        (.byteValue (cast Number x))
    )

    (defn #_"byte" RT'uncheckedByteCast-1b [#_"byte"   x]       x )
    (defn #_"byte" RT'uncheckedByteCast-1s [#_"short"  x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1i [#_"int"    x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1l [#_"long"   x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1f [#_"float"  x] (byte x))
    (defn #_"byte" RT'uncheckedByteCast-1d [#_"double" x] (byte x))

    (defn #_"short" RT'uncheckedShortCast-1o [#_"Object" x]
        (.shortValue (cast Number x))
    )

    (defn #_"short" RT'uncheckedShortCast-1b [#_"byte"   x]        x )
    (defn #_"short" RT'uncheckedShortCast-1s [#_"short"  x]        x )
    (defn #_"short" RT'uncheckedShortCast-1i [#_"int"    x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1l [#_"long"   x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1f [#_"float"  x] (short x))
    (defn #_"short" RT'uncheckedShortCast-1d [#_"double" x] (short x))

    (defn #_"char" RT'uncheckedCharCast-1o [#_"Object" x]
        (if (instance? Character x) (.charValue (cast Character x)) (char (.longValue (cast Number x))))
    )

    (defn #_"char" RT'uncheckedCharCast-1b [#_"byte"   x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1s [#_"short"  x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1c [#_"char"   x]       x )
    (defn #_"char" RT'uncheckedCharCast-1i [#_"int"    x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1l [#_"long"   x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1f [#_"float"  x] (char x))
    (defn #_"char" RT'uncheckedCharCast-1d [#_"double" x] (char x))

    (defn #_"int" RT'uncheckedIntCast-1o [#_"Object" x]
        (if (instance? Number x) (.intValue (cast Number x)) (.charValue (cast Character x)))
    )

    (defn #_"int" RT'uncheckedIntCast-1b [#_"byte"   x]      x )
    (defn #_"int" RT'uncheckedIntCast-1s [#_"short"  x]      x )
    (defn #_"int" RT'uncheckedIntCast-1c [#_"char"   x]      x )
    (defn #_"int" RT'uncheckedIntCast-1i [#_"int"    x]      x )
    (defn #_"int" RT'uncheckedIntCast-1l [#_"long"   x] (int x))
    (defn #_"int" RT'uncheckedIntCast-1f [#_"float"  x] (int x))
    (defn #_"int" RT'uncheckedIntCast-1d [#_"double" x] (int x))

    (defn #_"long" RT'uncheckedLongCast-1o [#_"Object" x]
        (.longValue (cast Number x))
    )

    (defn #_"long" RT'uncheckedLongCast-1b [#_"byte"   x]       x )
    (defn #_"long" RT'uncheckedLongCast-1s [#_"short"  x]       x )
    (defn #_"long" RT'uncheckedLongCast-1i [#_"int"    x]       x )
    (defn #_"long" RT'uncheckedLongCast-1l [#_"long"   x]       x )
    (defn #_"long" RT'uncheckedLongCast-1f [#_"float"  x] (long x))
    (defn #_"long" RT'uncheckedLongCast-1d [#_"double" x] (long x))

    (defn #_"float" RT'uncheckedFloatCast-1o [#_"Object" x]
        (.floatValue (cast Number x))
    )

    (defn #_"float" RT'uncheckedFloatCast-1b [#_"byte"   x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1s [#_"short"  x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1i [#_"int"    x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1l [#_"long"   x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1f [#_"float"  x]        x )
    (defn #_"float" RT'uncheckedFloatCast-1d [#_"double" x] (float x))

    (defn #_"double" RT'uncheckedDoubleCast-1o [#_"Object" x]
        (.doubleValue (cast Number x))
    )

    (defn #_"double" RT'uncheckedDoubleCast-1b [#_"byte"   x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1s [#_"short"  x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1i [#_"int"    x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1l [#_"long"   x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1f [#_"float"  x] x)
    (defn #_"double" RT'uncheckedDoubleCast-1d [#_"double" x] x)

    (defn #_"IPersistentMap" RT'map [& #_"Object..." init]
        (cond
            (nil? init)
                PersistentArrayMap'EMPTY
            (<= (alength init) PersistentArrayMap'HASHTABLE_THRESHOLD)
                (PersistentArrayMap'createWithCheck init)
            :else
                (PersistentHashMap'createWithCheck-1a init)
        )
    )

    (defn #_"IPersistentMap" RT'mapUniqueKeys [& #_"Object..." init]
        (cond
            (nil? init)
                PersistentArrayMap'EMPTY
            (<= (alength init) PersistentArrayMap'HASHTABLE_THRESHOLD)
                (PersistentArrayMap'new-1 init)
            :else
                (PersistentHashMap'create-1a init)
        )
    )

    (defn #_"IPersistentSet" RT'set [& #_"Object..." init]
        (PersistentHashSet'createWithCheck-1a init)
    )

    (defn #_"IPersistentVector" RT'vector [& #_"Object..." init]
        (LazilyPersistentVector'createOwning init)
    )

    (defn #_"IPersistentVector" RT'subvec [#_"IPersistentVector" v, #_"int" start, #_"int" end]
        (when (<= 0 start end (.count v)) => (throw (IndexOutOfBoundsException.))
            (if (= start end)
                PersistentVector'EMPTY
                (SubVector'new nil, v, start, end)
            )
        )
    )

    (defn #_"ISeq" RT'list-0 []
        nil
    )

    (defn #_"ISeq" RT'list-1 [#_"Object" arg1]
        (PersistentList'new-1 arg1)
    )

    (defn #_"ISeq" RT'list-2 [#_"Object" arg1, #_"Object" arg2]
        (RT'listStar-3 arg1, arg2, nil)
    )

    (defn #_"ISeq" RT'list-3 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (RT'listStar-4 arg1, arg2, arg3, nil)
    )

    (defn #_"ISeq" RT'list-4 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (RT'listStar-5 arg1, arg2, arg3, arg4, nil)
    )

    (defn #_"ISeq" RT'list-5 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (RT'listStar-6 arg1, arg2, arg3, arg4, arg5, nil)
    )

    (defn #_"ISeq" RT'listStar-2 [#_"Object" arg1, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, rest))
    )

    (defn #_"ISeq" RT'listStar-3 [#_"Object" arg1, #_"Object" arg2, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, (RT'cons arg2, rest)))
    )

    (defn #_"ISeq" RT'listStar-4 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, rest))))
    )

    (defn #_"ISeq" RT'listStar-5 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, (RT'cons arg4, rest)))))
    )

    (defn #_"ISeq" RT'listStar-6 [#_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"ISeq" rest]
        (cast' ISeq (RT'cons arg1, (RT'cons arg2, (RT'cons arg3, (RT'cons arg4, (RT'cons arg5, rest))))))
    )

    (defn #_"ISeq" RT'arrayToList [#_"Object[]" a]
        (let [#_"ISeq" s nil]
            (loop-when-recur [#_"int" i (dec (alength a))] (<= 0 i) [(dec i)]
                (§ ass s (cast' ISeq (RT'cons (aget a i), s)))
            )
            s
        )
    )

    (defn #_"Object[]" RT'object_array [#_"Object" sizeOrSeq]
        (if (instance? Number sizeOrSeq)
            (make-array Object (.intValue (cast Number sizeOrSeq)))
            (let [#_"ISeq" s (RT'seq sizeOrSeq) #_"int" size (RT'count s) #_"Object[]" a (make-array Object size)]
                (loop-when-recur [#_"int" i 0 s s] (and (< i size) (some? s)) [(inc i) (.next s)]
                    (aset a i (.first s))
                )
                a
            )
        )
    )

    (defn #_"Object[]" RT'toArray [#_"Object" coll]
        (cond
            (nil? coll)
                RT'EMPTY_ARRAY
            (§ instance? Object[] coll)
                (§ cast Object[] coll)
            (instance? Collection coll)
                (.toArray (cast Collection coll))
            (instance? Iterable coll)
                (let [#_"ArrayList" ret (ArrayList.)]
                    (doseq [#_"Object" o (cast Iterable coll)]
                        (.add ret, o)
                    )
                    (.toArray ret)
                )
            (instance? Map coll)
                (.toArray (.entrySet (cast Map coll)))
            (instance? String coll)
                (let [#_"char[]" chars (.toCharArray (cast String coll))
                      #_"Object[]" a (make-array Object (alength chars))]
                    (dotimes [#_"int" i (alength chars)]
                        (aset a i (aget chars i))
                    )
                    a
                )
            (.isArray (.getClass coll))
                (let [#_"ISeq" s (RT'seq coll)
                      #_"Object[]" a (make-array Object (RT'count s))]
                    (loop-when-recur [#_"int" i 0 s s] (< i (alength a)) [(inc i) (.next s)]
                        (aset a i (.first s))
                    )
                    a
                )
            :else
                (throw (RuntimeException. (str "Unable to convert: " (.getClass coll) " to Object[]")))
        )
    )

    (defn #_"Object[]" RT'seqToArray [#_"ISeq" s]
        (let [#_"Object[]" a (make-array Object (RT'length s))]
            (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                (aset a i (.first s))
            )
            a
        )
    )

    (defn #_"Object[]" RT'seqToPassedArray [#_"ISeq" s, #_"Object[]" passed]
        (let [#_"Object[]" dest passed #_"int" len (RT'count s)]
            (when (< (alength dest) len)
                (§ ass dest (§ cast Object[] (Array/newInstance (.getComponentType (.getClass passed)), len)))
            )
            (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                (aset dest i (.first s))
            )
            (when (< len (alength passed))
                (aset dest len nil)
            )
            dest
        )
    )

    (defn #_"Object" RT'seqToTypedArray-1 [#_"ISeq" s]
        (let [#_"Class" type (if (and (some? s) (some? (.first s))) (.getClass (.first s)) Object)]
            (RT'seqToTypedArray-2 type, s)
        )
    )

    (defn #_"Object" RT'seqToTypedArray-2 [#_"Class" type, #_"ISeq" s]
        (let [#_"Object" a (Array/newInstance type, (RT'length s))]
            (condp = type
                Integer/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'intCast-1o (.first s)))
                    )
                Byte/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'byteCast-1o (.first s)))
                    )
                Float/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'floatCast-1o (.first s)))
                    )
                Short/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'shortCast-1o (.first s)))
                    )
                Character/TYPE
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (RT'charCast-1o (.first s)))
                    )
                #_else
                    (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)]
                        (Array/set a, i, (.first s))
                    )
            )
            a
        )
    )

    (defn #_"int" RT'length [#_"ISeq" s]
        (loop-when-recur [#_"int" i 0 s s] (some? s) [(inc i) (.next s)] => i)
    )

    (defn #_"int" RT'boundedLength [#_"ISeq" s, #_"int" limit]
        (loop-when-recur [#_"int" i 0 s s] (and (some? s) (<= i limit)) [(inc i) (.next s)] => i)
    )

    (defn #_"Character" RT'readRet [#_"int" ret]
        (when-not (= ret -1)
            (RT'box-1c (char ret))
        )
    )

    (defn #_"Character" RT'readChar [#_"Reader" r] #_(§ throws IOException)
        (let [#_"int" ret (.read r)]
            (RT'readRet ret)
        )
    )

    (defn #_"Character" RT'peekChar [#_"Reader" r] #_(§ throws IOException)
        (let [#_"int" ret
                (if (instance? PushbackReader r)
                    (let [ret (.read r) _ (.unread (cast PushbackReader r), ret)]
                        ret
                    )
                    (let [_ (.mark r, 1) ret (.read r) _ (.reset r)]
                        ret
                    )
                )]
            (RT'readRet ret)
        )
    )

    (defn #_"int" RT'getLineNumber [#_"Reader" r]
        (if (§ instance? LineNumberingPushbackReader r)
            (LineNumberingPushbackReader''getLineNumber (cast' LineNumberingPushbackReader r))
            0
        )
    )

    (defn #_"int" RT'getColumnNumber [#_"Reader" r]
        (if (§ instance? LineNumberingPushbackReader r)
            (LineNumberingPushbackReader''getColumnNumber (cast' LineNumberingPushbackReader r))
            0
        )
    )

    (defn #_"LineNumberingPushbackReader" RT'getLineNumberingReader [#_"Reader" r]
        (if (RT'isLineNumberingReader r)
            (cast' LineNumberingPushbackReader r)
            (LineNumberingPushbackReader'new-1 r)
        )
    )

    (defn #_"boolean" RT'isLineNumberingReader [#_"Reader" r] (§ instance? LineNumberingPushbackReader r))

    (defn #_"boolean" RT'isReduced [#_"Object" r] (§ instance? Reduced r))

    (defn #_"String" RT'printString [#_"Object" x]
        (try
            (let [#_"StringWriter" sw (StringWriter.)]
                (RT'print x, sw)
                (.toString sw)
            )
            (catch Exception e
                (throw (Util'sneakyThrow e))
            )
        )
    )

    (defn #_"Object" RT'readString [#_"String" s]
        (let [#_"PushbackReader" r (PushbackReader. (java.io.StringReader. s))]
            (LispReader'read-1 r)
        )
    )

    (defn #_"void" RT'print [#_"Object" x, #_"Writer" w] #_(§ throws IOException)
        (if (and (Var''isBound RT'PRINT_INITIALIZED) (RT'booleanCast-1o (IDeref'''deref RT'PRINT_INITIALIZED)))
            (IFn'''invoke-3 RT'PR_ON, x, w) ;; call multimethod
            (let [#_"boolean" readably (RT'booleanCast-1o (IDeref'''deref RT'PRINT_READABLY))]
                (cond (nil? x)
                    (do
                        (.write w, "nil")
                    )
                    (or (§ instance? ISeq x) (§ instance? IPersistentList x))
                    (do
                        (.write w, \()
                        (RT'printInnerSeq (RT'seq x), w)
                        (.write w, \))
                    )
                    (instance? String x)
                        (let [#_"String" s (cast String x)]
                            (when readably => (.write w, s)
                                (.write w, \") ;; oops! "
                                (dotimes [#_"int" i (.length s)]
                                    (let [#_"char" c (.charAt s, i)]
                                        (case c
                                            \newline   (.write w, "\\n")
                                            \tab       (.write w, "\\t")
                                            \"         (.write w, "\\\"")
                                            \\         (.write w, "\\\\")
                                            \return    (.write w, "\\r")
                                            \formfeed  (.write w, "\\f")
                                            \backspace (.write w, "\\b")
                                                       (.write w, c)
                                        )
                                    )
                                )
                                (.write w, \") ;; oops! "
                            )
                        )
                    (§ instance? IPersistentMap x)
                    (do
                        (.write w, \{)
                        (loop-when-recur [#_"ISeq" s (RT'seq x)] (some? s) [(.next s)]
                            (let [#_"IMapEntry" e (cast' IMapEntry (.first s))]
                                (RT'print (IMapEntry'''key e), w)
                                (.write w, \space)
                                (RT'print (IMapEntry'''val e), w)
                                (when (some? (.next s))
                                    (.write w, ", ")
                                )
                            )
                        )
                        (.write w, \})
                    )
                    (§ instance? IPersistentVector x)
                        (let [#_"IPersistentVector" a (cast' IPersistentVector x)]
                            (.write w, \[)
                            (dotimes [#_"int" i (.count a)]
                                (RT'print (Indexed'''nth-2 a, i), w)
                                (when (< i (dec (.count a)))
                                    (.write w, \space)
                                )
                            )
                            (.write w, \])
                        )
                    (§ instance? IPersistentSet x)
                    (do
                        (.write w, "#{")
                        (loop-when-recur [#_"ISeq" s (RT'seq x)] (some? s) [(.next s)]
                            (RT'print (.first s), w)
                            (when (some? (.next s))
                                (.write w, \space)
                            )
                        )
                        (.write w, \})
                    )
                    (instance? Character x)
                        (let [#_"char" c (.charValue (cast Character x))]
                            (when readably => (.write w, c)
                                (.write w, \\)
                                (case c
                                    \newline   (.write w, "newline")
                                    \tab       (.write w, "tab")
                                    \space     (.write w, "space")
                                    \return    (.write w, "return")
                                    \formfeed  (.write w, "formfeed")
                                    \backspace (.write w, "backspace")
                                               (.write w, c)
                                )
                            )
                        )
                    (instance? Class x)
                    (do
                        (.write w, "#=")
                        (.write w, (.getName (cast Class x)))
                    )
                    (and (instance? BigDecimal x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, \M)
                    )
                    (and (§ instance? BigInt x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, \N)
                    )
                    (and (instance? BigInteger x) readably)
                    (do
                        (.write w, (.toString x))
                        (.write w, "BIGINT")
                    )
                    (§ instance? Var x)
                        (let [#_"Var" v (cast' Var x)]
                            (.write w, (str "#=(var " (:name (:ns v)) "/" (:sym v) ")"))
                        )
                    (instance? Pattern x)
                        (let [#_"Pattern" p (cast Pattern x)]
                            (.write w, (str "#\"" (.pattern p) "\""))
                        )
                    :else
                    (do
                        (.write w, (.toString x))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" RT'printInnerSeq [#_"ISeq" x, #_"Writer" w] #_(§ throws IOException)
        (loop-when-recur [#_"ISeq" s x] (some? s) [(.next s)]
            (RT'print (.first s), w)
            (when (some? (.next s))
                (.write w, \space)
            )
        )
        nil
    )

    (defn #_"ClassLoader" RT'makeClassLoader []
        (cast ClassLoader
            (§ unsure AccessController/doPrivileged
                (§ reify PrivilegedAction()
                    #_foreign
                    (§ defn #_"Object" run [#_"PrivilegedAction" _this]
                        (DynamicClassLoader'new (RT'baseLoader))
                    )
                )
            )
        )
    )

    (defn #_"ClassLoader" RT'baseLoader []
        (if (Var''isBound Compiler'LOADER)
            (cast ClassLoader (IDeref'''deref Compiler'LOADER))
            (.getContextClassLoader (Thread/currentThread))
        )
    )

    (defn #_"InputStream" RT'resourceAsStream [#_"ClassLoader" loader, #_"String" name]
        (if (nil? loader)
            (ClassLoader/getSystemResourceAsStream name)
            (.getResourceAsStream loader, name)
        )
    )

    (defn #_"URL" RT'getResource [#_"ClassLoader" loader, #_"String" name]
        (if (nil? loader)
            (ClassLoader/getSystemResource name)
            (.getResource loader, name)
        )
    )

    (defn #_"Class" RT'classForName-3 [#_"String" name, #_"boolean" load, #_"ClassLoader" loader]
        (try
            (let [#_"Class" c
                    (when-not (§ instance? DynamicClassLoader loader)
                        (DynamicClassLoader'findInMemoryClass name)
                    )]
                (or c (Class/forName name, load, loader))
            )
            (catch ClassNotFoundException e
                (throw (Util'sneakyThrow e))
            )
        )
    )

    (defn #_"Class" RT'classForName-1 [#_"String" name]
        (RT'classForName-3 name, true, (RT'baseLoader))
    )

    (defn #_"Class" RT'classForNameNonLoading [#_"String" name]
        (RT'classForName-3 name, false, (RT'baseLoader))
    )

    (defn #_"Class" RT'loadClassForName [#_"String" name]
        (try
            (RT'classForNameNonLoading name)
            (catch ClassNotFoundException _
                (§ return nil)
            )
            (catch Exception e
                (throw (Util'sneakyThrow e))
            )
        )
        (RT'classForName-1 name)
    )

    (defn #_"boolean" RT'aget_boolean [#_"boolean[]" a, #_"int" i] (aget a i))
    (defn #_"byte"    RT'aget_byte    [#_"byte[]"    a, #_"int" i] (aget a i))
    (defn #_"short"   RT'aget_short   [#_"short[]"   a, #_"int" i] (aget a i))
    (defn #_"char"    RT'aget_char    [#_"char[]"    a, #_"int" i] (aget a i))
    (defn #_"int"     RT'aget_int     [#_"int[]"     a, #_"int" i] (aget a i))
    (defn #_"long"    RT'aget_long    [#_"long[]"    a, #_"int" i] (aget a i))
    (defn #_"float"   RT'aget_float   [#_"float[]"   a, #_"int" i] (aget a i))
    (defn #_"double"  RT'aget_double  [#_"double[]"  a, #_"int" i] (aget a i))
    (defn #_"Object"  RT'aget_object  [#_"Object[]"  a, #_"int" i] (aget a i))

    (defn #_"boolean" RT'aset_boolean [#_"boolean[]" a, #_"int" i, #_"boolean" v] (aset a i v) v)
    (defn #_"byte"    RT'aset_byte    [#_"byte[]"    a, #_"int" i, #_"byte"    v] (aset a i v) v)
    (defn #_"short"   RT'aset_short   [#_"short[]"   a, #_"int" i, #_"short"   v] (aset a i v) v)
    (defn #_"char"    RT'aset_char    [#_"char[]"    a, #_"int" i, #_"char"    v] (aset a i v) v)
    (defn #_"int"     RT'aset_int     [#_"int[]"     a, #_"int" i, #_"int"     v] (aset a i v) v)
    (defn #_"long"    RT'aset_long    [#_"long[]"    a, #_"int" i, #_"long"    v] (aset a i v) v)
    (defn #_"float"   RT'aset_float   [#_"float[]"   a, #_"int" i, #_"float"   v] (aset a i v) v)
    (defn #_"double"  RT'aset_double  [#_"double[]"  a, #_"int" i, #_"double"  v] (aset a i v) v)
    (defn #_"Object"  RT'aset_object  [#_"Object[]"  a, #_"int" i, #_"Object"  v] (aset a i v) v)

    (defn #_"int" RT'alength_boolean [#_"boolean[]" a] (alength a))
    (defn #_"int" RT'alength_byte    [#_"byte[]"    a] (alength a))
    (defn #_"int" RT'alength_short   [#_"short[]"   a] (alength a))
    (defn #_"int" RT'alength_char    [#_"char[]"    a] (alength a))
    (defn #_"int" RT'alength_int     [#_"int[]"     a] (alength a))
    (defn #_"int" RT'alength_long    [#_"long[]"    a] (alength a))
    (defn #_"int" RT'alength_float   [#_"float[]"   a] (alength a))
    (defn #_"int" RT'alength_double  [#_"double[]"  a] (alength a))
    (defn #_"int" RT'alength_object  [#_"Object[]"  a] (alength a))

    (defn #_"boolean[]" RT'aclone_boolean [#_"boolean[]" a] (.clone a))
    (defn #_"byte[]"    RT'aclone_byte    [#_"byte[]"    a] (.clone a))
    (defn #_"short[]"   RT'aclone_short   [#_"short[]"   a] (.clone a))
    (defn #_"char[]"    RT'aclone_char    [#_"char[]"    a] (.clone a))
    (defn #_"int[]"     RT'aclone_int     [#_"int[]"     a] (.clone a))
    (defn #_"long[]"    RT'aclone_long    [#_"long[]"    a] (.clone a))
    (defn #_"float[]"   RT'aclone_float   [#_"float[]"   a] (.clone a))
    (defn #_"double[]"  RT'aclone_double  [#_"double[]"  a] (.clone a))
    (defn #_"Object[]"  RT'aclone_object  [#_"Object[]"  a] (.clone a))
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (def #_"Object" SeqIterator'START (Object.))

    (defn- #_"SeqIterator" SeqIterator'init []
        (hash-map
            #_"Object" :seq nil
            #_"Object" :next nil
        )
    )

    (defn #_"SeqIterator" SeqIterator'new [#_"Object" o]
        (let [this (SeqIterator'init)]
            (§ ass this (assoc this :seq SeqIterator'START))
            (§ ass this (assoc this :next o))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"SeqIterator" this]
        (cond (= (:seq this) SeqIterator'START)
            (do
                (§ ass this (assoc this :seq nil))
                (§ ass this (assoc this :next (RT'seq (:next this))))
            )
            (= (:seq this) (:next this))
            (do
                (§ ass this (assoc this :next (RT'next (:seq this))))
            )
        )
        (some? (:next this))
    )

    #_foreign
    (§ defn #_"Object" next [#_"SeqIterator" this] #_(§ throws NoSuchElementException)
        (when (not (.hasNext this))
            (throw (NoSuchElementException.))
        )
        (§ ass this (assoc this :seq (:next this)))
        (RT'first (:next this))
    )

    #_foreign
    (§ defn #_"void" remove [#_"SeqIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (defn #_"StringSeq" StringSeq'create [#_"CharSequence" s]
        (when (pos? (.length s))
            (StringSeq'new nil, s, 0)
        )
    )

    (defn- #_"StringSeq" StringSeq'init []
        (hash-map
            #_"CharSequence" :s nil
            #_"int" :i 0
        )
    )

    (defn #_"StringSeq" StringSeq'new [#_"IPersistentMap" meta, #_"CharSequence" s, #_"int" i]
        (let [this (merge (ASeq'new-1 meta) (StringSeq'init))]
            (§ ass this (assoc this :s s))
            (§ ass this (assoc this :i i))
            this
        )
    )

    #_override
    (defn #_"Obj" IObj'''withMeta--StringSeq [#_"StringSeq" this, #_"IPersistentMap" meta]
        (if (= meta (IMeta'''meta this))
            this
            (StringSeq'new meta, (:s this), (:i this))
        )
    )

    #_override
    (defn #_"Object" ISeq'''first--StringSeq [#_"StringSeq" this]
        (Character/valueOf (.charAt (:s this), (:i this)))
    )

    #_override
    (defn #_"ISeq" ISeq'''next--StringSeq [#_"StringSeq" this]
        (when (< (inc (:i this)) (.length (:s this)))
            (StringSeq'new (:_meta this), (:s this), (inc (:i this)))
        )
    )

    #_override
    (defn #_"int" IndexedSeq'''index--StringSeq [#_"StringSeq" this]
        (:i this)
    )

    #_override
    (defn #_"int" Counted'''count--StringSeq [#_"StringSeq" this]
        (- (.length (:s this)) (:i this))
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (defn #_"Symbol" Symbol'create-2 [#_"String" ns, #_"String" name]
        (Symbol'intern ns, name)
    )

    (defn #_"Symbol" Symbol'create-1 [#_"String" nsname]
        (Symbol'intern nsname)
    )

    (defn #_"Symbol" Symbol'intern
        ([#_"String" nsname]
            (let [#_"int" i (.indexOf nsname, \/)]
                (if (or (= i -1) (= nsname "/"))
                    (Symbol'new-2 nil, nsname)
                    (Symbol'new-2 (.substring nsname, 0, i), (.substring nsname, (inc i)))
                )
            )
        )
        ([#_"String" ns, #_"String" name]
            (Symbol'new-2 ns, name)
        )
    )

    (defn- #_"Symbol" Symbol'init []
        (hash-map
            #_"String" :ns nil
            #_"String" :name nil
            #_"int" :_hasheq 0
            #_"IPersistentMap" :_meta nil
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Symbol" Symbol'new-2 [#_"String" ns_interned, #_"String" name_interned]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass this (assoc this :name name_interned))
            (§ ass this (assoc this :ns ns_interned))
            (§ ass this (assoc this :_meta nil))
            this
        )
    )

    #_foreign
    (§ defn #_"String" toString [#_"Symbol" this]
        (when (nil? (:_str this))
            (§ ass this (assoc this :_str (if (some? (:ns this)) (str (:ns this) "/" (:name this)) (:name this))))
        )
        (:_str this)
    )

    #_override
    (defn #_"String" Named'''getNamespace--Symbol [#_"Symbol" this]
        (:ns this)
    )

    #_override
    (defn #_"String" Named'''getName--Symbol [#_"Symbol" this]
        (:name this)
    )

    #_foreign
    (§ defn #_"boolean" equals [#_"Symbol" this, #_"Object" o]
        (cond
            (= this o)
                true
            (§ instance? Symbol o)
                (let [#_"Symbol" symbol (cast' Symbol o)]
                    (and (Util'equals (:ns this), (:ns symbol)) (.equals (:name this), (:name symbol)))
                )
            :else
                false
        )
    )

    #_foreign
    (§ defn #_"int" hashCode [#_"Symbol" this]
        (Util'hashCombine (.hashCode (:name this)), (Util'hash (:ns this)))
    )

    #_override
    (defn #_"int" IHashEq'''hasheq--Symbol [#_"Symbol" this]
        (when (zero? (:_hasheq this))
            (§ ass this (assoc this :_hasheq (Util'hashCombine (Murmur3'hashUnencodedChars (:name this)), (Util'hash (:ns this)))))
        )
        (:_hasheq this)
    )

    #_override
    (defn #_"IObj" IObj'''withMeta--Symbol [#_"Symbol" this, #_"IPersistentMap" meta]
        (Symbol'new-3 meta, (:ns this), (:name this))
    )

    (defn- #_"Symbol" Symbol'new-3 [#_"IPersistentMap" meta, #_"String" ns, #_"String" name]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass this (assoc this :name name))
            (§ ass this (assoc this :ns ns))
            (§ ass this (assoc this :_meta meta))
            this
        )
    )

    #_foreign
    (§ defn #_"int" compareTo [#_"Symbol" this, #_"Object" o]
        (let [#_"Symbol" s (cast' Symbol o)]
            (cond
                (.equals this, o)                       0
                (and (nil? (:ns this)) (some? (:ns s))) -1
                (nil? (:ns this))                       (.compareTo (:name this), (:name s))
                (nil? (:ns s))                          1
                :else
                    (let-when [#_"int" nsc (.compareTo (:ns this), (:ns s))] (zero? nsc) => nsc
                        (.compareTo (:name this), (:name s))
                    )
            )
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--Symbol [#_"Symbol" this, #_"Object" obj]
        (RT'get-2 obj, this)
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--Symbol [#_"Symbol" this, #_"Object" obj, #_"Object" notFound]
        (RT'get-3 obj, this, notFound)
    )

    #_override
    (defn #_"IPersistentMap" IMeta'''meta--Symbol [#_"Symbol" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (defn- #_"TransactionalHashMap" TransactionalHashMap'init []
        (hash-map
            #_"Ref[]" :bins nil
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-0 []
        (TransactionalHashMap'new-1i 421)
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1i [#_"int" nBins]
        (let [this (merge (§ foreign AbstractMap'new) (TransactionalHashMap'init))]
            (§ ass this (assoc this :bins (make-array #_"Ref" Object nBins)))
            (loop-when-recur [#_"int" i 0] (< i nBins) [(inc i)]
                (aset (:bins this) i (Ref'new-1 PersistentHashMap'EMPTY))
            )
            this
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1m [#_"Map<? extends K, ? extends V>" m]
        (let [this (TransactionalHashMap'new-1i (.size m))]
            (.putAll this, m)
            this
        )
    )

    #_method
    (defn #_"IPersistentMap" TransactionalHashMap''mapAt [#_"TransactionalHashMap" this, #_"int" bin]
        (cast' IPersistentMap (IDeref'''deref (aget (:bins this) bin)))
    )

    #_method
    (defn #_"int" TransactionalHashMap''binFor [#_"TransactionalHashMap" this, #_"Object" k]
        ;; spread hashes, a la Cliff Click
        (let [#_"int" h (.hashCode k)]
            (§ ass h (bit-xor h (bit-xor (>>> h 20) (>>> h 12))))
            (§ ass h (bit-xor h (bit-xor (>>> h 7) (>>> h 4))))
            (% h (alength (:bins this)))
        )
    )

    #_foreign
    (§ defn #_"Map$Entry" entryAt [#_"TransactionalHashMap" this, #_"Object" k]
        (Associative'''entryAt (TransactionalHashMap''mapAt this, (TransactionalHashMap''binFor this, k)), k)
    )

    #_foreign
    (§ defn #_"int" size [#_"TransactionalHashMap" this]
        (let [#_"int" n 0]
            (loop-when-recur [#_"int" i 0] (< i (alength (:bins this))) [(inc i)]
                (§ ass n (+ n (.count (TransactionalHashMap''mapAt this, i))))
            )
            n
        )
    )

    #_foreign
    (§ defn #_"boolean" isEmpty [#_"TransactionalHashMap" this]
        (zero? (.size this))
    )

    #_foreign
    (§ defn #_"boolean" containsKey [#_"TransactionalHashMap" this, #_"Object" k]
        (some? (.entryAt this, k))
    )

    #_foreign
    (§ defn #_"V" get [#_"TransactionalHashMap" this, #_"Object" k]
        (when-let [#_"Map$Entry" e (.entryAt this, k)]
            (cast' V (.getValue e))
        )
    )

    #_foreign
    (§ defn #_"V" put [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (aget (:bins this) (TransactionalHashMap''binFor this, k))
              #_"IPersistentMap" m (cast' IPersistentMap (IDeref'''deref r))
              #_"Object" ret (ILookup'''valAt-2 m, k)]
            (Ref''set r, (IPersistentMap'''assoc m, k, v))
            (cast' V ret)
        )
    )

    #_foreign
    (§ defn #_"V" remove [#_"TransactionalHashMap" this, #_"Object" k]
        (let [#_"Ref" r (aget (:bins this) (TransactionalHashMap''binFor this, k))
              #_"IPersistentMap" m (cast' IPersistentMap (IDeref'''deref r))
              #_"Object" ret (ILookup'''valAt-2 m, k)]
            (Ref''set r, (IPersistentMap'''without m, k))
            (cast' V ret)
        )
    )

    #_foreign
    (§ defn #_"void" putAll [#_"TransactionalHashMap" this, #_"Map<? extends K, ? extends V>" m]
        (loop-when-recur [#_"Iterator" i (.iterator (.entrySet m))] (.hasNext i) [i]
            (let [#_"Map$Entry<K, V>" e (cast Map$Entry (.next i))]
                (.put this, (.getKey e), (.getValue e))
            )
        )
        nil
    )

    #_foreign
    (§ defn #_"void" clear [#_"TransactionalHashMap" this]
        (dotimes [#_"int" i (alength (:bins this))]
            (let [#_"Ref" r (aget (:bins this) i)
                  #_"IPersistentMap" m (cast' IPersistentMap (IDeref'''deref r))]
                (when (pos? (.count m))
                    (Ref''set r, PersistentHashMap'EMPTY)
                )
            )
        )
        nil
    )

    #_foreign
    (§ defn #_"Set<Map$Entry<K, V>>" entrySet [#_"TransactionalHashMap" this]
        (let [#_"ArrayList<Map$Entry<K, V>>" entries (ArrayList. (alength (:bins this)))]
            (dotimes [#_"int" i (alength (:bins this))]
                (let [#_"IPersistentMap" m (TransactionalHashMap''mapAt this, i)]
                    (when (pos? (.count m))
                        (.addAll entries, (cast Collection (RT'seq m)))
                    )
                )
            )
            (§ reify AbstractSet<Map$Entry<K, V>>()
                #_foreign
                (§ defn #_"Iterator" iterator [#_"AbstractSet<Map$Entry<K, V>>" this]
                    (.iterator (Collections/unmodifiableList entries))
                )

                #_foreign
                (§ defn #_"int" size [#_"AbstractSet<Map$Entry<K, V>>" this]
                    (.size entries)
                )
            )
        )
    )

    #_foreign
    (§ defn #_"V" putIfAbsent [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (aget (:bins this) (TransactionalHashMap''binFor this, k)) #_"IPersistentMap" m (cast' IPersistentMap (IDeref'''deref r))]
            (let-when [#_"Map$Entry" e (Associative'''entryAt m, k)] (nil? e) => (cast' V (.getValue e))
                (Ref''set r, (IPersistentMap'''assoc m, k, v))
                nil
            )
        )
    )

    #_foreign
    (§ defn #_"boolean" remove [#_"TransactionalHashMap" this, #_"Object" k, #_"Object" v]
        (let [#_"Ref" r (aget (:bins this) (TransactionalHashMap''binFor this, k)) #_"IPersistentMap" m (cast' IPersistentMap (IDeref'''deref r))]
            (let-when [#_"Map$Entry" e (Associative'''entryAt m, k)] (and (some? e) (.equals (.getValue e), v)) => false
                (Ref''set r, (IPersistentMap'''without m, k))
                true
            )
        )
    )

    #_foreign
    (§ defn #_"boolean" replace [#_"TransactionalHashMap" this, #_"K" k, #_"V" oldv, #_"V" newv]
        (let [#_"Ref" r (aget (:bins this) (TransactionalHashMap''binFor this, k)) #_"IPersistentMap" m (cast' IPersistentMap (IDeref'''deref r))]
            (let-when [#_"Map$Entry" e (Associative'''entryAt m, k)] (and (some? e) (.equals (.getValue e), oldv)) => false
                (Ref''set r, (IPersistentMap'''assoc m, k, newv))
                true
            )
        )
    )

    #_foreign
    (§ defn #_"V" replace [#_"TransactionalHashMap" this, #_"K" k, #_"V" v]
        (let [#_"Ref" r (aget (:bins this) (TransactionalHashMap''binFor this, k)) #_"IPersistentMap" m (cast' IPersistentMap (IDeref'''deref r))]
            (when-let [#_"Map$Entry" e (Associative'''entryAt m, k)]
                (Ref''set r, (IPersistentMap'''assoc m, k, v))
                (cast' V (.getValue e))
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

#_private
(class-ns EmptyBuffer (§ implements Buffer)
    (defn #_"EmptyBuffer" EmptyBuffer'new []
        (hash-map)
    )

    #_override
    (defn #_"Buffer" Buffer'''add--EmptyBuffer [#_"EmptyBuffer" this, #_"Object" o]
        (SingleBuffer'new o)
    )

    #_override
    (defn #_"Object" Buffer'''remove--EmptyBuffer [#_"EmptyBuffer" this]
        (throw (IllegalStateException. "Removing object from empty buffer"))
    )

    #_override
    (defn #_"boolean" Buffer'''isEmpty--EmptyBuffer [#_"EmptyBuffer" this]
        true
    )

    #_foreign
    (§ defn #_"String" toString [#_"EmptyBuffer" this]
        "EmptyBuffer"
    )
)

#_private
(class-ns SingleBuffer (§ implements Buffer)
    (defn- #_"SingleBuffer" SingleBuffer'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"SingleBuffer" SingleBuffer'new [#_"Object" o]
        (let [this (SingleBuffer'init)]
            (§ ass this (assoc this :val o))
            this
        )
    )

    #_override
    (defn #_"Buffer" Buffer'''add--SingleBuffer [#_"SingleBuffer" this, #_"Object" o]
        (if (= (:val this) TransformerIterator'NONE)
            (assoc this :val o)
            (ManyBuffer'new (:val this), o)
        )
    )

    #_override
    (defn #_"Object" Buffer'''remove--SingleBuffer [#_"SingleBuffer" this]
        (when (= (:val this) TransformerIterator'NONE)
            (throw (IllegalStateException. "Removing object from empty buffer"))
        )
        (let [#_"Object" ret (:val this)]
            (§ ass this (assoc this :val TransformerIterator'NONE))
            ret
        )
    )

    #_override
    (defn #_"boolean" Buffer'''isEmpty--SingleBuffer [#_"SingleBuffer" this]
        (= (:val this) TransformerIterator'NONE)
    )

    #_foreign
    (§ defn #_"String" toString [#_"SingleBuffer" this]
        (str "SingleBuffer: " (:val this))
    )
)

#_private
(class-ns ManyBuffer (§ implements Buffer)
    (defn- #_"ManyBuffer" ManyBuffer'init []
        (hash-map
            #_"Queue" :vals (LinkedList.)
        )
    )

    (defn #_"ManyBuffer" ManyBuffer'new [#_"Object" o1, #_"Object" o2]
        (let [this (ManyBuffer'init)]
            (.add (:vals this), o1)
            (.add (:vals this), o2)
            this
        )
    )

    #_override
    (defn #_"Buffer" Buffer'''add--ManyBuffer [#_"ManyBuffer" this, #_"Object" o]
        (.add (:vals this), o)
        this
    )

    #_override
    (defn #_"Object" Buffer'''remove--ManyBuffer [#_"ManyBuffer" this]
        (.remove (:vals this))
    )

    #_override
    (defn #_"boolean" Buffer'''isEmpty--ManyBuffer [#_"ManyBuffer" this]
        (.isEmpty (:vals this))
    )

    #_foreign
    (§ defn #_"String" toString [#_"ManyBuffer" this]
        (str "ManyBuffer: " (:vals this))
    )
)

#_private
(class-ns MultiIterator (§ implements Iterator)
    (defn- #_"MultiIterator" MultiIterator'init []
        (hash-map
            #_"Iterator[]" :iters nil
        )
    )

    (defn #_"MultiIterator" MultiIterator'new [#_"Iterator[]" iters]
        (let [this (MultiIterator'init)]
            (§ ass this (assoc this :iters iters))
            this
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"MultiIterator" this]
        (let [#_"Iterator[]" iters (:iters this)]
            (loop-when [#_"int" i 0] (< i (alength iters)) => true
                (and (.hasNext (aget iters i)) (recur (inc i)))
            )
        )
    )

    #_foreign
    (§ defn #_"Object" next [#_"MultiIterator" this]
        (let [#_"Iterator[]" iters (:iters this)
              #_"Object[]" nexts (make-array Object (alength iters))]
            (dotimes [#_"int" i (alength iters)]
                (aset nexts i (.next (aget iters i)))
            )
            (ArraySeq'new-2 nexts, 0)
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"MultiIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransformerIterator (§ implements Iterator)
    (def- #_"Buffer" TransformerIterator'EMPTY (EmptyBuffer'new))
    (def- #_"Object" TransformerIterator'NONE (Object.))

    (defn- #_"TransformerIterator" TransformerIterator'init []
        (hash-map
            ;; Source
            #_"Iterator" :sourceIter nil
            #_"IFn" :xf nil
            #_"boolean" :multi false

            ;; Iteration state
            #_volatile
            #_"Buffer" :buffer TransformerIterator'EMPTY
            #_volatile
            #_"Object" :next TransformerIterator'NONE
            #_volatile
            #_"boolean" :completed false
        )
    )

    (defn- #_"TransformerIterator" TransformerIterator'new [#_"IFn" xform, #_"Iterator" sourceIter, #_"boolean" multi]
        (let [this (TransformerIterator'init)]
            (§ ass this (assoc this :sourceIter sourceIter))
            (§ ass this (assoc this :xf (cast' IFn (IFn'''invoke-2 xform,
                (§ reify AFn()
                    #_override
                    (defn #_"Object" IFn'''invoke-1--AFn [#_"AFn" this]
                        nil
                    )

                    #_override
                    (defn #_"Object" IFn'''invoke-2--AFn [#_"AFn" this, #_"Object" acc]
                        acc
                    )

                    #_override
                    (defn #_"Object" IFn'''invoke-3--AFn [#_"AFn" this, #_"Object" acc, #_"Object" o]
                        (§ ass this (assoc this :buffer (Buffer'''add (:buffer this), o)))
                        acc
                    )
                )
            ))))
            (§ ass this (assoc this :multi multi))
            this
        )
    )

    (defn #_"Iterator" TransformerIterator'create [#_"IFn" xform, #_"Iterator" source]
        (TransformerIterator'new xform, source, false)
    )

    (defn #_"Iterator" TransformerIterator'createMulti [#_"IFn" xform, #_"List" sources]
        (let [#_"Iterator[]" iters (make-array Iterator (.size sources))]
            (dotimes [#_"int" i (.size sources)]
                (aset iters i (cast Iterator (.get sources, i)))
            )
            (TransformerIterator'new xform, (MultiIterator'new iters), true)
        )
    )

    #_method
    (defn- #_"boolean" TransformerIterator''step [#_"TransformerIterator" this]
        (loop []
            (cond
                (not (= (:next this) TransformerIterator'NONE))
                    true
                (not (Buffer'''isEmpty (:buffer this)))
                    (do
                        (§ ass this (assoc this :next (Buffer'''remove (:buffer this))))
                        (recur)
                    )
                (:completed this)
                    false
                (.hasNext (:sourceIter this))
                    (let [#_"Object" it
                            (if (:multi this)
                                (IFn'''applyTo (:xf this), (RT'cons nil, (.next (:sourceIter this))))
                                (IFn'''invoke-3 (:xf this), nil, (.next (:sourceIter this)))
                            )]
                        (when (RT'isReduced it)
                            (IFn'''invoke-2 (:xf this), nil)
                            (§ ass this (assoc this :completed true))
                        )
                        (recur)
                    )
                :else
                    (do
                        (IFn'''invoke-2 (:xf this), nil)
                        (§ ass this (assoc this :completed true))
                        (recur)
                    )
            )
        )
    )

    #_foreign
    (§ defn #_"boolean" hasNext [#_"TransformerIterator" this]
        (TransformerIterator''step this)
    )

    #_foreign
    (§ defn #_"Object" next [#_"TransformerIterator" this]
        (when (.hasNext this) => (throw (NoSuchElementException.))
            (let [#_"Object" ret (:next this)]
                (§ ass this (assoc this :next TransformerIterator'NONE))
                ret
            )
        )
    )

    #_foreign
    (§ defn #_"void" remove [#_"TransformerIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Tuple

#_stateless
(class-ns Tuple
    (def #_"int" Tuple'MAX_SIZE 6)

    (defn #_"IPersistentVector" Tuple'create
        ([] PersistentVector'EMPTY)
        ([#_"Object" v0] (RT'vector v0))
        ([#_"Object" v0, #_"Object" v1] (RT'vector v0, v1))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2] (RT'vector v0, v1, v2))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3] (RT'vector v0, v1, v2, v3))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4] (RT'vector v0, v1, v2, v3, v4))
        ([#_"Object" v0, #_"Object" v1, #_"Object" v2, #_"Object" v3, #_"Object" v4, #_"Object" v5] (RT'vector v0, v1, v2, v3, v4, v5))
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

#_stateless
(class-ns Util
    (defn #_"boolean" Util'equiv-2oo [#_"Object" k1, #_"Object" k2]
        (cond
            (= k1 k2) true
            (nil? k1) false
            (and (instance? Number k1) (instance? Number k2)) (Numbers'equal (cast Number k1), (cast Number k2))
            (or (§ instance? IPersistentCollection k1) (§ instance? IPersistentCollection k2)) (Util'pcequiv k1, k2)
            :else (.equals k1, k2)
        )
    )

    (def #_"EquivPred" Util'equivNull
        (§ reify EquivPred()
            #_override
            (defn #_"boolean" EquivPred'''equiv--EquivPred [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (nil? k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivEquals
        (§ reify EquivPred()
            #_override
            (defn #_"boolean" EquivPred'''equiv--EquivPred [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (.equals k1, k2)
            )
        )
    )

    (def #_"EquivPred" Util'equivNumber
        (§ reify EquivPred()
            #_override
            (defn #_"boolean" EquivPred'''equiv--EquivPred [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (and (instance? Number k2) (Numbers'equal (cast Number k1), (cast Number k2)))
            )
        )
    )

    (def #_"EquivPred" Util'equivColl
        (§ reify EquivPred()
            #_override
            (defn #_"boolean" EquivPred'''equiv--EquivPred [#_"EquivPred" this, #_"Object" k1, #_"Object" k2]
                (if (or (§ instance? IPersistentCollection k1) (§ instance? IPersistentCollection k2)) (Util'pcequiv k1, k2) (.equals k1, k2))
            )
        )
    )

    (defn #_"EquivPred" Util'equivPred [#_"Object" k1]
        (cond
            (nil? k1)                                          Util'equivNull
            (instance? Number k1)                              Util'equivNumber
            (or (instance? String k1) (§ instance? Symbol k1)) Util'equivEquals
            (or (instance? Collection k1) (instance? Map k1))  Util'equivColl
            :else                                              Util'equivEquals
        )
    )

    (defn #_"boolean" Util'equiv-2ll [#_"long" k1, #_"long" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2ol [#_"Object" k1, #_"long" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2lo [#_"long" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2dd [#_"double" k1, #_"double" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2od [#_"Object" k1, #_"double" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2do [#_"double" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2bb [#_"boolean" k1, #_"boolean" k2]
        (= k1 k2)
    )

    (defn #_"boolean" Util'equiv-2ob [#_"Object" k1, #_"boolean" k2]
        (Util'equiv-2oo k1, (cast Object k2))
    )

    (defn #_"boolean" Util'equiv-2bo [#_"boolean" k1, #_"Object" k2]
        (Util'equiv-2oo (cast Object k1), k2)
    )

    (defn #_"boolean" Util'equiv-2cc [#_"char" c1, #_"char" c2]
        (= c1 c2)
    )

    (defn #_"boolean" Util'pcequiv [#_"Object" k1, #_"Object" k2]
        (if (§ instance? IPersistentCollection k1)
            (IPersistentCollection'''equiv (cast' IPersistentCollection k1), k2)
            (IPersistentCollection'''equiv (cast' IPersistentCollection k2), k1)
        )
    )

    (defn #_"boolean" Util'equals [#_"Object" k1, #_"Object" k2]
        (or (= k1 k2) (and (some? k1) (.equals k1, k2)))
    )

    (defn #_"boolean" Util'identical [#_"Object" k1, #_"Object" k2]
        (= k1 k2)
    )

    (defn #_"Class" Util'classOf [#_"Object" x]
        (when (some? x)
            (.getClass x)
        )
    )

    (defn #_"int" Util'compare [#_"Object" k1, #_"Object" k2]
        (cond
            (= k1 k2)             0
            (nil? k1)             -1
            (nil? k2)             1
            (instance? Number k1) (Numbers'compare (cast Number k1), (cast Number k2))
            :else                 (.compareTo (cast Comparable k1), k2)
        )
    )

    (defn #_"int" Util'hash [#_"Object" o]
        (cond
            (nil? o) 0
            :else    (.hashCode o)
        )
    )

    (defn #_"int" Util'hasheq [#_"Object" o]
        (cond
            (nil? o)                0
            (§ instance? IHashEq o) (IHashEq'''hasheq (cast' IHashEq o))
            (instance? Number o)    (Numbers'hasheq (cast Number o))
            (instance? String o)    (Murmur3'hashInt (.hashCode o))
            :else                   (.hashCode o)
        )
    )

    (defn #_"int" Util'hashCombine [#_"int" seed, #_"int" hash]
        ;; a la boost
        (bit-xor seed (+ hash 0x9e3779b9 (<< seed 6) (>> seed 2)))
    )

    (defn #_"boolean" Util'isPrimitive [#_"Class" c]
        (and (some? c) (.isPrimitive c) (not (= c Void/TYPE)))
    )

    (defn #_"boolean" Util'isInteger [#_"Object" x]
        (or (instance? Integer x) (instance? Long x) (§ instance? BigInt x) (instance? BigInteger x))
    )

    (defn #_"Object" Util'ret1 [#_"Object" ret, #_"Object" _nil]
        ret
    )

    (defn #_"<K, V> void" Util'clearCache [#_"ReferenceQueue" rq, #_"ConcurrentHashMap<K, Reference<V>>" cache]
        ;; cleanup any dead entries
        (when (some? (.poll rq))
            (while (some? (.poll rq))
            )
            (doseq [#_"Map$Entry<K, Reference<V>>" e (.entrySet cache)]
                (let-when [#_"Reference<V>" r (.getValue e)] (and (some? r) (nil? (.get r)))
                    (.remove cache, (.getKey e), r)
                )
            )
        )
        nil
    )

    (defn- #_"<T extends Throwable> void" Util'sneakyThrow0 [#_"Throwable" t] #_(§ throws T)
        (throw (cast' T t))
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (defn #_"RuntimeException" Util'sneakyThrow [#_"Throwable" t]
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (some? t) => (throw (NullPointerException.))
            (Util'sneakyThrow0 #_"<RuntimeException>" t)
        )
        nil
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns TBox
    (defn- #_"TBox" TBox'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_"Thread" :thread nil
        )
    )

    (defn #_"TBox" TBox'new [#_"Thread" t, #_"Object" val]
        (let [this (TBox'init)]
            (§ ass this (assoc this :thread t))
            (§ ass this (assoc this :val val))
            this
        )
    )
)

(class-ns Unbound (§ extends AFn)
    (defn- #_"Unbound" Unbound'init []
        (hash-map
            #_"Var" :v nil
        )
    )

    (defn #_"Unbound" Unbound'new [#_"Var" v]
        (let [this (merge (AFn'new) (Unbound'init))]
            (§ ass this (assoc this :v v))
            this
        )
    )

    #_foreign
    (§ defn #_"String" toString [#_"Unbound" this]
        (str "Unbound: " (:v this))
    )

    #_override
    (defn #_"Object" AFn'''throwArity--Unbound [#_"Unbound" this, #_"int" n]
        (throw (IllegalStateException. (str "Attempting to call unbound fn: " (:v this))))
    )
)

(class-ns Frame
    (§ def #_"Frame" Frame'TOP (Frame'new PersistentHashMap'EMPTY, nil))

    (defn- #_"Frame" Frame'init []
        (hash-map
            ;; Var->TBox
            #_"Associative" :bindings nil
            ;; Var->val
            #_"Frame" :prev nil
        )
    )

    (defn #_"Frame" Frame'new [#_"Associative" bindings, #_"Frame" prev]
        (let [this (Frame'init)]
            (§ ass this (assoc this :bindings bindings))
            (§ ass this (assoc this :prev prev))
            this
        )
    )
)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (def #_"ThreadLocal<Frame>" Var'dvals
        (§ reify ThreadLocal<Frame>()
            #_protected
            #_foreign
            (§ defn #_"Frame" initialValue [#_"ThreadLocal<Frame>" this]
                Frame'TOP
            )
        )
    )

    #_volatile
    (def #_"int" Var'rev 0)

    (§ def #_"Keyword" Var'privateKey (Keyword'intern (Symbol'intern nil, "private")))
    (§ def #_"IPersistentMap" Var'privateMeta (PersistentArrayMap'new-1 (object-array [ Var'privateKey, Boolean/TRUE ])))
    (§ def #_"Keyword" Var'macroKey (Keyword'intern (Symbol'intern nil, "macro")))
    (§ def #_"Keyword" Var'nameKey (Keyword'intern (Symbol'intern nil, "name")))
    (§ def #_"Keyword" Var'nsKey (Keyword'intern (Symbol'intern nil, "ns")))

    (defn #_"Object" Var'getThreadBindingFrame []
        (.get Var'dvals)
    )

    (defn #_"void" Var'resetThreadBindingFrame [#_"Object" frame]
        (.set Var'dvals, (cast' Frame frame))
        nil
    )

    (defn #_"Var" Var'intern
        ([#_"Namespace" ns, #_"Symbol" sym]
            (Namespace''intern ns, sym)
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
            (Var'intern ns, sym, root, true)
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root, #_"boolean" replaceRoot]
            (let [#_"Var" v (Namespace''intern ns, sym)]
                (when (or (not (Var''hasRoot v)) replaceRoot)
                    (Var''bindRoot v, root)
                )
                v
            )
        )
    )

    (defn #_"Var" Var'internPrivate [#_"String" nsName, #_"String" sym]
        (let [#_"Namespace" ns (Namespace'findOrCreate (Symbol'intern nsName)) #_"Var" v (Var'intern ns, (Symbol'intern sym))]
            (Var''setMeta v, Var'privateMeta)
            v
        )
    )

    (defn #_"Var" Var'find [#_"Symbol" nsQualifiedSym]
        (when (some? (:ns nsQualifiedSym)) => (throw (IllegalArgumentException. "Symbol must be namespace-qualified"))
            (let [#_"Namespace" ns (Namespace'find (Symbol'intern (:ns nsQualifiedSym)))]
                (when (some? ns) => (throw (IllegalArgumentException. (str "No such namespace: " (:ns nsQualifiedSym))))
                    (Namespace''findInternedVar ns, (Symbol'intern (:name nsQualifiedSym)))
                )
            )
        )
    )

    (defn #_"Var" Var'create
        ([               ] (Var'new nil, nil      ))
        ([#_"Object" root] (Var'new nil, nil, root))
    )

    (defn- #_"Var" Var'init []
        (hash-map
            #_"Namespace" :ns nil
            #_"Symbol" :sym nil
            #_volatile
            #_"Object" :root nil
            #_volatile
            #_"boolean" :dynamic false
            #_transient
            #_"AtomicBoolean" :threadBound nil
        )
    )

    (defn #_"Var" Var'new
        ([#_"Namespace" ns, #_"Symbol" sym]
            (let [this (merge (ARef'new-0) (Var'init))]
                (§ ass this (assoc this :ns ns))
                (§ ass this (assoc this :sym sym))
                (§ ass this (assoc this :threadBound (AtomicBoolean. false)))
                (§ ass this (assoc this :root (Unbound'new this)))
                (Var''setMeta this, PersistentHashMap'EMPTY)
                this
            )
        )
        ([#_"Namespace" ns, #_"Symbol" sym, #_"Object" root]
            (let [this (Var'new ns, sym)]
                (§ ass this (assoc this :root root))
                (§ ass Var'rev (inc Var'rev))
                this
            )
        )
    )

    #_method
    (defn #_"Var" Var''setDynamic [#_"Var" this]
        (assoc this :dynamic true)
    )

    #_method
    (defn #_"Var" Var''setDynamic [#_"Var" this, #_"boolean" b]
        (assoc this :dynamic b)
    )

    #_method
    (defn #_"boolean" Var''isDynamic [#_"Var" this]
        (:dynamic this)
    )

    #_foreign
    (§ defn #_"String" toString [#_"Var" this]
        (if (some? (:ns this))
            (str "#'" (:name (:ns this)) "/" (:sym this))
            (str "#<Var: " (or (:sym this) "--unnamed--") ">")
        )
    )

    #_method
    (defn #_"boolean" Var''isBound [#_"Var" this]
        (or (Var''hasRoot this) (and (.get (:threadBound this)) (Associative'''containsKey (:bindings (.get Var'dvals)), this)))
    )

    #_method
    (defn #_"Object" Var''get [#_"Var" this]
        (if (.get (:threadBound this)) (IDeref'''deref this) (:root this))
    )

    #_override
    (defn #_"Object" IDeref'''deref--Var [#_"Var" this]
        (let [#_"TBox" b (Var''getThreadBinding this)]
            (if (some? b) (:val b) (:root this))
        )
    )

    #_override
    (defn #_"void" IRef'''setValidator--Var [#_"Var" this, #_"IFn" vf]
        (when (Var''hasRoot this)
            (ARef''validate this, vf, (:root this))
        )
        (§ ass this (assoc this :validator vf))
        nil
    )

    #_method
    (defn #_"Object" Var''alter [#_"Var" this, #_"IFn" fn, #_"ISeq" args]
        (Var''set this, (IFn'''applyTo fn, (RT'cons (IDeref'''deref this), args)))
        this
    )

    #_method
    (defn #_"Object" Var''set [#_"Var" this, #_"Object" val]
        (ARef''validate this, (IRef'''getValidator this), val)
        (let [#_"TBox" b (Var''getThreadBinding this)]
            (when (some? b) => (throw (IllegalStateException. (str "Can't change/establish root binding of: " (:sym this) " with set")))
                (when (= (Thread/currentThread) (:thread b)) => (throw (IllegalStateException. (str "Can't set!: " (:sym this) " from non-binding thread")))
                    (§ ass b (assoc b :val val))
                    val
                )
            )
        )
    )

    #_override
    (defn #_"Object" Settable'''doSet--Var [#_"Var" this, #_"Object" val]
        (Var''set this, val)
    )

    #_override
    (defn #_"Object" Settable'''doReset--Var [#_"Var" this, #_"Object" val]
        (Var''bindRoot this, val)
        val
    )

    #_method
    (defn #_"void" Var''setMeta [#_"Var" this, #_"IPersistentMap" m]
        ;; ensure these basis keys
        (IReference'''resetMeta this, (-> m (IPersistentMap'''assoc Var'nameKey, (:sym this)) (IPersistentMap'''assoc Var'nsKey, (:ns this))))
        nil
    )

    #_method
    (defn #_"void" Var''setMacro [#_"Var" this]
        (IReference'''alterMeta this, Var'assoc, (RT'list-2 Var'macroKey, RT'T))
        nil
    )

    #_method
    (defn #_"boolean" Var''isMacro [#_"Var" this]
        (RT'booleanCast-1o (ILookup'''valAt-2 (IMeta'''meta this), Var'macroKey))
    )

    #_method
    (defn #_"boolean" Var''isPublic [#_"Var" this]
        (not (RT'booleanCast-1o (ILookup'''valAt-2 (IMeta'''meta this), Var'privateKey)))
    )

    #_method
    (defn #_"Object" Var''getRawRoot [#_"Var" this]
        (:root this)
    )

    #_method
    (defn #_"Object" Var''getTag [#_"Var" this]
        (ILookup'''valAt-2 (IMeta'''meta this), RT'TAG_KEY)
    )

    #_method
    (defn #_"void" Var''setTag [#_"Var" this, #_"Symbol" tag]
        (IReference'''alterMeta this, Var'assoc, (RT'list-2 RT'TAG_KEY, tag))
        nil
    )

    #_method
    (defn #_"boolean" Var''hasRoot [#_"Var" this]
        (not (§ instance? Unbound (:root this)))
    )

    ;; binding root always clears macro flag
    #_method
    (defn #_"void" Var''bindRoot [#_"Var" this, #_"Object" root]
        (§ sync this
            (ARef''validate this, (IRef'''getValidator this), root)
            (let [#_"Object" oldroot (:root this)]
                (§ ass this (assoc this :root root))
                (§ ass Var'rev (inc Var'rev))
                (IReference'''alterMeta this, Var'dissoc, (RT'list-1 Var'macroKey))
                (ARef''notifyWatches this, oldroot, (:root this))
            )
        )
        nil
    )

    #_method
    (defn #_"void" Var''swapRoot [#_"Var" this, #_"Object" root]
        (§ sync this
            (ARef''validate this, (IRef'''getValidator this), root)
            (let [#_"Object" oldroot (:root this)]
                (§ ass this (assoc this :root root))
                (§ ass Var'rev (inc Var'rev))
                (ARef''notifyWatches this, oldroot, root)
            )
        )
        nil
    )

    #_method
    (defn #_"void" Var''unbindRoot [#_"Var" this]
        (§ sync this
            (§ ass this (assoc this :root (Unbound'new this)))
            (§ ass Var'rev (inc Var'rev))
        )
        nil
    )

    #_method
    (defn #_"void" Var''commuteRoot [#_"Var" this, #_"IFn" fn]
        (§ sync this
            (let [#_"Object" newRoot (IFn'''invoke-2 fn, (:root this))]
                (ARef''validate this, (IRef'''getValidator this), newRoot)
                (let [#_"Object" oldroot (:root this)]
                    (§ ass this (assoc this :root newRoot))
                    (§ ass Var'rev (inc Var'rev))
                    (ARef''notifyWatches this, oldroot, newRoot)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"Object" Var''alterRoot [#_"Var" this, #_"IFn" fn, #_"ISeq" args]
        (§ sync this
            (let [#_"Object" newRoot (IFn'''applyTo fn, (RT'cons (:root this), args))]
                (ARef''validate this, (IRef'''getValidator this), newRoot)
                (let [#_"Object" oldroot (:root this)]
                    (§ ass this (assoc this :root newRoot))
                    (§ ass Var'rev (inc Var'rev))
                    (ARef''notifyWatches this, oldroot, newRoot)
                    newRoot
                )
            )
        )
    )

    (defn #_"void" Var'pushThreadBindings [#_"Associative" bindings]
        (let [#_"Frame" f (.get Var'dvals)]
            (loop-when [#_"Associative" m (:bindings f) #_"ISeq" s (Seqable'''seq bindings)] (some? s) => (.set Var'dvals, (Frame'new m, f))
                (let [#_"IMapEntry" e (cast' IMapEntry (.first s)) #_"Var" v (cast' Var (IMapEntry'''key e))]
                    (when-not (:dynamic v)
                        (throw (IllegalStateException. (str "Can't dynamically bind non-dynamic var: " (:ns v) "/" (:sym v))))
                    )
                    (ARef''validate v, (IRef'''getValidator v), (IMapEntry'''val e))
                    (.set (:threadBound v), true)
                    (recur (Associative'''assoc m, v, (TBox'new (Thread/currentThread), (IMapEntry'''val e))) (.next s))
                )
            )
        )
        nil
    )

    (defn #_"void" Var'popThreadBindings []
        (let [#_"Frame" f (:prev (.get Var'dvals))]
            (cond
                (nil? f)        (throw (IllegalStateException. "Pop without matching push"))
                (= f Frame'TOP) (.remove Var'dvals)
                :else           (.set Var'dvals, f)
            )
        )
        nil
    )

    (defn #_"Associative" Var'getThreadBindings []
        (let [#_"Frame" f (.get Var'dvals)]
            (loop-when [#_"IPersistentMap" m PersistentHashMap'EMPTY #_"ISeq" s (Seqable'''seq (:bindings f))] (some? s) => m
                (let [#_"IMapEntry" e (cast' IMapEntry (.first s)) #_"Var" v (cast' Var (IMapEntry'''key e)) #_"TBox" b (cast' TBox (IMapEntry'''val e))]
                    (recur (IPersistentMap'''assoc m, v, (:val b)) (.next s))
                )
            )
        )
    )

    #_method
    (defn #_"TBox" Var''getThreadBinding [#_"Var" this]
        (when (.get (:threadBound this))
            (when-let [#_"IMapEntry" e (Associative'''entryAt (:bindings (.get Var'dvals)), this)]
                (cast' TBox (IMapEntry'''val e))
            )
        )
    )

    #_method
    (defn #_"IFn" Var''fn [#_"Var" this]
        (cast' IFn (IDeref'''deref this))
    )

    #_foreign
    (§ defn #_"Object" call [#_"Var" this]
        (IFn'''invoke-1 this)
    )

    #_foreign
    (§ defn #_"void" run [#_"Var" this]
        (IFn'''invoke-1 this)
        nil
    )

    #_override
    (defn #_"Object" IFn'''invoke-1--Var [#_"Var" this]
        (IFn'''invoke-1 (Var''fn this))
    )

    #_override
    (defn #_"Object" IFn'''invoke-2--Var [#_"Var" this, #_"Object" arg1]
        (IFn'''invoke-2 (Var''fn this), (Util'ret1 arg1, (§ ass arg1 nil)))
    )

    #_override
    (defn #_"Object" IFn'''invoke-3--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2]
        (IFn'''invoke-3 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-4--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3]
        (IFn'''invoke-4 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-5--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4]
        (IFn'''invoke-5 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-6--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5]
        (IFn'''invoke-6 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-7--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6]
        (IFn'''invoke-7 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-8--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7]
        (IFn'''invoke-8 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-9--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8]
        (IFn'''invoke-9 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-10--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9]
        (IFn'''invoke-10 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-11--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10]
        (IFn'''invoke-11 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-12--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11]
        (IFn'''invoke-12 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-13--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12]
        (IFn'''invoke-13 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-14--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13]
        (IFn'''invoke-14 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-15--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14]
        (IFn'''invoke-15 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-16--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15]
        (IFn'''invoke-16 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-17--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16]
        (IFn'''invoke-17 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-18--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17]
        (IFn'''invoke-18 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil))
        )
    )

    #_override
    (defn #_"Object" IFn'''invoke-19--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18]
        (IFn'''invoke-19 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil))
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-20--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19]
        (IFn'''invoke-20 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil))
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-21--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20]
        (IFn'''invoke-21 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil)),
            (Util'ret1 arg20, (§ ass arg20 nil))
        )
    )

    #_override
  #_(defn #_"Object" IFn'''invoke-22--Var [#_"Var" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20 & #_"Object..." args]
        (IFn'''invoke-22 (Var''fn this),
            (Util'ret1 arg1, (§ ass arg1 nil)),
            (Util'ret1 arg2, (§ ass arg2 nil)),
            (Util'ret1 arg3, (§ ass arg3 nil)),
            (Util'ret1 arg4, (§ ass arg4 nil)),
            (Util'ret1 arg5, (§ ass arg5 nil)),
            (Util'ret1 arg6, (§ ass arg6 nil)),
            (Util'ret1 arg7, (§ ass arg7 nil)),
            (Util'ret1 arg8, (§ ass arg8 nil)),
            (Util'ret1 arg9, (§ ass arg9 nil)),
            (Util'ret1 arg10, (§ ass arg10 nil)),
            (Util'ret1 arg11, (§ ass arg11 nil)),
            (Util'ret1 arg12, (§ ass arg12 nil)),
            (Util'ret1 arg13, (§ ass arg13 nil)),
            (Util'ret1 arg14, (§ ass arg14 nil)),
            (Util'ret1 arg15, (§ ass arg15 nil)),
            (Util'ret1 arg16, (§ ass arg16 nil)),
            (Util'ret1 arg17, (§ ass arg17 nil)),
            (Util'ret1 arg18, (§ ass arg18 nil)),
            (Util'ret1 arg19, (§ ass arg19 nil)),
            (Util'ret1 arg20, (§ ass arg20 nil)),
            (§ cast Object[] (Util'ret1 args, (§ ass args nil)))
        )
    )

    #_override
    (defn #_"Object" IFn'''applyTo--Var [#_"Var" this, #_"ISeq" args]
        (IFn'''applyTo (Var''fn this), args)
    )

    (def #_"IFn" Var'assoc
        (§ reify AFn()
            #_override
            (defn #_"Object" IFn'''invoke-4--AFn [#_"AFn" this, #_"Object" m, #_"Object" k, #_"Object" v]
                (RT'assoc m, k, v)
            )
        )
    )

    (def #_"IFn" Var'dissoc
        (§ reify AFn()
            #_override
            (defn #_"Object" IFn'''invoke-3--AFn [#_"AFn" this, #_"Object" c, #_"Object" k]
                (RT'dissoc c, k)
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    (defn- #_"Volatile" Volatile'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"Volatile" Volatile'new [#_"Object" val]
        (let [this (Volatile'init)]
            (§ ass this (assoc this :val val))
            this
        )
    )

    #_override
    (defn #_"Object" IDeref'''deref--Volatile [#_"Volatile" this]
        (:val this)
    )

    #_method
    (defn #_"Object" Volatile''reset [#_"Volatile" this, #_"Object" newval]
        (§ ass this (assoc this :val newval))
        newval
    )
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

#_stateless
(class-ns main
    (§ def- #_"Symbol" main'CLOIURE_MAIN (Symbol'intern "cloiure.main"))
    (§ def- #_"Var" main'REQUIRE (RT'var "cloiure.core", "require"))
    (§ def- #_"Var" main'MAIN (RT'var "cloiure.main", "main"))

    (defn #_"void" -main [#_"String[]" args]
        (IFn'''invoke-2 main'REQUIRE, main'CLOIURE_MAIN)
        (IFn'''applyTo main'MAIN, (RT'seq args))
        nil
    )
)
)
