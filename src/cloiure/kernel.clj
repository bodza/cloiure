(ns #_cloiure.slang cloiure.kernel
    (:refer-clojure :exclude [when when-not]))

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(def % rem)
(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro java-ns [name & _] #_(ensure symbol? name) `(do ~@_))
(defmacro class-ns [name & _] #_(ensure symbol? name) `(do ~@_))

#_(ns cloiure.kernel
    (:refer-clojure :exclude [when when-not])
    (:use [cloiure slang]))

(import
    [java.io File FileInputStream FileNotFoundException FileOutputStream IOException LineNumberReader OutputStreamWriter PrintWriter PushbackReader Reader StringWriter]
  #_[java.lang Character Class Exception IllegalArgumentException IllegalStateException Integer Number NumberFormatException Object RuntimeException String StringBuilder Throwable UnsupportedOperationException]
    [java.lang.ref Reference ReferenceQueue SoftReference WeakReference]
    [java.lang.reflect Array Constructor Field InvocationHandler #_Method Modifier]
    [java.math BigDecimal BigInteger MathContext]
    [java.net JarURLConnection MalformedURLException URL URLClassLoader URLConnection]
    [java.nio ByteBuffer]
    [java.nio.charset Charset]
    [java.security AccessController PrivilegedAction]
    [java.util ArrayList Arrays Collection Comparator Enumeration HashMap HashSet Iterator LinkedList List Map NoSuchElementException Queue RandomAccess Set Stack TreeMap]
    [java.util.concurrent Callable ConcurrentHashMap ConcurrentMap CountDownLatch Executor ExecutorService Executors ThreadFactory TimeUnit]
    [java.util.concurrent.atomic AtomicBoolean AtomicInteger AtomicLong AtomicReference]
    [java.util.concurrent.locks ReentrantReadWriteLock]
    [java.util.regex Matcher Pattern]
    [cloiure.asm Attribute ByteVector ClassVisitor ClassWriter FieldVisitor Label MethodVisitor Opcodes Type]
    [cloiure.asm.commons GeneratorAdapter Method]
)

(declare AFn'new AFunction'new AMapEntry'new APersistentMap'new APersistentVector'new AReference'new ASeq'new ATransientMap'new AbortException'new AbstractMap'new ArgReader'new AssignParser'new Attribute'new BigDecimalOps'new BigIntOps'new BodyParser'new CaseParser'new ConditionalReader'new ConstantParser'new CtorReader'new DefParser'new DefaultComparator'new DeftypeParser'new DoubleOps'new EdnCharacterReader'new EdnCommentReader'new EdnDiscardReader'new EdnDispatchReader'new EdnListReader'new EdnMapReader'new EdnMetaReader'new EdnNamespaceMapReader'new EdnSetReader'new EdnStringReader'new EdnSymbolicValueReader'new EdnUnmatchedDelimiterReader'new EdnUnreadableReader'new EdnVectorReader'new EmptyBuffer'new EnumerationSeqState'new Error'new EvalReader'new Exception'new FieldExpr'new FnReader'new HostExpr'new HostParser'new IfParser'new IllegalArgumentException'new ImportParser'new IteratorSeqState'new LetFnParser'new LetParser'new LispCharacterReader'new LispCommentReader'new LispDiscardReader'new LispDispatchReader'new LispListReader'new LispMapReader'new LispMetaReader'new LispNamespaceMapReader'new LispSetReader'new LispStringReader'new LispSymbolicValueReader'new LispUnmatchedDelimiterReader'new LispUnreadableReader'new LispVectorReader'new LiteralExpr'new LockingTransaction'new LongOps'new MethodExpr'new MonitorEnterParser'new MonitorExitParser'new NewParser'new NilExpr'new Number'new Obj'new OpsP'new Primordial'new PushbackReader'new RatioOps'new RecurParser'new RegexReader'new ReifyParser'new RestFn'new RetryEx'new RuntimeException'new SyntaxQuoteReader'new TaggedReader'new TheVarParser'new ThrowParser'new TryParser'new URLClassLoader'new UnquoteReader'new UntypedExpr'new VarReader'new)
(declare AFn'applyToHelper)
(declare ActionQueue'EMPTY ActionQueue'new)
(declare AgentAction'new AgentAction'doRun)
(declare Agent'CONTINUE Agent'FAIL Agent'sendThreadPoolCounter Agent'sendOffThreadPoolCounter Agent'createThreadFactory Agent'pooledExecutor Agent'soloExecutor Agent'nested Agent'shutdown Agent'new-1 Agent'new-2 Agent'dispatchAction Agent'releasePendingSends)
(declare KeySeq'create KeySeq'createFromMap KeySeq'new-2 KeySeq'new-3)
(declare ValSeq'create ValSeq'createFromMap ValSeq'new-2 ValSeq'new-3)
(declare APersistentMap'mapEquals APersistentMap'mapHash APersistentMap'mapHasheq APersistentMap'MAKE_ENTRY APersistentMap'MAKE_KEY APersistentMap'MAKE_VAL)
(declare APersistentSet'new APersistentSet'setEquals)
(declare VSeq'new-2 VSeq'new-3)
(declare RSeq'new-2 RSeq'new-3)
(declare SubVector'new)
(declare APersistentVector'doEquals APersistentVector'doEquiv)
(declare ARef'new-0 ARef'new-1)
(declare AReference'new-0 AReference'new-1)
(declare ArityException'new-2 ArityException'new-3)
(declare ArrayChunk'new-1 ArrayChunk'new-2 ArrayChunk'new-3)
(declare ArrayIter_int'new ArrayIter_float'new ArrayIter_double'new ArrayIter_long'new ArrayIter_byte'new ArrayIter_char'new ArrayIter_short'new ArrayIter_boolean'new ArrayIter'EMPTY_ITERATOR ArrayIter'create-0 ArrayIter'create-1 ArrayIter'createFromObject ArrayIter'new)
(declare ArraySeq_int'new ArraySeq_float'new ArraySeq_double'new ArraySeq_long'new ArraySeq_byte'new ArraySeq_char'new ArraySeq_short'new ArraySeq_boolean'new ArraySeq'create-0 ArraySeq'create-1 ArraySeq'createFromObject ArraySeq'new-2 ArraySeq'new-3)
(declare ASeq'new-1 ASeq'new-0)
(declare Atom'new-1 Atom'new-2)
(declare ATransientMap'NOT_FOUND)
(declare ATransientSet'new)
(declare BigInt'ZERO BigInt'ONE BigInt'new BigInt'fromBigInteger BigInt'fromLong BigInt'valueOf)
(declare Binding'new-1 Binding'new-2)
(declare Box'new)
(declare ChunkBuffer'new)
(declare ChunkedCons'new-3 ChunkedCons'new-2)
(declare Compile'PATH_PROP Compile'REFLECTION_WARNING_PROP Compile'UNCHECKED_MATH_PROP Compile'compile_path Compile'compile Compile'warn_on_reflection Compile'unchecked_math Compile'main)
(declare DefExpr'bindRootMethod DefExpr'setTagMethod DefExpr'setMetaMethod DefExpr'setDynamicMethod DefExpr'symintern DefExpr'internVar DefExpr'new)
(declare AssignExpr'new)
(declare VarExpr'getMethod VarExpr'setMethod VarExpr'new)
(declare TheVarExpr'new)
(declare KeywordExpr'new)
(declare ImportExpr'forNameMethod ImportExpr'importClassMethod ImportExpr'derefMethod ImportExpr'new)
(declare HostExpr'BOOLEAN_TYPE HostExpr'CHAR_TYPE HostExpr'INTEGER_TYPE HostExpr'LONG_TYPE HostExpr'FLOAT_TYPE HostExpr'DOUBLE_TYPE HostExpr'SHORT_TYPE HostExpr'BYTE_TYPE HostExpr'NUMBER_TYPE HostExpr'charValueMethod HostExpr'booleanValueMethod HostExpr'charValueOfMethod HostExpr'intValueOfMethod HostExpr'longValueOfMethod HostExpr'floatValueOfMethod HostExpr'doubleValueOfMethod HostExpr'shortValueOfMethod HostExpr'byteValueOfMethod HostExpr'intValueMethod HostExpr'longValueMethod HostExpr'floatValueMethod HostExpr'doubleValueMethod HostExpr'byteValueMethod HostExpr'shortValueMethod HostExpr'fromIntMethod HostExpr'fromLongMethod HostExpr'fromDoubleMethod HostExpr'emitBoxReturn HostExpr'emitUnboxArg HostExpr'maybeClass HostExpr'maybeSpecialTag HostExpr'tagToClass)
(declare InstanceFieldExpr'invokeNoArgInstanceMember InstanceFieldExpr'setInstanceFieldMethod InstanceFieldExpr'new)
(declare StaticFieldExpr'new)
(declare MethodExpr'emitArgsAsArray MethodExpr'emitTypedArgs)
(declare InstanceMethodExpr'invokeInstanceMethodMethod InstanceMethodExpr'new)
(declare StaticMethodExpr'forNameMethod StaticMethodExpr'invokeStaticMethodMethod StaticMethodExpr'warnOnBoxedKeyword StaticMethodExpr'new StaticMethodExpr'isBoxedMath)
(declare UnresolvedVarExpr'new)
(declare NumberExpr'new NumberExpr'parse)
(declare ConstantParser'formKey)
(declare ConstantExpr'new)
(declare BooleanExpr'new)
(declare StringExpr'new)
(declare MonitorEnterExpr'new)
(declare MonitorExitExpr'new)
(declare CatchClause'new)
(declare TryExpr'new)
(declare ThrowExpr'new)
(declare NewExpr'invokeConstructorMethod NewExpr'forNameMethod NewExpr'new)
(declare MetaExpr'IOBJ_TYPE MetaExpr'withMetaMethod MetaExpr'new)
(declare IfExpr'new)
(declare EmptyExpr'HASHMAP_TYPE EmptyExpr'HASHSET_TYPE EmptyExpr'VECTOR_TYPE EmptyExpr'IVECTOR_TYPE EmptyExpr'TUPLE_TYPE EmptyExpr'LIST_TYPE EmptyExpr'EMPTY_LIST_TYPE EmptyExpr'new)
(declare ListExpr'arrayToListMethod ListExpr'new)
(declare MapExpr'mapMethod MapExpr'mapUniqueKeysMethod MapExpr'new MapExpr'parse)
(declare SetExpr'setMethod SetExpr'new SetExpr'parse)
(declare VectorExpr'vectorMethod VectorExpr'new VectorExpr'parse)
(declare KeywordInvokeExpr'ILOOKUP_TYPE KeywordInvokeExpr'new)
(declare InstanceOfExpr'new)
(declare StaticInvokeExpr'new StaticInvokeExpr'parse)
(declare InvokeExpr'onKey InvokeExpr'methodMapKey InvokeExpr'sigTag InvokeExpr'new InvokeExpr'parse)
(declare SourceDebugExtensionAttribute'new)
(declare FnExpr'aFnType FnExpr'restFnType FnExpr'new FnExpr'parse)
(declare ObjExpr'CONST_PREFIX ObjExpr'voidctor ObjExpr'kwintern ObjExpr'symintern ObjExpr'varintern ObjExpr'DYNAMIC_CLASSLOADER_TYPE ObjExpr'getClassMethod ObjExpr'getClassLoaderMethod ObjExpr'getConstantsMethod ObjExpr'readStringMethod ObjExpr'ILOOKUP_SITE_TYPE ObjExpr'ILOOKUP_THUNK_TYPE ObjExpr'KEYWORD_LOOKUPSITE_TYPE ObjExpr'new ObjExpr'trimGenID ObjExpr'varGetMethod ObjExpr'varGetRawMethod)
(declare PathNode'new)
(declare FnMethod'new FnMethod'classChar FnMethod'primInterface FnMethod'parse)
(declare ObjMethod'new ObjMethod'emitBody)
(declare LocalBinding'new)
(declare LocalBindingExpr'new)
(declare BodyExpr'new)
(declare BindingInit'new)
(declare LetFnExpr'new)
(declare LetExpr'new)
(declare RecurExpr'new)
(declare CompilerException'new)
(declare NewInstanceExpr'new NewInstanceExpr'build NewInstanceExpr'compileStub NewInstanceExpr'interfaceNames NewInstanceExpr'slashname NewInstanceExpr'msig NewInstanceExpr'considerMethod NewInstanceExpr'gatherMethods-2m NewInstanceExpr'gatherMethods-2s)
(declare NewInstanceMethod'dummyThis NewInstanceMethod'new NewInstanceMethod'msig NewInstanceMethod'parse NewInstanceMethod'findMethodsWithNameAndArity NewInstanceMethod'findMethodsWithName)
(declare MethodParamExpr'new)
(declare CaseExpr'NUMBER_TYPE CaseExpr'intValueMethod CaseExpr'hashMethod CaseExpr'hashCodeMethod CaseExpr'equivMethod CaseExpr'compactKey CaseExpr'sparseKey CaseExpr'hashIdentityKey CaseExpr'hashEquivKey CaseExpr'intKey CaseExpr'new CaseExpr'emitExpr)
(declare Compiler'DEF Compiler'LOOP Compiler'RECUR Compiler'IF Compiler'LET Compiler'LETFN Compiler'DO Compiler'FN Compiler'FNONCE Compiler'QUOTE Compiler'THE_VAR Compiler'DOT Compiler'ASSIGN Compiler'TRY Compiler'CATCH Compiler'FINALLY Compiler'THROW Compiler'MONITOR_ENTER Compiler'MONITOR_EXIT Compiler'IMPORT Compiler'DEFTYPE Compiler'CASE Compiler'CLASS Compiler'NEW Compiler'THIS Compiler'REIFY Compiler'LIST Compiler'HASHMAP Compiler'VECTOR Compiler'IDENTITY Compiler'_AMP_ Compiler'ISEQ Compiler'loadNs Compiler'inlineKey Compiler'inlineAritiesKey Compiler'staticKey Compiler'arglistsKey Compiler'INVOKE_STATIC Compiler'volatileKey Compiler'implementsKey Compiler'COMPILE_STUB_PREFIX Compiler'protocolKey Compiler'onKey Compiler'dynamicKey Compiler'redefKey Compiler'NS Compiler'IN_NS Compiler'specials Compiler'MAX_POSITIONAL_ARITY Compiler'OBJECT_TYPE Compiler'KEYWORD_TYPE Compiler'VAR_TYPE Compiler'SYMBOL_TYPE Compiler'IFN_TYPE Compiler'AFUNCTION_TYPE Compiler'RT_TYPE Compiler'NUMBERS_TYPE Compiler'CLASS_TYPE Compiler'NS_TYPE Compiler'UTIL_TYPE Compiler'REFLECTOR_TYPE Compiler'THROWABLE_TYPE Compiler'BOOLEAN_OBJECT_TYPE Compiler'IPERSISTENTMAP_TYPE Compiler'IOBJ_TYPE Compiler'TUPLE_TYPE Compiler'createTupleMethods Compiler'ARG_TYPES Compiler'EXCEPTION_TYPES Compiler'LOCAL_ENV Compiler'LOOP_LOCALS Compiler'LOOP_LABEL Compiler'CONSTANTS Compiler'CONSTANT_IDS Compiler'KEYWORD_CALLSITES Compiler'PROTOCOL_CALLSITES Compiler'VAR_CALLSITES Compiler'KEYWORDS Compiler'VARS Compiler'METHOD Compiler'IN_CATCH_FINALLY Compiler'METHOD_RETURN_CONTEXT Compiler'NO_RECUR Compiler'LOADER Compiler'SOURCE Compiler'SOURCE_PATH Compiler'COMPILE_PATH Compiler'COMPILE_FILES Compiler'INSTANCE Compiler'ADD_ANNOTATIONS Compiler'disableLocalsClearingKey Compiler'directLinkingKey Compiler'elideMetaKey Compiler'COMPILER_OPTIONS Compiler'getCompilerOption Compiler'elideMeta Compiler'LINE Compiler'COLUMN Compiler'lineDeref Compiler'columnDeref Compiler'LINE_BEFORE Compiler'COLUMN_BEFORE Compiler'LINE_AFTER Compiler'COLUMN_AFTER Compiler'NEXT_LOCAL_NUM Compiler'RET_LOCAL_NUM Compiler'COMPILE_STUB_SYM Compiler'COMPILE_STUB_CLASS Compiler'CLEAR_PATH Compiler'CLEAR_ROOT Compiler'CLEAR_SITES Compiler'RECUR_CLASS Compiler'isSpecial Compiler'inTailCall Compiler'resolveSymbol Compiler'maybePrimitiveType Compiler'maybeJavaClass Compiler'NIL_EXPR Compiler'TRUE_EXPR Compiler'FALSE_EXPR Compiler'subsumes Compiler'getTypeStringForArgs Compiler'getMatchingParams Compiler'CHAR_MAP Compiler'DEMUNGE_MAP Compiler'DEMUNGE_PATTERN Compiler'munge Compiler'demunge Compiler'clearPathRoot Compiler'registerLocal Compiler'getAndIncLocalNum Compiler'analyze-2 Compiler'analyze-3 Compiler'isMacro Compiler'isInline Compiler'namesStaticMember Compiler'preserveTag Compiler'MACRO_CHECK Compiler'MACRO_CHECK_LOADING Compiler'MACRO_CHECK_LOCK Compiler'ensureMacroCheck Compiler'checkSpecs Compiler'macroexpand1 Compiler'macroexpand Compiler'analyzeSeq Compiler'errorMsg Compiler'eval-1 Compiler'eval-2 Compiler'registerConstant Compiler'registerKeyword Compiler'registerKeywordCallsite Compiler'registerProtocolCallsite Compiler'registerVarCallsite Compiler'fwdPath Compiler'commonPath Compiler'addAnnotation Compiler'addParameterAnnotation Compiler'analyzeSymbol Compiler'destubClassName Compiler'getType Compiler'resolve-2 Compiler'resolve-1 Compiler'namespaceFor-1 Compiler'namespaceFor-2 Compiler'resolveIn Compiler'maybeResolveIn Compiler'lookupVar-3 Compiler'lookupVar-2 Compiler'registerVar Compiler'currentNS Compiler'closeOver Compiler'referenceLocal Compiler'tagOf Compiler'loadFile Compiler'load-1 Compiler'consumeWhitespaces Compiler'OPTS_COND_ALLOWED Compiler'readerOpts Compiler'load-3 Compiler'writeClassFile Compiler'pushNS Compiler'pushNSandLoader Compiler'getLookupThunk Compiler'compile1 Compiler'compile Compiler'inty Compiler'retType Compiler'primClass-1s Compiler'tagClass Compiler'primClass-1c Compiler'boxClass Compiler'emptyVarCallSites)
(declare Cons'new-2 Cons'new-3)
(declare Cycle'new-3 Cycle'new-5 Cycle'create)
(declare Delay'new Delay'force)
(declare DynamicClassLoader'classCache DynamicClassLoader'EMPTY_URLS DynamicClassLoader'RQ DynamicClassLoader'new-0 DynamicClassLoader'new-1 DynamicClassLoader'findInMemoryClass)
(declare EdnReaderException'new)
(declare EdnSymbolicValueReader'specials)
(declare TaggedReader'READERS TaggedReader'DEFAULT)
(declare EdnReader'macros EdnReader'dispatchMacros EdnReader'symbolPat EdnReader'intPat EdnReader'ratioPat EdnReader'floatPat EdnReader'taggedReader EdnReader'nonConstituent EdnReader'readString EdnReader'isWhitespace EdnReader'unread EdnReader'read1 EdnReader'EOF EdnReader'read-2 EdnReader'read-5 EdnReader'readToken EdnReader'readNumber EdnReader'readUnicodeChar-4 EdnReader'readUnicodeChar-5 EdnReader'interpretToken EdnReader'matchSymbol EdnReader'matchNumber EdnReader'getMacro EdnReader'isMacro EdnReader'isTerminatingMacro EdnReader'readDelimitedList)
(declare EnumerationSeq'create EnumerationSeq'new-1 EnumerationSeq'new-3)
(declare ExceptionInfo'new-2 ExceptionInfo'new-3)
(declare FnLoaderThunk'new)
(declare Intrinsics'oa Intrinsics'ops Intrinsics'preds)
(declare Iterate'UNREALIZED_SEED Iterate'new-3 Iterate'new-5 Iterate'create)
(declare IteratorSeq'create IteratorSeq'new-1 IteratorSeq'new-3)
(declare Keyword'TABLE Keyword'RQ Keyword'intern Keyword'intern-2 Keyword'intern-1 Keyword'new Keyword'find Keyword'find-2 Keyword'find-1)
(declare KeywordLookupSite'new)
(declare LazilyPersistentVector'createOwning LazilyPersistentVector'fcount LazilyPersistentVector'create)
(declare LazySeq'new-1 LazySeq'new-2)
(declare LineNumberingPushbackReader'newline LineNumberingPushbackReader'new-1 LineNumberingPushbackReader'new-2)
(declare LispReaderException'new)
(declare RegexReader'stringrdr)
(declare LispSymbolicValueReader'specials)
(declare WrappingReader'new)
(declare DeprecatedWrappingReader'new)
(declare SyntaxQuoteReader'syntaxQuote SyntaxQuoteReader'sqExpandList SyntaxQuoteReader'flattenMap)
(declare ConditionalReader'READ_STARTED ConditionalReader'DEFAULT_FEATURE ConditionalReader'RESERVED_FEATURES ConditionalReader'hasFeature ConditionalReader'readCondDelimited ConditionalReader'checkConditionalAllowed)
(declare LispReader'QUOTE LispReader'THE_VAR LispReader'UNQUOTE LispReader'UNQUOTE_SPLICING LispReader'CONCAT LispReader'SEQ LispReader'LIST LispReader'APPLY LispReader'HASHMAP LispReader'HASHSET LispReader'VECTOR LispReader'WITH_META LispReader'META LispReader'DEREF LispReader'READ_COND LispReader'READ_COND_SPLICING LispReader'UNKNOWN LispReader'macros LispReader'dispatchMacros LispReader'symbolPat LispReader'intPat LispReader'ratioPat LispReader'floatPat LispReader'GENSYM_ENV LispReader'ARG_ENV LispReader'ctorReader LispReader'READ_COND_ENV LispReader'isWhitespace LispReader'unread LispReader'read1 LispReader'OPT_EOF LispReader'OPT_FEATURES LispReader'OPT_READ_COND LispReader'EOFTHROW LispReader'PLATFORM_KEY LispReader'PLATFORM_FEATURES LispReader'COND_ALLOW LispReader'COND_PRESERVE LispReader'read-2 LispReader'read-4 LispReader'read-5 LispReader'read-6 LispReader'ensurePending LispReader'installPlatformFeature LispReader'read-9 LispReader'readToken LispReader'readNumber LispReader'readUnicodeChar-4 LispReader'readUnicodeChar-5 LispReader'interpretToken LispReader'matchSymbol LispReader'matchNumber LispReader'getMacro LispReader'isMacro LispReader'isTerminatingMacro LispReader'garg LispReader'registerArg LispReader'isUnquoteSplicing LispReader'isUnquote LispReader'READ_EOF LispReader'READ_FINISHED LispReader'readDelimitedList LispReader'isPreserveReadCond)
(declare LockingTransactionInfo'new)
(declare CFn'new)
(declare Notify'new)
(declare LockingTransaction'RETRY_LIMIT LockingTransaction'LOCK_WAIT_MSECS LockingTransaction'BARGE_WAIT_NANOS LockingTransaction'RUNNING LockingTransaction'COMMITTING LockingTransaction'RETRY LockingTransaction'KILLED LockingTransaction'COMMITTED LockingTransaction'transaction LockingTransaction'lastPoint LockingTransaction'getEx LockingTransaction'isRunning LockingTransaction'getRunning LockingTransaction'runInTransaction)
(declare LongRangeIterator'new)
(declare LongChunk'new)
(declare LongRange'CHUNK_SIZE LongRange'positiveStep LongRange'negativeStep LongRange'new-4 LongRange'new-6 LongRange'new-7 LongRange'create-1 LongRange'create-2 LongRange'create-3)
(declare MapEntry'create MapEntry'new)
(declare Entry'new)
(declare MethodImplCache'new-2 MethodImplCache'new-5 MethodImplCache'new-3)
(declare MultiFn'assoc MultiFn'dissoc MultiFn'isa MultiFn'parents MultiFn'new)
(declare Murmur3'seed Murmur3'C1 Murmur3'C2 Murmur3'hashInt Murmur3'hashLong Murmur3'hashUnencodedChars Murmur3'mixCollHash Murmur3'hashOrdered Murmur3'hashUnordered Murmur3'mixK1 Murmur3'mixH1 Murmur3'fmix)
(declare Namespace'namespaces Namespace'new Namespace'all Namespace'areDifferentInstancesOfSameClassName Namespace'findOrCreate Namespace'remove Namespace'find)
(declare LongOps'gcd)
(declare RatioOps'normalizeRet)
(declare BigDecimalOps'MATH_CONTEXT)
(declare Numbers'isZero-1o Numbers'isPos-1o Numbers'isNeg-1o Numbers'minus-1o Numbers'minusP-1o Numbers'inc-1o Numbers'incP-1o Numbers'dec-1o Numbers'decP-1o Numbers'add-2oo Numbers'addP-2oo Numbers'minus-2oo Numbers'minusP-2oo Numbers'multiply-2oo Numbers'multiplyP-2oo Numbers'divide-2oo Numbers'quotient-2oo Numbers'remainder-2oo Numbers'quotient-2dd Numbers'remainder-2dd Numbers'equiv-2oo Numbers'equiv-2nn Numbers'equal Numbers'lt-2oo Numbers'lte-2oo Numbers'gt-2oo Numbers'gte-2oo Numbers'compare Numbers'toBigInt Numbers'toBigInteger Numbers'toBigDecimal Numbers'toRatio Numbers'rationalize Numbers'reduceBigInt Numbers'divide-2ii Numbers'shiftLeftInt Numbers'shiftLeft-2oo Numbers'shiftLeft-2ol Numbers'shiftLeft-2lo Numbers'shiftLeft-2ll Numbers'shiftRightInt Numbers'shiftRight-2oo Numbers'shiftRight-2ol Numbers'shiftRight-2lo Numbers'shiftRight-2ll Numbers'unsignedShiftRightInt Numbers'unsignedShiftRight-2oo Numbers'unsignedShiftRight-2ol Numbers'unsignedShiftRight-2lo Numbers'unsignedShiftRight-2ll Numbers'LONG_OPS Numbers'DOUBLE_OPS Numbers'RATIO_OPS Numbers'BIGINT_OPS Numbers'BIGDECIMAL_OPS Numbers'ops Numbers'hasheqFrom Numbers'hasheq Numbers'category Numbers'bitOpsCast Numbers'float_array-2 Numbers'float_array-1 Numbers'double_array-2 Numbers'double_array-1 Numbers'int_array-2 Numbers'int_array-1 Numbers'long_array-2 Numbers'long_array-1 Numbers'short_array-2 Numbers'short_array-1 Numbers'char_array-2 Numbers'char_array-1 Numbers'byte_array-2 Numbers'byte_array-1 Numbers'boolean_array-2 Numbers'boolean_array-1 Numbers'booleans Numbers'bytes Numbers'chars Numbers'shorts Numbers'floats Numbers'doubles Numbers'ints Numbers'longs Numbers'num-1o Numbers'num-1f Numbers'num-1d Numbers'add-2dd Numbers'addP-2dd Numbers'minus-2dd Numbers'minusP-2dd Numbers'minus-1d Numbers'minusP-1d Numbers'inc-1d Numbers'incP-1d Numbers'dec-1d Numbers'decP-1d Numbers'multiply-2dd Numbers'multiplyP-2dd Numbers'divide-2dd Numbers'equiv-2dd Numbers'lt-2dd Numbers'lte-2dd Numbers'gt-2dd Numbers'gte-2dd Numbers'isPos-1d Numbers'isNeg-1d Numbers'isZero-1d Numbers'throwIntOverflow Numbers'unchecked_int_add Numbers'unchecked_int_subtract Numbers'unchecked_int_negate Numbers'unchecked_int_inc Numbers'unchecked_int_dec Numbers'unchecked_int_multiply Numbers'not-1o Numbers'not-1l Numbers'and-2oo Numbers'and-2ol Numbers'and-2lo Numbers'and-2ll Numbers'or-2oo Numbers'or-2ol Numbers'or-2lo Numbers'or-2ll Numbers'xor-2oo Numbers'xor-2ol Numbers'xor-2lo Numbers'xor-2ll Numbers'andNot-2oo Numbers'andNot-2ol Numbers'andNot-2lo Numbers'andNot-2ll Numbers'clearBit-2oo Numbers'clearBit-2ol Numbers'clearBit-2lo Numbers'clearBit-2ll Numbers'setBit-2oo Numbers'setBit-2ol Numbers'setBit-2lo Numbers'setBit-2ll Numbers'flipBit-2oo Numbers'flipBit-2ol Numbers'flipBit-2lo Numbers'flipBit-2ll Numbers'testBit-2oo Numbers'testBit-2ol Numbers'testBit-2lo Numbers'testBit-2ll Numbers'unchecked_int_divide Numbers'unchecked_int_remainder Numbers'num-1l Numbers'unchecked_add-2ll Numbers'unchecked_minus-2ll Numbers'unchecked_multiply-2ll Numbers'unchecked_minus-1l Numbers'unchecked_inc-1l Numbers'unchecked_dec-1l Numbers'unchecked_add-2oo Numbers'unchecked_minus-2oo Numbers'unchecked_multiply-2oo Numbers'unchecked_minus-1o Numbers'unchecked_inc-1o Numbers'unchecked_dec-1o Numbers'unchecked_add-2dd Numbers'unchecked_minus-2dd Numbers'unchecked_multiply-2dd Numbers'unchecked_minus-1d Numbers'unchecked_inc-1d Numbers'unchecked_dec-1d Numbers'unchecked_add-2do Numbers'unchecked_minus-2do Numbers'unchecked_multiply-2do Numbers'unchecked_add-2od Numbers'unchecked_minus-2od Numbers'unchecked_multiply-2od Numbers'unchecked_add-2dl Numbers'unchecked_minus-2dl Numbers'unchecked_multiply-2dl Numbers'unchecked_add-2ld Numbers'unchecked_minus-2ld Numbers'unchecked_multiply-2ld Numbers'unchecked_add-2lo Numbers'unchecked_minus-2lo Numbers'unchecked_multiply-2lo Numbers'unchecked_add-2ol Numbers'unchecked_minus-2ol Numbers'unchecked_multiply-2ol Numbers'quotient-2do Numbers'quotient-2od Numbers'quotient-2lo Numbers'quotient-2ol Numbers'quotient-2dl Numbers'quotient-2ld Numbers'remainder-2do Numbers'remainder-2od Numbers'remainder-2lo Numbers'remainder-2ol Numbers'remainder-2dl Numbers'remainder-2ld Numbers'add-2ll Numbers'addP-2ll Numbers'minus-2ll Numbers'minusP-2ll Numbers'minus-1l Numbers'minusP-1l Numbers'inc-1l Numbers'incP-1l Numbers'dec-1l Numbers'decP-1l Numbers'multiply-2ll Numbers'multiplyP-2ll Numbers'quotient-2ll Numbers'remainder-2ll Numbers'equiv-2ll Numbers'lt-2ll Numbers'lte-2ll Numbers'gt-2ll Numbers'gte-2ll Numbers'isPos-1l Numbers'isNeg-1l Numbers'isZero-1l Numbers'add-2lo Numbers'add-2ol Numbers'addP-2lo Numbers'addP-2ol Numbers'add-2do Numbers'add-2od Numbers'add-2dl Numbers'add-2ld Numbers'addP-2do Numbers'addP-2od Numbers'addP-2dl Numbers'addP-2ld Numbers'minus-2lo Numbers'minus-2ol Numbers'minusP-2lo Numbers'minusP-2ol Numbers'minus-2do Numbers'minus-2od Numbers'minus-2dl Numbers'minus-2ld Numbers'minusP-2do Numbers'minusP-2od Numbers'minusP-2dl Numbers'minusP-2ld Numbers'multiply-2lo Numbers'multiply-2ol Numbers'multiplyP-2lo Numbers'multiplyP-2ol Numbers'multiply-2do Numbers'multiply-2od Numbers'multiply-2dl Numbers'multiply-2ld Numbers'multiplyP-2do Numbers'multiplyP-2od Numbers'multiplyP-2dl Numbers'multiplyP-2ld Numbers'divide-2lo Numbers'divide-2ol Numbers'divide-2do Numbers'divide-2od Numbers'divide-2dl Numbers'divide-2ld Numbers'divide-2ll Numbers'lt-2lo Numbers'lt-2ol Numbers'lt-2do Numbers'lt-2od Numbers'lt-2dl Numbers'lt-2ld Numbers'lte-2lo Numbers'lte-2ol Numbers'lte-2do Numbers'lte-2od Numbers'lte-2dl Numbers'lte-2ld Numbers'gt-2lo Numbers'gt-2ol Numbers'gt-2do Numbers'gt-2od Numbers'gt-2dl Numbers'gt-2ld Numbers'gte-2lo Numbers'gte-2ol Numbers'gte-2do Numbers'gte-2od Numbers'gte-2dl Numbers'gte-2ld Numbers'equiv-2lo Numbers'equiv-2ol Numbers'equiv-2do Numbers'equiv-2od Numbers'equiv-2dl Numbers'equiv-2ld Numbers'isNaN Numbers'max-2dd Numbers'max-2dl Numbers'max-2do Numbers'max-2ld Numbers'max-2ll Numbers'max-2lo Numbers'max-2ol Numbers'max-2od Numbers'max-2oo Numbers'min-2dd Numbers'min-2dl Numbers'min-2do Numbers'min-2ld Numbers'min-2ll Numbers'min-2lo Numbers'min-2ol Numbers'min-2od Numbers'min-2oo)
(declare Obj'new-1 Obj'new-0)
(declare MSeq'new-2 MSeq'new-3)
(declare MIter'new-2 MIter'new-3)
(declare TransientArrayMap'new)
(declare PersistentArrayMap'EMPTY PersistentArrayMap'HASHTABLE_THRESHOLD PersistentArrayMap'create PersistentArrayMap'new-0 PersistentArrayMap'createWithCheck PersistentArrayMap'createAsIfByAssoc PersistentArrayMap'new-1 PersistentArrayMap'new-2 PersistentArrayMap'equalKey)
(declare TransientHashMap'new-1 TransientHashMap'new-5)
(declare HSeq'create-1 HSeq'create-4 HSeq'new)
(declare HIter'new)
(declare ArrayNode'new ArrayNode'foldTasks)
(declare BitmapIndexedNode'EMPTY BitmapIndexedNode'new)
(declare HashCollisionNode'new)
(declare NodeIter'NULL NodeIter'new)
(declare NodeSeq'new-2 NodeSeq'create-1 NodeSeq'kvreduce NodeSeq'create-3 NodeSeq'new-4)
(declare PersistentHashMap'EMPTY PersistentHashMap'NOT_FOUND PersistentHashMap'create-1m PersistentHashMap'create-1a PersistentHashMap'createWithCheck-1a PersistentHashMap'create-1s PersistentHashMap'createWithCheck-1s PersistentHashMap'create-2 PersistentHashMap'new-4 PersistentHashMap'new-5 PersistentHashMap'hash PersistentHashMap'EMPTY_ITER PersistentHashMap'mask PersistentHashMap'cloneAndSet-3 PersistentHashMap'cloneAndSet-5 PersistentHashMap'removePair PersistentHashMap'createNode-6 PersistentHashMap'createNode-7 PersistentHashMap'bitpos)
(declare TransientHashSet'new)
(declare PersistentHashSet'EMPTY PersistentHashSet'create-1a PersistentHashSet'create-1l PersistentHashSet'create-1s PersistentHashSet'createWithCheck-1a PersistentHashSet'createWithCheck-1l PersistentHashSet'createWithCheck-1s PersistentHashSet'new)
(declare Primordial'invokeStatic)
(declare EmptyList'HASHEQ EmptyList'new EmptyList'hasheq)
(declare PersistentList'creator PersistentList'EMPTY PersistentList'new-1 PersistentList'new-4 PersistentList'create)
(declare QSeq'new-2 QSeq'new-3)
(declare PersistentQueue'EMPTY PersistentQueue'new)
(declare TNode'new)
(declare Black'new)
(declare BlackVal'new)
(declare BlackBranch'new)
(declare BlackBranchVal'new)
(declare Red'new)
(declare RedVal'new)
(declare RedBranch'new)
(declare RedBranchVal'new)
(declare TSeq'new-2 TSeq'new-3 TSeq'new-4 TSeq'create TSeq'push)
(declare NodeIterator'new)
(declare KeyIterator'new)
(declare ValIterator'new)
(declare PersistentTreeMap'EMPTY PersistentTreeMap'create-1m PersistentTreeMap'new-0 PersistentTreeMap'new-1 PersistentTreeMap'new-2 PersistentTreeMap'new-4m PersistentTreeMap'create-1s PersistentTreeMap'create-2 PersistentTreeMap'append PersistentTreeMap'balanceLeftDel PersistentTreeMap'balanceRightDel PersistentTreeMap'leftBalance PersistentTreeMap'rightBalance PersistentTreeMap'new-4c PersistentTreeMap'red PersistentTreeMap'black)
(declare PersistentTreeSet'EMPTY PersistentTreeSet'create-1 PersistentTreeSet'create-2 PersistentTreeSet'new)
(declare VNode'new-2 VNode'new-1)
(declare ChunkedSeq'new-3 ChunkedSeq'new-5 ChunkedSeq'new-4)
(declare TransientVector'new-4 TransientVector'new-1 TransientVector'editableRoot TransientVector'editableTail TransientVector'NOT_FOUND)
(declare PersistentVector'NOEDIT PersistentVector'EMPTY_NODE PersistentVector'EMPTY PersistentVector'TRANSIENT_VECTOR_CONJ PersistentVector'adopt PersistentVector'create-1r PersistentVector'create-1s PersistentVector'create-1l PersistentVector'create-1i PersistentVector'create-1a PersistentVector'new-4 PersistentVector'new-5 PersistentVector'doAssoc PersistentVector'newPath)
(declare ProxyHandler'new)
(declare RangeIterator'new)
(declare Range'CHUNK_SIZE Range'positiveStep Range'negativeStep Range'new-4 Range'new-6 Range'new-7 Range'create-1 Range'create-2 Range'create-3)
(declare Ratio'new)
(declare ReaderConditional'FORM_KW ReaderConditional'SPLICING_KW ReaderConditional'create ReaderConditional'new)
(declare RecordIterator'new)
(declare Reduced'new)
(declare RefTVal'new-3 RefTVal'new-2)
(declare Ref'ids Ref'new-1 Ref'new-2)
(declare Reflector'invokeInstanceMethod Reflector'getCauseOrElse Reflector'throwCauseOrElseException Reflector'noMethodReport Reflector'invokeMatchingMethod Reflector'getAsMethodOfPublicBase Reflector'isMatch Reflector'invokeConstructor Reflector'invokeStaticMethodVariadic Reflector'invokeStaticMethod-3s Reflector'invokeStaticMethod-3c Reflector'getStaticField-2s Reflector'getStaticField-2c Reflector'setStaticField-3s Reflector'setStaticField-3c Reflector'getInstanceField Reflector'setInstanceField Reflector'invokeNoArgInstanceMember-2 Reflector'invokeNoArgInstanceMember-3 Reflector'invokeInstanceMember-2 Reflector'invokeInstanceMember-3o Reflector'invokeInstanceMember-3a Reflector'getField Reflector'getMethods Reflector'boxArg Reflector'boxArgs Reflector'paramArgTypeMatch Reflector'isCongruent Reflector'prepRet)
(declare Repeat'INFINITE Repeat'new-2 Repeat'new-3 Repeat'create-1 Repeat'create-2)
(declare RestFn'ontoArrayPrepend RestFn'findKey)
(declare RT'T RT'F RT'LOADER_SUFFIX RT'DEFAULT_IMPORTS RT'UTF8 RT'readTrueFalseUnknown RT'CLOIURE_NS RT'OUT RT'IN RT'ERR RT'TAG_KEY RT'CONST_KEY RT'AGENT RT'readeval RT'READEVAL RT'DATA_READERS RT'DEFAULT_DATA_READER_FN RT'DEFAULT_DATA_READERS RT'SUPPRESS_READ RT'ASSERT RT'MATH_CONTEXT RT'LINE_KEY RT'COLUMN_KEY RT'FILE_KEY RT'DECLARED_KEY RT'DOC_KEY RT'USE_CONTEXT_CLASSLOADER RT'UNCHECKED_MATH RT'LOAD_FILE RT'IN_NAMESPACE RT'NAMESPACE RT'IDENTICAL RT'CMD_LINE_ARGS RT'CURRENT_NS RT'FLUSH_ON_NEWLINE RT'PRINT_META RT'PRINT_READABLY RT'PRINT_DUP RT'WARN_ON_REFLECTION RT'ALLOW_UNRESOLVED_VARS RT'READER_RESOLVER RT'IN_NS_VAR RT'NS_VAR RT'FN_LOADER_VAR RT'PRINT_INITIALIZED RT'PR_ON RT'inNamespace RT'bootNamespace RT'processCommandLine RT'errPrintWriter RT'EMPTY_ARRAY RT'DEFAULT_COMPARATOR RT'ID RT'addURL RT'CHECK_SPEC_ASSERTS RT'INSTRUMENT_MACROS RT'CHECK_SPECS RT'keyword RT'var-2 RT'var-3 RT'loadResourceScript-1 RT'maybeLoadResourceScript RT'loadResourceScript-2s RT'loadResourceScript-2c RT'loadResourceScript-3 RT'lastModified RT'compile RT'load-1 RT'load-2 RT'doInit RT'nextID RT'loadLibrary RT'CHUNK_SIZE RT'chunkIteratorSeq RT'seq RT'seqFrom RT'canSeq RT'iter RT'seqOrElse RT'keys RT'vals RT'meta RT'count RT'countFrom RT'conj RT'cons RT'first RT'second RT'third RT'fourth RT'next RT'more RT'peek RT'pop RT'get-2 RT'getFrom-2 RT'get-3 RT'getFrom-3 RT'assoc RT'contains RT'find RT'findKey RT'dissoc RT'nth-2 RT'nthFrom-2 RT'nth-3 RT'nthFrom-3 RT'assocN RT'hasTag RT'box-1o RT'box-1c RT'box-1z RT'box-1Z RT'box-1b RT'box-1s RT'box-1i RT'box-1l RT'box-1f RT'box-1d RT'charCast-1o RT'charCast-1b RT'charCast-1s RT'charCast-1c RT'charCast-1i RT'charCast-1l RT'charCast-1f RT'charCast-1d RT'booleanCast-1o RT'booleanCast-1b RT'byteCast-1o RT'byteCast-1b RT'byteCast-1s RT'byteCast-1i RT'byteCast-1l RT'byteCast-1f RT'byteCast-1d RT'shortCast-1o RT'shortCast-1b RT'shortCast-1s RT'shortCast-1i RT'shortCast-1l RT'shortCast-1f RT'shortCast-1d RT'intCast-1o RT'intCast-1c RT'intCast-1b RT'intCast-1s RT'intCast-1i RT'intCast-1f RT'intCast-1l RT'intCast-1d RT'longCast-1o RT'longCast-1b RT'longCast-1s RT'longCast-1i RT'longCast-1f RT'longCast-1l RT'longCast-1d RT'floatCast-1o RT'floatCast-1b RT'floatCast-1s RT'floatCast-1i RT'floatCast-1f RT'floatCast-1l RT'floatCast-1d RT'doubleCast-1o RT'doubleCast-1b RT'doubleCast-1s RT'doubleCast-1i RT'doubleCast-1f RT'doubleCast-1l RT'doubleCast-1d RT'uncheckedByteCast-1o RT'uncheckedByteCast-1b RT'uncheckedByteCast-1s RT'uncheckedByteCast-1i RT'uncheckedByteCast-1l RT'uncheckedByteCast-1f RT'uncheckedByteCast-1d RT'uncheckedShortCast-1o RT'uncheckedShortCast-1b RT'uncheckedShortCast-1s RT'uncheckedShortCast-1i RT'uncheckedShortCast-1l RT'uncheckedShortCast-1f RT'uncheckedShortCast-1d RT'uncheckedCharCast-1o RT'uncheckedCharCast-1b RT'uncheckedCharCast-1s RT'uncheckedCharCast-1c RT'uncheckedCharCast-1i RT'uncheckedCharCast-1l RT'uncheckedCharCast-1f RT'uncheckedCharCast-1d RT'uncheckedIntCast-1o RT'uncheckedIntCast-1b RT'uncheckedIntCast-1s RT'uncheckedIntCast-1c RT'uncheckedIntCast-1i RT'uncheckedIntCast-1l RT'uncheckedIntCast-1f RT'uncheckedIntCast-1d RT'uncheckedLongCast-1o RT'uncheckedLongCast-1b RT'uncheckedLongCast-1s RT'uncheckedLongCast-1i RT'uncheckedLongCast-1l RT'uncheckedLongCast-1f RT'uncheckedLongCast-1d RT'uncheckedFloatCast-1o RT'uncheckedFloatCast-1b RT'uncheckedFloatCast-1s RT'uncheckedFloatCast-1i RT'uncheckedFloatCast-1l RT'uncheckedFloatCast-1f RT'uncheckedFloatCast-1d RT'uncheckedDoubleCast-1o RT'uncheckedDoubleCast-1b RT'uncheckedDoubleCast-1s RT'uncheckedDoubleCast-1i RT'uncheckedDoubleCast-1l RT'uncheckedDoubleCast-1f RT'uncheckedDoubleCast-1d RT'map RT'mapUniqueKeys RT'set RT'vector RT'subvec RT'list-0 RT'list-1 RT'list-2 RT'list-3 RT'list-4 RT'list-5 RT'listStar-2 RT'listStar-3 RT'listStar-4 RT'listStar-5 RT'listStar-6 RT'arrayToList RT'object_array RT'toArray RT'seqToArray RT'seqToPassedArray RT'seqToTypedArray-1 RT'seqToTypedArray-2 RT'length RT'boundedLength RT'readRet RT'readChar RT'peekChar RT'getLineNumber RT'getColumnNumber RT'getLineNumberingReader RT'isLineNumberingReader RT'isReduced RT'resolveClassNameInContext RT'suppressRead RT'printString RT'readString-1 RT'readString-2 RT'print RT'printInnerSeq RT'formatAesthetic RT'formatStandard RT'format RT'doFormat RT'setValues RT'makeClassLoader RT'baseLoader RT'resourceAsStream RT'getResource RT'classForName-3 RT'classForName-1 RT'classForNameNonLoading RT'loadClassForName RT'aget-2f RT'aset-3f RT'alength-1f RT'aclone-1f RT'aget-2d RT'aset-3d RT'alength-1d RT'aclone-1d RT'aget-2i RT'aset-3i RT'alength-1i RT'aclone-1i RT'aget-2l RT'aset-3l RT'alength-1l RT'aclone-1l RT'aget-2c RT'aset-3c RT'alength-1c RT'aclone-1c RT'aget-2b RT'aset-3b RT'alength-1b RT'aclone-1b RT'aget-2s RT'aset-3s RT'alength-1s RT'aclone-1s RT'aget-2z RT'aset-3z RT'alength-1z RT'aclone-1z RT'aget-2o RT'aset-3o RT'alength-1o RT'aclone-1o)
(declare SeqEnumeration'new)
(declare SeqIterator'START SeqIterator'new)
(declare StringSeq'create StringSeq'new)
(declare Symbol'create-2 Symbol'create-1 Symbol'intern-2 Symbol'intern-1 Symbol'new-2 Symbol'new-3)
(declare TaggedLiteral'TAG_KW TaggedLiteral'FORM_KW TaggedLiteral'create TaggedLiteral'new)
(declare TransactionalHashMap'new-0 TransactionalHashMap'new-1i TransactionalHashMap'new-1m)
(declare SingleBuffer'new)
(declare ManyBuffer'new)
(declare MultiIterator'new)
(declare TransformerIterator'EMPTY TransformerIterator'NONE TransformerIterator'new TransformerIterator'create TransformerIterator'createMulti)
(declare Tuple'MAX_SIZE Tuple'create-0 Tuple'create-1 Tuple'create-2 Tuple'create-3 Tuple'create-4 Tuple'create-5 Tuple'create-6)
(declare Util'equiv-2oo Util'equivNull Util'equivEquals Util'equivNumber Util'equivColl Util'equivPred Util'equiv-2ll Util'equiv-2ol Util'equiv-2lo Util'equiv-2dd Util'equiv-2od Util'equiv-2do Util'equiv-2bb Util'equiv-2ob Util'equiv-2bo Util'equiv-2cc Util'pcequiv Util'equals Util'identical Util'classOf Util'compare Util'hash Util'hasheq Util'dohasheq Util'hashCombine Util'isPrimitive Util'isInteger Util'ret1 Util'clearCache Util'runtimeException-1 Util'runtimeException-2 Util'sneakyThrow Util'sneakyThrow0 Util'loadWithClass)
(declare TBox'new)
(declare Unbound'new)
(declare Frame'TOP Frame'new)
(declare Var'dvals Var'rev Var'privateKey Var'privateMeta Var'macroKey Var'nameKey Var'nsKey Var'getThreadBindingFrame Var'cloneThreadBindingFrame Var'resetThreadBindingFrame Var'intern-3 Var'intern-4 Var'find Var'intern-2s Var'internPrivate Var'intern-2n Var'create-0 Var'create-1 Var'new-2 Var'new-3 Var'pushThreadBindings Var'popThreadBindings Var'getThreadBindings Var'assoc Var'dissoc)
(declare Volatile'new)
(declare main'CLOIURE_MAIN main'REQUIRE main'MAIN)

(java-ns cloiure.lang.AFn

#_stateless
#_abstract
(class-ns AFn (§ implements IFn)
    #_protected
    (defn #_"AFn" AFn'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Object" call [#_"AFn" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"AFn" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this]
        (ß throwArity(0))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1]
        (ß throwArity(1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß throwArity(2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß throwArity(3))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß throwArity(4))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß throwArity(5))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß throwArity(6))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß throwArity(7))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß throwArity(8))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß throwArity(9))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß throwArity(10))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß throwArity(11))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß throwArity(12))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß throwArity(13))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß throwArity(14))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß throwArity(15))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß throwArity(16))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß throwArity(17))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß throwArity(18))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß throwArity(19))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß throwArity(20))
    )

    #_method
    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß throwArity(21))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"AFn" this, #_"ISeq" ___arglist]
        (ß AFn'applyToHelper(this, Util'ret1(___arglist, (§ ass ___arglist nil))))
    )

    (defn #_"Object" AFn'applyToHelper [#_"IFn" ___ifn, #_"ISeq" ___arglist]
        (§ switch (RT'boundedLength ___arglist, 20)
            (§ case 0)
            (do
                (§ ass ___arglist nil)
                (ß ___ifn.invoke())
            )
            (§ case 1)
            (do
                (ß ___ifn.invoke(Util'ret1(___arglist.first(), (§ ass ___arglist nil))))
            )
            (§ case 2)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 3)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 4)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 5)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 6)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 7)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 8)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 9)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 10)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 11)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 12)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 13)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 14)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 15)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 16)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 17)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 18)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 19)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ case 20)
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        Util'ret1((§ ass ___arglist (ß ___arglist.next())).first(), (§ ass ___arglist nil))))
            )
            (§ default )
            (do
                (ß ___ifn.invoke(___arglist.first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        (§ ass ___arglist (ß ___arglist.next())).first(),
                        RT'seqToArray(Util'ret1(___arglist.next(), (§ ass ___arglist nil)))))
            )
        )
    )

    #_method
    (§ defn #_"Object" throwArity [#_"AFn" this, #_"int" ___n]
        (let [#_"String" ___name (ß getClass().getSimpleName())]
            (throw (ß ArityException'new-2(___n, Compiler'demunge(___name))))
        )
    )
)
)

(java-ns cloiure.lang.AFunction

(§ import java.util.Comparator)

#_abstract
(class-ns AFunction (§ extends AFn) (§ implements IObj, Comparator, Fn)
    (defn- #_"AFunction" AFunction'init []
        (hash-map
            #_volatile
            #_"MethodImplCache" :__methodImplCache nil
        )
    )

    #_protected
    (defn #_"AFunction" AFunction'new []
        (merge (AFn'new) (AFunction'init))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"AFunction" this]
        nil
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"AFunction" this, #_"IPersistentMap" ___meta]
        (§ reify RestFn()
            #_protected
            #_method
            (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___args]
                (ß (§ this AFunction).applyTo((ISeq) ___args))
            )

            #_method
            (§ defn #_"IPersistentMap" meta [#_"RestFn" this]
                ___meta
            )

            #_method
            (§ defn #_"IObj" withMeta [#_"RestFn" this, #_"IPersistentMap" ___meta]
                (ß (§ this AFunction).withMeta(___meta))
            )

            #_method
            (§ defn #_"int" getRequiredArity [#_"RestFn" this]
                0
            )
        )
    )

    #_method
    (§ defn #_"int" compare [#_"AFunction" this, #_"Object" ___o1, #_"Object" ___o2]
        (let [#_"Object" ___o (ß invoke(___o1, ___o2))]
            (when (ß ___o instanceof Boolean)
                (when (RT'booleanCast-1o ___o)
                    (§ return -1)
                )
                (§ return (ß RT'booleanCast-1o(invoke(___o2, ___o1)) ? 1 :or 0))
            )

            (let [#_"Number" ___n (ß (Number) ___o)]
                (ß ___n.intValue())
            )
        )
    )
)
)

(java-ns cloiure.lang.Agent

(§ import java.util.concurrent.Executor)
(§ import java.util.concurrent.ExecutorService)
(§ import java.util.concurrent.Executors)
(§ import java.util.concurrent.ThreadFactory)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns ActionQueue
    (§ def #_"ActionQueue" ActionQueue'EMPTY (ActionQueue'new PersistentQueue'EMPTY, nil))

    (defn- #_"ActionQueue" ActionQueue'init []
        (hash-map
            #_"IPersistentStack" :q nil
            #_"Throwable" :error nil ;; non-null indicates fail state
        )
    )

    (defn #_"ActionQueue" ActionQueue'new [#_"IPersistentStack" ___q, #_"Throwable" ___error]
        (let [this (ActionQueue'init)]
            (§ ass (:q this) ___q)
            (§ ass (:error this) ___error)
            this
        )
    )
)

(class-ns AgentAction (§ implements Runnable)
    (defn- #_"AgentAction" AgentAction'init []
        (hash-map
            #_"Agent" :agent nil
            #_"IFn" :fn nil
            #_"ISeq" :args nil
            #_"Executor" :exec nil
        )
    )

    (defn #_"AgentAction" AgentAction'new [#_"Agent" ___agent, #_"IFn" ___fn, #_"ISeq" ___args, #_"Executor" ___exec]
        (let [this (AgentAction'init)]
            (§ ass (:agent this) ___agent)
            (§ ass (:args this) ___args)
            (§ ass (:fn this) ___fn)
            (§ ass (:exec this) ___exec)
            this
        )
    )

    #_method
    (§ defn #_"void" execute [#_"AgentAction" this]
        (try
            (ß (:exec this).execute(this))
            (catch Throwable ___error
                (when (ß (:agent this).errorHandler != nil)
                    (try
                        (ß (:agent this).errorHandler.invoke((:agent this), ___error))
                        (catch Throwable ___e
                            ;; ignore errorHandler errors
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" AgentAction'doRun [#_"AgentAction" ___action]
        (try
            (ß nested.set(PersistentVector'EMPTY))

            (let [#_"Throwable" ___error nil]
                (try
                    (let [#_"Object" ___oldval (ß (:agent ___action).state)]
                        (let [#_"Object" ___newval (ß (:fn ___action).applyTo(RT'cons((:agent ___action).state, (:args ___action))))]
                            (ß (:agent ___action).setState(___newval))
                            (ß (:agent ___action).notifyWatches(___oldval, ___newval))
                        )
                    )
                    (catch Throwable ___e
                        (§ ass ___error ___e)
                    )
                )

                (if (nil? ___error)
                    (do
                        (ß releasePendingSends())
                    )
                    (do
                        (ß nested.set(nil)) ;; allow errorHandler to send
                        (when (ß (:agent ___action).errorHandler != nil)
                            (try
                                (ß (:agent ___action).errorHandler.invoke((:agent ___action), ___error))
                                (catch Throwable ___e
                                    ;; ignore errorHandler errors
                                )
                            )
                        )
                        (when (ß (:agent ___action).errorMode == Agent'CONTINUE)
                            (§ ass ___error nil)
                        )
                    )
                )

                (let [#_"boolean" ___popped false]
                    (let [#_"ActionQueue" ___next nil]
                        (while (ß !___popped)
                            (let [#_"ActionQueue" ___prior (ß (:agent ___action).aq.get())]
                                (§ ass ___next (ß ActionQueue'new((:q ___prior).pop(), ___error)))
                                (§ ass ___popped (ß (:agent ___action).aq.compareAndSet(___prior, ___next)))
                            )
                        )

                        (when (ß ___error == nil && (:q ___next).count() > 0)
                            (ß ((AgentAction) (:q ___next).peek()).execute())
                        )
                    )
                )
            )
            (finally
                (ß nested.set(nil))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" run [#_"AgentAction" this]
        (AgentAction'doRun this)
        nil
    )
)

(class-ns Agent (§ extends ARef)
    (§ def #_"Keyword" Agent'CONTINUE (Keyword'intern-2 nil, "continue"))
    (§ def #_"Keyword" Agent'FAIL (Keyword'intern-2 nil, "fail"))

    (def- #_"AtomicLong" Agent'sendThreadPoolCounter (AtomicLong. 0))
    (def- #_"AtomicLong" Agent'sendOffThreadPoolCounter (AtomicLong. 0))

    (defn- #_"ThreadFactory" Agent'createThreadFactory [#_"String" ___format, #_"AtomicLong" ___threadPoolCounter]
        (§ reify ThreadFactory()
            #_method
            (§ defn #_"Thread" newThread [#_"ThreadFactory" this, #_"Runnable" ___runnable]
                (let [#_"Thread" ___thread (Thread. ___runnable)]
                    (ß ___thread.setName(String/format(___format, (§ array (ß ___threadPoolCounter.getAndIncrement())))))
                    ___thread
                )
            )
        )
    )

    #_volatile
    (def #_"ExecutorService" Agent'pooledExecutor (ß Executors/newFixedThreadPool(2 + Runtime/getRuntime().availableProcessors(), createThreadFactory("cloiure-agent-send-pool-%d", sendThreadPoolCounter))))

    #_volatile
    (def #_"ExecutorService" Agent'soloExecutor (ß Executors/newCachedThreadPool(createThreadFactory("cloiure-agent-send-off-pool-%d", sendOffThreadPoolCounter))))

    (def #_"ThreadLocal<IPersistentVector>" Agent'nested (ThreadLocal.))

    (defn #_"void" Agent'shutdown []
        (ß soloExecutor.shutdown())
        (ß pooledExecutor.shutdown())
        nil
    )

    (defn- #_"Agent" Agent'init []
        (hash-map
            #_volatile
            #_"Object" :state nil
            #_"AtomicReference<ActionQueue>" :aq (AtomicReference. ActionQueue'EMPTY)

            #_volatile
            #_"Keyword" :errorMode Agent'CONTINUE
            #_volatile
            #_"IFn" :errorHandler nil
        )
    )

    (defn #_"Agent" Agent'new-1 [#_"Object" ___state]
        (Agent'new-2 ___state, nil)
    )

    (defn #_"Agent" Agent'new-2 [#_"Object" ___state, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Agent'init))]
            (ß setState(___state))
            this
        )
    )

    #_method
    (§ defn #_"boolean" setState [#_"Agent" this, #_"Object" ___newState]
        (ß validate(___newState))
        (let [#_"boolean" ___ret (ß ((:state this) != ___newState))]
            (§ ass (:state this) ___newState)
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Agent" this]
        (:state this)
    )

    #_method
    (§ defn #_"Throwable" getError [#_"Agent" this]
        (ß (:aq this).get().error)
    )

    #_method
    (§ defn #_"void" setErrorMode [#_"Agent" this, #_"Keyword" ___k]
        (§ ass (:errorMode this) ___k)
        nil
    )

    #_method
    (§ defn #_"Keyword" getErrorMode [#_"Agent" this]
        (:errorMode this)
    )

    #_method
    (§ defn #_"void" setErrorHandler [#_"Agent" this, #_"IFn" ___f]
        (§ ass (:errorHandler this) ___f)
        nil
    )

    #_method
    (§ defn #_"IFn" getErrorHandler [#_"Agent" this]
        (:errorHandler this)
    )

    #_method
    (§ defn #_"Object" restart [#_"Agent" this, #_"Object" ___newState, #_"boolean" ___clearActions]
        (§ sync this
            (when (ß getError() == nil)
                (throw (Util'runtimeException-1 "Agent does not need a restart"))
            )
            (ß validate(___newState))
            (§ ass (:state this) ___newState)

            (if ___clearActions
                (do
                    (ß (:aq this).set(ActionQueue'EMPTY))
                )
                (do
                    (let [#_"boolean" ___restarted false]
                        (let [#_"ActionQueue" ___prior nil]
                            (while (ß !___restarted)
                                (§ ass ___prior (ß (:aq this).get()))
                                (§ ass ___restarted (ß (:aq this).compareAndSet(___prior, ActionQueue'new((:q ___prior), nil))))
                            )

                            (when (ß (:q ___prior).count() > 0)
                                (ß ((AgentAction) (:q ___prior).peek()).execute())
                            )
                        )
                    )
                )
            )

            ___newState
        )
    )

    #_method
    (§ defn #_"Object" dispatch [#_"Agent" this, #_"IFn" ___fn, #_"ISeq" ___args, #_"Executor" ___exec]
        (let [#_"Throwable" ___error (ß getError())]
            (when (some? ___error)
                (throw (Util'runtimeException-2 "Agent is failed, needs restart", ___error))
            )
            (let [#_"AgentAction" ___action (AgentAction'new this, ___fn, ___args, ___exec)]
                (ß dispatchAction(___action))

                this
            )
        )
    )

    (defn #_"void" Agent'dispatchAction [#_"AgentAction" ___action]
        (let [#_"LockingTransaction" ___trans (ß LockingTransaction'getRunning())]
            (cond (some? ___trans)
                (do
                    (ß ___trans.enqueue(___action))
                )
                (ß nested.get() != nil)
                (do
                    (ß nested.set(nested.get().cons(___action)))
                )
                :else
                (do
                    (ß (:agent ___action).enqueue(___action))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" enqueue [#_"Agent" this, #_"AgentAction" ___action]
        (let [#_"boolean" ___queued false]
            (let [#_"ActionQueue" ___prior nil]
                (while (ß !___queued)
                    (§ ass ___prior (ß (:aq this).get()))
                    (§ ass ___queued (ß (:aq this).compareAndSet(___prior, ActionQueue'new((IPersistentStack)___prior.q.cons(___action), (:error ___prior)))))
                )

                (when (ß (:q ___prior).count() == 0 && (:error ___prior) == nil)
                    (ß ___action.execute())
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" getQueueCount [#_"Agent" this]
        (ß (:aq this).get().q.count())
    )

    (defn #_"int" Agent'releasePendingSends []
        (let [#_"IPersistentVector" ___sends (ß nested.get())]
            (when (nil? ___sends)
                (§ return 0)
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___sends.count()) [(inc ___i)]
                (let [#_"AgentAction" ___a (ß (AgentAction) ___sends.valAt(___i))]
                    (ß (:agent ___a).enqueue(___a))
                )
            )
            (ß nested.set(PersistentVector'EMPTY))
            (ß ___sends.count())
        )
    )
)
)

(java-ns cloiure.lang.AMapEntry

(§ import java.io.StringWriter)

#_stateless
#_abstract
(class-ns AMapEntry (§ extends APersistentVector) (§ implements IMapEntry)
    #_protected
    (defn #_"AMapEntry" AMapEntry'new []
        (APersistentVector'new)
    )

    #_method
    (§ defn #_"Object" nth [#_"AMapEntry" this, #_"int" ___i]
        (cond (ß ___i == 0)
            (do
                (ß key())
            )
            (ß ___i == 1)
            (do
                (ß val())
            )
            :else
            (do
                (throw (IndexOutOfBoundsException.))
            )
        )
    )

    #_method
    (§ defn- #_"IPersistentVector" asVector [#_"AMapEntry" this]
        (ß LazilyPersistentVector'createOwning(key(), val()))
    )

    #_method
    (§ defn #_"IPersistentVector" assocN [#_"AMapEntry" this, #_"int" ___i, #_"Object" ___val]
        (ß asVector().assocN(___i, ___val))
    )

    #_method
    (§ defn #_"int" count [#_"AMapEntry" this]
        2
    )

    #_method
    (§ defn #_"ISeq" seq [#_"AMapEntry" this]
        (ß asVector().seq())
    )

    #_method
    (§ defn #_"IPersistentVector" cons [#_"AMapEntry" this, #_"Object" ___o]
        (ß asVector().cons(___o))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"AMapEntry" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentStack" pop [#_"AMapEntry" this]
        (ß LazilyPersistentVector'createOwning(key()))
    )

    #_method
    (§ defn #_"Object" setValue [#_"AMapEntry" this, #_"Object" ___value]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.APersistentMap

(§ import java.util.*)

(class-ns KeySeq (§ extends ASeq)
    (defn #_"KeySeq" KeySeq'create [#_"ISeq" ___seq]
        (when (nil? ___seq)
            (§ return nil)
        )
        (KeySeq'new-2 ___seq, nil)
    )

    (defn #_"KeySeq" KeySeq'createFromMap [#_"IPersistentMap" ___map]
        (when (nil? ___map)
            (§ return nil)
        )
        (let [#_"ISeq" ___seq (ß ___map.seq())]
            (when (nil? ___seq)
                (§ return nil)
            )
            (KeySeq'new-2 ___seq, ___map)
        )
    )

    (defn- #_"KeySeq" KeySeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"KeySeq" KeySeq'new-2 [#_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new) (KeySeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    (defn- #_"KeySeq" KeySeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new ___meta) (KeySeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"KeySeq" this]
        (ß ((Map$Entry) (:seq this).first()).getKey())
    )

    #_method
    (§ defn #_"ISeq" next [#_"KeySeq" this]
        (ß create((:seq this).next()))
    )

    #_method
    (§ defn #_"KeySeq" withMeta [#_"KeySeq" this, #_"IPersistentMap" ___meta]
        (KeySeq'new-3 ___meta, (:seq this), (:iterable this))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"KeySeq" this]
        (when (nil? (:iterable this))
            (§ return (ß super.iterator()))
        )

        (when (ß (:iterable this) instanceof IMapIterable)
            (§ return (ß ((IMapIterable)this.iterable).keyIterator()))
        )

        (let [#_"Iterator" ___mapIter (ß (:iterable this).iterator())]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß ___mapIter.hasNext())
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (ß ((Map$Entry)___mapIter.next()).getKey())
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)

(class-ns ValSeq (§ extends ASeq)
    (defn #_"ValSeq" ValSeq'create [#_"ISeq" ___seq]
        (when (nil? ___seq)
            (§ return nil)
        )
        (ValSeq'new-2 ___seq, nil)
    )

    (defn #_"ValSeq" ValSeq'createFromMap [#_"IPersistentMap" ___map]
        (when (nil? ___map)
            (§ return nil)
        )
        (let [#_"ISeq" ___seq (ß ___map.seq())]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ValSeq'new-2 ___seq, ___map)
        )
    )

    (defn- #_"ValSeq" ValSeq'init []
        (hash-map
            #_"ISeq" :seq nil
            #_"Iterable" :iterable nil
        )
    )

    (defn- #_"ValSeq" ValSeq'new-2 [#_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new) (ValSeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    (defn- #_"ValSeq" ValSeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___seq, #_"Iterable" ___iterable]
        (let [this (merge (ASeq'new ___meta) (ValSeq'init))]
            (§ ass (:seq this) ___seq)
            (§ ass (:iterable this) ___iterable)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ValSeq" this]
        (ß ((Map$Entry) (:seq this).first()).getValue())
    )

    #_method
    (§ defn #_"ISeq" next [#_"ValSeq" this]
        (ß create((:seq this).next()))
    )

    #_method
    (§ defn #_"ValSeq" withMeta [#_"ValSeq" this, #_"IPersistentMap" ___meta]
        (ValSeq'new-3 ___meta, (:seq this), (:iterable this))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"ValSeq" this]
        (when (nil? (:iterable this))
            (§ return (ß super.iterator()))
        )

        (when (ß (:iterable this) instanceof IMapIterable)
            (§ return (ß ((IMapIterable)this.iterable).valIterator()))
        )

        (let [#_"Iterator" ___mapIter (ß (:iterable this).iterator())]
            (§ reify Iterator()
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß ___mapIter.hasNext())
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (ß ((Map$Entry)___mapIter.next()).getValue())
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )
)

#_abstract
(class-ns APersistentMap (§ extends AFn) (§ implements IPersistentMap, Map, Iterable, MapEquivalence, IHashEq)
    (defn- #_"APersistentMap" APersistentMap'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentMap" APersistentMap'new []
        (merge (AFn'new) (APersistentMap'init))
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentMap" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"IPersistentCollection" cons [#_"APersistentMap" this, #_"Object" ___o]
        (cond (ß ___o instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (§ return (ß assoc(___e.getKey(), ___e.getValue())))
                )
            )
            (ß ___o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
                    (when (ß ___v.count() != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß assoc(___v.nth(0), ___v.nth(1))))
                )
            )
        )

        (let [#_"IPersistentMap" ___ret this]
            (loop-when-recur [#_"ISeq" ___es (RT'seq ___o)] (some? ___es) [(ß ___es.next())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___es.first())]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentMap" this, #_"Object" ___obj]
        (ß mapEquals(this, ___obj))
    )

    (defn #_"boolean" APersistentMap'mapEquals [#_"IPersistentMap" ___m1, #_"Object" ___obj]
        (when (ß ___m1 == ___obj)
            (§ return true)
        )
        (when (ß !(___obj instanceof Map))
            (§ return false)
        )
        (let [#_"Map" ___m (ß (Map) ___obj)]
            (when (ß ___m.size() != ___m1.count())
                (§ return false)
            )

            (loop-when-recur [#_"ISeq" ___s (ß ___m1.seq())] (some? ___s) [(ß ___s.next())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___s.first())]
                    (let [#_"boolean" ___found (ß ___m.containsKey(___e.getKey()))]
                        (when (ß !___found || !Util'equals(___e.getValue(), ___m.get(___e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentMap" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Map))
            (§ return false)
        )
        (when (ß ___obj instanceof IPersistentMap && !(___obj instanceof MapEquivalence))
            (§ return false)
        )

        (let [#_"Map" ___m (ß (Map) ___obj)]
            (when (ß ___m.size() != size())
                (§ return false)
            )

            (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___s.first())]
                    (let [#_"boolean" ___found (ß ___m.containsKey(___e.getKey()))]
                        (when (ß !___found || !Util'equiv-2oo(___e.getValue(), ___m.get(___e.getKey())))
                            (§ return false)
                        )
                    )
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentMap" this]
        (let [#_"int" ___cached (:_hash this)]
            (when (ß ___cached == 0)
                (§ ass (:_hash this) (§ ass ___cached (ß mapHash(this))))
            )
            ___cached
        )
    )

    (defn #_"int" APersistentMap'mapHash [#_"IPersistentMap" ___m]
        (let [#_"int" ___hash 0]
            (loop-when-recur [#_"ISeq" ___s (ß ___m.seq())] (some? ___s) [(ß ___s.next())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___s.first())]
                    (§ ass ___hash (ß ___hash + (((___e.getKey() == nil) ? 0 :or ___e.getKey().hashCode()) :xor ((___e.getValue() == nil) ? 0 :or ___e.getValue().hashCode()))))
                )
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentMap" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (ß ___cached == 0)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashUnordered this)))
            )
            ___cached
        )
    )

    (defn #_"int" APersistentMap'mapHasheq [#_"IPersistentMap" ___m]
        (Murmur3'hashUnordered ___m)
    )

    (def #_"IFn" APersistentMap'MAKE_ENTRY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                (MapEntry'create ___key, ___val)
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_KEY
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                ___key
            )
        )
    )

    (def #_"IFn" APersistentMap'MAKE_VAL
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___key, #_"Object" ___val]
                ___val
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentMap" this, #_"Object" ___arg1]
        (ß valAt(___arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentMap" this, #_"Object" ___arg1, #_"Object" ___notFound]
        (ß valAt(___arg1, ___notFound))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentMap" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsValue [#_"APersistentMap" this, #_"Object" ___value]
        (ß values().contains(___value))
    )

    #_method
    (§ defn #_"Set" entrySet [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractSet" this]
                (ß (§ this APersistentMap).iterator())
            )

            #_method
            (§ defn #_"int" size [#_"AbstractSet" this]
                (ß count())
            )

            #_method
            (§ defn #_"int" hashCode [#_"AbstractSet" this]
                (ß (§ this APersistentMap).hashCode())
            )

            #_method
            (§ defn #_"boolean" contains [#_"AbstractSet" this, #_"Object" ___o]
                (when (ß ___o instanceof Entry)
                    (let [#_"Entry" ___e (ß (Entry) ___o)]
                        (let [#_"Entry" ___found (ß entryAt(___e.getKey()))]
                            (when (ß ___found != nil && Util'equals(___found.getValue(), ___e.getValue()))
                                (§ return true)
                            )
                        )
                    )
                )
                false
            )
        )
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentMap" this, #_"Object" ___key]
        (ß valAt(___key))
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentMap" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"Set" keySet [#_"APersistentMap" this]
        (§ reify AbstractSet()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractSet" this]
                (let [#_"Iterator" ___mi (ß (§ this APersistentMap).iterator())]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (ß ___mi.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [#_"Entry" ___e (ß (Entry) ___mi.next())]
                                (ß ___e.getKey())
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" size [#_"AbstractSet" this]
                (ß count())
            )

            #_method
            (§ defn #_"boolean" contains [#_"AbstractSet" this, #_"Object" ___o]
                (ß (§ this APersistentMap).containsKey(___o))
            )
        )
    )

    #_method
    (§ defn #_"Object" put [#_"APersistentMap" this, #_"Object" ___key, #_"Object" ___value]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" putAll [#_"APersistentMap" this, #_"Map" ___t]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"APersistentMap" this, #_"Object" ___key]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentMap" this]
        (ß count())
    )

    #_method
    (§ defn #_"Collection" values [#_"APersistentMap" this]
        (§ reify AbstractCollection()
            #_method
            (§ defn #_"Iterator" iterator [#_"AbstractCollection" this]
                (let [#_"Iterator" ___mi (ß (§ this APersistentMap).iterator())]
                    (§ reify Iterator()
                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (ß ___mi.hasNext())
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (let [#_"Entry" ___e (ß (Entry) ___mi.next())]
                                (ß ___e.getValue())
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
            )

            #_method
            (§ defn #_"int" size [#_"AbstractCollection" this]
                (ß count())
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentSet

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.Set)

#_abstract
(class-ns APersistentSet (§ extends AFn) (§ implements IPersistentSet, Collection, Set, IHashEq)
    (defn- #_"APersistentSet" APersistentSet'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
            #_"IPersistentMap" :impl nil
        )
    )

    #_protected
    (defn #_"APersistentSet" APersistentSet'new [#_"IPersistentMap" ___impl]
        (let [this (merge (AFn'new) (APersistentSet'init))]
            (§ ass (:impl this) ___impl)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentSet" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"boolean" contains [#_"APersistentSet" this, #_"Object" ___key]
        (ß (:impl this).containsKey(___key))
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentSet" this, #_"Object" ___key]
        (ß (:impl this).valAt(___key))
    )

    #_method
    (§ defn #_"int" count [#_"APersistentSet" this]
        (ß (:impl this).count())
    )

    #_method
    (§ defn #_"ISeq" seq [#_"APersistentSet" this]
        (RT'keys (:impl this))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentSet" this, #_"Object" ___arg1]
        (ß get(___arg1))
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentSet" this, #_"Object" ___obj]
        (APersistentSet'setEquals this, ___obj)
    )

    (defn #_"boolean" APersistentSet'setEquals [#_"IPersistentSet" ___s1, #_"Object" ___obj]
        (when (ß ___s1 == ___obj)
            (§ return true)
        )
        (when (ß !(___obj instanceof Set))
            (§ return false)
        )
        (let [#_"Set" ___m (ß (Set) ___obj)]
            (when (ß ___m.size() != ___s1.count())
                (§ return false)
            )

            (doseq [#_"Object" ___aM ___m]
                (when (ß !___s1.contains(___aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentSet" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Set))
            (§ return false)
        )

        (let [#_"Set" ___m (ß (Set) ___obj)]
            (when (ß ___m.size() != size())
                (§ return false)
            )

            (doseq [#_"Object" ___aM ___m]
                (when (ß !contains(___aM))
                    (§ return false)
                )
            )

            true
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentSet" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (ß ___hash == 0)
                (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
                    (let [#_"Object" ___e (ß ___s.first())]
                        (§ ass ___hash (ß ___hash + Util'hash(___e)))
                    )
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentSet" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (ß ___cached == 0)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashUnordered this)))
            )
            ___cached
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentSet" this]
        (ß RT'seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"APersistentSet" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"APersistentSet" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentSet" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"APersistentSet" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"APersistentSet" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß !contains(___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentSet" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentSet" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentSet" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"APersistentSet" this]
        (if (ß (:impl this) instanceof IMapIterable)
            (do
                (ß ((IMapIterable)this.impl).keyIterator())
            )
            (do
                (§ reify Iterator()
                    (§ init
                        (hash-map
                            #_"Iterator" :iter (ß (:impl this).iterator())
                        )
                    )

                    #_method
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        (ß (:iter this).hasNext())
                    )

                    #_method
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (ß ((IMapEntry)this.iter.next()).key())
                    )

                    #_method
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.APersistentVector

(§ import java.util.*)

(class-ns VSeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"VSeq" VSeq'init []
        (hash-map
            ;; todo - something more efficient
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"VSeq" VSeq'new-2 [#_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new) (VSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"VSeq" VSeq'new-3 [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (VSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"VSeq" this]
        (ß (:v this).nth((:i this)))
    )

    #_method
    (§ defn #_"ISeq" next [#_"VSeq" this]
        (when (ß (:i this) + 1 < (:v this).count())
            (§ return (ß VSeq'new-2((:v this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" index [#_"VSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" count [#_"VSeq" this]
        (ß (:v this).count() - (:i this))
    )

    #_method
    (§ defn #_"VSeq" withMeta [#_"VSeq" this, #_"IPersistentMap" ___meta]
        (VSeq'new-3 ___meta, (:v this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"VSeq" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:v this).nth((:i this)))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:v this).count()) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:v this).nth(___x))))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"VSeq" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:v this).nth((:i this))))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:v this).count()) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:v this).nth(___x))))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )
)

(class-ns RSeq (§ extends ASeq) (§ implements IndexedSeq, Counted)
    (defn- #_"RSeq" RSeq'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :i 0
        )
    )

    (defn #_"RSeq" RSeq'new-2 [#_"IPersistentVector" ___vector, #_"int" ___i]
        (let [this (merge (ASeq'new) (RSeq'init))]
            (§ ass (:v this) ___vector)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"RSeq" RSeq'new-3 [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (RSeq'init))]
            (§ ass (:v this) ___v)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"RSeq" this]
        (ß (:v this).nth((:i this)))
    )

    #_method
    (§ defn #_"ISeq" next [#_"RSeq" this]
        (when (> (:i this) 0)
            (§ return (ß RSeq'new-2((:v this), (:i this) - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" index [#_"RSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" count [#_"RSeq" this]
        (+ (:i this) 1)
    )

    #_method
    (§ defn #_"RSeq" withMeta [#_"RSeq" this, #_"IPersistentMap" ___meta]
        (RSeq'new-3 ___meta, (:v this), (:i this))
    )
)

(class-ns SubVector (§ extends APersistentVector) (§ implements IObj)
    (defn- #_"SubVector" SubVector'init []
        (hash-map
            #_"IPersistentVector" :v nil
            #_"int" :start 0
            #_"int" :end 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"SubVector" SubVector'new [#_"IPersistentMap" ___meta, #_"IPersistentVector" ___v, #_"int" ___start, #_"int" ___end]
        (let [this (merge (APersistentVector'new) (SubVector'init))]
            (§ ass (:_meta this) ___meta)

            (when (ß ___v instanceof SubVector)
                (let [#_"SubVector" ___sv (ß (SubVector) ___v)]
                    (§ ass ___start (ß ___start + (:start ___sv)))
                    (§ ass ___end (ß ___end + (:start ___sv)))
                    (§ ass ___v (:v ___sv))
                )
            )
            (§ ass (:v this) ___v)
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            this
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"SubVector" this]
        (when (ß (:v this) instanceof APersistentVector)
            (§ return (ß ((APersistentVector)this.v).rangedIterator((:start this), (:end this))))
        )
        (ß super.iterator())
    )

    #_method
    (§ defn #_"Object" nth [#_"SubVector" this, #_"int" ___i]
        (when (ß ((:start this) + ___i >= (:end this)) || (___i < 0))
            (throw (IndexOutOfBoundsException.))
        )
        (ß (:v this).nth((:start this) + ___i))
    )

    #_method
    (§ defn #_"IPersistentVector" assocN [#_"SubVector" this, #_"int" ___i, #_"Object" ___val]
        (cond (ß (:start this) + ___i > (:end this))
            (do
                (throw (IndexOutOfBoundsException.))
            )
            (ß (:start this) + ___i == (:end this))
            (do
                (§ return (ß cons(___val)))
            )
        )
        (ß SubVector'new((:_meta this), (:v this).assocN((:start this) + ___i, ___val), (:start this), (:end this)))
    )

    #_method
    (§ defn #_"int" count [#_"SubVector" this]
        (- (:end this) (:start this))
    )

    #_method
    (§ defn #_"IPersistentVector" cons [#_"SubVector" this, #_"Object" ___o]
        (ß SubVector'new((:_meta this), (:v this).assocN((:end this), ___o), (:start this), (:end this) + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"SubVector" this]
        (ß PersistentVector'EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"IPersistentStack" pop [#_"SubVector" this]
        (when (ß (:end this) - 1 == (:start this))
            (§ return PersistentVector'EMPTY)
        )
        (ß SubVector'new((:_meta this), (:v this), (:start this), (:end this) - 1))
    )

    #_method
    (§ defn #_"SubVector" withMeta [#_"SubVector" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (SubVector'new ___meta, (:v this), (:start this), (:end this))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"SubVector" this]
        (:_meta this)
    )
)

#_abstract
(class-ns APersistentVector (§ extends AFn) (§ implements IPersistentVector, Iterable, List, RandomAccess, Comparable, IHashEq)
    (defn- #_"APersistentVector" APersistentVector'init []
        (hash-map
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"APersistentVector" APersistentVector'new []
        (merge (AFn'new) (APersistentVector'init))
    )

    #_method
    (§ defn #_"String" toString [#_"APersistentVector" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"ISeq" seq [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (VSeq'new-2 this, 0))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (ß RSeq'new-2(this, count() - 1)))
        )
        nil
    )

    (defn #_"boolean" APersistentVector'doEquals [#_"IPersistentVector" ___v, #_"Object" ___obj]
        (cond (ß ___obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___ov (ß (IPersistentVector) ___obj)]
                    (when (ß ___ov.count() != ___v.count())
                        (§ return false)
                    )
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___v.count()) [(inc ___i)]
                        (when (ß !Util'equals(___v.nth(___i), ___ov.nth(___i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß ___obj instanceof List)
            (do
                (let [#_"Collection" ___ma (ß (Collection) ___obj)]
                    (when (ß ___ma.size() != ___v.count() || ___ma.hashCode() != ___v.hashCode())
                        (§ return false)
                    )
                    (loop-when-recur [#_"Iterator" ___i1 (ß ((List) ___v).iterator()) #_"Iterator" ___i2 (ß ___ma.iterator())] (ß ___i1.hasNext()) [___i1 ___i2]
                        (when (ß !Util'equals(___i1.next(), ___i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(___obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ___ms (RT'seq ___obj)]
                    (loop-when-recur [#_"int" ___i 0 ___ms ___ms] (ß ___i < ___v.count()) [(inc ___i) (ß ___ms.next())]
                        (when (ß ___ms == nil || !Util'equals(___v.nth(___i), ___ms.first()))
                            (§ return false)
                        )
                    )
                    (when (some? ___ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    (defn #_"boolean" APersistentVector'doEquiv [#_"IPersistentVector" ___v, #_"Object" ___obj]
        (cond (ß ___obj instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___ov (ß (IPersistentVector) ___obj)]
                    (when (ß ___ov.count() != ___v.count())
                        (§ return false)
                    )
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___v.count()) [(inc ___i)]
                        (when (ß !Util'equiv-2oo(___v.nth(___i), ___ov.nth(___i)))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            (ß ___obj instanceof List)
            (do
                (let [#_"Collection" ___ma (ß (Collection) ___obj)]
                    (when (ß ___ma.size() != ___v.count())
                        (§ return false)
                    )
                    (loop-when-recur [#_"Iterator" ___i1 (ß ((List) ___v).iterator()) #_"Iterator" ___i2 (ß ___ma.iterator())] (ß ___i1.hasNext()) [___i1 ___i2]
                        (when (ß !Util'equiv-2oo(___i1.next(), ___i2.next()))
                            (§ return false)
                        )
                    )
                    (§ return true)
                )
            )
            :else
            (do
                (when (ß !(___obj instanceof Sequential))
                    (§ return false)
                )
                (let [#_"ISeq" ___ms (RT'seq ___obj)]
                    (loop-when-recur [#_"int" ___i 0 ___ms ___ms] (ß ___i < ___v.count()) [(inc ___i) (ß ___ms.next())]
                        (when (ß ___ms == nil || !Util'equiv-2oo(___v.nth(___i), ___ms.first()))
                            (§ return false)
                        )
                    )
                    (when (some? ___ms)
                        (§ return false)
                    )
                )
            )
        )

        true
    )

    #_method
    (§ defn #_"boolean" equals [#_"APersistentVector" this, #_"Object" ___obj]
        (when (ß ___obj == this)
            (§ return true)
        )
        (ß doEquals(this, ___obj))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"APersistentVector" this, #_"Object" ___obj]
        (when (ß ___obj == this)
            (§ return true)
        )
        (APersistentVector'doEquiv this, ___obj)
    )

    #_method
    (§ defn #_"int" hashCode [#_"APersistentVector" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (ß ___hash == 0)
                (§ ass ___hash 1)
                (loop-when-recur [#_"int" ___i 0] (ß ___i < count()) [(inc ___i)]
                    (let [#_"Object" ___obj (ß nth(___i))]
                        (§ ass ___hash (ß 31 * ___hash + ((___obj == nil) ? 0 :or ___obj.hashCode())))
                    )
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"APersistentVector" this]
        (let [#_"int" ___hash (:_hasheq this)]
            (when (ß ___hash == 0)
                (§ let [#_"int" ___n]
                    (§ ass ___hash 1)

                    (loop-when-recur [___n 0] (ß ___n < count()) [(inc ___n)]
                        (§ ass ___hash (ß 31 * ___hash + Util'hasheq(nth(___n))))
                    )

                    (§ ass (:_hasheq this) (§ ass ___hash (Murmur3'mixCollHash ___hash, ___n)))
                )
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"Object" get [#_"APersistentVector" this, #_"int" ___index]
        (ß nth(___index))
    )

    #_method
    (§ defn #_"Object" nth [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < count())
            (§ return (ß nth(___i)))
        )
        ___notFound
    )

    #_method
    (§ defn #_"Object" remove [#_"APersistentVector" this, #_"int" ___i]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < count()) [(inc ___i)]
            (when (ß Util'equiv-2oo(nth(___i), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"int" ___i (ß count() - 1)] (ß ___i >= 0) [(dec ___i)]
            (when (ß Util'equiv-2oo(nth(___i), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"APersistentVector" this]
        (ß listIterator(0))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"APersistentVector" this, #_"int" ___index]
        (§ reify ListIterator()
            (let [#_"int" ___nexti ___index]
                #_method
                (§ defn #_"boolean" hasNext [#_"ListIterator" this]
                    (ß (___nexti < count()))
                )

                #_method
                (§ defn #_"Object" next [#_"ListIterator" this]
                    (if (ß ___nexti < count())
                        (let [_ (ß nth(___nexti))]
                            (§ ass ___nexti (inc ___nexti))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"boolean" hasPrevious [#_"ListIterator" this]
                    (ß (___nexti > 0))
                )

                #_method
                (§ defn #_"Object" previous [#_"ListIterator" this]
                    (if (> ___nexti 0)
                        (do
                            (§ ass ___nexti (dec ___nexti))
                            (ß nth(___nexti))
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"int" nextIndex [#_"ListIterator" this]
                    ___nexti
                )

                #_method
                (§ defn #_"int" previousIndex [#_"ListIterator" this]
                    (dec ___nexti)
                )

                #_method
                (§ defn #_"void" remove [#_"ListIterator" this]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" set [#_"ListIterator" this, #_"Object" ___o]
                    (throw (UnsupportedOperationException.))
                )

                #_method
                (§ defn #_"void" add [#_"ListIterator" this, #_"Object" ___o]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" rangedIterator [#_"APersistentVector" this, #_"int" ___start, #_"int" ___end]
        (§ reify Iterator()
            (let [#_"int" ___i ___start]
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß (___i < ___end))
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (if (< ___i ___end)
                        (let [_ (ß nth(___i))]
                            (§ ass ___i (inc ___i))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"List" subList [#_"APersistentVector" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß (List) RT'subvec(this, ___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" add [#_"APersistentVector" this, #_"int" ___i, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentVector" this, #_"int" ___i, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" invoke [#_"APersistentVector" this, #_"Object" ___arg1]
        (when (Util'isInteger ___arg1)
            (§ return (ß nth(((Number) ___arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"APersistentVector" this]
        ;; todo - something more efficient
        (§ reify Iterator()
            (let [#_"int" ___i 0]
                #_method
                (§ defn #_"boolean" hasNext [#_"Iterator" this]
                    (ß (___i < count()))
                )

                #_method
                (§ defn #_"Object" next [#_"Iterator" this]
                    (if (ß ___i < count())
                        (let [_ (ß nth(___i))]
                            (§ ass ___i (inc ___i))
                            _
                        )
                        (do
                            (throw (NoSuchElementException.))
                        )
                    )
                )

                #_method
                (§ defn #_"void" remove [#_"Iterator" this]
                    (throw (UnsupportedOperationException.))
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" peek [#_"APersistentVector" this]
        (when (ß count() > 0)
            (§ return (ß nth(count() - 1)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"APersistentVector" this, #_"Object" ___key]
        (when (ß !(Util'isInteger(___key)))
            (§ return false)
        )
        (let [#_"int" ___i (ß ((Number) ___key).intValue())]
            (ß (___i >= 0 && ___i < count()))
        )
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"APersistentVector" this, #_"Object" ___key]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (when (ß ___i >= 0 && ___i < count())
                    (§ return (ß (IMapEntry) MapEntry'create(___key, nth(___i))))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentVector" assoc [#_"APersistentVector" this, #_"Object" ___key, #_"Object" ___val]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (§ return (ß assocN(___i, ___val)))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" valAt [#_"APersistentVector" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (when (ß ___i >= 0 && ___i < count())
                    (§ return (ß nth(___i)))
                )
            )
        )
        ___notFound
    )

    #_method
    (§ defn #_"Object" valAt [#_"APersistentVector" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentVector" this]
        (let [#_"Object[]" ___ret (make-array Object (ß count()))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < count()) [(inc ___i)]
                (§ ass (ß ___ret[___i]) (ß nth(___i)))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" add [#_"APersistentVector" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"APersistentVector" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"APersistentVector" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"APersistentVector" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"APersistentVector" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß !contains(___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"APersistentVector" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"APersistentVector" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"APersistentVector" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"boolean" contains [#_"APersistentVector" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
            (when (ß Util'equiv-2oo(___s.first(), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"int" length [#_"APersistentVector" this]
        (ß count())
    )

    #_method
    (§ defn #_"int" compareTo [#_"APersistentVector" this, #_"Object" ___o]
        (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
            (cond (ß count() < ___v.count())
                (do
                    (§ return -1)
                )
                (ß count() > ___v.count())
                (do
                    (§ return 1)
                )
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < count()) [(inc ___i)]
                (let [#_"int" ___c (ß Util'compare(nth(___i), ___v.nth(___i)))]
                    (when (ß ___c != 0)
                        (§ return ___c)
                    )
                )
            )
            0
        )
    )
)
)

(java-ns cloiure.lang.ARef

(§ import java.util.Map)

#_abstract
(class-ns ARef (§ extends AReference) (§ implements IRef)
    (defn- #_"ARef" ARef'init []
        (hash-map
            #_protected
            #_volatile
            #_"IFn" :validator nil
            #_volatile
            #_"IPersistentMap" :watches PersistentHashMap'EMPTY
        )
    )

    (defn #_"ARef" ARef'new-0 []
        (merge (AReference'new) (ARef'init))
    )

    (defn #_"ARef" ARef'new-1 [#_"IPersistentMap" ___meta]
        (merge (AReference'new ___meta) (ARef'init))
    )

    #_method
    (§ defn #_"void" validate [#_"ARef" this, #_"IFn" ___vf, #_"Object" ___val]
        (try
            (when (ß ___vf != nil && !RT'booleanCast-1o(___vf.invoke(___val)))
                (throw (IllegalStateException. "Invalid reference state"))
            )
            (catch RuntimeException ___re
                (throw ___re)
            )
            (catch Exception ___e
                (throw (IllegalStateException. "Invalid reference state", ___e))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" validate [#_"ARef" this, #_"Object" ___val]
        (ß validate((:validator this), ___val))
        nil
    )

    #_method
    (§ defn #_"void" setValidator [#_"ARef" this, #_"IFn" ___vf]
        (ß validate(___vf, deref()))
        (§ ass (:validator this) ___vf)
        nil
    )

    #_method
    (§ defn #_"IFn" getValidator [#_"ARef" this]
        (:validator this)
    )

    #_method
    (§ defn #_"IPersistentMap" getWatches [#_"ARef" this]
        (:watches this)
    )

    #_method
    (§ defn #_"IRef" addWatch [#_"ARef" this, #_"Object" ___key, #_"IFn" ___callback]
        (§ sync this
            (§ ass (:watches this) (ß (:watches this).assoc(___key, ___callback)))
            this
        )
    )

    #_method
    (§ defn #_"IRef" removeWatch [#_"ARef" this, #_"Object" ___key]
        (§ sync this
            (§ ass (:watches this) (ß (:watches this).without(___key)))
            this
        )
    )

    #_method
    (§ defn #_"void" notifyWatches [#_"ARef" this, #_"Object" ___oldval, #_"Object" ___newval]
        (let [#_"IPersistentMap" ___ws (:watches this)]
            (when (ß ___ws.count() > 0)
                (loop-when-recur [#_"ISeq" ___s (ß ___ws.seq())] (some? ___s) [(ß ___s.next())]
                    (let [#_"Map$Entry" ___e (ß (Map$Entry) ___s.first())]
                        (let [#_"IFn" ___fn (ß (IFn) ___e.getValue())]
                            (when (some? ___fn)
                                (ß ___fn.invoke(___e.getKey(), this, ___oldval, ___newval))
                            )
                        )
                    )
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.AReference

(class-ns AReference (§ implements IReference)
    (defn- #_"AReference" AReference'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"AReference" AReference'new-0 []
        (AReference'new-1 nil)
    )

    (defn #_"AReference" AReference'new-1 [#_"IPersistentMap" ___meta]
        (let [this (AReference'init)]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"AReference" this]
        (§ sync this
            (:_meta this)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" alterMeta [#_"AReference" this, #_"IFn" ___alter, #_"ISeq" ___args]
        (§ sync this
            (§ ass (:_meta this) (ß (IPersistentMap) ___alter.applyTo(Cons'new-2((:_meta this), ___args))))
            (:_meta this)
        )
    )

    #_method
    (§ defn #_"IPersistentMap" resetMeta [#_"AReference" this, #_"IPersistentMap" ___m]
        (§ sync this
            (§ ass (:_meta this) ___m)
            ___m
        )
    )
)
)

(java-ns cloiure.lang.ArityException

(class-ns ArityException (§ extends IllegalArgumentException)
    (defn- #_"ArityException" ArityException'init []
        (hash-map
            #_"int" :actual 0
            #_"String" :name nil
        )
    )

    (defn #_"ArityException" ArityException'new-2 [#_"int" ___actual, #_"String" ___name]
        (ArityException'new-3 ___actual, ___name, nil)
    )

    (defn #_"ArityException" ArityException'new-3 [#_"int" ___actual, #_"String" ___name, #_"Throwable" ___cause]
        (let [this (merge (§ foreign IllegalArgumentException'new (str "Wrong number of args (" ___actual ") passed to: " ___name), ___cause) (ArityException'init))]
            (§ ass (:actual this) ___actual)
            (§ ass (:name this) ___name)
            this
        )
    )
)
)

(java-ns cloiure.lang.ArrayChunk

(class-ns ArrayChunk (§ implements IChunk)
    (defn- #_"ArrayChunk" ArrayChunk'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :off 0
            #_"int" :end 0
        )
    )

    (defn #_"ArrayChunk" ArrayChunk'new-1 [#_"Object[]" ___array]
        (ArrayChunk'new-3 ___array, 0, (ß ___array.length))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-2 [#_"Object[]" ___array, #_"int" ___off]
        (ArrayChunk'new-3 ___array, ___off, (ß ___array.length))
    )

    (defn #_"ArrayChunk" ArrayChunk'new-3 [#_"Object[]" ___array, #_"int" ___off, #_"int" ___end]
        (let [this (ArrayChunk'init)]
            (§ ass (:array this) ___array)
            (§ ass (:off this) ___off)
            (§ ass (:end this) ___end)
            this
        )
    )

    #_method
    (§ defn #_"Object" nth [#_"ArrayChunk" this, #_"int" ___i]
        (ß (:array this)[(:off this) + ___i])
    )

    #_method
    (§ defn #_"Object" nth [#_"ArrayChunk" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < count())
            (§ return (ß nth(___i)))
        )
        ___notFound
    )

    #_method
    (§ defn #_"int" count [#_"ArrayChunk" this]
        (- (:end this) (:off this))
    )

    #_method
    (§ defn #_"IChunk" dropFirst [#_"ArrayChunk" this]
        (when (ß (:off this) == (:end this))
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß ArrayChunk'new-3((:array this), (:off this) + 1, (:end this)))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArrayChunk" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:off this)]))]
            (when (RT'isReduced ___ret)
                (§ return ___ret)
            )
            (loop-when-recur [#_"int" ___x (+ (:off this) 1)] (< ___x (:end this)) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return ___ret)
                )
            )
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.ArrayIter

(§ import java.lang.reflect.Array)
(§ import java.util.Iterator)

(class-ns ArrayIter_int (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_int" ArrayIter_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_int" ArrayIter_int'new [#_"int[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_int'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_int" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Long" next [#_"ArrayIter_int" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_int" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_float (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_float" ArrayIter_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_float" ArrayIter_float'new [#_"float[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_float'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_float" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Double" next [#_"ArrayIter_float" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Double/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_float" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_double (§ implements Iterator<Double>)
    (defn- #_"ArrayIter_double" ArrayIter_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_double" ArrayIter_double'new [#_"double[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_double'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_double" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Double" next [#_"ArrayIter_double" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß (:array this)[(:i this)])]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_double" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_long (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_long" ArrayIter_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_long" ArrayIter_long'new [#_"long[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_long'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_long" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Long" next [#_"ArrayIter_long" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_long" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_byte (§ implements Iterator<Byte>)
    (defn- #_"ArrayIter_byte" ArrayIter_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_byte" ArrayIter_byte'new [#_"byte[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_byte'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_byte" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Byte" next [#_"ArrayIter_byte" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß (:array this)[(:i this)])]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_byte" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_char (§ implements Iterator<Character>)
    (defn- #_"ArrayIter_char" ArrayIter_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_char" ArrayIter_char'new [#_"char[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_char'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_char" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Character" next [#_"ArrayIter_char" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß (:array this)[(:i this)])]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_char" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_short (§ implements Iterator<Long>)
    (defn- #_"ArrayIter_short" ArrayIter_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_short" ArrayIter_short'new [#_"short[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_short'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_short" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Long" next [#_"ArrayIter_short" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Long/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_short" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter_boolean (§ implements Iterator<Boolean>)
    (defn- #_"ArrayIter_boolean" ArrayIter_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter_boolean" ArrayIter_boolean'new [#_"boolean[]" ___array, #_"int" ___i]
        (let [this (ArrayIter_boolean'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter_boolean" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Boolean" next [#_"ArrayIter_boolean" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß Boolean/valueOf((:array this)[(:i this)]))]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter_boolean" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)

(class-ns ArrayIter (§ implements Iterator)
    (def #_"Iterator" ArrayIter'EMPTY_ITERATOR
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (java.util.NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException. "remove() not supported"))
            )
        )
    )

    (defn #_"Iterator" ArrayIter'create-0 []
        ArrayIter'EMPTY_ITERATOR
    )

    (defn #_"Iterator" ArrayIter'create-1 [#_"Object..." ___array]
        (when (ß ___array == nil || ___array.length == 0)
            (§ return ArrayIter'EMPTY_ITERATOR)
        )
        (ArrayIter'new ___array, 0)
    )

    (defn #_"Iterator" ArrayIter'createFromObject [#_"Object" ___array]
        (when (ß ___array == nil || Array/getLength(___array) == 0)
            (§ return ArrayIter'EMPTY_ITERATOR)
        )
        (let [#_"Class" ___aclass (ß ___array.getClass())]
            (when (ß ___aclass == (§ class int[]))
                (§ return (ß ArrayIter_int'new((int[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class float[]))
                (§ return (ß ArrayIter_float'new((float[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class double[]))
                (§ return (ß ArrayIter_double'new((double[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class long[]))
                (§ return (ß ArrayIter_long'new((long[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class byte[]))
                (§ return (ß ArrayIter_byte'new((byte[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class char[]))
                (§ return (ß ArrayIter_char'new((char[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class short[]))
                (§ return (ß ArrayIter_short'new((short[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class boolean[]))
                (§ return (ß ArrayIter_boolean'new((boolean[]) ___array, 0)))
            )
            (ArrayIter'new ___array, 0)
        )
    )

    (defn- #_"ArrayIter" ArrayIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArrayIter" ArrayIter'new [#_"Object" ___array, #_"int" ___i]
        (let [this (ArrayIter'init)]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ArrayIter" this]
        (ß ((:array this) != nil && (:i this) < (:array this).length))
    )

    #_method
    (§ defn #_"Object" next [#_"ArrayIter" this]
        (when (ß (:array this) != nil && (:i this) < (:array this).length)
            (let [_ (ß (:array this)[(:i this)])]
                (§ ass (:i this) (+ (:i this) 1))
                (§ return _)
            )
        )
        (throw (java.util.NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"ArrayIter" this]
        (throw (UnsupportedOperationException. "remove() not supported"))
    )
)
)

(java-ns cloiure.lang.ArraySeq

(§ import java.lang.reflect.Array)

(class-ns ArraySeq_int (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_int" ArraySeq_int'init []
        (hash-map
            #_"int[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_int" ArraySeq_int'new [#_"IPersistentMap" ___meta, #_"int[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_int'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_int" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_int" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_int'new(meta(), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_int" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_int" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_int" withMeta [#_"ArraySeq_int" this, #_"IPersistentMap" ___meta]
        (ArraySeq_int'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_int" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_int" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_int" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"int" ___k (ß ((Number) ___o).intValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___k == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_int" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"int" ___k (ß ((Number) ___o).intValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___k == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_float (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_float" ArraySeq_float'init []
        (hash-map
            #_"float[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_float" ArraySeq_float'new [#_"IPersistentMap" ___meta, #_"float[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_float'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_float" this]
        (ß Numbers'num-1f((:array this)[(:i this)]))
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_float" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_float'new(meta(), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_float" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_float" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_float" withMeta [#_"ArraySeq_float" this, #_"IPersistentMap" ___meta]
        (ArraySeq_float'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_float" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß Numbers'num-1f((:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1f((:array this)[___x]))))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_float" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, Numbers'num-1f((:array this)[(:i this)])))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1f((:array this)[___x]))))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_float" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"float" ___f (ß ((Number) ___o).floatValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___f == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_float" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"float" ___f (ß ((Number) ___o).floatValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___f == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        -1
    )
)

(class-ns ArraySeq_double (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_double" ArraySeq_double'init []
        (hash-map
            #_"double[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_double" ArraySeq_double'new [#_"IPersistentMap" ___meta, #_"double[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_double'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_double" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_double" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_double'new(meta(), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_double" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_double" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_double" withMeta [#_"ArraySeq_double" this, #_"IPersistentMap" ___meta]
        (ArraySeq_double'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_double" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_double" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_double" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"double" ___d (ß ((Number) ___o).doubleValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___d == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_double" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"double" ___d (ß ((Number) ___o).doubleValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___d == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_long (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_long" ArraySeq_long'init []
        (hash-map
            #_"long[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_long" ArraySeq_long'new [#_"IPersistentMap" ___meta, #_"long[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_long'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_long" this]
        (ß Numbers'num-1l((:array this)[(:i this)]))
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_long" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_long'new(meta(), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_long" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_long" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_long" withMeta [#_"ArraySeq_long" this, #_"IPersistentMap" ___meta]
        (ArraySeq_long'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_long" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß Numbers'num-1l((:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1l((:array this)[___x]))))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_long" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, Numbers'num-1l((:array this)[(:i this)])))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, Numbers'num-1l((:array this)[___x]))))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_long" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"long" ___l (ß ((Number) ___o).longValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___l == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_long" this, #_"Object" ___o]
        (when (ß ___o instanceof Number)
            (let [#_"long" ___l (ß ((Number) ___o).longValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___l == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )

        -1
    )
)

(class-ns ArraySeq_byte (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_byte" ArraySeq_byte'init []
        (hash-map
            #_"byte[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_byte" ArraySeq_byte'new [#_"IPersistentMap" ___meta, #_"byte[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_byte'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_byte" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_byte" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_byte'new(meta(), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_byte" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_byte" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_byte" withMeta [#_"ArraySeq_byte" this, #_"IPersistentMap" ___meta]
        (ArraySeq_byte'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_byte" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_byte" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_byte" this, #_"Object" ___o]
        (when (ß ___o instanceof Byte)
            (let [#_"byte" ___b (ß ((Byte) ___o).byteValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_byte" this, #_"Object" ___o]
        (when (ß ___o instanceof Byte)
            (let [#_"byte" ___b (ß ((Byte) ___o).byteValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_char (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_char" ArraySeq_char'init []
        (hash-map
            #_"char[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_char" ArraySeq_char'new [#_"IPersistentMap" ___meta, #_"char[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_char'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_char" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_char" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_char'new(meta(), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_char" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_char" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_char" withMeta [#_"ArraySeq_char" this, #_"IPersistentMap" ___meta]
        (ArraySeq_char'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_char" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_char" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_char" this, #_"Object" ___o]
        (when (ß ___o instanceof Character)
            (let [#_"char" ___c (ß ((Character) ___o).charValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___c == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_char" this, #_"Object" ___o]
        (when (ß ___o instanceof Character)
            (let [#_"char" ___c (ß ((Character) ___o).charValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___c == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_short (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_short" ArraySeq_short'init []
        (hash-map
            #_"short[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_short" ArraySeq_short'new [#_"IPersistentMap" ___meta, #_"short[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_short'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_short" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_short" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_short'new(meta(), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_short" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_short" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_short" withMeta [#_"ArraySeq_short" this, #_"IPersistentMap" ___meta]
        (ArraySeq_short'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_short" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_short" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_short" this, #_"Object" ___o]
        (when (ß ___o instanceof Short)
            (let [#_"short" ___s (ß ((Short) ___o).shortValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___s == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_short" this, #_"Object" ___o]
        (when (ß ___o instanceof Short)
            (let [#_"short" ___s (ß ((Short) ___o).shortValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___s == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq_boolean (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn- #_"ArraySeq_boolean" ArraySeq_boolean'init []
        (hash-map
            #_"boolean[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq_boolean" ArraySeq_boolean'new [#_"IPersistentMap" ___meta, #_"boolean[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq_boolean'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq_boolean" this]
        (ß (:array this)[(:i this)])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq_boolean" this]
        (when (ß (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq_boolean'new(meta(), (:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq_boolean" this]
        (ß (:array this).length - (:i this))
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq_boolean" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq_boolean" withMeta [#_"ArraySeq_boolean" this, #_"IPersistentMap" ___meta]
        (ArraySeq_boolean'new ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_boolean" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq_boolean" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
            (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq_boolean" this, #_"Object" ___o]
        (when (ß ___o instanceof Boolean)
            (let [#_"boolean" ___b (ß ((Boolean) ___o).booleanValue())]
                (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq_boolean" this, #_"Object" ___o]
        (when (ß ___o instanceof Boolean)
            (let [#_"boolean" ___b (ß ((Boolean) ___o).booleanValue())]
                (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                    (when (ß ___b == (:array this)[___j])
                        (§ return (- ___j (:i this)))
                    )
                )
            )
        )
        (when (nil? ___o)
            (§ return -1)
        )
        (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
            (when (ß ___o.equals((:array this)[___j]))
                (§ return (- ___j (:i this)))
            )
        )
        -1
    )
)

(class-ns ArraySeq (§ extends ASeq) (§ implements IndexedSeq, IReduce)
    (defn #_"ArraySeq" ArraySeq'create-0 []
        nil
    )

    (defn #_"ArraySeq" ArraySeq'create-1 [#_"Object..." ___array]
        (when (ß ___array == nil || ___array.length == 0)
            (§ return nil)
        )
        (ArraySeq'new-2 ___array, 0)
    )

    (defn #_"ISeq" ArraySeq'createFromObject [#_"Object" ___array]
        (when (ß ___array == nil || Array/getLength(___array) == 0)
            (§ return nil)
        )
        (let [#_"Class" ___aclass (ß ___array.getClass())]
            (when (ß ___aclass == (§ class int[]))
                (§ return (ß ArraySeq_int'new(nil, (int[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class float[]))
                (§ return (ß ArraySeq_float'new(nil, (float[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class double[]))
                (§ return (ß ArraySeq_double'new(nil, (double[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class long[]))
                (§ return (ß ArraySeq_long'new(nil, (long[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class byte[]))
                (§ return (ß ArraySeq_byte'new(nil, (byte[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class char[]))
                (§ return (ß ArraySeq_char'new(nil, (char[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class short[]))
                (§ return (ß ArraySeq_short'new(nil, (short[]) ___array, 0)))
            )
            (when (ß ___aclass == (§ class boolean[]))
                (§ return (ß ArraySeq_boolean'new(nil, (boolean[]) ___array, 0)))
            )
            (ArraySeq'new-2 ___array, 0)
        )
    )

    (defn- #_"ArraySeq" ArraySeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-2 [#_"Object" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new) (ArraySeq'init))]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    (defn #_"ArraySeq" ArraySeq'new-3 [#_"IPersistentMap" ___meta, #_"Object" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (ArraySeq'init))]
            (§ ass (:i this) ___i)
            (§ ass (:array this) (ß (Object[]) ___array))
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"ArraySeq" this]
        (when (some? (:array this))
            (§ return (ß (:array this)[(:i this)]))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" next [#_"ArraySeq" this]
        (when (ß (:array this) != nil && (:i this) + 1 < (:array this).length)
            (§ return (ß ArraySeq'new-2((:array this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"ArraySeq" this]
        (when (some? (:array this))
            (§ return (ß (:array this).length - (:i this)))
        )
        0
    )

    #_method
    (§ defn #_"int" index [#_"ArraySeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"ArraySeq" withMeta [#_"ArraySeq" this, #_"IPersistentMap" ___meta]
        (ArraySeq'new-3 ___meta, (:array this), (:i this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq" this, #_"IFn" ___f]
        (when (some? (:array this))
            (let [#_"Object" ___ret (ß (:array this)[(:i this)])]
                (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                    (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                    (when (RT'isReduced ___ret)
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                )
                (§ return ___ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" reduce [#_"ArraySeq" this, #_"IFn" ___f, #_"Object" ___start]
        (when (some? (:array this))
            (let [#_"Object" ___ret (ß ___f.invoke(___start, (:array this)[(:i this)]))]
                (loop-when-recur [#_"int" ___x (+ (:i this) 1)] (ß ___x < (:array this).length) [(inc ___x)]
                    (when (RT'isReduced ___ret)
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                    (§ ass ___ret (ß ___f.invoke(___ret, (:array this)[___x])))
                )
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ return ___ret)
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" indexOf [#_"ArraySeq" this, #_"Object" ___o]
        (when (some? (:array this))
            (loop-when-recur [#_"int" ___j (:i this)] (ß ___j < (:array this).length) [(inc ___j)]
                (when (ß Util'equals(___o, (:array this)[___j]))
                    (§ return (- ___j (:i this)))
                )
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ArraySeq" this, #_"Object" ___o]
        (when (some? (:array this))
            (if (nil? ___o)
                (do
                    (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                        (when (ß (:array this)[___j] == nil)
                            (§ return (- ___j (:i this)))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"int" ___j (ß (:array this).length - 1)] (ß ___j >= (:i this)) [(dec ___j)]
                        (when (ß ___o.equals((:array this)[___j]))
                            (§ return (- ___j (:i this)))
                        )
                    )
                )
            )
        )
        -1
    )
)
)

(java-ns cloiure.lang.ASeq

(§ import java.util.*)

#_abstract
(class-ns ASeq (§ extends Obj) (§ implements ISeq, Sequential, List, IHashEq)
    (defn- #_"ASeq" ASeq'init []
        (hash-map
            #_transient
            #_"int" :_hash 0
            #_transient
            #_"int" :_hasheq 0
        )
    )

    #_protected
    (defn #_"ASeq" ASeq'new-1 [#_"IPersistentMap" ___meta]
        (merge (Obj'new ___meta) (ASeq'init))
    )

    #_protected
    (defn #_"ASeq" ASeq'new-0 []
        (merge (Obj'new) (ASeq'init))
    )

    #_method
    (§ defn #_"String" toString [#_"ASeq" this]
        (RT'printString this)
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"ASeq" this]
        PersistentList'EMPTY
    )

    #_method
    (§ defn #_"boolean" equiv [#_"ASeq" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Sequential || ___obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (ß seq()) ___ms ___ms] (some? ___s) [(ß ___s.next()) (ß ___ms.next())]
                (when (ß ___ms == nil || !Util'equiv-2oo(___s.first(), ___ms.first()))
                    (§ return false)
                )
            )
            (ß (___ms == nil))
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"ASeq" this, #_"Object" ___obj]
        (when (ß this == ___obj)
            (§ return true)
        )
        (when (ß !(___obj instanceof Sequential || ___obj instanceof List))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (ß seq()) ___ms ___ms] (some? ___s) [(ß ___s.next()) (ß ___ms.next())]
                (when (ß ___ms == nil || !Util'equals(___s.first(), ___ms.first()))
                    (§ return false)
                )
            )
            (ß (___ms == nil))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"ASeq" this]
        (when (ß (:_hash this) == 0)
            (let [#_"int" ___hash 1]
                (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
                    (§ ass ___hash (ß 31 * ___hash + ((___s.first() == nil) ? 0 :or ___s.first().hashCode())))
                )
                (§ ass (:_hash this) ___hash)
            )
        )
        (:_hash this)
    )

    #_method
    (§ defn #_"int" hasheq [#_"ASeq" this]
        (when (ß (:_hasheq this) == 0)
            (§ ass (:_hasheq this) (Murmur3'hashOrdered this))
        )
        (:_hasheq this)
    )

    #_method
    (§ defn #_"int" count [#_"ASeq" this]
        (let [#_"int" ___i 1]
            (loop-when-recur [#_"ISeq" ___s (ß next()) ___i ___i] (some? ___s) [(ß ___s.next()) (inc ___i)]
                (when (ß ___s instanceof Counted)
                    (§ return (ß ___i + ___s.count()))
                )
            )
            ___i
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"ASeq" this]
        this
    )

    #_method
    (§ defn #_"ISeq" cons [#_"ASeq" this, #_"Object" ___o]
        (Cons'new-2 ___o, this)
    )

    #_method
    (§ defn #_"ISeq" more [#_"ASeq" this]
        (let [#_"ISeq" ___s (ß next())]
            (when (nil? ___s)
                (§ return PersistentList'EMPTY)
            )
            ___s
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"ASeq" this]
        (ß RT'seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"ASeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"ASeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"ASeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"ASeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"ASeq" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß !contains(___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"ASeq" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"ASeq" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"ASeq" this]
        (ß (seq() == nil))
    )

    #_method
    (§ defn #_"boolean" contains [#_"ASeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
            (when (ß Util'equiv-2oo(___s.first(), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"ASeq" this]
        (SeqIterator'new this)
    )

    #_method
    (§ defn- #_"List" reify [#_"ASeq" this]
        (Collections/unmodifiableList (ArrayList. this))
    )

    #_method
    (§ defn #_"List" subList [#_"ASeq" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß reify().subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"ASeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"ASeq" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"ASeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (ß seq()) #_"int" ___i 0] (some? ___s) [(ß ___s.next()) (inc ___i)]
            (when (ß Util'equiv-2oo(___s.first(), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"ASeq" this, #_"Object" ___o]
        (ß reify().lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"ASeq" this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"ASeq" this, #_"int" ___index]
        (ß reify().listIterator(___index))
    )

    #_method
    (§ defn #_"Object" get [#_"ASeq" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" add [#_"ASeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"ASeq" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Associative

(defprotocol Associative #_(§ extends IPersistentCollection, ILookup)
    #_abstract
    (#_"boolean" Associative'''containsKey [#_"Associative" this, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" Associative'''entryAt [#_"Associative" this, #_"Object" ___key])
    #_abstract
    (#_"Associative" Associative'''assoc [#_"Associative" this, #_"Object" ___key, #_"Object" ___val])
)
)

(java-ns cloiure.lang.Atom

(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Atom (§ extends ARef) (§ implements IAtom2)
    (defn- #_"Atom" Atom'init []
        (hash-map
            #_"AtomicReference" :state nil
        )
    )

    (defn #_"Atom" Atom'new-1 [#_"Object" ___state]
        (let [this (merge (ARef'new-0) (Atom'init))]
            (§ ass (:state this) (AtomicReference. ___state))
            this
        )
    )

    (defn #_"Atom" Atom'new-2 [#_"Object" ___state, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Atom'init))]
            (§ ass (:state this) (AtomicReference. ___state))
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Atom" this]
        (ß (:state this).get())
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" ___f]
        (while true
            (let [#_"Object" ___v (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___v))]
                    (ß validate(___newv))
                    (when (ß (:state this).compareAndSet(___v, ___newv))
                        (ß notifyWatches(___v, ___newv))
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg]
        (while true
            (let [#_"Object" ___v (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___v, ___arg))]
                    (ß validate(___newv))
                    (when (ß (:state this).compareAndSet(___v, ___newv))
                        (ß notifyWatches(___v, ___newv))
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2]
        (while true
            (let [#_"Object" ___v (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___v, ___arg1, ___arg2))]
                    (ß validate(___newv))
                    (when (ß (:state this).compareAndSet(___v, ___newv))
                        (ß notifyWatches(___v, ___newv))
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" swap [#_"Atom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args]
        (while true
            (let [#_"Object" ___v (ß deref())]
                (let [#_"Object" ___newv (ß ___f.applyTo(RT'listStar-4(___v, ___x, ___y, ___args)))]
                    (ß validate(___newv))
                    (when (ß (:state this).compareAndSet(___v, ___newv))
                        (ß notifyWatches(___v, ___newv))
                        (§ return ___newv)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" ___f]
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___oldv))]
                    (ß validate(___newv))
                    (when (ß (:state this).compareAndSet(___oldv, ___newv))
                        (ß notifyWatches(___oldv, ___newv))
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg]
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___oldv, ___arg))]
                    (ß validate(___newv))
                    (when (ß (:state this).compareAndSet(___oldv, ___newv))
                        (ß notifyWatches(___oldv, ___newv))
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2]
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (let [#_"Object" ___newv (ß ___f.invoke(___oldv, ___arg1, ___arg2))]
                    (ß validate(___newv))
                    (when (ß (:state this).compareAndSet(___oldv, ___newv))
                        (ß notifyWatches(___oldv, ___newv))
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IPersistentVector" swapVals [#_"Atom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args]
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (let [#_"Object" ___newv (ß ___f.applyTo(RT'listStar-4(___oldv, ___x, ___y, ___args)))]
                    (ß validate(___newv))
                    (when (ß (:state this).compareAndSet(___oldv, ___newv))
                        (ß notifyWatches(___oldv, ___newv))
                        (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" compareAndSet [#_"Atom" this, #_"Object" ___oldv, #_"Object" ___newv]
        (ß validate(___newv))
        (let [#_"boolean" ___ret (ß (:state this).compareAndSet(___oldv, ___newv))]
            (when ___ret
                (ß notifyWatches(___oldv, ___newv))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reset [#_"Atom" this, #_"Object" ___newval]
        (let [#_"Object" ___oldval (ß (:state this).get())]
            (ß validate(___newval))
            (ß (:state this).set(___newval))
            (ß notifyWatches(___oldval, ___newval))
            ___newval
        )
    )

    #_method
    (§ defn #_"IPersistentVector" resetVals [#_"Atom" this, #_"Object" ___newv]
        (ß validate(___newv))
        (while true
            (let [#_"Object" ___oldv (ß deref())]
                (when (ß (:state this).compareAndSet(___oldv, ___newv))
                    (ß notifyWatches(___oldv, ___newv))
                    (§ return (LazilyPersistentVector'createOwning ___oldv, ___newv))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ATransientMap

(§ import java.util.Map)

#_stateless
#_abstract
(class-ns ATransientMap (§ extends AFn) (§ implements ITransientMap, ITransientAssociative2)
    #_protected
    (defn #_"ATransientMap" ATransientMap'new []
        (AFn'new)
    )

    #_abstract
    (§ defn #_"void" ensureEditable [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"ITransientMap" doAssoc [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (§ defn #_"ITransientMap" doWithout [#_"ATransientMap" this, #_"Object" ___key])
    #_abstract
    (§ defn #_"Object" doValAt [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___notFound])
    #_abstract
    (§ defn #_"int" doCount [#_"ATransientMap" this])
    #_abstract
    (§ defn #_"IPersistentMap" doPersistent [#_"ATransientMap" this])

    #_method
    (§ defn #_"ITransientMap" conj [#_"ATransientMap" this, #_"Object" ___o]
        (ß ensureEditable())
        (cond (ß ___o instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (§ return (ß assoc(___e.getKey(), ___e.getValue())))
                )
            )
            (ß ___o instanceof IPersistentVector)
            (do
                (let [#_"IPersistentVector" ___v (ß (IPersistentVector) ___o)]
                    (when (ß ___v.count() != 2)
                        (throw (IllegalArgumentException. "Vector arg to map conj must be a pair"))
                    )
                    (§ return (ß assoc(___v.nth(0), ___v.nth(1))))
                )
            )
        )

        (let [#_"ITransientMap" ___ret this]
            (loop-when-recur [#_"ISeq" ___es (RT'seq ___o)] (some? ___es) [(ß ___es.next())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___es.first())]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientMap" this, #_"Object" ___arg1]
        (ß valAt(___arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientMap" this, #_"Object" ___arg1, #_"Object" ___notFound]
        (ß valAt(___arg1, ___notFound))
    )

    #_method
    (§ defn #_"Object" valAt [#_"ATransientMap" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"ITransientMap" assoc [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___val]
        (ß ensureEditable())
        (ß doAssoc(___key, ___val))
    )

    #_method
    (§ defn #_"ITransientMap" without [#_"ATransientMap" this, #_"Object" ___key]
        (ß ensureEditable())
        (ß doWithout(___key))
    )

    #_method
    (§ defn #_"IPersistentMap" persistent [#_"ATransientMap" this]
        (ß ensureEditable())
        (ß doPersistent())
    )

    #_method
    (§ defn #_"Object" valAt [#_"ATransientMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (ß ensureEditable())
        (ß doValAt(___key, ___notFound))
    )

    (def- #_"Object" ATransientMap'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" containsKey [#_"ATransientMap" this, #_"Object" ___key]
        (ß (valAt(___key, ATransientMap'NOT_FOUND) != ATransientMap'NOT_FOUND))
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"ATransientMap" this, #_"Object" ___key]
        (let [#_"Object" ___v (ß valAt(___key, ATransientMap'NOT_FOUND))]
            (when (ß ___v != ATransientMap'NOT_FOUND)
                (§ return (MapEntry'create ___key, ___v))
            )
            nil
        )
    )

    #_method
    (§ defn #_"int" count [#_"ATransientMap" this]
        (ß ensureEditable())
        (ß doCount())
    )
)
)

(java-ns cloiure.lang.ATransientSet

#_abstract
(class-ns ATransientSet (§ extends AFn) (§ implements ITransientSet)
    (defn- #_"ATransientSet" ATransientSet'init []
        (hash-map
            #_volatile
            #_"ITransientMap" :impl nil
        )
    )

    (defn #_"ATransientSet" ATransientSet'new [#_"ITransientMap" ___impl]
        (let [this (merge (AFn'new) (ATransientSet'init))]
            (§ ass (:impl this) ___impl)
            this
        )
    )

    #_method
    (§ defn #_"int" count [#_"ATransientSet" this]
        (ß (:impl this).count())
    )

    #_method
    (§ defn #_"ITransientSet" conj [#_"ATransientSet" this, #_"Object" ___val]
        (let [#_"ITransientMap" ___m (ß (:impl this).assoc(___val, ___val))]
            (when (ß ___m != (:impl this))
                (§ ass (:impl this) ___m)
            )
            this
        )
    )

    #_method
    (§ defn #_"boolean" contains [#_"ATransientSet" this, #_"Object" ___key]
        (ß (this != (:impl this).valAt(___key, this)))
    )

    #_method
    (§ defn #_"ITransientSet" disjoin [#_"ATransientSet" this, #_"Object" ___key]
        (let [#_"ITransientMap" ___m (ß (:impl this).without(___key))]
            (when (ß ___m != (:impl this))
                (§ ass (:impl this) ___m)
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" get [#_"ATransientSet" this, #_"Object" ___key]
        (ß (:impl this).valAt(___key))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientSet" this, #_"Object" ___key, #_"Object" ___notFound]
        (ß (:impl this).valAt(___key, ___notFound))
    )

    #_method
    (§ defn #_"Object" invoke [#_"ATransientSet" this, #_"Object" ___key]
        (ß (:impl this).valAt(___key))
    )
)
)

(java-ns cloiure.lang.BigInt

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)

(class-ns BigInt (§ extends Number) (§ implements IHashEq)
    (§ def #_"BigInt" BigInt'ZERO (BigInt'new 0, nil))
    (§ def #_"BigInt" BigInt'ONE (BigInt'new 1, nil))

    (defn- #_"BigInt" BigInt'init []
        (hash-map
            #_"long" :lpart 0
            #_"BigInteger" :bipart nil
        )
    )

    (defn- #_"BigInt" BigInt'new [#_"long" ___lpart, #_"BigInteger" ___bipart]
        (let [this (merge (Number'new) (BigInt'init))]
            (§ ass (:lpart this) ___lpart)
            (§ ass (:bipart this) ___bipart)
            this
        )
    )

    ;; must follow Long
    #_method
    (§ defn #_"int" hashCode [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (ß (int) ((:lpart this) :xor ((:lpart this) >>> 32))))
        )
        (ß (:bipart this).hashCode())
    )

    #_method
    (§ defn #_"int" hasheq [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (Murmur3'hashLong (:lpart this)))
        )
        (ß (:bipart this).hashCode())
    )

    #_method
    (§ defn #_"boolean" equals [#_"BigInt" this, #_"Object" ___obj]
        (when (ß this == ___obj)
            (§ return true)
        )
        (when (ß ___obj instanceof BigInt)
            (let [#_"BigInt" ___o (ß (BigInt) ___obj)]
                (when (nil? (:bipart this))
                    (§ return (ß ((:bipart ___o) == nil && (:lpart this) == (:lpart ___o))))
                )
                (§ return (ß ((:bipart ___o) != nil && (:bipart this).equals((:bipart ___o)))))
            )
        )
        false
    )

    (defn #_"BigInt" BigInt'fromBigInteger [#_"BigInteger" ___val]
        (if (ß ___val.bitLength() < 64)
            (do
                (ß BigInt'new(___val.longValue(), nil))
            )
            (do
                (BigInt'new 0, ___val)
            )
        )
    )

    (defn #_"BigInt" BigInt'fromLong [#_"long" ___val]
        (BigInt'new ___val, nil)
    )

    #_method
    (§ defn #_"BigInteger" toBigInteger [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (BigInteger/valueOf (:lpart this))
            )
            (do
                (:bipart this)
            )
        )
    )

    #_method
    (§ defn #_"BigDecimal" toBigDecimal [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (BigDecimal/valueOf (:lpart this))
            )
            (do
                (BigDecimal. (:bipart this))
            )
        )
    )

    #_method
    (§ defn #_"int" intValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (int) (:lpart this))
            )
            (do
                (ß (:bipart this).intValue())
            )
        )
    )

    #_method
    (§ defn #_"long" longValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (ß (:bipart this).longValue())
            )
        )
    )

    #_method
    (§ defn #_"float" floatValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (ß (:bipart this).floatValue())
            )
        )
    )

    #_method
    (§ defn #_"double" doubleValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (:lpart this)
            )
            (do
                (ß (:bipart this).doubleValue())
            )
        )
    )

    #_method
    (§ defn #_"byte" byteValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (byte) (:lpart this))
            )
            (do
                (ß (:bipart this).byteValue())
            )
        )
    )

    #_method
    (§ defn #_"short" shortValue [#_"BigInt" this]
        (if (nil? (:bipart this))
            (do
                (ß (short) (:lpart this))
            )
            (do
                (ß (:bipart this).shortValue())
            )
        )
    )

    (defn #_"BigInt" BigInt'valueOf [#_"long" ___val]
        (BigInt'new ___val, nil)
    )

    #_method
    (§ defn #_"String" toString [#_"BigInt" this]
        (when (nil? (:bipart this))
            (§ return (String/valueOf (:lpart this)))
        )
        (ß (:bipart this).toString())
    )

    #_method
    (§ defn #_"int" bitLength [#_"BigInt" this]
        (ß toBigInteger().bitLength())
    )

    #_method
    (§ defn #_"BigInt" add [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (let [#_"long" ___ret (ß (:lpart this) + (:lpart ___y))]
                (when (ß (___ret :xor (:lpart this)) >= 0 || (___ret :xor (:lpart ___y)) >= 0)
                    (§ return (BigInt'valueOf ___ret))
                )
            )
        )
        (ß BigInt'fromBigInteger(this.toBigInteger().add(___y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" multiply [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (let [#_"long" ___ret (ß (:lpart this) * (:lpart ___y))]
                (when (ß (:lpart ___y) == 0 || (___ret / (:lpart ___y) == (:lpart this) && (:lpart this) != Long/MIN_VALUE))
                    (§ return (BigInt'valueOf ___ret))
                )
            )
        )
        (ß BigInt'fromBigInteger(this.toBigInteger().multiply(___y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" quotient [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (when (ß (:lpart this) == Long/MIN_VALUE && (:lpart ___y) == -1)
                (§ return (ß BigInt'fromBigInteger(this.toBigInteger().negate())))
            )
            (§ return (ß BigInt'valueOf((:lpart this) / (:lpart ___y))))
        )
        (ß BigInt'fromBigInteger(this.toBigInteger().divide(___y.toBigInteger())))
    )

    #_method
    (§ defn #_"BigInt" remainder [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (§ return (ß BigInt'valueOf((:lpart this) % (:lpart ___y))))
        )
        (ß BigInt'fromBigInteger(this.toBigInteger().remainder(___y.toBigInteger())))
    )

    #_method
    (§ defn #_"boolean" lt [#_"BigInt" this, #_"BigInt" ___y]
        (when (ß ((:bipart this) == nil) && ((:bipart ___y) == nil))
            (§ return (ß ((:lpart this) < (:lpart ___y))))
        )
        (ß (this.toBigInteger().compareTo(___y.toBigInteger()) < 0))
    )
)
)

(java-ns cloiure.lang.Binding

(class-ns Binding #_"<T>"
    (defn- #_"Binding" Binding'init []
        (hash-map
            #_"T" :val nil
            #_"Binding" :rest nil
        )
    )

    (defn #_"Binding" Binding'new-1 [#_"T" ___val]
        (let [this (Binding'init)]
            (§ ass (:val this) ___val)
            (§ ass (:rest this) nil)
            this
        )
    )

    (defn #_"Binding" Binding'new-2 [#_"T" ___val, #_"Binding" ___rest]
        (let [this (Binding'init)]
            (§ ass (:val this) ___val)
            (§ ass (:rest this) ___rest)
            this
        )
    )
)
)

(java-ns cloiure.lang.Box

(class-ns Box
    (defn- #_"Box" Box'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Box" Box'new [#_"Object" ___val]
        (let [this (Box'init)]
            (§ ass (:val this) ___val)
            this
        )
    )
)
)

(java-ns cloiure.lang.ChunkBuffer

(class-ns ChunkBuffer (§ implements Counted)
    (defn- #_"ChunkBuffer" ChunkBuffer'init []
        (hash-map
            #_"Object[]" :buffer nil
            #_"int" :end 0
        )
    )

    (defn #_"ChunkBuffer" ChunkBuffer'new [#_"int" ___capacity]
        (let [this (ChunkBuffer'init)]
            (§ ass (:buffer this) (make-array Object ___capacity))
            (§ ass (:end this) 0)
            this
        )
    )

    #_method
    (§ defn #_"void" add [#_"ChunkBuffer" this, #_"Object" ___o]
        (§ ass (ß (:buffer this)[(:end this)]) ___o)
        (§ ass (:end this) (+ (:end this) 1))
        nil
    )

    #_method
    (§ defn #_"IChunk" chunk [#_"ChunkBuffer" this]
        (let [#_"ArrayChunk" ___ret (ArrayChunk'new-3 (:buffer this), 0, (:end this))]
            (§ ass (:buffer this) nil)
            ___ret
        )
    )

    #_method
    (§ defn #_"int" count [#_"ChunkBuffer" this]
        (:end this)
    )
)
)

(java-ns cloiure.lang.ChunkedCons

(class-ns ChunkedCons (§ extends ASeq) (§ implements IChunkedSeq)
    (defn- #_"ChunkedCons" ChunkedCons'init []
        (hash-map
            #_"IChunk" :chunk nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-3 [#_"IPersistentMap" ___meta, #_"IChunk" ___chunk, #_"ISeq" ___more]
        (let [this (merge (ASeq'new ___meta) (ChunkedCons'init))]
            (§ ass (:chunk this) ___chunk)
            (§ ass (:_more this) ___more)
            this
        )
    )

    (defn #_"ChunkedCons" ChunkedCons'new-2 [#_"IChunk" ___chunk, #_"ISeq" ___more]
        (ChunkedCons'new-3 nil, ___chunk, ___more)
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"ChunkedCons" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != (:_meta this))
            (§ return (ChunkedCons'new-3 ___meta, (:chunk this), (:_more this)))
        )
        this
    )

    #_method
    (§ defn #_"Object" first [#_"ChunkedCons" this]
        (ß (:chunk this).nth(0))
    )

    #_method
    (§ defn #_"ISeq" next [#_"ChunkedCons" this]
        (when (ß (:chunk this).count() > 1)
            (§ return (ß ChunkedCons'new-2((:chunk this).dropFirst(), (:_more this))))
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"ISeq" more [#_"ChunkedCons" this]
        (when (ß (:chunk this).count() > 1)
            (§ return (ß ChunkedCons'new-2((:chunk this).dropFirst(), (:_more this))))
        )
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"ChunkedCons" this]
        (:chunk this)
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"ChunkedCons" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"ChunkedCons" this]
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )
)
)

(java-ns cloiure.lang.Compile

(§ import java.io.OutputStreamWriter)
(§ import java.io.PrintWriter)
(§ import java.io.IOException)

;; Compiles libs and generates class files stored within the directory
;; named by the Java System property "cloiure.compile.path". Arguments are
;; strings naming the libs to be compiled. The libs and compile-path must
;; all be within CLASSPATH.

#_stateless
(class-ns Compile
    (def- #_"String" Compile'PATH_PROP "cloiure.compile.path")
    (def- #_"String" Compile'REFLECTION_WARNING_PROP "cloiure.compile.warn-on-reflection")
    (def- #_"String" Compile'UNCHECKED_MATH_PROP "cloiure.compile.unchecked-math")

    (§ def- #_"Var" Compile'compile_path (RT'var-2 "cloiure.core", "*compile-path*"))
    (§ def- #_"Var" Compile'compile (RT'var-2 "cloiure.core", "compile"))
    (§ def- #_"Var" Compile'warn_on_reflection (RT'var-2 "cloiure.core", "*warn-on-reflection*"))
    (§ def- #_"Var" Compile'unchecked_math (RT'var-2 "cloiure.core", "*unchecked-math*"))

    (defn #_"void" Compile'main [#_"String[]" ___args] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"OutputStreamWriter" ___out (ß (OutputStreamWriter) RT'OUT.deref())]
            (let [#_"PrintWriter" ___err (ß RT'errPrintWriter())]
                (let [#_"String" ___path (System/getProperty Compile'PATH_PROP)]
                    (let [#_"int" ___count (ß ___args.length)]
                        (when (nil? ___path)
                            (ß ___err.println("ERROR: Must set system property " + Compile'PATH_PROP + "\nto the location for compiled .class files." + "\nThis directory must also be on your CLASSPATH."))
                            (System/exit 1)
                        )

                        (let [#_"boolean" ___warnOnReflection (ß System/getProperty(Compile'REFLECTION_WARNING_PROP, "false").equals("true"))]
                            (let [#_"String" ___uncheckedMathProp (System/getProperty Compile'UNCHECKED_MATH_PROP)]
                                (let [#_"Object" ___uncheckedMath Boolean/FALSE]
                                    (cond (ß "true".equals(___uncheckedMathProp))
                                        (do
                                            (§ ass ___uncheckedMath Boolean/TRUE)
                                        )
                                        (ß "warn-on-boxed".equals(___uncheckedMathProp))
                                        (do
                                            (§ ass ___uncheckedMath (Keyword'intern-1 "warn-on-boxed"))
                                        )
                                    )

                                    ;; force load to avoid transitive compilation during lazy load
                                    (RT'load-1 "cloiure/core/specs/alpha")

                                    (try
                                        (ß Var'pushThreadBindings(RT'map(
                                            (§ map
                                                compile_path       ___path
                                                warn_on_reflection ___warnOnReflection
                                                unchecked_math     ___uncheckedMath
                                            )
                                        )))

                                        (doseq [#_"String" ___lib ___args]
                                            (ß ___out.write("Compiling " + ___lib + " to " + ___path + "\n"))
                                            (ß ___out.flush())
                                            (ß compile.invoke(Symbol'intern-1(___lib)))
                                        )
                                        (finally
                                            (ß Var'popThreadBindings())
                                            (try
                                                (ß ___out.flush())
                                                (catch IOException ___e
                                                    (ß ___e.printStackTrace(___err))
                                                )
                                            )
                                        )
                                    )
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Compiler

(§ import cloiure.asm.*)
(§ import cloiure.asm.commons.GeneratorAdapter)
(§ import cloiure.asm.commons.Method)

(§ import java.io.*)
(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Modifier)
(§ import java.util.*)
(§ import java.util.regex.Pattern)
(§ import java.util.regex.Matcher)

(def Context'enum-set
    (hash-set
        :Context'STATEMENT ;; value ignored
        :Context'EXPRESSION ;; value required
        :Context'RETURN ;; tail position relative to enclosing recur frame
        :Context'EVAL
    )
)

#_private
#_stateless
(class-ns Recur
)

(defprotocol Expr
    #_abstract
    (#_"Object" Expr'''eval [#_"Expr" this])
    #_abstract
    (#_"void" Expr'''emit [#_"Expr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen])
    #_abstract
    (#_"boolean" Expr'''hasJavaClass [#_"Expr" this])
    #_abstract
    (#_"Class" Expr'''getJavaClass [#_"Expr" this])
)

#_stateless
#_abstract
(class-ns UntypedExpr (§ implements Expr)
    #_protected
    (defn #_"UntypedExpr" UntypedExpr'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"UntypedExpr" this]
        (throw (IllegalArgumentException. "Has no Java class"))
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"UntypedExpr" this]
        false
    )
)

(defprotocol IParser
    #_abstract
    (#_"Expr" IParser'''parse [#_"IParser" this, #_"Context" ___context, #_"Object" ___form])
)

#_closure
(class-ns DefParser (§ implements IParser)
    (defn #_"DefParser" DefParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"DefParser" this, #_"Context" ___context, #_"Object" ___form]
        ;; (def x) or (def x initexpr) or (def x "docstring" initexpr)
        (let [#_"String" ___docstring nil]
            (when (ß RT'count(___form) == 4 && (RT'third(___form) instanceof String))
                (§ ass ___docstring (ß (String) RT'third(___form)))
                (§ ass ___form (ß RT'list-3(RT'first(___form), RT'second(___form), RT'fourth(___form))))
            )
            (cond (ß RT'count(___form) > 3)
                (do
                    (throw (Util'runtimeException-1 "Too many arguments to def"))
                )
                (ß RT'count(___form) < 2)
                (do
                    (throw (Util'runtimeException-1 "Too few arguments to def"))
                )
                (ß !(RT'second(___form) instanceof Symbol))
                (do
                    (throw (Util'runtimeException-1 "First argument to def must be a Symbol"))
                )
            )
            (let [#_"Symbol" ___sym (ß (Symbol) RT'second(___form))]
                (let [#_"Var" ___v (ß lookupVar(___sym, true))]
                    (when (nil? ___v)
                        (throw (Util'runtimeException-1 "Can't refer to qualified var that doesn't exist"))
                    )
                    (let [#_"boolean" ___shadowsCoreMapping false]
                        (when (ß !___v.ns.equals(currentNS()))
                            (if (ß (:ns ___sym) == nil)
                                (do
                                    (§ ass ___v (ß currentNS().intern(___sym)))
                                    (§ ass ___shadowsCoreMapping true)
                                    (ß registerVar(___v))
                                )
                                (do
                                    (throw (Util'runtimeException-1 "Can't create defs outside of current ns"))
                                )
                            )
                        )
                        (let [#_"IPersistentMap" ___mm (ß ___sym.meta())]
                            (let [#_"boolean" ___isDynamic (ß RT'booleanCast-1o(RT'get-2(___mm, dynamicKey)))]
                                (when ___isDynamic
                                    (ß ___v.setDynamic())
                                )
                                (when (ß !___isDynamic && (:name ___sym).startsWith("*") && (:name ___sym).endsWith("*") && (:name ___sym).length() > 2)
                                    (ß RT'errPrintWriter().format("Warning: %1$s not declared dynamic and thus is not dynamically rebindable, " + "but its name suggests otherwise. Please either indicate ^:dynamic %1$s or change the name. (%2$s:%3$d)\n", (§ array ___sym, (ß Compiler'SOURCE_PATH.get()), (ß Compiler'LINE.get()))))
                                )
                                (when (ß RT'booleanCast-1o(RT'get-2(___mm, arglistsKey)))
                                    (let [#_"IPersistentMap" ___vm (ß ___v.meta())]
                                        ;; drop quote
                                        (§ ass ___vm (ß (IPersistentMap) RT'assoc(___vm, arglistsKey, RT'second(___mm.valAt(arglistsKey)))))
                                        (ß ___v.setMeta(___vm))
                                    )
                                )
                                (let [#_"Object" ___source_path (ß Compiler'SOURCE_PATH.get())]
                                    (§ ass ___source_path (ß (___source_path == nil) ? "NO_SOURCE_FILE" :or ___source_path))
                                    (§ ass ___mm (ß (IPersistentMap) RT'assoc(___mm, RT'LINE_KEY, Compiler'LINE.get()).assoc(RT'COLUMN_KEY, Compiler'COLUMN.get()).assoc(RT'FILE_KEY, ___source_path)))
                                    (when (some? ___docstring)
                                        (§ ass ___mm (ß (IPersistentMap) RT'assoc(___mm, RT'DOC_KEY, ___docstring)))
                                    )
                                    (§ ass ___mm (ß (IPersistentMap) elideMeta(___mm)))
                                    (let [#_"Expr" ___meta (ß (___mm.count() == 0) ? nil :or analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___mm))]
                                        (ß DefExpr'new((String) Compiler'SOURCE.deref(), lineDeref(), columnDeref(), ___v, analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, RT'third(___form), (:sym ___v).name), ___meta, (RT'count(___form) == 3), ___isDynamic, ___shadowsCoreMapping))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns DefExpr (§ implements Expr)
    (def #_"Method" DefExpr'bindRootMethod (Method/getMethod "void bindRoot(Object)"))
    (def #_"Method" DefExpr'setTagMethod (Method/getMethod "void setTag(cloiure.lang.Symbol)"))
    (def #_"Method" DefExpr'setMetaMethod (Method/getMethod "void setMeta(cloiure.lang.IPersistentMap)"))
    (def #_"Method" DefExpr'setDynamicMethod (Method/getMethod "cloiure.lang.Var setDynamic(boolean)"))
    (def #_"Method" DefExpr'symintern (Method/getMethod "cloiure.lang.Symbol intern(String, String)"))
    (def #_"Method" DefExpr'internVar (Method/getMethod "cloiure.lang.Var refer(cloiure.lang.Symbol, cloiure.lang.Var)"))

    (defn- #_"DefExpr" DefExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Expr" :init nil
            #_"Expr" :meta nil
            #_"boolean" :initProvided false
            #_"boolean" :isDynamic false
            #_"boolean" :shadowsCoreMapping false
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"DefExpr" DefExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Var" ___var, #_"Expr" ___init, #_"Expr" ___meta, #_"boolean" ___initProvided, #_"boolean" ___isDynamic, #_"boolean" ___shadowsCoreMapping]
        (let [this (DefExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:var this) ___var)
            (§ ass (:init this) ___init)
            (§ ass (:meta this) ___meta)
            (§ ass (:isDynamic this) ___isDynamic)
            (§ ass (:shadowsCoreMapping this) ___shadowsCoreMapping)
            (§ ass (:initProvided this) ___initProvided)
            this
        )
    )

    #_method
    (§ defn- #_"boolean" includesExplicitMetadata [#_"DefExpr" this, #_"MapExpr" ___expr]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals ___expr).count()) [(+ ___i 2)]
            (let [#_"Keyword" ___k (ß ((KeywordExpr) (:keyvals ___expr).nth(___i)).k)]
                (when (ß (___k != RT'FILE_KEY) && (___k != RT'DECLARED_KEY) && (___k != RT'LINE_KEY) && (___k != RT'COLUMN_KEY))
                    (§ return true)
                )
            )
        )
        false
    )

    #_method
    (§ defn #_"Object" eval [#_"DefExpr" this]
        (try
            (when (:initProvided this)
                (ß (:var this).bindRoot((:init this).eval()))
            )
            (when (some? (:meta this))
                (let [#_"IPersistentMap" ___metaMap (ß (IPersistentMap) (:meta this).eval())]
                    (when (ß (:initProvided this) || true) ;; includesExplicitMetadata((MapExpr) meta)
                        (ß (:var this).setMeta(___metaMap))
                    )
                )
            )
            (ß (:var this).setDynamic((:isDynamic this)))
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emit [#_"DefExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitVar(___gen, (:var this)))

        (when (:shadowsCoreMapping this)
            (ß ___gen.dup())
            (ß ___gen.getField(Compiler'VAR_TYPE, "ns", Compiler'NS_TYPE))
            (ß ___gen.swap())
            (ß ___gen.dup())
            (ß ___gen.getField(Compiler'VAR_TYPE, "sym", Compiler'SYMBOL_TYPE))
            (ß ___gen.swap())
            (ß ___gen.invokeVirtual(Compiler'NS_TYPE, DefExpr'internVar))
        )

        (when (:isDynamic this)
            (ß ___gen.push((:isDynamic this)))
            (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, setDynamicMethod))
        )
        (when (some? (:meta this))
            (when (ß (:initProvided this) || true) ;; includesExplicitMetadata((MapExpr) meta)
                (ß ___gen.dup())
                (ß (:meta this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(Compiler'IPERSISTENTMAP_TYPE))
                (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, setMetaMethod))
            )
        )
        (when (:initProvided this)
            (ß ___gen.dup())
            (if (ß (:init this) instanceof FnExpr)
                (do
                    (ß ((FnExpr)this.init).emitForDefn(___objx, ___gen))
                )
                (do
                    (ß (:init this).emit(:Context'EXPRESSION, ___objx, ___gen))
                )
            )
            (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, bindRootMethod))
        )

        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"DefExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"DefExpr" this]
        (§ class Var)
    )
)

#_closure
(class-ns AssignParser (§ implements IParser)
    (defn #_"AssignParser" AssignParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"AssignParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß RT'length(___form) != 3)
                (throw (IllegalArgumentException. "Malformed assignment, expecting (set! target val)"))
            )
            (let [#_"Expr" ___target (ß analyze(:Context'EXPRESSION, RT'second(___form)))]
                (when (ß !(___target instanceof AssignableExpr))
                    (throw (IllegalArgumentException. "Invalid assignment target"))
                )
                (ß AssignExpr'new((AssignableExpr) ___target, analyze(:Context'EXPRESSION, RT'third(___form))))
            )
        )
    )
)

(class-ns AssignExpr (§ implements Expr)
    (defn- #_"AssignExpr" AssignExpr'init []
        (hash-map
            #_"AssignableExpr" :target nil
            #_"Expr" :val nil
        )
    )

    (defn #_"AssignExpr" AssignExpr'new [#_"AssignableExpr" ___target, #_"Expr" ___val]
        (let [this (AssignExpr'init)]
            (§ ass (:target this) ___target)
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"AssignExpr" this]
        (ß (:target this).evalAssign((:val this)))
    )

    #_method
    (§ defn #_"void" emit [#_"AssignExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emitAssign(___context, ___objx, ___gen, (:val this)))
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"AssignExpr" this]
        (ß (:val this).hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"AssignExpr" this]
        (ß (:val this).getJavaClass())
    )
)

(class-ns VarExpr (§ implements Expr, AssignableExpr)
    (def #_"Method" VarExpr'getMethod (Method/getMethod "Object get()"))
    (def #_"Method" VarExpr'setMethod (Method/getMethod "Object set(Object)"))

    (defn- #_"VarExpr" VarExpr'init []
        (hash-map
            #_"Var" :var nil
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"VarExpr" VarExpr'new [#_"Var" ___var, #_"Symbol" ___tag]
        (let [this (VarExpr'init)]
            (§ ass (:var this) ___var)
            (§ ass (:tag this) (ß (___tag != nil) ? ___tag :or ___var.getTag()))
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"VarExpr" this]
        (ß (:var this).deref())
    )

    #_method
    (§ defn #_"void" emit [#_"VarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitVarValue(___gen, (:var this)))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"VarExpr" this]
        (ß ((:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"VarExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" evalAssign [#_"VarExpr" this, #_"Expr" ___val]
        (ß (:var this).set(___val.eval()))
    )

    #_method
    (§ defn #_"void" emitAssign [#_"VarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (ß ___objx.emitVar(___gen, (:var this)))
        (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, VarExpr'setMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )
)

#_closure
(class-ns TheVarParser (§ implements IParser)
    (defn #_"TheVarParser" TheVarParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"TheVarParser" this, #_"Context" ___context, #_"Object" ___form]
        (let [#_"Symbol" ___sym (ß (Symbol) RT'second(___form))]
            (let [#_"Var" ___v (ß lookupVar(___sym, false))]
                (when (some? ___v)
                    (§ return (TheVarExpr'new ___v))
                )
                (throw (Util'runtimeException-1 (str "Unable to resolve var: " ___sym " in this context")))
            )
        )
    )
)

(class-ns TheVarExpr (§ implements Expr)
    (defn- #_"TheVarExpr" TheVarExpr'init []
        (hash-map
            #_"Var" :var nil
        )
    )

    (defn #_"TheVarExpr" TheVarExpr'new [#_"Var" ___var]
        (let [this (TheVarExpr'init)]
            (§ ass (:var this) ___var)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"TheVarExpr" this]
        (:var this)
    )

    #_method
    (§ defn #_"void" emit [#_"TheVarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitVar(___gen, (:var this)))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"TheVarExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"TheVarExpr" this]
        (§ class Var)
    )
)

(class-ns KeywordExpr (§ extends LiteralExpr)
    (defn- #_"KeywordExpr" KeywordExpr'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordExpr" KeywordExpr'new [#_"Keyword" ___k]
        (let [this (merge (LiteralExpr'new) (KeywordExpr'init))]
            (§ ass (:k this) ___k)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"KeywordExpr" this]
        (:k this)
    )

    #_method
    (§ defn #_"Object" eval [#_"KeywordExpr" this]
        (:k this)
    )

    #_method
    (§ defn #_"void" emit [#_"KeywordExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitKeyword(___gen, (:k this)))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"KeywordExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"KeywordExpr" this]
        (§ class Keyword)
    )
)

#_closure
(class-ns ImportParser (§ implements IParser)
    (defn #_"ImportParser" ImportParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"ImportParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß ImportExpr'new((String) RT'second(___form)))
    )
)

(class-ns ImportExpr (§ implements Expr)
    (def #_"Method" ImportExpr'forNameMethod (Method/getMethod "Class classForNameNonLoading(String)"))
    (def #_"Method" ImportExpr'importClassMethod (Method/getMethod "Class importClass(Class)"))
    (def #_"Method" ImportExpr'derefMethod (Method/getMethod "Object deref()"))

    (defn- #_"ImportExpr" ImportExpr'init []
        (hash-map
            #_"String" :c nil
        )
    )

    (defn #_"ImportExpr" ImportExpr'new [#_"String" ___c]
        (let [this (ImportExpr'init)]
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"ImportExpr" this]
        (let [#_"Namespace" ___ns (ß (Namespace) RT'CURRENT_NS.deref())]
            (ß ___ns.importClass(RT'classForNameNonLoading((:c this))))
            nil
        )
    )

    #_method
    (§ defn #_"void" emit [#_"ImportExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.getStatic(Compiler'RT_TYPE, "CURRENT_NS", Compiler'VAR_TYPE))
        (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, ImportExpr'derefMethod))
        (ß ___gen.checkCast(Compiler'NS_TYPE))
        (ß ___gen.push((:c this)))
        (ß ___gen.invokeStatic(Compiler'RT_TYPE, forNameMethod))
        (ß ___gen.invokeVirtual(Compiler'NS_TYPE, importClassMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"ImportExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"ImportExpr" this]
        (throw (IllegalArgumentException. "ImportExpr has no Java class"))
    )
)

#_stateless
#_abstract
(class-ns LiteralExpr (§ implements Expr)
    #_protected
    (defn #_"LiteralExpr" LiteralExpr'new []
        (hash-map)
    )

    #_abstract
    (§ defn #_"Object" val [#_"LiteralExpr" this])

    #_method
    (§ defn #_"Object" eval [#_"LiteralExpr" this]
        (ß val())
    )
)

(defprotocol AssignableExpr
    #_abstract
    (#_"Object" AssignableExpr'''evalAssign [#_"AssignableExpr" this, #_"Expr" ___val])
    #_abstract
    (#_"void" AssignableExpr'''emitAssign [#_"AssignableExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val])
)

(defprotocol MaybePrimitiveExpr #_(§ extends Expr)
    #_abstract
    (#_"boolean" MaybePrimitiveExpr'''canEmitPrimitive [#_"MaybePrimitiveExpr" this])
    #_abstract
    (#_"void" MaybePrimitiveExpr'''emitUnboxed [#_"MaybePrimitiveExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen])
)

#_closure
(class-ns HostParser (§ implements IParser)
    (defn #_"HostParser" HostParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"HostParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (. x fieldname-sym) or
            ;; (. x 0-ary-method)
            ;; (. x methodname-sym args+)
            ;; (. x (methodname-sym args?))
            (when (ß RT'length(___form) < 3)
                (throw (IllegalArgumentException. "Malformed member expression, expecting (. target member ...)"))
            )
            ;; determine static or instance
            ;; static target must be symbol, either fully.qualified.Classname or Classname that has been imported
            (let [#_"int" ___line (ß lineDeref())]
                (let [#_"int" ___column (ß columnDeref())]
                    (let [#_"String" ___source (ß (String) Compiler'SOURCE.deref())]
                        (let [#_"Class" ___c (ß maybeClass(RT'second(___form), false))]
                            ;; at this point c will be non-null if static
                            (let [#_"Expr" ___instance nil]
                                (when (nil? ___c)
                                    (§ ass ___instance (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, RT'second(___form))))
                                )

                                (let [#_"boolean" ___maybeField (ß (RT'length(___form) == 3) && (RT'third(___form) instanceof Symbol))]
                                    (when (ß ___maybeField && !(((Symbol)RT'third(___form)).name.charAt(0) == \-))
                                        (let [#_"Symbol" ___sym (ß (Symbol) RT'third(___form))]
                                            (cond (some? ___c)
                                                (do
                                                    (§ ass ___maybeField (ß Reflector'getMethods(___c, 0, munge((:name ___sym)), true).size() == 0))
                                                )
                                                (ß ___instance != nil && ___instance.hasJavaClass() && ___instance.getJavaClass() != nil)
                                                (do
                                                    (§ ass ___maybeField (ß Reflector'getMethods(___instance.getJavaClass(), 0, munge((:name ___sym)), false).size() == 0))
                                                )
                                            )
                                        )
                                    )

                                    (if ___maybeField ;; field
                                        (do
                                            (let [#_"Symbol" ___sym (ß (((Symbol)RT'third(___form)).name.charAt(0) == \-) ? Symbol'intern-1(((Symbol)RT'third(___form)).name.substring(1)) :or (Symbol) RT'third(___form))]
                                                (let [#_"Symbol" ___tag (ß tagOf(___form))]
                                                    (if (some? ___c)
                                                        (do
                                                            (ß StaticFieldExpr'new(___line, ___column, ___c, munge((:name ___sym)), ___tag))
                                                        )
                                                        (do
                                                            (ß InstanceFieldExpr'new(___line, ___column, ___instance, munge((:name ___sym)), ___tag, (((Symbol)RT'third(___form)).name.charAt(0) == \-)))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (let [#_"ISeq" ___call (ß (ISeq) ((RT'third(___form) instanceof ISeq) ? RT'third(___form) :or RT'next(RT'next(___form))))]
                                                (when (ß !(RT'first(___call) instanceof Symbol))
                                                    (throw (IllegalArgumentException. "Malformed member expression"))
                                                )
                                                (let [#_"Symbol" ___sym (ß (Symbol) RT'first(___call))]
                                                    (let [#_"Symbol" ___tag (ß tagOf(___form))]
                                                        (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                                                            (let [#_"boolean" ___tailPosition (ß inTailCall(___context))]
                                                                (loop-when-recur [#_"ISeq" ___s (RT'next ___call)] (some? ___s) [(ß ___s.next())]
                                                                    (§ ass ___args (ß ___args.cons(analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___s.first()))))
                                                                )
                                                                (if (some? ___c)
                                                                    (do
                                                                        (ß StaticMethodExpr'new(___source, ___line, ___column, ___tag, ___c, munge((:name ___sym)), ___args, ___tailPosition))
                                                                    )
                                                                    (do
                                                                        (ß InstanceMethodExpr'new(___source, ___line, ___column, ___tag, ___instance, munge((:name ___sym)), ___args, ___tailPosition))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_stateless
#_abstract
(class-ns HostExpr (§ implements Expr, MaybePrimitiveExpr)
    #_protected
    (defn #_"HostExpr" HostExpr'new []
        (hash-map)
    )

    (def #_"Type" HostExpr'BOOLEAN_TYPE (Type/getType Boolean))
    (def #_"Type" HostExpr'CHAR_TYPE (Type/getType Character))
    (def #_"Type" HostExpr'INTEGER_TYPE (Type/getType Integer))
    (def #_"Type" HostExpr'LONG_TYPE (Type/getType Long))
    (def #_"Type" HostExpr'FLOAT_TYPE (Type/getType Float))
    (def #_"Type" HostExpr'DOUBLE_TYPE (Type/getType Double))
    (def #_"Type" HostExpr'SHORT_TYPE (Type/getType Short))
    (def #_"Type" HostExpr'BYTE_TYPE (Type/getType Byte))
    (def #_"Type" HostExpr'NUMBER_TYPE (Type/getType Number))

    (def #_"Method" HostExpr'charValueMethod (Method/getMethod "char charValue()"))
    (def #_"Method" HostExpr'booleanValueMethod (Method/getMethod "boolean booleanValue()"))

    (def #_"Method" HostExpr'charValueOfMethod (Method/getMethod "Character valueOf(char)"))
    (def #_"Method" HostExpr'intValueOfMethod (Method/getMethod "Integer valueOf(int)"))
    (def #_"Method" HostExpr'longValueOfMethod (Method/getMethod "Long valueOf(long)"))
    (def #_"Method" HostExpr'floatValueOfMethod (Method/getMethod "Float valueOf(float)"))
    (def #_"Method" HostExpr'doubleValueOfMethod (Method/getMethod "Double valueOf(double)"))
    (def #_"Method" HostExpr'shortValueOfMethod (Method/getMethod "Short valueOf(short)"))
    (def #_"Method" HostExpr'byteValueOfMethod (Method/getMethod "Byte valueOf(byte)"))

    (def #_"Method" HostExpr'intValueMethod (Method/getMethod "int intValue()"))
    (def #_"Method" HostExpr'longValueMethod (Method/getMethod "long longValue()"))
    (def #_"Method" HostExpr'floatValueMethod (Method/getMethod "float floatValue()"))
    (def #_"Method" HostExpr'doubleValueMethod (Method/getMethod "double doubleValue()"))
    (def #_"Method" HostExpr'byteValueMethod (Method/getMethod "byte byteValue()"))
    (def #_"Method" HostExpr'shortValueMethod (Method/getMethod "short shortValue()"))

    (def #_"Method" HostExpr'fromIntMethod (Method/getMethod "cloiure.lang.Num from(int)"))
    (def #_"Method" HostExpr'fromLongMethod (Method/getMethod "cloiure.lang.Num from(long)"))
    (def #_"Method" HostExpr'fromDoubleMethod (Method/getMethod "cloiure.lang.Num from(double)"))

    (defn #_"void" HostExpr'emitBoxReturn [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___returnType]
        (when (ß ___returnType.isPrimitive())
            (cond (ß ___returnType == (§ class boolean))
                (do
                    (let [#_"Label" ___falseLabel (ß ___gen.newLabel())]
                        (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
                            (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___falseLabel))
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE))
                            (ß ___gen.goTo(___endLabel))
                            (ß ___gen.mark(___falseLabel))
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE))
                            (ß ___gen.mark(___endLabel))
                        )
                    )
                )
                (ß ___returnType == (§ class void))
                (do
                    (ß Compiler'NIL_EXPR.emit(:Context'EXPRESSION, ___objx, ___gen))
                )
                (ß ___returnType == (§ class char))
                (do
                    (ß ___gen.invokeStatic(HostExpr'CHAR_TYPE, charValueOfMethod))
                )
                :else
                (do
                    (cond (ß ___returnType == (§ class int))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'INTEGER_TYPE, intValueOfMethod))
                        )
                        (ß ___returnType == (§ class float))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'FLOAT_TYPE, floatValueOfMethod))
                        )
                        (ß ___returnType == (§ class double))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'DOUBLE_TYPE, doubleValueOfMethod))
                        )
                        (ß ___returnType == (§ class long))
                        (do
                            (ß ___gen.invokeStatic(Compiler'NUMBERS_TYPE, Method/getMethod("Number num(long)")))
                        )
                        (ß ___returnType == (§ class byte))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'BYTE_TYPE, byteValueOfMethod))
                        )
                        (ß ___returnType == (§ class short))
                        (do
                            (ß ___gen.invokeStatic(HostExpr'SHORT_TYPE, shortValueOfMethod))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"void" HostExpr'emitUnboxArg [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___paramType]
        (if (ß ___paramType.isPrimitive())
            (do
                (cond (ß ___paramType == (§ class boolean))
                    (do
                        (ß ___gen.checkCast(HostExpr'BOOLEAN_TYPE))
                        (ß ___gen.invokeVirtual(HostExpr'BOOLEAN_TYPE, booleanValueMethod))
                    )
                    (ß ___paramType == (§ class char))
                    (do
                        (ß ___gen.checkCast(HostExpr'CHAR_TYPE))
                        (ß ___gen.invokeVirtual(HostExpr'CHAR_TYPE, charValueMethod))
                    )
                    :else
                    (do
                        (let [#_"Method" ___m nil]
                            (ß ___gen.checkCast(HostExpr'NUMBER_TYPE))
                            (if (ß RT'booleanCast-1o(RT'UNCHECKED_MATH.deref()))
                                (do
                                    (cond (ß ___paramType == (§ class int))
                                        (do
                                            (§ ass ___m (Method/getMethod "int uncheckedIntCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class float))
                                        (do
                                            (§ ass ___m (Method/getMethod "float uncheckedFloatCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class double))
                                        (do
                                            (§ ass ___m (Method/getMethod "double uncheckedDoubleCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class long))
                                        (do
                                            (§ ass ___m (Method/getMethod "long uncheckedLongCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class byte))
                                        (do
                                            (§ ass ___m (Method/getMethod "byte uncheckedByteCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class short))
                                        (do
                                            (§ ass ___m (Method/getMethod "short uncheckedShortCast(Object)"))
                                        )
                                    )
                                )
                                (do
                                    (cond (ß ___paramType == (§ class int))
                                        (do
                                            (§ ass ___m (Method/getMethod "int intCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class float))
                                        (do
                                            (§ ass ___m (Method/getMethod "float floatCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class double))
                                        (do
                                            (§ ass ___m (Method/getMethod "double doubleCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class long))
                                        (do
                                            (§ ass ___m (Method/getMethod "long longCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class byte))
                                        (do
                                            (§ ass ___m (Method/getMethod "byte byteCast(Object)"))
                                        )
                                        (ß ___paramType == (§ class short))
                                        (do
                                            (§ ass ___m (Method/getMethod "short shortCast(Object)"))
                                        )
                                    )
                                )
                            )
                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, ___m))
                        )
                    )
                )
            )
            (do
                (ß ___gen.checkCast(Type/getType(___paramType)))
            )
        )
        nil
    )

    (defn #_"Class" HostExpr'maybeClass [#_"Object" ___form, #_"boolean" ___stringOk]
        (when (ß ___form instanceof Class)
            (§ return (ß (Class) ___form))
        )
        (let [#_"Class" ___c nil]
            (cond (ß ___form instanceof Symbol)
                (do
                    (let [#_"Symbol" ___sym (ß (Symbol) ___form)]
                        (when (ß (:ns ___sym) == nil) ;; if ns-qualified can't be classname
                            (when (ß Util'equals(___sym, Compiler'COMPILE_STUB_SYM.get()))
                                (§ return (ß (Class) Compiler'COMPILE_STUB_CLASS.get()))
                            )
                            (if (ß (:name ___sym).indexOf(\.) > 0 || (:name ___sym).charAt(0) == \[)
                                (do
                                    (§ ass ___c (ß RT'classForNameNonLoading((:name ___sym))))
                                )
                                (do
                                    (let [#_"Object" ___o (ß currentNS().getMapping(___sym))]
                                        (cond (ß ___o instanceof Class)
                                            (do
                                                (§ ass ___c (ß (Class) ___o))
                                            )
                                            (ß Compiler'LOCAL_ENV.deref() != nil && ((java.util.Map)Compiler'LOCAL_ENV.deref()).containsKey(___form))
                                            (do
                                                (§ return nil)
                                            )
                                            :else
                                            (do
                                                (try
                                                    (§ ass ___c (ß RT'classForNameNonLoading((:name ___sym))))
                                                    (catch Exception ___e
                                                        ;; aargh
                                                        ;; leave c set to nil -> return nil
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (ß ___stringOk && ___form instanceof String)
                (do
                    (§ ass ___c (ß RT'classForNameNonLoading((String) ___form)))
                )
            )
            ___c
        )
    )

    (defn #_"Class" HostExpr'maybeSpecialTag [#_"Symbol" ___sym]
        (let [#_"Class" ___c (ß primClass(___sym))]
            (cond (some? ___c)
                (do
                    (§ return ___c)
                )
                (ß (:name ___sym).equals("objects"))
                (do
                    (§ ass ___c (§ class Object[]))
                )
                (ß (:name ___sym).equals("ints"))
                (do
                    (§ ass ___c (§ class int[]))
                )
                (ß (:name ___sym).equals("longs"))
                (do
                    (§ ass ___c (§ class long[]))
                )
                (ß (:name ___sym).equals("floats"))
                (do
                    (§ ass ___c (§ class float[]))
                )
                (ß (:name ___sym).equals("doubles"))
                (do
                    (§ ass ___c (§ class double[]))
                )
                (ß (:name ___sym).equals("chars"))
                (do
                    (§ ass ___c (§ class char[]))
                )
                (ß (:name ___sym).equals("shorts"))
                (do
                    (§ ass ___c (§ class short[]))
                )
                (ß (:name ___sym).equals("bytes"))
                (do
                    (§ ass ___c (§ class byte[]))
                )
                (ß (:name ___sym).equals("booleans"))
                (do
                    (§ ass ___c (§ class boolean[]))
                )
            )
            ___c
        )
    )

    (defn #_"Class" HostExpr'tagToClass [#_"Object" ___tag]
        (let [#_"Class" ___c nil]
            (when (ß ___tag instanceof Symbol)
                (let [#_"Symbol" ___sym (ß (Symbol) ___tag)]
                    (when (ß (:ns ___sym) == nil) ;; if ns-qualified can't be classname
                        (§ ass ___c (ß maybeSpecialTag(___sym)))
                    )
                )
            )
            (when (nil? ___c)
                (§ ass ___c (ß maybeClass(___tag, true)))
            )
            (when (some? ___c)
                (§ return ___c)
            )
            (throw (IllegalArgumentException. (str "Unable to resolve classname: " ___tag)))
        )
    )
)

#_stateless
#_abstract
(class-ns FieldExpr (§ extends HostExpr)
    #_protected
    (defn #_"FieldExpr" FieldExpr'new []
        (HostExpr'new)
    )

)

(class-ns InstanceFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (def #_"Method" InstanceFieldExpr'invokeNoArgInstanceMember (Method/getMethod "Object invokeNoArgInstanceMember(Object,String,boolean)"))
    (def #_"Method" InstanceFieldExpr'setInstanceFieldMethod (Method/getMethod "Object setInstanceField(Object,String,Object)"))

    (defn- #_"InstanceFieldExpr" InstanceFieldExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"Class" :targetClass nil
            #_"java.lang.reflect.Field" :field nil
            #_"String" :fieldName nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :requireField false

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceFieldExpr" InstanceFieldExpr'new [#_"int" ___line, #_"int" ___column, #_"Expr" ___target, #_"String" ___fieldName, #_"Symbol" ___tag, #_"boolean" ___requireField]
        (let [this (merge (FieldExpr'new) (InstanceFieldExpr'init))]
            (§ ass (:target this) ___target)
            (§ ass (:targetClass this) (ß ___target.hasJavaClass() ? ___target.getJavaClass() :or nil))
            (§ ass (:field this) (ß ((:targetClass this) != nil) ? Reflector'getField((:targetClass this), ___fieldName, false) :or nil))
            (§ ass (:fieldName this) ___fieldName)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:requireField this) ___requireField)

            (when (ß (:field this) == nil && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                (if (nil? (:targetClass this))
                    (do
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s can't be resolved.\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column, ___fieldName)))
                    )
                    (do
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - reference to field %s on %s can't be resolved.\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column, ___fieldName, (ß (:targetClass this).getName()))))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"InstanceFieldExpr" this]
        (ß Reflector'invokeNoArgInstanceMember-3((:target this).eval(), (:fieldName this), (:requireField this)))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"InstanceFieldExpr" this]
        (ß ((:targetClass this) != nil && (:field this) != nil && Util'isPrimitive((:field this).getType())))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:targetClass this) != nil && (:field this) != nil)
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.checkCast(getType((:targetClass this))))
                (ß ___gen.getField(getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:targetClass this) != nil && (:field this) != nil)
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.checkCast(getType((:targetClass this))))
                (ß ___gen.getField(getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
                (ß HostExpr'emitBoxReturn(___objx, ___gen, (:field this).getType()))
                (when (ß ___context == :Context'STATEMENT)
                    (ß ___gen.pop())
                )
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.push((:fieldName this)))
                (ß ___gen.push((:requireField this)))
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, invokeNoArgInstanceMember))
                (when (ß ___context == :Context'STATEMENT)
                    (ß ___gen.pop())
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"InstanceFieldExpr" this]
        (ß ((:field this) != nil || (:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"InstanceFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß ((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or (:field this).getType()))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" evalAssign [#_"InstanceFieldExpr" this, #_"Expr" ___val]
        (ß Reflector'setInstanceField((:target this).eval(), (:fieldName this), ___val.eval()))
    )

    #_method
    (§ defn #_"void" emitAssign [#_"InstanceFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (if (ß (:targetClass this) != nil && (:field this) != nil)
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(getType((:targetClass this))))
                (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.dupX1())
                (ß HostExpr'emitUnboxArg(___objx, ___gen, (:field this).getType()))
                (ß ___gen.putField(getType((:targetClass this)), (:fieldName this), Type/getType((:field this).getType())))
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.push((:fieldName this)))
                (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, InstanceFieldExpr'setInstanceFieldMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )
)

(class-ns StaticFieldExpr (§ extends FieldExpr) (§ implements AssignableExpr)
    (defn- #_"StaticFieldExpr" StaticFieldExpr'init []
        (hash-map
            #_"String" :fieldName nil
            #_"Class" :c nil
            #_"java.lang.reflect.Field" :field nil
            #_"Symbol" :tag nil

            #_"int" :line 0
            #_"int" :column 0

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticFieldExpr" StaticFieldExpr'new [#_"int" ___line, #_"int" ___column, #_"Class" ___c, #_"String" ___fieldName, #_"Symbol" ___tag]
        (let [this (merge (FieldExpr'new) (StaticFieldExpr'init))]
            (§ ass (:fieldName this) ___fieldName)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:c this) ___c)
            (try
                (§ ass (:field this) (ß ___c.getField(___fieldName)))
                (catch NoSuchFieldException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"StaticFieldExpr" this]
        (Reflector'getStaticField-2c (:c this), (:fieldName this))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"StaticFieldExpr" this]
        (ß Util'isPrimitive((:field this).getType()))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
        (ß ___gen.getStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitLineNumber((:line this), ___gen.mark()))

        (ß ___gen.getStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        (ß HostExpr'emitBoxReturn(___objx, ___gen, (:field this).getType()))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"StaticFieldExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"StaticFieldExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß ((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or (:field this).getType()))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Object" evalAssign [#_"StaticFieldExpr" this, #_"Expr" ___val]
        (ß Reflector'setStaticField-3c((:c this), (:fieldName this), ___val.eval()))
    )

    #_method
    (§ defn #_"void" emitAssign [#_"StaticFieldExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (ß ___val.emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
        (ß ___gen.dup())
        (ß HostExpr'emitUnboxArg(___objx, ___gen, (:field this).getType()))
        (ß ___gen.putStatic(Type/getType((:c this)), (:fieldName this), Type/getType((:field this).getType())))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )
)

#_stateless
#_abstract
(class-ns MethodExpr (§ extends HostExpr)
    #_protected
    (defn #_"MethodExpr" MethodExpr'new []
        (HostExpr'new)
    )

    (defn #_"void" MethodExpr'emitArgsAsArray [#_"IPersistentVector" ___args, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.push(___args.count()))
        (ß ___gen.newArray(Compiler'OBJECT_TYPE))
        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___args.count()) [(inc ___i)]
            (ß ___gen.dup())
            (ß ___gen.push(___i))
            (ß ((Expr) ___args.nth(___i)).emit(:Context'EXPRESSION, ___objx, ___gen))
            (ß ___gen.arrayStore(Compiler'OBJECT_TYPE))
        )
        nil
    )

    (defn #_"void" MethodExpr'emitTypedArgs [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class[]" ___parameterTypes, #_"IPersistentVector" ___args]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___parameterTypes.length) [(inc ___i)]
            (let [#_"Expr" ___e (ß (Expr) ___args.nth(___i))]
                (try
                    (let [#_"Class" ___primc (ß maybePrimitiveType(___e))]
                        (cond (ß ___primc == ___parameterTypes[___i])
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                )
                            )
                            (ß ___primc == (§ class int) && ___parameterTypes[___i] == (§ class long))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß ___gen.visitInsn(I2L))
                                )
                            )
                            (ß ___primc == (§ class long) && ___parameterTypes[___i] == (§ class int))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (if (ß RT'booleanCast-1o(RT'UNCHECKED_MATH.deref()))
                                        (do
                                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int uncheckedIntCast(long)")))
                                        )
                                        (do
                                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                                        )
                                    )
                                )
                            )
                            (ß ___primc == (§ class float) && ___parameterTypes[___i] == (§ class double))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß ___gen.visitInsn(F2D))
                                )
                            )
                            (ß ___primc == (§ class double) && ___parameterTypes[___i] == (§ class float))
                            (do
                                (let [#_"MaybePrimitiveExpr" ___pe (ß (MaybePrimitiveExpr) ___e)]
                                    (ß ___pe.emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß ___gen.visitInsn(D2F))
                                )
                            )
                            :else
                            (do
                                (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (ß HostExpr'emitUnboxArg(___objx, ___gen, ___parameterTypes[___i]))
                            )
                        )
                    )
                    (catch Exception ___e1
                        (throw (Util'sneakyThrow ___e1))
                    )
                )
            )
        )
        nil
    )
)

(class-ns InstanceMethodExpr (§ extends MethodExpr)
    (def #_"Method" InstanceMethodExpr'invokeInstanceMethodMethod (Method/getMethod "Object invokeInstanceMethod(Object,String,Object[])"))

    (defn- #_"InstanceMethodExpr" InstanceMethodExpr'init []
        (hash-map
            #_"Expr" :target nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false
            #_"java.lang.reflect.Method" :method nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InstanceMethodExpr" InstanceMethodExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Expr" ___target, #_"String" ___methodName, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (merge (MethodExpr'new) (InstanceMethodExpr'init))]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:args this) ___args)
            (§ ass (:methodName this) ___methodName)
            (§ ass (:target this) ___target)
            (§ ass (:tag this) ___tag)
            (§ ass (:tailPosition this) ___tailPosition)
            (if (ß ___target.hasJavaClass() && ___target.getJavaClass() != nil)
                (do
                    (let [#_"List" ___methods (ß Reflector'getMethods(___target.getJavaClass(), ___args.count(), ___methodName, false))]
                        (if (ß ___methods.isEmpty())
                            (do
                                (§ ass (:method this) nil)
                                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                    (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (no such method).\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column, ___methodName, (ß ___target.getJavaClass().getName()))))
                                )
                            )
                            (do
                                (let [#_"int" ___methodidx 0]
                                    (when (ß ___methods.size() > 1)
                                        (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                                            (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___methods.size()) [(inc ___i)]
                                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___methods.get(___i))]
                                                        (ß ___params.add(___m.getParameterTypes()))
                                                        (ß ___rets.add(___m.getReturnType()))
                                                    )
                                                )
                                                (§ ass ___methodidx (ß getMatchingParams(___methodName, ___params, ___args, ___rets)))
                                            )
                                        )
                                    )
                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ((___methodidx >= 0) ? ___methods.get(___methodidx) :or nil))]
                                        (when (ß ___m != nil && !Modifier/isPublic(___m.getDeclaringClass().getModifiers()))
                                            ;; public method of non-public class, try to find it in hierarchy
                                            (§ ass ___m (ß Reflector'getAsMethodOfPublicBase(___m.getDeclaringClass(), ___m)))
                                        )
                                        (§ ass (:method this) ___m)
                                        (when (ß (:method this) == nil && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                            (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s on %s can't be resolved (argument types: %s).\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column, ___methodName, (ß ___target.getJavaClass().getName()), (ß getTypeStringForArgs(___args)))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
                (do
                    (§ ass (:method this) nil)
                    (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to method %s can't be resolved (target class is unknown).\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column, ___methodName)))
                    )
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"InstanceMethodExpr" this]
        (try
            (let [#_"Object" ___targetval (ß (:target this).eval())]
                (let [#_"Object[]" ___argvals (make-array Object (ß (:args this).count()))]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                        (§ ass (ß ___argvals[___i]) (ß ((Expr) (:args this).nth(___i)).eval()))
                    )
                    (when (some? (:method this))
                        (let [#_"LinkedList" ___ms (LinkedList.)]
                            (ß ___ms.add((:method this)))
                            (§ return (Reflector'invokeMatchingMethod (:methodName this), ___ms, ___targetval, ___argvals))
                        )
                    )
                    (Reflector'invokeInstanceMethod ___targetval, (:methodName this), ___argvals)
                )
            )
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"InstanceMethodExpr" this]
        (ß ((:method this) != nil && Util'isPrimitive((:method this).getReturnType())))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"InstanceMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (let [#_"Type" ___type (ß Type/getType((:method this).getDeclaringClass()))]
                    (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.checkCast(___type))
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                    (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                    (when (ß (:tailPosition this) && !___objx.canBeDirect)
                        (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                            (ß ___method.emitClearThis(___gen))
                        )
                    )
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (if (ß (:method this).getDeclaringClass().isInterface())
                            (do
                                (ß ___gen.invokeInterface(___type, ___m))
                            )
                            (do
                                (ß ___gen.invokeVirtual(___type, ___m))
                            )
                        )
                    )
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"InstanceMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (let [#_"Type" ___type (ß Type/getType((:method this).getDeclaringClass()))]
                    (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.checkCast(___type))
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                    (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                    (when (ß ___context == :Context'RETURN)
                        (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                            (ß ___method.emitClearLocals(___gen))
                        )
                    )
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (if (ß (:method this).getDeclaringClass().isInterface())
                            (do
                                (ß ___gen.invokeInterface(___type, ___m))
                            )
                            (do
                                (ß ___gen.invokeVirtual(___type, ___m))
                            )
                        )
                        (ß HostExpr'emitBoxReturn(___objx, ___gen, (:method this).getReturnType()))
                    )
                )
            )
            (do
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.push((:methodName this)))
                (ß emitArgsAsArray((:args this), ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (ß ___method.emitClearLocals(___gen))
                    )
                )
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, InstanceMethodExpr'invokeInstanceMethodMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"InstanceMethodExpr" this]
        (ß ((:method this) != nil || (:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"InstanceMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß retType(((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or nil, ((:method this) != nil) ? (:method this).getReturnType() :or nil)))
        )
        (:jc this)
    )
)

(class-ns StaticMethodExpr (§ extends MethodExpr)
    (def #_"Method" StaticMethodExpr'forNameMethod (Method/getMethod "Class classForName(String)"))
    (def #_"Method" StaticMethodExpr'invokeStaticMethodMethod (Method/getMethod "Object invokeStaticMethod(Class,String,Object[])"))
    (§ def #_"Keyword" StaticMethodExpr'warnOnBoxedKeyword (Keyword'intern-1 "warn-on-boxed"))

    (defn- #_"StaticMethodExpr" StaticMethodExpr'init []
        (hash-map
            #_"Class" :c nil
            #_"String" :methodName nil
            #_"IPersistentVector" :args nil
            #_"String" :source nil
            #_"int" :line 0
            #_"int" :column 0
            #_"java.lang.reflect.Method" :method nil
            #_"Symbol" :tag nil
            #_"boolean" :tailPosition false

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticMethodExpr" StaticMethodExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Class" ___c, #_"String" ___methodName, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (merge (MethodExpr'new) (StaticMethodExpr'init))]
            (§ ass (:c this) ___c)
            (§ ass (:methodName this) ___methodName)
            (§ ass (:args this) ___args)
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:tailPosition this) ___tailPosition)

            (let [#_"List" ___methods (ß Reflector'getMethods(___c, ___args.count(), ___methodName, true))]
                (when (ß ___methods.isEmpty())
                    (throw (IllegalArgumentException. (str "No matching method: " ___methodName)))
                )

                (let [#_"int" ___methodidx 0]
                    (when (ß ___methods.size() > 1)
                        (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                            (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___methods.size()) [(inc ___i)]
                                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___methods.get(___i))]
                                        (ß ___params.add(___m.getParameterTypes()))
                                        (ß ___rets.add(___m.getReturnType()))
                                    )
                                )
                                (§ ass ___methodidx (ß getMatchingParams(___methodName, ___params, ___args, ___rets)))
                            )
                        )
                    )
                    (§ ass (:method this) (ß (java.lang.reflect.Method) ((___methodidx >= 0) ? ___methods.get(___methodidx) :or nil)))
                    (when (ß (:method this) == nil && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                        (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to static method %s on %s can't be resolved (argument types: %s).\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column, ___methodName, (ß ___c.getName()), (ß getTypeStringForArgs(___args)))))
                    )
                    (when (ß (:method this) != nil && warnOnBoxedKeyword.equals(RT'UNCHECKED_MATH.deref()) && StaticMethodExpr'isBoxedMath((:method this)))
                        (ß RT'errPrintWriter().format("Boxed math warning, %s:%d:%d - call: %s.\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column, (ß (:method this).toString()))))
                    )
                    this
                )
            )
        )
    )

    (defn #_"boolean" StaticMethodExpr'isBoxedMath [#_"java.lang.reflect.Method" ___m]
        (let [#_"Class" ___c (ß ___m.getDeclaringClass())]
            (when (ß ___c.equals((§ class Numbers)))
                (let [#_"Class[]" ___argTypes (ß ___m.getParameterTypes())]
                    (doseq [#_"Class" ___argType ___argTypes]
                        (when (ß ___argType.equals((§ class Object)) || ___argType.equals((§ class Number)))
                            (§ return true)
                        )
                    )
                )
            )
            false
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"StaticMethodExpr" this]
        (try
            (let [#_"Object[]" ___argvals (make-array Object (ß (:args this).count()))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                    (§ ass (ß ___argvals[___i]) (ß ((Expr) (:args this).nth(___i)).eval()))
                )
                (when (some? (:method this))
                    (let [#_"LinkedList" ___ms (LinkedList.)]
                        (ß ___ms.add((:method this)))
                        (§ return (Reflector'invokeMatchingMethod (:methodName this), ___ms, nil, ___argvals))
                    )
                )
                (Reflector'invokeStaticMethod-3c (:c this), (:methodName this), ___argvals)
            )
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"StaticMethodExpr" this]
        (ß ((:method this) != nil && Util'isPrimitive((:method this).getReturnType())))
    )

    #_method
    (§ defn #_"boolean" canEmitIntrinsicPredicate [#_"StaticMethodExpr" this]
        (ß ((:method this) != nil && RT'get-2(Intrinsics'preds, (:method this).toString()) != nil))
    )

    #_method
    (§ defn #_"void" emitIntrinsicPredicate [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Label" ___falseLabel]
        (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (ß ___method.emitClearLocals(___gen))
                    )
                )
                (let [#_"Object[]" ___predOps (ß (Object[]) RT'get-2(Intrinsics'preds, (:method this).toString()))]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___predOps.length - 1) [(inc ___i)]
                        (ß ___gen.visitInsn((Integer)___predOps[___i]))
                    )
                    (ß ___gen.visitJumpInsn((Integer)___predOps[___predOps.length - 1], ___falseLabel))
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (ß ___method.emitClearLocals(___gen))
                    )
                )
                (let [#_"Object" ___ops (ß RT'get-2(Intrinsics'ops, (:method this).toString()))]
                    (if (some? ___ops)
                        (do
                            (if (ß ___ops instanceof Object[])
                                (do
                                    (doseq [#_"Object" ___op (ß (Object[])___ops)]
                                        (ß ___gen.visitInsn((Integer) ___op))
                                    )
                                )
                                (do
                                    (ß ___gen.visitInsn((Integer) ___ops))
                                )
                            )
                        )
                        (do
                            (let [#_"Type" ___type (Type/getType (:c this))]
                                (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                                    (ß ___gen.invokeStatic(___type, ___m))
                                )
                            )
                        )
                    )
                )
            )
            (do
                (throw (UnsupportedOperationException. "Unboxed emit of unknown member"))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"StaticMethodExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (some? (:method this))
            (do
                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:method this).getParameterTypes(), (:args this)))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (when (ß (:tailPosition this) && !___objx.canBeDirect)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (ß ___method.emitClearThis(___gen))
                    )
                )
                (let [#_"Type" ___type (Type/getType (:c this))]
                    (let [#_"Method" ___m (Method. (:methodName this), (Type/getReturnType (:method this)), (Type/getArgumentTypes (:method this)))]
                        (ß ___gen.invokeStatic(___type, ___m))
                        (let [#_"Class" ___retClass (ß (:method this).getReturnType())]
                            (if (ß ___context == :Context'STATEMENT)
                                (do
                                    (cond (ß ___retClass == (§ class long) || ___retClass == (§ class double))
                                        (do
                                            (ß ___gen.pop2())
                                        )
                                        (ß ___retClass != (§ class void))
                                        (do
                                            (ß ___gen.pop())
                                        )
                                    )
                                )
                                (do
                                    (ß HostExpr'emitBoxReturn(___objx, ___gen, (:method this).getReturnType()))
                                )
                            )
                        )
                    )
                )
            )
            (do
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.push((:c this).getName()))
                (ß ___gen.invokeStatic(Compiler'RT_TYPE, forNameMethod))
                (ß ___gen.push((:methodName this)))
                (ß emitArgsAsArray((:args this), ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (when (ß ___context == :Context'RETURN)
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (ß ___method.emitClearLocals(___gen))
                    )
                )
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, invokeStaticMethodMethod))
                (when (ß ___context == :Context'STATEMENT)
                    (ß ___gen.pop())
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"StaticMethodExpr" this]
        (ß ((:method this) != nil || (:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"StaticMethodExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß retType(((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or nil, ((:method this) != nil) ? (:method this).getReturnType() :or nil)))
        )
        (:jc this)
    )
)

(class-ns UnresolvedVarExpr (§ implements Expr)
    (defn- #_"UnresolvedVarExpr" UnresolvedVarExpr'init []
        (hash-map
            #_"Symbol" :symbol nil
        )
    )

    (defn #_"UnresolvedVarExpr" UnresolvedVarExpr'new [#_"Symbol" ___symbol]
        (let [this (UnresolvedVarExpr'init)]
            (§ ass (:symbol this) ___symbol)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"UnresolvedVarExpr" this]
        false
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr has no Java class"))
    )

    #_method
    (§ defn #_"void" emit [#_"UnresolvedVarExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"Object" eval [#_"UnresolvedVarExpr" this]
        (throw (IllegalArgumentException. "UnresolvedVarExpr cannot be evalled"))
    )
)

(class-ns NumberExpr (§ extends LiteralExpr) (§ implements MaybePrimitiveExpr)
    (defn- #_"NumberExpr" NumberExpr'init []
        (hash-map
            #_"Number" :n nil
            #_"int" :id 0
        )
    )

    (defn #_"NumberExpr" NumberExpr'new [#_"Number" ___n]
        (let [this (merge (LiteralExpr'new) (NumberExpr'init))]
            (§ ass (:n this) ___n)
            (§ ass (:id this) (ß registerConstant(___n)))
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"NumberExpr" this]
        (:n this)
    )

    #_method
    (§ defn #_"void" emit [#_"NumberExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (ß ___objx.emitConstant(___gen, (:id this)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"NumberExpr" this]
        (cond (ß (:n this) instanceof Integer)
            (do
                (§ class long)
            )
            (ß (:n this) instanceof Double)
            (do
                (§ class double)
            )
            (ß (:n this) instanceof Long)
            (do
                (§ class long)
            )
            :else
            (do
                (throw (IllegalStateException. (str "Unsupported Number type: " (ß (:n this).getClass().getName()))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"NumberExpr" this]
        true
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"NumberExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (cond (ß (:n this) instanceof Integer)
            (do
                (ß ___gen.push((:n this).longValue()))
            )
            (ß (:n this) instanceof Double)
            (do
                (ß ___gen.push((:n this).doubleValue()))
            )
            (ß (:n this) instanceof Long)
            (do
                (ß ___gen.push((:n this).longValue()))
            )
        )
        nil
    )

    (defn #_"Expr" NumberExpr'parse [#_"Number" ___form]
        (if (ß ___form instanceof Integer || ___form instanceof Double || ___form instanceof Long)
            (do
                (NumberExpr'new ___form)
            )
            (do
                (ConstantExpr'new ___form)
            )
        )
    )
)

#_closure
(class-ns ConstantParser (§ implements IParser)
    (§ def #_"Keyword" ConstantParser'formKey (Keyword'intern-1 "form"))

    (defn #_"ConstantParser" ConstantParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"ConstantParser" this, #_"Context" ___context, #_"Object" ___form]
        (let [#_"int" ___argCount (ß RT'count(___form) - 1)]
            (when (ß ___argCount != 1)
                (let [#_"IPersistentMap" ___exData (ß PersistentArrayMap'new-1(new Object[] (§ array ConstantParser'formKey, ___form )))]
                    (throw (ExceptionInfo'new-2 (str "Wrong number of args (" ___argCount ") passed to quote"), ___exData))
                )
            )
            (let [#_"Object" ___v (RT'second ___form)]
                (cond (nil? ___v)
                    (do
                        (§ return Compiler'NIL_EXPR)
                    )
                    (ß ___v == Boolean/TRUE)
                    (do
                        (§ return Compiler'TRUE_EXPR)
                    )
                    (ß ___v == Boolean/FALSE)
                    (do
                        (§ return Compiler'FALSE_EXPR)
                    )
                )
                (cond (ß ___v instanceof Number)
                    (do
                        (ß NumberExpr'parse((Number)___v))
                    )
                    (ß ___v instanceof String)
                    (do
                        (ß StringExpr'new((String) ___v))
                    )
                    (ß ___v instanceof IPersistentCollection && ((IPersistentCollection) ___v).count() == 0)
                    (do
                        (EmptyExpr'new ___v)
                    )
                    :else
                    (do
                        (ConstantExpr'new ___v)
                    )
                )
            )
        )
    )
)

(class-ns ConstantExpr (§ extends LiteralExpr)
    (defn- #_"ConstantExpr" ConstantExpr'init []
        (hash-map
            ;; stuff quoted vals in classloader at compile time, pull out at runtime
            ;; this won't work for static compilation...
            #_"Object" :v nil
            #_"int" :id 0
        )
    )

    (defn #_"ConstantExpr" ConstantExpr'new [#_"Object" ___v]
        (let [this (merge (LiteralExpr'new) (ConstantExpr'init))]
            (§ ass (:v this) ___v)
            (§ ass (:id this) (ß registerConstant(___v)))
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"ConstantExpr" this]
        (:v this)
    )

    #_method
    (§ defn #_"void" emit [#_"ConstantExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitConstant(___gen, (:id this)))

        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"ConstantExpr" this]
        (ß Modifier/isPublic((:v this).getClass().getModifiers()))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"ConstantExpr" this]
        (cond (ß (:v this) instanceof APersistentMap)
            (do
                (§ class APersistentMap)
            )
            (ß (:v this) instanceof APersistentSet)
            (do
                (§ class APersistentSet)
            )
            (ß (:v this) instanceof APersistentVector)
            (do
                (§ class APersistentVector)
            )
            :else
            (do
                (ß (:v this).getClass())
            )
        )
    )
)

(class-ns NilExpr (§ extends LiteralExpr)
    (defn #_"NilExpr" NilExpr'new []
        (LiteralExpr'new)
    )

    #_method
    (§ defn #_"Object" val [#_"NilExpr" this]
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"NilExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"NilExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"NilExpr" this]
        nil
    )
)

(class-ns BooleanExpr (§ extends LiteralExpr)
    (defn- #_"BooleanExpr" BooleanExpr'init []
        (hash-map
            #_"boolean" :val false
        )
    )

    (defn #_"BooleanExpr" BooleanExpr'new [#_"boolean" ___val]
        (let [this (merge (LiteralExpr'new) (BooleanExpr'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"BooleanExpr" this]
        (ß (:val this) ? RT'T :or RT'F)
    )

    #_method
    (§ defn #_"void" emit [#_"BooleanExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (:val this)
            (do
                (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE))
            )
            (do
                (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"BooleanExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"BooleanExpr" this]
        (§ class Boolean)
    )
)

(class-ns StringExpr (§ extends LiteralExpr)
    (defn- #_"StringExpr" StringExpr'init []
        (hash-map
            #_"String" :str nil
        )
    )

    (defn #_"StringExpr" StringExpr'new [#_"String" ___str]
        (let [this (merge (LiteralExpr'new) (StringExpr'init))]
            (§ ass (:str this) ___str)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"StringExpr" this]
        (:str this)
    )

    #_method
    (§ defn #_"void" emit [#_"StringExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (ß ___gen.push((:str this)))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"StringExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"StringExpr" this]
        (§ class String)
    )
)

#_closure
(class-ns MonitorEnterParser (§ implements IParser)
    (defn #_"MonitorEnterParser" MonitorEnterParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"MonitorEnterParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß MonitorEnterExpr'new(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns MonitorEnterExpr (§ extends UntypedExpr)
    (defn- #_"MonitorEnterExpr" MonitorEnterExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorEnterExpr" MonitorEnterExpr'new [#_"Expr" ___target]
        (let [this (merge (UntypedExpr'new) (MonitorEnterExpr'init))]
            (§ ass (:target this) ___target)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MonitorEnterExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-enter"))
    )

    #_method
    (§ defn #_"void" emit [#_"MonitorEnterExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.monitorEnter())
        (ß Compiler'NIL_EXPR.emit(___context, ___objx, ___gen))
        nil
    )
)

#_closure
(class-ns MonitorExitParser (§ implements IParser)
    (defn #_"MonitorExitParser" MonitorExitParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"MonitorExitParser" this, #_"Context" ___context, #_"Object" ___form]
        (ß MonitorExitExpr'new(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns MonitorExitExpr (§ extends UntypedExpr)
    (defn- #_"MonitorExitExpr" MonitorExitExpr'init []
        (hash-map
            #_"Expr" :target nil
        )
    )

    (defn #_"MonitorExitExpr" MonitorExitExpr'new [#_"Expr" ___target]
        (let [this (merge (UntypedExpr'new) (MonitorExitExpr'init))]
            (§ ass (:target this) ___target)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MonitorExitExpr" this]
        (throw (UnsupportedOperationException. "Can't eval monitor-exit"))
    )

    #_method
    (§ defn #_"void" emit [#_"MonitorExitExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.monitorExit())
        (ß Compiler'NIL_EXPR.emit(___context, ___objx, ___gen))
        nil
    )
)

(class-ns CatchClause
    (defn- #_"CatchClause" CatchClause'init []
        (hash-map
            #_"Class" :c nil
            #_"LocalBinding" :lb nil
            #_"Expr" :handler nil
            #_"Label" :label nil
            #_"Label" :endLabel nil
        )
    )

    (defn #_"CatchClause" CatchClause'new [#_"Class" ___c, #_"LocalBinding" ___lb, #_"Expr" ___handler]
        (let [this (CatchClause'init)]
            (§ ass (:c this) ___c)
            (§ ass (:lb this) ___lb)
            (§ ass (:handler this) ___handler)
            this
        )
    )
)

#_closure
(class-ns TryParser (§ implements IParser)
    (defn #_"TryParser" TryParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"TryParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß ___context != :Context'RETURN)
                (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )

            ;; (try try-expr* catch-expr* finally-expr?)
            ;; catch-expr: (catch class sym expr*)
            ;; finally-expr: (finally expr*)

            (let [#_"PersistentVector" ___body PersistentVector'EMPTY]
                (let [#_"PersistentVector" ___catches PersistentVector'EMPTY]
                    (let [#_"Expr" ___bodyExpr nil]
                        (let [#_"Expr" ___finallyExpr nil]
                            (let [#_"boolean" ___caught false]
                                (let [#_"int" ___retLocal (ß getAndIncLocalNum())]
                                    (let [#_"int" ___finallyLocal (ß getAndIncLocalNum())]
                                        (loop-when-recur [#_"ISeq" ___fs (ß ___form.next())] (some? ___fs) [(ß ___fs.next())]
                                            (let [#_"Object" ___f (ß ___fs.first())]
                                                (let [#_"Object" ___op (ß (___f instanceof ISeq) ? ((ISeq) ___f).first() :or nil)]
                                                    (if (ß !Util'equals(___op, Compiler'CATCH) && !Util'equals(___op, Compiler'FINALLY))
                                                        (do
                                                            (when ___caught
                                                                (throw (Util'runtimeException-1 "Only catch or finally clause can follow catch in try expression"))
                                                            )
                                                            (§ ass ___body (ß ___body.cons(___f)))
                                                        )
                                                        (do
                                                            (when (nil? ___bodyExpr)
                                                                (try
                                                                    (ß Var'pushThreadBindings(RT'map(
                                                                        (§ map
                                                                            Compiler'NO_RECUR              true
                                                                            Compiler'METHOD_RETURN_CONTEXT nil
                                                                        )
                                                                    )))
                                                                    (§ ass ___bodyExpr (ß (BodyParser'new()).parse(___context, RT'seq(___body))))
                                                                    (finally
                                                                        (ß Var'popThreadBindings())
                                                                    )
                                                                )
                                                            )

                                                            (cond (Util'equals ___op, Compiler'CATCH)
                                                                (do
                                                                    (let [#_"Class" ___c (ß HostExpr'maybeClass(RT'second(___f), false))]
                                                                        (when (nil? ___c)
                                                                            (throw (IllegalArgumentException. (str "Unable to resolve classname: " (ß RT'second(___f)))))
                                                                        )
                                                                        (when (ß !(RT'third(___f) instanceof Symbol))
                                                                            (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (ß RT'third(___f)))))
                                                                        )
                                                                        (let [#_"Symbol" ___sym (ß (Symbol) RT'third(___f))]
                                                                            (when (ß ___sym.getNamespace() != nil)
                                                                                (throw (Util'runtimeException-1 (str "Can't bind qualified name:" ___sym)))
                                                                            )

                                                                            (let [#_"IPersistentMap" ___dynamicBindings
                                                                                    (ß RT'map(
                                                                                        (§ map
                                                                                            Compiler'LOCAL_ENV        Compiler'LOCAL_ENV.deref()
                                                                                            Compiler'NEXT_LOCAL_NUM   Compiler'NEXT_LOCAL_NUM.deref()
                                                                                            Compiler'IN_CATCH_FINALLY RT'T
                                                                                        )
                                                                                    ))]
                                                                                (try
                                                                                    (Var'pushThreadBindings ___dynamicBindings)
                                                                                    (let [#_"LocalBinding" ___lb (ß registerLocal(___sym, (Symbol) ((RT'second(___f) instanceof Symbol) ? RT'second(___f) :or nil), nil, false))]
                                                                                        (let [#_"Expr" ___handler (ß (BodyParser'new()).parse(:Context'EXPRESSION, RT'next(RT'next(RT'next(___f)))))]
                                                                                            (§ ass ___catches (ß ___catches.cons(CatchClause'new(___c, ___lb, ___handler))))
                                                                                        )
                                                                                    )
                                                                                    (finally
                                                                                        (ß Var'popThreadBindings())
                                                                                    )
                                                                                )
                                                                                (§ ass ___caught true)
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                :else ;; finally
                                                                (do
                                                                    (when (ß ___fs.next() != nil)
                                                                        (throw (Util'runtimeException-1 "finally clause must be last in try expression"))
                                                                    )
                                                                    (try
                                                                        (ß Var'pushThreadBindings(RT'map(
                                                                            (§ map
                                                                                Compiler'IN_CATCH_FINALLY RT'T
                                                                            )
                                                                        )))
                                                                        (§ ass ___finallyExpr (ß (BodyParser'new()).parse(:Context'STATEMENT, RT'next(___f))))
                                                                        (finally
                                                                            (ß Var'popThreadBindings())
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (when (nil? ___bodyExpr)
                                            ;; this codepath is hit when there is neither catch or finally, e.g. (try (expr))
                                            ;; return a body expr directly
                                            (try
                                                (ß Var'pushThreadBindings(RT'map(
                                                    (§ map
                                                        Compiler'NO_RECUR true
                                                    )
                                                )))
                                                (§ ass ___bodyExpr (ß (BodyParser'new()).parse(___context, RT'seq(___body))))
                                                (finally
                                                    (ß Var'popThreadBindings())
                                                )
                                            )
                                            (§ return ___bodyExpr)
                                        )

                                        (TryExpr'new ___bodyExpr, ___catches, ___finallyExpr, ___retLocal, ___finallyLocal)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns TryExpr (§ implements Expr)
    (defn- #_"TryExpr" TryExpr'init []
        (hash-map
            #_"Expr" :tryExpr nil
            #_"Expr" :finallyExpr nil
            #_"PersistentVector" :catchExprs nil
            #_"int" :retLocal 0
            #_"int" :finallyLocal 0
        )
    )

    (defn #_"TryExpr" TryExpr'new [#_"Expr" ___tryExpr, #_"PersistentVector" ___catchExprs, #_"Expr" ___finallyExpr, #_"int" ___retLocal, #_"int" ___finallyLocal]
        (let [this (TryExpr'init)]
            (§ ass (:tryExpr this) ___tryExpr)
            (§ ass (:catchExprs this) ___catchExprs)
            (§ ass (:finallyExpr this) ___finallyExpr)
            (§ ass (:retLocal this) ___retLocal)
            (§ ass (:finallyLocal this) ___finallyLocal)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"TryExpr" this]
        (throw (UnsupportedOperationException. "Can't eval try"))
    )

    #_method
    (§ defn #_"void" emit [#_"TryExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___startTry (ß ___gen.newLabel())]
            (let [#_"Label" ___endTry (ß ___gen.newLabel())]
                (let [#_"Label" ___end (ß ___gen.newLabel())]
                    (let [#_"Label" ___ret (ß ___gen.newLabel())]
                        (let [#_"Label" ___finallyLabel (ß ___gen.newLabel())]
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                    (§ ass (:label ___clause) (ß ___gen.newLabel()))
                                    (§ ass (:endLabel ___clause) (ß ___gen.newLabel()))
                                )
                            )

                            (ß ___gen.mark(___startTry))
                            (ß (:tryExpr this).emit(___context, ___objx, ___gen))
                            (when (ß ___context != :Context'STATEMENT)
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:retLocal this)))
                            )
                            (ß ___gen.mark(___endTry))
                            (when (some? (:finallyExpr this))
                                (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                            )
                            (ß ___gen.goTo(___ret))

                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                    (ß ___gen.mark((:label ___clause)))
                                    ;; exception should be on stack
                                    ;; put in clause local
                                    (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:lb ___clause).idx))
                                    (ß (:handler ___clause).emit(___context, ___objx, ___gen))
                                    (when (ß ___context != :Context'STATEMENT)
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:retLocal this)))
                                    )
                                    (ß ___gen.mark((:endLabel ___clause)))

                                    (when (some? (:finallyExpr this))
                                        (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                                    )
                                    (ß ___gen.goTo(___ret))
                                )
                            )
                            (when (some? (:finallyExpr this))
                                (ß ___gen.mark(___finallyLabel))
                                ;; exception should be on stack
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:finallyLocal this)))
                                (ß (:finallyExpr this).emit(:Context'STATEMENT, ___objx, ___gen))
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:finallyLocal this)))
                                (ß ___gen.throwException())
                            )
                            (ß ___gen.mark(___ret))
                            (when (ß ___context != :Context'STATEMENT)
                                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:retLocal this)))
                            )
                            (ß ___gen.mark(___end))
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                    (ß ___gen.visitTryCatchBlock(___startTry, ___endTry, (:label ___clause), (:c ___clause).getName().replace(\., \/)))
                                )
                            )
                            (when (some? (:finallyExpr this))
                                (ß ___gen.visitTryCatchBlock(___startTry, ___endTry, ___finallyLabel, nil))
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                    (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                        (ß ___gen.visitTryCatchBlock((:label ___clause), (:endLabel ___clause), ___finallyLabel, nil))
                                    )
                                )
                            )
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:catchExprs this).count()) [(inc ___i)]
                                (let [#_"CatchClause" ___clause (ß (CatchClause) (:catchExprs this).nth(___i))]
                                    (ß ___gen.visitLocalVariable((:lb ___clause).name, "Ljava/lang/Object;", nil, (:label ___clause), (:endLabel ___clause), (:lb ___clause).idx))
                                )
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"TryExpr" this]
        (ß (:tryExpr this).hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"TryExpr" this]
        (ß (:tryExpr this).getJavaClass())
    )
)

#_closure
(class-ns ThrowParser (§ implements IParser)
    (defn #_"ThrowParser" ThrowParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"ThrowParser" this, #_"Context" ___context, #_"Object" ___form]
        (cond (ß ___context == :Context'EVAL)
            (do
                (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )
            (ß RT'count(___form) == 1)
            (do
                (throw (Util'runtimeException-1 "Too few arguments to throw, throw expects a single Throwable instance"))
            )
            (ß RT'count(___form) > 2)
            (do
                (throw (Util'runtimeException-1 "Too many arguments to throw, throw expects a single Throwable instance"))
            )
        )
        (ß ThrowExpr'new(analyze(:Context'EXPRESSION, RT'second(___form))))
    )
)

(class-ns ThrowExpr (§ extends UntypedExpr)
    (defn- #_"ThrowExpr" ThrowExpr'init []
        (hash-map
            #_"Expr" :excExpr nil
        )
    )

    (defn #_"ThrowExpr" ThrowExpr'new [#_"Expr" ___excExpr]
        (let [this (merge (UntypedExpr'new) (ThrowExpr'init))]
            (§ ass (:excExpr this) ___excExpr)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"ThrowExpr" this]
        (throw (Util'runtimeException-1 "Can't eval throw"))
    )

    #_method
    (§ defn #_"void" emit [#_"ThrowExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:excExpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(Compiler'THROWABLE_TYPE))
        (ß ___gen.throwException())
        nil
    )
)

#_closure
(class-ns NewParser (§ implements IParser)
    (defn #_"NewParser" NewParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"NewParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"int" ___line (ß lineDeref())]
            (let [#_"int" ___column (ß columnDeref())]
                (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
                    ;; (new Classname args...)
                    (when (ß ___form.count() < 2)
                        (throw (Util'runtimeException-1 "wrong number of arguments, expecting: (new Classname args...)"))
                    )
                    (let [#_"Class" ___c (ß HostExpr'maybeClass(RT'second(___form), false))]
                        (when (nil? ___c)
                            (throw (IllegalArgumentException. (str "Unable to resolve classname: " (ß RT'second(___form)))))
                        )
                        (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                            (loop-when-recur [#_"ISeq" ___s (ß RT'next(RT'next(___form)))] (some? ___s) [(ß ___s.next())]
                                (§ ass ___args (ß ___args.cons(analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___s.first()))))
                            )
                            (NewExpr'new ___c, ___args, ___line, ___column)
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewExpr (§ implements Expr)
    (def #_"Method" NewExpr'invokeConstructorMethod (Method/getMethod "Object invokeConstructor(Class,Object[])"))
    (def #_"Method" NewExpr'forNameMethod (Method/getMethod "Class classForName(String)"))

    (defn- #_"NewExpr" NewExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"Constructor" :ctor nil
            #_"Class" :c nil
        )
    )

    (defn #_"NewExpr" NewExpr'new [#_"Class" ___c, #_"IPersistentVector" ___args, #_"int" ___line, #_"int" ___column]
        (let [this (NewExpr'init)]
            (§ ass (:args this) ___args)
            (§ ass (:c this) ___c)
            (let [#_"Constructor[]" ___allctors (ß ___c.getConstructors())]
                (let [#_"ArrayList" ___ctors (ArrayList.)]
                    (let [#_"ArrayList<Class[]>" ___params (ArrayList.)]
                        (let [#_"ArrayList<Class>" ___rets (ArrayList.)]
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allctors.length) [(inc ___i)]
                                (let [#_"Constructor" ___ctor (ß ___allctors[___i])]
                                    (when (ß ___ctor.getParameterTypes().length == ___args.count())
                                        (ß ___ctors.add(___ctor))
                                        (ß ___params.add(___ctor.getParameterTypes()))
                                        (ß ___rets.add(___c))
                                    )
                                )
                            )
                            (when (ß ___ctors.isEmpty())
                                (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                            )

                            (let [#_"int" ___ctoridx 0]
                                (when (ß ___ctors.size() > 1)
                                    (§ ass ___ctoridx (ß getMatchingParams(___c.getName(), ___params, ___args, ___rets)))
                                )

                                (§ ass (:ctor this) (ß (___ctoridx >= 0) ? (Constructor) ___ctors.get(___ctoridx) :or nil))
                                (when (ß (:ctor this) == nil && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                    (ß RT'errPrintWriter().format("Reflection warning, %s:%d:%d - call to %s ctor can't be resolved.\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column, (ß ___c.getName()))))
                                )
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"NewExpr" this]
        (let [#_"Object[]" ___argvals (make-array Object (ß (:args this).count()))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass (ß ___argvals[___i]) (ß ((Expr) (:args this).nth(___i)).eval()))
            )
            (when (ß (:ctor this) != nil)
                (try
                    (§ return (ß (:ctor this).newInstance(Reflector'boxArgs((:ctor this).getParameterTypes(), ___argvals))))
                    (catch Exception ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
            (Reflector'invokeConstructor (:c this), ___argvals)
        )
    )

    #_method
    (§ defn #_"void" emit [#_"NewExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:ctor this) != nil)
            (do
                (let [#_"Type" ___type (ß getType((:c this)))]
                    (ß ___gen.newInstance(___type))
                    (ß ___gen.dup())
                    (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:ctor this).getParameterTypes(), (:args this)))
                    (ß ___gen.invokeConstructor(___type, (Method. "<init>", (Type/getConstructorDescriptor (:ctor this)))))
                )
            )
            (do
                (ß ___gen.push(destubClassName((:c this).getName())))
                (ß ___gen.invokeStatic(Compiler'RT_TYPE, NewExpr'forNameMethod))
                (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
                (ß ___gen.invokeStatic(Compiler'REFLECTOR_TYPE, invokeConstructorMethod))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"NewExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"NewExpr" this]
        (:c this)
    )
)

(class-ns MetaExpr (§ implements Expr)
    (def #_"Type" MetaExpr'IOBJ_TYPE (ß Type/getType((§ class IObj))))
    (def #_"Method" MetaExpr'withMetaMethod (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

    (defn- #_"MetaExpr" MetaExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Expr" :meta nil
        )
    )

    (defn #_"MetaExpr" MetaExpr'new [#_"Expr" ___expr, #_"Expr" ___meta]
        (let [this (MetaExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MetaExpr" this]
        (ß ((IObj) (:expr this).eval()).withMeta((IPersistentMap) (:meta this).eval()))
    )

    #_method
    (§ defn #_"void" emit [#_"MetaExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(MetaExpr'IOBJ_TYPE))
        (ß (:meta this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.checkCast(Compiler'IPERSISTENTMAP_TYPE))
        (ß ___gen.invokeInterface(MetaExpr'IOBJ_TYPE, MetaExpr'withMetaMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"MetaExpr" this]
        (ß (:expr this).hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"MetaExpr" this]
        (ß (:expr this).getJavaClass())
    )
)

#_closure
(class-ns IfParser (§ implements IParser)
    (defn #_"IfParser" IfParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"IfParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (if test then) or (if test then else)
            (cond (ß ___form.count() > 4)
                (do
                    (throw (Util'runtimeException-1 "Too many arguments to if"))
                )
                (ß ___form.count() < 3)
                (do
                    (throw (Util'runtimeException-1 "Too few arguments to if"))
                )
            )
            (let [#_"PathNode" ___branch (ß PathNode'new(:PathType'BRANCH, (PathNode) Compiler'CLEAR_PATH.get()))]
                (let [#_"Expr" ___testexpr (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, RT'second(___form)))]
                    (let [(ß Expr thenexpr, elseexpr)]
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (§ map
                                    Compiler'CLEAR_PATH PathNode'new(:PathType'PATH, ___branch)
                                )
                            )))
                            (§ ass thenexpr (ß analyze(___context, RT'third(___form))))
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (§ map
                                    Compiler'CLEAR_PATH PathNode'new(:PathType'PATH, ___branch)
                                )
                            )))
                            (§ ass elseexpr (ß analyze(___context, RT'fourth(___form))))
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                        (ß IfExpr'new(lineDeref(), columnDeref(), ___testexpr, thenexpr, elseexpr))
                    )
                )
            )
        )
    )
)

(class-ns IfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"IfExpr" IfExpr'init []
        (hash-map
            #_"Expr" :testExpr nil
            #_"Expr" :thenExpr nil
            #_"Expr" :elseExpr nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"IfExpr" IfExpr'new [#_"int" ___line, #_"int" ___column, #_"Expr" ___testExpr, #_"Expr" ___thenExpr, #_"Expr" ___elseExpr]
        (let [this (IfExpr'init)]
            (§ ass (:testExpr this) ___testExpr)
            (§ ass (:thenExpr this) ___thenExpr)
            (§ ass (:elseExpr this) ___elseExpr)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"IfExpr" this]
        (let [#_"Object" ___t (ß (:testExpr this).eval())]
            (when (ß ___t != nil && ___t != Boolean/FALSE)
                (§ return (ß (:thenExpr this).eval()))
            )
            (ß (:elseExpr this).eval())
        )
    )

    #_method
    (§ defn #_"void" emit [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, false))
        nil
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, true))
        nil
    )

    #_method
    (§ defn #_"void" doEmit [#_"IfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"Label" ___nullLabel (ß ___gen.newLabel())]
            (let [#_"Label" ___falseLabel (ß ___gen.newLabel())]
                (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
                    (ß ___gen.visitLineNumber((:line this), ___gen.mark()))

                    (cond (ß (:testExpr this) instanceof StaticMethodExpr && ((StaticMethodExpr)this.testExpr).canEmitIntrinsicPredicate())
                        (do
                            (ß ((StaticMethodExpr) (:testExpr this)).emitIntrinsicPredicate(:Context'EXPRESSION, ___objx, ___gen, ___falseLabel))
                        )
                        (ß maybePrimitiveType((:testExpr this)) == (§ class boolean))
                        (do
                            (ß ((MaybePrimitiveExpr) (:testExpr this)).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                            (ß ___gen.ifZCmp(___gen.EQ, ___falseLabel))
                        )
                        :else
                        (do
                            (ß (:testExpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                            (ß ___gen.dup())
                            (ß ___gen.ifNull(___nullLabel))
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE))
                            (ß ___gen.visitJumpInsn(IF_ACMPEQ, ___falseLabel))
                        )
                    )
                    (if ___emitUnboxed
                        (do
                            (ß ((MaybePrimitiveExpr)this.thenExpr).emitUnboxed(___context, ___objx, ___gen))
                        )
                        (do
                            (ß (:thenExpr this).emit(___context, ___objx, ___gen))
                        )
                    )
                    (ß ___gen.goTo(___endLabel))
                    (ß ___gen.mark(___nullLabel))
                    (ß ___gen.pop())
                    (ß ___gen.mark(___falseLabel))
                    (if ___emitUnboxed
                        (do
                            (ß ((MaybePrimitiveExpr)this.elseExpr).emitUnboxed(___context, ___objx, ___gen))
                        )
                        (do
                            (ß (:elseExpr this).emit(___context, ___objx, ___gen))
                        )
                    )
                    (ß ___gen.mark(___endLabel))
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"IfExpr" this]
        (ß (:thenExpr this).hasJavaClass()
            && (:elseExpr this).hasJavaClass()
            && ((:thenExpr this).getJavaClass() == (:elseExpr this).getJavaClass()
                || (:thenExpr this).getJavaClass() == Compiler'RECUR_CLASS
                || (:elseExpr this).getJavaClass() == Compiler'RECUR_CLASS
                || ((:thenExpr this).getJavaClass() == nil && !this.elseExpr.getJavaClass().isPrimitive())
                || ((:elseExpr this).getJavaClass() == nil && !this.thenExpr.getJavaClass().isPrimitive())))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"IfExpr" this]
        (try
            (ß (:thenExpr this) instanceof MaybePrimitiveExpr
                && (:elseExpr this) instanceof MaybePrimitiveExpr
                && ((:thenExpr this).getJavaClass() == (:elseExpr this).getJavaClass()
                        || (:thenExpr this).getJavaClass() == Compiler'RECUR_CLASS
                        || (:elseExpr this).getJavaClass() == Compiler'RECUR_CLASS)
                && ((MaybePrimitiveExpr)this.thenExpr).canEmitPrimitive()
                && ((MaybePrimitiveExpr)this.elseExpr).canEmitPrimitive())
            (catch Exception ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"IfExpr" this]
        (let [#_"Class" ___thenClass (ß (:thenExpr this).getJavaClass())]
            (when (ß ___thenClass != nil && ___thenClass != Compiler'RECUR_CLASS)
                (§ return ___thenClass)
            )
            (ß (:elseExpr this).getJavaClass())
        )
    )
)

(class-ns EmptyExpr (§ implements Expr)
    (def #_"Type" EmptyExpr'HASHMAP_TYPE (ß Type/getType((§ class PersistentArrayMap))))
    (def #_"Type" EmptyExpr'HASHSET_TYPE (ß Type/getType((§ class PersistentHashSet))))
    (def #_"Type" EmptyExpr'VECTOR_TYPE (ß Type/getType((§ class PersistentVector))))
    (def #_"Type" EmptyExpr'IVECTOR_TYPE (ß Type/getType((§ class IPersistentVector))))
    (def #_"Type" EmptyExpr'TUPLE_TYPE (ß Type/getType((§ class Tuple))))
    (def #_"Type" EmptyExpr'LIST_TYPE (ß Type/getType((§ class PersistentList))))
    (def #_"Type" EmptyExpr'EMPTY_LIST_TYPE (ß Type/getType((§ class EmptyList))))

    (defn- #_"EmptyExpr" EmptyExpr'init []
        (hash-map
            #_"Object" :coll nil
        )
    )

    (defn #_"EmptyExpr" EmptyExpr'new [#_"Object" ___coll]
        (let [this (EmptyExpr'init)]
            (§ ass (:coll this) ___coll)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"EmptyExpr" this]
        (:coll this)
    )

    #_method
    (§ defn #_"void" emit [#_"EmptyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (cond (ß (:coll this) instanceof IPersistentList)
            (do
                (ß ___gen.getStatic(EmptyExpr'LIST_TYPE, "EMPTY", EmptyExpr'EMPTY_LIST_TYPE))
            )
            (ß (:coll this) instanceof IPersistentVector)
            (do
                (ß ___gen.getStatic(EmptyExpr'VECTOR_TYPE, "EMPTY", EmptyExpr'VECTOR_TYPE))
            )
            (ß (:coll this) instanceof IPersistentMap)
            (do
                (ß ___gen.getStatic(EmptyExpr'HASHMAP_TYPE, "EMPTY", EmptyExpr'HASHMAP_TYPE))
            )
            (ß (:coll this) instanceof IPersistentSet)
            (do
                (ß ___gen.getStatic(EmptyExpr'HASHSET_TYPE, "EMPTY", EmptyExpr'HASHSET_TYPE))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Unknown Collection type"))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"EmptyExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"EmptyExpr" this]
        (cond (ß (:coll this) instanceof IPersistentList)
            (do
                (§ class IPersistentList)
            )
            (ß (:coll this) instanceof IPersistentVector)
            (do
                (§ class IPersistentVector)
            )
            (ß (:coll this) instanceof IPersistentMap)
            (do
                (§ class IPersistentMap)
            )
            (ß (:coll this) instanceof IPersistentSet)
            (do
                (§ class IPersistentSet)
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Unknown Collection type"))
            )
        )
    )
)

(class-ns ListExpr (§ implements Expr)
    (def #_"Method" ListExpr'arrayToListMethod (Method/getMethod "cloiure.lang.ISeq arrayToList(Object[])"))

    (defn- #_"ListExpr" ListExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"ListExpr" ListExpr'new [#_"IPersistentVector" ___args]
        (let [this (ListExpr'init)]
            (§ ass (:args this) ___args)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"ListExpr" this]
        (let [#_"IPersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass ___ret (ß (IPersistentVector) ___ret.cons(((Expr) (:args this).nth(___i)).eval())))
            )
            (ß ___ret.seq())
        )
    )

    #_method
    (§ defn #_"void" emit [#_"ListExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
        (ß ___gen.invokeStatic(Compiler'RT_TYPE, ListExpr'arrayToListMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"ListExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"ListExpr" this]
        (§ class IPersistentList)
    )
)

(class-ns MapExpr (§ implements Expr)
    (def #_"Method" MapExpr'mapMethod (Method/getMethod "cloiure.lang.IPersistentMap map(Object[])"))
    (def #_"Method" MapExpr'mapUniqueKeysMethod (Method/getMethod "cloiure.lang.IPersistentMap mapUniqueKeys(Object[])"))

    (defn- #_"MapExpr" MapExpr'init []
        (hash-map
            #_"IPersistentVector" :keyvals nil
        )
    )

    (defn #_"MapExpr" MapExpr'new [#_"IPersistentVector" ___keyvals]
        (let [this (MapExpr'init)]
            (§ ass (:keyvals this) ___keyvals)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MapExpr" this]
        (let [#_"Object[]" ___ret (make-array Object (ß (:keyvals this).count()))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals this).count()) [(inc ___i)]
                (§ ass (ß ___ret[___i]) (ß ((Expr) (:keyvals this).nth(___i)).eval()))
            )
            (RT'map ___ret)
        )
    )

    #_method
    (§ defn #_"void" emit [#_"MapExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"boolean" ___allKeysConstant true]
            (let [#_"boolean" ___allConstantKeysUnique true]
                (let [#_"IPersistentSet" ___constantKeys PersistentHashSet'EMPTY]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keyvals this).count()) [(+ ___i 2)]
                        (let [#_"Expr" ___k (ß (Expr) (:keyvals this).nth(___i))]
                            (if (ß ___k instanceof LiteralExpr)
                                (do
                                    (let [#_"Object" ___kval (ß ___k.eval())]
                                        (if (ß ___constantKeys.contains(___kval))
                                            (do
                                                (§ ass ___allConstantKeysUnique false)
                                            )
                                            (do
                                                (§ ass ___constantKeys (ß (IPersistentSet)___constantKeys.cons(___kval)))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (§ ass ___allKeysConstant false)
                                )
                            )
                        )
                    )
                    (MethodExpr'emitArgsAsArray (:keyvals this), ___objx, ___gen)
                    (if (ß (___allKeysConstant && ___allConstantKeysUnique) || ((:keyvals this).count() <= 2))
                        (do
                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, mapUniqueKeysMethod))
                        )
                        (do
                            (ß ___gen.invokeStatic(Compiler'RT_TYPE, mapMethod))
                        )
                    )
                    (when (ß ___context == :Context'STATEMENT)
                        (ß ___gen.pop())
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"MapExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"MapExpr" this]
        (§ class IPersistentMap)
    )

    (defn #_"Expr" MapExpr'parse [#_"Context" ___context, #_"IPersistentMap" ___form]
        (let [#_"IPersistentVector" ___keyvals PersistentVector'EMPTY]
            (let [#_"boolean" ___keysConstant true]
                (let [#_"boolean" ___valsConstant true]
                    (let [#_"boolean" ___allConstantKeysUnique true]
                        (let [#_"IPersistentSet" ___constantKeys PersistentHashSet'EMPTY]
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(ß ___s.next())]
                                (let [#_"IMapEntry" ___e (ß (IMapEntry) ___s.first())]
                                    (let [#_"Expr" ___k (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___e.key()))]
                                        (let [#_"Expr" ___v (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___e.val()))]
                                            (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___k)))
                                            (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___v)))
                                            (if (ß ___k instanceof LiteralExpr)
                                                (do
                                                    (let [#_"Object" ___kval (ß ___k.eval())]
                                                        (if (ß ___constantKeys.contains(___kval))
                                                            (do
                                                                (§ ass ___allConstantKeysUnique false)
                                                            )
                                                            (do
                                                                (§ ass ___constantKeys (ß (IPersistentSet)___constantKeys.cons(___kval)))
                                                            )
                                                        )
                                                    )
                                                )
                                                (do
                                                    (§ ass ___keysConstant false)
                                                )
                                            )
                                            (when (ß !(___v instanceof LiteralExpr))
                                                (§ ass ___valsConstant false)
                                            )
                                        )
                                    )
                                )
                            )

                            (let [#_"Expr" ___ret (MapExpr'new ___keyvals)]
                                (cond (ß ___form instanceof IObj && ((IObj) ___form).meta() != nil)
                                    (do
                                        (ß MetaExpr'new(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___form).meta())))
                                    )
                                    ___keysConstant
                                    (do
                                        ;; TBD: Add more detail to exception thrown below.
                                        (when (ß !___allConstantKeysUnique)
                                            (throw (IllegalArgumentException. "Duplicate constant keys in map"))
                                        )
                                        (if ___valsConstant
                                            (do
                                                (let [#_"IPersistentMap" ___m PersistentArrayMap'EMPTY]
                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___keyvals.length()) [(+ ___i 2)]
                                                        (§ ass ___m (ß ___m.assoc(((LiteralExpr)___keyvals.nth(___i)).val(), ((LiteralExpr)___keyvals.nth(___i + 1)).val())))
                                                    )
                                                    (ConstantExpr'new ___m)
                                                )
                                            )
                                            (do
                                                ___ret
                                            )
                                        )
                                    )
                                    :else
                                    (do
                                        ___ret
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns SetExpr (§ implements Expr)
    (def #_"Method" SetExpr'setMethod (Method/getMethod "cloiure.lang.IPersistentSet set(Object[])"))

    (defn- #_"SetExpr" SetExpr'init []
        (hash-map
            #_"IPersistentVector" :keys nil
        )
    )

    (defn #_"SetExpr" SetExpr'new [#_"IPersistentVector" ___keys]
        (let [this (SetExpr'init)]
            (§ ass (:keys this) ___keys)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"SetExpr" this]
        (let [#_"Object[]" ___ret (make-array Object (ß (:keys this).count()))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keys this).count()) [(inc ___i)]
                (§ ass (ß ___ret[___i]) (ß ((Expr) (:keys this).nth(___i)).eval()))
            )
            (RT'set ___ret)
        )
    )

    #_method
    (§ defn #_"void" emit [#_"SetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (MethodExpr'emitArgsAsArray (:keys this), ___objx, ___gen)
        (ß ___gen.invokeStatic(Compiler'RT_TYPE, setMethod))
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"SetExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"SetExpr" this]
        (§ class IPersistentSet)
    )

    (defn #_"Expr" SetExpr'parse [#_"Context" ___context, #_"IPersistentSet" ___form]
        (let [#_"IPersistentVector" ___keys PersistentVector'EMPTY]
            (let [#_"boolean" ___constant true]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(ß ___s.next())]
                    (let [#_"Object" ___e (ß ___s.first())]
                        (let [#_"Expr" ___expr (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___e))]
                            (§ ass ___keys (ß (IPersistentVector) ___keys.cons(___expr)))
                            (when (ß !(___expr instanceof LiteralExpr))
                                (§ ass ___constant false)
                            )
                        )
                    )
                )
                (let [#_"Expr" ___ret (SetExpr'new ___keys)]
                    (cond (ß ___form instanceof IObj && ((IObj) ___form).meta() != nil)
                        (do
                            (ß MetaExpr'new(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___form).meta())))
                        )
                        ___constant
                        (do
                            (let [#_"IPersistentSet" ___set PersistentHashSet'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___keys.count()) [(inc ___i)]
                                    (let [#_"LiteralExpr" ___ve (ß (LiteralExpr)___keys.nth(___i))]
                                        (§ ass ___set (ß (IPersistentSet)___set.cons(___ve.val())))
                                    )
                                )
                                (ConstantExpr'new ___set)
                            )
                        )
                        :else
                        (do
                            ___ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns VectorExpr (§ implements Expr)
    (def #_"Method" VectorExpr'vectorMethod (Method/getMethod "cloiure.lang.IPersistentVector vector(Object[])"))

    (defn- #_"VectorExpr" VectorExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
        )
    )

    (defn #_"VectorExpr" VectorExpr'new [#_"IPersistentVector" ___args]
        (let [this (VectorExpr'init)]
            (§ ass (:args this) ___args)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"VectorExpr" this]
        (let [#_"IPersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                (§ ass ___ret (ß (IPersistentVector) ___ret.cons(((Expr) (:args this).nth(___i)).eval())))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"void" emit [#_"VectorExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (ß (:args this).count() <= Tuple'MAX_SIZE)
            (do
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                    (ß ((Expr) (:args this).nth(___i)).emit(:Context'EXPRESSION, ___objx, ___gen))
                )
                (ß ___gen.invokeStatic(Compiler'TUPLE_TYPE, createTupleMethods[(:args this).count()]))
            )
            (do
                (MethodExpr'emitArgsAsArray (:args this), ___objx, ___gen)
                (ß ___gen.invokeStatic(Compiler'RT_TYPE, vectorMethod))
            )
        )

        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"VectorExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"VectorExpr" this]
        (§ class IPersistentVector)
    )

    (defn #_"Expr" VectorExpr'parse [#_"Context" ___context, #_"IPersistentVector" ___form]
        (let [#_"boolean" ___constant true]
            (let [#_"IPersistentVector" ___args PersistentVector'EMPTY]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___form.count()) [(inc ___i)]
                    (let [#_"Expr" ___v (ß analyze((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___form.nth(___i)))]
                        (§ ass ___args (ß (IPersistentVector) ___args.cons(___v)))
                        (when (ß !(___v instanceof LiteralExpr))
                            (§ ass ___constant false)
                        )
                    )
                )
                (let [#_"Expr" ___ret (VectorExpr'new ___args)]
                    (cond (ß ___form instanceof IObj && ((IObj) ___form).meta() != nil)
                        (do
                            (ß MetaExpr'new(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___form).meta())))
                        )
                        ___constant
                        (do
                            (let [#_"IPersistentVector" ___rv PersistentVector'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___args.count()) [(inc ___i)]
                                    (let [#_"LiteralExpr" ___ve (ß (LiteralExpr)___args.nth(___i))]
                                        (§ ass ___rv (ß ___rv.cons(___ve.val())))
                                    )
                                )
                                (ConstantExpr'new ___rv)
                            )
                        )
                        :else
                        (do
                            ___ret
                        )
                    )
                )
            )
        )
    )
)

(class-ns KeywordInvokeExpr (§ implements Expr)
    (def #_"Type" KeywordInvokeExpr'ILOOKUP_TYPE (ß Type/getType((§ class ILookup))))

    (defn- #_"KeywordInvokeExpr" KeywordInvokeExpr'init []
        (hash-map
            #_"KeywordExpr" :kw nil
            #_"Object" :tag nil
            #_"Expr" :target nil
            #_"int" :line 0
            #_"int" :column 0
            #_"int" :siteIndex 0
            #_"String" :source nil

            #_"Class" :jc nil
        )
    )

    (defn #_"KeywordInvokeExpr" KeywordInvokeExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"KeywordExpr" ___kw, #_"Expr" ___target]
        (let [this (KeywordInvokeExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:kw this) ___kw)
            (§ ass (:target this) ___target)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tag this) ___tag)
            (§ ass (:siteIndex this) (ß registerKeywordCallsite((:k ___kw))))
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"KeywordInvokeExpr" this]
        (try
            (ß (:kw this).k.invoke((:target this).eval()))
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emit [#_"KeywordInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
            (let [#_"Label" ___faultLabel (ß ___gen.newLabel())]
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.getStatic((:objtype ___objx), ___objx.thunkNameStatic((:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE))
                (ß ___gen.dup()) ;; thunk, thunk
                (ß (:target this).emit(:Context'EXPRESSION, ___objx, ___gen)) ;; thunk, thunk, target
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.dupX2()) ;; target, thunk, thunk, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_THUNK_TYPE, Method/getMethod("Object get(Object)"))) ;; target, thunk, result
                (ß ___gen.dupX2()) ;; result, target, thunk, result
                (ß ___gen.visitJumpInsn(IF_ACMPEQ, ___faultLabel)) ;; result, target
                (ß ___gen.pop()) ;; result
                (ß ___gen.goTo(___endLabel))

                (ß ___gen.mark(___faultLabel)) ;; result, target
                (ß ___gen.swap()) ;; target, result
                (ß ___gen.pop()) ;; target
                (ß ___gen.dup()) ;; target, target
                (ß ___gen.getStatic((:objtype ___objx), ___objx.siteNameStatic((:siteIndex this)), ObjExpr'KEYWORD_LOOKUPSITE_TYPE)) ;; target, target, site
                (ß ___gen.swap()) ;; target, site, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_SITE_TYPE, Method/getMethod("cloiure.lang.ILookupThunk fault(Object)"))) ;; target, new-thunk
                (ß ___gen.dup()) ;; target, new-thunk, new-thunk
                (ß ___gen.putStatic((:objtype ___objx), ___objx.thunkNameStatic((:siteIndex this)), ObjExpr'ILOOKUP_THUNK_TYPE)) ;; target, new-thunk
                (ß ___gen.swap()) ;; new-thunk, target
                (ß ___gen.invokeInterface(ObjExpr'ILOOKUP_THUNK_TYPE, Method/getMethod("Object get(Object)"))) ;; result

                (ß ___gen.mark(___endLabel))
                (when (ß ___context == :Context'STATEMENT)
                    (ß ___gen.pop())
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"KeywordInvokeExpr" this]
        (ß ((:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"KeywordInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )
)

(class-ns InstanceOfExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"InstanceOfExpr" InstanceOfExpr'init []
        (hash-map
            #_"Expr" :expr nil
            #_"Class" :c nil
        )
    )

    (defn #_"InstanceOfExpr" InstanceOfExpr'new [#_"Class" ___c, #_"Expr" ___expr]
        (let [this (InstanceOfExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"InstanceOfExpr" this]
        (when (ß (:c this).isInstance((:expr this).eval()))
            (§ return RT'T)
        )
        RT'F
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"InstanceOfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.instanceOf(getType((:c this))))
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"InstanceOfExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß emitUnboxed(___context, ___objx, ___gen))
        (HostExpr'emitBoxReturn ___objx, ___gen, Boolean/TYPE)
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"InstanceOfExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"InstanceOfExpr" this]
        Boolean/TYPE
    )
)

(class-ns StaticInvokeExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"StaticInvokeExpr" StaticInvokeExpr'init []
        (hash-map
            #_"Type" :target nil
            #_"Class" :retClass nil
            #_"Class[]" :paramclasses nil
            #_"Type[]" :paramtypes nil
            #_"IPersistentVector" :args nil
            #_"boolean" :variadic false
            #_"boolean" :tailPosition false
            #_"Object" :tag nil

            #_"Class" :jc nil
        )
    )

    (defn #_"StaticInvokeExpr" StaticInvokeExpr'new [#_"Type" ___target, #_"Class" ___retClass, #_"Class[]" ___paramclasses, #_"Type[]" ___paramtypes, #_"boolean" ___variadic, #_"IPersistentVector" ___args, #_"Object" ___tag, #_"boolean" ___tailPosition]
        (let [this (StaticInvokeExpr'init)]
            (§ ass (:target this) ___target)
            (§ ass (:retClass this) ___retClass)
            (§ ass (:paramclasses this) ___paramclasses)
            (§ ass (:paramtypes this) ___paramtypes)
            (§ ass (:args this) ___args)
            (§ ass (:variadic this) ___variadic)
            (§ ass (:tailPosition this) ___tailPosition)
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"StaticInvokeExpr" this]
        (throw (UnsupportedOperationException. "Can't eval StaticInvokeExpr"))
    )

    #_method
    (§ defn #_"void" emit [#_"StaticInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß emitUnboxed(___context, ___objx, ___gen))
        (when (ß ___context != :Context'STATEMENT)
            (HostExpr'emitBoxReturn ___objx, ___gen, (:retClass this))
        )
        (when (ß ___context == :Context'STATEMENT)
            (if (ß (:retClass this) == (§ class long) || (:retClass this) == (§ class double))
                (do
                    (ß ___gen.pop2())
                )
                (do
                    (ß ___gen.pop())
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"StaticInvokeExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"StaticInvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß retType(((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or nil, (:retClass this))))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"StaticInvokeExpr" this]
        (ß (:retClass this).isPrimitive())
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"StaticInvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Method" ___ms (Method. "invokeStatic", (ß getReturnType()), (:paramtypes this))]
            (if (:variadic this)
                (do
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:paramclasses this).length - 1) [(inc ___i)]
                        (let [#_"Expr" ___e (ß (Expr) (:args this).nth(___i))]
                            (if (ß maybePrimitiveType(___e) == (:paramclasses this)[___i])
                                (do
                                    (ß ((MaybePrimitiveExpr) ___e).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                )
                                (do
                                    (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                                    (ß HostExpr'emitUnboxArg(___objx, ___gen, (:paramclasses this)[___i]))
                                )
                            )
                        )
                    )
                    (let [#_"IPersistentVector" ___restArgs (ß RT'subvec((:args this), (:paramclasses this).length - 1, (:args this).count()))]
                        (MethodExpr'emitArgsAsArray ___restArgs, ___objx, ___gen)
                        (ß ___gen.invokeStatic(Type/getType((§ class ArraySeq)), Method/getMethod("cloiure.lang.ArraySeq create(Object[])")))
                    )
                )
                (do
                    (MethodExpr'emitTypedArgs ___objx, ___gen, (:paramclasses this), (:args this))
                )
            )

            (when (ß (:tailPosition this) && !___objx.canBeDirect)
                (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                    (ß ___method.emitClearThis(___gen))
                )
            )

            (ß ___gen.invokeStatic((:target this), ___ms))
            nil
        )
    )

    #_method
    (§ defn- #_"Type" getReturnType [#_"StaticInvokeExpr" this]
        (Type/getType (:retClass this))
    )

    (defn #_"Expr" StaticInvokeExpr'parse [#_"Var" ___v, #_"ISeq" ___args, #_"Object" ___tag, #_"boolean" ___tailPosition]
        (when (ß !___v.isBound() || ___v.get() == nil)
            (§ return nil)
        )
        (let [#_"Class" ___c (ß ___v.get().getClass())]
            (let [#_"String" ___cname (ß ___c.getName())]
                (let [#_"java.lang.reflect.Method[]" ___allmethods (ß ___c.getMethods())]
                    (let [#_"boolean" ___variadic false]
                        (let [#_"int" ___argcount (RT'count ___args)]
                            (let [#_"java.lang.reflect.Method" ___method nil]
                                (doseq [#_"java.lang.reflect.Method" ___m ___allmethods]
                                    (when (ß Modifier/isStatic(___m.getModifiers()) && ___m.getName().equals("invokeStatic"))
                                        (let [#_"Class[]" ___params (ß ___m.getParameterTypes())]
                                            (cond (ß ___argcount == ___params.length)
                                                (do
                                                    (§ ass ___method ___m)
                                                    (§ ass ___variadic (ß (___argcount > 0 && ___params[___params.length - 1] == (§ class ISeq))))
                                                    (§ break )
                                                )
                                                (ß ___argcount > ___params.length && ___params.length > 0 && ___params[___params.length - 1] == (§ class ISeq))
                                                (do
                                                    (§ ass ___method ___m)
                                                    (§ ass ___variadic true)
                                                    (§ break )
                                                )
                                            )
                                        )
                                    )
                                )
                                (when (nil? ___method)
                                    (§ return nil)
                                )

                                (let [#_"Class" ___retClass (ß ___method.getReturnType())]
                                    (let [#_"Class[]" ___paramClasses (ß ___method.getParameterTypes())]
                                        (let [#_"Type[]" ___paramTypes (make-array Type (ß ___paramClasses.length))]
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___paramClasses.length) [(inc ___i)]
                                                (§ ass (ß ___paramTypes[___i]) (ß Type/getType(___paramClasses[___i])))
                                            )

                                            (let [#_"Type" ___target (§ unsure Type/getType ___c)]
                                                (let [#_"PersistentVector" ___argv PersistentVector'EMPTY]
                                                    (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(ß ___s.next())]
                                                        (§ ass ___argv (ß ___argv.cons(analyze(:Context'EXPRESSION, ___s.first()))))
                                                    )

                                                    (StaticInvokeExpr'new ___target, ___retClass, ___paramClasses, ___paramTypes, ___variadic, ___argv, ___tag, ___tailPosition)
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns InvokeExpr (§ implements Expr)
    (§ def #_"Keyword" InvokeExpr'onKey (Keyword'intern-1 "on"))
    (§ def #_"Keyword" InvokeExpr'methodMapKey (Keyword'intern-1 "method-map"))

    (defn #_"Object" InvokeExpr'sigTag [#_"int" ___argcount, #_"Var" ___v]
        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), arglistsKey))]
            (let [#_"Object" ___sigTag nil]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___arglists)] (some? ___s) [(ß ___s.next())]
                    (let [#_"APersistentVector" ___sig (ß (APersistentVector) ___s.first())]
                        (let [#_"int" ___restOffset (ß ___sig.indexOf(Compiler'_AMP_))]
                            (when (ß ___argcount == ___sig.count() || (___restOffset > -1 && ___argcount >= ___restOffset))
                                (§ return (ß tagOf(___sig)))
                            )
                        )
                    )
                )
                nil
            )
        )
    )

    (defn- #_"InvokeExpr" InvokeExpr'init []
        (hash-map
            #_"Expr" :fexpr nil
            #_"Object" :tag nil
            #_"IPersistentVector" :args nil
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :tailPosition false
            #_"String" :source nil

            #_"boolean" :isProtocol false
            #_"boolean" :isDirect false
            #_"int" :siteIndex -1
            #_"Class" :protocolOn nil
            #_"java.lang.reflect.Method" :onMethod nil

            #_"Class" :jc nil
        )
    )

    (defn #_"InvokeExpr" InvokeExpr'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Symbol" ___tag, #_"Expr" ___fexpr, #_"IPersistentVector" ___args, #_"boolean" ___tailPosition]
        (let [this (InvokeExpr'init)]
            (§ ass (:source this) ___source)
            (§ ass (:fexpr this) ___fexpr)
            (§ ass (:args this) ___args)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:tailPosition this) ___tailPosition)

            (when (ß ___fexpr instanceof VarExpr)
                (let [#_"Var" ___fvar (ß ((VarExpr)___fexpr).var)]
                    (let [#_"Var" ___pvar (ß (Var)RT'get-2(___fvar.meta(), protocolKey))]
                        (when (ß ___pvar != nil && Compiler'PROTOCOL_CALLSITES.isBound())
                            (§ ass (:isProtocol this) true)
                            (§ ass (:siteIndex this) (ß registerProtocolCallsite(((VarExpr)___fexpr).var)))
                            (let [#_"Object" ___pon (ß RT'get-2(___pvar.get(), onKey))]
                                (§ ass (:protocolOn this) (HostExpr'maybeClass ___pon, false))
                                (when (ß (:protocolOn this) != nil)
                                    (let [#_"IPersistentMap" ___mmap (ß (IPersistentMap) RT'get-2(___pvar.get(), methodMapKey))]
                                        (let [#_"Keyword" ___mmapVal (ß (Keyword) ___mmap.valAt(Keyword'intern((:sym ___fvar))))]
                                            (when (nil? ___mmapVal)
                                                (throw (IllegalArgumentException. (str "No method of interface: " (ß (:protocolOn this).getName()) " found for function: " (:sym ___fvar) " of protocol: " (:sym ___pvar) " (The protocol method may have been defined before and removed.)")))
                                            )
                                            (let [#_"String" ___mname (ß munge((:sym ___mmapVal).toString()))]
                                                (let [#_"List" ___methods (ß Reflector'getMethods((:protocolOn this), ___args.count() - 1, ___mname, false))]
                                                    (when (ß ___methods.size() != 1)
                                                        (throw (IllegalArgumentException. (str "No single method: " ___mname " of interface: " (ß (:protocolOn this).getName()) " found for function: " (:sym ___fvar) " of protocol: " (:sym ___pvar))))
                                                    )
                                                    (§ ass (:onMethod this) (ß (java.lang.reflect.Method) ___methods.get(0)))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (cond (some? ___tag)
                (do
                    (§ ass (:tag this) ___tag)
                )
                (ß ___fexpr instanceof VarExpr)
                (do
                    (let [#_"Var" ___v (ß ((VarExpr) ___fexpr).var)]
                        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), arglistsKey))]
                            (let [#_"Object" ___sigTag (ß ___sigTag(___args.count(), ___v))]
                                (§ ass (:tag this) (ß (___sigTag == nil) ? ((VarExpr) ___fexpr).tag :or ___sigTag))
                            )
                        )
                    )
                )
                :else
                (do
                    (§ ass (:tag this) nil)
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"InvokeExpr" this]
        (try
            (let [#_"IFn" ___fn (ß (IFn) (:fexpr this).eval())]
                (let [#_"PersistentVector" ___argvs PersistentVector'EMPTY]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:args this).count()) [(inc ___i)]
                        (§ ass ___argvs (ß ___argvs.cons(((Expr) (:args this).nth(___i)).eval())))
                    )
                    (ß ___fn.applyTo(RT'seq(Util'ret1(___argvs, (§ ass ___argvs nil)))))
                )
            )
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (CompilerException'new (:source this), (:line this), (:column this), ___e))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emit [#_"InvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (if (:isProtocol this)
            (do
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß emitProto(___context, ___objx, ___gen))
            )
            (do
                (ß (:fexpr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.visitLineNumber((:line this), ___gen.mark()))
                (ß ___gen.checkCast(Compiler'IFN_TYPE))
                (ß emitArgsAndCall(0, ___context, ___objx, ___gen))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"void" emitProto [#_"InvokeExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___onLabel (ß ___gen.newLabel())]
            (let [#_"Label" ___callLabel (ß ___gen.newLabel())]
                (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
                    (let [#_"Var" ___v (ß ((VarExpr)this.fexpr).var)]
                        (let [#_"Expr" ___e (ß (Expr) (:args this).nth(0))]
                            (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
                            (ß ___gen.dup()) ;; target, target
                            (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, Method/getMethod("Class classOf(Object)"))) ;; target, class
                            (ß ___gen.getStatic((:objtype ___objx), ___objx.cachedClassName((:siteIndex this)), Compiler'CLASS_TYPE)) ;; target, class, cached-class
                            (ß ___gen.visitJumpInsn(IF_ACMPEQ, ___callLabel)) ;; target
                            (when (some? (:protocolOn this))
                                (ß ___gen.dup()) ;; target, target
                                (ß ___gen.instanceOf(Type/getType((:protocolOn this))))
                                (ß ___gen.ifZCmp(GeneratorAdapter/NE, ___onLabel))
                            )

                            (ß ___gen.dup()) ;; target, target
                            (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, Method/getMethod("Class classOf(Object)"))) ;; target, class
                            (ß ___gen.putStatic((:objtype ___objx), ___objx.cachedClassName((:siteIndex this)), Compiler'CLASS_TYPE)) ;; target

                            (ß ___gen.mark(___callLabel)) ;; target
                            (ß ___objx.emitVar(___gen, ___v))
                            (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, Method/getMethod("Object getRawRoot()"))) ;; target, proto-fn
                            (ß ___gen.swap())
                            (ß emitArgsAndCall(1, ___context, ___objx, ___gen))
                            (ß ___gen.goTo(___endLabel))

                            (ß ___gen.mark(___onLabel)) ;; target
                            (when (some? (:protocolOn this))
                                (ß ___gen.checkCast(Type/getType((:protocolOn this))))
                                (ß MethodExpr'emitTypedArgs(___objx, ___gen, (:onMethod this).getParameterTypes(), RT'subvec((:args this), 1, (:args this).count())))
                                (when (ß ___context == :Context'RETURN)
                                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                                        (ß ___method.emitClearLocals(___gen))
                                    )
                                )
                                (let [#_"Method" ___m (Method. (ß (:onMethod this).getName()), (Type/getReturnType (:onMethod this)), (Type/getArgumentTypes (:onMethod this)))]
                                    (ß ___gen.invokeInterface(Type/getType((:protocolOn this)), ___m))
                                    (ß HostExpr'emitBoxReturn(___objx, ___gen, (:onMethod this).getReturnType()))
                                )
                            )
                            (ß ___gen.mark(___endLabel))
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emitArgsAndCall [#_"InvokeExpr" this, #_"int" ___firstArgToEmit, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i ___firstArgToEmit] (ß ___i < Math/min(Compiler'MAX_POSITIONAL_ARITY, (:args this).count())) [(inc ___i)]
            (let [#_"Expr" ___e (ß (Expr) (:args this).nth(___i))]
                (ß ___e.emit(:Context'EXPRESSION, ___objx, ___gen))
            )
        )
        (when (ß (:args this).count() > Compiler'MAX_POSITIONAL_ARITY)
            (let [#_"PersistentVector" ___restArgs PersistentVector'EMPTY]
                (loop-when-recur [#_"int" ___i Compiler'MAX_POSITIONAL_ARITY] (ß ___i < (:args this).count()) [(inc ___i)]
                    (§ ass ___restArgs (ß ___restArgs.cons((:args this).nth(___i))))
                )
                (MethodExpr'emitArgsAsArray ___restArgs, ___objx, ___gen)
            )
        )
        (ß ___gen.visitLineNumber((:line this), ___gen.mark()))

        (when (ß (:tailPosition this) && !___objx.canBeDirect)
            (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                (ß ___method.emitClearThis(___gen))
            )
        )

        (ß ___gen.invokeInterface(Compiler'IFN_TYPE, (Method. "invoke", Compiler'OBJECT_TYPE, (ß Compiler'ARG_TYPES[Math/min(Compiler'MAX_POSITIONAL_ARITY + 1, (:args this).count())]))))
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"InvokeExpr" this]
        (ß ((:tag this) != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"InvokeExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
        )
        (:jc this)
    )

    (defn #_"Expr" InvokeExpr'parse [#_"Context" ___context, #_"ISeq" ___form]
        (let [#_"boolean" ___tailPosition (ß inTailCall(___context))]
            (when (ß ___context != :Context'EVAL)
                (§ ass ___context (ß :Context'EXPRESSION))
            )
            (let [#_"Expr" ___fexpr (ß analyze(___context, ___form.first()))]
                (when (ß ___fexpr instanceof VarExpr && ((VarExpr)___fexpr).var.equals(Compiler'INSTANCE) && RT'count(___form) == 3)
                    (let [#_"Expr" ___sexpr (ß analyze(:Context'EXPRESSION, RT'second(___form)))]
                        (when (ß ___sexpr instanceof ConstantExpr)
                            (let [#_"Object" ___val (ß ((ConstantExpr) ___sexpr).val())]
                                (when (ß ___val instanceof Class)
                                    (§ return (ß InstanceOfExpr'new((Class) ___val, analyze(___context, RT'third(___form)))))
                                )
                            )
                        )
                    )
                )

                (when (ß RT'booleanCast-1o(Compiler'getCompilerOption(directLinkingKey)) && ___fexpr instanceof VarExpr && ___context != :Context'EVAL)
                    (let [#_"Var" ___v (ß ((VarExpr)___fexpr).var)]
                        (when (ß !___v.isDynamic() && !RT'booleanCast-1o(RT'get-3(___v.meta(), redefKey, false)))
                            (let [#_"Symbol" ___formtag (ß tagOf(___form))]
                                (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), arglistsKey))]
                                    (let [#_"int" ___arity (ß RT'count(___form.next()))]
                                        (let [#_"Object" ___sigtag (ß sigTag(___arity, ___v))]
                                            (let [#_"Object" ___vtag (ß RT'get-2(RT'meta(___v), RT'TAG_KEY))]
                                                (let [#_"Expr" ___ret (ß StaticInvokeExpr'parse(___v, RT'next(___form), (___formtag != nil) ? ___formtag :or (___sigtag != nil) ? ___sigtag :or ___vtag, ___tailPosition))]
                                                    (when (some? ___ret)
                                                        (§ return ___ret)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (when (ß ___fexpr instanceof VarExpr && ___context != :Context'EVAL)
                    (let [#_"Var" ___v (ß ((VarExpr)___fexpr).var)]
                        (let [#_"Object" ___arglists (ß RT'get-2(RT'meta(___v), arglistsKey))]
                            (let [#_"int" ___arity (ß RT'count(___form.next()))]
                                (loop-when-recur [#_"ISeq" ___s (RT'seq ___arglists)] (some? ___s) [(ß ___s.next())]
                                    (let [#_"IPersistentVector" ___args (ß (IPersistentVector) ___s.first())]
                                        (when (ß ___args.count() == ___arity)
                                            (let [#_"String" ___primc (FnMethod'primInterface ___args)]
                                                (when (some? ___primc)
                                                    (§ return (ß analyze(___context, ((IObj)RT'listStar-3(Symbol'intern-1(".invokePrim"), ((Symbol) ___form.first()).withMeta(RT'map(RT'TAG_KEY, Symbol'intern-1(___primc))), ___form.next())).withMeta((IPersistentMap)RT'conj(RT'meta(___v), RT'meta(___form))))))
                                                )
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (when (ß ___fexpr instanceof KeywordExpr && RT'count(___form) == 2 && Compiler'KEYWORD_CALLSITES.isBound())
                    (let [#_"Expr" ___target (ß analyze(___context, RT'second(___form)))]
                        (§ return (ß KeywordInvokeExpr'new((String) Compiler'SOURCE.deref(), lineDeref(), columnDeref(), tagOf(___form), (KeywordExpr) ___fexpr, ___target)))
                    )
                )
                (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                    (loop-when-recur [#_"ISeq" ___s (ß RT'seq(___form.next()))] (some? ___s) [(ß ___s.next())]
                        (§ ass ___args (ß ___args.cons(analyze(___context, ___s.first()))))
                    )

                    (ß InvokeExpr'new((String) Compiler'SOURCE.deref(), lineDeref(), columnDeref(), tagOf(___form), ___fexpr, ___args, ___tailPosition))
                )
            )
        )
    )
)

#_stateless
(class-ns SourceDebugExtensionAttribute (§ extends Attribute)
    (defn #_"SourceDebugExtensionAttribute" SourceDebugExtensionAttribute'new []
        (Attribute'new "SourceDebugExtension")
    )

    #_method
    (§ defn #_"void" writeSMAP [#_"SourceDebugExtensionAttribute" this, #_"ClassWriter" ___cw, #_"String" ___smap]
        (let [#_"ByteVector" ___bv (ß write(___cw, nil, -1, -1, -1))]
            (ß ___bv.putUTF8(___smap))
            nil
        )
    )
)

(class-ns FnExpr (§ extends ObjExpr)
    (def #_"Type" FnExpr'aFnType (ß Type/getType((§ class AFunction))))
    (def #_"Type" FnExpr'restFnType (ß Type/getType((§ class RestFn))))

    (defn- #_"FnExpr" FnExpr'init []
        (hash-map
            ;; if there is a variadic overload (there can only be one) it is stored here
            #_"FnMethod" :variadicMethod nil
            #_"IPersistentCollection" :methods nil
            #_"boolean" :hasPrimSigs false
            #_"boolean" :hasMeta false
            #_"boolean" :hasEnclosingMethod false

            #_"Class" :jc nil
        )
    )

    (defn #_"FnExpr" FnExpr'new [#_"Object" ___tag]
        (merge (ObjExpr'new ___tag) (FnExpr'init))
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"FnExpr" this]
        true
    )

    #_method
    (§ defn #_"boolean" supportsMeta [#_"FnExpr" this]
        (:hasMeta this)
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"FnExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß ((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or (§ class AFunction)))
        )
        (:jc this)
    )

    #_protected
    #_method
    (§ defn #_"void" emitMethods [#_"FnExpr" this, #_"ClassVisitor" ___cv]
        ;; override of invoke/doInvoke for each method
        (loop-when-recur [#_"ISeq" ___s (RT'seq (:methods this))] (some? ___s) [(ß ___s.next())]
            (let [#_"ObjMethod" ___method (ß (ObjMethod) ___s.first())]
                (ß ___method.emit(this, ___cv))
            )
        )

        (when (ß isVariadic())
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, (Method/getMethod "int getRequiredArity()"), nil, nil, ___cv)]
                (ß ___gen.visitCode())
                (ß ___gen.push((:variadicMethod this).reqParms.count()))
                (ß ___gen.returnValue())
                (ß ___gen.endMethod())
            )
        )
        nil
    )

    (defn #_"Expr" FnExpr'parse [#_"Context" ___context, #_"ISeq" ___form, #_"String" ___name]
        (let [#_"ISeq" ___origForm ___form]
            (let [#_"FnExpr" ___fn (ß FnExpr'new(tagOf(___form)))]
                (let [#_"Keyword" ___retkey (Keyword'intern-2 nil, "rettag")]
                    (let [#_"Object" ___rettag (ß RT'get-2(RT'meta(___form), ___retkey))]
                        (§ ass (:src ___fn) ___form)
                        (let [#_"ObjMethod" ___enclosingMethod (ß (ObjMethod) Compiler'METHOD.deref())]
                            (§ ass (:hasEnclosingMethod ___fn) (ß ___enclosingMethod != nil))
                            (when (ß ((IMeta) ___form.first()).meta() != nil)
                                (§ ass (:onceOnly ___fn) (ß RT'booleanCast-1o(RT'get-2(RT'meta(___form.first()), Keyword'intern-2(nil, "once")))))
                            )

                            (let [#_"String" ___basename (ß ((___enclosingMethod != nil) ? (:objx ___enclosingMethod).name :or munge(currentNS().name.name)) + "$")]
                                (let [#_"Symbol" ___nm nil]
                                    (if (ß RT'second(___form) instanceof Symbol)
                                        (do
                                            (§ ass ___nm (ß (Symbol) RT'second(___form)))
                                            (§ ass ___name (ß (:name ___nm) + "__" + RT'nextID()))
                                        )
                                        (do
                                            (cond (nil? ___name)
                                                (do
                                                    (§ ass ___name (ß "fn__" + RT'nextID()))
                                                )
                                                (some? ___enclosingMethod)
                                                (do
                                                    (§ ass ___name (ß ___name + "__" + RT'nextID()))
                                                )
                                            )
                                        )
                                    )

                                    (let [#_"String" ___simpleName (ß munge(___name).replace(".", "_DOT_"))]
                                        (§ ass (:name ___fn) (+ ___basename ___simpleName))
                                        (§ ass (:internalName ___fn) (ß (:name ___fn).replace(\., \/)))
                                        (§ ass (:objtype ___fn) (ß Type/getObjectType((:internalName ___fn))))
                                        (let [#_"ArrayList<String>" ___prims (ArrayList.)]
                                            (try
                                                (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                    (§ map
                                                        Compiler'CONSTANTS          PersistentVector'EMPTY
                                                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                                                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                                                        Compiler'VARS               PersistentHashMap'EMPTY
                                                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                                                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                                                        Compiler'VAR_CALLSITES      (ß emptyVarCallSites())
                                                        Compiler'NO_RECUR           nil
                                                    )
                                                )))

                                                ;; arglist might be preceded by symbol naming this fn
                                                (when (some? ___nm)
                                                    (§ ass (:thisName ___fn) (:name ___nm))
                                                    (§ ass ___form (ß RT'cons(Compiler'FN, RT'next(RT'next(___form)))))
                                                )

                                                ;; now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
                                                ;; turn former into latter
                                                (when (ß RT'second(___form) instanceof IPersistentVector)
                                                    (§ ass ___form (ß RT'list-2(Compiler'FN, RT'next(___form))))
                                                )
                                                (§ ass (:line ___fn) (ß lineDeref()))
                                                (§ ass (:column ___fn) (ß columnDeref()))
                                                (let [#_"FnMethod[]" ___methodArray (ß FnMethod'new[Compiler'MAX_POSITIONAL_ARITY + 1])]
                                                    (let [#_"FnMethod" ___variadicMethod nil]
                                                        (let [#_"boolean" ___usesThis false]
                                                            (loop-when-recur [#_"ISeq" ___s (RT'next ___form)] (some? ___s) [(RT'next ___s)]
                                                                (let [#_"FnMethod" ___f (ß FnMethod'parse(___fn, (ISeq) RT'first(___s), ___rettag))]
                                                                    (when (:usesThis ___f)
                                                                        (§ ass ___usesThis true)
                                                                    )
                                                                    (cond (ß ___f.isVariadic())
                                                                        (do
                                                                            (if (nil? ___variadicMethod)
                                                                                (do
                                                                                    (§ ass ___variadicMethod ___f)
                                                                                )
                                                                                (do
                                                                                    (throw (Util'runtimeException-1 "Can't have more than 1 variadic overload"))
                                                                                )
                                                                            )
                                                                        )
                                                                        (ß ___methodArray[(:reqParms ___f).count()] == nil)
                                                                        (do
                                                                            (§ ass (ß ___methodArray[(:reqParms ___f).count()]) ___f)
                                                                        )
                                                                        :else
                                                                        (do
                                                                            (throw (Util'runtimeException-1 "Can't have 2 overloads with same arity"))
                                                                        )
                                                                    )
                                                                    (when (ß (:prim ___f) != nil)
                                                                        (ß ___prims.add((:prim ___f)))
                                                                    )
                                                                )
                                                            )
                                                            (when (some? ___variadicMethod)
                                                                (loop-when-recur [#_"int" ___i (ß (:reqParms ___variadicMethod).count() + 1)] (ß ___i <= Compiler'MAX_POSITIONAL_ARITY) [(inc ___i)]
                                                                    (when (ß ___methodArray[___i] != nil)
                                                                        (throw (Util'runtimeException-1 "Can't have fixed arity function with more params than variadic function"))
                                                                    )
                                                                )
                                                            )

                                                            (§ ass (:canBeDirect ___fn) (ß (!___fn.hasEnclosingMethod && (:closes ___fn).count() == 0 && !___usesThis)))

                                                            (let [#_"IPersistentCollection" ___methods nil]
                                                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___methodArray.length) [(inc ___i)]
                                                                    (when (ß ___methodArray[___i] != nil)
                                                                        (§ ass ___methods (ß RT'conj(___methods, ___methodArray[___i])))
                                                                    )
                                                                )
                                                                (when (some? ___variadicMethod)
                                                                    (§ ass ___methods (RT'conj ___methods, ___variadicMethod))
                                                                )

                                                                (when (:canBeDirect ___fn)
                                                                    (doseq [#_"FnMethod" ___fm (ß (Collection<FnMethod>)___methods)]
                                                                        (when (ß (:locals ___fm) != nil)
                                                                            (doseq [#_"LocalBinding" ___lb (ß (Collection<LocalBinding>)RT'keys((:locals ___fm)))]
                                                                                (when (:isArg ___lb)
                                                                                    (§ ass (:idx ___lb) (ß (:idx ___lb) - 1))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )

                                                                (§ ass (:methods ___fn) ___methods)
                                                                (§ ass (:variadicMethod ___fn) ___variadicMethod)
                                                                (§ ass (:keywords ___fn) (ß (IPersistentMap) Compiler'KEYWORDS.deref()))
                                                                (§ ass (:vars ___fn) (ß (IPersistentMap) Compiler'VARS.deref()))
                                                                (§ ass (:constants ___fn) (ß (PersistentVector) Compiler'CONSTANTS.deref()))
                                                                (§ ass (:keywordCallsites ___fn) (ß (IPersistentVector) Compiler'KEYWORD_CALLSITES.deref()))
                                                                (§ ass (:protocolCallsites ___fn) (ß (IPersistentVector) Compiler'PROTOCOL_CALLSITES.deref()))
                                                                (§ ass (:varCallsites ___fn) (ß (IPersistentSet) Compiler'VAR_CALLSITES.deref()))

                                                                (§ ass (:constantsID ___fn) (ß RT'nextID()))
                                                            )
                                                        )
                                                    )
                                                )
                                                (finally
                                                    (ß Var'popThreadBindings())
                                                )
                                            )
                                            (§ ass (:hasPrimSigs ___fn) (ß ___prims.size() > 0))
                                            (let [#_"IPersistentMap" ___fmeta (RT'meta ___origForm)]
                                                (when (some? ___fmeta)
                                                    (§ ass ___fmeta (ß ___fmeta.without(RT'LINE_KEY).without(RT'COLUMN_KEY).without(RT'FILE_KEY).without(___retkey)))
                                                )

                                                (§ ass (:hasMeta ___fn) (ß RT'count(___fmeta) > 0))

                                                (try
                                                    (ß ___fn.compile(___fn.isVariadic() ? "cloiure/lang/RestFn" :or "cloiure/lang/AFunction", (___prims.size() == 0) ? nil :or ___prims.toArray(new String[___prims.size()]), (:onceOnly ___fn)))
                                                    (catch IOException ___e
                                                        (throw (Util'sneakyThrow ___e))
                                                    )
                                                )
                                                (ß ___fn.getCompiledClass())

                                                (if (ß ___fn.supportsMeta())
                                                    (do
                                                        (ß MetaExpr'new(___fn, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ___fmeta)))
                                                    )
                                                    (do
                                                        ___fn
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ObjMethod" variadicMethod [#_"FnExpr" this]
        (:variadicMethod this)
    )

    #_method
    (§ defn #_"boolean" isVariadic [#_"FnExpr" this]
        (ß ((:variadicMethod this) != nil))
    )

    #_method
    (§ defn #_"IPersistentCollection" methods [#_"FnExpr" this]
        (:methods this)
    )

    #_method
    (§ defn #_"void" emitForDefn [#_"FnExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß emit(:Context'EXPRESSION, ___objx, ___gen))
        nil
    )
)

(class-ns ObjExpr (§ implements Expr)
    (def #_"String" ObjExpr'CONST_PREFIX "const__")

    (def #_"Method" ObjExpr'voidctor (Method/getMethod "void <init>()"))

    (def #_"Method" ObjExpr'kwintern (Method/getMethod "cloiure.lang.Keyword intern(String, String)"))
    (def #_"Method" ObjExpr'symintern (Method/getMethod "cloiure.lang.Symbol intern(String)"))
    (def #_"Method" ObjExpr'varintern (Method/getMethod "cloiure.lang.Var intern(cloiure.lang.Symbol, cloiure.lang.Symbol)"))

    (def #_"Type" ObjExpr'DYNAMIC_CLASSLOADER_TYPE (ß Type/getType((§ class DynamicClassLoader))))
    (def #_"Method" ObjExpr'getClassMethod (Method/getMethod "Class getClass()"))
    (def #_"Method" ObjExpr'getClassLoaderMethod (Method/getMethod "ClassLoader getClassLoader()"))
    (def #_"Method" ObjExpr'getConstantsMethod (Method/getMethod "Object[] getConstants(int)"))
    (def #_"Method" ObjExpr'readStringMethod (Method/getMethod "Object readString(String)"))

    (def #_"Type" ObjExpr'ILOOKUP_SITE_TYPE (ß Type/getType((§ class ILookupSite))))
    (def #_"Type" ObjExpr'ILOOKUP_THUNK_TYPE (ß Type/getType((§ class ILookupThunk))))
    (def #_"Type" ObjExpr'KEYWORD_LOOKUPSITE_TYPE (ß Type/getType((§ class KeywordLookupSite))))

    (defn- #_"ObjExpr" ObjExpr'init []
        (hash-map
            #_"String" :name nil
            #_"String" :internalName nil
            #_"String" :thisName nil
            #_"Type" :objtype nil
            #_"Object" :tag nil
            ;; localbinding->itself
            #_"IPersistentMap" :closes PersistentHashMap'EMPTY
            ;; localbndingexprs
            #_"IPersistentVector" :closesExprs PersistentVector'EMPTY
            ;; symbols
            #_"IPersistentSet" :volatiles PersistentHashSet'EMPTY

            ;; symbol->lb
            #_"IPersistentMap" :fields nil

            ;; hinted fields
            #_"IPersistentVector" :hintedFields PersistentVector'EMPTY

            ;; Keyword->KeywordExpr
            #_"IPersistentMap" :keywords PersistentHashMap'EMPTY
            #_"IPersistentMap" :vars PersistentHashMap'EMPTY
            #_"Class" :compiledClass nil
            #_"int" :line 0
            #_"int" :column 0
            #_"PersistentVector" :constants nil
            #_"IPersistentSet" :usedConstants PersistentHashSet'EMPTY

            #_"int" :constantsID 0
            #_"int" :altCtorDrops 0

            #_"IPersistentVector" :keywordCallsites nil
            #_"IPersistentVector" :protocolCallsites nil
            #_"IPersistentSet" :varCallsites nil
            #_"boolean" :onceOnly false

            #_"Object" :src nil

            #_"IPersistentMap" :opts PersistentHashMap'EMPTY

            #_protected
            #_"IPersistentMap" :classMeta nil
            #_protected
            #_"boolean" :canBeDirect false

            #_"DynamicClassLoader" :loader nil
            #_"byte[]" :bytecode nil

            #_"Class" :jc nil
        )
    )

    (defn #_"ObjExpr" ObjExpr'new [#_"Object" ___tag]
        (let [this (ObjExpr'init)]
            (§ ass (:tag this) ___tag)
            this
        )
    )

    #_method
    (§ defn #_"String" name [#_"ObjExpr" this]
        (:name this)
    )

    #_method
    (§ defn #_"String" internalName [#_"ObjExpr" this]
        (:internalName this)
    )

    #_method
    (§ defn #_"String" thisName [#_"ObjExpr" this]
        (:thisName this)
    )

    #_method
    (§ defn #_"Type" objtype [#_"ObjExpr" this]
        (:objtype this)
    )

    #_method
    (§ defn #_"IPersistentMap" closes [#_"ObjExpr" this]
        (:closes this)
    )

    #_method
    (§ defn #_"IPersistentMap" keywords [#_"ObjExpr" this]
        (:keywords this)
    )

    #_method
    (§ defn #_"IPersistentMap" vars [#_"ObjExpr" this]
        (:vars this)
    )

    #_method
    (§ defn #_"Class" compiledClass [#_"ObjExpr" this]
        (:compiledClass this)
    )

    #_method
    (§ defn #_"int" line [#_"ObjExpr" this]
        (:line this)
    )

    #_method
    (§ defn #_"int" column [#_"ObjExpr" this]
        (:column this)
    )

    #_method
    (§ defn #_"PersistentVector" constants [#_"ObjExpr" this]
        (:constants this)
    )

    #_method
    (§ defn #_"int" constantsID [#_"ObjExpr" this]
        (:constantsID this)
    )

    (defn #_"String" ObjExpr'trimGenID [#_"String" ___name]
        (let [#_"int" ___i (ß ___name.lastIndexOf("__"))]
            (ß (___i == -1) ? ___name :or ___name.substring(0, ___i))
        )
    )

    #_method
    (§ defn #_"Type[]" ctorTypes [#_"ObjExpr" this]
        (let [#_"IPersistentVector" ___tv (ß !supportsMeta() ? PersistentVector'EMPTY :or RT'vector(Compiler'IPERSISTENTMAP_TYPE))]
            (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(ß ___s.next())]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                    (if (ß ___lb.getPrimitiveType() != nil)
                        (do
                            (§ ass ___tv (ß ___tv.cons(Type/getType(___lb.getPrimitiveType()))))
                        )
                        (do
                            (§ ass ___tv (ß ___tv.cons(Compiler'OBJECT_TYPE)))
                        )
                    )
                )
            )
            (let [#_"Type[]" ___ret (make-array Type (ß ___tv.count()))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___tv.count()) [(inc ___i)]
                    (§ ass (ß ___ret[___i]) (ß (Type) ___tv.nth(___i)))
                )
                ___ret
            )
        )
    )

    #_method
    (§ defn #_"void" compile [#_"ObjExpr" this, #_"String" ___superName, #_"String[]" ___interfaceNames, #_"boolean" ___oneTimeUse] #_(§ throws IOException)
        ;; create bytecode for a class
        ;; with name current_ns.defname[$letname]+
        ;; anonymous fns get names fn__id
        ;; derived from AFn'RestFn
        (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
            (let [#_"ClassVisitor" ___cv ___cw]
                (ß ___cv.visit(V1_5, Opcodes/ACC_PUBLIC + Opcodes/ACC_SUPER + Opcodes/ACC_FINAL, (:internalName this), nil, ___superName, ___interfaceNames))
                (let [#_"String" ___source (ß (String) Compiler'SOURCE.deref())]
                    (let [#_"int" ___lineBefore (ß (Integer) Compiler'LINE_BEFORE.deref())]
                        (let [#_"int" ___lineAfter (ß (Integer) Compiler'LINE_AFTER.deref() + 1)]
                            (let [#_"int" ___columnBefore (ß (Integer) Compiler'COLUMN_BEFORE.deref())]
                                (let [#_"int" ___columnAfter (ß (Integer) Compiler'COLUMN_AFTER.deref() + 1)]
                                    (when (ß ___source != nil && Compiler'SOURCE_PATH.deref() != nil)
                                        (let [#_"String" ___smap
                                                (str "SMAP\n"
                                                    (ß (___source.lastIndexOf(\.) > 0) ? ___source.substring(0, ___source.lastIndexOf(\.)) :or ___source) ;; :or simpleName
                                                    ".java\n"
                                                    "Cloiure\n"
                                                    "*S Cloiure\n"
                                                    "*F\n"
                                                    "+ 1 " ___source "\n"
                                                    (ß (String) Compiler'SOURCE_PATH.deref()) "\n"
                                                    "*L\n"
                                                    (ß String/format("%d#1,%d:%d\n", (§ array ___lineBefore, (- ___lineAfter ___lineBefore), ___lineBefore)))
                                                    "*E"
                                                )]
                                            (ß ___cv.visitSource(___source, ___smap))
                                        )
                                    )
                                    (ß addAnnotation(___cv, (:classMeta this)))

                                    (when (ß supportsMeta())
                                        (ß ___cv.visitField(Opcodes/ACC_FINAL, "__meta", Compiler'IPERSISTENTMAP_TYPE.getDescriptor(), nil, nil))
                                    )
                                    ;; instance fields for closed-overs
                                    (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(ß ___s.next())]
                                        (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                                            (if (ß isDeftype())
                                                (do
                                                    (let [#_"int" ___access (ß isVolatile(___lb) ? Opcodes/ACC_VOLATILE :or isMutable(___lb) ? 0 :or (Opcodes/ACC_PUBLIC + Opcodes/ACC_FINAL))]
                                                        (§ let [#_"FieldVisitor" ___fv]
                                                            (if (ß ___lb.getPrimitiveType() != nil)
                                                                (do
                                                                    (§ ass ___fv (ß ___cv.visitField(___access, (:name ___lb), Type/getType(___lb.getPrimitiveType()).getDescriptor(), nil, nil)))
                                                                )
                                                                (do
                                                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                                                    (§ ass ___fv (ß ___cv.visitField(___access, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil)))
                                                                )
                                                            )
                                                            (ß addAnnotation(___fv, RT'meta((:sym ___lb))))
                                                        )
                                                    )
                                                )
                                                (do
                                                    ;; todo - only enable this non-private+writability for letfns where we need it
                                                    (if (ß ___lb.getPrimitiveType() != nil)
                                                        (do
                                                            (ß ___cv.visitField(0 + (isVolatile(___lb) ? Opcodes/ACC_VOLATILE :or 0), (:name ___lb), Type/getType(___lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                                        )
                                                        (do
                                                            (ß ___cv.visitField(0, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )

                                    ;; static fields for callsites and thunks
                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:protocolCallsites this).count()) [(inc ___i)]
                                        (ß ___cv.visitField(Opcodes/ACC_PRIVATE + Opcodes/ACC_STATIC, cachedClassName(___i), Compiler'CLASS_TYPE.getDescriptor(), nil, nil))
                                    )

                                    ;; ctor that takes closed-overs and inits base + fields
                                    (let [#_"Method" ___m (Method. "<init>", Type/VOID_TYPE, (ß ctorTypes()))]
                                        (let [#_"GeneratorAdapter" ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, nil, ___cv)]
                                            (let [#_"Label" ___start (ß ___ctorgen.newLabel())]
                                                (let [#_"Label" ___end (ß ___ctorgen.newLabel())]
                                                    (ß ___ctorgen.visitCode())
                                                    (ß ___ctorgen.visitLineNumber((:line this), ___ctorgen.mark()))
                                                    (ß ___ctorgen.visitLabel(___start))
                                                    (ß ___ctorgen.loadThis())
                                                    (ß ___ctorgen.invokeConstructor(Type/getObjectType(___superName), voidctor))

                                                    (when (ß supportsMeta())
                                                        (ß ___ctorgen.loadThis())
                                                        (ß ___ctorgen.visitVarInsn(Compiler'IPERSISTENTMAP_TYPE.getOpcode(Opcodes/ILOAD), 1))
                                                        (ß ___ctorgen.putField((:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE))
                                                    )

                                                    (let [#_"int" ___a (ß supportsMeta() ? 2 :or 1)]
                                                        (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this)) ___a ___a] (some? ___s) [(ß ___s.next()) (inc ___a)]
                                                            (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                                                                (ß ___ctorgen.loadThis())
                                                                (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                                                                    (if (some? ___primc)
                                                                        (do
                                                                            (ß ___ctorgen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), ___a))
                                                                            (ß ___ctorgen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                                                                            (when (ß ___primc == Long/TYPE || ___primc == Double/TYPE)
                                                                                (§ ass ___a (inc ___a))
                                                                            )
                                                                        )
                                                                        (do
                                                                            (ß ___ctorgen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), ___a))
                                                                            (ß ___ctorgen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                                                                        )
                                                                    )
                                                                    (§ ass (:closesExprs this) (ß (:closesExprs this).cons(LocalBindingExpr'new(___lb, nil))))
                                                                )
                                                            )
                                                        )

                                                        (ß ___ctorgen.visitLabel(___end))

                                                        (ß ___ctorgen.returnValue())

                                                        (ß ___ctorgen.endMethod())

                                                        (when (> (:altCtorDrops this) 0)
                                                            ;; ctor that takes closed-overs and inits base + fields
                                                            (let [#_"Type[]" ___ctorTypes (ß ___ctorTypes())]
                                                                (let [#_"Type[]" ___altCtorTypes (make-array Type (ß ___ctorTypes.length - (:altCtorDrops this)))]
                                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___altCtorTypes.length) [(inc ___i)]
                                                                        (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                                                    )
                                                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes)]
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (ß ___ctorgen.visitCode())
                                                                        (ß ___ctorgen.loadThis())
                                                                        (ß ___ctorgen.loadArgs())

                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __meta
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __extmap
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (ß ___ctorgen.returnValue())
                                                                        (ß ___ctorgen.endMethod())

                                                                        ;; alt ctor no __hash, __hasheq
                                                                        (§ ass ___altCtorTypes (make-array Type (ß ___ctorTypes.length - 2)))
                                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___altCtorTypes.length) [(inc ___i)]
                                                                            (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                                                        )

                                                                        (§ ass ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes))
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (ß ___ctorgen.visitCode())
                                                                        (ß ___ctorgen.loadThis())
                                                                        (ß ___ctorgen.loadArgs())

                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (ß ___ctorgen.returnValue())
                                                                        (ß ___ctorgen.endMethod())
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (when (ß supportsMeta())
                                                            ;; ctor that takes closed-overs but not meta
                                                            (let [#_"Type[]" ___ctorTypes (ß ___ctorTypes())]
                                                                (let [#_"Type[]" ___noMetaCtorTypes (make-array Type (ß ___ctorTypes.length - 1))]
                                                                    (loop-when-recur [#_"int" ___i 1] (ß ___i < ___ctorTypes.length) [(inc ___i)]
                                                                        (§ ass (ß ___noMetaCtorTypes[___i - 1]) (ß ___ctorTypes[___i]))
                                                                    )
                                                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___noMetaCtorTypes)]
                                                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                                                        (ß ___ctorgen.visitCode())
                                                                        (ß ___ctorgen.loadThis())
                                                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; nil meta
                                                                        (ß ___ctorgen.loadArgs())
                                                                        (ß ___ctorgen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                                                        (ß ___ctorgen.returnValue())
                                                                        (ß ___ctorgen.endMethod())

                                                                        ;; meta()
                                                                        (let [#_"Method" ___meth (Method/getMethod "cloiure.lang.IPersistentMap meta()")]
                                                                            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___meth, nil, nil, ___cv)]
                                                                                (ß ___gen.visitCode())
                                                                                (ß ___gen.loadThis())
                                                                                (ß ___gen.getField((:objtype this), "__meta", Compiler'IPERSISTENTMAP_TYPE))

                                                                                (ß ___gen.returnValue())
                                                                                (ß ___gen.endMethod())

                                                                                ;; withMeta()
                                                                                (§ ass ___meth (Method/getMethod "cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)"))

                                                                                (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___meth, nil, nil, ___cv))
                                                                                (ß ___gen.visitCode())
                                                                                (ß ___gen.newInstance((:objtype this)))
                                                                                (ß ___gen.dup())
                                                                                (ß ___gen.loadArg(0))

                                                                                (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this)) ___a ___a] (some? ___s) [(ß ___s.next()) (inc ___a)]
                                                                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                                                                                        (ß ___gen.loadThis())
                                                                                        (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                                                                                            (if (some? ___primc)
                                                                                                (do
                                                                                                    (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                                                                                                )
                                                                                                (do
                                                                                                    (ß ___gen.getField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )

                                                                                (ß ___gen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))
                                                                                (ß ___gen.returnValue())
                                                                                (ß ___gen.endMethod())
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )

                                                        (ß emitStatics(___cv))
                                                        (ß emitMethods(___cv))

                                                        ;; static fields for constants
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants this).count()) [(inc ___i)]
                                                            (when (ß (:usedConstants this).contains(___i))
                                                                (ß ___cv.visitField(Opcodes/ACC_PUBLIC + Opcodes/ACC_FINAL + Opcodes/ACC_STATIC, constantName(___i), constantType(___i).getDescriptor(), nil, nil))
                                                            )
                                                        )

                                                        ;; static fields for lookup sites
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keywordCallsites this).count()) [(inc ___i)]
                                                            (ß ___cv.visitField(Opcodes/ACC_FINAL + Opcodes/ACC_STATIC, siteNameStatic(___i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE.getDescriptor(), nil, nil))
                                                            (ß ___cv.visitField(Opcodes/ACC_STATIC, thunkNameStatic(___i), ObjExpr'ILOOKUP_THUNK_TYPE.getDescriptor(), nil, nil))
                                                        )

                                                        ;; static init for constants, keywords and vars
                                                        (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, ___cv)]
                                                            (ß ___clinitgen.visitCode())
                                                            (ß ___clinitgen.visitLineNumber((:line this), ___clinitgen.mark()))

                                                            (when (ß (:constants this).count() > 0)
                                                                (ß emitConstants(___clinitgen))
                                                            )

                                                            (when (ß (:keywordCallsites this).count() > 0)
                                                                (ß emitKeywordCallsites(___clinitgen))
                                                            )

                                                            (when (ß isDeftype() && RT'booleanCast-1o(RT'get-2((:opts this), loadNs)))
                                                                (let [#_"String" ___nsname (ß ((Symbol)RT'second((:src this))).getNamespace())]
                                                                    (when (ß !___nsname.equals("cloiure.core"))
                                                                        (ß ___clinitgen.push("cloiure.core"))
                                                                        (ß ___clinitgen.push("require"))
                                                                        (ß ___clinitgen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Var var(String,String)")))
                                                                        (ß ___clinitgen.invokeVirtual(Compiler'VAR_TYPE, Method/getMethod("Object getRawRoot()")))
                                                                        (ß ___clinitgen.checkCast(Compiler'IFN_TYPE))
                                                                        (ß ___clinitgen.push(___nsname))
                                                                        (ß ___clinitgen.invokeStatic(Compiler'SYMBOL_TYPE, Method/getMethod("cloiure.lang.Symbol create(String)")))
                                                                        (ß ___clinitgen.invokeInterface(Compiler'IFN_TYPE, Method/getMethod("Object invoke(Object)")))
                                                                        (ß ___clinitgen.pop())
                                                                    )
                                                                )
                                                            )

                                                            (ß ___clinitgen.returnValue())

                                                            (ß ___clinitgen.endMethod())

                                                            ;; end of class
                                                            (ß ___cv.visitEnd())

                                                            (§ ass (:bytecode this) (ß ___cw.toByteArray()))
                                                            (when (ß RT'booleanCast-1o(Compiler'COMPILE_FILES.deref()))
                                                                (ß writeClassFile((:internalName this), (:bytecode this)))
                                                            )
                                                            nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" emitKeywordCallsites [#_"ObjExpr" this, #_"GeneratorAdapter" ___clinitgen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:keywordCallsites this).count()) [(inc ___i)]
            (let [#_"Keyword" ___k (ß (Keyword) (:keywordCallsites this).nth(___i))]
                (ß ___clinitgen.newInstance(ObjExpr'KEYWORD_LOOKUPSITE_TYPE))
                (ß ___clinitgen.dup())
                (ß emitValue(___k, ___clinitgen))
                (ß ___clinitgen.invokeConstructor(ObjExpr'KEYWORD_LOOKUPSITE_TYPE, Method/getMethod("void <init>(cloiure.lang.Keyword)")))
                (ß ___clinitgen.dup())
                (ß ___clinitgen.putStatic((:objtype this), siteNameStatic(___i), ObjExpr'KEYWORD_LOOKUPSITE_TYPE))
                (ß ___clinitgen.putStatic((:objtype this), thunkNameStatic(___i), ObjExpr'ILOOKUP_THUNK_TYPE))
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" emitStatics [#_"ObjExpr" this, #_"ClassVisitor" ___gen]
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" emitMethods [#_"ObjExpr" this, #_"ClassVisitor" ___gen]
        nil
    )

    #_method
    (§ defn #_"void" emitListAsObjectArray [#_"ObjExpr" this, #_"Object" ___value, #_"GeneratorAdapter" ___gen]
        (ß ___gen.push(((List) ___value).size()))
        (ß ___gen.newArray(Compiler'OBJECT_TYPE))
        (loop-when-recur [#_"Iterator" ___it (ß ((List) ___value).iterator()) #_"int" ___i 0] (ß ___it.hasNext()) [___it (inc ___i)]
            (ß ___gen.dup())
            (ß ___gen.push(___i))
            (ß emitValue(___it.next(), ___gen))
            (ß ___gen.arrayStore(Compiler'OBJECT_TYPE))
        )
        nil
    )

    #_method
    (§ defn #_"void" emitValue [#_"ObjExpr" this, #_"Object" ___value, #_"GeneratorAdapter" ___gen]
        (let [#_"boolean" ___partial true]
            (cond (nil? ___value)
                (do
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                )
                (ß ___value instanceof String)
                (do
                    (ß ___gen.push((String) ___value))
                )
                (ß ___value instanceof Boolean)
                (do
                    (if (ß ((Boolean) ___value).booleanValue())
                        (do
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "TRUE", Compiler'BOOLEAN_OBJECT_TYPE))
                        )
                        (do
                            (ß ___gen.getStatic(Compiler'BOOLEAN_OBJECT_TYPE, "FALSE", Compiler'BOOLEAN_OBJECT_TYPE))
                        )
                    )
                )
                (ß ___value instanceof Integer)
                (do
                    (ß ___gen.push(((Integer) ___value).intValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Integer)), Method/getMethod("Integer valueOf(int)")))
                )
                (ß ___value instanceof Long)
                (do
                    (ß ___gen.push(((Long) ___value).longValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Long)), Method/getMethod("Long valueOf(long)")))
                )
                (ß ___value instanceof Double)
                (do
                    (ß ___gen.push(((Double) ___value).doubleValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Double)), Method/getMethod("Double valueOf(double)")))
                )
                (ß ___value instanceof Character)
                (do
                    (ß ___gen.push(((Character) ___value).charValue()))
                    (ß ___gen.invokeStatic(Type/getType((§ class Character)), Method/getMethod("Character valueOf(char)")))
                )
                (ß ___value instanceof Class)
                (do
                    (let [#_"Class" ___cc (ß (Class)___value)]
                        (if (ß ___cc.isPrimitive())
                            (do
                                (§ let [#_"Type" ___bt]
                                    (cond (ß ___cc == (§ class boolean))
                                        (do
                                            (§ ass ___bt (Type/getType Boolean))
                                        )
                                        (ß ___cc == (§ class byte))
                                        (do
                                            (§ ass ___bt (Type/getType Byte))
                                        )
                                        (ß ___cc == (§ class char))
                                        (do
                                            (§ ass ___bt (Type/getType Character))
                                        )
                                        (ß ___cc == (§ class double))
                                        (do
                                            (§ ass ___bt (Type/getType Double))
                                        )
                                        (ß ___cc == (§ class float))
                                        (do
                                            (§ ass ___bt (Type/getType Float))
                                        )
                                        (ß ___cc == (§ class int))
                                        (do
                                            (§ ass ___bt (Type/getType Integer))
                                        )
                                        (ß ___cc == (§ class long))
                                        (do
                                            (§ ass ___bt (Type/getType Long))
                                        )
                                        (ß ___cc == (§ class short))
                                        (do
                                            (§ ass ___bt (Type/getType Short))
                                        )
                                        :else
                                        (do
                                            (throw (Util'runtimeException-1 (str "Can't embed unknown primitive in code: " ___value)))
                                        )
                                    )
                                    (ß ___gen.getStatic(___bt, "TYPE", Type/getType((§ class Class))))
                                )
                            )
                            (do
                                (ß ___gen.push(destubClassName(___cc.getName())))
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("Class classForName(String)")))
                            )
                        )
                    )
                )
                (ß ___value instanceof Symbol)
                (do
                    (ß ___gen.push(((Symbol) ___value).ns))
                    (ß ___gen.push(((Symbol) ___value).name))
                    (ß ___gen.invokeStatic(Type/getType((§ class Symbol)), Method/getMethod("cloiure.lang.Symbol intern(String,String)")))
                )
                (ß ___value instanceof Keyword)
                (do
                    (ß ___gen.push(((Keyword) ___value).sym.ns))
                    (ß ___gen.push(((Keyword) ___value).sym.name))
                    (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Keyword keyword(String,String)")))
                )
                (ß ___value instanceof Var)
                (do
                    (let [#_"Var" ___var (ß (Var) ___value)]
                        (ß ___gen.push((:ns ___var).name.toString()))
                        (ß ___gen.push((:sym ___var).toString()))
                        (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.Var var(String,String)")))
                    )
                )
                (ß ___value instanceof IType)
                (do
                    (let [#_"Method" ___ctor (Method. "<init>", (Type/getConstructorDescriptor (ß ___value.getClass().getConstructors()[0])))]
                        (ß ___gen.newInstance(Type/getType(___value.getClass())))
                        (ß ___gen.dup())
                        (let [#_"IPersistentVector" ___fields (ß (IPersistentVector) Reflector'invokeStaticMethod-3c(___value.getClass(), "getBasis", new Object[] (§ array )))]
                            (loop-when-recur [#_"ISeq" ___s (RT'seq ___fields)] (some? ___s) [(ß ___s.next())]
                                (let [#_"Symbol" ___field (ß (Symbol) ___s.first())]
                                    (let [#_"Class" ___k (ß tagClass(tagOf(___field)))]
                                        (let [#_"Object" ___val (ß Reflector'getInstanceField(___value, munge((:name ___field))))]
                                            (ß emitValue(___val, ___gen))

                                            (when (ß ___k.isPrimitive())
                                                (let [#_"Type" ___b (ß Type/getType(boxClass(___k)))]
                                                    (let [#_"String" ___p (ß Type/getType(___k).getDescriptor())]
                                                        (let [#_"String" ___n (ß ___k.getName())]
                                                            (ß ___gen.invokeVirtual(___b, (Method. (str ___n "Value"), (str "()" ___p))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (ß ___gen.invokeConstructor(Type/getType(___value.getClass()), ___ctor))
                        )
                    )
                )
                (ß ___value instanceof IRecord)
                (do
                    (let [#_"Method" ___createMethod (ß Method/getMethod(___value.getClass().getName() + " create(cloiure.lang.IPersistentMap)"))]
                        (ß emitValue(PersistentArrayMap'create((java.util.Map) ___value), ___gen))
                        (ß ___gen.invokeStatic(getType(___value.getClass()), ___createMethod))
                    )
                )
                (ß ___value instanceof IPersistentMap)
                (do
                    (let [#_"List" ___entries (ArrayList.)]
                        (doseq [#_"Map$Entry" ___entry (ß (Set<Map$Entry>) ((Map) ___value).entrySet())]
                            (ß ___entries.add(___entry.getKey()))
                            (ß ___entries.add(___entry.getValue()))
                        )
                        (ß emitListAsObjectArray(___entries, ___gen))
                        (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.IPersistentMap map(Object[])")))
                    )
                )
                (ß ___value instanceof IPersistentVector)
                (do
                    (let [#_"IPersistentVector" ___args (ß (IPersistentVector) ___value)]
                        (if (ß ___args.count() <= Tuple'MAX_SIZE)
                            (do
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___args.count()) [(inc ___i)]
                                    (ß emitValue(___args.nth(___i), ___gen))
                                )
                                (ß ___gen.invokeStatic(Compiler'TUPLE_TYPE, createTupleMethods[___args.count()]))
                            )
                            (do
                                (ß emitListAsObjectArray(___value, ___gen))
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("cloiure.lang.IPersistentVector vector(Object[])")))
                            )
                        )
                    )
                )
                (ß ___value instanceof PersistentHashSet)
                (do
                    (let [#_"ISeq" ___vs (RT'seq ___value)]
                        (if (nil? ___vs)
                            (do
                                (ß ___gen.getStatic(Type/getType((§ class PersistentHashSet)), "EMPTY", Type/getType((§ class PersistentHashSet))))
                            )
                            (do
                                (ß emitListAsObjectArray(___vs, ___gen))
                                (ß ___gen.invokeStatic(Type/getType((§ class PersistentHashSet)), Method/getMethod("cloiure.lang.PersistentHashSet create(Object[])")))
                            )
                        )
                    )
                )
                (ß ___value instanceof ISeq || ___value instanceof IPersistentList)
                (do
                    (ß emitListAsObjectArray(___value, ___gen))
                    (ß ___gen.invokeStatic(Type/getType((§ class java.util.Arrays)), Method/getMethod("java.util.List asList(Object[])")))
                    (ß ___gen.invokeStatic(Type/getType((§ class PersistentList)), Method/getMethod("cloiure.lang.IPersistentList create(java.util.List)")))
                )
                (ß ___value instanceof Pattern)
                (do
                    (ß emitValue(___value.toString(), ___gen))
                    (ß ___gen.invokeStatic(Type/getType((§ class Pattern)), Method/getMethod("java.util.regex.Pattern compile(String)")))
                )
                :else
                (do
                    (let [#_"String" ___cs nil]
                        (try
                            (§ ass ___cs (RT'printString ___value))
                            (catch Exception ___e
                                (throw (Util'runtimeException-1 (str "Can't embed object in code, maybe print-dup not defined: " ___value)))
                            )
                        )
                        (when (ß ___cs.length() == 0)
                            (throw (Util'runtimeException-1 (str "Can't embed unreadable object in code: " ___value)))
                        )

                        (when (ß ___cs.startsWith("#<"))
                            (throw (Util'runtimeException-1 (str "Can't embed unreadable object in code: " ___cs)))
                        )

                        (ß ___gen.push(___cs))
                        (ß ___gen.invokeStatic(Compiler'RT_TYPE, readStringMethod))
                        (§ ass ___partial false)
                    )
                )
            )

            (when ___partial
                (when (ß ___value instanceof IObj && RT'count(((IObj) ___value).meta()) > 0)
                    (ß ___gen.checkCast(Compiler'IOBJ_TYPE))
                    (let [#_"Object" ___m (ß ((IObj) ___value).meta())]
                        (ß emitValue(elideMeta(___m), ___gen))
                        (ß ___gen.checkCast(Compiler'IPERSISTENTMAP_TYPE))
                        (ß ___gen.invokeInterface(Compiler'IOBJ_TYPE, Method/getMethod("cloiure.lang.IObj withMeta(cloiure.lang.IPersistentMap)")))
                    )
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" emitConstants [#_"ObjExpr" this, #_"GeneratorAdapter" ___clinitgen]
        (try
            (ß Var'pushThreadBindings(RT'map(
                (§ map
                    RT'PRINT_DUP RT'T
                )
            )))

            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants this).count()) [(inc ___i)]
                (when (ß (:usedConstants this).contains(___i))
                    (ß emitValue((:constants this).nth(___i), ___clinitgen))
                    (ß ___clinitgen.checkCast(constantType(___i)))
                    (ß ___clinitgen.putStatic((:objtype this), constantName(___i), constantType(___i)))
                )
            )
            (finally
                (ß Var'popThreadBindings())
            )
        )
        nil
    )

    #_method
    (§ defn #_"boolean" isMutable [#_"ObjExpr" this, #_"LocalBinding" ___lb]
        (ß isVolatile(___lb) || RT'booleanCast-1o(RT'contains((:fields this), (:sym ___lb))) && RT'booleanCast-1o(RT'get-2((:sym ___lb).meta(), Keyword'intern-1("unsynchronized-mutable"))))
    )

    #_method
    (§ defn #_"boolean" isVolatile [#_"ObjExpr" this, #_"LocalBinding" ___lb]
        (ß RT'booleanCast-1o(RT'contains((:fields this), (:sym ___lb))) && RT'booleanCast-1o(RT'get-2((:sym ___lb).meta(), Keyword'intern-1("volatile-mutable"))))
    )

    #_method
    (§ defn #_"boolean" isDeftype [#_"ObjExpr" this]
        (ß ((:fields this) != nil))
    )

    #_method
    (§ defn #_"boolean" supportsMeta [#_"ObjExpr" this]
        (ß !isDeftype())
    )

    #_method
    (§ defn #_"void" emitClearCloses [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"Class" getCompiledClass [#_"ObjExpr" this]
        (§ sync this
            (when (nil? (:compiledClass this))
                (§ ass (:loader this) (ß (DynamicClassLoader) Compiler'LOADER.deref()))
                (§ ass (:compiledClass this) (ß (:loader this).defineClass((:name this), (:bytecode this), (:src this))))
            )
            (:compiledClass this)
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"ObjExpr" this]
        (when (ß isDeftype())
            (§ return nil)
        )
        (try
            (ß getCompiledClass().newInstance())
            (catch Exception ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    #_method
    (§ defn #_"void" emitLetFnInits [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"ObjExpr" ___objx, #_"IPersistentSet" ___letFnLocals]
        ;; objx arg is enclosing objx, not this
        (ß ___gen.checkCast((:objtype this)))

        (loop-when-recur [#_"ISeq" ___s (RT'keys (:closes this))] (some? ___s) [(ß ___s.next())]
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                (when (ß ___letFnLocals.contains(___lb))
                    (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                        (ß ___gen.dup())
                        (if (some? ___primc)
                            (do
                                (ß ___objx.emitUnboxedLocal(___gen, ___lb))
                                (ß ___gen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                            )
                            (do
                                (ß ___objx.emitLocal(___gen, ___lb, false))
                                (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            )
                        )
                    )
                )
            )
        )
        (ß ___gen.pop())
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"ObjExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        ;; emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
        ;; objx arg is enclosing objx, not this
        (if (ß isDeftype())
            (do
                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
            )
            (do
                (ß ___gen.newInstance((:objtype this)))
                (ß ___gen.dup())
                (when (ß supportsMeta())
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                )
                (loop-when-recur [#_"ISeq" ___s (RT'seq (:closesExprs this))] (some? ___s) [(ß ___s.next())]
                    (let [#_"LocalBindingExpr" ___lbe (ß (LocalBindingExpr) ___s.first())]
                        (let [#_"LocalBinding" ___lb (:b ___lbe)]
                            (if (ß ___lb.getPrimitiveType() != nil)
                                (do
                                    (ß ___objx.emitUnboxedLocal(___gen, ___lb))
                                )
                                (do
                                    (ß ___objx.emitLocal(___gen, ___lb, (:shouldClear ___lbe)))
                                )
                            )
                        )
                    )
                )
                (ß ___gen.invokeConstructor((:objtype this), (Method. "<init>", Type/VOID_TYPE, (ß ctorTypes()))))
            )
        )
        (when (ß ___context == :Context'STATEMENT)
            (ß ___gen.pop())
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"ObjExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"ObjExpr" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß ((:compiledClass this) != nil) ? (:compiledClass this) :or ((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or (§ class IFn)))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"void" emitAssignLocal [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb, #_"Expr" ___val]
        (when (ß !isMutable(___lb))
            (throw (IllegalArgumentException. (str "Cannot assign to non-mutable: " (:name ___lb))))
        )
        (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
            (ß ___gen.loadThis())
            (if (some? ___primc)
                (do
                    (when (ß !(___val instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr) ___val).canEmitPrimitive()))
                        (throw (IllegalArgumentException. (str "Must assign primitive to primitive mutable: " (:name ___lb))))
                    )
                    (let [#_"MaybePrimitiveExpr" ___me (ß (MaybePrimitiveExpr) ___val)]
                        (ß ___me.emitUnboxed(:Context'EXPRESSION, this, ___gen))
                        (ß ___gen.putField((:objtype this), (:name ___lb), Type/getType(___primc)))
                    )
                )
                (do
                    (ß ___val.emit(:Context'EXPRESSION, this, ___gen))
                    (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                )
            )
            nil
        )
    )

    #_method
    (§ defn- #_"void" emitLocal [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb, #_"boolean" ___clear]
        (if (ß (:closes this).containsKey(___lb))
            (do
                (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                    (ß ___gen.loadThis())
                    (if (some? ___primc)
                        (do
                            (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                            (HostExpr'emitBoxReturn this, ___gen, ___primc)
                        )
                        (do
                            (ß ___gen.getField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            (when (ß (:onceOnly this) && ___clear && (:canBeCleared ___lb))
                                (ß ___gen.loadThis())
                                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                (ß ___gen.putField((:objtype this), (:name ___lb), Compiler'OBJECT_TYPE))
                            )
                        )
                    )
                )
            )
            (do
                (let [#_"int" ___argoff (ß (:canBeDirect this) ? 0 :or 1)]
                    (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                        (if (:isArg ___lb)
                            (do
                                (ß ___gen.loadArg(___lb.idx-argoff))
                                (cond (some? ___primc)
                                    (do
                                        (HostExpr'emitBoxReturn this, ___gen, ___primc)
                                    )
                                    (ß ___clear && (:canBeCleared ___lb))
                                    (do
                                        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                        (ß ___gen.storeArg((:idx ___lb) - ___argoff))
                                    )
                                )
                            )
                            (do
                                (if (some? ___primc)
                                    (do
                                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                                        (HostExpr'emitBoxReturn this, ___gen, ___primc)
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                                        (when (ß ___clear && (:canBeCleared ___lb))
                                            (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                            (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" emitUnboxedLocal [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"LocalBinding" ___lb]
        (let [#_"int" ___argoff (ß (:canBeDirect this) ? 0 :or 1)]
            (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                (cond (ß (:closes this).containsKey(___lb))
                    (do
                        (ß ___gen.loadThis())
                        (ß ___gen.getField((:objtype this), (:name ___lb), Type/getType(___primc)))
                    )
                    (:isArg ___lb)
                    (do
                        (ß ___gen.loadArg(___lb.idx-argoff))
                    )
                    :else
                    (do
                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ILOAD), (:idx ___lb)))
                    )
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"void" emitVar [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Var" ___var]
        (let [#_"Integer" ___i (ß (Integer) (:vars this).valAt(___var))]
            (ß emitConstant(___gen, ___i))
            nil
        )
    )

    (def #_"Method" ObjExpr'varGetMethod (Method/getMethod "Object get()"))
    (def #_"Method" ObjExpr'varGetRawMethod (Method/getMethod "Object getRawRoot()"))

    #_method
    (§ defn #_"void" emitVarValue [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Var" ___v]
        (let [#_"Integer" ___i (ß (Integer) (:vars this).valAt(___v))]
            (if (ß !___v.isDynamic())
                (do
                    (ß emitConstant(___gen, ___i))
                    (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, ObjExpr'varGetRawMethod))
                )
                (do
                    (ß emitConstant(___gen, ___i))
                    (ß ___gen.invokeVirtual(Compiler'VAR_TYPE, varGetMethod))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" emitKeyword [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"Keyword" ___k]
        (let [#_"Integer" ___i (ß (Integer) (:keywords this).valAt(___k))]
            (ß emitConstant(___gen, ___i))
            nil
        )
    )

    #_method
    (§ defn #_"void" emitConstant [#_"ObjExpr" this, #_"GeneratorAdapter" ___gen, #_"int" ___id]
        (§ ass (:usedConstants this) (ß (IPersistentSet) (:usedConstants this).cons(___id)))
        (ß ___gen.getStatic((:objtype this), constantName(___id), constantType(___id)))
        nil
    )

    #_method
    (§ defn #_"String" constantName [#_"ObjExpr" this, #_"int" ___id]
        (ß ObjExpr'CONST_PREFIX + ___id)
    )

    #_method
    (§ defn #_"String" siteName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__site__" + ___n)
    )

    #_method
    (§ defn #_"String" siteNameStatic [#_"ObjExpr" this, #_"int" ___n]
        (ß siteName(___n) + "__")
    )

    #_method
    (§ defn #_"String" thunkName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__thunk__" + ___n)
    )

    #_method
    (§ defn #_"String" cachedClassName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__cached_class__" + ___n)
    )

    #_method
    (§ defn #_"String" cachedVarName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__cached_var__" + ___n)
    )

    #_method
    (§ defn #_"String" varCallsiteName [#_"ObjExpr" this, #_"int" ___n]
        (ß "__var__callsite__" + ___n)
    )

    #_method
    (§ defn #_"String" thunkNameStatic [#_"ObjExpr" this, #_"int" ___n]
        (ß thunkName(___n) + "__")
    )

    #_method
    (§ defn #_"Type" constantType [#_"ObjExpr" this, #_"int" ___id]
        (let [#_"Object" ___o (ß (:constants this).nth(___id))]
            (let [#_"Class" ___c (ß cloiure.lang.Util'classOf(___o))]
                (when (ß ___c != nil && Modifier/isPublic(___c.getModifiers()))
                    ;; can't emit derived fn types due to visibility
                    (cond (ß (§ class LazySeq).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class ISeq))))
                        )
                        (ß ___c == (§ class Keyword))
                        (do
                            (§ return (ß Type/getType((§ class Keyword))))
                        )
                        (ß (§ class RestFn).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class RestFn))))
                        )
                        (ß (§ class AFn).isAssignableFrom(___c))
                        (do
                            (§ return (ß Type/getType((§ class AFn))))
                        )
                        (ß ___c == (§ class Var))
                        (do
                            (§ return (ß Type/getType((§ class Var))))
                        )
                        (ß ___c == (§ class String))
                        (do
                            (§ return (Type/getType String))
                        )
                    )
                )
                Compiler'OBJECT_TYPE
            )
        )
    )
)

(def PathType'enum-set
    (hash-set
        :PathType'PATH
        :PathType'BRANCH
    )
)

(class-ns PathNode
    (defn- #_"PathNode" PathNode'init []
        (hash-map
            #_"PathType" :type nil
            #_"PathNode" :parent nil
        )
    )

    (defn #_"PathNode" PathNode'new [#_"PathType" ___type, #_"PathNode" ___parent]
        (let [this (PathNode'init)]
            (§ ass (:type this) ___type)
            (§ ass (:parent this) ___parent)
            this
        )
    )
)

(def PState'enum-set
    (hash-set
        :PState'REQ
        :PState'REST
        :PState'DONE
    )
)

(class-ns FnMethod (§ extends ObjMethod)
    (defn- #_"FnMethod" FnMethod'init []
        (hash-map
            ;; localbinding->localbinding
            #_"PersistentVector" :reqParms PersistentVector'EMPTY
            #_"LocalBinding" :restParm nil
            #_"Type[]" :argtypes nil
            #_"Class[]" :argclasses nil
            #_"Class" :retClass nil
            #_"String" :prim nil
        )
    )

    (defn #_"FnMethod" FnMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (merge (ObjMethod'new ___objx, ___parent) (FnMethod'init))
    )

    (defn #_"char" FnMethod'classChar [#_"Object" ___x]
        (let [#_"Class" ___c nil]
            (cond (ß ___x instanceof Class)
                (do
                    (§ ass ___c (ß (Class) ___x))
                )
                (ß ___x instanceof Symbol)
                (do
                    (§ ass ___c (ß primClass((Symbol) ___x)))
                )
            )
            (when (ß ___c == nil || !___c.isPrimitive())
                (§ return \O)
            )
            (when (ß ___c == (§ class long))
                (§ return \L)
            )
            (when (ß ___c == (§ class double))
                (§ return \D)
            )
            (throw (IllegalArgumentException. "Only long and double primitives are supported"))
        )
    )

    (defn #_"String" FnMethod'primInterface [#_"IPersistentVector" ___arglist]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___arglist.count()) [(inc ___i)]
                (ß ___sb.append(classChar(tagOf(___arglist.nth(___i)))))
            )
            (ß ___sb.append(classChar(tagOf(___arglist))))
            (let [#_"String" ___ret (ß ___sb.toString())]
                (let [#_"boolean" ___prim (ß ___ret.contains("L") || ___ret.contains("D"))]
                    (when (ß ___prim && ___arglist.count() > 4)
                        (throw (IllegalArgumentException. "fns taking primitives support only 4 or fewer args"))
                    )
                    (when ___prim
                        (§ return (ß "cloiure.lang.IFn$" + ___ret))
                    )
                    nil
                )
            )
        )
    )

    (defn #_"FnMethod" FnMethod'parse [#_"ObjExpr" ___objx, #_"ISeq" ___form, #_"Object" ___rettag]
        ;; ([args] body...)
        (let [#_"IPersistentVector" ___parms (ß (IPersistentVector) RT'first(___form))]
            (let [#_"ISeq" ___body (RT'next ___form)]
                (try
                    (let [#_"FnMethod" ___method (ß FnMethod'new(___objx, (ObjMethod) Compiler'METHOD.deref()))]
                        (§ ass (:line ___method) (ß lineDeref()))
                        (§ ass (:column ___method) (ß columnDeref()))
                        ;; register as the current method and set up a new env frame
                        (let [#_"PathNode" ___pnode (ß (PathNode) Compiler'CLEAR_PATH.get())]
                            (when (nil? ___pnode)
                                (§ ass ___pnode (ß PathNode'new(:PathType'PATH, nil)))
                            )
                            (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                (§ map
                                    Compiler'METHOD                ___method
                                    Compiler'LOCAL_ENV             (ß Compiler'LOCAL_ENV.deref())
                                    Compiler'LOOP_LOCALS           nil
                                    Compiler'NEXT_LOCAL_NUM        0
                                    Compiler'CLEAR_PATH            ___pnode
                                    Compiler'CLEAR_ROOT            ___pnode
                                    Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                    Compiler'METHOD_RETURN_CONTEXT RT'T
                                )
                            )))

                            (§ ass (:prim ___method) (ß primInterface(___parms)))
                            (when (ß (:prim ___method) != nil)
                                (§ ass (:prim ___method) (ß (:prim ___method).replace(\., \/)))
                            )

                            (when (ß ___rettag instanceof String)
                                (§ ass ___rettag (ß Symbol'intern-2(nil, (String) ___rettag)))
                            )
                            (when (ß !(___rettag instanceof Symbol))
                                (§ ass ___rettag nil)
                            )
                            (when (some? ___rettag)
                                (let [#_"String" ___retstr (ß ((Symbol)___rettag).getName())]
                                    (when (ß !(___retstr.equals("long") || ___retstr.equals("double")))
                                        (§ ass ___rettag nil)
                                    )
                                )
                            )
                            (§ ass (:retClass ___method) (ß tagClass((tagOf(___parms) != nil) ? tagOf(___parms) :or ___rettag)))
                            (if (ß (:retClass ___method).isPrimitive())
                                (do
                                    (when (ß !((:retClass ___method) == (§ class double) || (:retClass ___method) == (§ class long)))
                                        (throw (IllegalArgumentException. "Only long and double primitives are supported"))
                                    )
                                )
                                (do
                                    (§ ass (:retClass ___method) (§ class Object))
                                )
                            )
                            ;; register 'this' as local 0
                            (if (ß (:thisName ___objx) != nil)
                                (do
                                    (ß registerLocal(Symbol'intern-1((:thisName ___objx)), nil, nil, false))
                                )
                                (do
                                    (ß getAndIncLocalNum())
                                )
                            )
                            (let [#_"PState" ___state (ß :PState'REQ)]
                                (let [#_"PersistentVector" ___argLocals PersistentVector'EMPTY]
                                    (let [#_"ArrayList<Type>" ___argtypes (ArrayList.)]
                                        (let [#_"ArrayList<Class>" ___argclasses (ArrayList.)]
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___parms.count()) [(inc ___i)]
                                                (when (ß !(___parms.nth(___i) instanceof Symbol))
                                                    (throw (IllegalArgumentException. "fn params must be Symbols"))
                                                )
                                                (let [#_"Symbol" ___p (ß (Symbol) ___parms.nth(___i))]
                                                    (when (ß ___p.getNamespace() != nil)
                                                        (throw (Util'runtimeException-1 (str "Can't use qualified name as parameter: " ___p)))
                                                    )
                                                    (if (ß ___p.equals(Compiler'_AMP_))
                                                        (do
                                                            (if (ß ___state == :PState'REQ)
                                                                (do
                                                                    (§ ass ___state (ß :PState'REST))
                                                                )
                                                                (do
                                                                    (throw (Util'runtimeException-1 "Invalid parameter list"))
                                                                )
                                                            )
                                                        )
                                                        (do
                                                            (let [#_"Class" ___pc (ß primClass(tagClass(tagOf(___p))))]
                                                                (when (ß ___pc.isPrimitive() && !(___pc == (§ class double) || ___pc == (§ class long)))
                                                                    (throw (IllegalArgumentException. (str "Only long and double primitives are supported: " ___p)))
                                                                )

                                                                (when (ß ___state == :PState'REST && tagOf(___p) != nil)
                                                                    (throw (Util'runtimeException-1 "& arg cannot have type hint"))
                                                                )
                                                                (when (ß ___state == :PState'REST && (:prim ___method) != nil)
                                                                    (throw (Util'runtimeException-1 "fns taking primitives cannot be variadic"))
                                                                )

                                                                (when (ß ___state == :PState'REST)
                                                                    (§ ass ___pc (§ class ISeq))
                                                                )
                                                                (ß ___argtypes.add(Type/getType(___pc)))
                                                                (ß ___argclasses.add(___pc))
                                                                (let [#_"LocalBinding" ___lb (ß ___pc.isPrimitive() ? registerLocal(___p, nil, MethodParamExpr'new(___pc), true) :or registerLocal(___p, (___state == :PState'REST) ? Compiler'ISEQ :or tagOf(___p), nil, true))]
                                                                    (§ ass ___argLocals (ß ___argLocals.cons(___lb)))
                                                                    (§ switch ___state
                                                                        (§ case :PState'REQ)
                                                                        (do
                                                                            (§ ass (:reqParms ___method) (ß (:reqParms ___method).cons(___lb)))
                                                                            (§ break )
                                                                        )
                                                                        (§ case :PState'REST)
                                                                        (do
                                                                            (§ ass (:restParm ___method) ___lb)
                                                                            (§ ass ___state (ß :PState'DONE))
                                                                            (§ break )
                                                                        )
                                                                        (§ default )
                                                                        (do
                                                                            (throw (Util'runtimeException-1 "Unexpected parameter"))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (when (ß (:reqParms ___method).count() > Compiler'MAX_POSITIONAL_ARITY)
                                                (throw (Util'runtimeException-1 (str "Can't specify more than " Compiler'MAX_POSITIONAL_ARITY " params")))
                                            )
                                            (ß Compiler'LOOP_LOCALS.set(___argLocals))
                                            (§ ass (:argLocals ___method) ___argLocals)
                                            (§ ass (:argtypes ___method) (ß ___argtypes.toArray(new Type[___argtypes.size()])))
                                            (§ ass (:argclasses ___method) (ß ___argclasses.toArray(new Class[___argtypes.size()])))
                                            (when (ß (:prim ___method) != nil)
                                                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argclasses ___method).length) [(inc ___i)]
                                                    (when (ß (:argclasses ___method)[___i] == (§ class long) || (:argclasses ___method)[___i] == (§ class double))
                                                        (ß getAndIncLocalNum())
                                                    )
                                                )
                                            )
                                            (§ ass (:body ___method) (ß (BodyParser'new()).parse(:Context'RETURN, ___body)))
                                            ___method
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (finally
                        (ß Var'popThreadBindings())
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emit [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (cond (:canBeDirect ___fn)
            (do
                (ß doEmitStatic(___fn, ___cv))
            )
            (some? (:prim this))
            (do
                (ß doEmitPrim(___fn, ___cv))
            )
            :else
            (do
                (ß doEmit(___fn, ___cv))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" doEmitStatic [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Type" ___returnType (Type/getType (:retClass this))]
            (let [#_"Method" ___ms (Method. "invokeStatic", ___returnType, (:argtypes this))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ___ms, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                    (ß ___gen.visitCode())
                    (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                        (ß ___gen.visitLineNumber((:line this), ___loopLabel))
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (§ map
                                    Compiler'LOOP_LABEL ___loopLabel
                                    Compiler'METHOD     this
                                )
                            )))
                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))

                            (let [#_"Label" ___end (ß ___gen.mark())]
                                (loop-when-recur [#_"ISeq" ___lbs (ß (:argLocals this).seq())] (some? ___lbs) [(ß ___lbs.next())]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argtypes this)[(:idx ___lb)].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )

                        (ß ___gen.returnValue())
                        (ß ___gen.endMethod())

                        ;; generate the regular invoke, calling the static method
                        (let [#_"Method" ___m (Method. (ß getMethodName()), Compiler'OBJECT_TYPE, (ß getArgTypes()))]
                            ;; todo don't hardwire EXCEPTION_TYPES
                            (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv))
                            (ß ___gen.visitCode())
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argtypes this).length) [(inc ___i)]
                                (ß ___gen.loadArg(___i))
                                (ß HostExpr'emitUnboxArg(___fn, ___gen, (:argclasses this)[___i]))
                                (when (ß !this.argclasses[___i].isPrimitive())
                                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                    (ß ___gen.storeArg(___i))
                                )
                            )
                            (let [#_"Label" ___callLabel (ß ___gen.mark())]
                                (ß ___gen.visitLineNumber((:line this), ___callLabel))
                                (ß ___gen.invokeStatic((:objx this).objtype, ___ms))
                                (ß ___gen.box(___returnType))

                                (ß ___gen.returnValue())
                                (ß ___gen.endMethod())

                                ;; generate primInvoke if prim
                                (when (some? (:prim this))
                                    (when (ß (:retClass this) == (§ class double) || (:retClass this) == (§ class long))
                                        (§ ass ___returnType (ß getReturnType()))
                                    )
                                    (let [#_"else" ___returnType Compiler'OBJECT_TYPE]
                                        (let [#_"Method" ___pm (Method. "invokePrim", ___returnType, (:argtypes this))]
                                            ;; todo don't hardwire EXCEPTION_TYPES
                                            (§ ass ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ___pm, nil, Compiler'EXCEPTION_TYPES, ___cv))
                                            (ß ___gen.visitCode())
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argtypes this).length) [(inc ___i)]
                                                (ß ___gen.loadArg(___i))
                                                (when (ß !this.argclasses[___i].isPrimitive())
                                                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                                                    (ß ___gen.storeArg(___i))
                                                )
                                            )
                                            (ß ___gen.invokeStatic((:objx this).objtype, ___ms))

                                            (ß ___gen.returnValue())
                                            (ß ___gen.endMethod())
                                        )
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" doEmitPrim [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (§ let [#_"Type" ___returnType]
            (if (ß (:retClass this) == (§ class double) || (:retClass this) == (§ class long))
                (do
                    (§ ass ___returnType (ß getReturnType()))
                )
                (do
                    (§ ass ___returnType Compiler'OBJECT_TYPE)
                )
            )
            (let [#_"Method" ___ms (Method. "invokePrim", ___returnType, (:argtypes this))]
                ;; todo don't hardwire EXCEPTION_TYPES
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_FINAL), ___ms, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                    (ß ___gen.visitCode())

                    (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                        (ß ___gen.visitLineNumber((:line this), ___loopLabel))
                        (try
                            (ß Var'pushThreadBindings(RT'map(
                                (§ map
                                    Compiler'LOOP_LABEL ___loopLabel
                                    Compiler'METHOD     this
                                )
                            )))
                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))

                            (let [#_"Label" ___end (ß ___gen.mark())]
                                (ß ___gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0))
                                (loop-when-recur [#_"ISeq" ___lbs (ß (:argLocals this).seq())] (some? ___lbs) [(ß ___lbs.next())]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argtypes this)[___lb.idx-1].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )

                        (ß ___gen.returnValue())
                        (ß ___gen.endMethod())

                        ;; generate the regular invoke, calling the prim method
                        (let [#_"Method" ___m (Method. (ß getMethodName()), Compiler'OBJECT_TYPE, (ß getArgTypes()))]
                            ;; todo don't hardwire EXCEPTION_TYPES
                            (§ ass ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv))
                            (ß ___gen.visitCode())
                            (ß ___gen.loadThis())
                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argtypes this).length) [(inc ___i)]
                                (ß ___gen.loadArg(___i))
                                (ß HostExpr'emitUnboxArg(___fn, ___gen, (:argclasses this)[___i]))
                            )
                            (ß ___gen.invokeInterface(Type/getType("L" + (:prim this) + ";"), ___ms))
                            (ß ___gen.box(getReturnType()))

                            (ß ___gen.returnValue())
                            (ß ___gen.endMethod())
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" doEmit [#_"FnMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (ß getMethodName()), (ß getReturnType()), (ß getArgTypes()))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                (ß ___gen.visitCode())

                (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                    (ß ___gen.visitLineNumber((:line this), ___loopLabel))
                    (try
                        (ß Var'pushThreadBindings(RT'map(
                            (§ map
                                Compiler'LOOP_LABEL ___loopLabel
                                Compiler'METHOD     this
                            )
                        )))

                        (ß (:body this).emit(:Context'RETURN, ___fn, ___gen))
                        (let [#_"Label" ___end (ß ___gen.mark())]
                            (ß ___gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0))
                            (loop-when-recur [#_"ISeq" ___lbs (ß (:argLocals this).seq())] (some? ___lbs) [(ß ___lbs.next())]
                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                    (ß ___gen.visitLocalVariable((:name ___lb), "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:idx ___lb)))
                                )
                            )
                        )
                        (finally
                            (ß Var'popThreadBindings())
                        )
                    )

                    (ß ___gen.returnValue())
                    (ß ___gen.endMethod())
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"PersistentVector" reqParms [#_"FnMethod" this]
        (:reqParms this)
    )

    #_method
    (§ defn #_"LocalBinding" restParm [#_"FnMethod" this]
        (:restParm this)
    )

    #_method
    (§ defn #_"boolean" isVariadic [#_"FnMethod" this]
        (ß ((:restParm this) != nil))
    )

    #_method
    (§ defn #_"int" numParams [#_"FnMethod" this]
        (ß (:reqParms this).count() + (isVariadic() ? 1 :or 0))
    )

    #_method
    (§ defn #_"String" getMethodName [#_"FnMethod" this]
        (ß isVariadic() ? "doInvoke" :or "invoke")
    )

    #_method
    (§ defn #_"Type" getReturnType [#_"FnMethod" this]
        (when (some? (:prim this)) ;; objx.isStatic
            (§ return (Type/getType (:retClass this)))
        )
        Compiler'OBJECT_TYPE
    )

    #_method
    (§ defn #_"Type[]" getArgTypes [#_"FnMethod" this]
        (when (ß isVariadic() && (:reqParms this).count() == Compiler'MAX_POSITIONAL_ARITY)
            (let [#_"Type[]" ___ret (make-array Type (ß Compiler'MAX_POSITIONAL_ARITY + 1))]
                (loop-when-recur [#_"int" ___i 0] (ß ___i < Compiler'MAX_POSITIONAL_ARITY + 1) [(inc ___i)]
                    (§ ass (ß ___ret[___i]) Compiler'OBJECT_TYPE)
                )
                (§ return ___ret)
            )
        )
        (ß Compiler'ARG_TYPES[numParams()])
    )

    #_method
    (§ defn #_"void" emitClearLocals [#_"FnMethod" this, #_"GeneratorAdapter" ___gen]
        nil
    )
)

#_abstract
(class-ns ObjMethod
    (defn- #_"ObjMethod" ObjMethod'init []
        (hash-map
            ;; when closures are defined inside other closures,
            ;; the closed over locals need to be propagated to the enclosing objx
            #_"ObjMethod" :parent nil
            ;; localbinding->localbinding
            #_"IPersistentMap" :locals nil
            ;; num->localbinding
            #_"IPersistentMap" :indexlocals nil
            #_"Expr" :body nil
            #_"ObjExpr" :objx nil
            #_"PersistentVector" :argLocals nil
            #_"int" :maxLocal 0
            #_"int" :line 0
            #_"int" :column 0
            #_"boolean" :usesThis false
            #_"PersistentHashSet" :localsUsedInCatchFinally PersistentHashSet'EMPTY
            #_protected
            #_"IPersistentMap" :methodMeta nil
        )
    )

    (defn #_"ObjMethod" ObjMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (let [this (ObjMethod'init)]
            (§ ass (:parent this) ___parent)
            (§ ass (:objx this) ___objx)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" locals [#_"ObjMethod" this]
        (:locals this)
    )

    #_method
    (§ defn #_"Expr" body [#_"ObjMethod" this]
        (:body this)
    )

    #_method
    (§ defn #_"ObjExpr" objx [#_"ObjMethod" this]
        (:objx this)
    )

    #_method
    (§ defn #_"PersistentVector" argLocals [#_"ObjMethod" this]
        (:argLocals this)
    )

    #_method
    (§ defn #_"int" maxLocal [#_"ObjMethod" this]
        (:maxLocal this)
    )

    #_method
    (§ defn #_"int" line [#_"ObjMethod" this]
        (:line this)
    )

    #_method
    (§ defn #_"int" column [#_"ObjMethod" this]
        (:column this)
    )

    (defn #_"void" ObjMethod'emitBody [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Class" ___retClass, #_"Expr" ___body]
        (let [#_"MaybePrimitiveExpr" ___be (ß (MaybePrimitiveExpr) ___body)]
            (if (ß Util'isPrimitive(___retClass) && ___be.canEmitPrimitive())
                (do
                    (let [#_"Class" ___bc (ß maybePrimitiveType(___be))]
                        (cond (ß ___bc == ___retClass)
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                            )
                            (ß ___retClass == (§ class long) && ___bc == (§ class int))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.visitInsn(I2L))
                            )
                            (ß ___retClass == (§ class double) && ___bc == (§ class float))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.visitInsn(F2D))
                            )
                            (ß ___retClass == (§ class int) && ___bc == (§ class long))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                            )
                            (ß ___retClass == (§ class float) && ___bc == (§ class double))
                            (do
                                (ß ___be.emitUnboxed(:Context'RETURN, ___objx, ___gen))
                                (ß ___gen.visitInsn(D2F))
                            )
                            :else
                            (do
                                (throw (IllegalArgumentException. (str "Mismatched primitive return, expected: " ___retClass ", had: " (ß ___be.getJavaClass()))))
                            )
                        )
                    )
                )
                (do
                    (ß ___body.emit(:Context'RETURN, ___objx, ___gen))
                    (if (ß ___retClass == (§ class void))
                        (do
                            (ß ___gen.pop())
                        )
                        (do
                            (ß ___gen.unbox(Type/getType(___retClass)))
                        )
                    )
                )
            )
            nil
        )
    )

    #_abstract
    (§ defn #_"int" numParams [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"String" getMethodName [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type" getReturnType [#_"ObjMethod" this])
    #_abstract
    (§ defn #_"Type[]" getArgTypes [#_"ObjMethod" this])

    #_method
    (§ defn #_"void" emit [#_"ObjMethod" this, #_"ObjExpr" ___fn, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (ß getMethodName()), (ß getReturnType()), (ß getArgTypes()))]
            ;; todo don't hardwire EXCEPTION_TYPES
            (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                (ß ___gen.visitCode())

                (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                    (ß ___gen.visitLineNumber((:line this), ___loopLabel))
                    (try
                        (ß Var'pushThreadBindings(RT'map(
                            (§ map
                                Compiler'LOOP_LABEL ___loopLabel
                                Compiler'METHOD     this
                            )
                        )))

                        (ß (:body this).emit(:Context'RETURN, ___fn, ___gen))
                        (let [#_"Label" ___end (ß ___gen.mark())]
                            (ß ___gen.visitLocalVariable("this", "Ljava/lang/Object;", nil, ___loopLabel, ___end, 0))
                            (loop-when-recur [#_"ISeq" ___lbs (ß (:argLocals this).seq())] (some? ___lbs) [(ß ___lbs.next())]
                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                    (ß ___gen.visitLocalVariable((:name ___lb), "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:idx ___lb)))
                                )
                            )
                        )
                        (finally
                            (ß Var'popThreadBindings())
                        )
                    )

                    (ß ___gen.returnValue())
                    (ß ___gen.endMethod())
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"void" emitClearLocals [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        nil
    )

    #_method
    (§ defn #_"void" emitClearLocalsOld [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:argLocals this).count()) [(inc ___i)]
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) (:argLocals this).nth(___i))]
                (when (ß !this.localsUsedInCatchFinally.contains((:idx ___lb)) && ___lb.getPrimitiveType() == nil)
                    (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                    (ß ___gen.storeArg((:idx ___lb) - 1))
                )
            )
        )
        (loop-when-recur [#_"int" ___i (ß numParams() + 1)] (ß ___i < (:maxLocal this) + 1) [(inc ___i)]
            (when (ß !this.localsUsedInCatchFinally.contains(___i))
                (let [#_"LocalBinding" ___b (ß (LocalBinding) RT'get-2((:indexlocals this), ___i))]
                    (when (ß ___b == nil || maybePrimitiveType((:init ___b)) == nil)
                        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), ___i))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" emitClearThis [#_"ObjMethod" this, #_"GeneratorAdapter" ___gen]
        (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
        (ß ___gen.visitVarInsn(Opcodes/ASTORE, 0))
        nil
    )
)

(class-ns LocalBinding
    (defn- #_"LocalBinding" LocalBinding'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"Symbol" :tag nil
            #_"Expr" :init nil
            #_"int" :idx 0
            #_"String" :name nil
            #_"boolean" :isArg false
            #_"PathNode" :clearPathRoot nil
            #_"boolean" :canBeCleared (not (RT'booleanCast-1o (Compiler'getCompilerOption Compiler'disableLocalsClearingKey)))
            #_"boolean" :recurMistmatch false
            #_"boolean" :used false

            #_"Boolean" :hjc nil

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBinding" LocalBinding'new [#_"int" ___num, #_"Symbol" ___sym, #_"Symbol" ___tag, #_"Expr" ___init, #_"boolean" ___isArg, #_"PathNode" ___clearPathRoot]
        (let [this (LocalBinding'init)]
            (when (ß maybePrimitiveType(___init) != nil && ___tag != nil)
                (throw (UnsupportedOperationException. "Can't type hint a local with a primitive initializer"))
            )
            (§ ass (:idx this) ___num)
            (§ ass (:sym this) ___sym)
            (§ ass (:tag this) ___tag)
            (§ ass (:init this) ___init)
            (§ ass (:isArg this) ___isArg)
            (§ ass (:clearPathRoot this) ___clearPathRoot)
            (§ ass (:name this) (ß munge((:name ___sym))))
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"LocalBinding" this]
        (when (nil? (:hjc this))
            (if (ß ((:init this) != nil) && (:init this).hasJavaClass() && Util'isPrimitive((:init this).getJavaClass()) && !((:init this) instanceof MaybePrimitiveExpr))
                (do
                    (§ ass (:hjc this) false)
                )
                (do
                    (§ ass (:hjc this) (ß ((:tag this) != nil || ((:init this) != nil && (:init this).hasJavaClass()))))
                )
            )
        )
        (:hjc this)
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"LocalBinding" this]
        (when (nil? (:jc this))
            (§ ass (:jc this) (ß ((:tag this) != nil) ? HostExpr'tagToClass((:tag this)) :or (:init this).getJavaClass()))
        )
        (:jc this)
    )

    #_method
    (§ defn #_"Class" getPrimitiveType [#_"LocalBinding" this]
        (ß maybePrimitiveType((:init this)))
    )
)

(class-ns LocalBindingExpr (§ implements Expr, MaybePrimitiveExpr, AssignableExpr)
    (defn- #_"LocalBindingExpr" LocalBindingExpr'init []
        (hash-map
            #_"LocalBinding" :b nil
            #_"Symbol" :tag nil

            #_"PathNode" :clearPath nil
            #_"PathNode" :clearRoot nil
            #_"boolean" :shouldClear false

            #_"Class" :jc nil
        )
    )

    (defn #_"LocalBindingExpr" LocalBindingExpr'new [#_"LocalBinding" ___b, #_"Symbol" ___tag]
        (let [this (LocalBindingExpr'init)]
            (when (ß ___b.getPrimitiveType() != nil && ___tag != nil)
                (throw (UnsupportedOperationException. "Can't type hint a primitive local"))
            )
            (§ ass (:b this) ___b)
            (§ ass (:tag this) ___tag)

            (§ ass (:clearPath this) (ß (PathNode)Compiler'CLEAR_PATH.get()))
            (§ ass (:clearRoot this) (ß (PathNode)Compiler'CLEAR_ROOT.get()))
            (let [#_"IPersistentCollection" ___sites (ß (IPersistentCollection) RT'get-2(Compiler'CLEAR_SITES.get(), ___b))]
                (§ ass (:used ___b) true)

                (when (ß (:idx ___b) > 0)
                    (when (some? ___sites)
                        (loop-when-recur [#_"ISeq" ___s (ß ___sites.seq())] (some? ___s) [(ß ___s.next())]
                            (let [#_"LocalBindingExpr" ___o (ß (LocalBindingExpr) ___s.first())]
                                (let [#_"PathNode" ___common (ß commonPath((:clearPath this), (:clearPath ___o)))]
                                    (when (ß ___common != nil && (:type ___common) == :PathType'PATH)
                                        (§ ass (:shouldClear ___o) false)
                                    )
                                )
                            )
                        )
                    )

                    (when (ß (:clearRoot this) == (:clearPathRoot ___b))
                        (§ ass (:shouldClear this) true)
                        (§ ass ___sites (RT'conj ___sites, this))
                        (ß Compiler'CLEAR_SITES.set(RT'assoc(Compiler'CLEAR_SITES.get(), ___b, ___sites)))
                    )
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"LocalBindingExpr" this]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"LocalBindingExpr" this]
        (ß ((:b this).getPrimitiveType() != nil))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß ___objx.emitUnboxedLocal(___gen, (:b this)))
        nil
    )

    #_method
    (§ defn #_"void" emit [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (when (ß ___context != :Context'STATEMENT)
            (ß ___objx.emitLocal(___gen, (:b this), (:shouldClear this)))
        )
        nil
    )

    #_method
    (§ defn #_"Object" evalAssign [#_"LocalBindingExpr" this, #_"Expr" ___val]
        (throw (UnsupportedOperationException. "Can't eval locals"))
    )

    #_method
    (§ defn #_"void" emitAssign [#_"LocalBindingExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___val]
        (ß ___objx.emitAssignLocal(___gen, (:b this), ___val))
        (when (ß ___context != :Context'STATEMENT)
            (ß ___objx.emitLocal(___gen, (:b this), false))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"LocalBindingExpr" this]
        (ß ((:tag this) != nil || (:b this).hasJavaClass()))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"LocalBindingExpr" this]
        (when (nil? (:jc this))
            (if (some? (:tag this))
                (do
                    (§ ass (:jc this) (HostExpr'tagToClass (:tag this)))
                )
                (do
                    (§ ass (:jc this) (ß (:b this).getJavaClass()))
                )
            )
        )
        (:jc this)
    )
)

#_closure
(class-ns BodyParser (§ implements IParser)
    (defn #_"BodyParser" BodyParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"BodyParser" this, #_"Context" ___context, #_"Object" ___frms]
        (let [#_"ISeq" ___forms (ß (ISeq) ___frms)]
            (when (ß Util'equals(RT'first(___forms), Compiler'DO))
                (§ ass ___forms (RT'next ___forms))
            )
            (let [#_"PersistentVector" ___exprs PersistentVector'EMPTY]
                (loop-when-recur [___forms ___forms] (some? ___forms) [(ß ___forms.next())]
                    (let [#_"Expr" ___e (ß (___context != :Context'EVAL && (___context == :Context'STATEMENT || ___forms.next() != nil)) ? analyze(:Context'STATEMENT, ___forms.first()) :or analyze(___context, ___forms.first()))]
                        (§ ass ___exprs (ß ___exprs.cons(___e)))
                    )
                )
                (when (ß ___exprs.count() == 0)
                    (§ ass ___exprs (ß ___exprs.cons(Compiler'NIL_EXPR)))
                )
                (BodyExpr'new ___exprs)
            )
        )
    )
)

(class-ns BodyExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"BodyExpr" BodyExpr'init []
        (hash-map
            #_"PersistentVector" :exprs nil
        )
    )

    (defn #_"BodyExpr" BodyExpr'new [#_"PersistentVector" ___exprs]
        (let [this (BodyExpr'init)]
            (§ ass (:exprs this) ___exprs)
            this
        )
    )

    #_method
    (§ defn #_"PersistentVector" exprs [#_"BodyExpr" this]
        (:exprs this)
    )

    #_method
    (§ defn #_"Object" eval [#_"BodyExpr" this]
        (let [#_"Object" ___ret nil]
            (doseq [#_"Object" ___o (:exprs this)]
                (let [#_"Expr" ___e (ß (Expr) ___o)]
                    (§ ass ___ret (ß ___e.eval()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"BodyExpr" this]
        (ß (lastExpr() instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)lastExpr()).canEmitPrimitive()))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"BodyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:exprs this).count() - 1) [(inc ___i)]
            (let [#_"Expr" ___e (ß (Expr) (:exprs this).nth(___i))]
                (ß ___e.emit(:Context'STATEMENT, ___objx, ___gen))
            )
        )
        (let [#_"MaybePrimitiveExpr" ___last (ß (MaybePrimitiveExpr) (:exprs this).nth((:exprs this).count() - 1))]
            (ß ___last.emitUnboxed(___context, ___objx, ___gen))
            nil
        )
    )

    #_method
    (§ defn #_"void" emit [#_"BodyExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:exprs this).count() - 1) [(inc ___i)]
            (let [#_"Expr" ___e (ß (Expr) (:exprs this).nth(___i))]
                (ß ___e.emit(:Context'STATEMENT, ___objx, ___gen))
            )
        )
        (let [#_"Expr" ___last (ß (Expr) (:exprs this).nth((:exprs this).count() - 1))]
            (ß ___last.emit(___context, ___objx, ___gen))
            nil
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"BodyExpr" this]
        (ß lastExpr().hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"BodyExpr" this]
        (ß lastExpr().getJavaClass())
    )

    #_method
    (§ defn- #_"Expr" lastExpr [#_"BodyExpr" this]
        (ß (Expr) (:exprs this).nth((:exprs this).count() - 1))
    )
)

(class-ns BindingInit
    (defn- #_"BindingInit" BindingInit'init []
        (hash-map
            #_"LocalBinding" :binding nil
            #_"Expr" :init nil
        )
    )

    (defn #_"BindingInit" BindingInit'new [#_"LocalBinding" ___binding, #_"Expr" ___init]
        (let [this (BindingInit'init)]
            (§ ass (:binding this) ___binding)
            (§ ass (:init this) ___init)
            this
        )
    )

    #_method
    (§ defn #_"LocalBinding" binding [#_"BindingInit" this]
        (:binding this)
    )

    #_method
    (§ defn #_"Expr" init [#_"BindingInit" this]
        (:init this)
    )
)

#_closure
(class-ns LetFnParser (§ implements IParser)
    (defn #_"LetFnParser" LetFnParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"LetFnParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (letfns* [var (fn [args] body) ...] body...)
            (when (ß !(RT'second(___form) instanceof IPersistentVector))
                (throw (IllegalArgumentException. "Bad binding form, expected vector"))
            )

            (let [#_"IPersistentVector" ___bindings (ß (IPersistentVector) RT'second(___form))]
                (when (ß (___bindings.count() % 2) != 0)
                    (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                )

                (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                    (when (ß ___context == :Context'EVAL)
                        (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
                    )

                    (let [#_"IPersistentMap" ___dynamicBindings
                            (ß RT'map(
                                (§ map
                                    Compiler'LOCAL_ENV      Compiler'LOCAL_ENV.deref()
                                    Compiler'NEXT_LOCAL_NUM Compiler'NEXT_LOCAL_NUM.deref()
                                )
                            ))]
                        (try
                            (Var'pushThreadBindings ___dynamicBindings)

                            ;; pre-seed env (like Lisp labels)
                            (let [#_"PersistentVector" ___lbs PersistentVector'EMPTY]
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___bindings.count()) [(+ ___i 2)]
                                    (when (ß !(___bindings.nth(___i) instanceof Symbol))
                                        (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (ß ___bindings.nth(___i)))))
                                    )
                                    (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                        (when (ß ___sym.getNamespace() != nil)
                                            (throw (Util'runtimeException-1 (str "Can't let qualified name: " ___sym)))
                                        )
                                        (let [#_"LocalBinding" ___lb (ß registerLocal(___sym, tagOf(___sym), nil, false))]
                                            (§ ass (:canBeCleared ___lb) false)
                                            (§ ass ___lbs (ß ___lbs.cons(___lb)))
                                        )
                                    )
                                )
                                (let [#_"PersistentVector" ___bindingInits PersistentVector'EMPTY]
                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___bindings.count()) [(+ ___i 2)]
                                        (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                            (let [#_"Expr" ___init (ß analyze(:Context'EXPRESSION, ___bindings.nth(___i + 1), (:name ___sym)))]
                                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.nth(___i / 2))]
                                                    (§ ass (:init ___lb) ___init)
                                                    (let [#_"BindingInit" ___bi (BindingInit'new ___lb, ___init)]
                                                        (§ ass ___bindingInits (ß ___bindingInits.cons(___bi)))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (ß LetFnExpr'new(___bindingInits, (BodyParser'new()).parse(___context, ___body)))
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetFnExpr (§ implements Expr)
    (defn- #_"LetFnExpr" LetFnExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
        )
    )

    (defn #_"LetFnExpr" LetFnExpr'new [#_"PersistentVector" ___bindingInits, #_"Expr" ___body]
        (let [this (LetFnExpr'init)]
            (§ ass (:bindingInits this) ___bindingInits)
            (§ ass (:body this) ___body)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"LetFnExpr" this]
        (throw (UnsupportedOperationException. "Can't eval letfns"))
    )

    #_method
    (§ defn #_"void" emit [#_"LetFnExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
            (let [#_"BindingInit" ___bi (ß (BindingInit) (:bindingInits this).nth(___i))]
                (ß ___gen.visitInsn(Opcodes/ACONST_NULL))
                (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:binding ___bi).idx))
            )
        )

        (let [#_"IPersistentSet" ___lbset PersistentHashSet'EMPTY]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (ß (BindingInit) (:bindingInits this).nth(___i))]
                    (§ ass ___lbset (ß (IPersistentSet) ___lbset.cons((:binding ___bi))))
                    (ß (:init ___bi).emit(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:binding ___bi).idx))
                )
            )

            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (ß (BindingInit) (:bindingInits this).nth(___i))]
                    (let [#_"ObjExpr" ___fe (ß (ObjExpr) (:init ___bi))]
                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ILOAD), (:binding ___bi).idx))
                        (ß ___fe.emitLetFnInits(___gen, ___objx, ___lbset))
                    )
                )
            )

            (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                (ß (:body this).emit(___context, ___objx, ___gen))

                (let [#_"Label" ___end (ß ___gen.mark())]
                    (loop-when-recur [#_"ISeq" ___bis (ß (:bindingInits this).seq())] (some? ___bis) [(ß ___bis.next())]
                        (let [#_"BindingInit" ___bi (ß (BindingInit) ___bis.first())]
                            (let [#_"String" ___lname (ß (:binding ___bi).name)]
                                (when (ß ___lname.endsWith("__auto__"))
                                    (§ ass ___lname (ß ___lname + RT'nextID()))
                                )
                                (let [#_"Class" ___primc (ß maybePrimitiveType((:init ___bi)))]
                                    (if (some? ___primc)
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, Type/getDescriptor(___primc), nil, ___loopLabel, ___end, (:binding ___bi).idx))
                                        )
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, "Ljava/lang/Object;", nil, ___loopLabel, ___end, (:binding ___bi).idx))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"LetFnExpr" this]
        (ß (:body this).hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"LetFnExpr" this]
        (ß (:body this).getJavaClass())
    )
)

#_closure
(class-ns LetParser (§ implements IParser)
    (defn #_"LetParser" LetParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"LetParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            ;; (let [var val var2 val2 ...] body...)
            (let [#_"boolean" ___isLoop (ß RT'first(___form).equals(Compiler'LOOP))]
                (when (ß !(RT'second(___form) instanceof IPersistentVector))
                    (throw (IllegalArgumentException. "Bad binding form, expected vector"))
                )

                (let [#_"IPersistentVector" ___bindings (ß (IPersistentVector) RT'second(___form))]
                    (when (ß (___bindings.count() % 2) != 0)
                        (throw (IllegalArgumentException. "Bad binding form, expected matched symbol expression pairs"))
                    )

                    (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                        (when (ß ___context == :Context'EVAL || (___context == :Context'EXPRESSION && ___isLoop))
                            (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
                        )

                        (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                            (let [#_"IPersistentMap" ___backupMethodLocals (:locals ___method)]
                                (let [#_"IPersistentMap" ___backupMethodIndexLocals (:indexlocals ___method)]
                                    (let [#_"IPersistentVector" ___recurMismatches PersistentVector'EMPTY]
                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___bindings.count() / 2) [(inc ___i)]
                                            (§ ass ___recurMismatches (ß ___recurMismatches.cons(RT'F)))
                                        )

                                        ;; may repeat once for each binding with a mismatch, return breaks
                                        (while true
                                            (let [#_"IPersistentMap" ___dynamicBindings
                                                    (ß RT'map(
                                                        (§ map
                                                            Compiler'LOCAL_ENV      Compiler'LOCAL_ENV.deref()
                                                            Compiler'NEXT_LOCAL_NUM Compiler'NEXT_LOCAL_NUM.deref()
                                                        )
                                                    ))]
                                                (§ ass (:locals ___method) ___backupMethodLocals)
                                                (§ ass (:indexlocals ___method) ___backupMethodIndexLocals)

                                                (let [#_"PathNode" ___looproot (ß PathNode'new(:PathType'PATH, (PathNode) Compiler'CLEAR_PATH.get()))]
                                                    (let [#_"PathNode" ___clearroot (ß PathNode'new(:PathType'PATH, ___looproot))]
                                                        (let [#_"PathNode" ___clearpath (ß PathNode'new(:PathType'PATH, ___looproot))]
                                                            (when ___isLoop
                                                                (§ ass ___dynamicBindings (ß ___dynamicBindings.assoc(Compiler'LOOP_LOCALS, nil)))
                                                            )

                                                            (try
                                                                (Var'pushThreadBindings ___dynamicBindings)

                                                                (let [#_"PersistentVector" ___bindingInits PersistentVector'EMPTY]
                                                                    (let [#_"PersistentVector" ___loopLocals PersistentVector'EMPTY]
                                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___bindings.count()) [(+ ___i 2)]
                                                                            (when (ß !(___bindings.nth(___i) instanceof Symbol))
                                                                                (throw (IllegalArgumentException. (str "Bad binding form, expected symbol, got: " (ß ___bindings.nth(___i)))))
                                                                            )
                                                                            (let [#_"Symbol" ___sym (ß (Symbol) ___bindings.nth(___i))]
                                                                                (when (ß ___sym.getNamespace() != nil)
                                                                                    (throw (Util'runtimeException-1 (str "Can't let qualified name: " ___sym)))
                                                                                )
                                                                                (let [#_"Expr" ___init (ß analyze(:Context'EXPRESSION, ___bindings.nth(___i + 1), (:name ___sym)))]
                                                                                    (when ___isLoop
                                                                                        (cond (ß ___recurMismatches != nil && RT'booleanCast-1o(___recurMismatches.nth(___i / 2)))
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "box", RT'vector(___init), false)))
                                                                                                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                                                                                    (ß RT'errPrintWriter().println("Auto-boxing loop arg: " + ___sym))
                                                                                                )
                                                                                            )
                                                                                            (ß maybePrimitiveType(___init) == (§ class int))
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "longCast", RT'vector(___init), false)))
                                                                                            )
                                                                                            (ß maybePrimitiveType(___init) == (§ class float))
                                                                                            (do
                                                                                                (§ ass ___init (ß StaticMethodExpr'new("", 0, 0, nil, (§ class RT), "doubleCast", RT'vector(___init), false)))
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                    ;; sequential enhancement of env (like Lisp let*)
                                                                                    (try
                                                                                        (when ___isLoop
                                                                                            (ß Var'pushThreadBindings(RT'map(
                                                                                                (§ map
                                                                                                    Compiler'CLEAR_PATH ___clearpath
                                                                                                    Compiler'CLEAR_ROOT ___clearroot
                                                                                                    Compiler'NO_RECUR   nil
                                                                                                )
                                                                                            )))
                                                                                        )
                                                                                        (let [#_"LocalBinding" ___lb (ß registerLocal(___sym, tagOf(___sym), ___init, false))]
                                                                                            (let [#_"BindingInit" ___bi (BindingInit'new ___lb, ___init)]
                                                                                                (§ ass ___bindingInits (ß ___bindingInits.cons(___bi)))
                                                                                                (when ___isLoop
                                                                                                    (§ ass ___loopLocals (ß ___loopLocals.cons(___lb)))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                        (finally
                                                                                            (when ___isLoop
                                                                                                (ß Var'popThreadBindings())
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (when ___isLoop
                                                                            (ß Compiler'LOOP_LOCALS.set(___loopLocals))
                                                                        )
                                                                        (§ let [#_"Expr" ___bodyExpr]
                                                                            (let [#_"boolean" ___moreMismatches false]
                                                                                (try
                                                                                    (when ___isLoop
                                                                                        (let [#_"Object" ___methodReturnContext (ß (___context == :Context'RETURN) ? Compiler'METHOD_RETURN_CONTEXT.deref() :or nil)]
                                                                                            (ß Var'pushThreadBindings(RT'map(
                                                                                                (§ map
                                                                                                    Compiler'CLEAR_PATH            ___clearpath
                                                                                                    Compiler'CLEAR_ROOT            ___clearroot
                                                                                                    Compiler'NO_RECUR              nil
                                                                                                    Compiler'METHOD_RETURN_CONTEXT ___methodReturnContext
                                                                                                )
                                                                                            )))
                                                                                        )
                                                                                    )
                                                                                    (§ ass ___bodyExpr (ß (BodyParser'new()).parse(___isLoop ? :Context'RETURN :or ___context, ___body)))
                                                                                    (finally
                                                                                        (when ___isLoop
                                                                                            (ß Var'popThreadBindings())
                                                                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___loopLocals.count()) [(inc ___i)]
                                                                                                (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___loopLocals.nth(___i))]
                                                                                                    (when (:recurMistmatch ___lb)
                                                                                                        (§ ass ___recurMismatches (ß (IPersistentVector)___recurMismatches.assoc(___i, RT'T)))
                                                                                                        (§ ass ___moreMismatches true)
                                                                                                    )
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                                (when (ß !___moreMismatches)
                                                                                    (§ return (LetExpr'new ___bindingInits, ___bodyExpr, ___isLoop))
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                                (finally
                                                                    (ß Var'popThreadBindings())
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns LetExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"LetExpr" LetExpr'init []
        (hash-map
            #_"PersistentVector" :bindingInits nil
            #_"Expr" :body nil
            #_"boolean" :isLoop false
        )
    )

    (defn #_"LetExpr" LetExpr'new [#_"PersistentVector" ___bindingInits, #_"Expr" ___body, #_"boolean" ___isLoop]
        (let [this (LetExpr'init)]
            (§ ass (:bindingInits this) ___bindingInits)
            (§ ass (:body this) ___body)
            (§ ass (:isLoop this) ___isLoop)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"LetExpr" this]
        (throw (UnsupportedOperationException. "Can't eval let/loop"))
    )

    #_method
    (§ defn #_"void" emit [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, false))
        nil
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, true))
        nil
    )

    #_method
    (§ defn #_"void" doEmit [#_"LetExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"HashMap<BindingInit, Label>" ___bindingLabels (HashMap.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bindingInits this).count()) [(inc ___i)]
                (let [#_"BindingInit" ___bi (ß (BindingInit) (:bindingInits this).nth(___i))]
                    (let [#_"Class" ___primc (ß maybePrimitiveType((:init ___bi)))]
                        (if (some? ___primc)
                            (do
                                (ß ((MaybePrimitiveExpr) (:init ___bi)).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ISTORE), (:binding ___bi).idx))
                            )
                            (do
                                (ß (:init ___bi).emit(:Context'EXPRESSION, ___objx, ___gen))
                                (if (ß !___bi.binding.used && (:binding ___bi).canBeCleared)
                                    (do
                                        (ß ___gen.pop())
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:binding ___bi).idx))
                                    )
                                )
                            )
                        )
                        (ß ___bindingLabels.put(___bi, ___gen.mark()))
                    )
                )
            )
            (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                (if (:isLoop this)
                    (do
                        (try
                            (ß Var'pushThreadBindings(RT'map(Compiler'LOOP_LABEL, ___loopLabel)))
                            (if ___emitUnboxed
                                (do
                                    (ß ((MaybePrimitiveExpr)this.body).emitUnboxed(___context, ___objx, ___gen))
                                )
                                (do
                                    (ß (:body this).emit(___context, ___objx, ___gen))
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                    )
                    (do
                        (if ___emitUnboxed
                            (do
                                (ß ((MaybePrimitiveExpr)this.body).emitUnboxed(___context, ___objx, ___gen))
                            )
                            (do
                                (ß (:body this).emit(___context, ___objx, ___gen))
                            )
                        )
                    )
                )
                (let [#_"Label" ___end (ß ___gen.mark())]
                    (loop-when-recur [#_"ISeq" ___bis (ß (:bindingInits this).seq())] (some? ___bis) [(ß ___bis.next())]
                        (let [#_"BindingInit" ___bi (ß (BindingInit) ___bis.first())]
                            (let [#_"String" ___lname (ß (:binding ___bi).name)]
                                (when (ß ___lname.endsWith("__auto__"))
                                    (§ ass ___lname (ß ___lname + RT'nextID()))
                                )
                                (let [#_"Class" ___primc (ß maybePrimitiveType((:init ___bi)))]
                                    (if (some? ___primc)
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, Type/getDescriptor(___primc), nil, ___bindingLabels.get(___bi), ___end, (:binding ___bi).idx))
                                        )
                                        (do
                                            (ß ___gen.visitLocalVariable(___lname, "Ljava/lang/Object;", nil, ___bindingLabels.get(___bi), ___end, (:binding ___bi).idx))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"LetExpr" this]
        (ß (:body this).hasJavaClass())
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"LetExpr" this]
        (ß (:body this).getJavaClass())
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"LetExpr" this]
        (ß ((:body this) instanceof MaybePrimitiveExpr && ((MaybePrimitiveExpr)this.body).canEmitPrimitive()))
    )
)

#_closure
(class-ns RecurParser (§ implements IParser)
    (defn #_"RecurParser" RecurParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"RecurParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"int" ___line (ß lineDeref())]
            (let [#_"int" ___column (ß columnDeref())]
                (let [#_"String" ___source (ß (String) Compiler'SOURCE.deref())]
                    (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
                        (let [#_"IPersistentVector" ___loopLocals (ß (IPersistentVector) Compiler'LOOP_LOCALS.deref())]
                            (when (ß ___context != :Context'RETURN || ___loopLocals == nil)
                                (throw (UnsupportedOperationException. "Can only recur from tail position"))
                            )
                            (when (ß Compiler'NO_RECUR.deref() != nil)
                                (throw (UnsupportedOperationException. "Cannot recur across try"))
                            )
                            (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                                (loop-when-recur [#_"ISeq" ___s (ß RT'seq(___form.next()))] (some? ___s) [(ß ___s.next())]
                                    (§ ass ___args (ß ___args.cons(analyze(:Context'EXPRESSION, ___s.first()))))
                                )
                                (when (ß ___args.count() != ___loopLocals.count())
                                    (throw (IllegalArgumentException. (String/format "Mismatched argument count to recur, expected: %d args, got: %d", (§ array (ß ___loopLocals.count()), (ß ___args.count())))))
                                )
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___loopLocals.count()) [(inc ___i)]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___loopLocals.nth(___i))]
                                        (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                                            (when (some? ___primc)
                                                (let [#_"boolean" ___mismatch false]
                                                    (let [#_"Class" ___pc (ß maybePrimitiveType((Expr) ___args.nth(___i)))]
                                                        (cond (ß ___primc == (§ class long))
                                                            (do
                                                                (when (ß !(___pc == (§ class long) || ___pc == (§ class int) || ___pc == (§ class short) || ___pc == (§ class char) || ___pc == (§ class byte)))
                                                                    (§ ass ___mismatch true)
                                                                )
                                                            )
                                                            (ß ___primc == (§ class double))
                                                            (do
                                                                (when (ß !(___pc == (§ class double) || ___pc == (§ class float)))
                                                                    (§ ass ___mismatch true)
                                                                )
                                                            )
                                                        )
                                                        (when ___mismatch
                                                            (§ ass (:recurMistmatch ___lb) true)
                                                            (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                                                                (ß RT'errPrintWriter().println(___source + ":" + ___line + " recur arg for primitive local: " + (:name ___lb) + " is not matching primitive, had: " + ((___pc != nil) ? ___pc.getName() :or "Object") + ", needed: " + ___primc.getName()))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                (RecurExpr'new ___loopLocals, ___args, ___line, ___column, ___source)
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns RecurExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"RecurExpr" RecurExpr'init []
        (hash-map
            #_"IPersistentVector" :args nil
            #_"IPersistentVector" :loopLocals nil

            #_"int" :line 0
            #_"int" :column 0
            #_"String" :source nil
        )
    )

    (defn #_"RecurExpr" RecurExpr'new [#_"IPersistentVector" ___loopLocals, #_"IPersistentVector" ___args, #_"int" ___line, #_"int" ___column, #_"String" ___source]
        (let [this (RecurExpr'init)]
            (§ ass (:loopLocals this) ___loopLocals)
            (§ ass (:args this) ___args)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (§ ass (:source this) ___source)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"RecurExpr" this]
        (throw (UnsupportedOperationException. "Can't eval recur"))
    )

    #_method
    (§ defn #_"void" emit [#_"RecurExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (let [#_"Label" ___loopLabel (ß (Label) Compiler'LOOP_LABEL.deref())]
            (when (nil? ___loopLabel)
                (throw (IllegalStateException.))
            )
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:loopLocals this).count()) [(inc ___i)]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) (:loopLocals this).nth(___i))]
                    (let [#_"Expr" ___arg (ß (Expr) (:args this).nth(___i))]
                        (if (ß ___lb.getPrimitiveType() != nil)
                            (do
                                (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                                    (let [#_"Class" ___pc (ß maybePrimitiveType(___arg))]
                                        (cond (ß ___pc == ___primc)
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                            )
                                            (ß ___primc == (§ class long) && ___pc == (§ class int))
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.visitInsn(I2L))
                                            )
                                            (ß ___primc == (§ class double) && ___pc == (§ class float))
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.visitInsn(F2D))
                                            )
                                            (ß ___primc == (§ class int) && ___pc == (§ class long))
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("int intCast(long)")))
                                            )
                                            (ß ___primc == (§ class float) && ___pc == (§ class double))
                                            (do
                                                (ß ((MaybePrimitiveExpr) ___arg).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                                                (ß ___gen.visitInsn(D2F))
                                            )
                                            :else
                                            (do
                                                (throw (IllegalArgumentException. (str "recur arg for primitive local: " (:name ___lb) " is not matching primitive, had: " (ß ___arg.hasJavaClass() ? ___arg.getJavaClass().getName() :or "Object") ", needed: " (ß ___primc.getName()))))
                                            )
                                        )
                                    )
                                )
                            )
                            (do
                                (ß ___arg.emit(:Context'EXPRESSION, ___objx, ___gen))
                            )
                        )
                    )
                )
            )

            (loop-when-recur [#_"int" ___i (ß (:loopLocals this).count() - 1)] (ß ___i >= 0) [(dec ___i)]
                (let [#_"LocalBinding" ___lb (ß (LocalBinding) (:loopLocals this).nth(___i))]
                    (let [#_"Class" ___primc (ß ___lb.getPrimitiveType())]
                        (if (:isArg ___lb)
                            (do
                                (ß ___gen.storeArg((:idx ___lb) - ((:canBeDirect ___objx) ? 0 :or 1)))
                            )
                            (do
                                (if (some? ___primc)
                                    (do
                                        (ß ___gen.visitVarInsn(Type/getType(___primc).getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                    )
                                    (do
                                        (ß ___gen.visitVarInsn(Compiler'OBJECT_TYPE.getOpcode(Opcodes/ISTORE), (:idx ___lb)))
                                    )
                                )
                            )
                        )
                    )
                )
            )

            (ß ___gen.goTo(___loopLabel))
            nil
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"RecurExpr" this]
        Compiler'RECUR_CLASS
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"RecurExpr" this]
        true
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"RecurExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß emit(___context, ___objx, ___gen))
        nil
    )
)

(class-ns CompilerException (§ extends RuntimeException)
    (defn- #_"CompilerException" CompilerException'init []
        (hash-map
            #_"String" :source nil
            #_"int" :line 0
        )
    )

    (defn #_"CompilerException" CompilerException'new [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new (ß errorMsg(___source, ___line, ___column, (ß ___cause.toString()))), ___cause) (CompilerException'init))]
            (§ ass (:source this) ___source)
            (§ ass (:line this) ___line)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"CompilerException" this]
        (ß getMessage())
    )
)

#_closure
(class-ns DeftypeParser (§ implements IParser)
    (defn #_"DeftypeParser" DeftypeParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"DeftypeParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___rform (ß (ISeq) ___frm)]
            ;; (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
            (§ ass ___rform (RT'next ___rform))
            (let [#_"String" ___tagname (ß ((Symbol) ___rform.first()).getName())]
                (§ ass ___rform (ß ___rform.next()))
                (let [#_"Symbol" ___classname (ß (Symbol) ___rform.first())]
                    (§ ass ___rform (ß ___rform.next()))
                    (let [#_"IPersistentVector" ___fields (ß (IPersistentVector) ___rform.first())]
                        (§ ass ___rform (ß ___rform.next()))
                        (let [#_"IPersistentMap" ___opts PersistentHashMap'EMPTY]
                            (while (ß ___rform != nil && ___rform.first() instanceof Keyword)
                                (§ ass ___opts (ß ___opts.assoc(___rform.first(), RT'second(___rform))))
                                (§ ass ___rform (ß ___rform.next().next()))
                            )

                            (let [#_"ObjExpr" ___ret (ß build((IPersistentVector)RT'get-3(___opts, implementsKey, PersistentVector'EMPTY), ___fields, nil, ___tagname, ___classname, (Symbol) RT'get-2(___opts, RT'TAG_KEY), ___rform, ___frm, ___opts))]
                                ___ret
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ReifyParser (§ implements IParser)
    (defn #_"ReifyParser" ReifyParser'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Expr" parse [#_"ReifyParser" this, #_"Context" ___context, #_"Object" ___frm]
        ;; (reify this-name? [interfaces] (method-name [args] body)*)
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (let [#_"ObjMethod" ___enclosingMethod (ß (ObjMethod) Compiler'METHOD.deref())]
                (let [#_"String" ___basename (ß (___enclosingMethod != nil) ? (trimGenID((:objx ___enclosingMethod).name) + "$") :or (munge(currentNS().name.name) + "$"))]
                    (let [#_"String" ___simpleName (ß "reify__" + RT'nextID())]
                        (let [#_"String" ___classname (+ ___basename ___simpleName)]
                            (let [#_"ISeq" ___rform (RT'next ___form)]
                                (let [#_"IPersistentVector" ___interfaces (ß ((IPersistentVector) RT'first(___rform)).cons(Symbol'intern-1("cloiure.lang.IObj")))]
                                    (§ ass ___rform (RT'next ___rform))

                                    (let [#_"ObjExpr" ___ret (ß build(___interfaces, nil, nil, ___classname, Symbol'intern-1(___classname), nil, ___rform, ___frm, nil))]
                                        (if (ß ___frm instanceof IObj && ((IObj) ___frm).meta() != nil)
                                            (do
                                                (ß MetaExpr'new(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___frm).meta())))
                                            )
                                            (do
                                                ___ret
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns NewInstanceExpr (§ extends ObjExpr)
    (defn- #_"NewInstanceExpr" NewInstanceExpr'init []
        (hash-map
            #_"IPersistentCollection" :methods nil

            #_"Map<IPersistentVector, java.lang.reflect.Method>" :mmap nil
            #_"Map<IPersistentVector, Set<Class>>" :covariants nil
        )
    )

    (defn #_"NewInstanceExpr" NewInstanceExpr'new [#_"Object" ___tag]
        (merge (ObjExpr'new ___tag) (NewInstanceExpr'init))
    )

    (defn #_"ObjExpr" NewInstanceExpr'build [#_"IPersistentVector" ___interfaceSyms, #_"IPersistentVector" ___fieldSyms, #_"Symbol" ___thisSym, #_"String" ___tagName, #_"Symbol" ___className, #_"Symbol" ___typeTag, #_"ISeq" ___methodForms, #_"Object" ___frm, #_"IPersistentMap" ___opts]
        (let [#_"NewInstanceExpr" ___ret (NewInstanceExpr'new nil)]
            (§ ass (:src ___ret) ___frm)
            (§ ass (:name ___ret) (ß ___className.toString()))
            (§ ass (:classMeta ___ret) (RT'meta ___className))
            (§ ass (:internalName ___ret) (ß (:name ___ret).replace(\., \/)))
            (§ ass (:objtype ___ret) (ß Type/getObjectType((:internalName ___ret))))
            (§ ass (:opts ___ret) ___opts)

            (when (some? ___thisSym)
                (§ ass (:thisName ___ret) (:name ___thisSym))
            )

            (when (some? ___fieldSyms)
                (let [#_"IPersistentMap" ___fmap PersistentHashMap'EMPTY]
                    (let [#_"Object[]" ___closesvec (make-array Object (ß 2 * ___fieldSyms.count()))]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___fieldSyms.count()) [(inc ___i)]
                            (let [#_"Symbol" ___sym (ß (Symbol) ___fieldSyms.nth(___i))]
                                (let [#_"LocalBinding" ___lb (ß LocalBinding'new(-1, ___sym, nil, MethodParamExpr'new(tagClass(tagOf(___sym))), false, nil))]
                                    (§ ass ___fmap (ß ___fmap.assoc(___sym, ___lb)))
                                    (§ ass (ß ___closesvec[___i * 2]) ___lb)
                                    (§ ass (ß ___closesvec[___i * 2 + 1]) ___lb)
                                )
                            )
                        )

                        ;; todo - inject __meta et al into closes - when?
                        ;; use array map to preserve ctor order
                        (§ ass (:closes ___ret) (PersistentArrayMap'new-1 ___closesvec))
                        (§ ass (:fields ___ret) ___fmap)
                        (loop-when-recur [#_"int" ___i (ß ___fieldSyms.count() - 1)] (ß ___i >= 0 && (((Symbol)___fieldSyms.nth(___i)).name.equals("__meta") || ((Symbol)___fieldSyms.nth(___i)).name.equals("__extmap") || ((Symbol)___fieldSyms.nth(___i)).name.equals("__hash") || ((Symbol)___fieldSyms.nth(___i)).name.equals("__hasheq"))) [(dec ___i)]
                            (§ ass (:altCtorDrops ___ret) (ß (:altCtorDrops ___ret) + 1))
                        )
                    )
                )
            )

            (let [#_"PersistentVector" ___interfaces PersistentVector'EMPTY]
                (loop-when-recur [#_"ISeq" ___s (RT'seq ___interfaceSyms)] (some? ___s) [(ß ___s.next())]
                    (let [#_"Class" ___c (ß (Class) resolve((Symbol) ___s.first()))]
                        (when (ß !___c.isInterface())
                            (throw (IllegalArgumentException. (str "only interfaces are supported, had: " (ß ___c.getName()))))
                        )
                        (§ ass ___interfaces (ß ___interfaces.cons(___c)))
                    )
                )
                (let [#_"Class" ___superClass (§ class Object)]
                    (let [#_"Map[]" ___mc (ß NewInstanceExpr'gatherMethods-2s(___superClass, RT'seq(___interfaces)))]
                        (let [#_"Map" ___overrideables (ß ___mc[0])]
                            (let [#_"Map" ___covariants (ß ___mc[1])]
                                (§ ass (:mmap ___ret) ___overrideables)
                                (§ ass (:covariants ___ret) ___covariants)

                                (let [#_"String[]" ___inames (ß interfaceNames(___interfaces))]
                                    (let [#_"Class" ___stub (ß compileStub(slashname(___superClass), ___ret, ___inames, ___frm))]
                                        (let [#_"Symbol" ___thistag (ß Symbol'intern-2(nil, ___stub.getName()))]
                                            (try
                                                (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                    (§ map
                                                        Compiler'CONSTANTS          PersistentVector'EMPTY
                                                        Compiler'CONSTANT_IDS       (IdentityHashMap.)
                                                        Compiler'KEYWORDS           PersistentHashMap'EMPTY
                                                        Compiler'VARS               PersistentHashMap'EMPTY
                                                        Compiler'KEYWORD_CALLSITES  PersistentVector'EMPTY
                                                        Compiler'PROTOCOL_CALLSITES PersistentVector'EMPTY
                                                        Compiler'VAR_CALLSITES      (ß emptyVarCallSites())
                                                        Compiler'NO_RECUR           nil
                                                    )
                                                )))
                                                (when (ß ___ret.isDeftype())
                                                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                                        (§ map
                                                            Compiler'METHOD             nil
                                                            Compiler'LOCAL_ENV          (:fields ___ret)
                                                            Compiler'COMPILE_STUB_SYM   (Symbol'intern-2 nil, ___tagName)
                                                            Compiler'COMPILE_STUB_CLASS ___stub
                                                        )
                                                    )))

                                                    (§ ass (:hintedFields ___ret) (ß RT'subvec(___fieldSyms, 0, ___fieldSyms.count() - (:altCtorDrops ___ret))))
                                                )

                                                ;; now (methodname [args] body)*
                                                (§ ass (:line ___ret) (ß lineDeref()))
                                                (§ ass (:column ___ret) (ß columnDeref()))
                                                (let [#_"IPersistentCollection" ___methods nil]
                                                    (loop-when-recur [#_"ISeq" ___s ___methodForms] (some? ___s) [(RT'next ___s)]
                                                        (let [#_"NewInstanceMethod" ___m (ß NewInstanceMethod'parse(___ret, (ISeq) RT'first(___s), ___thistag, ___overrideables))]
                                                            (§ ass ___methods (RT'conj ___methods, ___m))
                                                        )
                                                    )

                                                    (§ ass (:methods ___ret) ___methods)
                                                    (§ ass (:keywords ___ret) (ß (IPersistentMap) Compiler'KEYWORDS.deref()))
                                                    (§ ass (:vars ___ret) (ß (IPersistentMap) Compiler'VARS.deref()))
                                                    (§ ass (:constants ___ret) (ß (PersistentVector) Compiler'CONSTANTS.deref()))
                                                    (§ ass (:constantsID ___ret) (ß RT'nextID()))
                                                    (§ ass (:keywordCallsites ___ret) (ß (IPersistentVector) Compiler'KEYWORD_CALLSITES.deref()))
                                                    (§ ass (:protocolCallsites ___ret) (ß (IPersistentVector) Compiler'PROTOCOL_CALLSITES.deref()))
                                                    (§ ass (:varCallsites ___ret) (ß (IPersistentSet) Compiler'VAR_CALLSITES.deref()))
                                                )
                                                (finally
                                                    (when (ß ___ret.isDeftype())
                                                        (ß Var'popThreadBindings())
                                                    )
                                                    (ß Var'popThreadBindings())
                                                )
                                            )

                                            (try
                                                (ß ___ret.compile(slashname(___superClass), ___inames, false))
                                                (catch IOException ___e
                                                    (throw (Util'sneakyThrow ___e))
                                                )
                                            )
                                            (ß ___ret.getCompiledClass())
                                            ___ret
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
        ; Current host interop uses reflection, which requires pre-existing classes
        ; Work around this by:
        ; Generate a stub class that has the same interfaces and fields as the class we are generating.
        ; Use it as a type hint for this, and bind the simple name of the class to this stub (in resolve etc)
        ; Unmunge the name (using a magic prefix) on any code gen for classes
        ;;
    (defn #_"Class" NewInstanceExpr'compileStub [#_"String" ___superName, #_"NewInstanceExpr" ___ret, #_"String[]" ___interfaceNames, #_"Object" ___frm]
        (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
            (let [#_"ClassVisitor" ___cv ___cw]
                (ß ___cv.visit(V1_5, Opcodes/ACC_PUBLIC + Opcodes/ACC_SUPER, Compiler'COMPILE_STUB_PREFIX + "/" + (:internalName ___ret), nil, ___superName, ___interfaceNames))

                ;; instance fields for closed-overs
                (loop-when-recur [#_"ISeq" ___s (ß RT'keys((:closes ___ret)))] (some? ___s) [(ß ___s.next())]
                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___s.first())]
                        (let [#_"int" ___access (ß Opcodes/ACC_PUBLIC + (___ret.isVolatile(___lb) ? Opcodes/ACC_VOLATILE :or ___ret.isMutable(___lb) ? 0 :or Opcodes/ACC_FINAL))]
                            (if (ß ___lb.getPrimitiveType() != nil)
                                (do
                                    (ß ___cv.visitField(___access, (:name ___lb), Type/getType(___lb.getPrimitiveType()).getDescriptor(), nil, nil))
                                )
                                (do
                                    ;; todo - when closed-overs are fields, use more specific types here and in ctor and emitLocal?
                                    (ß ___cv.visitField(___access, (:name ___lb), Compiler'OBJECT_TYPE.getDescriptor(), nil, nil))
                                )
                            )
                        )
                    )
                )

                ;; ctor that takes closed-overs and does nothing
                (let [#_"Method" ___m (Method. "<init>", Type/VOID_TYPE, (ß ___ret.ctorTypes()))]
                    (let [#_"GeneratorAdapter" ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, nil, ___cv)]
                        (ß ___ctorgen.visitCode())
                        (ß ___ctorgen.loadThis())
                        (ß ___ctorgen.invokeConstructor(Type/getObjectType(___superName), voidctor))
                        (ß ___ctorgen.returnValue())
                        (ß ___ctorgen.endMethod())

                        (when (ß (:altCtorDrops ___ret) > 0)
                            (let [#_"Type[]" ___ctorTypes (ß ___ret.ctorTypes())]
                                (let [#_"Type[]" ___altCtorTypes (make-array Type (ß ___ctorTypes.length - (:altCtorDrops ret)))]
                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___altCtorTypes.length) [(inc ___i)]
                                        (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                    )
                                    (let [#_"Method" ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes)]
                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                        (ß ___ctorgen.visitCode())
                                        (ß ___ctorgen.loadThis())
                                        (ß ___ctorgen.loadArgs())

                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __meta
                                        (ß ___ctorgen.visitInsn(Opcodes/ACONST_NULL)) ;; __extmap
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                        (ß ___ctorgen.invokeConstructor(Type/getObjectType(Compiler'COMPILE_STUB_PREFIX + "/" + (:internalName ___ret)), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                        (ß ___ctorgen.returnValue())
                                        (ß ___ctorgen.endMethod())

                                        ;; alt ctor no __hash, __hasheq
                                        (§ ass ___altCtorTypes (make-array Type (ß ___ctorTypes.length - 2)))
                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___altCtorTypes.length) [(inc ___i)]
                                            (§ ass (ß ___altCtorTypes[___i]) (ß ___ctorTypes[___i]))
                                        )

                                        (§ ass ___alt (Method. "<init>", Type/VOID_TYPE, ___altCtorTypes))
                                        (§ ass ___ctorgen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___alt, nil, nil, ___cv))
                                        (ß ___ctorgen.visitCode())
                                        (ß ___ctorgen.loadThis())
                                        (ß ___ctorgen.loadArgs())

                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hash
                                        (ß ___ctorgen.visitInsn(Opcodes/ICONST_0)) ;; __hasheq

                                        (ß ___ctorgen.invokeConstructor(Type/getObjectType(Compiler'COMPILE_STUB_PREFIX + "/" + (:internalName ___ret)), (Method. "<init>", Type/VOID_TYPE, ___ctorTypes)))

                                        (ß ___ctorgen.returnValue())
                                        (ß ___ctorgen.endMethod())
                                    )
                                )
                            )
                        )
                        ;; end of class
                        (ß ___cv.visitEnd())

                        (let [#_"byte[]" ___bytecode (ß ___cw.toByteArray())]
                            (let [#_"DynamicClassLoader" ___loader (ß (DynamicClassLoader) Compiler'LOADER.deref())]
                                (ß ___loader.defineClass(Compiler'COMPILE_STUB_PREFIX + "." + (:name ___ret), ___bytecode, ___frm))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"String[]" NewInstanceExpr'interfaceNames [#_"IPersistentVector" ___interfaces]
        (let [#_"int" ___icnt (ß ___interfaces.count())]
            (let [#_"String[]" ___inames (ß (___icnt > 0) ? new String[___icnt] :or nil)]
                (loop-when-recur [#_"int" ___i 0] (< ___i ___icnt) [(inc ___i)]
                    (§ ass (ß ___inames[___i]) (ß slashname((Class) ___interfaces.nth(___i))))
                )
                ___inames
            )
        )
    )

    (defn #_"String" NewInstanceExpr'slashname [#_"Class" ___c]
        (ß ___c.getName().replace(\., \/))
    )

    #_protected
    #_method
    (§ defn #_"void" emitStatics [#_"NewInstanceExpr" this, #_"ClassVisitor" ___cv]
        (when (ß this.isDeftype())
            ;; getBasis()
            (let [#_"Method" ___meth (Method/getMethod "cloiure.lang.IPersistentVector getBasis()")]
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), ___meth, nil, nil, ___cv)]
                    (ß emitValue((:hintedFields this), ___gen))
                    (ß ___gen.returnValue())
                    (ß ___gen.endMethod())

                    (when (ß this.isDeftype() && (:fields this).count() > (:hintedFields this).count())
                        ;; create(IPersistentMap)
                        (let [#_"String" ___className (ß (:name this).replace(\., \/))]
                            (let [#_"int" ___i 1]
                                (let [#_"int" ___fieldCount (ß (:hintedFields this).count())]
                                    (let [#_"MethodVisitor" ___mv (ß ___cv.visitMethod(Opcodes/ACC_PUBLIC + Opcodes/ACC_STATIC, "create", "(Lcloiure/lang/IPersistentMap;)L" + ___className + ";", nil, nil))]
                                        (ß ___mv.visitCode())

                                        (loop-when-recur [#_"ISeq" ___s (RT'seq (:hintedFields this)) ___i ___i] (some? ___s) [(ß ___s.next()) (inc ___i)]
                                            (let [#_"String" ___bName (ß ((Symbol)___s.first()).name)]
                                                (let [#_"Class" ___k (ß tagClass(tagOf(___s.first())))]
                                                    (ß ___mv.visitVarInsn(ALOAD, 0))
                                                    (ß ___mv.visitLdcInsn(___bName))
                                                    (ß ___mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                    (ß ___mv.visitInsn(ACONST_NULL))
                                                    (ß ___mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "valAt", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;"))
                                                    (when (ß ___k.isPrimitive())
                                                        (ß ___mv.visitTypeInsn(CHECKCAST, Type/getType(boxClass(___k)).getInternalName()))
                                                    )
                                                    (ß ___mv.visitVarInsn(ASTORE, ___i))
                                                    (ß ___mv.visitVarInsn(ALOAD, 0))
                                                    (ß ___mv.visitLdcInsn(___bName))
                                                    (ß ___mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/Keyword", "intern", "(Ljava/lang/String;)Lcloiure/lang/Keyword;"))
                                                    (ß ___mv.visitMethodInsn(INVOKEINTERFACE, "cloiure/lang/IPersistentMap", "without", "(Ljava/lang/Object;)Lcloiure/lang/IPersistentMap;"))
                                                    (ß ___mv.visitVarInsn(ASTORE, 0))
                                                )
                                            )
                                        )

                                        (ß ___mv.visitTypeInsn(Opcodes/NEW, ___className))
                                        (ß ___mv.visitInsn(DUP))

                                        (let [#_"Method" ___ctor (Method. "<init>", Type/VOID_TYPE, (ß ctorTypes()))]
                                            (when (ß (:hintedFields this).count() > 0)
                                                (loop-when-recur [___i 1] (ß ___i <= ___fieldCount) [(inc ___i)]
                                                    (ß ___mv.visitVarInsn(ALOAD, ___i))
                                                    (let [#_"Class" ___k (ß tagClass(tagOf((:hintedFields this).nth(___i - 1))))]
                                                        (when (ß ___k.isPrimitive())
                                                            (let [#_"String" ___b (ß Type/getType(boxClass(___k)).getInternalName())]
                                                                (let [#_"String" ___p (ß Type/getType(___k).getDescriptor())]
                                                                    (let [#_"String" ___n (ß ___k.getName())]
                                                                        (ß ___mv.visitMethodInsn(INVOKEVIRTUAL, ___b, ___n + "Value", "()" + ___p))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )

                                            (ß ___mv.visitInsn(ACONST_NULL)) ;; __meta
                                            (ß ___mv.visitVarInsn(ALOAD, 0)) ;; __extmap
                                            (ß ___mv.visitMethodInsn(INVOKESTATIC, "cloiure/lang/RT", "seqOrElse", "(Ljava/lang/Object;)Ljava/lang/Object;"))
                                            (ß ___mv.visitInsn(ICONST_0)) ;; __hash
                                            (ß ___mv.visitInsn(ICONST_0)) ;; __hasheq
                                            (ß ___mv.visitMethodInsn(INVOKESPECIAL, ___className, "<init>", ___ctor.getDescriptor()))
                                            (ß ___mv.visitInsn(ARETURN))
                                            (ß ___mv.visitMaxs(4 + ___fieldCount, 1 + ___fieldCount))
                                            (ß ___mv.visitEnd())
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_protected
    #_method
    (§ defn #_"void" emitMethods [#_"NewInstanceExpr" this, #_"ClassVisitor" ___cv]
        (loop-when-recur [#_"ISeq" ___s (RT'seq (:methods this))] (some? ___s) [(ß ___s.next())]
            (let [#_"ObjMethod" ___method (ß (ObjMethod) ___s.first())]
                (ß ___method.emit(this, ___cv))
            )
        )
        ;; emit bridge methods
        (doseq [#_"Map$Entry<IPersistentVector, Set<Class>>" ___e (ß (:covariants this).entrySet())]
            (let [#_"java.lang.reflect.Method" ___m (ß (:mmap this).get(___e.getKey()))]
                (let [#_"Class[]" ___params (ß ___m.getParameterTypes())]
                    (let [#_"Type[]" ___argTypes (make-array Type (ß ___params.length))]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___params.length) [(inc ___i)]
                            (§ ass (ß ___argTypes[___i]) (ß Type/getType(___params[___i])))
                        )

                        (let [#_"Method" ___target (Method. (ß ___m.getName()), (Type/getType (ß ___m.getReturnType())), ___argTypes)]
                            (doseq [#_"Class" ___retType (ß ___e.getValue())]
                                (let [#_"Method" ___meth (Method. (ß ___m.getName()), (Type/getType ___retType), ___argTypes)]
                                    ;; todo don't hardwire EXCEPTION_TYPES
                                    (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_BRIDGE), ___meth, nil, Compiler'EXCEPTION_TYPES, ___cv)]
                                        (ß ___gen.visitCode())
                                        (ß ___gen.loadThis())
                                        (ß ___gen.loadArgs())
                                        (ß ___gen.invokeInterface(Type/getType(___m.getDeclaringClass()), ___target))
                                        (ß ___gen.returnValue())
                                        (ß ___gen.endMethod())
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"IPersistentVector" NewInstanceExpr'msig [#_"java.lang.reflect.Method" ___m]
        (ß RT'vector(___m.getName(), RT'seq(___m.getParameterTypes()), ___m.getReturnType()))
    )

    (defn #_"void" NewInstanceExpr'considerMethod [#_"java.lang.reflect.Method" ___m, #_"Map" ___mm]
        (let [#_"IPersistentVector" ___mk (ß msig(___m))]
            (let [#_"int" ___mods (ß ___m.getModifiers())]
                (when (ß !(___mm.containsKey(___mk) || !(Modifier/isPublic(___mods) || Modifier/isProtected(___mods)) || Modifier/isStatic(___mods) || Modifier/isFinal(___mods)))
                    (ß ___mm.put(___mk, ___m))
                )
                nil
            )
        )
    )

    (defn #_"void" NewInstanceExpr'gatherMethods-2m [#_"Class" ___c, #_"Map" ___mm]
        (loop-when-recur [___c ___c] (some? ___c) [(ß ___c.getSuperclass())]
            (doseq [#_"java.lang.reflect.Method" ___m (ß ___c.getDeclaredMethods())]
                (ß considerMethod(___m, ___mm))
            )
            (doseq [#_"java.lang.reflect.Method" ___m (ß ___c.getMethods())]
                (ß considerMethod(___m, ___mm))
            )
        )
        nil
    )

    (defn #_"Map[]" NewInstanceExpr'gatherMethods-2s [#_"Class" ___sc, #_"ISeq" ___interfaces]
        (let [#_"Map" ___allm (HashMap.)]
            (NewInstanceExpr'gatherMethods-2m ___sc, ___allm)
            (loop-when-recur [___interfaces ___interfaces] (some? ___interfaces) [(ß ___interfaces.next())]
                (ß NewInstanceExpr'gatherMethods-2m((Class) ___interfaces.first(), ___allm))
            )

            (let [#_"Map<IPersistentVector, java.lang.reflect.Method>" ___mm (HashMap.)]
                (let [#_"Map<IPersistentVector, Set<Class>>" ___covariants (HashMap.)]
                    (doseq [#_"Object" ___o (ß ___allm.entrySet())]
                        (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                            (let [#_"IPersistentVector" ___mk (ß (IPersistentVector) ___e.getKey())]
                                (§ ass ___mk (ß (IPersistentVector) ___mk.pop()))
                                (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___e.getValue())]
                                    (if (ß ___mm.containsKey(___mk)) ;; covariant return
                                        (do
                                            (let [#_"Set<Class>" ___cvs (ß ___covariants.get(___mk))]
                                                (when (nil? ___cvs)
                                                    (§ ass ___cvs (HashSet.))
                                                    (ß ___covariants.put(___mk, ___cvs))
                                                )
                                                (let [#_"java.lang.reflect.Method" ___om (ß ___mm.get(___mk))]
                                                    (if (ß ___om.getReturnType().isAssignableFrom(___m.getReturnType()))
                                                        (do
                                                            (ß ___cvs.add(___om.getReturnType()))
                                                            (ß ___mm.put(___mk, ___m))
                                                        )
                                                        (do
                                                            (ß ___cvs.add(___m.getReturnType()))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (ß ___mm.put(___mk, ___m))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (ß new Map[] (§ array ___mm, ___covariants ))
                )
            )
        )
    )
)

(class-ns NewInstanceMethod (§ extends ObjMethod)
    (§ def #_"Symbol" NewInstanceMethod'dummyThis (Symbol'intern-2 nil, "dummy_this_dlskjsdfower"))

    (defn- #_"NewInstanceMethod" NewInstanceMethod'init []
        (hash-map
            #_"String" :name nil
            #_"Type[]" :argTypes nil
            #_"Type" :retType nil
            #_"Class" :retClass nil
            #_"Class[]" :exclasses nil

            #_"IPersistentVector" :parms nil
        )
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'new [#_"ObjExpr" ___objx, #_"ObjMethod" ___parent]
        (merge (ObjMethod'new ___objx, ___parent) (NewInstanceMethod'init))
    )

    #_method
    (§ defn #_"int" numParams [#_"NewInstanceMethod" this]
        (ß (:argLocals this).count())
    )

    #_method
    (§ defn #_"String" getMethodName [#_"NewInstanceMethod" this]
        (:name this)
    )

    #_method
    (§ defn #_"Type" getReturnType [#_"NewInstanceMethod" this]
        (:retType this)
    )

    #_method
    (§ defn #_"Type[]" getArgTypes [#_"NewInstanceMethod" this]
        (:argTypes this)
    )

    (defn #_"IPersistentVector" NewInstanceMethod'msig [#_"String" ___name, #_"Class[]" ___paramTypes]
        (ß RT'vector(___name, RT'seq(___paramTypes)))
    )

    (defn #_"NewInstanceMethod" NewInstanceMethod'parse [#_"ObjExpr" ___objx, #_"ISeq" ___form, #_"Symbol" ___thistag, #_"Map" ___overrideables]
        ;; (methodname [this-name args*] body...)
        ;; this-name might be nil
        (let [#_"NewInstanceMethod" ___method (ß NewInstanceMethod'new(___objx, (ObjMethod) Compiler'METHOD.deref()))]
            (let [#_"Symbol" ___dotname (ß (Symbol)RT'first(___form))]
                (let [#_"Symbol" ___name (ß (Symbol) Symbol'intern-2(nil, munge((:name ___dotname))).withMeta(RT'meta(___dotname)))]
                    (let [#_"IPersistentVector" ___parms (ß (IPersistentVector) RT'second(___form))]
                        (when (ß ___parms.count() == 0)
                            (throw (IllegalArgumentException. (str "Must supply at least one argument for 'this' in: " ___dotname)))
                        )
                        (let [#_"Symbol" ___thisName (ß (Symbol) ___parms.nth(0))]
                            (§ ass ___parms (ß RT'subvec(___parms, 1, ___parms.count())))
                            (let [#_"ISeq" ___body (ß RT'next(RT'next(___form)))]
                                (try
                                    (§ ass (:line ___method) (ß lineDeref()))
                                    (§ ass (:column ___method) (ß columnDeref()))
                                    ;; register as the current method and set up a new env frame
                                    (let [#_"PathNode" ___pnode (ß PathNode'new(:PathType'PATH, (PathNode) Compiler'CLEAR_PATH.get()))]
                                        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                            (§ map
                                                Compiler'METHOD                ___method
                                                Compiler'LOCAL_ENV             (ß Compiler'LOCAL_ENV.deref())
                                                Compiler'LOOP_LOCALS           nil
                                                Compiler'NEXT_LOCAL_NUM        0
                                                Compiler'CLEAR_PATH            ___pnode
                                                Compiler'CLEAR_ROOT            ___pnode
                                                Compiler'CLEAR_SITES           PersistentHashMap'EMPTY
                                                Compiler'METHOD_RETURN_CONTEXT RT'T
                                            )
                                        )))

                                        ;; register 'this' as local 0
                                        (if (some? ___thisName)
                                            (do
                                                (ß registerLocal((___thisName == nil) ? dummyThis :or ___thisName, ___thistag, nil, false))
                                            )
                                            (do
                                                (ß getAndIncLocalNum())
                                            )
                                        )

                                        (let [#_"PersistentVector" ___argLocals PersistentVector'EMPTY]
                                            (§ ass (:retClass ___method) (ß tagClass(tagOf(___name))))
                                            (§ ass (:argTypes ___method) (make-array Type (ß ___parms.count())))
                                            (let [#_"boolean" ___hinted (ß tagOf(___name) != nil)]
                                                (let [#_"Class[]" ___pclasses (make-array Class (ß ___parms.count()))]
                                                    (let [#_"Symbol[]" ___psyms (§ typeless make-array Symbol (ß ___parms.count()))]
                                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___parms.count()) [(inc ___i)]
                                                            (when (ß !(___parms.nth(___i) instanceof Symbol))
                                                                (throw (IllegalArgumentException. "params must be Symbols"))
                                                            )
                                                            (let [#_"Symbol" ___p (ß (Symbol) ___parms.nth(___i))]
                                                                (let [#_"Object" ___tag (ß tagOf(___p))]
                                                                    (when (some? ___tag)
                                                                        (§ ass ___hinted true)
                                                                    )
                                                                    (when (ß ___p.getNamespace() != nil)
                                                                        (§ ass ___p (ß Symbol'intern-1((:name ___p))))
                                                                    )
                                                                    (let [#_"Class" ___pclass (ß tagClass(___tag))]
                                                                        (§ ass (ß ___pclasses[___i]) ___pclass)
                                                                        (§ ass (ß ___psyms[___i]) ___p)
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (let [#_"Map" ___matches (ß findMethodsWithNameAndArity((:name ___name), ___parms.count(), ___overrideables))]
                                                            (let [#_"Object" ___mk (ß msig((:name ___name), ___pclasses))]
                                                                (let [#_"java.lang.reflect.Method" ___m nil]
                                                                    (if (ß ___matches.size() > 0)
                                                                        (do
                                                                            ;; multiple methods
                                                                            (cond (ß ___matches.size() > 1)
                                                                                (do
                                                                                    ;; must be hinted and match one method
                                                                                    (when (ß !___hinted)
                                                                                        (throw (IllegalArgumentException. (str "Must hint overloaded method: " (:name ___name))))
                                                                                    )
                                                                                    (§ ass ___m (ß (java.lang.reflect.Method) ___matches.get(___mk)))
                                                                                    (when (nil? ___m)
                                                                                        (throw (IllegalArgumentException. (str "Can't find matching overloaded method: " (:name ___name))))
                                                                                    )
                                                                                    (when (ß ___m.getReturnType() != (:retClass ___method))
                                                                                        (throw (IllegalArgumentException. (str "Mismatched return type: " (:name ___name) ", expected: " (ß ___m.getReturnType().getName()) ", had: " (ß (:retClass ___method).getName()))))
                                                                                    )
                                                                                )
                                                                                :else ;; one match
                                                                                (do
                                                                                    ;; if hinted, validate match
                                                                                    (cond ___hinted
                                                                                        (do
                                                                                            (§ ass ___m (ß (java.lang.reflect.Method) ___matches.get(___mk)))
                                                                                            (when (nil? ___m)
                                                                                                (throw (IllegalArgumentException. (str "Can't find matching method: " (:name ___name) ", leave off hints for auto match.")))
                                                                                            )
                                                                                            (when (ß ___m.getReturnType() != (:retClass ___method))
                                                                                                (throw (IllegalArgumentException. (str "Mismatched return type: " (:name ___name) ", expected: " (ß ___m.getReturnType().getName()) ", had: " (ß (:retClass ___method).getName()))))
                                                                                            )
                                                                                        )
                                                                                        :else ;; adopt found method sig
                                                                                        (do
                                                                                            (§ ass ___m (ß (java.lang.reflect.Method) ___matches.values().iterator().next()))
                                                                                            (§ ass (:retClass ___method) (ß ___m.getReturnType()))
                                                                                            (§ ass ___pclasses (ß ___m.getParameterTypes()))
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                        (do
                                                                            (throw (IllegalArgumentException. (str "Can't define method not in interfaces: " (:name ___name))))
                                                                        )
                                                                    )

                                                                    ;; validate unque name+arity among additional methods

                                                                    (§ ass (:retType ___method) (ß Type/getType((:retClass ___method))))
                                                                    (§ ass (:exclasses ___method) (ß ___m.getExceptionTypes()))

                                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___parms.count()) [(inc ___i)]
                                                                        (let [#_"LocalBinding" ___lb (ß registerLocal(___psyms[___i], nil, MethodParamExpr'new(___pclasses[___i]), true))]
                                                                            (§ ass ___argLocals (ß ___argLocals.assocN(___i, ___lb)))
                                                                            (§ ass (ß (:argTypes ___method)[___i]) (ß Type/getType(___pclasses[___i])))
                                                                        )
                                                                    )
                                                                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___parms.count()) [(inc ___i)]
                                                                        (when (ß ___pclasses[___i] == (§ class long) || ___pclasses[___i] == (§ class double))
                                                                            (ß getAndIncLocalNum())
                                                                        )
                                                                    )
                                                                    (ß Compiler'LOOP_LOCALS.set(___argLocals))
                                                                    (§ ass (:name ___method) (:name ___name))
                                                                    (§ ass (:methodMeta ___method) (RT'meta ___name))
                                                                    (§ ass (:parms ___method) ___parms)
                                                                    (§ ass (:argLocals ___method) ___argLocals)
                                                                    (§ ass (:body ___method) (ß (BodyParser'new()).parse(:Context'RETURN, ___body)))
                                                                    ___method
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (finally
                                        (ß Var'popThreadBindings())
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithNameAndArity [#_"String" ___name, #_"int" ___arity, #_"Map" ___mm]
        (let [#_"Map" ___ret (HashMap.)]
            (doseq [#_"Object" ___o (ß ___mm.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___e.getValue())]
                        (when (ß ___name.equals(___m.getName()) && ___m.getParameterTypes().length == ___arity)
                            (ß ___ret.put(___e.getKey(), ___e.getValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn- #_"Map" NewInstanceMethod'findMethodsWithName [#_"String" ___name, #_"Map" ___mm]
        (let [#_"Map" ___ret (HashMap.)]
            (doseq [#_"Object" ___o (ß ___mm.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                    (let [#_"java.lang.reflect.Method" ___m (ß (java.lang.reflect.Method) ___e.getValue())]
                        (when (ß ___name.equals(___m.getName()))
                            (ß ___ret.put(___e.getKey(), ___e.getValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"void" emit [#_"NewInstanceMethod" this, #_"ObjExpr" ___obj, #_"ClassVisitor" ___cv]
        (let [#_"Method" ___m (Method. (ß getMethodName()), (ß getReturnType()), (ß getArgTypes()))]
            (let [#_"Type[]" ___extypes nil]
                (when (ß (:exclasses this).length > 0)
                    (§ ass ___extypes (make-array Type (ß (:exclasses this).length)))
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:exclasses this).length) [(inc ___i)]
                        (§ ass (ß ___extypes[___i]) (ß Type/getType((:exclasses this)[___i])))
                    )
                )
                (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. Opcodes/ACC_PUBLIC, ___m, nil, ___extypes, ___cv)]
                    (ß addAnnotation(___gen, (:methodMeta this)))
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < (:parms this).count()) [(inc ___i)]
                        (let [#_"IPersistentMap" ___meta (ß RT'meta((:parms this).nth(___i)))]
                            (ß addParameterAnnotation(___gen, ___meta, ___i))
                        )
                    )
                    (ß ___gen.visitCode())

                    (let [#_"Label" ___loopLabel (ß ___gen.mark())]
                        (ß ___gen.visitLineNumber((:line this), ___loopLabel))
                        (try
                            (ß Var'pushThreadBindings(RT'map(Compiler'LOOP_LABEL, ___loopLabel, Compiler'METHOD, this)))

                            (ß emitBody((:objx this), ___gen, (:retClass this), (:body this)))
                            (let [#_"Label" ___end (ß ___gen.mark())]
                                (ß ___gen.visitLocalVariable("this", (:objtype ___obj).getDescriptor(), nil, ___loopLabel, ___end, 0))
                                (loop-when-recur [#_"ISeq" ___lbs (ß (:argLocals this).seq())] (some? ___lbs) [(ß ___lbs.next())]
                                    (let [#_"LocalBinding" ___lb (ß (LocalBinding) ___lbs.first())]
                                        (ß ___gen.visitLocalVariable((:name ___lb), (:argTypes this)[___lb.idx-1].getDescriptor(), nil, ___loopLabel, ___end, (:idx ___lb)))
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )

                        (ß ___gen.returnValue())
                        (ß ___gen.endMethod())
                        nil
                    )
                )
            )
        )
    )
)

(class-ns MethodParamExpr (§ implements Expr, MaybePrimitiveExpr)
    (defn- #_"MethodParamExpr" MethodParamExpr'init []
        (hash-map
            #_"Class" :c nil
        )
    )

    (defn #_"MethodParamExpr" MethodParamExpr'new [#_"Class" ___c]
        (let [this (MethodParamExpr'init)]
            (§ ass (:c this) ___c)
            this
        )
    )

    #_method
    (§ defn #_"Object" eval [#_"MethodParamExpr" this]
        (throw (Util'runtimeException-1 "Can't eval"))
    )

    #_method
    (§ defn #_"void" emit [#_"MethodParamExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (throw (Util'runtimeException-1 "Can't emit"))
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"MethodParamExpr" this]
        (ß ((:c this) != nil))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"MethodParamExpr" this]
        (:c this)
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"MethodParamExpr" this]
        (Util'isPrimitive (:c this))
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"MethodParamExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (throw (Util'runtimeException-1 "Can't emit"))
    )
)

#_closure
(class-ns CaseParser (§ implements IParser)
    (defn #_"CaseParser" CaseParser'new []
        (hash-map)
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    ;; prepared by case macro and presumed correct
    ;; case macro binds actual expr in let so expr is always a local,
    ;; no need to worry about multiple evaluation
    #_method
    (§ defn #_"Expr" parse [#_"CaseParser" this, #_"Context" ___context, #_"Object" ___frm]
        (let [#_"ISeq" ___form (ß (ISeq) ___frm)]
            (when (ß ___context == :Context'EVAL)
                (§ return (ß analyze(___context, RT'list-1(RT'list-3(Compiler'FNONCE, PersistentVector'EMPTY, ___form)))))
            )
            (let [#_"IPersistentVector" ___args (ß LazilyPersistentVector'create(___form.next()))]
                (let [#_"Object" ___exprForm (ß ___args.nth(0))]
                    (let [#_"int" ___shift (ß ((Number)___args.nth(1)).intValue())]
                        (let [#_"int" ___mask (ß ((Number)___args.nth(2)).intValue())]
                            (let [#_"Object" ___defaultForm (ß ___args.nth(3))]
                                (let [#_"Map" ___caseMap (ß (Map)___args.nth(4))]
                                    (let [#_"Keyword" ___switchType (ß ((Keyword)___args.nth(5)))]
                                        (let [#_"Keyword" ___testType (ß ((Keyword)___args.nth(6)))]
                                            (let [#_"Set" ___skipCheck (ß (RT'count(___args) < 8) ? nil :or (Set)___args.nth(7))]
                                                (let [#_"ISeq" ___keys (RT'keys ___caseMap)]
                                                    (let [#_"int" ___low (ß ((Number)RT'first(___keys)).intValue())]
                                                        (let [#_"int" ___high (ß ((Number)RT'nth-2(___keys, RT'count(___keys) - 1)).intValue())]
                                                            (let [#_"LocalBindingExpr" ___testexpr (ß (LocalBindingExpr) analyze(:Context'EXPRESSION, ___exprForm))]
                                                                (§ ass (:shouldClear ___testexpr) false)

                                                                (let [#_"SortedMap<Integer, Expr>" ___tests (TreeMap.)]
                                                                    (let [#_"HashMap<Integer, Expr>" ___thens (HashMap.)]
                                                                        (let [#_"PathNode" ___branch (ß PathNode'new(:PathType'BRANCH, (PathNode) Compiler'CLEAR_PATH.get()))]
                                                                            (doseq [#_"Object" ___o (ß ___caseMap.entrySet())]
                                                                                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                                                                                    (let [#_"Integer" ___minhash (ß ((Number)___e.getKey()).intValue())]
                                                                                        (let [#_"Object" ___pair (ß ___e.getValue())] ;; [test-val then-expr]
                                                                                            (let [#_"Expr" ___testExpr (ß (___testType == intKey) ? NumberExpr'parse(((Number)RT'first(___pair)).intValue()) :or ConstantExpr'new(RT'first(___pair)))]
                                                                                                (ß ___tests.put(___minhash, ___testExpr))

                                                                                                (§ let [#_"Expr" ___thenExpr]
                                                                                                    (try
                                                                                                        (ß Var'pushThreadBindings(RT'map(Compiler'CLEAR_PATH, PathNode'new(:PathType'PATH, ___branch))))
                                                                                                        (§ ass ___thenExpr (ß analyze(___context, RT'second(___pair))))
                                                                                                        (finally
                                                                                                            (ß Var'popThreadBindings())
                                                                                                        )
                                                                                                    )
                                                                                                    (ß ___thens.put(___minhash, ___thenExpr))
                                                                                                )
                                                                                            )
                                                                                        )
                                                                                    )
                                                                                )
                                                                            )

                                                                            (§ let [#_"Expr" ___defaultExpr]
                                                                                (try
                                                                                    (ß Var'pushThreadBindings(RT'map(Compiler'CLEAR_PATH, PathNode'new(:PathType'PATH, ___branch))))
                                                                                    (§ ass ___defaultExpr (ß analyze(___context, ___args.nth(3))))
                                                                                    (finally
                                                                                        (ß Var'popThreadBindings())
                                                                                    )
                                                                                )

                                                                                (let [#_"int" ___line (ß ((Number)Compiler'LINE.deref()).intValue())]
                                                                                    (let [#_"int" ___column (ß ((Number)Compiler'COLUMN.deref()).intValue())]
                                                                                        (CaseExpr'new ___line, ___column, ___testexpr, ___shift, ___mask, ___low, ___high, ___defaultExpr, ___tests, ___thens, ___switchType, ___testType, ___skipCheck)
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

(class-ns CaseExpr (§ implements Expr, MaybePrimitiveExpr)
    (def #_"Type" CaseExpr'NUMBER_TYPE (Type/getType Number))
    (def #_"Method" CaseExpr'intValueMethod (Method/getMethod "int intValue()"))

    (def #_"Method" CaseExpr'hashMethod (Method/getMethod "int hash(Object)"))
    (def #_"Method" CaseExpr'hashCodeMethod (Method/getMethod "int hashCode()"))
    (def #_"Method" CaseExpr'equivMethod (Method/getMethod "boolean equiv(Object, Object)"))
    (§ def #_"Keyword" CaseExpr'compactKey (Keyword'intern-2 nil, "compact"))
    (§ def #_"Keyword" CaseExpr'sparseKey (Keyword'intern-2 nil, "sparse"))
    (§ def #_"Keyword" CaseExpr'hashIdentityKey (Keyword'intern-2 nil, "hash-identity"))
    (§ def #_"Keyword" CaseExpr'hashEquivKey (Keyword'intern-2 nil, "hash-equiv"))
    (§ def #_"Keyword" CaseExpr'intKey (Keyword'intern-2 nil, "int"))

    (defn- #_"CaseExpr" CaseExpr'init []
        (hash-map
            #_"LocalBindingExpr" :expr nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"int" :low 0
            #_"int" :high 0
            #_"Expr" :defaultExpr nil
            #_"SortedMap<Integer, Expr>" :tests nil
            #_"HashMap<Integer, Expr>" :thens nil
            #_"Keyword" :switchType nil
            #_"Keyword" :testType nil
            #_"Set<Integer>" :skipCheck nil
            #_"Class" :returnType nil
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    ;; (case* expr shift mask default map<minhash, [test then]> table-type test-type skip-check?)
    (defn #_"CaseExpr" CaseExpr'new [#_"int" ___line, #_"int" ___column, #_"LocalBindingExpr" ___expr, #_"int" ___shift, #_"int" ___mask, #_"int" ___low, #_"int" ___high, #_"Expr" ___defaultExpr, #_"SortedMap<Integer, Expr>" ___tests, #_"HashMap<Integer, Expr>" ___thens, #_"Keyword" ___switchType, #_"Keyword" ___testType, #_"Set<Integer>" ___skipCheck]
        (let [this (CaseExpr'init)]
            (§ ass (:expr this) ___expr)
            (§ ass (:shift this) ___shift)
            (§ ass (:mask this) ___mask)
            (§ ass (:low this) ___low)
            (§ ass (:high this) ___high)
            (§ ass (:defaultExpr this) ___defaultExpr)
            (§ ass (:tests this) ___tests)
            (§ ass (:thens this) ___thens)
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            (when (ß ___switchType != compactKey && ___switchType != sparseKey)
                (throw (IllegalArgumentException. (str "Unexpected switch type: " ___switchType)))
            )
            (§ ass (:switchType this) ___switchType)
            (when (ß ___testType != intKey && ___testType != hashEquivKey && ___testType != hashIdentityKey)
                (throw (IllegalArgumentException. (str "Unexpected test type: " ___switchType)))
            )
            (§ ass (:testType this) ___testType)
            (§ ass (:skipCheck this) ___skipCheck)
            (let [#_"Collection<Expr>" ___returns (ArrayList. (§ pars ___thens.values()))]
                (ß ___returns.add(___defaultExpr))
                (§ ass (:returnType this) (ß maybeJavaClass(___returns)))
                (when (ß RT'count(___skipCheck) > 0 && RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                    (ß RT'errPrintWriter().format("Performance warning, %s:%d:%d - hash collision of some case test constants; if selected, those entries will be tested sequentially.\n", (§ array (ß Compiler'SOURCE_PATH.deref()), ___line, ___column)))
                )
                this
            )
        )
    )

    #_method
    (§ defn #_"boolean" hasJavaClass [#_"CaseExpr" this]
        (ß ((:returnType this) != nil))
    )

    #_method
    (§ defn #_"boolean" canEmitPrimitive [#_"CaseExpr" this]
        (Util'isPrimitive (:returnType this))
    )

    #_method
    (§ defn #_"Class" getJavaClass [#_"CaseExpr" this]
        (:returnType this)
    )

    #_method
    (§ defn #_"Object" eval [#_"CaseExpr" this]
        (throw (UnsupportedOperationException. "Can't eval case"))
    )

    #_method
    (§ defn #_"void" emit [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, false))
        nil
    )

    #_method
    (§ defn #_"void" emitUnboxed [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß doEmit(___context, ___objx, ___gen, true))
        nil
    )

    #_method
    (§ defn #_"void" doEmit [#_"CaseExpr" this, #_"Context" ___context, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"boolean" ___emitUnboxed]
        (let [#_"Label" ___defaultLabel (ß ___gen.newLabel())]
            (let [#_"Label" ___endLabel (ß ___gen.newLabel())]
                (let [#_"SortedMap<Integer, Label>" ___labels (TreeMap.)]
                    (doseq [#_"Integer" ___i (ß (:tests this).keySet())]
                        (ß ___labels.put(___i, ___gen.newLabel()))
                    )

                    (ß ___gen.visitLineNumber((:line this), ___gen.mark()))

                    (let [#_"Class" ___primExprClass (ß maybePrimitiveType((:expr this)))]
                        (let [#_"Type" ___primExprType (ß (___primExprClass == nil) ? nil :or Type/getType(___primExprClass))]
                            (if (ß (:testType this) == intKey)
                                (do
                                    (ß emitExprForInts(___objx, ___gen, ___primExprType, ___defaultLabel))
                                )
                                (do
                                    (ß emitExprForHashes(___objx, ___gen))
                                )
                            )

                            (if (ß (:switchType this) == sparseKey)
                                (do
                                    (let [#_"Label[]" ___la (make-array Label (ß ___labels.size()))]
                                        (§ ass ___la (ß ___labels.values().toArray(___la)))
                                        (let [#_"int[]" ___ints (ß Numbers'int_array-1((:tests this).keySet()))]
                                            (ß ___gen.visitLookupSwitchInsn(___defaultLabel, ___ints, ___la))
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Label[]" ___la (make-array Label (ß ((:high this) - (:low this)) + 1))]
                                        (loop-when-recur [#_"int" ___i (:low this)] (ß ___i <= (:high this)) [(inc ___i)]
                                            (§ ass (ß ___la[___i - (:low this)]) (ß ___labels.containsKey(___i) ? ___labels.get(___i) :or ___defaultLabel))
                                        )
                                        (ß ___gen.visitTableSwitchInsn((:low this), (:high this), ___defaultLabel, ___la))
                                    )
                                )
                            )

                            (doseq [#_"Integer" ___i (ß ___labels.keySet())]
                                (ß ___gen.mark(___labels.get(___i)))
                                (cond (ß (:testType this) == intKey)
                                    (do
                                        (ß emitThenForInts(___objx, ___gen, ___primExprType, (:tests this).get(___i), (:thens this).get(___i), ___defaultLabel, ___emitUnboxed))
                                    )
                                    (ß RT'contains((:skipCheck this), ___i) == RT'T)
                                    (do
                                        (ß CaseExpr'emitExpr(___objx, ___gen, (:thens this).get(___i), ___emitUnboxed))
                                    )
                                    :else
                                    (do
                                        (ß emitThenForHashes(___objx, ___gen, (:tests this).get(___i), (:thens this).get(___i), ___defaultLabel, ___emitUnboxed))
                                    )
                                )
                                (ß ___gen.goTo(___endLabel))
                            )

                            (ß ___gen.mark(___defaultLabel))
                            (CaseExpr'emitExpr ___objx, ___gen, (:defaultExpr this), ___emitUnboxed)
                            (ß ___gen.mark(___endLabel))
                            (when (ß ___context == :Context'STATEMENT)
                                (ß ___gen.pop())
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"boolean" isShiftMasked [#_"CaseExpr" this]
        (ß ((:mask this) != 0))
    )

    #_method
    (§ defn- #_"void" emitShiftMask [#_"CaseExpr" this, #_"GeneratorAdapter" ___gen]
        (when (ß isShiftMasked())
            (ß ___gen.push((:shift this)))
            (ß ___gen.visitInsn(ISHR))
            (ß ___gen.push((:mask this)))
            (ß ___gen.visitInsn(IAND))
        )
        nil
    )

    #_method
    (§ defn- #_"void" emitExprForInts [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Type" ___exprType, #_"Label" ___defaultLabel]
        (cond (nil? ___exprType)
            (do
                (when (ß RT'booleanCast-1o(RT'WARN_ON_REFLECTION.deref()))
                    (ß RT'errPrintWriter().format("Performance warning, %s:%d:%d - case has int tests, but tested expression is not primitive.\n", (§ array (ß Compiler'SOURCE_PATH.deref()), (:line this), (:column this))))
                )
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.instanceOf(CaseExpr'NUMBER_TYPE))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.checkCast(CaseExpr'NUMBER_TYPE))
                (ß ___gen.invokeVirtual(CaseExpr'NUMBER_TYPE, intValueMethod))
                (ß emitShiftMask(___gen))
            )
            (ß ___exprType == Type/LONG_TYPE || ___exprType == Type/INT_TYPE || ___exprType == Type/SHORT_TYPE || ___exprType == Type/BYTE_TYPE)
            (do
                (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.cast(___exprType, Type/INT_TYPE))
                (ß emitShiftMask(___gen))
            )
            :else
            (do
                (ß ___gen.goTo(___defaultLabel))
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" emitThenForInts [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Type" ___exprType, #_"Expr" ___test, #_"Expr" ___then, #_"Label" ___defaultLabel, #_"boolean" ___emitUnboxed]
        (cond (nil? ___exprType)
            (do
                (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___test.emit(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, equivMethod))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            (ß ___exprType == Type/LONG_TYPE)
            (do
                (ß ((NumberExpr)___test).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                (ß ___gen.ifCmp(Type/LONG_TYPE, GeneratorAdapter/NE, ___defaultLabel))
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            (ß ___exprType == Type/INT_TYPE || ___exprType == Type/SHORT_TYPE || ___exprType == Type/BYTE_TYPE)
            (do
                (when (ß isShiftMasked())
                    (ß ((NumberExpr)___test).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                    (ß (:expr this).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
                    (ß ___gen.cast(___exprType, Type/LONG_TYPE))
                    (ß ___gen.ifCmp(Type/LONG_TYPE, GeneratorAdapter/NE, ___defaultLabel))
                )
                ;; else direct match
                (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
            )
            :else
            (do
                (ß ___gen.goTo(___defaultLabel))
            )
        )
        nil
    )

    #_method
    (§ defn- #_"void" emitExprForHashes [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, hashMethod))
        (ß emitShiftMask(___gen))
        nil
    )

    #_method
    (§ defn- #_"void" emitThenForHashes [#_"CaseExpr" this, #_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___test, #_"Expr" ___then, #_"Label" ___defaultLabel, #_"boolean" ___emitUnboxed]
        (ß (:expr this).emit(:Context'EXPRESSION, ___objx, ___gen))
        (ß ___test.emit(:Context'EXPRESSION, ___objx, ___gen))
        (if (ß (:testType this) == hashIdentityKey)
            (do
                (ß ___gen.visitJumpInsn(IF_ACMPNE, ___defaultLabel))
            )
            (do
                (ß ___gen.invokeStatic(Compiler'UTIL_TYPE, equivMethod))
                (ß ___gen.ifZCmp(GeneratorAdapter/EQ, ___defaultLabel))
            )
        )
        (CaseExpr'emitExpr ___objx, ___gen, ___then, ___emitUnboxed)
        nil
    )

    (defn- #_"void" CaseExpr'emitExpr [#_"ObjExpr" ___objx, #_"GeneratorAdapter" ___gen, #_"Expr" ___expr, #_"boolean" ___emitUnboxed]
        (if (ß ___emitUnboxed && ___expr instanceof MaybePrimitiveExpr)
            (do
                (ß ((MaybePrimitiveExpr)___expr).emitUnboxed(:Context'EXPRESSION, ___objx, ___gen))
            )
            (do
                (ß ___expr.emit(:Context'EXPRESSION, ___objx, ___gen))
            )
        )
        nil
    )
)

#_stateless
(class-ns Compiler (§ implements Opcodes)
    (§ def #_"Symbol" Compiler'DEF (Symbol'intern-1 "def"))
    (§ def #_"Symbol" Compiler'LOOP (Symbol'intern-1 "loop*"))
    (§ def #_"Symbol" Compiler'RECUR (Symbol'intern-1 "recur"))
    (§ def #_"Symbol" Compiler'IF (Symbol'intern-1 "if"))
    (§ def #_"Symbol" Compiler'LET (Symbol'intern-1 "let*"))
    (§ def #_"Symbol" Compiler'LETFN (Symbol'intern-1 "letfn*"))
    (§ def #_"Symbol" Compiler'DO (Symbol'intern-1 "do"))
    (§ def #_"Symbol" Compiler'FN (Symbol'intern-1 "fn*"))
    (§ def #_"Symbol" Compiler'FNONCE (ß (Symbol) Symbol'intern-1("fn*").withMeta(RT'map(Keyword'intern-2(nil, "once"), RT'T))))
    (§ def #_"Symbol" Compiler'QUOTE (Symbol'intern-1 "quote"))
    (§ def #_"Symbol" Compiler'THE_VAR (Symbol'intern-1 "var"))
    (§ def #_"Symbol" Compiler'DOT (Symbol'intern-1 "."))
    (§ def #_"Symbol" Compiler'ASSIGN (Symbol'intern-1 "set!"))
    (§ def #_"Symbol" Compiler'TRY (Symbol'intern-1 "try"))
    (§ def #_"Symbol" Compiler'CATCH (Symbol'intern-1 "catch"))
    (§ def #_"Symbol" Compiler'FINALLY (Symbol'intern-1 "finally"))
    (§ def #_"Symbol" Compiler'THROW (Symbol'intern-1 "throw"))
    (§ def #_"Symbol" Compiler'MONITOR_ENTER (Symbol'intern-1 "monitor-enter"))
    (§ def #_"Symbol" Compiler'MONITOR_EXIT (Symbol'intern-1 "monitor-exit"))
    (§ def #_"Symbol" Compiler'IMPORT (Symbol'intern-2 "cloiure.core", "import*"))
    (§ def #_"Symbol" Compiler'DEFTYPE (Symbol'intern-1 "deftype*"))
    (§ def #_"Symbol" Compiler'CASE (Symbol'intern-1 "case*"))

    (§ def #_"Symbol" Compiler'CLASS (Symbol'intern-1 "Class"))
    (§ def #_"Symbol" Compiler'NEW (Symbol'intern-1 "new"))
    (§ def #_"Symbol" Compiler'THIS (Symbol'intern-1 "this"))
    (§ def #_"Symbol" Compiler'REIFY (Symbol'intern-1 "reify*"))
    (§ def #_"Symbol" Compiler'LIST (Symbol'intern-2 "cloiure.core", "list"))
    (§ def #_"Symbol" Compiler'HASHMAP (Symbol'intern-2 "cloiure.core", "hash-map"))
    (§ def #_"Symbol" Compiler'VECTOR (Symbol'intern-2 "cloiure.core", "vector"))
    (§ def #_"Symbol" Compiler'IDENTITY (Symbol'intern-2 "cloiure.core", "identity"))

    (§ def #_"Symbol" Compiler'_AMP_ (Symbol'intern-1 "&"))
    (§ def #_"Symbol" Compiler'ISEQ (Symbol'intern-1 "cloiure.lang.ISeq"))

    (§ def #_"Keyword" Compiler'loadNs (Keyword'intern-2 nil, "load-ns"))
    (§ def #_"Keyword" Compiler'inlineKey (Keyword'intern-2 nil, "inline"))
    (§ def #_"Keyword" Compiler'inlineAritiesKey (Keyword'intern-2 nil, "inline-arities"))
    (§ def #_"Keyword" Compiler'staticKey (Keyword'intern-2 nil, "static"))
    (§ def #_"Keyword" Compiler'arglistsKey (Keyword'intern-2 nil, "arglists"))
    (§ def #_"Symbol" Compiler'INVOKE_STATIC (Symbol'intern-1 "invokeStatic"))

    (§ def #_"Keyword" Compiler'volatileKey (Keyword'intern-2 nil, "volatile"))
    (§ def #_"Keyword" Compiler'implementsKey (Keyword'intern-2 nil, "implements"))
    (def #_"String" Compiler'COMPILE_STUB_PREFIX "compile__stub")

    (§ def #_"Keyword" Compiler'protocolKey (Keyword'intern-2 nil, "protocol"))
    (§ def #_"Keyword" Compiler'onKey (Keyword'intern-2 nil, "on"))
    (§ def #_"Keyword" Compiler'dynamicKey (Keyword'intern-1 "dynamic"))
    (§ def #_"Keyword" Compiler'redefKey (Keyword'intern-2 nil, "redef"))

    (§ def #_"Symbol" Compiler'NS (Symbol'intern-1 "ns"))
    (§ def #_"Symbol" Compiler'IN_NS (Symbol'intern-1 "in-ns"))

    (def #_"IPersistentMap" Compiler'specials (ß PersistentHashMap'create-1a(
        (§ map
            Compiler'DEF           (DefParser'new)
            Compiler'LOOP          (LetParser'new)
            Compiler'RECUR         (RecurParser'new)
            Compiler'IF            (IfParser'new)
            Compiler'CASE          (CaseParser'new)
            Compiler'LET           (LetParser'new)
            Compiler'LETFN         (LetFnParser'new)
            Compiler'DO            (BodyParser'new)
            Compiler'FN            nil
            Compiler'QUOTE         (ConstantParser'new)
            Compiler'THE_VAR       (TheVarParser'new)
            Compiler'IMPORT        (ImportParser'new)
            Compiler'DOT           (HostParser'new)
            Compiler'ASSIGN        (AssignParser'new)
            Compiler'DEFTYPE       (DeftypeParser'new)
            Compiler'REIFY         (ReifyParser'new)
            Compiler'TRY           (TryParser'new)
            Compiler'THROW         (ThrowParser'new)
            Compiler'MONITOR_ENTER (MonitorEnterParser'new)
            Compiler'MONITOR_EXIT  (MonitorExitParser'new)
            Compiler'CATCH         nil
            Compiler'FINALLY       nil
            Compiler'NEW           (NewParser'new)
            Compiler'_AMP_         nil
        )
    )))

    (def- #_"int" Compiler'MAX_POSITIONAL_ARITY 20)

    (def #_"Type" Compiler'CLASS_TYPE (Type/getType Class))
    (def #_"Type" Compiler'OBJECT_TYPE (Type/getType Object))
    (def #_"Type" Compiler'BOOLEAN_OBJECT_TYPE (Type/getType Boolean))
    (def #_"Type" Compiler'THROWABLE_TYPE (Type/getType Throwable))

    (def- #_"Type" Compiler'KEYWORD_TYPE (ß Type/getType((§ class Keyword))))
    (def- #_"Type" Compiler'VAR_TYPE (ß Type/getType((§ class Var))))
    (def- #_"Type" Compiler'SYMBOL_TYPE (ß Type/getType((§ class Symbol))))
    (def- #_"Type" Compiler'IFN_TYPE (ß Type/getType((§ class IFn))))
    (def- #_"Type" Compiler'AFUNCTION_TYPE (ß Type/getType((§ class AFunction))))
    (def- #_"Type" Compiler'RT_TYPE (ß Type/getType((§ class RT))))
    (def- #_"Type" Compiler'NUMBERS_TYPE (ß Type/getType((§ class Numbers))))

    (def #_"Type" Compiler'NS_TYPE (ß Type/getType((§ class Namespace))))
    (def #_"Type" Compiler'UTIL_TYPE (ß Type/getType((§ class Util))))
    (def #_"Type" Compiler'REFLECTOR_TYPE (ß Type/getType((§ class Reflector))))
    (def #_"Type" Compiler'IPERSISTENTMAP_TYPE (ß Type/getType((§ class IPersistentMap))))
    (def #_"Type" Compiler'IOBJ_TYPE (ß Type/getType((§ class IObj))))
    (def #_"Type" Compiler'TUPLE_TYPE (ß Type/getType((§ class Tuple))))

    (def #_"Method[]" Compiler'createTupleMethods (§ array
        (Method/getMethod "cloiure.lang.IPersistentVector create()")
        (Method/getMethod "cloiure.lang.IPersistentVector create(Object)")
        (Method/getMethod "cloiure.lang.IPersistentVector create(Object,Object)")
        (Method/getMethod "cloiure.lang.IPersistentVector create(Object,Object,Object)")
        (Method/getMethod "cloiure.lang.IPersistentVector create(Object,Object,Object,Object)")
        (Method/getMethod "cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object)")
        (Method/getMethod "cloiure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)")
    ))

    (def- #_"Type[][]" Compiler'ARG_TYPES nil)
    (def- #_"Type[]" Compiler'EXCEPTION_TYPES (§ array ))

    (§ static
        (§ ass Compiler'ARG_TYPES (ß new Type[Compiler'MAX_POSITIONAL_ARITY + 2][]))
        (loop-when-recur [#_"int" ___i 0] (ß ___i <= Compiler'MAX_POSITIONAL_ARITY) [(inc ___i)]
            (let [#_"Type[]" ___a (make-array Type ___i)]
                (loop-when-recur [#_"int" ___j 0] (< ___j ___i) [(inc ___j)]
                    (§ ass (ß ___a[___j]) Compiler'OBJECT_TYPE)
                )
                (§ ass (ß Compiler'ARG_TYPES[___i]) ___a)
            )
        )
        (let [#_"Type[]" ___a (make-array Type (ß Compiler'MAX_POSITIONAL_ARITY + 1))]
            (loop-when-recur [#_"int" ___j 0] (ß ___j < Compiler'MAX_POSITIONAL_ARITY) [(inc ___j)]
                (§ ass (ß ___a[___j]) Compiler'OBJECT_TYPE)
            )
            (§ ass (ß ___a[Compiler'MAX_POSITIONAL_ARITY]) (Type/getType "[Ljava/lang/Object;"))
            (§ ass (ß Compiler'ARG_TYPES[Compiler'MAX_POSITIONAL_ARITY + 1]) ___a)
        )
    )

    ;; symbol->localbinding
    (§ def #_"Var" Compiler'LOCAL_ENV (ß Var'create-1(nil).setDynamic()))

    ;; vector<localbinding>
    (§ def #_"Var" Compiler'LOOP_LOCALS (ß Var'create-0().setDynamic()))

    ;; Label
    (§ def #_"Var" Compiler'LOOP_LABEL (ß Var'create-0().setDynamic()))

    ;; vector<object>
    (§ def #_"Var" Compiler'CONSTANTS (ß Var'create-0().setDynamic()))

    ;; IdentityHashMap
    (§ def #_"Var" Compiler'CONSTANT_IDS (ß Var'create-0().setDynamic()))

    ;; vector<keyword>
    (§ def #_"Var" Compiler'KEYWORD_CALLSITES (ß Var'create-0().setDynamic()))

    ;; vector<var>
    (§ def #_"Var" Compiler'PROTOCOL_CALLSITES (ß Var'create-0().setDynamic()))

    ;; set<var>
    (§ def #_"Var" Compiler'VAR_CALLSITES (ß Var'create-0().setDynamic()))

    ;; keyword->constid
    (§ def #_"Var" Compiler'KEYWORDS (ß Var'create-0().setDynamic()))

    ;; var->constid
    (§ def #_"Var" Compiler'VARS (ß Var'create-0().setDynamic()))

    ;; FnFrame
    (§ def #_"Var" Compiler'METHOD (ß Var'create-1(nil).setDynamic()))

    ;; nil or not
    (§ def #_"Var" Compiler'IN_CATCH_FINALLY (ß Var'create-1(nil).setDynamic()))

    (§ def #_"Var" Compiler'METHOD_RETURN_CONTEXT (ß Var'create-1(nil).setDynamic()))

    (§ def #_"Var" Compiler'NO_RECUR (ß Var'create-1(nil).setDynamic()))

    ;; DynamicClassLoader
    (§ def #_"Var" Compiler'LOADER (ß Var'create-0().setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'SOURCE (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*source-path*"), "NO_SOURCE_FILE").setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'SOURCE_PATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*file*"), "NO_SOURCE_PATH").setDynamic()))

    ;; String
    (§ def #_"Var" Compiler'COMPILE_PATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compile-path*"), nil).setDynamic()))
    ;; boolean
    (§ def #_"Var" Compiler'COMPILE_FILES (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compile-files*"), Boolean/FALSE).setDynamic()))

    (§ def #_"Var" Compiler'INSTANCE (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("instance?"))))

    (§ def #_"Var" Compiler'ADD_ANNOTATIONS (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("add-annotations"))))

    (§ def #_"Keyword" Compiler'disableLocalsClearingKey (Keyword'intern-1 "disable-locals-clearing"))
    (§ def #_"Keyword" Compiler'directLinkingKey (Keyword'intern-1 "direct-linking"))
    (§ def #_"Keyword" Compiler'elideMetaKey (Keyword'intern-1 "elide-meta"))

    (def #_"Var" Compiler'COMPILER_OPTIONS nil)

    (defn #_"Object" Compiler'getCompilerOption [#_"Keyword" ___k]
        (ß RT'get-2(Compiler'COMPILER_OPTIONS.deref(), ___k))
    )

    (§ static
        (let [#_"Object" ___compilerOptions nil]
            (doseq [#_"Map$Entry" ___e (ß System/getProperties().entrySet())]
                (let [#_"String" ___name (ß (String) ___e.getKey())]
                    (let [#_"String" ___v (ß (String) ___e.getValue())]
                        (when (ß ___name.startsWith("cloiure.compiler."))
                            (§ ass ___compilerOptions (ß RT'assoc(___compilerOptions, RT'keyword(nil, ___name.substring(1 + ___name.lastIndexOf(\.))), RT'readString-1(___v))))
                        )
                    )
                )
            )

            (§ ass Compiler'COMPILER_OPTIONS (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*compiler-options*"), ___compilerOptions).setDynamic()))
        )
    )

    (defn #_"Object" Compiler'elideMeta [#_"Object" ___m]
        (let [#_"Collection<Object>" ___elides (ß (Collection<Object>) Compiler'getCompilerOption(elideMetaKey))]
            (when (some? ___elides)
                (doseq [#_"Object" ___k ___elides]
                    (§ ass ___m (RT'dissoc ___m, ___k))
                )
            )
            ___m
        )
    )

    ;; Integer
    (§ def #_"Var" Compiler'LINE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN (ß Var'create-1(0).setDynamic()))

    (defn #_"int" Compiler'lineDeref []
        (ß ((Number)Compiler'LINE.deref()).intValue())
    )

    (defn #_"int" Compiler'columnDeref []
        (ß ((Number)Compiler'COLUMN.deref()).intValue())
    )

    ;; Integer
    (§ def #_"Var" Compiler'LINE_BEFORE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN_BEFORE (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'LINE_AFTER (ß Var'create-1(0).setDynamic()))
    (§ def #_"Var" Compiler'COLUMN_AFTER (ß Var'create-1(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" Compiler'NEXT_LOCAL_NUM (ß Var'create-1(0).setDynamic()))

    ;; Integer
    (§ def #_"Var" Compiler'RET_LOCAL_NUM (ß Var'create-0().setDynamic()))

    (§ def #_"Var" Compiler'COMPILE_STUB_SYM (ß Var'create-1(nil).setDynamic()))
    (§ def #_"Var" Compiler'COMPILE_STUB_CLASS (ß Var'create-1(nil).setDynamic()))

    ;; PathNode chain
    (§ def #_"Var" Compiler'CLEAR_PATH (ß Var'create-1(nil).setDynamic()))

    ;; tail of PathNode chain
    (§ def #_"Var" Compiler'CLEAR_ROOT (ß Var'create-1(nil).setDynamic()))

    ;; LocalBinding -> Set<LocalBindingExpr>
    (§ def #_"Var" Compiler'CLEAR_SITES (ß Var'create-1(nil).setDynamic()))

    (def #_"Class" Compiler'RECUR_CLASS (§ class Recur))

    (defn #_"boolean" Compiler'isSpecial [#_"Object" ___sym]
        (ß specials.containsKey(___sym))
    )

    (defn #_"boolean" Compiler'inTailCall [#_"Context" ___context]
        (ß (___context == :Context'RETURN) && (Compiler'METHOD_RETURN_CONTEXT.deref() != nil) && (Compiler'IN_CATCH_FINALLY.deref() == nil))
    )

    (defn #_"Symbol" Compiler'resolveSymbol [#_"Symbol" ___sym]
        ;; already qualified or classname?
        (when (ß (:name ___sym).indexOf(\.) > 0)
            (§ return ___sym)
        )
        (when (ß (:ns ___sym) != nil)
            (let [#_"Namespace" ___ns (ß namespaceFor(___sym))]
                (when (ß ___ns == nil || (((:name ___ns).name == nil) ? ((:ns ___sym) == nil) :or (:name ___ns).name.equals((:ns ___sym))))
                    (§ return ___sym)
                )
                (§ return (ß Symbol'intern-2((:name ___ns).name, (:name ___sym))))
            )
        )
        (let [#_"Object" ___o (ß currentNS().getMapping(___sym))]
            (cond (nil? ___o)
                (do
                    (§ return (ß Symbol'intern-2(currentNS().name.name, (:name ___sym))))
                )
                (ß ___o instanceof Class)
                (do
                    (§ return (ß Symbol'intern-2(nil, ((Class) ___o).getName())))
                )
                (ß ___o instanceof Var)
                (do
                    (let [#_"Var" ___v (ß (Var) ___o)]
                        (§ return (ß Symbol'intern-2((:ns ___v).name.name, (:sym ___v).name)))
                    )
                )
            )
            nil
        )
    )

    (defn #_"Class" Compiler'maybePrimitiveType [#_"Expr" ___e]
        (when (ß ___e instanceof MaybePrimitiveExpr && ___e.hasJavaClass() && ((MaybePrimitiveExpr)___e).canEmitPrimitive())
            (let [#_"Class" ___c (ß ___e.getJavaClass())]
                (when (Util'isPrimitive ___c)
                    (§ return ___c)
                )
            )
        )
        nil
    )

    (defn #_"Class" Compiler'maybeJavaClass [#_"Collection<Expr>" ___exprs]
        (let [#_"Class" ___match nil]
            (try
                (doseq [#_"Expr" ___e ___exprs]
                    (when (ß ___e instanceof ThrowExpr)
                        (§ continue )
                    )
                    (when (ß !___e.hasJavaClass())
                        (§ return nil)
                    )
                    (let [#_"Class" ___c (ß ___e.getJavaClass())]
                        (cond (nil? ___match)
                            (do
                                (§ ass ___match ___c)
                            )
                            (ß ___match != ___c)
                            (do
                                (§ return nil)
                            )
                        )
                    )
                )
                (catch Exception ___e
                    (§ return nil)
                )
            )
            ___match
        )
    )

    (§ def #_"NilExpr" Compiler'NIL_EXPR (NilExpr'new))

    (§ def #_"BooleanExpr" Compiler'TRUE_EXPR (BooleanExpr'new true))
    (§ def #_"BooleanExpr" Compiler'FALSE_EXPR (BooleanExpr'new false))

    (defn #_"boolean" Compiler'subsumes [#_"Class[]" ___c1, #_"Class[]" ___c2]
        ;; presumes matching lengths
        (let [#_"Boolean" ___better false]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___c1.length) [(inc ___i)]
                (when (ß ___c1[___i] != ___c2[___i]) ;; || c2[i].isPrimitive() && c1[i] == Object.class
                    (if (ß !___c1[___i].isPrimitive() && ___c2[___i].isPrimitive() || ___c2[___i].isAssignableFrom(___c1[___i]))
                        (do
                            (§ ass ___better true)
                        )
                        (do
                            (§ return false)
                        )
                    )
                )
            )
            ___better
        )
    )

    (defn #_"String" Compiler'getTypeStringForArgs [#_"IPersistentVector" ___args]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___args.count()) [(inc ___i)]
                (let [#_"Expr" ___arg (ß (Expr) ___args.nth(___i))]
                    (when (> ___i 0)
                        (ß ___sb.append(", "))
                    )
                    (ß ___sb.append((___arg.hasJavaClass() && ___arg.getJavaClass() != nil) ? ___arg.getJavaClass().getName() :or "unknown"))
                )
            )
            (ß ___sb.toString())
        )
    )

    (defn #_"int" Compiler'getMatchingParams [#_"String" ___methodName, #_"ArrayList<Class[]>" ___paramlists, #_"IPersistentVector" ___argexprs, #_"List<Class>" ___rets]
        ;; presumes matching lengths
        (let [#_"int" ___matchIdx -1]
            (let [#_"boolean" ___tied false]
                (let [#_"boolean" ___foundExact false]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___paramlists.size()) [(inc ___i)]
                        (let [#_"boolean" ___match true]
                            (let [#_"ISeq" ___aseq (ß ___argexprs.seq())]
                                (let [#_"int" ___exact 0]
                                    (loop-when-recur [#_"int" ___p 0 ___aseq ___aseq] (ß ___match && ___p < ___argexprs.count() && ___aseq != nil) [(inc ___p) (ß ___aseq.next())]
                                        (let [#_"Expr" ___arg (ß (Expr) ___aseq.first())]
                                            (let [#_"Class" ___aclass (ß ___arg.hasJavaClass() ? ___arg.getJavaClass() :or (§ class Object))]
                                                (let [#_"Class" ___pclass (ß ___paramlists.get(___i)[___p])]
                                                    (if (ß ___arg.hasJavaClass() && ___aclass == ___pclass)
                                                        (do
                                                            (§ ass ___exact (inc ___exact))
                                                        )
                                                        (do
                                                            (§ ass ___match (Reflector'paramArgTypeMatch ___pclass, ___aclass))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (cond (ß ___exact == ___argexprs.count())
                                        (do
                                            (when (ß !___foundExact || ___matchIdx == -1 || ___rets.get(___matchIdx).isAssignableFrom(___rets.get(___i)))
                                                (§ ass ___matchIdx ___i)
                                            )
                                            (§ ass ___tied false)
                                            (§ ass ___foundExact true)
                                        )
                                        (ß ___match && !___foundExact)
                                        (do
                                            (if (ß ___matchIdx == -1)
                                                (do
                                                    (§ ass ___matchIdx ___i)
                                                )
                                                (do
                                                    (cond (ß subsumes(___paramlists.get(___i), ___paramlists.get(___matchIdx)))
                                                        (do
                                                            (§ ass ___matchIdx ___i)
                                                            (§ ass ___tied false)
                                                        )
                                                        (ß Arrays/equals(___paramlists.get(___matchIdx), ___paramlists.get(___i)))
                                                        (do
                                                            (when (ß ___rets.get(___matchIdx).isAssignableFrom(___rets.get(___i)))
                                                                (§ ass ___matchIdx ___i)
                                                            )
                                                        )
                                                        (ß !(subsumes(___paramlists.get(___matchIdx), ___paramlists.get(___i))))
                                                        (do
                                                            (§ ass ___tied true)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when ___tied
                        (throw (IllegalArgumentException. (str "More than one matching method found: " ___methodName)))
                    )

                    ___matchIdx
                )
            )
        )
    )

    (def #_"IPersistentMap" Compiler'CHAR_MAP (ß PersistentHashMap'create-1a(
        (§ map
            \- "_"
            \: "_COLON_"
            \+ "_PLUS_"
            \> "_GT_"
            \< "_LT_"
            \= "_EQ_"
            \~ "_TILDE_"
            \! "_BANG_"
            \@ "_CIRCA_"
            \# "_SHARP_"
            \' "_SINGLEQUOTE_"
            \" "_DOUBLEQUOTE_" ;; oops! "
            \% "_PERCENT_"
            \^ "_CARET_"
            \& "_AMPERSAND_"
            \* "_STAR_"
            \| "_BAR_"
            \{ "_LBRACE_"
            \} "_RBRACE_"
            \[ "_LBRACK_"
            \] "_RBRACK_"
            \/ "_SLASH_"
            \\ "_BSLASH_"
            \? "_QMARK_"
        )
    )))

    (def #_"IPersistentMap" Compiler'DEMUNGE_MAP nil)
    (def #_"Pattern" Compiler'DEMUNGE_PATTERN nil)

    (§ static
        ;; DEMUNGE_MAP maps strings to characters in the opposite
        ;; direction that CHAR_MAP does, plus it maps "$" to '/'
        (let [#_"IPersistentMap" ___m (ß RT'map("$", \/))]
            (loop-when-recur [#_"ISeq" ___s (RT'seq Compiler'CHAR_MAP)] (some? ___s) [(ß ___s.next())]
                (let [#_"IMapEntry" ___e (ß (IMapEntry) ___s.first())]
                    (let [#_"Character" ___origCh (ß (Character) ___e.key())]
                        (let [#_"String" ___escapeStr (ß (String) ___e.val())]
                            (§ ass ___m (ß ___m.assoc(___escapeStr, ___origCh)))
                        )
                    )
                )
            )
            (§ ass Compiler'DEMUNGE_MAP ___m)

            ;; DEMUNGE_PATTERN searches for the first of any occurrence of
            ;; the strings that are keys of DEMUNGE_MAP.
            ;; Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
            ;; returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
            ;; as desired. Sorting string keys of DEMUNGE_MAP from longest to
            ;; shortest ensures correct matching behavior, even if some strings are
            ;; prefixes of others.
            (let [#_"Object[]" ___mungeStrs (ß RT'toArray(RT'keys(___m)))]
                (ß Arrays/sort(___mungeStrs,
                        (§ reify Comparator()
                            #_method
                            (§ defn #_"int" compare [#_"Comparator" this, #_"Object" ___s1, #_"Object" ___s2]
                                (ß ((String) ___s2).length() - ((String) ___s1).length())
                            )
                        )
                    )
                )
                (let [#_"StringBuilder" ___sb (StringBuilder.)]
                    (let [#_"boolean" ___first true]
                        (doseq [#_"Object" ___s ___mungeStrs]
                            (let [#_"String" ___escapeStr (ß (String) ___s)]
                                (when (ß !___first)
                                    (ß ___sb.append("|"))
                                )
                                (§ ass ___first false)
                                (ß ___sb.append("\\Q"))
                                (ß ___sb.append(___escapeStr))
                                (ß ___sb.append("\\E"))
                            )
                        )
                        (§ ass Compiler'DEMUNGE_PATTERN (ß Pattern/compile(___sb.toString())))
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'munge [#_"String" ___name]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (doseq [#_"char" ___c (ß ___name.toCharArray())]
                (let [#_"String" ___sub (ß (String) Compiler'CHAR_MAP.valAt(___c))]
                    (if (some? ___sub)
                        (do
                            (ß ___sb.append(___sub))
                        )
                        (do
                            (ß ___sb.append(___c))
                        )
                    )
                )
            )
            (ß ___sb.toString())
        )
    )

    (defn #_"String" Compiler'demunge [#_"String" ___mungedName]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Matcher" ___m (ß Compiler'DEMUNGE_PATTERN.matcher(___mungedName))]
                (let [#_"int" ___lastMatchEnd 0]
                    (while (ß ___m.find())
                        (let [#_"int" ___start (ß ___m.start())]
                            (let [#_"int" ___end (ß ___m.end())]
                                ;; Keep everything before the match
                                (ß ___sb.append(___mungedName.substring(___lastMatchEnd, ___start)))
                                (§ ass ___lastMatchEnd ___end)
                                ;; Replace the match with DEMUNGE_MAP result
                                (let [#_"Character" ___origCh (ß (Character) Compiler'DEMUNGE_MAP.valAt(___m.group()))]
                                    (ß ___sb.append(___origCh))
                                )
                            )
                        )
                    )
                    ;; Keep everything after the last match
                    (ß ___sb.append(___mungedName.substring(___lastMatchEnd)))
                    (ß ___sb.toString())
                )
            )
        )
    )

    (defn #_"PathNode" Compiler'clearPathRoot []
        (ß (PathNode) Compiler'CLEAR_ROOT.get())
    )

    (defn- #_"LocalBinding" Compiler'registerLocal [#_"Symbol" ___sym, #_"Symbol" ___tag, #_"Expr" ___init, #_"boolean" ___isArg]
        (let [#_"int" ___num (ß getAndIncLocalNum())]
            (let [#_"LocalBinding" ___b (ß LocalBinding'new(___num, ___sym, ___tag, ___init, ___isArg, clearPathRoot()))]
                (let [#_"IPersistentMap" ___localsMap (ß (IPersistentMap) Compiler'LOCAL_ENV.deref())]
                    (ß Compiler'LOCAL_ENV.set(RT'assoc(___localsMap, (:sym ___b), ___b)))
                    (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                        (§ ass (:locals ___method) (ß (IPersistentMap) RT'assoc((:locals ___method), ___b, ___b)))
                        (§ ass (:indexlocals ___method) (ß (IPersistentMap) RT'assoc((:indexlocals ___method), ___num, ___b)))
                        ___b
                    )
                )
            )
        )
    )

    (defn- #_"int" Compiler'getAndIncLocalNum []
        (let [#_"int" ___num (ß ((Number) Compiler'NEXT_LOCAL_NUM.deref()).intValue())]
            (let [#_"ObjMethod" ___m (ß (ObjMethod) Compiler'METHOD.deref())]
                (when (ß ___num > (:maxLocal ___m))
                    (§ ass (:maxLocal ___m) ___num)
                )
                (ß Compiler'NEXT_LOCAL_NUM.set(___num + 1))
                ___num
            )
        )
    )

    (defn #_"Expr" Compiler'analyze-2 [#_"Context" ___context, #_"Object" ___form]
        (ß analyze(___context, ___form, nil))
    )

    (defn- #_"Expr" Compiler'analyze-3 [#_"Context" ___context, #_"Object" ___form, #_"String" ___name]
        ;; todo symbol macro expansion?
        (try
            (when (ß ___form instanceof LazySeq)
                (let [#_"Object" ___mform ___form]
                    (§ ass ___form (RT'seq ___form))
                    (when (nil? ___form)
                        (§ ass ___form PersistentList'EMPTY)
                    )
                    (§ ass ___form (ß ((IObj)___form).withMeta(RT'meta(___mform))))
                )
            )
            (cond (nil? ___form)
                (do
                    (§ return Compiler'NIL_EXPR)
                )
                (ß ___form == Boolean/TRUE)
                (do
                    (§ return Compiler'TRUE_EXPR)
                )
                (ß ___form == Boolean/FALSE)
                (do
                    (§ return Compiler'FALSE_EXPR)
                )
            )
            (let [#_"Class" ___fclass (ß ___form.getClass())]
                (cond (ß ___fclass == (§ class Symbol))
                    (do
                        (§ return (ß analyzeSymbol((Symbol) ___form)))
                    )
                    (ß ___fclass == (§ class Keyword))
                    (do
                        (§ return (ß registerKeyword((Keyword) ___form)))
                    )
                    (ß ___form instanceof Number)
                    (do
                        (§ return (ß NumberExpr'parse((Number) ___form)))
                    )
                    (ß ___fclass == (§ class String))
                    (do
                        (§ return (ß StringExpr'new(((String) ___form).intern())))
                    )
                    (ß ___form instanceof IPersistentCollection && !(___form instanceof IRecord) && !(___form instanceof IType) && ((IPersistentCollection) ___form).count() == 0)
                    (do
                        (let [#_"Expr" ___ret (EmptyExpr'new ___form)]
                            (when (ß RT'meta(___form) != nil)
                                (§ ass ___ret (ß MetaExpr'new(___ret, MapExpr'parse((___context == :Context'EVAL) ? ___context :or :Context'EXPRESSION, ((IObj) ___form).meta()))))
                            )
                            (§ return ___ret)
                        )
                    )
                    (ß ___form instanceof ISeq)
                    (do
                        (§ return (ß analyzeSeq(___context, (ISeq) ___form, ___name)))
                    )
                    (ß ___form instanceof IPersistentVector)
                    (do
                        (§ return (ß VectorExpr'parse(___context, (IPersistentVector) ___form)))
                    )
                    (ß ___form instanceof IRecord)
                    (do
                        (§ return (ConstantExpr'new ___form))
                    )
                    (ß ___form instanceof IType)
                    (do
                        (§ return (ConstantExpr'new ___form))
                    )
                    (ß ___form instanceof IPersistentMap)
                    (do
                        (§ return (ß MapExpr'parse(___context, (IPersistentMap) ___form)))
                    )
                    (ß ___form instanceof IPersistentSet)
                    (do
                        (§ return (ß SetExpr'parse(___context, (IPersistentSet) ___form)))
                    )
                )

                (ConstantExpr'new ___form)
            )
            (catch Throwable ___e
                (if (ß !(___e instanceof CompilerException))
                    (do
                        (throw (ß CompilerException'new((String) Compiler'SOURCE_PATH.deref(), lineDeref(), columnDeref(), ___e)))
                    )
                    (do
                        (throw (ß (CompilerException) ___e))
                    )
                )
            )
        )
    )

    (defn #_"Var" Compiler'isMacro [#_"Object" ___op]
        ;; no local macros for now
        (when (ß ___op instanceof Symbol && referenceLocal((Symbol) ___op) != nil)
            (§ return nil)
        )
        (when (ß ___op instanceof Symbol || ___op instanceof Var)
            (let [#_"Var" ___v (ß (___op instanceof Var) ? (Var) ___op :or lookupVar((Symbol) ___op, false, false))]
                (when (ß ___v != nil && ___v.isMacro())
                    (when (ß (:ns ___v) != currentNS() && !___v.isPublic())
                        (throw (IllegalStateException. (str "var: " ___v " is not public")))
                    )
                    (§ return ___v)
                )
            )
        )
        nil
    )

    (defn #_"IFn" Compiler'isInline [#_"Object" ___op, #_"int" ___arity]
        ;; no local inlines for now
        (when (ß ___op instanceof Symbol && referenceLocal((Symbol) ___op) != nil)
            (§ return nil)
        )
        (when (ß ___op instanceof Symbol || ___op instanceof Var)
            (let [#_"Var" ___v (ß (___op instanceof Var) ? (Var) ___op :or lookupVar((Symbol) ___op, false))]
                (when (some? ___v)
                    (when (ß (:ns ___v) != currentNS() && !___v.isPublic())
                        (throw (IllegalStateException. (str "var: " ___v " is not public")))
                    )
                    (let [#_"IFn" ___ret (ß (IFn) RT'get-2(___v.meta(), inlineKey))]
                        (when (some? ___ret)
                            (let [#_"IFn" ___arityPred (ß (IFn) RT'get-2(___v.meta(), inlineAritiesKey))]
                                (when (ß ___arityPred == nil || RT'booleanCast-1o(___arityPred.invoke(___arity)))
                                    (§ return ___ret)
                                )
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"boolean" Compiler'namesStaticMember [#_"Symbol" ___sym]
        (ß ((:ns ___sym) != nil && namespaceFor(___sym) == nil))
    )

    (defn #_"Object" Compiler'preserveTag [#_"ISeq" ___src, #_"Object" ___dst]
        (let [#_"Symbol" ___tag (ß tagOf(___src))]
            (when (ß ___tag != nil && ___dst instanceof IObj)
                (let [#_"IPersistentMap" ___meta (RT'meta ___dst)]
                    (§ return (ß ((IObj) ___dst).withMeta((IPersistentMap) RT'assoc(___meta, RT'TAG_KEY, ___tag))))
                )
            )
            ___dst
        )
    )

    #_volatile
    (def- #_"Var" Compiler'MACRO_CHECK nil)
    #_volatile
    (def- #_"boolean" Compiler'MACRO_CHECK_LOADING false)
    (def- #_"Object" Compiler'MACRO_CHECK_LOCK (Object.))

    (defn- #_"Var" Compiler'ensureMacroCheck [] #_(§ throws ClassNotFoundException, IOException)
        (when (nil? Compiler'MACRO_CHECK)
            (§ sync Compiler'MACRO_CHECK_LOCK
                (when (nil? Compiler'MACRO_CHECK)
                    (§ ass Compiler'MACRO_CHECK_LOADING true)
                    (RT'load-1 "cloiure/spec/alpha")
                    (RT'load-1 "cloiure/core/specs/alpha")
                    (§ ass Compiler'MACRO_CHECK (ß Var'find(Symbol'intern-2("cloiure.spec.alpha", "macroexpand-check"))))
                    (§ ass Compiler'MACRO_CHECK_LOADING false)
                )
            )
        )
        Compiler'MACRO_CHECK
    )

    (defn #_"void" Compiler'checkSpecs [#_"Var" ___v, #_"ISeq" ___form]
        (when (ß RT'CHECK_SPECS && !Compiler'MACRO_CHECK_LOADING)
            (try
                (ß ensureMacroCheck().applyTo(RT'cons(___v, RT'list-1(___form.next()))))
                (catch Exception ___e
                    (throw (ß CompilerException'new((String) Compiler'SOURCE_PATH.deref(), lineDeref(), columnDeref(), ___e)))
                )
            )
        )
        nil
    )

    (defn #_"Object" Compiler'macroexpand1 [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (let [#_"ISeq" ___form (ß (ISeq) ___x)]
                (let [#_"Object" ___op (RT'first ___form)]
                    (when (ß isSpecial(___op))
                        (§ return ___x)
                    )
                    ;; macro expansion
                    (let [#_"Var" ___v (ß isMacro(___op))]
                        (if (some? ___v)
                            (do
                                (ß checkSpecs(___v, ___form))

                                (try
                                    (let [#_"ISeq" ___args (ß RT'cons(___form, RT'cons(Compiler'LOCAL_ENV.get(), ___form.next())))]
                                        (§ return (ß ___v.applyTo(___args)))
                                    )
                                    (§ catch ArityException ___e
                                        ;; hide the 2 extra params for a macro
                                        (throw (ß ArityException'new-2((:actual ___e) - 2, (:name ___e))))
                                    )
                                )
                            )
                            (do
                                (when (ß ___op instanceof Symbol)
                                    (let [#_"Symbol" ___sym (ß (Symbol) ___op)]
                                        (let [#_"String" ___sname (:name ___sym)]
                                            ;; (.substring s 2 5) => (. s substring 2 5)
                                            (cond (ß (:name ___sym).charAt(0) == \.)
                                                (do
                                                    (when (ß RT'length(___form) < 2)
                                                        (throw (IllegalArgumentException. "Malformed member expression, expecting (.member target ...)"))
                                                    )
                                                    (let [#_"Symbol" ___meth (ß Symbol'intern-1(___sname.substring(1)))]
                                                        (let [#_"Object" ___target (RT'second ___form)]
                                                            (when (ß HostExpr'maybeClass(___target, false) != nil)
                                                                (§ ass ___target (ß ((IObj)RT'list-2(Compiler'IDENTITY, ___target)).withMeta(RT'map(RT'TAG_KEY, Compiler'CLASS))))
                                                            )
                                                            (§ return (ß preserveTag(___form, RT'listStar-4(Compiler'DOT, ___target, ___meth, ___form.next().next()))))
                                                        )
                                                    )
                                                )
                                                (ß namesStaticMember(___sym))
                                                (do
                                                    (let [#_"Symbol" ___target (ß Symbol'intern-1((:ns ___sym)))]
                                                        (let [#_"Class" ___c (HostExpr'maybeClass ___target, false)]
                                                            (when (some? ___c)
                                                                (let [#_"Symbol" ___meth (ß Symbol'intern-1((:name ___sym)))]
                                                                    (§ return (ß preserveTag(___form, RT'listStar-4(Compiler'DOT, ___target, ___meth, ___form.next()))))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                :else
                                                (do
                                                    ;; (s.substring 2 5) => (. s substring 2 5)
                                                    ;; also (package.class.name ...) (. package.class name ...)
                                                    (let [#_"int" ___idx (ß ___sname.lastIndexOf(\.))]
                                                        ;; (StringBuilder. "foo") => (new StringBuilder "foo")
                                                        (when (ß ___idx == ___sname.length() - 1)
                                                            (§ return (ß RT'listStar-3(Compiler'NEW, Symbol'intern-1(___sname.substring(0, ___idx)), ___form.next())))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        ___x
    )

    (defn #_"Object" Compiler'macroexpand [#_"Object" ___form]
        (let [#_"Object" ___exf (ß macroexpand1(___form))]
            (when (ß ___exf != ___form)
                (§ return (ß macroexpand(___exf)))
            )
            ___form
        )
    )

    (defn- #_"Expr" Compiler'analyzeSeq [#_"Context" ___context, #_"ISeq" ___form, #_"String" ___name]
        (let [#_"Object" ___line (ß lineDeref())]
            (let [#_"Object" ___column (ß columnDeref())]
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                    (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                )
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                    (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                )
                (ß Var'pushThreadBindings(RT'map(Compiler'LINE, ___line, Compiler'COLUMN, ___column)))
                (try
                    (let [#_"Object" ___me (ß macroexpand1(___form))]
                        (when (ß ___me != ___form)
                            (§ return (ß analyze(___context, ___me, ___name)))
                        )

                        (let [#_"Object" ___op (RT'first ___form)]
                            (when (nil? ___op)
                                (throw (IllegalArgumentException. (str "Can't call nil, form: " ___form)))
                            )
                            (let [#_"IFn" ___inline (ß isInline(___op, RT'count(RT'next(___form))))]
                                (when (some? ___inline)
                                    (§ return (ß analyze(___context, preserveTag(___form, ___inline.applyTo(RT'next(___form))))))
                                )
                                (§ let [#_"IParser" ___p]
                                    (cond (ß ___op.equals(Compiler'FN))
                                        (do
                                            (FnExpr'parse ___context, ___form, ___name)
                                        )
                                        (some? (§ ass ___p (ß (IParser) specials.valAt(___op))))
                                        (do
                                            (ß ___p.parse(___context, ___form))
                                        )
                                        :else
                                        (do
                                            (InvokeExpr'parse ___context, ___form)
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (catch Throwable ___e
                        (if (ß !(___e instanceof CompilerException))
                            (do
                                (throw (ß CompilerException'new((String) Compiler'SOURCE_PATH.deref(), lineDeref(), columnDeref(), ___e)))
                            )
                            (do
                                (throw (ß (CompilerException) ___e))
                            )
                        )
                    )
                    (finally
                        (ß Var'popThreadBindings())
                    )
                )
            )
        )
    )

    (defn #_"String" Compiler'errorMsg [#_"String" ___source, #_"int" ___line, #_"int" ___column, #_"String" ___s]
        (String/format "%s, compiling:(%s:%d:%d)", (§ array ___s, ___source, ___line, ___column))
    )

    (defn #_"Object" Compiler'eval-1 [#_"Object" ___form]
        (ß eval(___form, true))
    )

    (defn #_"Object" Compiler'eval-2 [#_"Object" ___form, #_"boolean" ___freshLoader]
        (let [#_"boolean" ___createdLoader false]
            (when true ;; !LOADER.isBound()
                (ß Var'pushThreadBindings(RT'map(Compiler'LOADER, RT'makeClassLoader())))
                (§ ass ___createdLoader true)
            )
            (try
                (let [#_"Object" ___line (ß lineDeref())]
                    (let [#_"Object" ___column (ß columnDeref())]
                        (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                            (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                        )
                        (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                            (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                        )
                        (ß Var'pushThreadBindings(RT'map(Compiler'LINE, ___line, Compiler'COLUMN, ___column)))
                        (try
                            (§ ass ___form (ß macroexpand(___form)))
                            (cond (ß ___form instanceof ISeq && Util'equals(RT'first(___form), Compiler'DO))
                                (do
                                    (let [#_"ISeq" ___s (RT'next ___form)]
                                        (loop-when-recur [___s ___s] (ß RT'next(___s) != nil) [(RT'next ___s)]
                                            (ß eval(RT'first(___s), false))
                                        )
                                        (ß eval(RT'first(___s), false))
                                    )
                                )
                                (ß (___form instanceof IType) || (___form instanceof IPersistentCollection && !(RT'first(___form) instanceof Symbol && ((Symbol) RT'first(___form)).name.startsWith("def"))))
                                (do
                                    (let [#_"ObjExpr" ___fexpr (ß (ObjExpr) analyze(:Context'EXPRESSION, RT'list-3(Compiler'FN, PersistentVector'EMPTY, ___form), "eval" + RT'nextID()))]
                                        (let [#_"IFn" ___fn (ß (IFn) ___fexpr.eval())]
                                            (ß ___fn.invoke())
                                        )
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Expr" ___expr (ß analyze(:Context'EVAL, ___form))]
                                        (ß ___expr.eval())
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                    )
                )
                (finally
                    (when ___createdLoader
                        (ß Var'popThreadBindings())
                    )
                )
            )
        )
    )

    (defn- #_"int" Compiler'registerConstant [#_"Object" ___o]
        (when (ß !Compiler'CONSTANTS.isBound())
            (§ return -1)
        )
        (let [#_"PersistentVector" ___v (ß (PersistentVector) Compiler'CONSTANTS.deref())]
            (let [#_"IdentityHashMap<Object, Integer>" ___ids (ß (IdentityHashMap<Object, Integer>) Compiler'CONSTANT_IDS.deref())]
                (let [#_"Integer" ___i (ß ___ids.get(___o))]
                    (when (some? ___i)
                        (§ return ___i)
                    )
                    (ß Compiler'CONSTANTS.set(RT'conj(___v, ___o)))
                    (ß ___ids.put(___o, ___v.count()))
                    (ß ___v.count())
                )
            )
        )
    )

    (defn- #_"KeywordExpr" Compiler'registerKeyword [#_"Keyword" ___keyword]
        (when (ß !Compiler'KEYWORDS.isBound())
            (§ return (KeywordExpr'new ___keyword))
        )

        (let [#_"IPersistentMap" ___keywordsMap (ß (IPersistentMap) Compiler'KEYWORDS.deref())]
            (let [#_"Object" ___id (RT'get-2 ___keywordsMap, ___keyword)]
                (when (nil? ___id)
                    (ß Compiler'KEYWORDS.set(RT'assoc(___keywordsMap, ___keyword, registerConstant(___keyword))))
                )
                (KeywordExpr'new ___keyword)
            )
        )
    )

    (defn- #_"int" Compiler'registerKeywordCallsite [#_"Keyword" ___keyword]
        (when (ß !Compiler'KEYWORD_CALLSITES.isBound())
            (throw (IllegalAccessError. "KEYWORD_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" ___keywordCallsites (ß (IPersistentVector) Compiler'KEYWORD_CALLSITES.deref())]
            (§ ass ___keywordCallsites (ß ___keywordCallsites.cons(___keyword)))
            (ß Compiler'KEYWORD_CALLSITES.set(___keywordCallsites))
            (ß ___keywordCallsites.count() - 1)
        )
    )

    (defn- #_"int" Compiler'registerProtocolCallsite [#_"Var" ___v]
        (when (ß !Compiler'PROTOCOL_CALLSITES.isBound())
            (throw (IllegalAccessError. "PROTOCOL_CALLSITES is not bound"))
        )

        (let [#_"IPersistentVector" ___protocolCallsites (ß (IPersistentVector) Compiler'PROTOCOL_CALLSITES.deref())]
            (§ ass ___protocolCallsites (ß ___protocolCallsites.cons(___v)))
            (ß Compiler'PROTOCOL_CALLSITES.set(___protocolCallsites))
            (ß ___protocolCallsites.count() - 1)
        )
    )

    (defn- #_"void" Compiler'registerVarCallsite [#_"Var" ___v]
        (when (ß !Compiler'VAR_CALLSITES.isBound())
            (throw (IllegalAccessError. "VAR_CALLSITES is not bound"))
        )

        (let [#_"IPersistentCollection" ___varCallsites (ß (IPersistentCollection) Compiler'VAR_CALLSITES.deref())]
            (§ ass ___varCallsites (ß ___varCallsites.cons(___v)))
            (ß Compiler'VAR_CALLSITES.set(___varCallsites))
            nil
        )
    )

    (defn #_"ISeq" Compiler'fwdPath [#_"PathNode" ___p1]
        (let [#_"ISeq" ___ret nil]
            (loop-when-recur [___p1 ___p1] (some? ___p1) [(:parent ___p1)]
                (§ ass ___ret (RT'cons ___p1, ___ret))
            )
            ___ret
        )
    )

    (defn #_"PathNode" Compiler'commonPath [#_"PathNode" ___n1, #_"PathNode" ___n2]
        (let [#_"ISeq" ___xp (ß fwdPath(___n1))]
            (let [#_"ISeq" ___yp (ß fwdPath(___n2))]
                (when (ß RT'first(___xp) != RT'first(___yp))
                    (§ return nil)
                )
                (while (ß RT'second(___xp) != nil && RT'second(___xp) == RT'second(___yp))
                    (§ ass ___xp (ß ___xp.next()))
                    (§ ass ___yp (ß ___yp.next()))
                )
                (ß (PathNode) RT'first(___xp))
            )
        )
    )

    (defn #_"void" Compiler'addAnnotation [#_"Object" ___visitor, #_"IPersistentMap" ___meta]
        (when (ß ___meta != nil && Compiler'ADD_ANNOTATIONS.isBound())
            (ß Compiler'ADD_ANNOTATIONS.invoke(___visitor, ___meta))
        )
        nil
    )

    (defn #_"void" Compiler'addParameterAnnotation [#_"Object" ___visitor, #_"IPersistentMap" ___meta, #_"int" ___i]
        (when (ß ___meta != nil && Compiler'ADD_ANNOTATIONS.isBound())
            (ß Compiler'ADD_ANNOTATIONS.invoke(___visitor, ___meta, ___i))
        )
        nil
    )

    (defn- #_"Expr" Compiler'analyzeSymbol [#_"Symbol" ___sym]
        (let [#_"Symbol" ___tag (ß tagOf(___sym))]
            (cond (ß (:ns ___sym) == nil) ;; ns-qualified syms are always Vars
                (do
                    (let [#_"LocalBinding" ___b (ß referenceLocal(___sym))]
                        (when (some? ___b)
                            (§ return (LocalBindingExpr'new ___b, ___tag))
                        )
                    )
                )
                (ß namespaceFor(___sym) == nil)
                (do
                    (let [#_"Symbol" ___nsSym (ß Symbol'intern-1((:ns ___sym)))]
                        (let [#_"Class" ___c (HostExpr'maybeClass ___nsSym, false)]
                            (when (some? ___c)
                                (when (ß Reflector'getField(___c, (:name ___sym), true) != nil)
                                    (§ return (ß StaticFieldExpr'new(lineDeref(), columnDeref(), ___c, (:name ___sym), ___tag)))
                                )
                                (throw (Util'runtimeException-1 (str "Unable to find static field: " (:name ___sym) " in " ___c)))
                            )
                        )
                    )
                )
            )
            (let [#_"Object" ___o (ß resolve(___sym))]
                (cond (ß ___o instanceof Var)
                    (do
                        (let [#_"Var" ___v (ß (Var) ___o)]
                            (when (ß isMacro(___v) != nil)
                                (throw (Util'runtimeException-1 (str "Can't take value of a macro: " ___v)))
                            )
                            (when (ß RT'booleanCast-1o(RT'get-2(___v.meta(), RT'CONST_KEY)))
                                (§ return (ß analyze(:Context'EXPRESSION, RT'list-2(Compiler'QUOTE, ___v.get()))))
                            )
                            (ß registerVar(___v))
                            (§ return (VarExpr'new ___v, ___tag))
                        )
                    )
                    (ß ___o instanceof Class)
                    (do
                        (§ return (ConstantExpr'new ___o))
                    )
                    (ß ___o instanceof Symbol)
                    (do
                        (§ return (ß UnresolvedVarExpr'new((Symbol) ___o)))
                    )
                )

                (throw (Util'runtimeException-1 (str "Unable to resolve symbol: " ___sym " in this context")))
            )
        )
    )

    (defn #_"String" Compiler'destubClassName [#_"String" ___className]
        ;; skip over prefix + '.' or '/'
        (when (ß ___className.startsWith(Compiler'COMPILE_STUB_PREFIX))
            (§ return (ß ___className.substring(Compiler'COMPILE_STUB_PREFIX.length() + 1)))
        )
        ___className
    )

    (defn #_"Type" Compiler'getType [#_"Class" ___c]
        (let [#_"String" ___descriptor (ß Type/getType(___c).getDescriptor())]
            (when (ß ___descriptor.startsWith("L"))
                (§ ass ___descriptor (ß "L" + destubClassName(___descriptor.substring(1))))
            )
            (§ unsure Type/getType ___descriptor)
        )
    )

    (defn #_"Object" Compiler'resolve-2 [#_"Symbol" ___sym, #_"boolean" ___allowPrivate]
        (ß resolveIn(currentNS(), ___sym, ___allowPrivate))
    )

    (defn #_"Object" Compiler'resolve-1 [#_"Symbol" ___sym]
        (ß resolveIn(currentNS(), ___sym, false))
    )

    (defn #_"Namespace" Compiler'namespaceFor-1 [#_"Symbol" ___sym]
        (ß namespaceFor(currentNS(), ___sym))
    )

    (defn #_"Namespace" Compiler'namespaceFor-2 [#_"Namespace" ___inns, #_"Symbol" ___sym]
        ;; note, presumes non-nil sym.ns
        ;; first check against currentNS' aliases...
        (let [#_"Symbol" ___nsSym (ß Symbol'intern-1((:ns ___sym)))]
            (let [#_"Namespace" ___ns (ß ___inns.lookupAlias(___nsSym))]
                (when (nil? ___ns)
                    ;; ...otherwise check the Namespaces map.
                    (§ ass ___ns (Namespace'find ___nsSym))
                )
                ___ns
            )
        )
    )

    (defn #_"Object" Compiler'resolveIn [#_"Namespace" ___n, #_"Symbol" ___sym, #_"boolean" ___allowPrivate]
        ;; note - ns-qualified vars must already exist
        (cond (ß (:ns ___sym) != nil)
            (do
                (let [#_"Namespace" ___ns (ß namespaceFor(___n, ___sym))]
                    (when (nil? ___ns)
                        (throw (Util'runtimeException-1 (str "No such namespace: " (:ns ___sym))))
                    )

                    (let [#_"Var" ___v (ß ___ns.findInternedVar(Symbol'intern-1((:name ___sym))))]
                        (cond (nil? ___v)
                            (do
                                (throw (Util'runtimeException-1 (str "No such var: " ___sym)))
                            )
                            (ß (:ns ___v) != currentNS() && !___v.isPublic() && !___allowPrivate)
                            (do
                                (throw (IllegalStateException. (str "var: " ___sym " is not public")))
                            )
                        )
                        ___v
                    )
                )
            )
            (ß (:name ___sym).indexOf(\.) > 0 || (:name ___sym).charAt(0) == \[)
            (do
                (ß RT'classForName-1((:name ___sym)))
            )
            (ß ___sym.equals(Compiler'NS))
            (do
                RT'NS_VAR
            )
            (ß ___sym.equals(Compiler'IN_NS))
            (do
                RT'IN_NS_VAR
            )
            :else
            (do
                (when (ß Util'equals(___sym, Compiler'COMPILE_STUB_SYM.get()))
                    (§ return (ß Compiler'COMPILE_STUB_CLASS.get()))
                )
                (let [#_"Object" ___o (ß ___n.getMapping(___sym))]
                    (when (nil? ___o)
                        (if (ß RT'booleanCast-1o(RT'ALLOW_UNRESOLVED_VARS.deref()))
                            (do
                                (§ return ___sym)
                            )
                            (do
                                (throw (Util'runtimeException-1 (str "Unable to resolve symbol: " ___sym " in this context")))
                            )
                        )
                    )
                    ___o
                )
            )
        )
    )

    (defn #_"Object" Compiler'maybeResolveIn [#_"Namespace" ___n, #_"Symbol" ___sym]
        ;; note - ns-qualified vars must already exist
        (cond (ß (:ns ___sym) != nil)
            (do
                (let [#_"Namespace" ___ns (ß namespaceFor(___n, ___sym))]
                    (when (nil? ___ns)
                        (§ return nil)
                    )
                    (let [#_"Var" ___v (ß ___ns.findInternedVar(Symbol'intern-1((:name ___sym))))]
                        (when (nil? ___v)
                            (§ return nil)
                        )
                        ___v
                    )
                )
            )
            (ß (:name ___sym).indexOf(\.) > 0 && !___sym.name.endsWith(".") || (:name ___sym).charAt(0) == \[)
            (do
                (ß RT'classForName-1((:name ___sym)))
            )
            (ß ___sym.equals(Compiler'NS))
            (do
                RT'NS_VAR
            )
            (ß ___sym.equals(Compiler'IN_NS))
            (do
                RT'IN_NS_VAR
            )
            :else
            (do
                (let [#_"Object" ___o (ß ___n.getMapping(___sym))]
                    ___o
                )
            )
        )
    )

    (defn #_"Var" Compiler'lookupVar-3 [#_"Symbol" ___sym, #_"boolean" ___internNew, #_"boolean" ___registerMacro]
        (let [#_"Var" ___var nil]
            ;; note - ns-qualified vars in other namespaces must already exist
            (cond (ß (:ns ___sym) != nil)
                (do
                    (let [#_"Namespace" ___ns (ß namespaceFor(___sym))]
                        (when (nil? ___ns)
                            (§ return nil)
                        )
                        (let [#_"Symbol" ___name (ß Symbol'intern-1((:name ___sym)))]
                            (if (ß ___internNew && ___ns == currentNS())
                                (do
                                    (§ ass ___var (ß currentNS().intern(___name)))
                                )
                                (do
                                    (§ ass ___var (ß ___ns.findInternedVar(___name)))
                                )
                            )
                        )
                    )
                )
                (ß ___sym.equals(Compiler'NS))
                (do
                    (§ ass ___var RT'NS_VAR)
                )
                (ß ___sym.equals(Compiler'IN_NS))
                (do
                    (§ ass ___var RT'IN_NS_VAR)
                )
                :else
                (do
                    ;; is it mapped?
                    (let [#_"Object" ___o (ß currentNS().getMapping(___sym))]
                        (cond (nil? ___o)
                            (do
                                ;; introduce a new var in the current ns
                                (when ___internNew
                                    (§ ass ___var (ß currentNS().intern(Symbol'intern-1((:name ___sym)))))
                                )
                            )
                            (ß ___o instanceof Var)
                            (do
                                (§ ass ___var (ß (Var) ___o))
                            )
                            :else
                            (do
                                (throw (Util'runtimeException-1 (str "Expecting var, but " ___sym " is mapped to " ___o)))
                            )
                        )
                    )
                )
            )
            (when (ß ___var != nil && (!___var.isMacro() || ___registerMacro))
                (ß registerVar(___var))
            )
            ___var
        )
    )

    (defn #_"Var" Compiler'lookupVar-2 [#_"Symbol" ___sym, #_"boolean" ___internNew]
        (ß lookupVar(___sym, ___internNew, true))
    )

    (defn- #_"void" Compiler'registerVar [#_"Var" ___var]
        (when (ß !Compiler'VARS.isBound())
            (§ return nil)
        )
        (let [#_"IPersistentMap" ___varsMap (ß (IPersistentMap) Compiler'VARS.deref())]
            (let [#_"Object" ___id (RT'get-2 ___varsMap, ___var)]
                (when (nil? ___id)
                    (ß Compiler'VARS.set(RT'assoc(___varsMap, ___var, registerConstant(___var))))
                )
                nil
            )
        )
    )

    (defn #_"Namespace" Compiler'currentNS []
        (ß (Namespace) RT'CURRENT_NS.deref())
    )

    (defn #_"void" Compiler'closeOver [#_"LocalBinding" ___b, #_"ObjMethod" ___method]
        (when (ß ___b != nil && ___method != nil)
            (let [#_"LocalBinding" ___lb (ß (LocalBinding) RT'get-2((:locals ___method), ___b))]
                (if (nil? ___lb)
                    (do
                        (§ ass (ß (:objx ___method).closes) (ß (IPersistentMap) RT'assoc((:objx ___method).closes, ___b, ___b)))
                        (ß closeOver(___b, (:parent ___method)))
                    )
                    (do
                        (when (ß (:idx ___lb) == 0)
                            (§ ass (:usesThis ___method) true)
                        )
                        (when (ß Compiler'IN_CATCH_FINALLY.deref() != nil)
                            (§ ass (:localsUsedInCatchFinally ___method) (ß (PersistentHashSet) (:localsUsedInCatchFinally ___method).cons((:idx ___b))))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"LocalBinding" Compiler'referenceLocal [#_"Symbol" ___sym]
        (when (ß !Compiler'LOCAL_ENV.isBound())
            (§ return nil)
        )
        (let [#_"LocalBinding" ___b (ß (LocalBinding) RT'get-2(Compiler'LOCAL_ENV.deref(), ___sym))]
            (when (some? ___b)
                (let [#_"ObjMethod" ___method (ß (ObjMethod) Compiler'METHOD.deref())]
                    (when (ß (:idx ___b) == 0)
                        (§ ass (:usesThis ___method) true)
                    )
                    (ß closeOver(___b, ___method))
                )
            )
            ___b
        )
    )

    (defn- #_"Symbol" Compiler'tagOf [#_"Object" ___o]
        (let [#_"Object" ___tag (ß RT'get-2(RT'meta(___o), RT'TAG_KEY))]
            (cond (ß ___tag instanceof Symbol)
                (do
                    (§ return (ß (Symbol) ___tag))
                )
                (ß ___tag instanceof String)
                (do
                    (§ return (ß Symbol'intern-2(nil, (String) ___tag)))
                )
            )
            nil
        )
    )

    (defn #_"Object" Compiler'loadFile [#_"String" ___file] #_(§ throws IOException)
        (let [#_"FileInputStream" ___f (FileInputStream. ___file)]
            (try
                (ß load((InputStreamReader. ___f, RT'UTF8), (File. ___file).getAbsolutePath(), (File. ___file).getName()))
                (finally
                    (ß ___f.close())
                )
            )
        )
    )

    (defn #_"Object" Compiler'load-1 [#_"Reader" ___rdr]
        (ß load(___rdr, nil, "NO_SOURCE_FILE"))
    )

    (defn #_"void" Compiler'consumeWhitespaces [#_"LineNumberingPushbackReader" ___pushbackReader]
        (let [#_"int" ___ch (LispReader'read1 ___pushbackReader)]
            (while (LispReader'isWhitespace ___ch)
                (§ ass ___ch (LispReader'read1 ___pushbackReader))
            )
            (LispReader'unread ___pushbackReader, ___ch)
            nil
        )
    )

    (§ def- #_"Object" Compiler'OPTS_COND_ALLOWED (RT'mapUniqueKeys LispReader'OPT_READ_COND, LispReader'COND_ALLOW))

    (defn- #_"Object" Compiler'readerOpts [#_"String" ___sourceName]
        (if (ß ___sourceName != nil && ___sourceName.endsWith(".clic"))
            (do
                Compiler'OPTS_COND_ALLOWED
            )
            (do
                nil
            )
        )
    )

    (defn #_"Object" Compiler'load-3 [#_"Reader" ___rdr, #_"String" ___sourcePath, #_"String" ___sourceName]
        (let [#_"Object" ___EOF (Object.)]
            (let [#_"Object" ___ret nil]
                (let [#_"LineNumberingPushbackReader" ___pushbackReader (ß (___rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) ___rdr :or LineNumberingPushbackReader'new-1(___rdr))]
                    (ß consumeWhitespaces(___pushbackReader))
                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                        (§ map
                            Compiler'LOADER                (ß RT'makeClassLoader())
                            Compiler'SOURCE_PATH           ___sourcePath
                            Compiler'SOURCE                ___sourceName
                            Compiler'METHOD                nil
                            Compiler'LOCAL_ENV             nil
                            Compiler'LOOP_LOCALS           nil
                            Compiler'NEXT_LOCAL_NUM        0
                            RT'READEVAL           RT'T
                            RT'CURRENT_NS         (ß RT'CURRENT_NS.deref())
                            Compiler'LINE_BEFORE           (ß ___pushbackReader.getLineNumber())
                            Compiler'COLUMN_BEFORE         (ß ___pushbackReader.getColumnNumber())
                            Compiler'LINE_AFTER            (ß ___pushbackReader.getLineNumber())
                            Compiler'COLUMN_AFTER          (ß ___pushbackReader.getColumnNumber())
                            RT'UNCHECKED_MATH     (ß RT'UNCHECKED_MATH.deref())
                            RT'WARN_ON_REFLECTION (ß RT'WARN_ON_REFLECTION.deref())
                            RT'DATA_READERS       (ß RT'DATA_READERS.deref())
                        )
                    )))

                    (let [#_"Object" ___readerOpts (ß ___readerOpts(___sourceName))]
                        (try
                            (loop-when-recur [#_"Object" ___r (LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)] (ß ___r != ___EOF) [(LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)]
                                (ß consumeWhitespaces(___pushbackReader))
                                (ß Compiler'LINE_AFTER.set(___pushbackReader.getLineNumber()))
                                (ß Compiler'COLUMN_AFTER.set(___pushbackReader.getColumnNumber()))
                                (§ ass ___ret (ß eval(___r, false)))
                                (ß Compiler'LINE_BEFORE.set(___pushbackReader.getLineNumber()))
                                (ß Compiler'COLUMN_BEFORE.set(___pushbackReader.getColumnNumber()))
                            )
                            (§ catch LispReaderException ___e
                                (throw (ß CompilerException'new(___sourcePath, (:line ___e), (:column ___e), ___e.getCause())))
                            )
                            (catch Throwable ___e
                                (if (ß !(___e instanceof CompilerException))
                                    (do
                                        (throw (ß CompilerException'new(___sourcePath, (Integer) Compiler'LINE_BEFORE.deref(), (Integer) Compiler'COLUMN_BEFORE.deref(), ___e)))
                                    )
                                    (do
                                        (throw (ß (CompilerException) ___e))
                                    )
                                )
                            )
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                        ___ret
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'writeClassFile [#_"String" ___internalName, #_"byte[]" ___bytecode] #_(§ throws IOException)
        (let [#_"String" ___genPath (ß (String) Compiler'COMPILE_PATH.deref())]
            (when (nil? ___genPath)
                (throw (Util'runtimeException-1 "*compile-path* not set"))
            )
            (let [#_"String[]" ___dirs (ß ___internalName.split("/"))]
                (let [#_"String" ___p ___genPath]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___dirs.length - 1) [(inc ___i)]
                        (§ ass ___p (ß ___p + File/separator + ___dirs[___i]))
                        (ß (File. ___p).mkdir())
                    )
                    (let [#_"String" ___path (ß ___genPath + File/separator + ___internalName + ".class")]
                        (let [#_"File" ___cf (§ unsure File. ___path)]
                            (ß ___cf.createNewFile())
                            (let [#_"FileOutputStream" ___cfs (§ unsure FileOutputStream. ___cf)]
                                (try
                                    (ß ___cfs.write(___bytecode))
                                    (ß ___cfs.flush())
                                    (finally
                                        (ß ___cfs.close())
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" Compiler'pushNS []
        (ß Var'pushThreadBindings(PersistentHashMap'create-1a(
            (§ map
                Var'intern-2s(Symbol'intern-1("cloiure.core"), Symbol'intern-1("*ns*")).setDynamic() nil
            )
        )))
        nil
    )

    (defn #_"void" Compiler'pushNSandLoader [#_"ClassLoader" ___loader]
        (ß Var'pushThreadBindings(RT'map(
            (§ map
                Var'intern-2s(Symbol'intern-1("cloiure.core"), Symbol'intern-1("*ns*")).setDynamic() nil
                RT'FN_LOADER_VAR                                                                    ___loader
                RT'READEVAL                                                                         RT'T
            )
        )))
        nil
    )

    (defn #_"ILookupThunk" Compiler'getLookupThunk [#_"Object" ___target, #_"Keyword" ___k]
        nil
    )

    (defn #_"void" Compiler'compile1 [#_"GeneratorAdapter" ___gen, #_"ObjExpr" ___objx, #_"Object" ___form]
        (let [#_"Object" ___line (ß lineDeref())]
            (let [#_"Object" ___column (ß columnDeref())]
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'LINE_KEY))
                    (§ ass ___line (ß RT'meta(___form).valAt(RT'LINE_KEY)))
                )
                (when (ß RT'meta(___form) != nil && RT'meta(___form).containsKey(RT'COLUMN_KEY))
                    (§ ass ___column (ß RT'meta(___form).valAt(RT'COLUMN_KEY)))
                )
                (ß Var'pushThreadBindings(RT'map(
                    (§ map
                        Compiler'LINE   ___line
                        Compiler'COLUMN ___column
                        Compiler'LOADER (ß RT'makeClassLoader())
                    )
                )))
                (try
                    (§ ass ___form (ß macroexpand(___form)))
                    (if (ß ___form instanceof ISeq && Util'equals(RT'first(___form), Compiler'DO))
                        (do
                            (loop-when-recur [#_"ISeq" ___s (RT'next ___form)] (some? ___s) [(RT'next ___s)]
                                (ß compile1(___gen, ___objx, RT'first(___s)))
                            )
                        )
                        (do
                            (let [#_"Expr" ___expr (ß analyze(:Context'EVAL, ___form))]
                                (§ ass (:keywords ___objx) (ß (IPersistentMap) Compiler'KEYWORDS.deref()))
                                (§ ass (:vars ___objx) (ß (IPersistentMap) Compiler'VARS.deref()))
                                (§ ass (:constants ___objx) (ß (PersistentVector) Compiler'CONSTANTS.deref()))
                                (ß ___expr.emit(:Context'EXPRESSION, ___objx, ___gen))
                                (ß ___expr.eval())
                            )
                        )
                    )
                    (finally
                        (ß Var'popThreadBindings())
                    )
                )
                nil
            )
        )
    )

    (defn #_"Object" Compiler'compile [#_"Reader" ___rdr, #_"String" ___sourcePath, #_"String" ___sourceName] #_(§ throws IOException)
        (when (ß Compiler'COMPILE_PATH.deref() == nil)
            (throw (Util'runtimeException-1 "*compile-path* not set"))
        )

        (let [#_"Object" ___EOF (Object.)]
            (let [#_"Object" ___ret nil]
                (let [#_"LineNumberingPushbackReader" ___pushbackReader (ß (___rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader) ___rdr :or LineNumberingPushbackReader'new-1(___rdr))]
                    (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                        (§ map
                            Compiler'SOURCE_PATH           ___sourcePath
                            Compiler'SOURCE                ___sourceName
                            Compiler'METHOD                nil
                            Compiler'LOCAL_ENV             nil
                            Compiler'LOOP_LOCALS           nil
                            Compiler'NEXT_LOCAL_NUM        0
                            RT'READEVAL           RT'T
                            RT'CURRENT_NS         (ß RT'CURRENT_NS.deref())
                            Compiler'LINE_BEFORE           (ß ___pushbackReader.getLineNumber())
                            Compiler'COLUMN_BEFORE         (ß ___pushbackReader.getColumnNumber())
                            Compiler'LINE_AFTER            (ß ___pushbackReader.getLineNumber())
                            Compiler'COLUMN_AFTER          (ß ___pushbackReader.getColumnNumber())
                            Compiler'CONSTANTS             PersistentVector'EMPTY
                            Compiler'CONSTANT_IDS          (IdentityHashMap.)
                            Compiler'KEYWORDS              PersistentHashMap'EMPTY
                            Compiler'VARS                  PersistentHashMap'EMPTY
                            RT'UNCHECKED_MATH     (ß RT'UNCHECKED_MATH.deref())
                            RT'WARN_ON_REFLECTION (ß RT'WARN_ON_REFLECTION.deref())
                            RT'DATA_READERS       (ß RT'DATA_READERS.deref())
                        )
                    )))

                    (try
                        ;; generate loader class
                        (let [#_"ObjExpr" ___objx (ObjExpr'new nil)]
                            (§ ass (:internalName ___objx) (ß ___sourcePath.replace(File/separator, "/").substring(0, ___sourcePath.lastIndexOf(\.)) + RT'LOADER_SUFFIX))

                            (§ ass (:objtype ___objx) (ß Type/getObjectType((:internalName ___objx))))
                            (let [#_"ClassWriter" ___cw (ClassWriter. ClassWriter/COMPUTE_MAXS)]
                                (let [#_"ClassVisitor" ___cv ___cw]
                                    (ß ___cv.visit(V1_5, Opcodes/ACC_PUBLIC + Opcodes/ACC_SUPER, (:internalName ___objx), nil, "java/lang/Object", nil))

                                    ;; static load method
                                    (let [#_"GeneratorAdapter" ___gen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void load ()"), nil, nil, ___cv)]
                                        (ß ___gen.visitCode())

                                        (let [#_"Object" ___readerOpts (ß ___readerOpts(___sourceName))]
                                            (loop-when-recur [#_"Object" ___r (LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)] (ß ___r != ___EOF) [(LispReader'read-5 ___pushbackReader, false, ___EOF, false, ___readerOpts)]
                                                (ß Compiler'LINE_AFTER.set(___pushbackReader.getLineNumber()))
                                                (ß Compiler'COLUMN_AFTER.set(___pushbackReader.getColumnNumber()))
                                                (ß compile1(___gen, ___objx, ___r))
                                                (ß Compiler'LINE_BEFORE.set(___pushbackReader.getLineNumber()))
                                                (ß Compiler'COLUMN_BEFORE.set(___pushbackReader.getColumnNumber()))
                                            )
                                            ;; end of load
                                            (ß ___gen.returnValue())
                                            (ß ___gen.endMethod())

                                            ;; static fields for constants
                                            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:constants ___objx).count()) [(inc ___i)]
                                                (when (ß (:usedConstants ___objx).contains(___i))
                                                    (ß ___cv.visitField(Opcodes/ACC_PUBLIC + Opcodes/ACC_FINAL + Opcodes/ACC_STATIC, ___objx.constantName(___i), ___objx.constantType(___i).getDescriptor(), nil, nil))
                                                )
                                            )

                                            (let [#_"int" ___INITS_PER 100]
                                                (let [#_"int" ___numInits (ß (:constants ___objx).count() / ___INITS_PER)]
                                                    (when (ß (:constants ___objx).count() % ___INITS_PER != 0)
                                                        (§ ass ___numInits (inc ___numInits))
                                                    )

                                                    (loop-when-recur [#_"int" ___n 0] (< ___n ___numInits) [(inc ___n)]
                                                        (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod (str "void __init" ___n"()")), nil, nil, ___cv)]
                                                            (ß ___clinitgen.visitCode())
                                                            (try
                                                                (ß Var'pushThreadBindings(RT'map(RT'PRINT_DUP, RT'T)))

                                                                (loop-when-recur [#_"int" ___i (* ___n ___INITS_PER)] (ß ___i < (:constants ___objx).count() && ___i < (___n + 1) * ___INITS_PER) [(inc ___i)]
                                                                    (when (ß (:usedConstants ___objx).contains(___i))
                                                                        (ß ___objx.emitValue((:constants ___objx).nth(___i), ___clinitgen))
                                                                        (ß ___clinitgen.checkCast(___objx.constantType(___i)))
                                                                        (ß ___clinitgen.putStatic((:objtype ___objx), ___objx.constantName(___i), ___objx.constantType(___i)))
                                                                    )
                                                                )
                                                                (finally
                                                                    (ß Var'popThreadBindings())
                                                                )
                                                            )
                                                            (ß ___clinitgen.returnValue())
                                                            (ß ___clinitgen.endMethod())
                                                        )
                                                    )

                                                    ;; static init for constants, keywords and vars
                                                    (let [#_"GeneratorAdapter" ___clinitgen (GeneratorAdapter. (+ Opcodes/ACC_PUBLIC Opcodes/ACC_STATIC), (Method/getMethod "void <clinit> ()"), nil, nil, ___cv)]
                                                        (ß ___clinitgen.visitCode())
                                                        (let [#_"Label" ___startTry (ß ___clinitgen.newLabel())]
                                                            (let [#_"Label" ___endTry (ß ___clinitgen.newLabel())]
                                                                (let [#_"Label" ___end (ß ___clinitgen.newLabel())]
                                                                    (let [#_"Label" ___finallyLabel (ß ___clinitgen.newLabel())]
                                                                        (loop-when-recur [#_"int" ___n 0] (< ___n ___numInits) [(inc ___n)]
                                                                            (ß ___clinitgen.invokeStatic((:objtype ___objx), Method/getMethod("void __init" + ___n + "()")))
                                                                        )

                                                                        (ß ___clinitgen.push((:internalName ___objx).replace(\/, \.)))
                                                                        (ß ___clinitgen.invokeStatic(Compiler'RT_TYPE, Method/getMethod("Class classForName(String)")))
                                                                        (ß ___clinitgen.invokeVirtual(Compiler'CLASS_TYPE, Method/getMethod("ClassLoader getClassLoader()")))
                                                                        (ß ___clinitgen.invokeStatic(Type/getType((§ class Compiler)), Method/getMethod("void pushNSandLoader(ClassLoader)")))
                                                                        (ß ___clinitgen.mark(___startTry))
                                                                        (ß ___clinitgen.invokeStatic((:objtype ___objx), Method/getMethod("void load()")))
                                                                        (ß ___clinitgen.mark(___endTry))
                                                                        (ß ___clinitgen.invokeStatic(Compiler'VAR_TYPE, Method/getMethod("void popThreadBindings()")))
                                                                        (ß ___clinitgen.goTo(___end))

                                                                        (ß ___clinitgen.mark(___finallyLabel))
                                                                        ;; exception should be on stack
                                                                        (ß ___clinitgen.invokeStatic(Compiler'VAR_TYPE, Method/getMethod("void popThreadBindings()")))
                                                                        (ß ___clinitgen.throwException())
                                                                        (ß ___clinitgen.mark(___end))
                                                                        (ß ___clinitgen.visitTryCatchBlock(___startTry, ___endTry, ___finallyLabel, nil))

                                                                        ;; end of static init
                                                                        (ß ___clinitgen.returnValue())
                                                                        (ß ___clinitgen.endMethod())

                                                                        ;; end of class
                                                                        (ß ___cv.visitEnd())

                                                                        (ß writeClassFile((:internalName ___objx), ___cw.toByteArray()))
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (§ catch LispReaderException ___e
                            (throw (ß CompilerException'new(___sourcePath, (:line ___e), (:column ___e), ___e.getCause())))
                        )
                        (finally
                            (ß Var'popThreadBindings())
                        )
                    )
                    ___ret
                )
            )
        )
    )

    (defn #_"boolean" Compiler'inty [#_"Class" ___c]
        (ß (___c == (§ class int) || ___c == (§ class short) || ___c == (§ class byte) || ___c == (§ class char)))
    )

    (defn #_"Class" Compiler'retType [#_"Class" ___tc, #_"Class" ___ret]
        (when (nil? ___tc)
            (§ return ___ret)
        )
        (when (nil? ___ret)
            (§ return ___tc)
        )
        (when (ß ___ret.isPrimitive() && ___tc.isPrimitive())
            (when (ß (inty(___ret) && inty(___tc)) || (___ret == ___tc))
                (§ return ___tc)
            )
            (throw (UnsupportedOperationException. (str "Cannot coerce " ___ret " to " ___tc ", use a cast instead")))
        )
        ___tc
    )

    (defn #_"Class" Compiler'primClass-1s [#_"Symbol" ___sym]
        (when (nil? ___sym)
            (§ return nil)
        )
        (let [#_"Class" ___c nil]
            (cond (ß (:name ___sym).equals("int"))
                (do
                    (§ ass ___c (§ class int))
                )
                (ß (:name ___sym).equals("long"))
                (do
                    (§ ass ___c (§ class long))
                )
                (ß (:name ___sym).equals("float"))
                (do
                    (§ ass ___c (§ class float))
                )
                (ß (:name ___sym).equals("double"))
                (do
                    (§ ass ___c (§ class double))
                )
                (ß (:name ___sym).equals("char"))
                (do
                    (§ ass ___c (§ class char))
                )
                (ß (:name ___sym).equals("short"))
                (do
                    (§ ass ___c (§ class short))
                )
                (ß (:name ___sym).equals("byte"))
                (do
                    (§ ass ___c (§ class byte))
                )
                (ß (:name ___sym).equals("boolean"))
                (do
                    (§ ass ___c (§ class boolean))
                )
                (ß (:name ___sym).equals("void"))
                (do
                    (§ ass ___c (§ class void))
                )
            )
            ___c
        )
    )

    (defn #_"Class" Compiler'tagClass [#_"Object" ___tag]
        (when (nil? ___tag)
            (§ return (§ class Object))
        )
        (let [#_"Class" ___c nil]
            (when (ß ___tag instanceof Symbol)
                (§ ass ___c (ß primClass((Symbol) ___tag)))
            )
            (when (nil? ___c)
                (§ ass ___c (HostExpr'tagToClass ___tag))
            )
            ___c
        )
    )

    (defn #_"Class" Compiler'primClass-1c [#_"Class" ___c]
        (ß ___c.isPrimitive() ? ___c :or (§ class Object))
    )

    (defn #_"Class" Compiler'boxClass [#_"Class" ___p]
        (when (ß !___p.isPrimitive())
            (§ return ___p)
        )

        (let [#_"Class" ___c nil]
            (cond (ß ___p == Integer/TYPE)
                (do
                    (§ ass ___c (§ class Integer))
                )
                (ß ___p == Long/TYPE)
                (do
                    (§ ass ___c (§ class Long))
                )
                (ß ___p == Float/TYPE)
                (do
                    (§ ass ___c (§ class Float))
                )
                (ß ___p == Double/TYPE)
                (do
                    (§ ass ___c (§ class Double))
                )
                (ß ___p == Character/TYPE)
                (do
                    (§ ass ___c (§ class Character))
                )
                (ß ___p == Short/TYPE)
                (do
                    (§ ass ___c (§ class Short))
                )
                (ß ___p == Byte/TYPE)
                (do
                    (§ ass ___c (§ class Byte))
                )
                (ß ___p == Boolean/TYPE)
                (do
                    (§ ass ___c (§ class Boolean))
                )
            )

            ___c
        )
    )

    (defn #_"IPersistentCollection" Compiler'emptyVarCallSites []
        PersistentHashSet'EMPTY
    )
)
)

(java-ns cloiure.lang.Cons

(class-ns Cons (§ extends ASeq)
    (defn- #_"Cons" Cons'init []
        (hash-map
            #_"Object" :_first nil
            #_"ISeq" :_more nil
        )
    )

    (defn #_"Cons" Cons'new-2 [#_"Object" ___first, #_"ISeq" ____more]
        (let [this (merge (ASeq'new) (Cons'init))]
            (§ ass (:_first this) ___first)
            (§ ass (:_more this) ____more)
            this
        )
    )

    (defn #_"Cons" Cons'new-3 [#_"IPersistentMap" ___meta, #_"Object" ____first, #_"ISeq" ____more]
        (let [this (merge (ASeq'new ___meta) (Cons'init))]
            (§ ass (:_first this) ____first)
            (§ ass (:_more this) ____more)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"Cons" this]
        (:_first this)
    )

    #_method
    (§ defn #_"ISeq" next [#_"Cons" this]
        (ß more().seq())
    )

    #_method
    (§ defn #_"ISeq" more [#_"Cons" this]
        (when (nil? (:_more this))
            (§ return PersistentList'EMPTY)
        )
        (:_more this)
    )

    #_method
    (§ defn #_"int" count [#_"Cons" this]
        (ß 1 + RT'count((:_more this)))
    )

    #_method
    (§ defn #_"Cons" withMeta [#_"Cons" this, #_"IPersistentMap" ___meta]
        (Cons'new-3 ___meta, (:_first this), (:_more this))
    )
)
)

(java-ns cloiure.lang.Counted

;;;
 ; A class that implements Counted promises that it is a collection
 ; that implement a constant-time count()
 ;;
(defprotocol Counted
    #_abstract
    (#_"int" Counted'''count [#_"Counted" this])
)
)

(java-ns cloiure.lang.Cycle

(class-ns Cycle (§ extends ASeq) (§ implements IReduce, IPending)
    (defn- #_"Cycle" Cycle'init []
        (hash-map
            #_"ISeq" :all nil ;; never nil
            #_"ISeq" :prev nil
            #_volatile
            #_"ISeq" :_current nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Cycle" Cycle'new-3 [#_"ISeq" ___all, #_"ISeq" ___prev, #_"ISeq" ___current]
        (let [this (merge (ASeq'new) (Cycle'init))]
            (§ ass (:all this) ___all)
            (§ ass (:prev this) ___prev)
            (§ ass (:_current this) ___current)
            this
        )
    )

    (defn- #_"Cycle" Cycle'new-5 [#_"IPersistentMap" ___meta, #_"ISeq" ___all, #_"ISeq" ___prev, #_"ISeq" ___current, #_"ISeq" ___next]
        (let [this (merge (ASeq'new ___meta) (Cycle'init))]
            (§ ass (:all this) ___all)
            (§ ass (:prev this) ___prev)
            (§ ass (:_current this) ___current)
            (§ ass (:_next this) ___next)
            this
        )
    )

    (defn #_"ISeq" Cycle'create [#_"ISeq" ___vals]
        (when (nil? ___vals)
            (§ return PersistentList'EMPTY)
        )
        (Cycle'new-3 ___vals, nil, ___vals)
    )

    ;; realization for use of current
    #_method
    (§ defn- #_"ISeq" current [#_"Cycle" this]
        (when (nil? (:_current this))
            (let [#_"ISeq" ___current (ß (:prev this).next())]
                (§ ass (:_current this) (ß (___current == nil) ? (:all this) :or ___current))
            )
        )
        (:_current this)
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Cycle" this]
        (ß ((:_current this) != nil))
    )

    #_method
    (§ defn #_"Object" first [#_"Cycle" this]
        (ß current().first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"Cycle" this]
        (when (nil? (:_next this))
            (§ ass (:_next this) (ß Cycle'new-3((:all this), current(), nil)))
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Cycle" withMeta [#_"Cycle" this, #_"IPersistentMap" ___meta]
        (Cycle'new-5 ___meta, (:all this), (:prev this), (:_current this), (:_next this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Cycle" this, #_"IFn" ___f]
        (let [#_"ISeq" ___s (ß current())]
            (let [#_"Object" ___ret (ß ___s.first())]
                (while true
                    (§ ass ___s (ß ___s.next()))
                    (when (nil? ___s)
                        (§ ass ___s (:all this))
                    )
                    (§ ass ___ret (ß ___f.invoke(___ret, ___s.first())))
                    (when (RT'isReduced ___ret)
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Cycle" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (let [#_"ISeq" ___s (ß current())]
                (while true
                    (§ ass ___ret (ß ___f.invoke(___ret, ___s.first())))
                    (when (RT'isReduced ___ret)
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                    (§ ass ___s (ß ___s.next()))
                    (when (nil? ___s)
                        (§ ass ___s (:all this))
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Delay

(class-ns Delay (§ implements IDeref, IPending)
    (defn- #_"Delay" Delay'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Throwable" :exception nil
            #_volatile
            #_"IFn" :fn nil
        )
    )

    (defn #_"Delay" Delay'new [#_"IFn" ___fn]
        (let [this (Delay'init)]
            (§ ass (:fn this) ___fn)
            (§ ass (:val this) nil)
            (§ ass (:exception this) nil)
            this
        )
    )

    (defn #_"Object" Delay'force [#_"Object" ___x]
        (ß (___x instanceof Delay) ? ((Delay) ___x).deref() :or ___x)
    )

    #_method
    (§ defn #_"Object" deref [#_"Delay" this]
        (when (some? (:fn this))
            (§ sync this
                ;; double check
                (when (some? (:fn this))
                    (try
                        (§ ass (:val this) (ß (:fn this).invoke()))
                        (catch Throwable ___t
                            (§ ass (:exception this) ___t)
                        )
                    )
                    (§ ass (:fn this) nil)
                )
            )
        )
        (when (some? (:exception this))
            (throw (Util'sneakyThrow (:exception this)))
        )
        (:val this)
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Delay" this]
        (§ sync this
            (ß ((:fn this) == nil))
        )
    )
)
)

(java-ns cloiure.lang.DynamicClassLoader

(§ import java.lang.ref.Reference)
(§ import java.util.HashMap)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.net.URLClassLoader)
(§ import java.net.URL)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns DynamicClassLoader (§ extends URLClassLoader)
    (def #_"ConcurrentHashMap<String, Reference<Class>>" DynamicClassLoader'classCache (ConcurrentHashMap.))

    (def #_"URL[]" DynamicClassLoader'EMPTY_URLS (make-array URL 0))

    (def #_"ReferenceQueue" DynamicClassLoader'RQ (ReferenceQueue.))

    (defn- #_"DynamicClassLoader" DynamicClassLoader'init []
        (hash-map
            #_"HashMap<Integer, Object[]>" :constantVals (HashMap.)
        )
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new-0 []
        ;; pseudo test in lieu of hasContextClassLoader()
        (merge (URLClassLoader'new DynamicClassLoader'EMPTY_URLS, (ß (Thread/currentThread().getContextClassLoader() == nil || Thread/currentThread().getContextClassLoader() == ClassLoader/getSystemClassLoader()) ? (§ class Compiler).getClassLoader() :or Thread/currentThread().getContextClassLoader())) (DynamicClassLoader'init))
    )

    (defn #_"DynamicClassLoader" DynamicClassLoader'new-1 [#_"ClassLoader" ___parent]
        (merge (URLClassLoader'new DynamicClassLoader'EMPTY_URLS, ___parent) (DynamicClassLoader'init))
    )

    #_method
    (§ defn #_"Class" defineClass [#_"DynamicClassLoader" this, #_"String" ___name, #_"byte[]" ___bytes, #_"Object" ___srcForm]
        (Util'clearCache DynamicClassLoader'RQ, classCache)
        (let [#_"Class" ___c (ß defineClass(___name, ___bytes, 0, ___bytes.length))]
            (ß classCache.put(___name, (SoftReference. ___c, DynamicClassLoader'RQ)))
            ___c
        )
    )

    (defn #_"Class<?>" DynamicClassLoader'findInMemoryClass [#_"String" ___name]
        (let [#_"Reference<Class>" ___cr (ß classCache.get(___name))]
            (when (some? ___cr)
                (let [#_"Class" ___c (ß ___cr.get())]
                    (if (some? ___c)
                        (do
                            (§ return ___c)
                        )
                        (do
                            (ß classCache.remove(___name, ___cr))
                        )
                    )
                )
            )
            nil
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" findClass [#_"DynamicClassLoader" this, #_"String" ___name] #_(§ throws ClassNotFoundException)
        (let [#_"Class" ___c (DynamicClassLoader'findInMemoryClass ___name)]
            (if (some? ___c)
                (do
                    ___c
                )
                (do
                    (ß super.findClass(___name))
                )
            )
        )
    )

    #_protected
    #_method
    (§ defn #_"Class<?>" loadClass [#_"DynamicClassLoader" this, #_"String" ___name, #_"boolean" ___resolve] #_(§ throws ClassNotFoundException)
        (§ sync this
            (let [#_"Class" ___c (ß findLoadedClass(___name))]
                (when (nil? ___c)
                    (§ ass ___c (DynamicClassLoader'findInMemoryClass ___name))
                    (when (nil? ___c)
                        (§ ass ___c (ß super.loadClass(___name, false)))
                    )
                )
                (when ___resolve
                    (ß resolveClass(___c))
                )
                ___c
            )
        )
    )

    #_method
    (§ defn #_"void" registerConstants [#_"DynamicClassLoader" this, #_"int" ___id, #_"Object[]" ___val]
        (ß (:constantVals this).put(___id, ___val))
        nil
    )

    #_method
    (§ defn #_"Object[]" getConstants [#_"DynamicClassLoader" this, #_"int" ___id]
        (ß (:constantVals this).get(___id))
    )

    #_method
    (§ defn #_"void" addURL [#_"DynamicClassLoader" this, #_"URL" ___url]
        (ß super.addURL(___url))
        nil
    )
)
)

(java-ns cloiure.lang.EdnReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(class-ns EdnReaderException (§ extends RuntimeException)
    (defn- #_"EdnReaderException" EdnReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"EdnReaderException" EdnReaderException'new [#_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new ___cause) (EdnReaderException'init))]
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )
)

#_closure
(class-ns EdnStringReader (§ extends AFn)
    (defn #_"EdnStringReader" EdnStringReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnStringReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [#_"int" ___ch (ß read1(___r))] (ß ___ch != \") [(ß read1(___r))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (Util'runtimeException-1 "EOF while reading string"))
                    )
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (Util'runtimeException-1 "EOF while reading string"))
                        )
                        (§ switch ___ch
                            (§ case \t)
                            (do
                                (§ ass ___ch \tab)
                                (§ break )
                            )
                            (§ case \r)
                            (do
                                (§ ass ___ch \return)
                                (§ break )
                            )
                            (§ case \n)
                            (do
                                (§ ass ___ch \newline)
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (§ break )
                            )
                            (§ case \") ;; oops! "
                            (do
                                (§ break )
                            )
                            (§ case \b)
                            (do
                                (§ ass ___ch \backspace)
                                (§ break )
                            )
                            (§ case \f)
                            (do
                                (§ ass ___ch \formfeed)
                                (§ break )
                            )
                            (§ case \u)
                            (do
                                (§ ass ___ch (ß read1(___r)))
                                (when (ß Character/digit(___ch, 16) == -1)
                                    (throw (Util'runtimeException-1 (str "Invalid unicode escape: \\u" (ß (char) ___ch))))
                                )
                                (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 16, 4, true)))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (if (Character/isDigit ___ch)
                                    (do
                                        (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 8, 3, false)))
                                        (when (> ___ch 0377)
                                            (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                        )
                                    )
                                    (do
                                        (throw (Util'runtimeException-1 (str "Unsupported escape character: \\" (ß (char) ___ch))))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
                (ß ___sb.toString())
            )
        )
    )
)

#_closure
(class-ns EdnCommentReader (§ extends AFn)
    (defn #_"EdnCommentReader" EdnCommentReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnCommentReader" this, #_"Object" ___reader, #_"Object" ___semicolon, #_"Object" ___opts]
        (let [#_"Reader" ___r (ß (Reader) ___reader)]
            (§ let [#_"int" ___ch]
                (§ loop
                    (§ ass ___ch (ß read1(___r)))
                    (§ recur-if (___ch != -1 && ___ch != \newline && ___ch != \return))
                )
                ___r
            )
        )
    )
)

#_closure
(class-ns EdnDiscardReader (§ extends AFn)
    (defn #_"EdnDiscardReader" EdnDiscardReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnDiscardReader" this, #_"Object" ___reader, #_"Object" ___underscore, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß read(___r, true, nil, true, ___opts))
            ___r
        )
    )
)

#_closure
(class-ns EdnNamespaceMapReader (§ extends AFn)
    (defn #_"EdnNamespaceMapReader" EdnNamespaceMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnNamespaceMapReader" this, #_"Object" ___reader, #_"Object" ___colon, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            ;; Read ns symbol
            (let [#_"Object" ___sym (ß read(___r, true, nil, false, ___opts))]
                (when (ß !(___sym instanceof Symbol) || ((Symbol)___sym).getNamespace() != nil)
                    (throw (RuntimeException. (str "Namespaced map must specify a valid namespace: " ___sym)))
                )
                (let [#_"String" ___ns (ß ((Symbol)___sym).getName())]
                    ;; Read map
                    (let [#_"int" ___nextChar (ß read1(___r))]
                        (while (ß isWhitespace(___nextChar))
                            (§ ass ___nextChar (ß read1(___r)))
                        )
                        (when (ß \{ != ___nextChar)
                            (throw (RuntimeException. "Namespaced map must specify a map"))
                        )
                        (let [#_"List" ___kvs (ß readDelimitedList(\}, ___r, true, ___opts))]
                            (when (ß (___kvs.size() & 1) == 1)
                                (throw (Util'runtimeException-1 "Namespaced map literal must contain an even number of forms"))
                            )

                            ;; Construct output map
                            (let [#_"Object[]" ___a (make-array Object (ß ___kvs.size()))]
                                (let [#_"Iterator" ___iter (ß ___kvs.iterator())]
                                    (loop-when-recur [#_"int" ___i 0] (ß ___iter.hasNext()) [(+ ___i 2)]
                                        (let [#_"Object" ___key (ß ___iter.next())]
                                            (let [#_"Object" ___val (ß ___iter.next())]
                                                (cond (ß ___key instanceof Keyword)
                                                    (do
                                                        (let [#_"Keyword" ___kw (ß (Keyword) ___key)]
                                                            (cond (ß ___kw.getNamespace() == nil)
                                                                (do
                                                                    (§ ass ___key (ß Keyword'intern-2(___ns, ___kw.getName())))
                                                                )
                                                                (ß ___kw.getNamespace().equals("_"))
                                                                (do
                                                                    (§ ass ___key (ß Keyword'intern-2(nil, ___kw.getName())))
                                                                )
                                                            )
                                                        )
                                                    )
                                                    (ß ___key instanceof Symbol)
                                                    (do
                                                        (let [#_"Symbol" ___s (ß (Symbol) ___key)]
                                                            (cond (ß ___s.getNamespace() == nil)
                                                                (do
                                                                    (§ ass ___key (ß Symbol'intern-2(___ns, ___s.getName())))
                                                                )
                                                                (ß ___s.getNamespace().equals("_"))
                                                                (do
                                                                    (§ ass ___key (ß Symbol'intern-2(nil, ___s.getName())))
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                                (§ ass (ß ___a[___i]) ___key)
                                                (§ ass (ß ___a[___i + 1]) ___val)
                                            )
                                        )
                                    )
                                    (RT'map ___a)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnDispatchReader (§ extends AFn)
    (defn #_"EdnDispatchReader" EdnDispatchReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnDispatchReader" this, #_"Object" ___reader, #_"Object" ___hash, #_"Object" ___opts]
        (let [#_"int" ___ch (ß read1((Reader) ___reader))]
            (when (ß ___ch == -1)
                (throw (Util'runtimeException-1 "EOF while reading character"))
            )
            (let [#_"IFn" ___fn (ß dispatchMacros[___ch])]
                (when (nil? ___fn)
                    ;; try tagged reader
                    (when (Character/isLetter ___ch)
                        (ß unread((PushbackReader) ___reader, ___ch))
                        (§ return (ß taggedReader.invoke(___reader, ___ch, ___opts)))
                    )

                    (throw (ß Util'runtimeException-1(String/format("No dispatch macro for: %c", (§ array (ß (char) ___ch))))))
                )
                (ß ___fn.invoke(___reader, ___ch, ___opts))
            )
        )
    )
)

#_closure
(class-ns EdnMetaReader (§ extends AFn)
    (defn #_"EdnMetaReader" EdnMetaReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnMetaReader" this, #_"Object" ___reader, #_"Object" ___caret, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
                        (§ ass ___column (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()-1))
                    )
                    (let [#_"Object" ___meta (ß read(___r, true, nil, true, ___opts))]
                        (cond (ß ___meta instanceof Symbol || ___meta instanceof String)
                            (do
                                (§ ass ___meta (RT'map RT'TAG_KEY, ___meta))
                            )
                            (ß ___meta instanceof Keyword)
                            (do
                                (§ ass ___meta (RT'map ___meta, RT'T))
                            )
                            (ß !(___meta instanceof IPersistentMap))
                            (do
                                (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                            )
                        )

                        (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts))]
                            (if (ß ___o instanceof IMeta)
                                (do
                                    (when (ß ___line != -1 && ___o instanceof ISeq)
                                        (§ ass ___meta (ß ((IPersistentMap) ___meta).assoc(RT'LINE_KEY, ___line).assoc(RT'COLUMN_KEY, ___column)))
                                    )
                                    (when (ß ___o instanceof IReference)
                                        (ß ((IReference)___o).resetMeta((IPersistentMap) ___meta))
                                        (§ return ___o)
                                    )
                                    (let [#_"Object" ___ometa (RT'meta ___o)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'seq ___meta)] (some? ___s) [(ß ___s.next())]
                                            (let [#_"IMapEntry" ___kv (ß (IMapEntry) ___s.first())]
                                                (§ ass ___ometa (ß RT'assoc(___ometa, ___kv.getKey(), ___kv.getValue())))
                                            )
                                        )
                                        (ß ((IObj) ___o).withMeta((IPersistentMap) ___ometa))
                                    )
                                )
                                (do
                                    (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnCharacterReader (§ extends AFn)
    (defn #_"EdnCharacterReader" EdnCharacterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnCharacterReader" this, #_"Object" ___reader, #_"Object" ___backslash, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß read1(___r))]
                (when (ß ___ch == -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (let [#_"String" ___token (ß readToken(___r, (char) ___ch, false))]
                    (cond (ß ___token.length() == 1)
                        (do
                            (§ return (ß Character/valueOf(___token.charAt(0))))
                        )
                        (ß ___token.equals("newline"))
                        (do
                            (§ return \newline)
                        )
                        (ß ___token.equals("space"))
                        (do
                            (§ return \space)
                        )
                        (ß ___token.equals("tab"))
                        (do
                            (§ return \tab)
                        )
                        (ß ___token.equals("backspace"))
                        (do
                            (§ return \backspace)
                        )
                        (ß ___token.equals("formfeed"))
                        (do
                            (§ return \formfeed)
                        )
                        (ß ___token.equals("return"))
                        (do
                            (§ return \return)
                        )
                        (ß ___token.startsWith("u"))
                        (do
                            (let [#_"char" ___c (ß (char) readUnicodeChar(___token, 1, 4, 16))]
                                (when (ß ___c >= (§ char "\ud800") && ___c <= (§ char "\udfff")) ;; surrogate code unit?
                                    (throw (Util'runtimeException-1 (str "Invalid character constant: \\u" (Integer/toString ___c, 16))))
                                )
                                (§ return ___c)
                            )
                        )
                        (ß ___token.startsWith("o"))
                        (do
                            (let [#_"int" ___len (ß ___token.length() - 1)]
                                (when (> ___len 3)
                                    (throw (Util'runtimeException-1 (str "Invalid octal escape sequence length: " ___len)))
                                )
                                (let [#_"int" ___uc (ß readUnicodeChar(___token, 1, ___len, 8))]
                                    (when (> ___uc 0377)
                                        (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                    )
                                    (§ return (ß (char) ___uc))
                                )
                            )
                        )
                    )
                    (throw (Util'runtimeException-1 (str "Unsupported character: \\" ___token)))
                )
            )
        )
    )
)

#_closure
(class-ns EdnListReader (§ extends AFn)
    (defn #_"EdnListReader" EdnListReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnListReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
                        (§ ass ___column (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()-1))
                    )
                    (let [#_"List" ___list (ß readDelimitedList(\), ___r, true, ___opts))]
                        (when (ß ___list.isEmpty())
                            (§ return PersistentList'EMPTY)
                        )
                        (let [#_"IObj" ___s (ß (IObj) PersistentList'create(___list))]
                            ___s
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EdnVectorReader (§ extends AFn)
    (defn #_"EdnVectorReader" EdnVectorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnVectorReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß LazilyPersistentVector'create(readDelimitedList(\], ___r, true, ___opts)))
        )
    )
)

#_closure
(class-ns EdnMapReader (§ extends AFn)
    (defn #_"EdnMapReader" EdnMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnMapReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object[]" ___a (ß readDelimitedList(\}, ___r, true, ___opts).toArray())]
                (when (ß (___a.length & 1) == 1)
                    (throw (Util'runtimeException-1 "Map literal must contain an even number of forms"))
                )
                (RT'map ___a)
            )
        )
    )
)

#_closure
(class-ns EdnSetReader (§ extends AFn)
    (defn #_"EdnSetReader" EdnSetReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnSetReader" this, #_"Object" ___reader, #_"Object" ___leftbracket, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß PersistentHashSet'createWithCheck-1l(readDelimitedList(\}, ___r, true, ___opts)))
        )
    )
)

#_closure
(class-ns EdnUnmatchedDelimiterReader (§ extends AFn)
    (defn #_"EdnUnmatchedDelimiterReader" EdnUnmatchedDelimiterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnUnmatchedDelimiterReader" this, #_"Object" ___reader, #_"Object" ___rightdelim, #_"Object" ___opts]
        (throw (Util'runtimeException-1 (str "Unmatched delimiter: " ___rightdelim)))
    )
)

#_closure
(class-ns EdnUnreadableReader (§ extends AFn)
    (defn #_"EdnUnreadableReader" EdnUnreadableReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EdnUnreadableReader" this, #_"Object" ___reader, #_"Object" ___leftangle, #_"Object" ___opts]
        (throw (Util'runtimeException-1 "Unreadable form"))
    )
)

#_closure
(class-ns EdnSymbolicValueReader (§ extends AFn)
    (defn #_"EdnSymbolicValueReader" EdnSymbolicValueReader'new []
        (AFn'new)
    )

    (def #_"IPersistentMap" EdnSymbolicValueReader'specials (ß PersistentHashMap'create-1a(
        (§ map
            (Symbol'intern-1 "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern-1 "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern-1 "NaN")  Double/NaN
        )
    )))

    #_method
    (§ defn #_"Object" invoke [#_"EdnSymbolicValueReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts))]
                (when (ß !(___o instanceof Symbol))
                    (throw (Util'runtimeException-1 (str "Invalid token: ##" ___o)))
                )
                (when (ß !(EdnSymbolicValueReader'specials.containsKey(___o)))
                    (throw (Util'runtimeException-1 (str "Unknown symbolic value: ##" ___o)))
                )

                (ß EdnSymbolicValueReader'specials.valAt(___o))
            )
        )
    )
)

#_closure
(class-ns TaggedReader (§ extends AFn)
    (defn #_"TaggedReader" TaggedReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"TaggedReader" this, #_"Object" ___reader, #_"Object" ___firstChar, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___name (ß read(___r, true, nil, false, ___opts))]
                (when (ß !(___name instanceof Symbol))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" ___sym (ß (Symbol)___name)]
                    (ß readTagged(___r, ___sym, (IPersistentMap) ___opts))
                )
            )
        )
    )

    (§ def #_"Keyword" TaggedReader'READERS (Keyword'intern-2 nil, "readers"))
    (§ def #_"Keyword" TaggedReader'DEFAULT (Keyword'intern-2 nil, "default"))

    #_method
    (§ defn- #_"Object" readTagged [#_"TaggedReader" this, #_"PushbackReader" ___reader, #_"Symbol" ___tag, #_"IPersistentMap" ___opts]
        (let [#_"Object" ___o (ß read(___reader, true, nil, true, ___opts))]
            (let [#_"ILookup" ___readers (ß (ILookup)RT'get-2(___opts, TaggedReader'READERS))]
                (let [#_"IFn" ___dataReader (ß (IFn)RT'get-2(___readers, ___tag))]
                    (when (nil? ___dataReader)
                        (§ ass ___dataReader (ß (IFn)RT'get-2(RT'DEFAULT_DATA_READERS.deref(), ___tag)))
                    )
                    (if (nil? ___dataReader)
                        (do
                            (let [#_"IFn" ___defaultReader (ß (IFn)RT'get-2(___opts, TaggedReader'DEFAULT))]
                                (if (some? ___defaultReader)
                                    (do
                                        (ß ___defaultReader.invoke(___tag, ___o))
                                    )
                                    (do
                                        (throw (RuntimeException. (str "No reader function for tag " (ß ___tag.toString()))))
                                    )
                                )
                            )
                        )
                        (do
                            (ß ___dataReader.invoke(___o))
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns EdnReader
    (def #_"IFn[]" EdnReader'macros (§ typeless make-array IFn 256))
    (def #_"IFn[]" EdnReader'dispatchMacros (§ typeless make-array IFn 256))
    (def #_"Pattern" EdnReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" EdnReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" EdnReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" EdnReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    (§ def #_"IFn" EdnReader'taggedReader (TaggedReader'new))

    (§ static
        (§ ass (ß macros[\"]) (EdnStringReader'new)) ;; oops! "
        (§ ass (ß macros[\;]) (EdnCommentReader'new))
        (§ ass (ß macros[\^]) (EdnMetaReader'new))
        (§ ass (ß macros[\(]) (EdnListReader'new))
        (§ ass (ß macros[\)]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\[]) (EdnVectorReader'new))
        (§ ass (ß macros[\]]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\{]) (EdnMapReader'new))
        (§ ass (ß macros[\}]) (EdnUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\\]) (EdnCharacterReader'new))
        (§ ass (ß macros[\#]) (EdnDispatchReader'new))

        (§ ass (ß dispatchMacros[\#]) (EdnSymbolicValueReader'new))
        (§ ass (ß dispatchMacros[\^]) (EdnMetaReader'new))
        (§ ass (ß dispatchMacros[\{]) (EdnSetReader'new))
        (§ ass (ß dispatchMacros[\<]) (EdnUnreadableReader'new))
        (§ ass (ß dispatchMacros[\_]) (EdnDiscardReader'new))
        (§ ass (ß dispatchMacros[\:]) (EdnNamespaceMapReader'new))
    )

    (defn #_"boolean" EdnReader'nonConstituent [#_"int" ___ch]
        (ß (___ch == \@ || ___ch == \` || ___ch == \~))
    )

    (defn #_"Object" EdnReader'readString [#_"String" ___s, #_"IPersistentMap" ___opts]
        (let [#_"PushbackReader" ___r (PushbackReader. (java.io.StringReader. ___s))]
            (ß read(___r, ___opts))
        )
    )

    (defn #_"boolean" EdnReader'isWhitespace [#_"int" ___ch]
        (ß (Character/isWhitespace(___ch) || ___ch == \,))
    )

    (defn #_"void" EdnReader'unread [#_"PushbackReader" ___r, #_"int" ___ch]
        (when (ß ___ch != -1)
            (try
                (ß ___r.unread(___ch))
                (catch IOException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
        )
        nil
    )

    (defn #_"int" EdnReader'read1 [#_"Reader" ___r]
        (try
            (ß ___r.read())
            (catch IOException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (§ def #_"Keyword" EdnReader'EOF (Keyword'intern-2 nil, "eof"))

    (defn #_"Object" EdnReader'read-2 [#_"PushbackReader" ___r, #_"IPersistentMap" ___opts]
        (ß read(___r, !___opts.containsKey(EdnReader'EOF), ___opts.valAt(EdnReader'EOF), false, ___opts))
    )

    (defn #_"Object" EdnReader'read-5 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts]
        (try
            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (when ___eofIsError
                            (throw (Util'runtimeException-1 "EOF while reading"))
                        )
                        (§ return ___eofValue)
                    )

                    (when (Character/isDigit ___ch)
                        (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                            (when (ß RT'suppressRead())
                                (§ return nil)
                            )
                            (§ return ___n)
                        )
                    )

                    (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                        (when (some? ___macroFn)
                            (let [#_"Object" ___ret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts))]
                                (when (ß RT'suppressRead())
                                    (§ return nil)
                                )
                                ;; no op macros return the reader
                                (when (ß ___ret == ___r)
                                    (§ continue )
                                )
                                (§ return ___ret)
                            )
                        )

                        (when (ß ___ch == \+ || ___ch == \-)
                            (let [#_"int" ___ch2 (ß read1(___r))]
                                (when (Character/isDigit ___ch2)
                                    (ß unread(___r, ___ch2))
                                    (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                                        (when (ß RT'suppressRead())
                                            (§ return nil)
                                        )
                                        (§ return ___n)
                                    )
                                )
                                (ß unread(___r, ___ch2))
                            )
                        )

                        (let [#_"String" ___token (ß readToken(___r, (char) ___ch, true))]
                            (when (ß RT'suppressRead())
                                (§ return nil)
                            )
                            (§ return (ß interpretToken(___token)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (when (ß ___isRecursive || !(___r instanceof LineNumberingPushbackReader))
                    (throw (Util'sneakyThrow ___e))
                )
                (let [#_"LineNumberingPushbackReader" ___rdr (ß (LineNumberingPushbackReader) ___r)]
                    (throw (ß EdnReaderException'new(___rdr.getLineNumber(), ___rdr.getColumnNumber(), ___e)))
                )
            )
        )
    )

    (defn- #_"String" EdnReader'readToken [#_"PushbackReader" ___r, #_"char" ___initch, #_"boolean" ___leadConstituent]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (when (ß ___leadConstituent && nonConstituent(___initch))
                (throw (Util'runtimeException-1 (str "Invalid leading character: " (ß (char)___initch))))
            )

            (ß ___sb.append(___initch))

            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (cond (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                        (do
                            (ß unread(___r, ___ch))
                            (§ return (ß ___sb.toString()))
                        )
                        (ß nonConstituent(___ch))
                        (do
                            (throw (Util'runtimeException-1 (str "Invalid constituent character: " (ß (char)___ch))))
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )
        )
    )

    (defn- #_"Object" EdnReader'readNumber [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (ß ___sb.append(___initch))

            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || isMacro(___ch))
                        (ß unread(___r, ___ch))
                        (§ break )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )

            (let [#_"String" ___s (ß ___sb.toString())]
                (let [#_"Object" ___n (ß matchNumber(___s))]
                    (when (nil? ___n)
                        (throw (NumberFormatException. (str "Invalid number: " ___s)))
                    )
                    ___n
                )
            )
        )
    )

    (defn- #_"int" EdnReader'readUnicodeChar-4 [#_"String" ___token, #_"int" ___offset, #_"int" ___length, #_"int" ___base]
        (when (ß ___token.length() != ___offset + ___length)
            (throw (IllegalArgumentException. (str "Invalid unicode character: \\" ___token)))
        )
        (let [#_"int" ___uc 0]
            (loop-when-recur [#_"int" ___i ___offset] (ß ___i < ___offset + ___length) [(inc ___i)]
                (let [#_"int" ___d (ß Character/digit(___token.charAt(___i), ___base))]
                    (when (ß ___d == -1)
                        (throw (IllegalArgumentException. (str "Invalid digit: " (ß ___token.charAt(___i)))))
                    )
                    (§ ass ___uc (ß ___uc * ___base + ___d))
                )
            )
            (ß (char) ___uc)
        )
    )

    (defn- #_"int" EdnReader'readUnicodeChar-5 [#_"PushbackReader" ___r, #_"int" ___initch, #_"int" ___base, #_"int" ___length, #_"boolean" ___exact]
        (let [#_"int" ___uc (Character/digit ___initch, ___base)]
            (when (ß ___uc == -1)
                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___initch))))
            )
            (let [#_"int" ___i 1]
                (loop-when-recur [___i ___i] (< ___i ___length) [(inc ___i)]
                    (let [#_"int" ___ch (ß read1(___r))]
                        (when (ß ___ch == -1 || isWhitespace(___ch) || isMacro(___ch))
                            (ß unread(___r, ___ch))
                            (§ break )
                        )
                        (let [#_"int" ___d (Character/digit ___ch, ___base)]
                            (when (ß ___d == -1)
                                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___ch))))
                            )
                            (§ ass ___uc (ß ___uc * ___base + ___d))
                        )
                    )
                )
                (when (ß ___i != ___length && ___exact)
                    (throw (IllegalArgumentException. (str "Invalid character length: " ___i ", should be: " ___length)))
                )
                ___uc
            )
        )
    )

    (defn- #_"Object" EdnReader'interpretToken [#_"String" ___s]
        (cond (ß ___s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß ___s.equals("true"))
            (do
                (§ return RT'T)
            )
            (ß ___s.equals("false"))
            (do
                (§ return RT'F)
            )
        )

        (let [#_"Object" ___ret nil]
            (§ ass ___ret (ß matchSymbol(___s)))
            (when (some? ___ret)
                (§ return ___ret)
            )

            (throw (Util'runtimeException-1 (str "Invalid token: " ___s)))
        )
    )

    (defn- #_"Object" EdnReader'matchSymbol [#_"String" ___s]
        (let [#_"Matcher" ___m (ß symbolPat.matcher(___s))]
            (when (ß ___m.matches())
                (let [#_"int" ___gc (ß ___m.groupCount())]
                    (let [#_"String" ___ns (ß ___m.group(1))]
                        (let [#_"String" ___name (ß ___m.group(2))]
                            (when (ß ___ns != nil && ___ns.endsWith(":/") || ___name.endsWith(":") || ___s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß ___s.startsWith("::"))
                                (§ return nil)
                            )
                            (let [#_"boolean" ___isKeyword (ß ___s.charAt(0) == \:)]
                                (let [#_"Symbol" ___sym (ß Symbol'intern-1(___s.substring(___isKeyword ? 1 :or 0)))]
                                    (when ___isKeyword
                                        (§ return (Keyword'intern ___sym))
                                    )
                                    (§ return ___sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn- #_"Object" EdnReader'matchNumber [#_"String" ___s]
        (let [#_"Matcher" ___m (ß intPat.matcher(___s))]
            (when (ß ___m.matches())
                (when (ß ___m.group(2) != nil)
                    (when (ß ___m.group(8) != nil)
                        (§ return BigInt'ZERO)
                    )
                    (§ return (Numbers'num-1l 0))
                )
                (let [#_"boolean" ___negate (ß ___m.group(1).equals("-"))]
                    (§ let [#_"String" ___n]
                        (let [#_"int" ___radix 10]
                            (cond (some? (§ ass ___n (ß ___m.group(3))))
                                (do
                                    (§ ass ___radix 10)
                                )
                                (some? (§ ass ___n (ß ___m.group(4))))
                                (do
                                    (§ ass ___radix 16)
                                )
                                (some? (§ ass ___n (ß ___m.group(5))))
                                (do
                                    (§ ass ___radix 8)
                                )
                                (some? (§ ass ___n (ß ___m.group(7))))
                                (do
                                    (§ ass ___radix (ß Integer/parseInt(___m.group(6))))
                                )
                            )
                            (when (nil? ___n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" ___bn (BigInteger. ___n, ___radix)]
                                (when ___negate
                                    (§ ass ___bn (ß ___bn.negate()))
                                )
                                (when (ß ___m.group(8) != nil)
                                    (§ return (BigInt'fromBigInteger ___bn))
                                )
                                (§ return (ß (___bn.bitLength() < 64) ? Numbers'num-1l(___bn.longValue()) :or BigInt'fromBigInteger(___bn)))
                            )
                        )
                    )
                )
            )
            (§ ass ___m (ß floatPat.matcher(___s)))
            (when (ß ___m.matches())
                (when (ß ___m.group(4) != nil)
                    (§ return (§ unsure BigDecimal. (ß ___m.group(1))))
                )
                (§ return (Double/parseDouble ___s))
            )
            (§ ass ___m (ß ratioPat.matcher(___s)))
            (when (ß ___m.matches())
                (let [#_"String" ___numerator (ß ___m.group(1))]
                    (when (ß ___numerator.startsWith("+"))
                        (§ ass ___numerator (ß ___numerator.substring(1)))
                    )

                    (§ return (ß Numbers'divide-2oo(Numbers'reduceBigInt(BigInt'fromBigInteger((BigInteger. ___numerator))), Numbers'reduceBigInt(BigInt'fromBigInteger((BigInteger. (§ pars ___m.group(2))))))))
                )
            )
            nil
        )
    )

    (defn- #_"IFn" EdnReader'getMacro [#_"int" ___ch]
        (when (ß ___ch < macros.length)
            (§ return (ß macros[___ch]))
        )
        nil
    )

    (defn- #_"boolean" EdnReader'isMacro [#_"int" ___ch]
        (ß (___ch < macros.length && macros[___ch] != nil))
    )

    (defn- #_"boolean" EdnReader'isTerminatingMacro [#_"int" ___ch]
        (ß (___ch != \# && ___ch != \' && isMacro(___ch)))
    )

    (defn #_"List" EdnReader'readDelimitedList [#_"char" ___delim, #_"PushbackReader" ___r, #_"boolean" ___isRecursive, #_"Object" ___opts]
        (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) ___r).getLineNumber() :or -1)]
            (let [#_"ArrayList" ___a (ArrayList.)]
                (while true
                    (let [#_"int" ___ch (ß read1(___r))]
                        (while (ß isWhitespace(___ch))
                            (§ ass ___ch (ß read1(___r)))
                        )

                        (when (ß ___ch == -1)
                            (if (< ___firstline 0)
                                (do
                                    (throw (Util'runtimeException-1 "EOF while reading"))
                                )
                                (do
                                    (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                )
                            )
                        )

                        (when (ß ___ch == ___delim)
                            (§ break )
                        )

                        (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                            (if (some? ___macroFn)
                                (do
                                    (let [#_"Object" ___mret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts))]
                                        ;; no op macros return the reader
                                        (when (ß ___mret != ___r)
                                            (ß ___a.add(___mret))
                                        )
                                    )
                                )
                                (do
                                    (ß unread(___r, ___ch))

                                    (let [#_"Object" ___o (ß read(___r, true, nil, ___isRecursive, ___opts))]
                                        (when (ß ___o != ___r)
                                            (ß ___a.add(___o))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                ___a
            )
        )
    )
)
)

(java-ns cloiure.lang.EnumerationSeq

(§ import java.io.IOException)
(§ import java.util.Enumeration)

(class-ns EnumerationSeqState
    (defn- #_"EnumerationSeqState" EnumerationSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"EnumerationSeqState" EnumerationSeqState'new []
        (EnumerationSeqState'init)
    )
)

(class-ns EnumerationSeq (§ extends ASeq)
    (defn #_"EnumerationSeq" EnumerationSeq'create [#_"Enumeration" ___iter]
        (when (ß ___iter.hasMoreElements())
            (§ return (EnumerationSeq'new-1 ___iter))
        )
        nil
    )

    (defn- #_"EnumerationSeq" EnumerationSeq'init []
        (hash-map
            #_"Enumeration" :iter nil
            #_"EnumerationSeqState" :state nil
        )
    )

    (defn #_"EnumerationSeq" EnumerationSeq'new-1 [#_"Enumeration" ___iter]
        (let [this (merge (ASeq'new) (EnumerationSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) (EnumerationSeqState'new))
            (§ ass (ß (:state this).val) (:state this))
            (§ ass (ß (:state this)._rest) (:state this))
            this
        )
    )

    (defn #_"EnumerationSeq" EnumerationSeq'new-3 [#_"IPersistentMap" ___meta, #_"Enumeration" ___iter, #_"EnumerationSeqState" ___state]
        (let [this (merge (ASeq'new ___meta) (EnumerationSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) ___state)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"EnumerationSeq" this]
        (when (ß (:state this).val == (:state this))
            (§ sync (:state this)
                (when (ß (:state this).val == (:state this))
                    (§ ass (ß (:state this).val) (ß (:iter this).nextElement()))
                )
            )
        )
        (ß (:state this).val)
    )

    #_method
    (§ defn #_"ISeq" next [#_"EnumerationSeq" this]
        (when (ß (:state this)._rest == (:state this))
            (§ sync (:state this)
                (when (ß (:state this)._rest == (:state this))
                    (ß first())
                    (§ ass (ß (:state this)._rest) (EnumerationSeq'create (:iter this)))
                )
            )
        )
        (ß (ISeq) (:state this)._rest)
    )

    #_method
    (§ defn #_"EnumerationSeq" withMeta [#_"EnumerationSeq" this, #_"IPersistentMap" ___meta]
        (EnumerationSeq'new-3 ___meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.ExceptionInfo

;;;
 ; Exception that carries data (a map) as additional payload. Cloiure programs that need
 ; richer semantics for exceptions should use this in lieu of defining project-specific
 ; exception classes.
 ;;
(class-ns ExceptionInfo (§ extends RuntimeException) (§ implements IExceptionInfo)
    (defn- #_"ExceptionInfo" ExceptionInfo'init []
        (hash-map
            #_"IPersistentMap" :data nil
        )
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-2 [#_"String" ___s, #_"IPersistentMap" ___data]
        (ExceptionInfo'new-3 ___s, ___data, nil)
    )

    (defn #_"ExceptionInfo" ExceptionInfo'new-3 [#_"String" ___s, #_"IPersistentMap" ___data, #_"Throwable" ___throwable]
        (let [this (merge (§ foreign RuntimeException'new ___s, ___throwable) (ExceptionInfo'init))]
            ;; nil cause is equivalent to not passing a cause
            (if (some? ___data)
                (do
                    (§ ass (:data this) ___data)
                )
                (do
                    (throw (IllegalArgumentException. "Additional data must be non-nil."))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" getData [#_"ExceptionInfo" this]
        (:data this)
    )

    #_method
    (§ defn #_"String" toString [#_"ExceptionInfo" this]
        (ß "cloiure.lang.ExceptionInfo: " + getMessage() + " " + (:data this).toString())
    )
)
)

(java-ns cloiure.lang.Fn

(defprotocol Fn
)
)

(java-ns cloiure.lang.FnLoaderThunk

(class-ns FnLoaderThunk (§ extends RestFn)
    (defn- #_"FnLoaderThunk" FnLoaderThunk'init []
        (hash-map
            #_"Var" :v nil
            #_"ClassLoader" :loader nil
            #_"String" :fnClassName nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"FnLoaderThunk" FnLoaderThunk'new [#_"Var" ___v, #_"String" ___fnClassName]
        (let [this (merge (RestFn'new) (FnLoaderThunk'init))]
            (§ ass (:v this) ___v)
            (§ ass (:loader this) (ß (ClassLoader) RT'FN_LOADER_VAR.get()))
            (§ ass (:fnClassName this) ___fnClassName)
            (§ ass (:fn this) nil)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" ___arg1]
        (ß load())
        (ß (:fn this).invoke(___arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß load())
        (ß (:fn this).invoke(___arg1, ___arg2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnLoaderThunk" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß load())
        (ß (:fn this).invoke(___arg1, ___arg2, ___arg3))
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"FnLoaderThunk" this, #_"Object" ___args]
        (ß load())
        (ß (:fn this).applyTo((ISeq) ___args))
    )

    #_method
    (§ defn- #_"void" load [#_"FnLoaderThunk" this]
        (when (nil? (:fn this))
            (try
                (§ ass (:fn this) (ß (IFn) Class/forName((:fnClassName this), true, (:loader this)).newInstance()))
                (catch Exception ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
            (§ ass (ß (:v this).root) (:fn this))
        )
        nil
    )

    #_method
    (§ defn #_"int" getRequiredArity [#_"FnLoaderThunk" this]
        0
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"FnLoaderThunk" this, #_"IPersistentMap" ___meta]
        this
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"FnLoaderThunk" this]
        nil
    )
)
)

(java-ns cloiure.lang.IAtom

(defprotocol IAtom
    #_abstract
    (#_"Object" IAtom'''swap2 [#_"IAtom" this, #_"IFn" ___f])
    #_abstract
    (#_"Object" IAtom'''swap3 [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___arg])
    #_abstract
    (#_"Object" IAtom'''swap4 [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"Object" IAtom'''swap5 [#_"IAtom" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args])
    #_abstract
    (#_"boolean" IAtom'''compareAndSet [#_"IAtom" this, #_"Object" ___oldv, #_"Object" ___newv])
    #_abstract
    (#_"Object" IAtom'''reset [#_"IAtom" this, #_"Object" ___newval])
)
)

(java-ns cloiure.lang.IAtom2

(defprotocol IAtom2 #_(§ extends IAtom)
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals2 [#_"IAtom2" this, #_"IFn" ___f])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals3 [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___arg])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals4 [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"IPersistentVector" IAtom2'''swapVals5 [#_"IAtom2" this, #_"IFn" ___f, #_"Object" ___x, #_"Object" ___y, #_"ISeq" ___args])
    #_abstract
    (#_"IPersistentVector" IAtom2'''resetVals [#_"IAtom2" this, #_"Object" ___newv])
)
)

(java-ns cloiure.lang.IBlockingDeref

(defprotocol IBlockingDeref
    #_abstract
    (#_"Object" IBlockingDeref'''deref [#_"IBlockingDeref" this, #_"long" ___ms, #_"Object" ___timeoutValue])
)
)

(java-ns cloiure.lang.IChunk

(defprotocol IChunk #_(§ extends Indexed)
    #_abstract
    (#_"IChunk" IChunk'''dropFirst [#_"IChunk" this])
    #_abstract
    (#_"Object" IChunk'''reduce [#_"IChunk" this, #_"IFn" ___f, #_"Object" ___start])
)
)

(java-ns cloiure.lang.IChunkedSeq

(defprotocol IChunkedSeq #_(§ extends ISeq, Sequential)
    #_abstract
    (#_"IChunk" IChunkedSeq'''chunkedFirst [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''chunkedNext [#_"IChunkedSeq" this])
    #_abstract
    (#_"ISeq" IChunkedSeq'''chunkedMore [#_"IChunkedSeq" this])
)
)

(java-ns cloiure.lang.IDeref

(defprotocol IDeref
    #_abstract
    (#_"Object" IDeref'''deref [#_"IDeref" this])
)
)

(java-ns cloiure.lang.IEditableCollection

(defprotocol IEditableCollection
    #_abstract
    (#_"ITransientCollection" IEditableCollection'''asTransient [#_"IEditableCollection" this])
)
)

(java-ns cloiure.lang.IExceptionInfo

;;;
 ; Interface for exceptions that carry data (a map) as additional payload. Cloiure
 ; programs that need richer semantics for exceptions should use this in lieu of
 ; defining project-specific exception classes.
 ;;
(defprotocol IExceptionInfo
    #_abstract
    (#_"IPersistentMap" IExceptionInfo'''getData [#_"IExceptionInfo" this])
)
)

(java-ns cloiure.lang.IFn

(§ import java.util.concurrent.Callable)

(defprotocol L
    #_abstract
    (#_"long" L'''invokePrim [#_"L" this])
)

(defprotocol D
    #_abstract
    (#_"double" D'''invokePrim [#_"D" this])
)

(defprotocol OL
    #_abstract
    (#_"long" OL'''invokePrim [#_"OL" this, #_"Object" ___arg0])
)

(defprotocol OD
    #_abstract
    (#_"double" OD'''invokePrim [#_"OD" this, #_"Object" ___arg0])
)

(defprotocol LO
    #_abstract
    (#_"Object" LO'''invokePrim [#_"LO" this, #_"long" ___arg0])
)

(defprotocol LL
    #_abstract
    (#_"long" LL'''invokePrim [#_"LL" this, #_"long" ___arg0])
)

(defprotocol LD
    #_abstract
    (#_"double" LD'''invokePrim [#_"LD" this, #_"long" ___arg0])
)

(defprotocol DO
    #_abstract
    (#_"Object" DO'''invokePrim [#_"DO" this, #_"double" ___arg0])
)

(defprotocol DL
    #_abstract
    (#_"long" DL'''invokePrim [#_"DL" this, #_"double" ___arg0])
)

(defprotocol DD
    #_abstract
    (#_"double" DD'''invokePrim [#_"DD" this, #_"double" ___arg0])
)

(defprotocol OOL
    #_abstract
    (#_"long" OOL'''invokePrim [#_"OOL" this, #_"Object" ___arg0, #_"Object" ___arg1])
)

(defprotocol OOD
    #_abstract
    (#_"double" OOD'''invokePrim [#_"OOD" this, #_"Object" ___arg0, #_"Object" ___arg1])
)

(defprotocol OLO
    #_abstract
    (#_"Object" OLO'''invokePrim [#_"OLO" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(defprotocol OLL
    #_abstract
    (#_"long" OLL'''invokePrim [#_"OLL" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(defprotocol OLD
    #_abstract
    (#_"double" OLD'''invokePrim [#_"OLD" this, #_"Object" ___arg0, #_"long" ___arg1])
)

(defprotocol ODO
    #_abstract
    (#_"Object" ODO'''invokePrim [#_"ODO" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(defprotocol ODL
    #_abstract
    (#_"long" ODL'''invokePrim [#_"ODL" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(defprotocol ODD
    #_abstract
    (#_"double" ODD'''invokePrim [#_"ODD" this, #_"Object" ___arg0, #_"double" ___arg1])
)

(defprotocol LOO
    #_abstract
    (#_"Object" LOO'''invokePrim [#_"LOO" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(defprotocol LOL
    #_abstract
    (#_"long" LOL'''invokePrim [#_"LOL" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(defprotocol LOD
    #_abstract
    (#_"double" LOD'''invokePrim [#_"LOD" this, #_"long" ___arg0, #_"Object" ___arg1])
)

(defprotocol LLO
    #_abstract
    (#_"Object" LLO'''invokePrim [#_"LLO" this, #_"long" ___arg0, #_"long" ___arg1])
)

(defprotocol LLL
    #_abstract
    (#_"long" LLL'''invokePrim [#_"LLL" this, #_"long" ___arg0, #_"long" ___arg1])
)

(defprotocol LLD
    #_abstract
    (#_"double" LLD'''invokePrim [#_"LLD" this, #_"long" ___arg0, #_"long" ___arg1])
)

(defprotocol LDO
    #_abstract
    (#_"Object" LDO'''invokePrim [#_"LDO" this, #_"long" ___arg0, #_"double" ___arg1])
)

(defprotocol LDL
    #_abstract
    (#_"long" LDL'''invokePrim [#_"LDL" this, #_"long" ___arg0, #_"double" ___arg1])
)

(defprotocol LDD
    #_abstract
    (#_"double" LDD'''invokePrim [#_"LDD" this, #_"long" ___arg0, #_"double" ___arg1])
)

(defprotocol DOO
    #_abstract
    (#_"Object" DOO'''invokePrim [#_"DOO" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(defprotocol DOL
    #_abstract
    (#_"long" DOL'''invokePrim [#_"DOL" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(defprotocol DOD
    #_abstract
    (#_"double" DOD'''invokePrim [#_"DOD" this, #_"double" ___arg0, #_"Object" ___arg1])
)

(defprotocol DLO
    #_abstract
    (#_"Object" DLO'''invokePrim [#_"DLO" this, #_"double" ___arg0, #_"long" ___arg1])
)

(defprotocol DLL
    #_abstract
    (#_"long" DLL'''invokePrim [#_"DLL" this, #_"double" ___arg0, #_"long" ___arg1])
)

(defprotocol DLD
    #_abstract
    (#_"double" DLD'''invokePrim [#_"DLD" this, #_"double" ___arg0, #_"long" ___arg1])
)

(defprotocol DDO
    #_abstract
    (#_"Object" DDO'''invokePrim [#_"DDO" this, #_"double" ___arg0, #_"double" ___arg1])
)

(defprotocol DDL
    #_abstract
    (#_"long" DDL'''invokePrim [#_"DDL" this, #_"double" ___arg0, #_"double" ___arg1])
)

(defprotocol DDD
    #_abstract
    (#_"double" DDD'''invokePrim [#_"DDD" this, #_"double" ___arg0, #_"double" ___arg1])
)

(defprotocol OOOL
    #_abstract
    (#_"long" OOOL'''invokePrim [#_"OOOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol OOOD
    #_abstract
    (#_"double" OOOD'''invokePrim [#_"OOOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol OOLO
    #_abstract
    (#_"Object" OOLO'''invokePrim [#_"OOLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol OOLL
    #_abstract
    (#_"long" OOLL'''invokePrim [#_"OOLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol OOLD
    #_abstract
    (#_"double" OOLD'''invokePrim [#_"OOLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol OODO
    #_abstract
    (#_"Object" OODO'''invokePrim [#_"OODO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol OODL
    #_abstract
    (#_"long" OODL'''invokePrim [#_"OODL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol OODD
    #_abstract
    (#_"double" OODD'''invokePrim [#_"OODD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol OLOO
    #_abstract
    (#_"Object" OLOO'''invokePrim [#_"OLOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol OLOL
    #_abstract
    (#_"long" OLOL'''invokePrim [#_"OLOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol OLOD
    #_abstract
    (#_"double" OLOD'''invokePrim [#_"OLOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol OLLO
    #_abstract
    (#_"Object" OLLO'''invokePrim [#_"OLLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol OLLL
    #_abstract
    (#_"long" OLLL'''invokePrim [#_"OLLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol OLLD
    #_abstract
    (#_"double" OLLD'''invokePrim [#_"OLLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol OLDO
    #_abstract
    (#_"Object" OLDO'''invokePrim [#_"OLDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol OLDL
    #_abstract
    (#_"long" OLDL'''invokePrim [#_"OLDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol OLDD
    #_abstract
    (#_"double" OLDD'''invokePrim [#_"OLDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol ODOO
    #_abstract
    (#_"Object" ODOO'''invokePrim [#_"ODOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol ODOL
    #_abstract
    (#_"long" ODOL'''invokePrim [#_"ODOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol ODOD
    #_abstract
    (#_"double" ODOD'''invokePrim [#_"ODOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol ODLO
    #_abstract
    (#_"Object" ODLO'''invokePrim [#_"ODLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol ODLL
    #_abstract
    (#_"long" ODLL'''invokePrim [#_"ODLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol ODLD
    #_abstract
    (#_"double" ODLD'''invokePrim [#_"ODLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol ODDO
    #_abstract
    (#_"Object" ODDO'''invokePrim [#_"ODDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol ODDL
    #_abstract
    (#_"long" ODDL'''invokePrim [#_"ODDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol ODDD
    #_abstract
    (#_"double" ODDD'''invokePrim [#_"ODDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol LOOO
    #_abstract
    (#_"Object" LOOO'''invokePrim [#_"LOOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol LOOL
    #_abstract
    (#_"long" LOOL'''invokePrim [#_"LOOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol LOOD
    #_abstract
    (#_"double" LOOD'''invokePrim [#_"LOOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol LOLO
    #_abstract
    (#_"Object" LOLO'''invokePrim [#_"LOLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol LOLL
    #_abstract
    (#_"long" LOLL'''invokePrim [#_"LOLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol LOLD
    #_abstract
    (#_"double" LOLD'''invokePrim [#_"LOLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol LODO
    #_abstract
    (#_"Object" LODO'''invokePrim [#_"LODO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol LODL
    #_abstract
    (#_"long" LODL'''invokePrim [#_"LODL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol LODD
    #_abstract
    (#_"double" LODD'''invokePrim [#_"LODD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol LLOO
    #_abstract
    (#_"Object" LLOO'''invokePrim [#_"LLOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol LLOL
    #_abstract
    (#_"long" LLOL'''invokePrim [#_"LLOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol LLOD
    #_abstract
    (#_"double" LLOD'''invokePrim [#_"LLOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol LLLO
    #_abstract
    (#_"Object" LLLO'''invokePrim [#_"LLLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol LLLL
    #_abstract
    (#_"long" LLLL'''invokePrim [#_"LLLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol LLLD
    #_abstract
    (#_"double" LLLD'''invokePrim [#_"LLLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol LLDO
    #_abstract
    (#_"Object" LLDO'''invokePrim [#_"LLDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol LLDL
    #_abstract
    (#_"long" LLDL'''invokePrim [#_"LLDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol LLDD
    #_abstract
    (#_"double" LLDD'''invokePrim [#_"LLDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol LDOO
    #_abstract
    (#_"Object" LDOO'''invokePrim [#_"LDOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol LDOL
    #_abstract
    (#_"long" LDOL'''invokePrim [#_"LDOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol LDOD
    #_abstract
    (#_"double" LDOD'''invokePrim [#_"LDOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol LDLO
    #_abstract
    (#_"Object" LDLO'''invokePrim [#_"LDLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol LDLL
    #_abstract
    (#_"long" LDLL'''invokePrim [#_"LDLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol LDLD
    #_abstract
    (#_"double" LDLD'''invokePrim [#_"LDLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol LDDO
    #_abstract
    (#_"Object" LDDO'''invokePrim [#_"LDDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol LDDL
    #_abstract
    (#_"long" LDDL'''invokePrim [#_"LDDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol LDDD
    #_abstract
    (#_"double" LDDD'''invokePrim [#_"LDDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol DOOO
    #_abstract
    (#_"Object" DOOO'''invokePrim [#_"DOOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol DOOL
    #_abstract
    (#_"long" DOOL'''invokePrim [#_"DOOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol DOOD
    #_abstract
    (#_"double" DOOD'''invokePrim [#_"DOOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2])
)

(defprotocol DOLO
    #_abstract
    (#_"Object" DOLO'''invokePrim [#_"DOLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol DOLL
    #_abstract
    (#_"long" DOLL'''invokePrim [#_"DOLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol DOLD
    #_abstract
    (#_"double" DOLD'''invokePrim [#_"DOLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2])
)

(defprotocol DODO
    #_abstract
    (#_"Object" DODO'''invokePrim [#_"DODO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol DODL
    #_abstract
    (#_"long" DODL'''invokePrim [#_"DODL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol DODD
    #_abstract
    (#_"double" DODD'''invokePrim [#_"DODD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2])
)

(defprotocol DLOO
    #_abstract
    (#_"Object" DLOO'''invokePrim [#_"DLOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol DLOL
    #_abstract
    (#_"long" DLOL'''invokePrim [#_"DLOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol DLOD
    #_abstract
    (#_"double" DLOD'''invokePrim [#_"DLOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2])
)

(defprotocol DLLO
    #_abstract
    (#_"Object" DLLO'''invokePrim [#_"DLLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol DLLL
    #_abstract
    (#_"long" DLLL'''invokePrim [#_"DLLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol DLLD
    #_abstract
    (#_"double" DLLD'''invokePrim [#_"DLLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2])
)

(defprotocol DLDO
    #_abstract
    (#_"Object" DLDO'''invokePrim [#_"DLDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol DLDL
    #_abstract
    (#_"long" DLDL'''invokePrim [#_"DLDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol DLDD
    #_abstract
    (#_"double" DLDD'''invokePrim [#_"DLDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2])
)

(defprotocol DDOO
    #_abstract
    (#_"Object" DDOO'''invokePrim [#_"DDOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol DDOL
    #_abstract
    (#_"long" DDOL'''invokePrim [#_"DDOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol DDOD
    #_abstract
    (#_"double" DDOD'''invokePrim [#_"DDOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2])
)

(defprotocol DDLO
    #_abstract
    (#_"Object" DDLO'''invokePrim [#_"DDLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol DDLL
    #_abstract
    (#_"long" DDLL'''invokePrim [#_"DDLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol DDLD
    #_abstract
    (#_"double" DDLD'''invokePrim [#_"DDLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2])
)

(defprotocol DDDO
    #_abstract
    (#_"Object" DDDO'''invokePrim [#_"DDDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol DDDL
    #_abstract
    (#_"long" DDDL'''invokePrim [#_"DDDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol DDDD
    #_abstract
    (#_"double" DDDD'''invokePrim [#_"DDDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2])
)

(defprotocol OOOOL
    #_abstract
    (#_"long" OOOOL'''invokePrim [#_"OOOOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOOOD
    #_abstract
    (#_"double" OOOOD'''invokePrim [#_"OOOOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOOLO
    #_abstract
    (#_"Object" OOOLO'''invokePrim [#_"OOOLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OOOLL
    #_abstract
    (#_"long" OOOLL'''invokePrim [#_"OOOLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OOOLD
    #_abstract
    (#_"double" OOOLD'''invokePrim [#_"OOOLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OOODO
    #_abstract
    (#_"Object" OOODO'''invokePrim [#_"OOODO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OOODL
    #_abstract
    (#_"long" OOODL'''invokePrim [#_"OOODL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OOODD
    #_abstract
    (#_"double" OOODD'''invokePrim [#_"OOODD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OOLOO
    #_abstract
    (#_"Object" OOLOO'''invokePrim [#_"OOLOO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOLOL
    #_abstract
    (#_"long" OOLOL'''invokePrim [#_"OOLOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOLOD
    #_abstract
    (#_"double" OOLOD'''invokePrim [#_"OOLOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OOLLO
    #_abstract
    (#_"Object" OOLLO'''invokePrim [#_"OOLLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OOLLL
    #_abstract
    (#_"long" OOLLL'''invokePrim [#_"OOLLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OOLLD
    #_abstract
    (#_"double" OOLLD'''invokePrim [#_"OOLLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OOLDO
    #_abstract
    (#_"Object" OOLDO'''invokePrim [#_"OOLDO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OOLDL
    #_abstract
    (#_"long" OOLDL'''invokePrim [#_"OOLDL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OOLDD
    #_abstract
    (#_"double" OOLDD'''invokePrim [#_"OOLDD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OODOO
    #_abstract
    (#_"Object" OODOO'''invokePrim [#_"OODOO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OODOL
    #_abstract
    (#_"long" OODOL'''invokePrim [#_"OODOL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OODOD
    #_abstract
    (#_"double" OODOD'''invokePrim [#_"OODOD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OODLO
    #_abstract
    (#_"Object" OODLO'''invokePrim [#_"OODLO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OODLL
    #_abstract
    (#_"long" OODLL'''invokePrim [#_"OODLL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OODLD
    #_abstract
    (#_"double" OODLD'''invokePrim [#_"OODLD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OODDO
    #_abstract
    (#_"Object" OODDO'''invokePrim [#_"OODDO" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OODDL
    #_abstract
    (#_"long" OODDL'''invokePrim [#_"OODDL" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OODDD
    #_abstract
    (#_"double" OODDD'''invokePrim [#_"OODDD" this, #_"Object" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OLOOO
    #_abstract
    (#_"Object" OLOOO'''invokePrim [#_"OLOOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLOOL
    #_abstract
    (#_"long" OLOOL'''invokePrim [#_"OLOOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLOOD
    #_abstract
    (#_"double" OLOOD'''invokePrim [#_"OLOOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLOLO
    #_abstract
    (#_"Object" OLOLO'''invokePrim [#_"OLOLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OLOLL
    #_abstract
    (#_"long" OLOLL'''invokePrim [#_"OLOLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OLOLD
    #_abstract
    (#_"double" OLOLD'''invokePrim [#_"OLOLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol OLODO
    #_abstract
    (#_"Object" OLODO'''invokePrim [#_"OLODO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OLODL
    #_abstract
    (#_"long" OLODL'''invokePrim [#_"OLODL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OLODD
    #_abstract
    (#_"double" OLODD'''invokePrim [#_"OLODD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol OLLOO
    #_abstract
    (#_"Object" OLLOO'''invokePrim [#_"OLLOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLLOL
    #_abstract
    (#_"long" OLLOL'''invokePrim [#_"OLLOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLLOD
    #_abstract
    (#_"double" OLLOD'''invokePrim [#_"OLLOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLLLO
    #_abstract
    (#_"Object" OLLLO'''invokePrim [#_"OLLLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OLLLL
    #_abstract
    (#_"long" OLLLL'''invokePrim [#_"OLLLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OLLLD
    #_abstract
    (#_"double" OLLLD'''invokePrim [#_"OLLLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol OLLDO
    #_abstract
    (#_"Object" OLLDO'''invokePrim [#_"OLLDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OLLDL
    #_abstract
    (#_"long" OLLDL'''invokePrim [#_"OLLDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OLLDD
    #_abstract
    (#_"double" OLLDD'''invokePrim [#_"OLLDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol OLDOO
    #_abstract
    (#_"Object" OLDOO'''invokePrim [#_"OLDOO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLDOL
    #_abstract
    (#_"long" OLDOL'''invokePrim [#_"OLDOL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLDOD
    #_abstract
    (#_"double" OLDOD'''invokePrim [#_"OLDOD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol OLDLO
    #_abstract
    (#_"Object" OLDLO'''invokePrim [#_"OLDLO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OLDLL
    #_abstract
    (#_"long" OLDLL'''invokePrim [#_"OLDLL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OLDLD
    #_abstract
    (#_"double" OLDLD'''invokePrim [#_"OLDLD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol OLDDO
    #_abstract
    (#_"Object" OLDDO'''invokePrim [#_"OLDDO" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OLDDL
    #_abstract
    (#_"long" OLDDL'''invokePrim [#_"OLDDL" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol OLDDD
    #_abstract
    (#_"double" OLDDD'''invokePrim [#_"OLDDD" this, #_"Object" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol ODOOO
    #_abstract
    (#_"Object" ODOOO'''invokePrim [#_"ODOOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODOOL
    #_abstract
    (#_"long" ODOOL'''invokePrim [#_"ODOOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODOOD
    #_abstract
    (#_"double" ODOOD'''invokePrim [#_"ODOOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODOLO
    #_abstract
    (#_"Object" ODOLO'''invokePrim [#_"ODOLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol ODOLL
    #_abstract
    (#_"long" ODOLL'''invokePrim [#_"ODOLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol ODOLD
    #_abstract
    (#_"double" ODOLD'''invokePrim [#_"ODOLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol ODODO
    #_abstract
    (#_"Object" ODODO'''invokePrim [#_"ODODO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol ODODL
    #_abstract
    (#_"long" ODODL'''invokePrim [#_"ODODL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol ODODD
    #_abstract
    (#_"double" ODODD'''invokePrim [#_"ODODD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol ODLOO
    #_abstract
    (#_"Object" ODLOO'''invokePrim [#_"ODLOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODLOL
    #_abstract
    (#_"long" ODLOL'''invokePrim [#_"ODLOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODLOD
    #_abstract
    (#_"double" ODLOD'''invokePrim [#_"ODLOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODLLO
    #_abstract
    (#_"Object" ODLLO'''invokePrim [#_"ODLLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol ODLLL
    #_abstract
    (#_"long" ODLLL'''invokePrim [#_"ODLLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol ODLLD
    #_abstract
    (#_"double" ODLLD'''invokePrim [#_"ODLLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol ODLDO
    #_abstract
    (#_"Object" ODLDO'''invokePrim [#_"ODLDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol ODLDL
    #_abstract
    (#_"long" ODLDL'''invokePrim [#_"ODLDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol ODLDD
    #_abstract
    (#_"double" ODLDD'''invokePrim [#_"ODLDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol ODDOO
    #_abstract
    (#_"Object" ODDOO'''invokePrim [#_"ODDOO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODDOL
    #_abstract
    (#_"long" ODDOL'''invokePrim [#_"ODDOL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODDOD
    #_abstract
    (#_"double" ODDOD'''invokePrim [#_"ODDOD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol ODDLO
    #_abstract
    (#_"Object" ODDLO'''invokePrim [#_"ODDLO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol ODDLL
    #_abstract
    (#_"long" ODDLL'''invokePrim [#_"ODDLL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol ODDLD
    #_abstract
    (#_"double" ODDLD'''invokePrim [#_"ODDLD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol ODDDO
    #_abstract
    (#_"Object" ODDDO'''invokePrim [#_"ODDDO" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol ODDDL
    #_abstract
    (#_"long" ODDDL'''invokePrim [#_"ODDDL" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol ODDDD
    #_abstract
    (#_"double" ODDDD'''invokePrim [#_"ODDDD" this, #_"Object" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LOOOO
    #_abstract
    (#_"Object" LOOOO'''invokePrim [#_"LOOOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOOOL
    #_abstract
    (#_"long" LOOOL'''invokePrim [#_"LOOOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOOOD
    #_abstract
    (#_"double" LOOOD'''invokePrim [#_"LOOOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOOLO
    #_abstract
    (#_"Object" LOOLO'''invokePrim [#_"LOOLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LOOLL
    #_abstract
    (#_"long" LOOLL'''invokePrim [#_"LOOLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LOOLD
    #_abstract
    (#_"double" LOOLD'''invokePrim [#_"LOOLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LOODO
    #_abstract
    (#_"Object" LOODO'''invokePrim [#_"LOODO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LOODL
    #_abstract
    (#_"long" LOODL'''invokePrim [#_"LOODL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LOODD
    #_abstract
    (#_"double" LOODD'''invokePrim [#_"LOODD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LOLOO
    #_abstract
    (#_"Object" LOLOO'''invokePrim [#_"LOLOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOLOL
    #_abstract
    (#_"long" LOLOL'''invokePrim [#_"LOLOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOLOD
    #_abstract
    (#_"double" LOLOD'''invokePrim [#_"LOLOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LOLLO
    #_abstract
    (#_"Object" LOLLO'''invokePrim [#_"LOLLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LOLLL
    #_abstract
    (#_"long" LOLLL'''invokePrim [#_"LOLLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LOLLD
    #_abstract
    (#_"double" LOLLD'''invokePrim [#_"LOLLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LOLDO
    #_abstract
    (#_"Object" LOLDO'''invokePrim [#_"LOLDO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LOLDL
    #_abstract
    (#_"long" LOLDL'''invokePrim [#_"LOLDL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LOLDD
    #_abstract
    (#_"double" LOLDD'''invokePrim [#_"LOLDD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LODOO
    #_abstract
    (#_"Object" LODOO'''invokePrim [#_"LODOO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LODOL
    #_abstract
    (#_"long" LODOL'''invokePrim [#_"LODOL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LODOD
    #_abstract
    (#_"double" LODOD'''invokePrim [#_"LODOD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LODLO
    #_abstract
    (#_"Object" LODLO'''invokePrim [#_"LODLO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LODLL
    #_abstract
    (#_"long" LODLL'''invokePrim [#_"LODLL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LODLD
    #_abstract
    (#_"double" LODLD'''invokePrim [#_"LODLD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LODDO
    #_abstract
    (#_"Object" LODDO'''invokePrim [#_"LODDO" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LODDL
    #_abstract
    (#_"long" LODDL'''invokePrim [#_"LODDL" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LODDD
    #_abstract
    (#_"double" LODDD'''invokePrim [#_"LODDD" this, #_"long" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LLOOO
    #_abstract
    (#_"Object" LLOOO'''invokePrim [#_"LLOOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLOOL
    #_abstract
    (#_"long" LLOOL'''invokePrim [#_"LLOOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLOOD
    #_abstract
    (#_"double" LLOOD'''invokePrim [#_"LLOOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLOLO
    #_abstract
    (#_"Object" LLOLO'''invokePrim [#_"LLOLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LLOLL
    #_abstract
    (#_"long" LLOLL'''invokePrim [#_"LLOLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LLOLD
    #_abstract
    (#_"double" LLOLD'''invokePrim [#_"LLOLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LLODO
    #_abstract
    (#_"Object" LLODO'''invokePrim [#_"LLODO" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LLODL
    #_abstract
    (#_"long" LLODL'''invokePrim [#_"LLODL" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LLODD
    #_abstract
    (#_"double" LLODD'''invokePrim [#_"LLODD" this, #_"long" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LLLOO
    #_abstract
    (#_"Object" LLLOO'''invokePrim [#_"LLLOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLLOL
    #_abstract
    (#_"long" LLLOL'''invokePrim [#_"LLLOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLLOD
    #_abstract
    (#_"double" LLLOD'''invokePrim [#_"LLLOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLLLO
    #_abstract
    (#_"Object" LLLLO'''invokePrim [#_"LLLLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LLLLL
    #_abstract
    (#_"long" LLLLL'''invokePrim [#_"LLLLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LLLLD
    #_abstract
    (#_"double" LLLLD'''invokePrim [#_"LLLLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LLLDO
    #_abstract
    (#_"Object" LLLDO'''invokePrim [#_"LLLDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LLLDL
    #_abstract
    (#_"long" LLLDL'''invokePrim [#_"LLLDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LLLDD
    #_abstract
    (#_"double" LLLDD'''invokePrim [#_"LLLDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LLDOO
    #_abstract
    (#_"Object" LLDOO'''invokePrim [#_"LLDOO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLDOL
    #_abstract
    (#_"long" LLDOL'''invokePrim [#_"LLDOL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLDOD
    #_abstract
    (#_"double" LLDOD'''invokePrim [#_"LLDOD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LLDLO
    #_abstract
    (#_"Object" LLDLO'''invokePrim [#_"LLDLO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LLDLL
    #_abstract
    (#_"long" LLDLL'''invokePrim [#_"LLDLL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LLDLD
    #_abstract
    (#_"double" LLDLD'''invokePrim [#_"LLDLD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LLDDO
    #_abstract
    (#_"Object" LLDDO'''invokePrim [#_"LLDDO" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LLDDL
    #_abstract
    (#_"long" LLDDL'''invokePrim [#_"LLDDL" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LLDDD
    #_abstract
    (#_"double" LLDDD'''invokePrim [#_"LLDDD" this, #_"long" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LDOOO
    #_abstract
    (#_"Object" LDOOO'''invokePrim [#_"LDOOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDOOL
    #_abstract
    (#_"long" LDOOL'''invokePrim [#_"LDOOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDOOD
    #_abstract
    (#_"double" LDOOD'''invokePrim [#_"LDOOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDOLO
    #_abstract
    (#_"Object" LDOLO'''invokePrim [#_"LDOLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LDOLL
    #_abstract
    (#_"long" LDOLL'''invokePrim [#_"LDOLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LDOLD
    #_abstract
    (#_"double" LDOLD'''invokePrim [#_"LDOLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol LDODO
    #_abstract
    (#_"Object" LDODO'''invokePrim [#_"LDODO" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LDODL
    #_abstract
    (#_"long" LDODL'''invokePrim [#_"LDODL" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LDODD
    #_abstract
    (#_"double" LDODD'''invokePrim [#_"LDODD" this, #_"long" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol LDLOO
    #_abstract
    (#_"Object" LDLOO'''invokePrim [#_"LDLOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDLOL
    #_abstract
    (#_"long" LDLOL'''invokePrim [#_"LDLOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDLOD
    #_abstract
    (#_"double" LDLOD'''invokePrim [#_"LDLOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDLLO
    #_abstract
    (#_"Object" LDLLO'''invokePrim [#_"LDLLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LDLLL
    #_abstract
    (#_"long" LDLLL'''invokePrim [#_"LDLLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LDLLD
    #_abstract
    (#_"double" LDLLD'''invokePrim [#_"LDLLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol LDLDO
    #_abstract
    (#_"Object" LDLDO'''invokePrim [#_"LDLDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LDLDL
    #_abstract
    (#_"long" LDLDL'''invokePrim [#_"LDLDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LDLDD
    #_abstract
    (#_"double" LDLDD'''invokePrim [#_"LDLDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol LDDOO
    #_abstract
    (#_"Object" LDDOO'''invokePrim [#_"LDDOO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDDOL
    #_abstract
    (#_"long" LDDOL'''invokePrim [#_"LDDOL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDDOD
    #_abstract
    (#_"double" LDDOD'''invokePrim [#_"LDDOD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol LDDLO
    #_abstract
    (#_"Object" LDDLO'''invokePrim [#_"LDDLO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LDDLL
    #_abstract
    (#_"long" LDDLL'''invokePrim [#_"LDDLL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LDDLD
    #_abstract
    (#_"double" LDDLD'''invokePrim [#_"LDDLD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol LDDDO
    #_abstract
    (#_"Object" LDDDO'''invokePrim [#_"LDDDO" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LDDDL
    #_abstract
    (#_"long" LDDDL'''invokePrim [#_"LDDDL" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol LDDDD
    #_abstract
    (#_"double" LDDDD'''invokePrim [#_"LDDDD" this, #_"long" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DOOOO
    #_abstract
    (#_"Object" DOOOO'''invokePrim [#_"DOOOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOOOL
    #_abstract
    (#_"long" DOOOL'''invokePrim [#_"DOOOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOOOD
    #_abstract
    (#_"double" DOOOD'''invokePrim [#_"DOOOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOOLO
    #_abstract
    (#_"Object" DOOLO'''invokePrim [#_"DOOLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DOOLL
    #_abstract
    (#_"long" DOOLL'''invokePrim [#_"DOOLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DOOLD
    #_abstract
    (#_"double" DOOLD'''invokePrim [#_"DOOLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DOODO
    #_abstract
    (#_"Object" DOODO'''invokePrim [#_"DOODO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DOODL
    #_abstract
    (#_"long" DOODL'''invokePrim [#_"DOODL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DOODD
    #_abstract
    (#_"double" DOODD'''invokePrim [#_"DOODD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DOLOO
    #_abstract
    (#_"Object" DOLOO'''invokePrim [#_"DOLOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOLOL
    #_abstract
    (#_"long" DOLOL'''invokePrim [#_"DOLOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOLOD
    #_abstract
    (#_"double" DOLOD'''invokePrim [#_"DOLOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DOLLO
    #_abstract
    (#_"Object" DOLLO'''invokePrim [#_"DOLLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DOLLL
    #_abstract
    (#_"long" DOLLL'''invokePrim [#_"DOLLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DOLLD
    #_abstract
    (#_"double" DOLLD'''invokePrim [#_"DOLLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DOLDO
    #_abstract
    (#_"Object" DOLDO'''invokePrim [#_"DOLDO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DOLDL
    #_abstract
    (#_"long" DOLDL'''invokePrim [#_"DOLDL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DOLDD
    #_abstract
    (#_"double" DOLDD'''invokePrim [#_"DOLDD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DODOO
    #_abstract
    (#_"Object" DODOO'''invokePrim [#_"DODOO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DODOL
    #_abstract
    (#_"long" DODOL'''invokePrim [#_"DODOL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DODOD
    #_abstract
    (#_"double" DODOD'''invokePrim [#_"DODOD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DODLO
    #_abstract
    (#_"Object" DODLO'''invokePrim [#_"DODLO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DODLL
    #_abstract
    (#_"long" DODLL'''invokePrim [#_"DODLL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DODLD
    #_abstract
    (#_"double" DODLD'''invokePrim [#_"DODLD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DODDO
    #_abstract
    (#_"Object" DODDO'''invokePrim [#_"DODDO" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DODDL
    #_abstract
    (#_"long" DODDL'''invokePrim [#_"DODDL" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DODDD
    #_abstract
    (#_"double" DODDD'''invokePrim [#_"DODDD" this, #_"double" ___arg0, #_"Object" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DLOOO
    #_abstract
    (#_"Object" DLOOO'''invokePrim [#_"DLOOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLOOL
    #_abstract
    (#_"long" DLOOL'''invokePrim [#_"DLOOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLOOD
    #_abstract
    (#_"double" DLOOD'''invokePrim [#_"DLOOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLOLO
    #_abstract
    (#_"Object" DLOLO'''invokePrim [#_"DLOLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DLOLL
    #_abstract
    (#_"long" DLOLL'''invokePrim [#_"DLOLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DLOLD
    #_abstract
    (#_"double" DLOLD'''invokePrim [#_"DLOLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DLODO
    #_abstract
    (#_"Object" DLODO'''invokePrim [#_"DLODO" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DLODL
    #_abstract
    (#_"long" DLODL'''invokePrim [#_"DLODL" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DLODD
    #_abstract
    (#_"double" DLODD'''invokePrim [#_"DLODD" this, #_"double" ___arg0, #_"long" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DLLOO
    #_abstract
    (#_"Object" DLLOO'''invokePrim [#_"DLLOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLLOL
    #_abstract
    (#_"long" DLLOL'''invokePrim [#_"DLLOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLLOD
    #_abstract
    (#_"double" DLLOD'''invokePrim [#_"DLLOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLLLO
    #_abstract
    (#_"Object" DLLLO'''invokePrim [#_"DLLLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DLLLL
    #_abstract
    (#_"long" DLLLL'''invokePrim [#_"DLLLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DLLLD
    #_abstract
    (#_"double" DLLLD'''invokePrim [#_"DLLLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DLLDO
    #_abstract
    (#_"Object" DLLDO'''invokePrim [#_"DLLDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DLLDL
    #_abstract
    (#_"long" DLLDL'''invokePrim [#_"DLLDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DLLDD
    #_abstract
    (#_"double" DLLDD'''invokePrim [#_"DLLDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DLDOO
    #_abstract
    (#_"Object" DLDOO'''invokePrim [#_"DLDOO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLDOL
    #_abstract
    (#_"long" DLDOL'''invokePrim [#_"DLDOL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLDOD
    #_abstract
    (#_"double" DLDOD'''invokePrim [#_"DLDOD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DLDLO
    #_abstract
    (#_"Object" DLDLO'''invokePrim [#_"DLDLO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DLDLL
    #_abstract
    (#_"long" DLDLL'''invokePrim [#_"DLDLL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DLDLD
    #_abstract
    (#_"double" DLDLD'''invokePrim [#_"DLDLD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DLDDO
    #_abstract
    (#_"Object" DLDDO'''invokePrim [#_"DLDDO" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DLDDL
    #_abstract
    (#_"long" DLDDL'''invokePrim [#_"DLDDL" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DLDDD
    #_abstract
    (#_"double" DLDDD'''invokePrim [#_"DLDDD" this, #_"double" ___arg0, #_"long" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DDOOO
    #_abstract
    (#_"Object" DDOOO'''invokePrim [#_"DDOOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDOOL
    #_abstract
    (#_"long" DDOOL'''invokePrim [#_"DDOOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDOOD
    #_abstract
    (#_"double" DDOOD'''invokePrim [#_"DDOOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDOLO
    #_abstract
    (#_"Object" DDOLO'''invokePrim [#_"DDOLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DDOLL
    #_abstract
    (#_"long" DDOLL'''invokePrim [#_"DDOLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DDOLD
    #_abstract
    (#_"double" DDOLD'''invokePrim [#_"DDOLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"long" ___arg3])
)

(defprotocol DDODO
    #_abstract
    (#_"Object" DDODO'''invokePrim [#_"DDODO" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DDODL
    #_abstract
    (#_"long" DDODL'''invokePrim [#_"DDODL" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DDODD
    #_abstract
    (#_"double" DDODD'''invokePrim [#_"DDODD" this, #_"double" ___arg0, #_"double" ___arg1, #_"Object" ___arg2, #_"double" ___arg3])
)

(defprotocol DDLOO
    #_abstract
    (#_"Object" DDLOO'''invokePrim [#_"DDLOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDLOL
    #_abstract
    (#_"long" DDLOL'''invokePrim [#_"DDLOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDLOD
    #_abstract
    (#_"double" DDLOD'''invokePrim [#_"DDLOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDLLO
    #_abstract
    (#_"Object" DDLLO'''invokePrim [#_"DDLLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DDLLL
    #_abstract
    (#_"long" DDLLL'''invokePrim [#_"DDLLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DDLLD
    #_abstract
    (#_"double" DDLLD'''invokePrim [#_"DDLLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"long" ___arg3])
)

(defprotocol DDLDO
    #_abstract
    (#_"Object" DDLDO'''invokePrim [#_"DDLDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DDLDL
    #_abstract
    (#_"long" DDLDL'''invokePrim [#_"DDLDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DDLDD
    #_abstract
    (#_"double" DDLDD'''invokePrim [#_"DDLDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"long" ___arg2, #_"double" ___arg3])
)

(defprotocol DDDOO
    #_abstract
    (#_"Object" DDDOO'''invokePrim [#_"DDDOO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDDOL
    #_abstract
    (#_"long" DDDOL'''invokePrim [#_"DDDOL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDDOD
    #_abstract
    (#_"double" DDDOD'''invokePrim [#_"DDDOD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"Object" ___arg3])
)

(defprotocol DDDLO
    #_abstract
    (#_"Object" DDDLO'''invokePrim [#_"DDDLO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DDDLL
    #_abstract
    (#_"long" DDDLL'''invokePrim [#_"DDDLL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DDDLD
    #_abstract
    (#_"double" DDDLD'''invokePrim [#_"DDDLD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"long" ___arg3])
)

(defprotocol DDDDO
    #_abstract
    (#_"Object" DDDDO'''invokePrim [#_"DDDDO" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DDDDL
    #_abstract
    (#_"long" DDDDL'''invokePrim [#_"DDDDL" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

(defprotocol DDDDD
    #_abstract
    (#_"double" DDDDD'''invokePrim [#_"DDDDD" this, #_"double" ___arg0, #_"double" ___arg1, #_"double" ___arg2, #_"double" ___arg3])
)

;;;
 ; <code>IFn</code> provides complete access to invoking
 ; any of Cloiure's <a href="http://clojure.github.io/clojure/">API</a>s.
 ; You can also access any other library written in Cloiure, after adding
 ; either its source or compiled form to the classpath.
 ;;
(defprotocol IFn #_(§ extends Callable, Runnable)
    #_abstract
    (#_"Object" IFn'''invoke1 [#_"IFn" this])
    #_abstract
    (#_"Object" IFn'''invoke2 [#_"IFn" this, #_"Object" ___arg1])
    #_abstract
    (#_"Object" IFn'''invoke3 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2])
    #_abstract
    (#_"Object" IFn'''invoke4 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3])
    #_abstract
    (#_"Object" IFn'''invoke5 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4])
    #_abstract
    (#_"Object" IFn'''invoke6 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5])
    #_abstract
    (#_"Object" IFn'''invoke7 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6])
    #_abstract
    (#_"Object" IFn'''invoke8 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7])
    #_abstract
    (#_"Object" IFn'''invoke9 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8])

    #_abstract
    (#_"Object" IFn'''invoke10 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9])

    #_abstract
    (#_"Object" IFn'''invoke11 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10])

    #_abstract
    (#_"Object" IFn'''invoke12 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11])

    #_abstract
    (#_"Object" IFn'''invoke13 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12])

    #_abstract
    (#_"Object" IFn'''invoke14 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13])

    #_abstract
    (#_"Object" IFn'''invoke15 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14])

    #_abstract
    (#_"Object" IFn'''invoke16 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15])

    #_abstract
    (#_"Object" IFn'''invoke17 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16])

    #_abstract
    (#_"Object" IFn'''invoke18 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17])

    #_abstract
    (#_"Object" IFn'''invoke19 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18])

    #_abstract
  #_(#_"Object" IFn'''invoke20 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19])

    #_abstract
  #_(#_"Object" IFn'''invoke21 [#_"IFn" this, #_"Object" arg1, #_"Object" arg2, #_"Object" arg3, #_"Object" arg4, #_"Object" arg5, #_"Object" arg6, #_"Object" arg7, #_"Object" arg8, #_"Object" arg9, #_"Object" arg10, #_"Object" arg11, #_"Object" arg12, #_"Object" arg13, #_"Object" arg14, #_"Object" arg15, #_"Object" arg16, #_"Object" arg17, #_"Object" arg18, #_"Object" arg19, #_"Object" arg20])

    #_abstract
    (#_"Object" IFn'''invoke22 [#_"IFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" #_arg19, #_"Object" #_arg20, #_"Object..." ___args])

    #_abstract
    (#_"Object" IFn'''applyTo [#_"IFn" this, #_"ISeq" ___arglist])
)
)

(java-ns cloiure.lang.IHashEq

(defprotocol IHashEq
    #_abstract
    (#_"int" IHashEq'''hasheq [#_"IHashEq" this])
)
)

(java-ns cloiure.lang.IKeywordLookup

(defprotocol IKeywordLookup
    #_abstract
    (#_"ILookupThunk" IKeywordLookup'''getLookupThunk [#_"IKeywordLookup" this, #_"Keyword" ___k])
)
)

(java-ns cloiure.lang.IKVReduce

(defprotocol IKVReduce
    #_abstract
    (#_"Object" IKVReduce'''kvreduce [#_"IKVReduce" this, #_"IFn" ___f, #_"Object" ___init])
)
)

(java-ns cloiure.lang.ILookup

(defprotocol ILookup
    #_abstract
    (#_"Object" ILookup'''valAt2 [#_"ILookup" this, #_"Object" ___key])
    #_abstract
    (#_"Object" ILookup'''valAt3 [#_"ILookup" this, #_"Object" ___key, #_"Object" ___notFound])
)
)

(java-ns cloiure.lang.ILookupSite

(defprotocol ILookupSite
    #_abstract
    (#_"ILookupThunk" ILookupSite'''fault [#_"ILookupSite" this, #_"Object" ___target])
)
)

(java-ns cloiure.lang.ILookupThunk

(defprotocol ILookupThunk
    #_abstract
    (#_"Object" ILookupThunk'''get [#_"ILookupThunk" this, #_"Object" ___target])
)
)

(java-ns cloiure.lang.IMapEntry

(§ import java.util.Map)

(defprotocol IMapEntry #_(§ extends Map$Entry)
    #_abstract
    (#_"Object" IMapEntry'''key [#_"IMapEntry" this])
    #_abstract
    (#_"Object" IMapEntry'''val [#_"IMapEntry" this])
)
)

(java-ns cloiure.lang.IMapIterable

(§ import java.util.Iterator)

;;;
 ; Indicate a map can provide more efficient key and val iterators.
 ;;
(defprotocol IMapIterable
    #_abstract
    (#_"Iterator" IMapIterable'''keyIterator [#_"IMapIterable" this])
    #_abstract
    (#_"Iterator" IMapIterable'''valIterator [#_"IMapIterable" this])
)
)

(java-ns cloiure.lang.IMeta

(defprotocol IMeta
    #_abstract
    (#_"IPersistentMap" IMeta'''meta [#_"IMeta" this])
)
)

(java-ns cloiure.lang.Indexed

(defprotocol Indexed #_(§ extends Counted)
    #_abstract
    (#_"Object" Indexed'''nth2 [#_"Indexed" this, #_"int" ___i])
    #_abstract
    (#_"Object" Indexed'''nth3 [#_"Indexed" this, #_"int" ___i, #_"Object" ___notFound])
)
)

(java-ns cloiure.lang.IndexedSeq

(defprotocol IndexedSeq #_(§ extends ISeq, Sequential, Counted)
    #_abstract
    (#_"int" IndexedSeq'''index [#_"IndexedSeq" this])
)
)

(java-ns cloiure.lang.Intrinsics

(§ import cloiure.asm.Opcodes)

#_stateless
(class-ns Intrinsics (§ implements Opcodes)
    (defn- #_"Object[]" Intrinsics'oa [#_"Object..." ___arr]
        ___arr
    )

    (def #_"IPersistentMap" Intrinsics'ops (ß RT'map(
        (§ map
            "public static double cloiure.lang.Numbers.add(double,double)"                DADD
            "public static long cloiure.lang.Numbers.and(long,long)"                      LAND
            "public static long cloiure.lang.Numbers.or(long,long)"                       LOR
            "public static long cloiure.lang.Numbers.xor(long,long)"                      LXOR
            "public static double cloiure.lang.Numbers.multiply(double,double)"           DMUL
            "public static double cloiure.lang.Numbers.divide(double,double)"             DDIV
            "public static long cloiure.lang.Numbers.remainder(long,long)"                LREM
            "public static long cloiure.lang.Numbers.shiftLeft(long,long)"                (ß oa(L2I, LSHL))
            "public static long cloiure.lang.Numbers.shiftRight(long,long)"               (ß oa(L2I, LSHR))
            "public static long cloiure.lang.Numbers.unsignedShiftRight(long,long)"       (ß oa(L2I, LUSHR))
            "public static double cloiure.lang.Numbers.minus(double)"                     DNEG
            "public static double cloiure.lang.Numbers.minus(double,double)"              DSUB
            "public static double cloiure.lang.Numbers.inc(double)"                       (ß oa(DCONST_1, DADD))
            "public static double cloiure.lang.Numbers.dec(double)"                       (ß oa(DCONST_1, DSUB))
            "public static long cloiure.lang.Numbers.quotient(long,long)"                 LDIV
            "public static int cloiure.lang.Numbers.shiftLeftInt(int,int)"                ISHL
            "public static int cloiure.lang.Numbers.shiftRightInt(int,int)"               ISHR
            "public static int cloiure.lang.Numbers.unsignedShiftRightInt(int,int)"       IUSHR
            "public static int cloiure.lang.Numbers.unchecked_int_add(int,int)"           IADD
            "public static int cloiure.lang.Numbers.unchecked_int_subtract(int,int)"      ISUB
            "public static int cloiure.lang.Numbers.unchecked_int_negate(int)"            INEG
            "public static int cloiure.lang.Numbers.unchecked_int_inc(int)"               (ß oa(ICONST_1, IADD))
            "public static int cloiure.lang.Numbers.unchecked_int_dec(int)"               (ß oa(ICONST_1, ISUB))
            "public static int cloiure.lang.Numbers.unchecked_int_multiply(int,int)"      IMUL
            "public static int cloiure.lang.Numbers.unchecked_int_divide(int,int)"        IDIV
            "public static int cloiure.lang.Numbers.unchecked_int_remainder(int,int)"     IREM
            "public static long cloiure.lang.Numbers.unchecked_add(long,long)"            LADD
            "public static double cloiure.lang.Numbers.unchecked_add(double,double)"      DADD
            "public static long cloiure.lang.Numbers.unchecked_minus(long)"               LNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double)"           DNEG
            "public static double cloiure.lang.Numbers.unchecked_minus(double,double)"    DSUB
            "public static long cloiure.lang.Numbers.unchecked_minus(long,long)"          LSUB
            "public static long cloiure.lang.Numbers.unchecked_multiply(long,long)"       LMUL
            "public static double cloiure.lang.Numbers.unchecked_multiply(double,double)" DMUL
            "public static double cloiure.lang.Numbers.unchecked_inc(double)"             (ß oa(DCONST_1, DADD))
            "public static long cloiure.lang.Numbers.unchecked_inc(long)"                 (ß oa(LCONST_1, LADD))
            "public static double cloiure.lang.Numbers.unchecked_dec(double)"             (ß oa(DCONST_1, DSUB))
            "public static long cloiure.lang.Numbers.unchecked_dec(long)"                 (ß oa(LCONST_1, LSUB))

            "public static short cloiure.lang.RT.aget(short[],int)"                       SALOAD
            "public static float cloiure.lang.RT.aget(float[],int)"                       FALOAD
            "public static double cloiure.lang.RT.aget(double[],int)"                     DALOAD
            "public static int cloiure.lang.RT.aget(int[],int)"                           IALOAD
            "public static long cloiure.lang.RT.aget(long[],int)"                         LALOAD
            "public static char cloiure.lang.RT.aget(char[],int)"                         CALOAD
            "public static byte cloiure.lang.RT.aget(byte[],int)"                         BALOAD
            "public static boolean cloiure.lang.RT.aget(boolean[],int)"                   BALOAD
            "public static java.lang.Object cloiure.lang.RT.aget(java.lang.Object[],int)" AALOAD
            "public static int cloiure.lang.RT.alength(int[])"                            ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(long[])"                           ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(char[])"                           ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(java.lang.Object[])"               ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(byte[])"                           ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(float[])"                          ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(short[])"                          ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(boolean[])"                        ARRAYLENGTH
            "public static int cloiure.lang.RT.alength(double[])"                         ARRAYLENGTH

            "public static double cloiure.lang.RT.doubleCast(long)"            L2D
            "public static double cloiure.lang.RT.doubleCast(double)"          NOP
            "public static double cloiure.lang.RT.doubleCast(float)"           F2D
            "public static double cloiure.lang.RT.doubleCast(int)"             I2D
            "public static double cloiure.lang.RT.doubleCast(short)"           I2D
            "public static double cloiure.lang.RT.doubleCast(byte)"            I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(double)" NOP
            "public static double cloiure.lang.RT.uncheckedDoubleCast(float)"  F2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(long)"   L2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(int)"    I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(short)"  I2D
            "public static double cloiure.lang.RT.uncheckedDoubleCast(byte)"   I2D
            "public static long cloiure.lang.RT.longCast(long)"                NOP
            "public static long cloiure.lang.RT.longCast(short)"               I2L
            "public static long cloiure.lang.RT.longCast(byte)"                I2L
            "public static long cloiure.lang.RT.longCast(int)"                 I2L
            "public static int cloiure.lang.RT.uncheckedIntCast(long)"         L2I
            "public static int cloiure.lang.RT.uncheckedIntCast(double)"       D2I
            "public static int cloiure.lang.RT.uncheckedIntCast(byte)"         NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(short)"        NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(char)"         NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(int)"          NOP
            "public static int cloiure.lang.RT.uncheckedIntCast(float)"        F2I
            "public static long cloiure.lang.RT.uncheckedLongCast(short)"      I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(float)"      F2L
            "public static long cloiure.lang.RT.uncheckedLongCast(double)"     D2
            "public static long cloiure.lang.RT.uncheckedLongCast(byte)"       I2L
            "public static long cloiure.lang.RT.uncheckedLongCast(long)"       NOP
            "public static long cloiure.lang.RT.uncheckedLongCast(int)"        I2L
        )
    )))

    ;; map to instructions terminated with comparator for branch to false
    (def #_"IPersistentMap" Intrinsics'preds (ß RT'map(
        (§ map
            "public static boolean cloiure.lang.Numbers.lt(double,double)"    (ß oa(DCMPG, IFGE))
            "public static boolean cloiure.lang.Numbers.lt(long,long)"        (ß oa(LCMP, IFGE))
            "public static boolean cloiure.lang.Numbers.equiv(double,double)" (ß oa(DCMPL, IFNE))
            "public static boolean cloiure.lang.Numbers.equiv(long,long)"     (ß oa(LCMP, IFNE))
            "public static boolean cloiure.lang.Numbers.lte(double,double)"   (ß oa(DCMPG, IFGT))
            "public static boolean cloiure.lang.Numbers.lte(long,long)"       (ß oa(LCMP, IFGT))
            "public static boolean cloiure.lang.Numbers.gt(long,long)"        (ß oa(LCMP, IFLE))
            "public static boolean cloiure.lang.Numbers.gt(double,double)"    (ß oa(DCMPL, IFLE))
            "public static boolean cloiure.lang.Numbers.gte(long,long)"       (ß oa(LCMP, IFLT))
            "public static boolean cloiure.lang.Numbers.gte(double,double)"   (ß oa(DCMPL, IFLT))
            "public static boolean cloiure.lang.Util.equiv(long,long)"        (ß oa(LCMP, IFNE))
            "public static boolean cloiure.lang.Util.equiv(boolean,boolean)"  (ß oa(IF_ICMPNE))
            "public static boolean cloiure.lang.Util.equiv(double,double)"    (ß oa(DCMPL, IFNE))

            "public static boolean cloiure.lang.Numbers.isZero(double)"       (ß oa(DCONST_0, DCMPL, IFNE))
            "public static boolean cloiure.lang.Numbers.isZero(long)"         (ß oa(LCONST_0, LCMP, IFNE))
            "public static boolean cloiure.lang.Numbers.isPos(long)"          (ß oa(LCONST_0, LCMP, IFLE))
            "public static boolean cloiure.lang.Numbers.isPos(double)"        (ß oa(DCONST_0, DCMPL, IFLE))
            "public static boolean cloiure.lang.Numbers.isNeg(long)"          (ß oa(LCONST_0, LCMP, IFGE))
            "public static boolean cloiure.lang.Numbers.isNeg(double)"        (ß oa(DCONST_0, DCMPG, IFGE))
        )
    )))
)
)

(java-ns cloiure.lang.IObj

(defprotocol IObj #_(§ extends IMeta)
    #_abstract
    (#_"IObj" IObj'''withMeta [#_"IObj" this, #_"IPersistentMap" ___meta])
)
)

(java-ns cloiure.lang.IPending

(defprotocol IPending
    #_abstract
    (#_"boolean" IPending'''isRealized [#_"IPending" this])
)
)

(java-ns cloiure.lang.IPersistentCollection

(defprotocol IPersistentCollection #_(§ extends Seqable)
    #_abstract
    (#_"int" IPersistentCollection'''count [#_"IPersistentCollection" this])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''cons [#_"IPersistentCollection" this, #_"Object" ___o])
    #_abstract
    (#_"IPersistentCollection" IPersistentCollection'''empty [#_"IPersistentCollection" this])
    #_abstract
    (#_"boolean" IPersistentCollection'''equiv [#_"IPersistentCollection" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.IPersistentList

(defprotocol IPersistentList #_(§ extends Sequential, IPersistentStack)
)
)

(java-ns cloiure.lang.IPersistentMap

(defprotocol IPersistentMap #_(§ extends Iterable, Associative, Counted)
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''assoc [#_"IPersistentMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''assocEx [#_"IPersistentMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"IPersistentMap" IPersistentMap'''without [#_"IPersistentMap" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IPersistentSet

(defprotocol IPersistentSet #_(§ extends IPersistentCollection, Counted)
    #_abstract
    (#_"IPersistentSet" IPersistentSet'''disjoin [#_"IPersistentSet" this, #_"Object" ___key])
    #_abstract
    (#_"boolean" IPersistentSet'''contains [#_"IPersistentSet" this, #_"Object" ___key])
    #_abstract
    (#_"Object" IPersistentSet'''get [#_"IPersistentSet" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IPersistentStack

(defprotocol IPersistentStack #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" IPersistentStack'''peek [#_"IPersistentStack" this])
    #_abstract
    (#_"IPersistentStack" IPersistentStack'''pop [#_"IPersistentStack" this])
)
)

(java-ns cloiure.lang.IPersistentVector

(defprotocol IPersistentVector #_(§ extends Associative, Sequential, IPersistentStack, Reversible, Indexed)
    #_abstract
    (#_"int" IPersistentVector'''length [#_"IPersistentVector" this])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''assocN [#_"IPersistentVector" this, #_"int" ___i, #_"Object" ___val])
    #_abstract
    (#_"IPersistentVector" IPersistentVector'''cons [#_"IPersistentVector" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.IProxy

(defprotocol IProxy
    #_abstract
    (#_"void" IProxy'''__initCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" ___m])
    #_abstract
    (#_"void" IProxy'''__updateCloiureFnMappings [#_"IProxy" this, #_"IPersistentMap" ___m])
    #_abstract
    (#_"IPersistentMap" IProxy'''__getCloiureFnMappings [#_"IProxy" this])
)
)

(java-ns cloiure.lang.IRecord

(defprotocol IRecord
)
)

(java-ns cloiure.lang.IReduce

(defprotocol IReduce #_(§ extends IReduceInit)
    #_abstract
    (#_"Object" IReduce'''reduce [#_"IReduce" this, #_"IFn" ___f])
)
)

(java-ns cloiure.lang.IReduceInit

(defprotocol IReduceInit
    #_abstract
    (#_"Object" IReduceInit'''reduce [#_"IReduceInit" this, #_"IFn" ___f, #_"Object" ___start])
)
)

(java-ns cloiure.lang.IRef

(defprotocol IRef #_(§ extends IDeref)
    #_abstract
    (#_"void" IRef'''setValidator [#_"IRef" this, #_"IFn" ___vf])
    #_abstract
    (#_"IFn" IRef'''getValidator [#_"IRef" this])
    #_abstract
    (#_"IPersistentMap" IRef'''getWatches [#_"IRef" this])
    #_abstract
    (#_"IRef" IRef'''addWatch [#_"IRef" this, #_"Object" ___key, #_"IFn" ___callback])
    #_abstract
    (#_"IRef" IRef'''removeWatch [#_"IRef" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.IReference

(defprotocol IReference #_(§ extends IMeta)
    #_abstract
    (#_"IPersistentMap" IReference'''alterMeta [#_"IReference" this, #_"IFn" ___alter, #_"ISeq" ___args])
    #_abstract
    (#_"IPersistentMap" IReference'''resetMeta [#_"IReference" this, #_"IPersistentMap" ___m])
)
)

(java-ns cloiure.lang.ISeq

;;;
 ; A persistent, functional, sequence interface
 ;
 ; ISeqs are immutable values, i.e. neither first(), nor rest() changes
 ; or invalidates the ISeq
 ;;
(defprotocol ISeq #_(§ extends IPersistentCollection)
    #_abstract
    (#_"Object" ISeq'''first [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''next [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''more [#_"ISeq" this])
    #_abstract
    (#_"ISeq" ISeq'''cons [#_"ISeq" this, #_"Object" ___o])
)
)

(java-ns cloiure.lang.Iterate

(class-ns Iterate (§ extends ASeq) (§ implements IReduce, IPending)
    (def- #_"Object" Iterate'UNREALIZED_SEED (Object.))

    (defn- #_"Iterate" Iterate'init []
        (hash-map
            #_"IFn" :f nil ;; never nil
            #_"Object" :prevSeed nil
            #_volatile
            #_"Object" :_seed nil ;; lazily realized
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Iterate" Iterate'new-3 [#_"IFn" ___f, #_"Object" ___prevSeed, #_"Object" ___seed]
        (let [this (merge (ASeq'new) (Iterate'init))]
            (§ ass (:f this) ___f)
            (§ ass (:prevSeed this) ___prevSeed)
            (§ ass (:_seed this) ___seed)
            this
        )
    )

    (defn- #_"Iterate" Iterate'new-5 [#_"IPersistentMap" ___meta, #_"IFn" ___f, #_"Object" ___prevSeed, #_"Object" ___seed, #_"ISeq" ___next]
        (let [this (merge (ASeq'new ___meta) (Iterate'init))]
            (§ ass (:f this) ___f)
            (§ ass (:prevSeed this) ___prevSeed)
            (§ ass (:_seed this) ___seed)
            (§ ass (:_next this) ___next)
            this
        )
    )

    (defn #_"ISeq" Iterate'create [#_"IFn" ___f, #_"Object" ___seed]
        (Iterate'new-3 ___f, nil, ___seed)
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"Iterate" this]
        (ß ((:_seed this) != Iterate'UNREALIZED_SEED))
    )

    #_method
    (§ defn #_"Object" first [#_"Iterate" this]
        (when (ß (:_seed this) == Iterate'UNREALIZED_SEED)
            (§ ass (:_seed this) (ß (:f this).invoke((:prevSeed this))))
        )
        (:_seed this)
    )

    #_method
    (§ defn #_"ISeq" next [#_"Iterate" this]
        (when (nil? (:_next this))
            (§ ass (:_next this) (ß Iterate'new-3((:f this), first(), Iterate'UNREALIZED_SEED)))
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Iterate" withMeta [#_"Iterate" this, #_"IPersistentMap" ___meta]
        (Iterate'new-5 ___meta, (:f this), (:prevSeed this), (:_seed this), (:_next this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Iterate" this, #_"IFn" ___rf]
        (let [#_"Object" ___first (ß first())]
            (let [#_"Object" ___ret ___first]
                (let [#_"Object" ___v (ß (:f this).invoke(___first))]
                    (while true
                        (§ ass ___ret (ß ___rf.invoke(___ret, ___v)))
                        (when (RT'isReduced ___ret)
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                        (§ ass ___v (ß (:f this).invoke(___v)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Iterate" this, #_"IFn" ___rf, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (let [#_"Object" ___v (ß first())]
                (while true
                    (§ ass ___ret (ß ___rf.invoke(___ret, ___v)))
                    (when (RT'isReduced ___ret)
                        (§ return (ß ((IDeref)___ret).deref()))
                    )
                    (§ ass ___v (ß (:f this).invoke(___v)))
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.IteratorSeq

(§ import java.io.IOException)
(§ import java.util.Iterator)

(class-ns IteratorSeqState
    (defn- #_"IteratorSeqState" IteratorSeqState'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_volatile
            #_"Object" :_rest nil
        )
    )

    (defn #_"IteratorSeqState" IteratorSeqState'new []
        (IteratorSeqState'init)
    )
)

(class-ns IteratorSeq (§ extends ASeq)
    (defn #_"IteratorSeq" IteratorSeq'create [#_"Iterator" ___iter]
        (when (ß ___iter.hasNext())
            (§ return (IteratorSeq'new-1 ___iter))
        )
        nil
    )

    (defn- #_"IteratorSeq" IteratorSeq'init []
        (hash-map
            #_"Iterator" :iter nil
            #_"IteratorSeqState" :state nil
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-1 [#_"Iterator" ___iter]
        (let [this (merge (ASeq'new) (IteratorSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) (IteratorSeqState'new))
            (§ ass (ß (:state this).val) (:state this))
            (§ ass (ß (:state this)._rest) (:state this))
            this
        )
    )

    (defn #_"IteratorSeq" IteratorSeq'new-3 [#_"IPersistentMap" ___meta, #_"Iterator" ___iter, #_"IteratorSeqState" ___state]
        (let [this (merge (ASeq'new ___meta) (IteratorSeq'init))]
            (§ ass (:iter this) ___iter)
            (§ ass (:state this) ___state)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"IteratorSeq" this]
        (when (ß (:state this).val == (:state this))
            (§ sync (:state this)
                (when (ß (:state this).val == (:state this))
                    (§ ass (ß (:state this).val) (ß (:iter this).next()))
                )
            )
        )
        (ß (:state this).val)
    )

    #_method
    (§ defn #_"ISeq" next [#_"IteratorSeq" this]
        (when (ß (:state this)._rest == (:state this))
            (§ sync (:state this)
                (when (ß (:state this)._rest == (:state this))
                    (ß first())
                    (§ ass (ß (:state this)._rest) (IteratorSeq'create (:iter this)))
                )
            )
        )
        (ß (ISeq) (:state this)._rest)
    )

    #_method
    (§ defn #_"IteratorSeq" withMeta [#_"IteratorSeq" this, #_"IPersistentMap" ___meta]
        (IteratorSeq'new-3 ___meta, (:iter this), (:state this))
    )
)
)

(java-ns cloiure.lang.ITransientAssociative

(defprotocol ITransientAssociative #_(§ extends ITransientCollection, ILookup)
    #_abstract
    (#_"ITransientAssociative" ITransientAssociative'''assoc [#_"ITransientAssociative" this, #_"Object" ___key, #_"Object" ___val])
)
)

(java-ns cloiure.lang.ITransientAssociative2

(defprotocol ITransientAssociative2 #_(§ extends ITransientAssociative)
    #_abstract
    (#_"boolean" ITransientAssociative2'''containsKey [#_"ITransientAssociative2" this, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" ITransientAssociative2'''entryAt [#_"ITransientAssociative2" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.ITransientCollection

(defprotocol ITransientCollection
    #_abstract
    (#_"ITransientCollection" ITransientCollection'''conj [#_"ITransientCollection" this, #_"Object" ___val])
    #_abstract
    (#_"IPersistentCollection" ITransientCollection'''persistent [#_"ITransientCollection" this])
)
)

(java-ns cloiure.lang.ITransientMap

(defprotocol ITransientMap #_(§ extends ITransientAssociative, Counted)
    #_abstract
    (#_"ITransientMap" ITransientMap'''assoc [#_"ITransientMap" this, #_"Object" ___key, #_"Object" ___val])
    #_abstract
    (#_"ITransientMap" ITransientMap'''without [#_"ITransientMap" this, #_"Object" ___key])
    #_abstract
    (#_"IPersistentMap" ITransientMap'''persistent [#_"ITransientMap" this])
)
)

(java-ns cloiure.lang.ITransientSet

(defprotocol ITransientSet #_(§ extends ITransientCollection, Counted)
    #_abstract
    (#_"ITransientSet" ITransientSet'''disjoin [#_"ITransientSet" this, #_"Object" ___key])
    #_abstract
    (#_"boolean" ITransientSet'''contains [#_"ITransientSet" this, #_"Object" ___key])
    #_abstract
    (#_"Object" ITransientSet'''get [#_"ITransientSet" this, #_"Object" ___key])
)
)

(java-ns cloiure.lang.ITransientVector

(defprotocol ITransientVector #_(§ extends ITransientAssociative, Indexed)
    #_abstract
    (#_"ITransientVector" ITransientVector'''assocN [#_"ITransientVector" this, #_"int" ___i, #_"Object" ___val])
    #_abstract
    (#_"ITransientVector" ITransientVector'''pop [#_"ITransientVector" this])
)
)

(java-ns cloiure.lang.IType

(defprotocol IType
)
)

(java-ns cloiure.lang.Keyword

(§ import java.lang.ref.Reference)
(§ import java.lang.ref.WeakReference)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)
(§ import java.lang.ref.SoftReference)

(class-ns Keyword (§ implements IFn, Comparable, Named, IHashEq)
    (def- #_"ConcurrentHashMap<Symbol, Reference<Keyword>>" Keyword'TABLE (ConcurrentHashMap.))

    (def #_"ReferenceQueue" Keyword'RQ (ReferenceQueue.))

    (defn #_"Keyword" Keyword'intern [#_"Symbol" ___sym]
        (let [#_"Keyword" ___k nil]
            (let [#_"Reference<Keyword>" ___existingRef (ß Keyword'TABLE.get(___sym))]
                (when (nil? ___existingRef)
                    (Util'clearCache Keyword'RQ, Keyword'TABLE)
                    (when (ß ___sym.meta() != nil)
                        (§ ass ___sym (ß (Symbol) ___sym.withMeta(nil)))
                    )
                    (§ ass ___k (Keyword'new ___sym))
                    (§ ass ___existingRef (ß Keyword'TABLE.putIfAbsent(___sym, new WeakReference<Keyword>(___k, Keyword'RQ))))
                )
                (when (nil? ___existingRef)
                    (§ return ___k)
                )
                (let [#_"Keyword" ___existingk (ß ___existingRef.get())]
                    (when (some? ___existingk)
                        (§ return ___existingk)
                    )
                    ;; entry died in the interim, do over
                    (ß Keyword'TABLE.remove(___sym, ___existingRef))
                    (ß intern(___sym))
                )
            )
        )
    )

    (defn #_"Keyword" Keyword'intern-2 [#_"String" ___ns, #_"String" ___name]
        (ß intern(Symbol'intern-2(___ns, ___name)))
    )

    (defn #_"Keyword" Keyword'intern-1 [#_"String" ___nsname]
        (ß intern(Symbol'intern-1(___nsname)))
    )

    (defn- #_"Keyword" Keyword'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"int" :hasheq 0
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Keyword" Keyword'new [#_"Symbol" ___sym]
        (let [this (Keyword'init)]
            (§ ass (:sym this) ___sym)
            (§ ass (:hasheq this) (ß ___sym.hasheq() + 0x9e3779b9))
            this
        )
    )

    (defn #_"Keyword" Keyword'find [#_"Symbol" ___sym]
        (let [#_"Reference<Keyword>" ___ref (ß Keyword'TABLE.get(___sym))]
            (if (some? ___ref)
                (do
                    (ß ___ref.get())
                )
                (do
                    nil
                )
            )
        )
    )

    (defn #_"Keyword" Keyword'find-2 [#_"String" ___ns, #_"String" ___name]
        (ß Keyword'find(Symbol'intern-2(___ns, ___name)))
    )

    (defn #_"Keyword" Keyword'find-1 [#_"String" ___nsname]
        (ß Keyword'find(Symbol'intern-1(___nsname)))
    )

    #_method
    (§ defn #_"int" hashCode [#_"Keyword" this]
        (ß (:sym this).hashCode() + 0x9e3779b9)
    )

    #_method
    (§ defn #_"int" hasheq [#_"Keyword" this]
        (:hasheq this)
    )

    #_method
    (§ defn #_"String" toString [#_"Keyword" this]
        (when (nil? (:_str this))
            (§ ass (:_str this) (ß (":" + (:sym this))))
        )
        (:_str this)
    )

    #_method
    (§ defn #_"Object" throwArity [#_"Keyword" this]
        (throw (IllegalArgumentException. (str "Wrong number of args passed to keyword: " (ß this.toString()))))
    )

    #_method
    (§ defn #_"Object" call [#_"Keyword" this]
        (ß throwArity())
    )

    #_method
    (§ defn #_"void" run [#_"Keyword" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this]
        (ß throwArity())
    )

    #_method
    (§ defn #_"int" compareTo [#_"Keyword" this, #_"Object" ___o]
        (ß (:sym this).compareTo(((Keyword) ___o).sym))
    )

    #_method
    (§ defn #_"String" getNamespace [#_"Keyword" this]
        (ß (:sym this).getNamespace())
    )

    #_method
    (§ defn #_"String" getName [#_"Keyword" this]
        (ß (:sym this).getName())
    )

    ;;;
     ; Indexer implements IFn for attr access
     ;
     ; @param obj - must be IPersistentMap
     ; @return the value at the key or nil if not found
     ;;
    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___obj]
        (when (ß ___obj instanceof ILookup)
            (§ return (ß ((ILookup)___obj).valAt(this)))
        )
        (RT'get-2 ___obj, this)
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___obj, #_"Object" ___notFound]
        (when (ß ___obj instanceof ILookup)
            (§ return (ß ((ILookup)___obj).valAt(this, ___notFound)))
        )
        (RT'get-3 ___obj, this, ___notFound)
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Keyword" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß throwArity())
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Keyword" this, #_"ISeq" ___arglist]
        (AFn'applyToHelper this, ___arglist)
    )
)
)

(java-ns cloiure.lang.KeywordLookupSite

(class-ns KeywordLookupSite (§ implements ILookupSite, ILookupThunk)
    (defn- #_"KeywordLookupSite" KeywordLookupSite'init []
        (hash-map
            #_"Keyword" :k nil
        )
    )

    (defn #_"KeywordLookupSite" KeywordLookupSite'new [#_"Keyword" ___k]
        (let [this (KeywordLookupSite'init)]
            (§ ass (:k this) ___k)
            this
        )
    )

    #_method
    (§ defn #_"ILookupThunk" fault [#_"KeywordLookupSite" this, #_"Object" ___target]
        (cond (ß ___target instanceof IKeywordLookup)
            (do
                (§ return (ß install(___target)))
            )
            (ß ___target instanceof ILookup)
            (do
                (§ return (ß ilookupThunk(___target.getClass())))
            )
        )
        this
    )

    #_method
    (§ defn #_"Object" get [#_"KeywordLookupSite" this, #_"Object" ___target]
        (when (ß ___target instanceof IKeywordLookup || ___target instanceof ILookup)
            (§ return this)
        )
        (RT'get-2 ___target, (:k this))
    )

    #_method
    (§ defn- #_"ILookupThunk" ilookupThunk [#_"KeywordLookupSite" this, #_"Class" ___c]
        (§ reify ILookupThunk()
            #_method
            (§ defn #_"Object" get [#_"ILookupThunk" this, #_"Object" ___target]
                (when (ß ___target != nil && ___target.getClass() == ___c)
                    (§ return (ß ((ILookup) ___target).valAt((:k this))))
                )
                this
            )
        )
    )

    #_method
    (§ defn- #_"ILookupThunk" install [#_"KeywordLookupSite" this, #_"Object" ___target]
        (let [#_"ILookupThunk" ___t (ß ((IKeywordLookup)___target).getLookupThunk((:k this)))]
            (when (some? ___t)
                (§ return ___t)
            )
            (ß ilookupThunk(___target.getClass()))
        )
    )
)
)

(java-ns cloiure.lang.LazilyPersistentVector

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns LazilyPersistentVector
    (defn #_"IPersistentVector" LazilyPersistentVector'createOwning [#_"Object..." ___items]
        (when (ß ___items.length <= 32)
            (§ return (ß PersistentVector'new-4(___items.length, 5, PersistentVector'EMPTY_NODE, ___items)))
        )
        (PersistentVector'create-1a ___items)
    )

    (defn #_"int" LazilyPersistentVector'fcount [#_"Object" ___c]
        (when (ß ___c instanceof Counted)
            (§ return (ß ((Counted) ___c).count()))
        )
        (ß ((Collection)___c).size())
    )

    (defn #_"IPersistentVector" LazilyPersistentVector'create [#_"Object" ___obj]
        (cond (ß ___obj instanceof IReduceInit)
            (do
                (ß PersistentVector'create-1r((IReduceInit) ___obj))
            )
            (ß ___obj instanceof ISeq)
            (do
                (ß PersistentVector'create-1s(RT'seq(___obj)))
            )
            (ß ___obj instanceof Iterable)
            (do
                (ß PersistentVector'create-1i((Iterable)___obj))
            )
            :else
            (do
                (ß createOwning(RT'toArray(___obj)))
            )
        )
    )
)
)

(java-ns cloiure.lang.LazySeq

(§ import java.util.*)

(class-ns LazySeq (§ extends Obj) (§ implements ISeq, Sequential, List, IPending, IHashEq)
    (defn- #_"LazySeq" LazySeq'init []
        (hash-map
            #_"IFn" :fn nil
            #_"Object" :sv nil
            #_"ISeq" :s nil
        )
    )

    (defn #_"LazySeq" LazySeq'new-1 [#_"IFn" ___fn]
        (let [this (merge (Obj'new) (LazySeq'init))]
            (§ ass (:fn this) ___fn)
            this
        )
    )

    (defn- #_"LazySeq" LazySeq'new-2 [#_"IPersistentMap" ___meta, #_"ISeq" ___s]
        (let [this (merge (Obj'new ___meta) (LazySeq'init))]
            (§ ass (:fn this) nil)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"LazySeq" this, #_"IPersistentMap" ___meta]
        (ß LazySeq'new-2(___meta, seq()))
    )

    #_method
    (§ defn #_"Object" sval [#_"LazySeq" this]
        (§ sync this
            (when (some? (:fn this))
                (§ ass (:sv this) (ß (:fn this).invoke()))
                (§ ass (:fn this) nil)
            )
            (when (some? (:sv this))
                (§ return (:sv this))
            )
            (:s this)
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"LazySeq" this]
        (§ sync this
            (ß sval())
            (when (some? (:sv this))
                (let [#_"Object" ___ls (:sv this)]
                    (§ ass (:sv this) nil)
                    (while (ß ___ls instanceof LazySeq)
                        (§ ass ___ls (ß ((LazySeq)___ls).sval()))
                    )
                    (§ ass (:s this) (RT'seq ___ls))
                )
            )
            (:s this)
        )
    )

    #_method
    (§ defn #_"int" count [#_"LazySeq" this]
        (let [#_"int" ___c 0]
            (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
                (§ ass ___c (inc ___c))
            )
            ___c
        )
    )

    #_method
    (§ defn #_"Object" first [#_"LazySeq" this]
        (ß seq())
        (when (nil? (:s this))
            (§ return nil)
        )
        (ß (:s this).first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"LazySeq" this]
        (ß seq())
        (when (nil? (:s this))
            (§ return nil)
        )
        (ß (:s this).next())
    )

    #_method
    (§ defn #_"ISeq" more [#_"LazySeq" this]
        (ß seq())
        (when (nil? (:s this))
            (§ return PersistentList'EMPTY)
        )
        (ß (:s this).more())
    )

    #_method
    (§ defn #_"ISeq" cons [#_"LazySeq" this, #_"Object" ___o]
        (ß RT'cons(___o, seq()))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"LazySeq" this]
        PersistentList'EMPTY
    )

    #_method
    (§ defn #_"boolean" equiv [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (ß seq())]
            (if (some? ___s)
                (do
                    (ß ___s.equiv(___o))
                )
                (do
                    (ß (___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"LazySeq" this]
        (let [#_"ISeq" ___s (ß seq())]
            (when (nil? ___s)
                (§ return 1)
            )
            (Util'hash ___s)
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"LazySeq" this]
        (Murmur3'hashOrdered this)
    )

    #_method
    (§ defn #_"boolean" equals [#_"LazySeq" this, #_"Object" ___o]
        (let [#_"ISeq" ___s (ß seq())]
            (if (some? ___s)
                (do
                    (ß ___s.equals(___o))
                )
                (do
                    (ß (___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"LazySeq" this]
        (ß RT'seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"LazySeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"LazySeq" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"LazySeq" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"LazySeq" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"LazySeq" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß !contains(___o))
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"LazySeq" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"LazySeq" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"LazySeq" this]
        (ß (seq() == nil))
    )

    #_method
    (§ defn #_"boolean" contains [#_"LazySeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
            (when (ß Util'equiv-2oo(___s.first(), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"LazySeq" this]
        (SeqIterator'new this)
    )

    #_method
    (§ defn- #_"List" reify [#_"LazySeq" this]
        (ArrayList. this)
    )

    #_method
    (§ defn #_"List" subList [#_"LazySeq" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß reify().subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"LazySeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"LazySeq" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"LazySeq" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (ß seq()) #_"int" ___i 0] (some? ___s) [(ß ___s.next()) (inc ___i)]
            (when (ß Util'equiv-2oo(___s.first(), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"LazySeq" this, #_"Object" ___o]
        (ß reify().lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"LazySeq" this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"LazySeq" this, #_"int" ___index]
        (ß reify().listIterator(___index))
    )

    #_method
    (§ defn #_"Object" get [#_"LazySeq" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" add [#_"LazySeq" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"LazySeq" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" isRealized [#_"LazySeq" this]
        (§ sync this
            (ß ((:fn this) == nil))
        )
    )
)
)

(java-ns cloiure.lang.LineNumberingPushbackReader

(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.io.LineNumberReader)
(§ import java.io.IOException)

(class-ns LineNumberingPushbackReader (§ extends PushbackReader)
    ;; This class is a PushbackReader that wraps a LineNumberReader. The code
    ;; here to handle line terminators only mentions '\n' because
    ;; LineNumberReader collapses all occurrences of CR, LF, and CRLF into a
    ;; single '\n'.
    (def- #_"int" LineNumberingPushbackReader'newline (ß (int) \newline))

    (defn- #_"LineNumberingPushbackReader" LineNumberingPushbackReader'init []
        (hash-map
            #_"boolean" :_atLineStart true
            #_"boolean" :_prev false
            #_"int" :_columnNumber 1
        )
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-1 [#_"Reader" ___r]
        (merge (PushbackReader'new (LineNumberReader. ___r)) (LineNumberingPushbackReader'init))
    )

    (defn #_"LineNumberingPushbackReader" LineNumberingPushbackReader'new-2 [#_"Reader" ___r, #_"int" ___size]
        (merge (PushbackReader'new (LineNumberReader. ___r, ___size)) (LineNumberingPushbackReader'init))
    )

    #_method
    (§ defn #_"int" getLineNumber [#_"LineNumberingPushbackReader" this]
        (ß ((LineNumberReader) in).getLineNumber() + 1)
    )

    #_method
    (§ defn #_"void" setLineNumber [#_"LineNumberingPushbackReader" this, #_"int" ___line]
        (ß ((LineNumberReader) in).setLineNumber(___line - 1))
        nil
    )

    #_method
    (§ defn #_"int" getColumnNumber [#_"LineNumberingPushbackReader" this]
        (:_columnNumber this)
    )

    #_method
    (§ defn #_"int" read [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" ___c (ß super.read())]
            (§ ass (:_prev this) (:_atLineStart this))
            (if (ß (___c == LineNumberingPushbackReader'newline) || (___c == -1))
                (do
                    (§ ass (:_atLineStart this) true)
                    (§ ass (:_columnNumber this) 1)
                )
                (do
                    (§ ass (:_atLineStart this) false)
                    (§ ass (:_columnNumber this) (inc (:_columnNumber this)))
                )
            )
            ___c
        )
    )

    #_method
    (§ defn #_"void" unread [#_"LineNumberingPushbackReader" this, #_"int" ___c] #_(§ throws IOException)
        (ß super.unread(___c))
        (§ ass (:_atLineStart this) (:_prev this))
        (§ ass (:_columnNumber this) (dec (:_columnNumber this)))
        nil
    )

    #_method
    (§ defn #_"String" readLine [#_"LineNumberingPushbackReader" this] #_(§ throws IOException)
        (let [#_"int" ___c (ß read())]
            (§ let [#_"String" ___line]
                (§ switch ___c
                    (§ case -1)
                    (do
                        (§ ass ___line nil)
                        (§ break )
                    )
                    (§ case LineNumberingPushbackReader'newline)
                    (do
                        (§ ass ___line "")
                        (§ break )
                    )
                    (§ default )
                    (do
                        (let [#_"String" ___first (ß String/valueOf((char) ___c))]
                            (let [#_"String" ___rest (ß ((LineNumberReader)in).readLine())]
                                (§ ass ___line (ß (___rest == nil) ? ___first :or ___first + ___rest))
                                (§ ass (:_prev this) false)
                                (§ ass (:_atLineStart this) true)
                                (§ ass (:_columnNumber this) 1)
                                (§ break )
                            )
                        )
                    )
                )
                ___line
            )
        )
    )

    #_method
    (§ defn #_"boolean" atLineStart [#_"LineNumberingPushbackReader" this]
        (:_atLineStart this)
    )
)
)

(java-ns cloiure.lang.LispReader

(§ import java.io.IOException)
(§ import java.io.PushbackReader)
(§ import java.io.Reader)
(§ import java.lang.Character)
(§ import java.lang.Class)
(§ import java.lang.Exception)
(§ import java.lang.IllegalArgumentException)
(§ import java.lang.IllegalStateException)
(§ import java.lang.Integer)
(§ import java.lang.Number)
(§ import java.lang.NumberFormatException)
(§ import java.lang.Object)
(§ import java.lang.RuntimeException)
(§ import java.lang.String)
(§ import java.lang.StringBuilder)
(§ import java.lang.Throwable)
(§ import java.lang.UnsupportedOperationException)
(§ import java.lang.reflect.Constructor)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.LinkedList)
(§ import java.util.List)
(§ import java.util.Map)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)

(defprotocol Resolver
    #_abstract
    (#_"Symbol" Resolver'''currentNS [#_"Resolver" this])
    #_abstract
    (#_"Symbol" Resolver'''resolveClass [#_"Resolver" this, #_"Symbol" ___sym])
    #_abstract
    (#_"Symbol" Resolver'''resolveAlias [#_"Resolver" this, #_"Symbol" ___sym])
    #_abstract
    (#_"Symbol" Resolver'''resolveVar [#_"Resolver" this, #_"Symbol" ___sym])
)

(class-ns LispReaderException (§ extends RuntimeException)
    (defn- #_"LispReaderException" LispReaderException'init []
        (hash-map
            #_"int" :line 0
            #_"int" :column 0
        )
    )

    (defn #_"LispReaderException" LispReaderException'new [#_"int" ___line, #_"int" ___column, #_"Throwable" ___cause]
        (let [this (merge (§ foreign RuntimeException'new ___cause) (LispReaderException'init))]
            (§ ass (:line this) ___line)
            (§ ass (:column this) ___column)
            this
        )
    )
)

#_closure
(class-ns RegexReader (§ extends AFn)
    (defn #_"RegexReader" RegexReader'new []
        (AFn'new)
    )

    (§ def #_"LispStringReader" RegexReader'stringrdr (LispStringReader'new))

    #_method
    (§ defn #_"Object" invoke [#_"RegexReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [#_"int" ___ch (ß read1(___r))] (ß ___ch != \") [(ß read1(___r))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (Util'runtimeException-1 "EOF while reading regex"))
                    )
                    (ß ___sb.append((char) ___ch))
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (Util'runtimeException-1 "EOF while reading regex"))
                        )
                        (ß ___sb.append((char) ___ch))
                    )
                )
                (ß Pattern/compile(___sb.toString()))
            )
        )
    )
)

#_closure
(class-ns LispStringReader (§ extends AFn)
    (defn #_"LispStringReader" LispStringReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispStringReader" this, #_"Object" ___reader, #_"Object" ___doublequote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (let [#_"Reader" ___r (ß (Reader) ___reader)]
                (loop-when-recur [#_"int" ___ch (ß read1(___r))] (ß ___ch != \") [(ß read1(___r))] ;; oops! "
                    (when (ß ___ch == -1)
                        (throw (Util'runtimeException-1 "EOF while reading string"))
                    )
                    (when (ß ___ch == \\) ;; escape
                        (§ ass ___ch (ß read1(___r)))
                        (when (ß ___ch == -1)
                            (throw (Util'runtimeException-1 "EOF while reading string"))
                        )
                        (§ switch ___ch
                            (§ case \t)
                            (do
                                (§ ass ___ch \tab)
                                (§ break )
                            )
                            (§ case \r)
                            (do
                                (§ ass ___ch \return)
                                (§ break )
                            )
                            (§ case \n)
                            (do
                                (§ ass ___ch \newline)
                                (§ break )
                            )
                            (§ case \\)
                            (do
                                (§ break )
                            )
                            (§ case \") ;; oops! "
                            (do
                                (§ break )
                            )
                            (§ case \b)
                            (do
                                (§ ass ___ch \backspace)
                                (§ break )
                            )
                            (§ case \f)
                            (do
                                (§ ass ___ch \formfeed)
                                (§ break )
                            )
                            (§ case \u)
                            (do
                                (§ ass ___ch (ß read1(___r)))
                                (when (ß Character/digit(___ch, 16) == -1)
                                    (throw (Util'runtimeException-1 (str "Invalid unicode escape: \\u" (ß (char) ___ch))))
                                )
                                (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 16, 4, true)))
                                (§ break )
                            )
                            (§ default )
                            (do
                                (if (Character/isDigit ___ch)
                                    (do
                                        (§ ass ___ch (ß readUnicodeChar((PushbackReader) ___r, ___ch, 8, 3, false)))
                                        (when (> ___ch 0377)
                                            (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                        )
                                    )
                                    (do
                                        (throw (Util'runtimeException-1 (str "Unsupported escape character: \\" (ß (char) ___ch))))
                                    )
                                )
                                (§ break )
                            )
                        )
                    )
                    (ß ___sb.append((char) ___ch))
                )
                (ß ___sb.toString())
            )
        )
    )
)

#_closure
(class-ns LispCommentReader (§ extends AFn)
    (defn #_"LispCommentReader" LispCommentReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispCommentReader" this, #_"Object" ___reader, #_"Object" ___semicolon, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"Reader" ___r (ß (Reader) ___reader)]
            (§ let [#_"int" ___ch]
                (§ loop
                    (§ ass ___ch (ß read1(___r)))
                    (§ recur-if (___ch != -1 && ___ch != \newline && ___ch != \return))
                )
                ___r
            )
        )
    )
)

#_closure
(class-ns LispDiscardReader (§ extends AFn)
    (defn #_"LispDiscardReader" LispDiscardReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispDiscardReader" this, #_"Object" ___reader, #_"Object" ___underscore, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))
            ___r
        )
    )
)

;; :a.b{:c 1} => {:a.b/c 1}
;; ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
;; ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
#_closure
(class-ns LispNamespaceMapReader (§ extends AFn)
    (defn #_"LispNamespaceMapReader" LispNamespaceMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispNamespaceMapReader" this, #_"Object" ___reader, #_"Object" ___colon, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"boolean" ___auto false]
                (let [#_"int" ___autoChar (ß read1(___r))]
                    (if (ß ___autoChar == \:)
                        (do
                            (§ ass ___auto true)
                        )
                        (do
                            (ß unread(___r, ___autoChar))
                        )
                    )

                    (let [#_"Object" ___sym nil]
                        (let [#_"int" ___nextChar (ß read1(___r))]
                            (cond (ß isWhitespace(___nextChar)) ;; the #:: { } case or an error
                                (do
                                    (if ___auto
                                        (do
                                            (while (ß isWhitespace(___nextChar))
                                                (§ ass ___nextChar (ß read1(___r)))
                                            )
                                            (when (ß ___nextChar != \{)
                                                (ß unread(___r, ___nextChar))
                                                (throw (Util'runtimeException-1 "Namespaced map must specify a namespace"))
                                            )
                                        )
                                        (do
                                            (ß unread(___r, ___nextChar))
                                            (throw (Util'runtimeException-1 "Namespaced map must specify a namespace"))
                                        )
                                    )
                                )
                                (ß ___nextChar != \{) ;; #:foo { } or #::foo { }
                                (do
                                    (ß unread(___r, ___nextChar))
                                    (§ ass ___sym (ß read(___r, true, nil, false, ___opts, ___pendingForms)))
                                    (§ ass ___nextChar (ß read1(___r)))
                                    (while (ß isWhitespace(___nextChar))
                                        (§ ass ___nextChar (ß read1(___r)))
                                    )
                                )
                            )
                            (when (ß ___nextChar != \{)
                                (throw (Util'runtimeException-1 "Namespaced map must specify a map"))
                            )

                            ;; Resolve autoresolved ns
                            (§ let [#_"String" ___ns]
                                (cond ___auto
                                    (do
                                        (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                                            (cond (nil? ___sym)
                                                (do
                                                    (if (some? ___resolver)
                                                        (do
                                                            (§ ass ___ns (ß ___resolver.currentNS().name))
                                                        )
                                                        (do
                                                            (§ ass ___ns (ß Compiler'currentNS().getName().getName()))
                                                        )
                                                    )
                                                )
                                                (ß !(___sym instanceof Symbol) || ((Symbol)___sym).getNamespace() != nil)
                                                (do
                                                    (throw (Util'runtimeException-1 (str "Namespaced map must specify a valid namespace: " ___sym)))
                                                )
                                                :else
                                                (do
                                                    (§ let [#_"Symbol" ___resolvedNS]
                                                        (if (some? ___resolver)
                                                            (do
                                                                (§ ass ___resolvedNS (ß ___resolver.resolveAlias((Symbol) ___sym)))
                                                            )
                                                            (do
                                                                (let [#_"Namespace" ___rns (ß Compiler'currentNS().lookupAlias((Symbol)___sym))]
                                                                    (§ ass ___resolvedNS (ß (___rns != nil) ? ___rns.getName() :or nil))
                                                                )
                                                            )
                                                        )

                                                        (if (nil? ___resolvedNS)
                                                            (do
                                                                (throw (Util'runtimeException-1 (str "Unknown auto-resolved namespace alias: " ___sym)))
                                                            )
                                                            (do
                                                                (§ ass ___ns (ß ___resolvedNS.getName()))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (ß !(___sym instanceof Symbol) || ((Symbol)___sym).getNamespace() != nil)
                                    (do
                                        (throw (Util'runtimeException-1 (str "Namespaced map must specify a valid namespace: " ___sym)))
                                    )
                                    :else
                                    (do
                                        (§ ass ___ns (ß ((Symbol)___sym).getName()))
                                    )
                                )

                                ;; Read map
                                (let [#_"List" ___kvs (ß readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms)))]
                                    (when (ß (___kvs.size() & 1) == 1)
                                        (throw (Util'runtimeException-1 "Namespaced map literal must contain an even number of forms"))
                                    )

                                    ;; Construct output map
                                    (let [#_"Object[]" ___a (make-array Object (ß ___kvs.size()))]
                                        (let [#_"Iterator" ___iter (ß ___kvs.iterator())]
                                            (loop-when-recur [#_"int" ___i 0] (ß ___iter.hasNext()) [(+ ___i 2)]
                                                (let [#_"Object" ___key (ß ___iter.next())]
                                                    (let [#_"Object" ___val (ß ___iter.next())]
                                                        (cond (ß ___key instanceof Keyword)
                                                            (do
                                                                (let [#_"Keyword" ___kw (ß (Keyword) ___key)]
                                                                    (cond (ß ___kw.getNamespace() == nil)
                                                                        (do
                                                                            (§ ass ___key (ß Keyword'intern-2(___ns, ___kw.getName())))
                                                                        )
                                                                        (ß ___kw.getNamespace().equals("_"))
                                                                        (do
                                                                            (§ ass ___key (ß Keyword'intern-2(nil, ___kw.getName())))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (ß ___key instanceof Symbol)
                                                            (do
                                                                (let [#_"Symbol" ___s (ß (Symbol) ___key)]
                                                                    (cond (ß ___s.getNamespace() == nil)
                                                                        (do
                                                                            (§ ass ___key (ß Symbol'intern-2(___ns, ___s.getName())))
                                                                        )
                                                                        (ß ___s.getNamespace().equals("_"))
                                                                        (do
                                                                            (§ ass ___key (ß Symbol'intern-2(nil, ___s.getName())))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                        (§ ass (ß ___a[___i]) ___key)
                                                        (§ ass (ß ___a[___i + 1]) ___val)
                                                    )
                                                )
                                            )
                                            (RT'map ___a)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispSymbolicValueReader (§ extends AFn)
    (defn #_"LispSymbolicValueReader" LispSymbolicValueReader'new []
        (AFn'new)
    )

    (def #_"IPersistentMap" LispSymbolicValueReader'specials (ß PersistentHashMap'create-1a(
        (§ map
            (Symbol'intern-1 "Inf")  Double/POSITIVE_INFINITY
            (Symbol'intern-1 "-Inf") Double/NEGATIVE_INFINITY
            (Symbol'intern-1 "NaN")  Double/NaN
        )
    )))

    #_method
    (§ defn #_"Object" invoke [#_"LispSymbolicValueReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (when (ß !(___o instanceof Symbol))
                    (throw (Util'runtimeException-1 (str "Invalid token: ##" ___o)))
                )
                (when (ß !(LispSymbolicValueReader'specials.containsKey(___o)))
                    (throw (Util'runtimeException-1 (str "Unknown symbolic value: ##" ___o)))
                )

                (ß LispSymbolicValueReader'specials.valAt(___o))
            )
        )
    )
)

(class-ns WrappingReader (§ extends AFn)
    (defn- #_"WrappingReader" WrappingReader'init []
        (hash-map
            #_"Symbol" :sym nil
        )
    )

    (defn #_"WrappingReader" WrappingReader'new [#_"Symbol" ___sym]
        (let [this (merge (AFn'new) (WrappingReader'init))]
            (§ ass (:sym this) ___sym)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"WrappingReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (RT'list-2 (:sym this), ___o)
            )
        )
    )
)

(class-ns DeprecatedWrappingReader (§ extends AFn)
    (defn- #_"DeprecatedWrappingReader" DeprecatedWrappingReader'init []
        (hash-map
            #_"Symbol" :sym nil
            #_"String" :macro nil
        )
    )

    (defn #_"DeprecatedWrappingReader" DeprecatedWrappingReader'new [#_"Symbol" ___sym, #_"String" ___macro]
        (let [this (merge (AFn'new) (DeprecatedWrappingReader'init))]
            (§ ass (:sym this) ___sym)
            (§ ass (:macro this) ___macro)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"DeprecatedWrappingReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (ß System/out.println("WARNING: reader macro " + (:macro this) + " is deprecated; use " + (:sym this).getName() + " instead"))
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (RT'list-2 (:sym this), ___o)
            )
        )
    )
)

#_closure
(class-ns VarReader (§ extends AFn)
    (defn #_"VarReader" VarReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"VarReader" this, #_"Object" ___reader, #_"Object" ___quote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (RT'list-2 LispReader'THE_VAR, ___o)
            )
        )
    )
)

#_closure
(class-ns LispDispatchReader (§ extends AFn)
    (defn #_"LispDispatchReader" LispDispatchReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispDispatchReader" this, #_"Object" ___reader, #_"Object" ___hash, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"int" ___ch (ß read1((Reader) ___reader))]
            (when (ß ___ch == -1)
                (throw (Util'runtimeException-1 "EOF while reading character"))
            )
            (let [#_"IFn" ___fn (ß dispatchMacros[___ch])]
                ;; Try the ctor reader first
                (when (nil? ___fn)
                    (ß unread((PushbackReader) ___reader, ___ch))
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                    (let [#_"Object" ___result (ß ctorReader.invoke(___reader, ___ch, ___opts, ___pendingForms))]
                        (if (some? ___result)
                            (do
                                (§ return ___result)
                            )
                            (do
                                (throw (Util'runtimeException-1 (String/format "No dispatch macro for: %c", (§ array (ß (char) ___ch)))))
                            )
                        )
                    )
                )
                (ß ___fn.invoke(___reader, ___ch, ___opts, ___pendingForms))
            )
        )
    )
)

#_closure
(class-ns FnReader (§ extends AFn)
    (defn #_"FnReader" FnReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"FnReader" this, #_"Object" ___reader, #_"Object" ___lparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (when (ß LispReader'ARG_ENV.deref() != nil)
                (throw (IllegalStateException. "Nested #()s are not allowed"))
            )
            (try
                (ß Var'pushThreadBindings(RT'map(LispReader'ARG_ENV, PersistentTreeMap'EMPTY)))
                (ß unread(___r, \())
                (let [#_"Object" ___form (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                    (let [#_"PersistentVector" ___args PersistentVector'EMPTY]
                        (let [#_"PersistentTreeMap" ___argsyms (ß (PersistentTreeMap) LispReader'ARG_ENV.deref())]
                            (let [#_"ISeq" ___rargs (ß ___argsyms.rseq())]
                                (when (some? ___rargs)
                                    (let [#_"int" ___higharg (ß (Integer) ((Map$Entry) ___rargs.first()).getKey())]
                                        (when (> ___higharg 0)
                                            (loop-when-recur [#_"int" ___i 1] (ß ___i <= ___higharg) [(inc ___i)]
                                                (let [#_"Object" ___sym (ß ___argsyms.valAt(___i))]
                                                    (when (nil? ___sym)
                                                        (§ ass ___sym (ß garg(___i)))
                                                    )
                                                    (§ ass ___args (ß ___args.cons(___sym)))
                                                )
                                            )
                                        )
                                        (let [#_"Object" ___restsym (ß ___argsyms.valAt(-1))]
                                            (when (some? ___restsym)
                                                (§ ass ___args (ß ___args.cons(Compiler'_AMP_)))
                                                (§ ass ___args (ß ___args.cons(___restsym)))
                                            )
                                        )
                                    )
                                )
                                (RT'list-3 Compiler'FN, ___args, ___form)
                            )
                        )
                    )
                )
                (finally
                    (ß Var'popThreadBindings())
                )
            )
        )
    )
)

#_closure
(class-ns ArgReader (§ extends AFn)
    (defn #_"ArgReader" ArgReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"ArgReader" this, #_"Object" ___reader, #_"Object" ___pct, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (when (ß LispReader'ARG_ENV.deref() == nil)
                (§ return (ß interpretToken(readToken(___r, \%), nil)))
            )
            (let [#_"int" ___ch (ß read1(___r))]
                (ß unread(___r, ___ch))
                ;; % alone is first arg
                (when (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                    (§ return (ß registerArg(1)))
                )
                (let [#_"Object" ___n (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                    (when (ß ___n.equals(Compiler'_AMP_))
                        (§ return (ß registerArg(-1)))
                    )
                    (when (ß !(___n instanceof Number))
                        (throw (IllegalStateException. "arg literal must be %, %& or %integer"))
                    )
                    (ß registerArg(((Number) ___n).intValue()))
                )
            )
        )
    )
)

#_closure
(class-ns LispMetaReader (§ extends AFn)
    (defn #_"LispMetaReader" LispMetaReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispMetaReader" this, #_"Object" ___reader, #_"Object" ___caret, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
                        (§ ass ___column (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()-1))
                    )
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                    (let [#_"Object" ___meta (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                        (cond (ß ___meta instanceof Symbol || ___meta instanceof String)
                            (do
                                (§ ass ___meta (RT'map RT'TAG_KEY, ___meta))
                            )
                            (ß ___meta instanceof Keyword)
                            (do
                                (§ ass ___meta (RT'map ___meta, RT'T))
                            )
                            (ß !(___meta instanceof IPersistentMap))
                            (do
                                (throw (IllegalArgumentException. "Metadata must be Symbol, Keyword, String or Map"))
                            )
                        )

                        (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                            (if (ß ___o instanceof IMeta)
                                (do
                                    (when (ß ___line != -1 && ___o instanceof ISeq)
                                        (§ ass ___meta (ß ((IPersistentMap) ___meta).assoc(RT'LINE_KEY, ___line).assoc(RT'COLUMN_KEY, ___column)))
                                    )
                                    (when (ß ___o instanceof IReference)
                                        (ß ((IReference)___o).resetMeta((IPersistentMap) ___meta))
                                        (§ return ___o)
                                    )
                                    (let [#_"Object" ___ometa (RT'meta ___o)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'seq ___meta)] (some? ___s) [(ß ___s.next())]
                                            (let [#_"IMapEntry" ___kv (ß (IMapEntry) ___s.first())]
                                                (§ ass ___ometa (ß RT'assoc(___ometa, ___kv.getKey(), ___kv.getValue())))
                                            )
                                        )
                                        (ß ((IObj) ___o).withMeta((IPersistentMap) ___ometa))
                                    )
                                )
                                (do
                                    (throw (IllegalArgumentException. "Metadata can only be applied to IMetas"))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns SyntaxQuoteReader (§ extends AFn)
    (defn #_"SyntaxQuoteReader" SyntaxQuoteReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"SyntaxQuoteReader" this, #_"Object" ___reader, #_"Object" ___backquote, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (try
                (ß Var'pushThreadBindings(RT'map(LispReader'GENSYM_ENV, PersistentHashMap'EMPTY)))

                (let [#_"Object" ___form (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                    (ß syntaxQuote(___form))
                )
                (finally
                    (ß Var'popThreadBindings())
                )
            )
        )
    )

    (defn #_"Object" SyntaxQuoteReader'syntaxQuote [#_"Object" ___form]
        (§ let [#_"Object" ___ret]
            (cond (Compiler'isSpecial ___form)
                (do
                    (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___form))
                )
                (ß ___form instanceof Symbol)
                (do
                    (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                        (let [#_"Symbol" ___sym (ß (Symbol) ___form)]
                            (cond (ß (:ns ___sym) == nil && (:name ___sym).endsWith("#"))
                                (do
                                    (let [#_"IPersistentMap" ___gmap (ß (IPersistentMap) LispReader'GENSYM_ENV.deref())]
                                        (when (nil? ___gmap)
                                            (throw (IllegalStateException. "Gensym literal not in syntax-quote"))
                                        )
                                        (let [#_"Symbol" ___gs (ß (Symbol) ___gmap.valAt(___sym))]
                                            (when (nil? ___gs)
                                                (ß LispReader'GENSYM_ENV.set(___gmap.assoc(___sym, (§ ass ___gs (ß Symbol'intern-2(nil, (:name ___sym).substring(0, (:name ___sym).length() - 1) + "__" + RT'nextID() + "__auto__"))))))
                                            )
                                            (§ ass ___sym ___gs)
                                        )
                                    )
                                )
                                (ß (:ns ___sym) == nil && (:name ___sym).endsWith("."))
                                (do
                                    (let [#_"Symbol" ___csym (ß Symbol'intern-2(nil, (:name ___sym).substring(0, (:name ___sym).length() - 1)))]
                                        (if (some? ___resolver)
                                            (do
                                                (let [#_"Symbol" ___rc (ß ___resolver.resolveClass(___csym))]
                                                    (when (some? ___rc)
                                                        (§ ass ___csym ___rc)
                                                    )
                                                )
                                            )
                                            (do
                                                (§ ass ___csym (Compiler'resolveSymbol ___csym))
                                            )
                                        )
                                        (§ ass ___sym (ß Symbol'intern-2(nil, (:name ___csym).concat("."))))
                                    )
                                )
                                (ß (:ns ___sym) == nil && (:name ___sym).startsWith("."))
                                (do
                                    ;; Simply quote method names.
                                )
                                (some? ___resolver)
                                (do
                                    (let [#_"Symbol" ___nsym nil]
                                        (when (ß (:ns ___sym) != nil)
                                            (let [#_"Symbol" ___alias (ß Symbol'intern-2(nil, (:ns ___sym)))]
                                                (§ ass ___nsym (ß ___resolver.resolveClass(___alias)))
                                                (when (nil? ___nsym)
                                                    (§ ass ___nsym (ß ___resolver.resolveAlias(___alias)))
                                                )
                                            )
                                        )
                                        (cond (some? ___nsym)
                                            (do
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass ___sym (ß Symbol'intern-2((:name ___nsym), (:name ___sym))))
                                            )
                                            (ß (:ns ___sym) == nil)
                                            (do
                                                (let [#_"Symbol" ___rsym (ß ___resolver.resolveClass(___sym))]
                                                    (when (nil? ___rsym)
                                                        (§ ass ___rsym (ß ___resolver.resolveVar(___sym)))
                                                    )
                                                    (if (some? ___rsym)
                                                        (do
                                                            (§ ass ___sym ___rsym)
                                                        )
                                                        (do
                                                            (§ ass ___sym (ß Symbol'intern-2(___resolver.currentNS().name, (:name ___sym))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        ;; leave alone if qualified
                                    )
                                )
                                :else
                                (do
                                    (let [#_"Object" ___maybeClass nil]
                                        (when (ß (:ns ___sym) != nil)
                                            (§ ass ___maybeClass (ß Compiler'currentNS().getMapping(Symbol'intern-2(nil, (:ns ___sym)))))
                                        )
                                        (if (ß ___maybeClass instanceof Class)
                                            (do
                                                ;; Classname/foo -> package.qualified.Classname/foo
                                                (§ ass ___sym (ß Symbol'intern-2(((Class)___maybeClass).getName(), (:name ___sym))))
                                            )
                                            (do
                                                (§ ass ___sym (Compiler'resolveSymbol ___sym))
                                            )
                                        )
                                    )
                                )
                            )
                            (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___sym))
                        )
                    )
                )
                (ß isUnquote(___form))
                (do
                    (§ return (RT'second ___form))
                )
                (ß isUnquoteSplicing(___form))
                (do
                    (throw (IllegalStateException. "splice not in list"))
                )
                (ß ___form instanceof IPersistentCollection)
                (do
                    (cond (ß ___form instanceof IRecord)
                        (do
                            (§ ass ___ret ___form)
                        )
                        (ß ___form instanceof IPersistentMap)
                        (do
                            (let [#_"IPersistentVector" ___keyvals (SyntaxQuoteReader'flattenMap ___form)]
                                (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'HASHMAP, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList(___keyvals.seq()))))))
                            )
                        )
                        (ß ___form instanceof IPersistentVector)
                        (do
                            (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'VECTOR, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList(((IPersistentVector) ___form).seq()))))))
                        )
                        (ß ___form instanceof IPersistentSet)
                        (do
                            (§ ass ___ret (ß RT'list-3(LispReader'APPLY, LispReader'HASHSET, RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList(((IPersistentSet) ___form).seq()))))))
                        )
                        (ß ___form instanceof ISeq || ___form instanceof IPersistentList)
                        (do
                            (let [#_"ISeq" ___seq (RT'seq ___form)]
                                (if (nil? ___seq)
                                    (do
                                        (§ ass ___ret (RT'cons LispReader'LIST, nil))
                                    )
                                    (do
                                        (§ ass ___ret (ß RT'list-2(LispReader'SEQ, RT'cons(LispReader'CONCAT, sqExpandList(___seq)))))
                                    )
                                )
                            )
                        )
                        :else
                        (do
                            (throw (UnsupportedOperationException. "Unknown Collection type"))
                        )
                    )
                )
                (ß ___form instanceof Keyword || ___form instanceof Number || ___form instanceof Character || ___form instanceof String)
                (do
                    (§ ass ___ret ___form)
                )
                :else
                (do
                    (§ ass ___ret (RT'list-2 Compiler'QUOTE, ___form))
                )
            )

            (when (ß ___form instanceof IObj && RT'meta(___form) != nil)
                ;; filter line and column numbers
                (let [#_"IPersistentMap" ___newMeta (ß ((IObj) ___form).meta().without(RT'LINE_KEY).without(RT'COLUMN_KEY))]
                    (when (ß ___newMeta.count() > 0)
                        (§ return (ß RT'list-3(LispReader'WITH_META, ___ret, syntaxQuote(((IObj) ___form).meta()))))
                    )
                )
            )
            ___ret
        )
    )

    (defn- #_"ISeq" SyntaxQuoteReader'sqExpandList [#_"ISeq" ___seq]
        (let [#_"PersistentVector" ___ret PersistentVector'EMPTY]
            (loop-when-recur [___seq ___seq] (some? ___seq) [(ß ___seq.next())]
                (let [#_"Object" ___item (ß ___seq.first())]
                    (cond (ß isUnquote(___item))
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'list-2(LispReader'LIST, RT'second(___item)))))
                        )
                        (ß isUnquoteSplicing(___item))
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'second(___item))))
                        )
                        :else
                        (do
                            (§ ass ___ret (ß ___ret.cons(RT'list-2(LispReader'LIST, syntaxQuote(___item)))))
                        )
                    )
                )
            )
            (ß ___ret.seq())
        )
    )

    (defn- #_"IPersistentVector" SyntaxQuoteReader'flattenMap [#_"Object" ___form]
        (let [#_"IPersistentVector" ___keyvals PersistentVector'EMPTY]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___form)] (some? ___s) [(ß ___s.next())]
                (let [#_"IMapEntry" ___e (ß (IMapEntry) ___s.first())]
                    (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___e.key())))
                    (§ ass ___keyvals (ß (IPersistentVector) ___keyvals.cons(___e.val())))
                )
            )
            ___keyvals
        )
    )
)

#_closure
(class-ns UnquoteReader (§ extends AFn)
    (defn #_"UnquoteReader" UnquoteReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"UnquoteReader" this, #_"Object" ___reader, #_"Object" ___comma, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß read1(___r))]
                (when (ß ___ch == -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
                (if (ß ___ch == \@)
                    (do
                        (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                            (RT'list-2 LispReader'UNQUOTE_SPLICING, ___o)
                        )
                    )
                    (do
                        (ß unread(___r, ___ch))
                        (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                            (RT'list-2 LispReader'UNQUOTE, ___o)
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispCharacterReader (§ extends AFn)
    (defn #_"LispCharacterReader" LispCharacterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispCharacterReader" this, #_"Object" ___reader, #_"Object" ___backslash, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß read1(___r))]
                (when (ß ___ch == -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )
                (let [#_"String" ___token (ß readToken(___r, (char) ___ch))]
                    (cond (ß ___token.length() == 1)
                        (do
                            (§ return (ß Character/valueOf(___token.charAt(0))))
                        )
                        (ß ___token.equals("newline"))
                        (do
                            (§ return \newline)
                        )
                        (ß ___token.equals("space"))
                        (do
                            (§ return \space)
                        )
                        (ß ___token.equals("tab"))
                        (do
                            (§ return \tab)
                        )
                        (ß ___token.equals("backspace"))
                        (do
                            (§ return \backspace)
                        )
                        (ß ___token.equals("formfeed"))
                        (do
                            (§ return \formfeed)
                        )
                        (ß ___token.equals("return"))
                        (do
                            (§ return \return)
                        )
                        (ß ___token.startsWith("u"))
                        (do
                            (let [#_"char" ___c (ß (char) readUnicodeChar(___token, 1, 4, 16))]
                                (when (ß ___c >= (§ char "\ud800") && ___c <= (§ char "\udfff")) ;; surrogate code unit?
                                    (throw (Util'runtimeException-1 (str "Invalid character constant: \\u" (Integer/toString ___c, 16))))
                                )
                                (§ return ___c)
                            )
                        )
                        (ß ___token.startsWith("o"))
                        (do
                            (let [#_"int" ___len (ß ___token.length() - 1)]
                                (when (> ___len 3)
                                    (throw (Util'runtimeException-1 (str "Invalid octal escape sequence length: " ___len)))
                                )
                                (let [#_"int" ___uc (ß readUnicodeChar(___token, 1, ___len, 8))]
                                    (when (> ___uc 0377)
                                        (throw (Util'runtimeException-1 "Octal escape sequence must be in range [0, 377]."))
                                    )
                                    (§ return (ß (char) ___uc))
                                )
                            )
                        )
                    )
                    (throw (Util'runtimeException-1 (str "Unsupported character: \\" ___token)))
                )
            )
        )
    )
)

#_closure
(class-ns LispListReader (§ extends AFn)
    (defn #_"LispListReader" LispListReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispListReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___line -1]
                (let [#_"int" ___column -1]
                    (when (ß ___r instanceof LineNumberingPushbackReader)
                        (§ ass ___line (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
                        (§ ass ___column (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()-1))
                    )
                    (let [#_"List" ___list (ß readDelimitedList(\), ___r, true, ___opts, ensurePending(___pendingForms)))]
                        (when (ß ___list.isEmpty())
                            (§ return PersistentList'EMPTY)
                        )
                        (let [#_"IObj" ___s (ß (IObj) PersistentList'create(___list))]
                            (if (ß ___line != -1)
                                (do
                                    (ß ___s.withMeta(RT'map(
                                        (§ map
                                            RT'LINE_KEY   ___line
                                            RT'COLUMN_KEY ___column
                                        )
                                    )))
                                )
                                (do
                                    ___s
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns EvalReader (§ extends AFn)
    (defn #_"EvalReader" EvalReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"EvalReader" this, #_"Object" ___reader, #_"Object" ___eq, #_"Object" ___opts, #_"Object" ___pendingForms]
        (when (ß !RT'booleanCast-1o(RT'READEVAL.deref()))
            (throw (Util'runtimeException-1 "EvalReader not allowed when *read-eval* is false."))
        )

        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object" ___o (ß read(___r, true, nil, true, ___opts, ensurePending(___pendingForms)))]
                (cond (ß ___o instanceof Symbol)
                    (do
                        (ß RT'classForName-1(___o.toString()))
                    )
                    (ß ___o instanceof IPersistentList)
                    (do
                        (let [#_"Symbol" ___fs (ß (Symbol) RT'first(___o))]
                            (when (ß ___fs.equals(LispReader'THE_VAR))
                                (let [#_"Symbol" ___vs (ß (Symbol) RT'second(___o))]
                                    (§ return (ß RT'var-2((:ns ___vs), (:name ___vs))))
                                )
                            )
                            (when (ß (:name ___fs).endsWith("."))
                                (let [#_"Object[]" ___args (ß RT'toArray(RT'next(___o)))]
                                    (§ return (ß Reflector'invokeConstructor(RT'classForName-1((:name ___fs).substring(0, (:name ___fs).length() - 1)), ___args)))
                                )
                            )
                            (when (Compiler'namesStaticMember ___fs)
                                (let [#_"Object[]" ___args (ß RT'toArray(RT'next(___o)))]
                                    (§ return (ß Reflector'invokeStaticMethod-3s((:ns ___fs), (:name ___fs), ___args)))
                                )
                            )
                            (let [#_"Object" ___v (ß Compiler'maybeResolveIn(Compiler'currentNS(), ___fs))]
                                (when (ß ___v instanceof Var)
                                    (§ return (ß ((IFn) ___v).applyTo(RT'next(___o))))
                                )
                                (throw (Util'runtimeException-1 (str "Can't resolve " ___fs)))
                            )
                        )
                    )
                    :else
                    (do
                        (throw (IllegalArgumentException. "Unsupported #= form"))
                    )
                )
            )
        )
    )
)

#_closure
(class-ns LispVectorReader (§ extends AFn)
    (defn #_"LispVectorReader" LispVectorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispVectorReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß LazilyPersistentVector'create(readDelimitedList(\], ___r, true, ___opts, ensurePending(___pendingForms))))
        )
    )
)

#_closure
(class-ns LispMapReader (§ extends AFn)
    (defn #_"LispMapReader" LispMapReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispMapReader" this, #_"Object" ___reader, #_"Object" ___leftparen, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"Object[]" ___a (ß readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms)).toArray())]
                (when (ß (___a.length & 1) == 1)
                    (throw (Util'runtimeException-1 "Map literal must contain an even number of forms"))
                )
                (RT'map ___a)
            )
        )
    )
)

#_closure
(class-ns LispSetReader (§ extends AFn)
    (defn #_"LispSetReader" LispSetReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispSetReader" this, #_"Object" ___reader, #_"Object" ___leftbracket, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (ß PersistentHashSet'createWithCheck-1l(readDelimitedList(\}, ___r, true, ___opts, ensurePending(___pendingForms))))
        )
    )
)

#_closure
(class-ns LispUnmatchedDelimiterReader (§ extends AFn)
    (defn #_"LispUnmatchedDelimiterReader" LispUnmatchedDelimiterReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispUnmatchedDelimiterReader" this, #_"Object" ___reader, #_"Object" ___rightdelim, #_"Object" ___opts, #_"Object" ___pendingForms]
        (throw (Util'runtimeException-1 (str "Unmatched delimiter: " ___rightdelim)))
    )
)

#_closure
(class-ns LispUnreadableReader (§ extends AFn)
    (defn #_"LispUnreadableReader" LispUnreadableReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"LispUnreadableReader" this, #_"Object" ___reader, #_"Object" ___leftangle, #_"Object" ___opts, #_"Object" ___pendingForms]
        (throw (Util'runtimeException-1 "Unreadable form"))
    )
)

#_closure
(class-ns CtorReader (§ extends AFn)
    (defn #_"CtorReader" CtorReader'new []
        (AFn'new)
    )

    #_method
    (§ defn #_"Object" invoke [#_"CtorReader" this, #_"Object" ___reader, #_"Object" ___firstChar, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (§ ass ___pendingForms (ß ensurePending(___pendingForms)))
            (let [#_"Object" ___name (ß read(___r, true, nil, false, ___opts, ___pendingForms))]
                (when (ß !(___name instanceof Symbol))
                    (throw (RuntimeException. "Reader tag must be a symbol"))
                )
                (let [#_"Symbol" ___sym (ß (Symbol)___name)]
                    (let [#_"Object" ___form (ß read(___r, true, nil, true, ___opts, ___pendingForms))]
                        (if (ß isPreserveReadCond(___opts) || RT'suppressRead())
                            (do
                                (TaggedLiteral'create ___sym, ___form)
                            )
                            (do
                                (ß ___sym.getName().contains(".") ? readRecord(___form, ___sym, ___opts, ___pendingForms) :or readTagged(___form, ___sym, ___opts, ___pendingForms))
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" readTagged [#_"CtorReader" this, #_"Object" ___o, #_"Symbol" ___tag, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"ILookup" ___data_readers (ß (ILookup)RT'DATA_READERS.deref())]
            (let [#_"IFn" ___data_reader (ß (IFn)RT'get-2(___data_readers, ___tag))]
                (when (nil? ___data_reader)
                    (§ ass ___data_readers (ß (ILookup)RT'DEFAULT_DATA_READERS.deref()))
                    (§ ass ___data_reader (ß (IFn)RT'get-2(___data_readers, ___tag)))
                    (when (nil? ___data_reader)
                        (let [#_"IFn" ___default_reader (ß (IFn)RT'DEFAULT_DATA_READER_FN.deref())]
                            (if (some? ___default_reader)
                                (do
                                    (§ return (ß ___default_reader.invoke(___tag, ___o)))
                                )
                                (do
                                    (throw (RuntimeException. (str "No reader function for tag " (ß ___tag.toString()))))
                                )
                            )
                        )
                    )
                )

                (ß ___data_reader.invoke(___o))
            )
        )
    )

    #_method
    (§ defn- #_"Object" readRecord [#_"CtorReader" this, #_"Object" ___form, #_"Symbol" ___recordName, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"boolean" ___readeval (ß RT'booleanCast-1o(RT'READEVAL.deref()))]
            (when (ß !___readeval)
                (throw (Util'runtimeException-1 "Record construction syntax can only be used when *read-eval* == true"))
            )

            (let [#_"Class" ___recordClass (ß RT'classForNameNonLoading(___recordName.toString()))]
                (let [#_"boolean" ___shortForm true]
                    (cond (ß ___form instanceof IPersistentMap)
                        (do
                            (§ ass ___shortForm false)
                        )
                        (ß ___form instanceof IPersistentVector)
                        (do
                            (§ ass ___shortForm true)
                        )
                        :else
                        (do
                            (throw (Util'runtimeException-1 (str "Unreadable constructor form starting with \"#" ___recordName "\"")))
                        )
                    )

                    (let [#_"Object" ___ret nil]
                        (let [#_"Constructor[]" ___allctors (ß ((Class)___recordClass).getConstructors())]
                            (if ___shortForm
                                (do
                                    (let [#_"IPersistentVector" ___recordEntries (ß (IPersistentVector)___form)]
                                        (let [#_"boolean" ___ctorFound false]
                                            (doseq [#_"Constructor" ___ctor ___allctors]
                                                (when (ß ___ctor.getParameterTypes().length == ___recordEntries.count())
                                                    (§ ass ___ctorFound true)
                                                )
                                            )

                                            (when (ß !___ctorFound)
                                                (throw (Util'runtimeException-1 (str "Unexpected number of constructor arguments to " (ß ___recordClass.toString()) ": got " (ß ___recordEntries.count()))))
                                            )

                                            (§ ass ___ret (ß Reflector'invokeConstructor(___recordClass, RT'toArray(___recordEntries))))
                                        )
                                    )
                                )
                                (do
                                    (let [#_"IPersistentMap" ___vals (ß (IPersistentMap)___form)]
                                        (loop-when-recur [#_"ISeq" ___s (RT'keys ___vals)] (some? ___s) [(ß ___s.next())]
                                            (when (ß !(___s.first() instanceof Keyword))
                                                (throw (Util'runtimeException-1 (str "Unreadable defrecord form: key must be of type cloiure.lang.Keyword, got " (ß ___s.first().toString()))))
                                            )
                                        )
                                        (§ ass ___ret (ß Reflector'invokeStaticMethod-3c(___recordClass, "create", new Object[] (§ array ___vals ))))
                                    )
                                )
                            )

                            ___ret
                        )
                    )
                )
            )
        )
    )
)

#_closure
(class-ns ConditionalReader (§ extends AFn)
    (defn #_"ConditionalReader" ConditionalReader'new []
        (AFn'new)
    )

    (def- #_"Object" ConditionalReader'READ_STARTED (Object.))
    (§ def #_"Keyword" ConditionalReader'DEFAULT_FEATURE (Keyword'intern-2 nil, "default"))
    (def #_"IPersistentSet" ConditionalReader'RESERVED_FEATURES (ß RT'set(Keyword'intern-2(nil, "else"), Keyword'intern-2(nil, "none"))))

    (defn #_"boolean" ConditionalReader'hasFeature [#_"Object" ___feature, #_"Object" ___opts]
        (when (ß !(___feature instanceof Keyword))
            (throw (Util'runtimeException-1 (str "Feature should be a keyword: " ___feature)))
        )

        (when (ß ConditionalReader'DEFAULT_FEATURE.equals(___feature))
            (§ return true)
        )

        (let [#_"IPersistentSet" ___custom (ß (IPersistentSet) ((IPersistentMap)___opts).valAt(LispReader'OPT_FEATURES))]
            (ß (___custom != nil && ___custom.contains(___feature)))
        )
    )

    (defn #_"Object" ConditionalReader'readCondDelimited [#_"PushbackReader" ___r, #_"boolean" ___splicing, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"Object" ___result ConditionalReader'READ_STARTED]
            (§ let [#_"Object" ___form] ;; The most recently ready form
                (let [#_"boolean" ___toplevel (ß (___pendingForms == nil))]
                    (§ ass ___pendingForms (ß ensurePending(___pendingForms)))

                    (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) ___r).getLineNumber() :or -1)]
                        (while true
                            (when (ß ___result == ConditionalReader'READ_STARTED)
                                ;; Read the next feature
                                (§ ass ___form (ß read(___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, nil)))

                                (cond (ß ___form == LispReader'READ_EOF)
                                    (do
                                        (if (< ___firstline 0)
                                            (do
                                                (throw (Util'runtimeException-1 "EOF while reading"))
                                            )
                                            (do
                                                (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                            )
                                        )
                                    )
                                    (ß ___form == LispReader'READ_FINISHED)
                                    (do
                                        (§ break ) ;; read-cond form is done
                                    )
                                )

                                (when (ß ConditionalReader'RESERVED_FEATURES.contains(___form))
                                    (throw (Util'runtimeException-1 (str "Feature name " ___form " is reserved.")))
                                )

                                (when (ß hasFeature(___form, ___opts))
                                    ;; Read the form corresponding to the feature, and assign it to result if everything is kosher
                                    (§ ass ___form (ß read(___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, (Resolver) RT'READER_RESOLVER.deref())))

                                    (cond (ß ___form == LispReader'READ_EOF)
                                        (do
                                            (if (< ___firstline 0)
                                                (do
                                                    (throw (Util'runtimeException-1 "EOF while reading"))
                                                )
                                                (do
                                                    (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                                )
                                            )
                                        )
                                        (ß ___form == LispReader'READ_FINISHED)
                                        (do
                                            (if (< ___firstline 0)
                                                (do
                                                    (throw (Util'runtimeException-1 "read-cond requires an even number of forms."))
                                                )
                                                (do
                                                    (throw (Util'runtimeException-1 (str "read-cond starting on line " ___firstline " requires an even number of forms")))
                                                )
                                            )
                                        )
                                        :else
                                        (do
                                            (§ ass ___result ___form)
                                        )
                                    )
                                )
                            )

                            ;; When we already have a result, or when the feature didn't match, discard the next form in the reader
                            (try
                                (ß Var'pushThreadBindings(RT'map(RT'SUPPRESS_READ, RT'T)))
                                (§ ass ___form (ß read(___r, false, LispReader'READ_EOF, \), LispReader'READ_FINISHED, true, ___opts, ___pendingForms, (Resolver) RT'READER_RESOLVER.deref())))

                                (cond (ß ___form == LispReader'READ_EOF)
                                    (do
                                        (if (< ___firstline 0)
                                            (do
                                                (throw (Util'runtimeException-1 "EOF while reading"))
                                            )
                                            (do
                                                (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                            )
                                        )
                                    )
                                    (ß ___form == LispReader'READ_FINISHED)
                                    (do
                                        (§ break )
                                    )
                                )
                                (finally
                                    (ß Var'popThreadBindings())
                                )
                            )
                        )

                        (when (ß ___result == ConditionalReader'READ_STARTED) ;; no features matched
                            (§ return ___r)
                        )

                        (if ___splicing
                            (do
                                (when (ß !(___result instanceof List))
                                    (throw (Util'runtimeException-1 "Spliced form list in read-cond-splicing must implement java.util.List"))
                                )

                                (when ___toplevel
                                    (throw (Util'runtimeException-1 "Reader conditional splicing not allowed at the top level."))
                                )

                                (ß ((List)___pendingForms).addAll(0, (List)___result))

                                ___r
                            )
                            (do
                                ___result
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" ConditionalReader'checkConditionalAllowed [#_"Object" ___opts]
        (let [#_"IPersistentMap" ___mopts (ß (IPersistentMap)___opts)]
            (when (ß !(___opts != nil && (LispReader'COND_ALLOW.equals(___mopts.valAt(LispReader'OPT_READ_COND)) || LispReader'COND_PRESERVE.equals(___mopts.valAt(LispReader'OPT_READ_COND)))))
                (throw (Util'runtimeException-1 "Conditional read not allowed"))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"ConditionalReader" this, #_"Object" ___reader, #_"Object" ___mode, #_"Object" ___opts, #_"Object" ___pendingForms]
        (ConditionalReader'checkConditionalAllowed ___opts)

        (let [#_"PushbackReader" ___r (ß (PushbackReader) ___reader)]
            (let [#_"int" ___ch (ß read1(___r))]
                (when (ß ___ch == -1)
                    (throw (Util'runtimeException-1 "EOF while reading character"))
                )

                (let [#_"boolean" ___splicing false]
                    (when (ß ___ch == \@)
                        (§ ass ___splicing true)
                        (§ ass ___ch (ß read1(___r)))
                    )

                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (throw (Util'runtimeException-1 "EOF while reading character"))
                    )

                    (when (ß ___ch != \()
                        (throw (Util'runtimeException-1 "read-cond body must be a list"))
                    )

                    (try
                        (ß Var'pushThreadBindings(RT'map(LispReader'READ_COND_ENV, RT'T)))

                        (if (ß isPreserveReadCond(___opts))
                            (do
                                (let [#_"IFn" ___listReader (ß getMacro(___ch))] ;; should always be a list
                                    (let [#_"Object" ___form (ß ___listReader.invoke(___r, ___ch, ___opts, ensurePending(___pendingForms)))]
                                        (ReaderConditional'create ___form, ___splicing)
                                    )
                                )
                            )
                            (do
                                (ß readCondDelimited(___r, ___splicing, ___opts, ___pendingForms))
                            )
                        )
                        (finally
                            (ß Var'popThreadBindings())
                        )
                    )
                )
            )
        )
    )
)

#_stateless
(class-ns LispReader
    (§ def #_"Symbol" LispReader'QUOTE (Symbol'intern-1 "quote"))
    (§ def #_"Symbol" LispReader'THE_VAR (Symbol'intern-1 "var"))

    (§ def #_"Symbol" LispReader'UNQUOTE (Symbol'intern-2 "cloiure.core", "unquote"))
    (§ def #_"Symbol" LispReader'UNQUOTE_SPLICING (Symbol'intern-2 "cloiure.core", "unquote-splicing"))
    (§ def #_"Symbol" LispReader'CONCAT (Symbol'intern-2 "cloiure.core", "concat"))
    (§ def #_"Symbol" LispReader'SEQ (Symbol'intern-2 "cloiure.core", "seq"))
    (§ def #_"Symbol" LispReader'LIST (Symbol'intern-2 "cloiure.core", "list"))
    (§ def #_"Symbol" LispReader'APPLY (Symbol'intern-2 "cloiure.core", "apply"))
    (§ def #_"Symbol" LispReader'HASHMAP (Symbol'intern-2 "cloiure.core", "hash-map"))
    (§ def #_"Symbol" LispReader'HASHSET (Symbol'intern-2 "cloiure.core", "hash-set"))
    (§ def #_"Symbol" LispReader'VECTOR (Symbol'intern-2 "cloiure.core", "vector"))
    (§ def #_"Symbol" LispReader'WITH_META (Symbol'intern-2 "cloiure.core", "with-meta"))
    (§ def #_"Symbol" LispReader'META (Symbol'intern-2 "cloiure.core", "meta"))
    (§ def #_"Symbol" LispReader'DEREF (Symbol'intern-2 "cloiure.core", "deref"))
    (§ def #_"Symbol" LispReader'READ_COND (Symbol'intern-2 "cloiure.core", "read-cond"))
    (§ def #_"Symbol" LispReader'READ_COND_SPLICING (Symbol'intern-2 "cloiure.core", "read-cond-splicing"))
    (§ def #_"Keyword" LispReader'UNKNOWN (Keyword'intern-2 nil, "unknown"))

    (def #_"IFn[]" LispReader'macros (§ typeless make-array IFn 256))
    (def #_"IFn[]" LispReader'dispatchMacros (§ typeless make-array IFn 256))

    (def #_"Pattern" LispReader'symbolPat (Pattern/compile "[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)"))
    (def #_"Pattern" LispReader'intPat (Pattern/compile "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?"))
    (def #_"Pattern" LispReader'ratioPat (Pattern/compile "([-+]?[0-9]+)/([0-9]+)"))
    (def #_"Pattern" LispReader'floatPat (Pattern/compile "([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?"))

    ;; symbol->gensymbol
    (§ def #_"Var" LispReader'GENSYM_ENV (ß Var'create-1(nil).setDynamic()))
    ;; sorted-map num->gensymbol
    (§ def #_"Var" LispReader'ARG_ENV (ß Var'create-1(nil).setDynamic()))
    (§ def #_"IFn" LispReader'ctorReader (CtorReader'new))

    ;; Dynamic var set to true in a read-cond context
    (§ def #_"Var" LispReader'READ_COND_ENV (ß Var'create-1(nil).setDynamic()))

    (§ static
        (§ ass (ß macros[\"]) (LispStringReader'new)) ;; oops! "
        (§ ass (ß macros[\;]) (LispCommentReader'new))
        (§ ass (ß macros[\']) (WrappingReader'new LispReader'QUOTE))
        (§ ass (ß macros[\@]) (WrappingReader'new LispReader'DEREF))
        (§ ass (ß macros[\^]) (LispMetaReader'new))
        (§ ass (ß macros[\`]) (SyntaxQuoteReader'new))
        (§ ass (ß macros[\~]) (UnquoteReader'new))
        (§ ass (ß macros[\(]) (LispListReader'new))
        (§ ass (ß macros[\)]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\[]) (LispVectorReader'new))
        (§ ass (ß macros[\]]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\{]) (LispMapReader'new))
        (§ ass (ß macros[\}]) (LispUnmatchedDelimiterReader'new))
        (§ ass (ß macros[\\]) (LispCharacterReader'new))
        (§ ass (ß macros[\%]) (ArgReader'new))
        (§ ass (ß macros[\#]) (LispDispatchReader'new))

        (§ ass (ß dispatchMacros[\^]) (LispMetaReader'new))
        (§ ass (ß dispatchMacros[\#]) (LispSymbolicValueReader'new))
        (§ ass (ß dispatchMacros[\']) (VarReader'new))
        (§ ass (ß dispatchMacros[\"]) (RegexReader'new)) ;; oops! "
        (§ ass (ß dispatchMacros[\(]) (FnReader'new))
        (§ ass (ß dispatchMacros[\{]) (LispSetReader'new))
        (§ ass (ß dispatchMacros[\=]) (EvalReader'new))
        (§ ass (ß dispatchMacros[\!]) (LispCommentReader'new))
        (§ ass (ß dispatchMacros[\<]) (LispUnreadableReader'new))
        (§ ass (ß dispatchMacros[\_]) (LispDiscardReader'new))
        (§ ass (ß dispatchMacros[\?]) (ConditionalReader'new))
        (§ ass (ß dispatchMacros[\:]) (LispNamespaceMapReader'new))
    )

    (defn #_"boolean" LispReader'isWhitespace [#_"int" ___ch]
        (ß (Character/isWhitespace(___ch) || ___ch == \,))
    )

    (defn #_"void" LispReader'unread [#_"PushbackReader" ___r, #_"int" ___ch]
        (when (ß ___ch != -1)
            (try
                (ß ___r.unread(___ch))
                (catch IOException ___e
                    (throw (Util'sneakyThrow ___e))
                )
            )
        )
        nil
    )

    (defn #_"int" LispReader'read1 [#_"Reader" ___r]
        (try
            (ß ___r.read())
            (catch IOException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    ;; Reader opts
    (§ def #_"Keyword" LispReader'OPT_EOF (Keyword'intern-2 nil, "eof"))
    (§ def #_"Keyword" LispReader'OPT_FEATURES (Keyword'intern-2 nil, "features"))
    (§ def #_"Keyword" LispReader'OPT_READ_COND (Keyword'intern-2 nil, "read-cond"))

    ;; EOF special value to throw on eof
    (§ def #_"Keyword" LispReader'EOFTHROW (Keyword'intern-2 nil, "eofthrow"))

    ;; Platform features - always installed
    (§ def- #_"Keyword" LispReader'PLATFORM_KEY (Keyword'intern-2 nil, "cli"))
    (§ def- #_"Object" LispReader'PLATFORM_FEATURES (PersistentHashSet'create-1a LispReader'PLATFORM_KEY))

    ;; Reader conditional options - use with :read-cond
    (§ def #_"Keyword" LispReader'COND_ALLOW (Keyword'intern-2 nil, "allow"))
    (§ def #_"Keyword" LispReader'COND_PRESERVE (Keyword'intern-2 nil, "preserve"))

    (defn #_"Object" LispReader'read-2 [#_"PushbackReader" ___r, #_"Object" ___opts]
        (let [#_"boolean" ___eofIsError true]
            (let [#_"Object" ___eofValue nil]
                (when (ß ___opts != nil && ___opts instanceof IPersistentMap)
                    (let [#_"Object" ___eof (ß ((IPersistentMap)___opts).valAt(LispReader'OPT_EOF, LispReader'EOFTHROW))]
                        (when (ß !LispReader'EOFTHROW.equals(___eof))
                            (§ ass ___eofIsError false)
                            (§ ass ___eofValue ___eof)
                        )
                    )
                )
                (ß read(___r, ___eofIsError, ___eofValue, false, ___opts))
            )
        )
    )

    (defn #_"Object" LispReader'read-4 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive]
        (ß read(___r, ___eofIsError, ___eofValue, ___isRecursive, PersistentHashMap'EMPTY))
    )

    (defn #_"Object" LispReader'read-5 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts]
        ;; start with pendingForms nil as reader conditional splicing is not allowed at top level
        (ß read(___r, ___eofIsError, ___eofValue, nil, nil, ___isRecursive, ___opts, nil, (Resolver) RT'READER_RESOLVER.deref()))
    )

    (defn- #_"Object" LispReader'read-6 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms]
        (ß read(___r, ___eofIsError, ___eofValue, nil, nil, ___isRecursive, ___opts, ensurePending(___pendingForms), (Resolver) RT'READER_RESOLVER.deref()))
    )

    (defn- #_"Object" LispReader'ensurePending [#_"Object" ___pendingForms]
        (if (nil? ___pendingForms)
            (do
                (LinkedList.)
            )
            (do
                ___pendingForms
            )
        )
    )

    (defn- #_"Object" LispReader'installPlatformFeature [#_"Object" ___opts]
        (if (nil? ___opts)
            (do
                (RT'mapUniqueKeys LispReader'OPT_FEATURES, LispReader'PLATFORM_FEATURES)
            )
            (do
                (let [#_"IPersistentMap" ___mopts (ß (IPersistentMap) ___opts)]
                    (let [#_"Object" ___features (ß ___mopts.valAt(LispReader'OPT_FEATURES))]
                        (if (nil? ___features)
                            (do
                                (ß ___mopts.assoc(LispReader'OPT_FEATURES, LispReader'PLATFORM_FEATURES))
                            )
                            (do
                                (ß ___mopts.assoc(LispReader'OPT_FEATURES, RT'conj((IPersistentSet) ___features, LispReader'PLATFORM_KEY)))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn- #_"Object" LispReader'read-9 [#_"PushbackReader" ___r, #_"boolean" ___eofIsError, #_"Object" ___eofValue, #_"Character" ___returnOn, #_"Object" ___returnOnValue, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms, #_"Resolver" ___resolver]
        (when (ß RT'READEVAL.deref() == LispReader'UNKNOWN)
            (throw (Util'runtimeException-1 "Reading disallowed - *read-eval* bound to :unknown"))
        )

        (§ ass ___opts (ß installPlatformFeature(___opts)))

        (try
            (while true
                (when (ß ___pendingForms instanceof List && !((List)___pendingForms).isEmpty())
                    (§ return (ß ((List)___pendingForms).remove(0)))
                )

                (let [#_"int" ___ch (ß read1(___r))]
                    (while (ß isWhitespace(___ch))
                        (§ ass ___ch (ß read1(___r)))
                    )

                    (when (ß ___ch == -1)
                        (when ___eofIsError
                            (throw (Util'runtimeException-1 "EOF while reading"))
                        )
                        (§ return ___eofValue)
                    )

                    (when (ß ___returnOn != nil && (___returnOn.charValue() == ___ch))
                        (§ return ___returnOnValue)
                    )

                    (when (Character/isDigit ___ch)
                        (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                            (§ return ___n)
                        )
                    )

                    (let [#_"IFn" ___macroFn (ß getMacro(___ch))]
                        (when (some? ___macroFn)
                            (let [#_"Object" ___ret (ß ___macroFn.invoke(___r, (char) ___ch, ___opts, ___pendingForms))]
                                ;; no op macros return the reader
                                (when (ß ___ret == ___r)
                                    (§ continue )
                                )
                                (§ return ___ret)
                            )
                        )

                        (when (ß ___ch == \+ || ___ch == \-)
                            (let [#_"int" ___ch2 (ß read1(___r))]
                                (when (Character/isDigit ___ch2)
                                    (ß unread(___r, ___ch2))
                                    (let [#_"Object" ___n (ß readNumber(___r, (char) ___ch))]
                                        (§ return ___n)
                                    )
                                )
                                (ß unread(___r, ___ch2))
                            )
                        )

                        (let [#_"String" ___token (ß readToken(___r, (char) ___ch))]
                            (§ return (ß interpretToken(___token, ___resolver)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (when (ß ___isRecursive || !(___r instanceof LineNumberingPushbackReader))
                    (throw (Util'sneakyThrow ___e))
                )
                (let [#_"LineNumberingPushbackReader" ___rdr (ß (LineNumberingPushbackReader) ___r)]
                    (throw (ß LispReaderException'new(___rdr.getLineNumber(), ___rdr.getColumnNumber(), ___e)))
                )
            )
        )
    )

    (defn- #_"String" LispReader'readToken [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (ß ___sb.append(___initch))

            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || isTerminatingMacro(___ch))
                        (ß unread(___r, ___ch))
                        (§ return (ß ___sb.toString()))
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )
        )
    )

    (defn- #_"Object" LispReader'readNumber [#_"PushbackReader" ___r, #_"char" ___initch]
        (let [#_"StringBuilder" ___sb (StringBuilder.)]
            (ß ___sb.append(___initch))

            (while true
                (let [#_"int" ___ch (ß read1(___r))]
                    (when (ß ___ch == -1 || isWhitespace(___ch) || isMacro(___ch))
                        (ß unread(___r, ___ch))
                        (§ break )
                    )
                    (ß ___sb.append((char) ___ch))
                )
            )

            (let [#_"String" ___s (ß ___sb.toString())]
                (let [#_"Object" ___n (ß matchNumber(___s))]
                    (when (nil? ___n)
                        (throw (NumberFormatException. (str "Invalid number: " ___s)))
                    )
                    ___n
                )
            )
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-4 [#_"String" ___token, #_"int" ___offset, #_"int" ___length, #_"int" ___base]
        (when (ß ___token.length() != ___offset + ___length)
            (throw (IllegalArgumentException. (str "Invalid unicode character: \\" ___token)))
        )
        (let [#_"int" ___uc 0]
            (loop-when-recur [#_"int" ___i ___offset] (ß ___i < ___offset + ___length) [(inc ___i)]
                (let [#_"int" ___d (ß Character/digit(___token.charAt(___i), ___base))]
                    (when (ß ___d == -1)
                        (throw (IllegalArgumentException. (str "Invalid digit: " (ß ___token.charAt(___i)))))
                    )
                    (§ ass ___uc (ß ___uc * ___base + ___d))
                )
            )
            (ß (char) ___uc)
        )
    )

    (defn- #_"int" LispReader'readUnicodeChar-5 [#_"PushbackReader" ___r, #_"int" ___initch, #_"int" ___base, #_"int" ___length, #_"boolean" ___exact]
        (let [#_"int" ___uc (Character/digit ___initch, ___base)]
            (when (ß ___uc == -1)
                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___initch))))
            )
            (let [#_"int" ___i 1]
                (loop-when-recur [___i ___i] (< ___i ___length) [(inc ___i)]
                    (let [#_"int" ___ch (ß read1(___r))]
                        (when (ß ___ch == -1 || isWhitespace(___ch) || isMacro(___ch))
                            (ß unread(___r, ___ch))
                            (§ break )
                        )
                        (let [#_"int" ___d (Character/digit ___ch, ___base)]
                            (when (ß ___d == -1)
                                (throw (IllegalArgumentException. (str "Invalid digit: " (ß (char) ___ch))))
                            )
                            (§ ass ___uc (ß ___uc * ___base + ___d))
                        )
                    )
                )
                (when (ß ___i != ___length && ___exact)
                    (throw (IllegalArgumentException. (str "Invalid character length: " ___i ", should be: " ___length)))
                )
                ___uc
            )
        )
    )

    (defn- #_"Object" LispReader'interpretToken [#_"String" ___s, #_"Resolver" ___resolver]
        (cond (ß ___s.equals("nil"))
            (do
                (§ return nil)
            )
            (ß ___s.equals("true"))
            (do
                (§ return RT'T)
            )
            (ß ___s.equals("false"))
            (do
                (§ return RT'F)
            )
        )
        (let [#_"Object" ___ret nil]
            (§ ass ___ret (ß matchSymbol(___s, ___resolver)))
            (when (some? ___ret)
                (§ return ___ret)
            )

            (throw (Util'runtimeException-1 (str "Invalid token: " ___s)))
        )
    )

    (defn- #_"Object" LispReader'matchSymbol [#_"String" ___s, #_"Resolver" ___resolver]
        (let [#_"Matcher" ___m (ß symbolPat.matcher(___s))]
            (when (ß ___m.matches())
                (let [#_"int" ___gc (ß ___m.groupCount())]
                    (let [#_"String" ___ns (ß ___m.group(1))]
                        (let [#_"String" ___name (ß ___m.group(2))]
                            (when (ß ___ns != nil && ___ns.endsWith(":/") || ___name.endsWith(":") || ___s.indexOf("::", 1) != -1)
                                (§ return nil)
                            )
                            (when (ß ___s.startsWith("::"))
                                (let [#_"Symbol" ___ks (ß Symbol'intern-1(___s.substring(2)))]
                                    (if (some? ___resolver)
                                        (do
                                            (§ let [#_"Symbol" ___nsym]
                                                (if (ß (:ns ___ks) != nil)
                                                    (do
                                                        (§ ass ___nsym (ß ___resolver.resolveAlias(Symbol'intern-1((:ns ___ks)))))
                                                    )
                                                    (do
                                                        (§ ass ___nsym (ß ___resolver.currentNS()))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? ___nsym)
                                                    (do
                                                        (§ return (ß Keyword'intern-2((:name ___nsym), (:name ___ks))))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                        (do
                                            (§ let [#_"Namespace" ___kns]
                                                (if (ß (:ns ___ks) != nil)
                                                    (do
                                                        (§ ass ___kns (ß Compiler'currentNS().lookupAlias(Symbol'intern-1((:ns ___ks)))))
                                                    )
                                                    (do
                                                        (§ ass ___kns (ß Compiler'currentNS()))
                                                    )
                                                )
                                                ;; auto-resolving keyword
                                                (if (some? ___kns)
                                                    (do
                                                        (§ return (ß Keyword'intern-2((:name ___kns).name, (:name ___ks))))
                                                    )
                                                    (do
                                                        (§ return nil)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (let [#_"boolean" ___isKeyword (ß (___s.charAt(0) == \:))]
                                (let [#_"Symbol" ___sym (ß Symbol'intern-1(___s.substring(___isKeyword ? 1 :or 0)))]
                                    (when ___isKeyword
                                        (§ return (Keyword'intern ___sym))
                                    )
                                    (§ return ___sym)
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    (defn- #_"Object" LispReader'matchNumber [#_"String" ___s]
        (let [#_"Matcher" ___m (ß intPat.matcher(___s))]
            (when (ß ___m.matches())
                (when (ß ___m.group(2) != nil)
                    (when (ß ___m.group(8) != nil)
                        (§ return BigInt'ZERO)
                    )
                    (§ return (Numbers'num-1l 0))
                )
                (let [#_"boolean" ___negate (ß ___m.group(1).equals("-"))]
                    (§ let [#_"String" ___n]
                        (let [#_"int" ___radix 10]
                            (cond (some? (§ ass ___n (ß ___m.group(3))))
                                (do
                                    (§ ass ___radix 10)
                                )
                                (some? (§ ass ___n (ß ___m.group(4))))
                                (do
                                    (§ ass ___radix 16)
                                )
                                (some? (§ ass ___n (ß ___m.group(5))))
                                (do
                                    (§ ass ___radix 8)
                                )
                                (some? (§ ass ___n (ß ___m.group(7))))
                                (do
                                    (§ ass ___radix (ß Integer/parseInt(___m.group(6))))
                                )
                            )
                            (when (nil? ___n)
                                (§ return nil)
                            )
                            (let [#_"BigInteger" ___bn (BigInteger. ___n, ___radix)]
                                (when ___negate
                                    (§ ass ___bn (ß ___bn.negate()))
                                )
                                (when (ß ___m.group(8) != nil)
                                    (§ return (BigInt'fromBigInteger ___bn))
                                )
                                (§ return (ß (___bn.bitLength() < 64) ? Numbers'num-1l(___bn.longValue()) :or BigInt'fromBigInteger(___bn)))
                            )
                        )
                    )
                )
            )
            (§ ass ___m (ß floatPat.matcher(___s)))
            (when (ß ___m.matches())
                (when (ß ___m.group(4) != nil)
                    (§ return (§ unsure BigDecimal. (ß ___m.group(1))))
                )
                (§ return (Double/parseDouble ___s))
            )
            (§ ass ___m (ß ratioPat.matcher(___s)))
            (when (ß ___m.matches())
                (let [#_"String" ___numerator (ß ___m.group(1))]
                    (when (ß ___numerator.startsWith("+"))
                        (§ ass ___numerator (ß ___numerator.substring(1)))
                    )
                    (§ return (ß Numbers'divide-2oo(Numbers'reduceBigInt(BigInt'fromBigInteger((BigInteger. ___numerator))), Numbers'reduceBigInt(BigInt'fromBigInteger((BigInteger. (§ pars ___m.group(2))))))))
                )
            )
            nil
        )
    )

    (defn- #_"IFn" LispReader'getMacro [#_"int" ___ch]
        (when (ß ___ch < macros.length)
            (§ return (ß macros[___ch]))
        )
        nil
    )

    (defn- #_"boolean" LispReader'isMacro [#_"int" ___ch]
        (ß (___ch < macros.length && macros[___ch] != nil))
    )

    (defn- #_"boolean" LispReader'isTerminatingMacro [#_"int" ___ch]
        (ß (___ch != \# && ___ch != \' && ___ch != \% && isMacro(___ch)))
    )

    (defn #_"Symbol" LispReader'garg [#_"int" ___n]
        (ß Symbol'intern-2(nil, ((___n == -1) ? "rest" :or ("p" + ___n)) + "__" + RT'nextID() + "#"))
    )

    (defn #_"Symbol" LispReader'registerArg [#_"int" ___n]
        (let [#_"PersistentTreeMap" ___argsyms (ß (PersistentTreeMap) LispReader'ARG_ENV.deref())]
            (when (nil? ___argsyms)
                (throw (IllegalStateException. "arg literal not in #()"))
            )
            (let [#_"Symbol" ___ret (ß (Symbol) ___argsyms.valAt(___n))]
                (when (nil? ___ret)
                    (§ ass ___ret (ß garg(___n)))
                    (ß LispReader'ARG_ENV.set(___argsyms.assoc(___n, ___ret)))
                )
                ___ret
            )
        )
    )

    (defn #_"boolean" LispReader'isUnquoteSplicing [#_"Object" ___form]
        (ß ___form instanceof ISeq && Util'equals(RT'first(___form), LispReader'UNQUOTE_SPLICING))
    )

    (defn #_"boolean" LispReader'isUnquote [#_"Object" ___form]
        (ß ___form instanceof ISeq && Util'equals(RT'first(___form), LispReader'UNQUOTE))
    )

    ;; Sentinel values for reading lists
    (def- #_"Object" LispReader'READ_EOF (Object.))
    (def- #_"Object" LispReader'READ_FINISHED (Object.))

    (defn #_"List" LispReader'readDelimitedList [#_"char" ___delim, #_"PushbackReader" ___r, #_"boolean" ___isRecursive, #_"Object" ___opts, #_"Object" ___pendingForms]
        (let [#_"int" ___firstline (ß (___r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader) ___r).getLineNumber() :or -1)]
            (let [#_"ArrayList" ___a (ArrayList.)]
                (let [#_"Resolver" ___resolver (ß (Resolver) RT'READER_RESOLVER.deref())]
                    (while true
                        (let [#_"Object" ___form (ß read(___r, false, LispReader'READ_EOF, ___delim, LispReader'READ_FINISHED, ___isRecursive, ___opts, ___pendingForms, ___resolver))]
                            (cond (ß ___form == LispReader'READ_EOF)
                                (do
                                    (if (< ___firstline 0)
                                        (do
                                            (throw (Util'runtimeException-1 "EOF while reading"))
                                        )
                                        (do
                                            (throw (Util'runtimeException-1 (str "EOF while reading, starting at line " ___firstline)))
                                        )
                                    )
                                )
                                (ß ___form == LispReader'READ_FINISHED)
                                (do
                                    (§ return ___a)
                                )
                            )

                            (ß ___a.add(___form))
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean" LispReader'isPreserveReadCond [#_"Object" ___opts]
        (if (ß RT'booleanCast-1o(LispReader'READ_COND_ENV.deref()) && ___opts instanceof IPersistentMap)
            (do
                (let [#_"Object" ___readCond (ß ((IPersistentMap) ___opts).valAt(LispReader'OPT_READ_COND))]
                    (ß LispReader'COND_PRESERVE.equals(___readCond))
                )
            )
            (do
                false
            )
        )
    )
)
)

(java-ns cloiure.lang.LockingTransaction

(§ import java.util.*)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.TimeUnit)
(§ import java.util.concurrent.CountDownLatch)

(class-ns RetryEx (§ extends Error)
    (defn #_"RetryEx" RetryEx'new []
        (§ foreign Error'new)
    )
)

(class-ns AbortException (§ extends Exception)
    (defn #_"AbortException" AbortException'new []
        (§ foreign Exception'new)
    )
)

(class-ns LockingTransactionInfo
    (defn- #_"LockingTransactionInfo" LockingTransactionInfo'init []
        (hash-map
            #_"AtomicInteger" :status nil
            #_"long" :startPoint 0
            #_"CountDownLatch" :latch nil
        )
    )

    (defn #_"LockingTransactionInfo" LockingTransactionInfo'new [#_"int" ___status, #_"long" ___startPoint]
        (let [this (LockingTransactionInfo'init)]
            (§ ass (:status this) (AtomicInteger. ___status))
            (§ ass (:startPoint this) ___startPoint)
            (§ ass (:latch this) (CountDownLatch. 1))
            this
        )
    )

    #_method
    (§ defn #_"boolean" running [#_"LockingTransactionInfo" this]
        (let [#_"int" ___s (ß (:status this).get())]
            (ß (___s == LockingTransaction'RUNNING || ___s == LockingTransaction'COMMITTING))
        )
    )
)

(class-ns CFn
    (defn- #_"CFn" CFn'init []
        (hash-map
            #_"IFn" :fn nil
            #_"ISeq" :args nil
        )
    )

    (defn #_"CFn" CFn'new [#_"IFn" ___fn, #_"ISeq" ___args]
        (let [this (CFn'init)]
            (§ ass (:fn this) ___fn)
            (§ ass (:args this) ___args)
            this
        )
    )
)

(class-ns Notify
    (defn- #_"Notify" Notify'init []
        (hash-map
            #_"Ref" :ref nil
            #_"Object" :oldval nil
            #_"Object" :newval nil
        )
    )

    (defn #_"Notify" Notify'new [#_"Ref" ___ref, #_"Object" ___oldval, #_"Object" ___newval]
        (let [this (Notify'init)]
            (§ ass (:ref this) ___ref)
            (§ ass (:oldval this) ___oldval)
            (§ ass (:newval this) ___newval)
            this
        )
    )
)

(class-ns LockingTransaction
    (def #_"int" LockingTransaction'RETRY_LIMIT 10000)
    (def #_"int" LockingTransaction'LOCK_WAIT_MSECS 100)
    (def #_"long" LockingTransaction'BARGE_WAIT_NANOS (* 10 1000000))

    (def #_"int" LockingTransaction'RUNNING 0)
    (def #_"int" LockingTransaction'COMMITTING 1)
    (def #_"int" LockingTransaction'RETRY 2)
    (def #_"int" LockingTransaction'KILLED 3)
    (def #_"int" LockingTransaction'COMMITTED 4)

    (def #_"ThreadLocal<LockingTransaction>" LockingTransaction'transaction (ThreadLocal.))

    ;; total order on transactions
    ;; transactions will consume a point for init, for each retry, and on commit if writing
    (def- #_"AtomicLong" LockingTransaction'lastPoint (AtomicLong.))

    (defn- #_"LockingTransaction" LockingTransaction'init []
        (hash-map
            #_"LockingTransactionInfo" :info nil
            #_"long" :readPoint 0
            #_"long" :startPoint 0
            #_"long" :startTime 0

            #_"RetryEx" :retryex (RetryEx'new)
            #_"ArrayList<AgentAction>" :actions (ArrayList.)
            #_"HashMap<Ref, Object>" :vals (HashMap.)
            #_"HashSet<Ref>" :sets (HashSet.)
            #_"TreeMap<Ref, ArrayList<CFn>>" :commutes (TreeMap.)

            #_"HashSet<Ref>" :ensures (HashSet.) ;; all hold readLock
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'new []
        (LockingTransaction'init)
    )

    #_method
    (§ defn #_"void" getReadPoint [#_"LockingTransaction" this]
        (§ ass (:readPoint this) (ß lastPoint.incrementAndGet()))
        nil
    )

    #_method
    (§ defn #_"long" getCommitPoint [#_"LockingTransaction" this]
        (ß lastPoint.incrementAndGet())
    )

    #_method
    (§ defn #_"void" stop [#_"LockingTransaction" this, #_"int" ___status]
        (when (some? (:info this))
            (§ sync (:info this)
                (ß (:info this).status.set(___status))
                (ß (:info this).latch.countDown())
            )
            (§ ass (:info this) nil)
            (ß (:vals this).clear())
            (ß (:sets this).clear())
            (ß (:commutes this).clear())
        )
        nil
    )

    #_method
    (§ defn #_"void" tryWriteLock [#_"LockingTransaction" this, #_"Ref" ___ref]
        (try
            (when (ß !___ref.lock.writeLock().tryLock(LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS))
                (throw (:retryex this))
            )
            (catch InterruptedException ___e
                (throw (:retryex this))
            )
        )
        nil
    )

    ;; returns the most recent val
    #_method
    (§ defn #_"Object" lock [#_"LockingTransaction" this, #_"Ref" ___ref]
        ;; can't upgrade readLock, so release it
        (ß releaseIfEnsured(___ref))

        (let [#_"boolean" ___unlocked true]
            (try
                (ß tryWriteLock(___ref))
                (§ ass ___unlocked false)

                (when (ß (:tvals ___ref) != nil && (:tvals ___ref).point > (:readPoint this))
                    (throw (:retryex this))
                )
                (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
                    ;; write lock conflict
                    (when (ß ___refinfo != nil && ___refinfo != (:info this) && ___refinfo.running())
                        (when (ß !barge(___refinfo))
                            (ß (:lock ___ref).writeLock().unlock())
                            (§ ass ___unlocked true)
                            (§ return (ß blockAndBail(___refinfo)))
                        )
                    )
                    (§ ass (:tinfo ___ref) (:info this))
                    (ß ((:tvals ___ref) == nil) ? nil :or (:tvals ___ref).val)
                )
                (finally
                    (when (ß !___unlocked)
                        (ß (:lock ___ref).writeLock().unlock())
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"Object" blockAndBail [#_"LockingTransaction" this, #_"LockingTransactionInfo" ___refinfo]
        ;; stop prior to blocking
        (ß stop(LockingTransaction'RETRY))
        (try
            (ß (:latch ___refinfo).await(LockingTransaction'LOCK_WAIT_MSECS, TimeUnit/MILLISECONDS))
            (catch InterruptedException ___e
                ;; ignore
            )
        )
        (throw (:retryex this))
    )

    #_method
    (§ defn- #_"void" releaseIfEnsured [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (ß (:ensures this).contains(___ref))
            (ß (:ensures this).remove(___ref))
            (ß (:lock ___ref).readLock().unlock())
        )
        nil
    )

    #_method
    (§ defn #_"void" abort [#_"LockingTransaction" this] #_(§ throws AbortException)
        (ß stop(LockingTransaction'KILLED))
        (throw (AbortException'new))
    )

    #_method
    (§ defn- #_"boolean" bargeTimeElapsed [#_"LockingTransaction" this]
        (ß (System/nanoTime() - (:startTime this) > LockingTransaction'BARGE_WAIT_NANOS))
    )

    #_method
    (§ defn- #_"boolean" barge [#_"LockingTransaction" this, #_"LockingTransactionInfo" ___refinfo]
        (let [#_"boolean" ___barged false]
            ;; if this transaction is older, try to abort the other
            (when (ß bargeTimeElapsed() && (:startPoint this) < (:startPoint ___refinfo))
                (§ ass ___barged (ß (:status ___refinfo).compareAndSet(LockingTransaction'RUNNING, LockingTransaction'KILLED)))
                (when ___barged
                    (ß (:latch ___refinfo).countDown())
                )
            )
            ___barged
        )
    )

    (defn #_"LockingTransaction" LockingTransaction'getEx []
        (let [#_"LockingTransaction" ___t (ß transaction.get())]
            (when (ß ___t == nil || (:info ___t) == nil)
                (throw (IllegalStateException. "No transaction running"))
            )
            ___t
        )
    )

    (defn #_"boolean" LockingTransaction'isRunning []
        (ß (getRunning() != nil))
    )

    (defn #_"LockingTransaction" LockingTransaction'getRunning []
        (let [#_"LockingTransaction" ___t (ß transaction.get())]
            (when (ß ___t == nil || (:info ___t) == nil)
                (§ return nil)
            )
            ___t
        )
    )

    (defn #_"Object" LockingTransaction'runInTransaction [#_"Callable" ___fn] #_(§ throws Exception)
        (let [#_"LockingTransaction" ___t (ß transaction.get())]
            (§ let [#_"Object" ___ret]
                (if (nil? ___t)
                    (do
                        (ß transaction.set(§ ass ___t (LockingTransaction'new)))
                        (try
                            (§ ass ___ret (ß ___t.run(___fn)))
                            (finally
                                (ß transaction.remove())
                            )
                        )
                    )
                    (do
                        (if (ß (:info ___t) != nil)
                            (do
                                (§ ass ___ret (ß ___fn.call()))
                            )
                            (do
                                (§ ass ___ret (ß ___t.run(___fn)))
                            )
                        )
                    )
                )

                ___ret
            )
        )
    )

    #_method
    (§ defn #_"Object" run [#_"LockingTransaction" this, #_"Callable" ___fn] #_(§ throws Exception)
        (let [#_"boolean" ___done false]
            (let [#_"Object" ___ret nil]
                (let [#_"ArrayList<Ref>" ___locked (ArrayList.)]
                    (let [#_"ArrayList<Notify>" ___notify (ArrayList.)]
                        (loop-when-recur [#_"int" ___i 0] (ß !___done && ___i < LockingTransaction'RETRY_LIMIT) [(inc ___i)]
                            (try
                                (ß getReadPoint())
                                (when (ß ___i == 0)
                                    (§ ass (:startPoint this) (:readPoint this))
                                    (§ ass (:startTime this) (ß System/nanoTime()))
                                )
                                (§ ass (:info this) (LockingTransactionInfo'new LockingTransaction'RUNNING, (:startPoint this)))
                                (§ ass ___ret (ß ___fn.call()))
                                ;; make sure no one has killed us before this point, and can't from now on
                                (when (ß (:info this).status.compareAndSet(LockingTransaction'RUNNING, LockingTransaction'COMMITTING))
                                    (doseq [#_"Map$Entry<Ref, ArrayList<CFn>>" ___e (ß (:commutes this).entrySet())]
                                        (let [#_"Ref" ___ref (ß ___e.getKey())]
                                            (when (ß (:sets this).contains(___ref))
                                                (§ continue )
                                            )

                                            (let [#_"boolean" ___wasEnsured (ß (:ensures this).contains(___ref))]
                                                ;; can't upgrade readLock, so release it
                                                (ß releaseIfEnsured(___ref))
                                                (ß tryWriteLock(___ref))
                                                (ß ___locked.add(___ref))
                                                (when (ß ___wasEnsured && (:tvals ___ref) != nil && (:tvals ___ref).point > (:readPoint this))
                                                    (throw (:retryex this))
                                                )

                                                (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
                                                    (when (ß ___refinfo != nil && ___refinfo != (:info this) && ___refinfo.running())
                                                        (when (ß !barge(___refinfo))
                                                            (throw (:retryex this))
                                                        )
                                                    )
                                                    (let [#_"Object" ___val (ß ((:tvals ___ref) == nil) ? nil :or (:tvals ___ref).val)]
                                                        (ß (:vals this).put(___ref, ___val))
                                                        (doseq [#_"CFn" ___f (ß ___e.getValue())]
                                                            (ß (:vals this).put(___ref, (:fn ___f).applyTo(RT'cons((:vals this).get(___ref), (:args ___f)))))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (doseq [#_"Ref" ___ref (:sets this)]
                                        (ß tryWriteLock(___ref))
                                        (ß ___locked.add(___ref))
                                    )

                                    ;; validate and enqueue notifications
                                    (doseq [#_"Map$Entry<Ref, Object>" ___e (ß (:vals this).entrySet())]
                                        (let [#_"Ref" ___ref (ß ___e.getKey())]
                                            (ß ___ref.validate(___ref.getValidator(), ___e.getValue()))
                                        )
                                    )

                                    ;; at this point, all values calced, all refs to be written locked
                                    ;; no more client code to be called
                                    (let [#_"long" ___commitPoint (ß getCommitPoint())]
                                        (doseq [#_"Map$Entry<Ref, Object>" ___e (ß (:vals this).entrySet())]
                                            (let [#_"Ref" ___ref (ß ___e.getKey())]
                                                (let [#_"Object" ___oldval (ß ((:tvals ___ref) == nil) ? nil :or (:tvals ___ref).val)]
                                                    (let [#_"Object" ___newval (ß ___e.getValue())]
                                                        (let [#_"int" ___hcount (ß ___ref.histCount())]
                                                            (cond (ß (:tvals ___ref) == nil)
                                                                (do
                                                                    (§ ass (:tvals ___ref) (RefTVal'new-2 ___newval, ___commitPoint))
                                                                )
                                                                (ß ((:faults ___ref).get() > 0 && ___hcount < (:maxHistory ___ref)) || ___hcount < (:minHistory ___ref))
                                                                (do
                                                                    (§ ass (:tvals ___ref) (ß RefTVal'new-3(___newval, ___commitPoint, (:tvals ___ref))))
                                                                    (ß (:faults ___ref).set(0))
                                                                )
                                                                :else
                                                                (do
                                                                    (§ ass (:tvals ___ref) (ß (:tvals ___ref).next))
                                                                    (§ ass (ß (:tvals ___ref).val) ___newval)
                                                                    (§ ass (ß (:tvals ___ref).point) ___commitPoint)
                                                                )
                                                            )
                                                            (when (ß ___ref.getWatches().count() > 0)
                                                                (ß ___notify.add(Notify'new(___ref, ___oldval, ___newval)))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )

                                        (§ ass ___done true)
                                        (ß (:info this).status.set(LockingTransaction'COMMITTED))
                                    )
                                )
                                (§ catch RetryEx ___retry
                                    ;; eat this so we retry rather than fall out
                                )
                                (finally
                                    (loop-when-recur [#_"int" ___k (ß ___locked.size() - 1)] (ß ___k >= 0) [(dec ___k)]
                                        (ß ___locked.get(___k).lock.writeLock().unlock())
                                    )
                                    (ß ___locked.clear())
                                    (doseq [#_"Ref" ___r (:ensures this)]
                                        (ß (:lock ___r).readLock().unlock())
                                    )
                                    (ß (:ensures this).clear())
                                    (ß stop(___done ? LockingTransaction'COMMITTED :or LockingTransaction'RETRY))
                                    (try
                                        (when ___done ;; re-dispatch out of transaction
                                            (doseq [#_"Notify" ___n ___notify]
                                                (ß (:ref ___n).notifyWatches((:oldval ___n), (:newval ___n)))
                                            )
                                            (doseq [#_"AgentAction" ___action (:actions this)]
                                                (Agent'dispatchAction ___action)
                                            )
                                        )
                                        (finally
                                            (ß ___notify.clear())
                                            (ß (:actions this).clear())
                                        )
                                    )
                                )
                            )
                        )
                        (when (ß !___done)
                            (throw (Util'runtimeException-1 "Transaction failed after reaching retry limit"))
                        )
                        ___ret
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"void" enqueue [#_"LockingTransaction" this, #_"AgentAction" ___action]
        (ß (:actions this).add(___action))
        nil
    )

    #_method
    (§ defn #_"Object" doGet [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (ß !this.info.running())
            (throw (:retryex this))
        )
        (when (ß (:vals this).containsKey(___ref))
            (§ return (ß (:vals this).get(___ref)))
        )
        (try
            (ß (:lock ___ref).readLock().lock())
            (when (ß (:tvals ___ref) == nil)
                (throw (IllegalStateException. (str (ß ___ref.toString()) " is unbound.")))
            )
            (let [#_"RefTVal" ___ver (:tvals ___ref)]
                (§ loop
                    (when (ß (:point ___ver) <= (:readPoint this))
                        (§ return (:val ___ver))
                    )
                    (§ recur-if ((§ ass ___ver (:prior ___ver)) != (:tvals ___ref)))
                )
            )
            (finally
                (ß (:lock ___ref).readLock().unlock())
            )
        )
        ;; no version of val precedes the read point
        (ß (:faults ___ref).incrementAndGet())
        (throw (:retryex this))
    )

    #_method
    (§ defn #_"Object" doSet [#_"LockingTransaction" this, #_"Ref" ___ref, #_"Object" ___val]
        (when (ß !this.info.running())
            (throw (:retryex this))
        )
        (when (ß (:commutes this).containsKey(___ref))
            (throw (IllegalStateException. "Can't set after commute"))
        )
        (when (ß !this.sets.contains(___ref))
            (ß (:sets this).add(___ref))
            (ß lock(___ref))
        )
        (ß (:vals this).put(___ref, ___val))
        ___val
    )

    #_method
    (§ defn #_"void" doEnsure [#_"LockingTransaction" this, #_"Ref" ___ref]
        (when (ß !this.info.running())
            (throw (:retryex this))
        )
        (when (ß (:ensures this).contains(___ref))
            (§ return nil)
        )
        (ß (:lock ___ref).readLock().lock())

        ;; someone completed a write after our snapshot
        (when (ß (:tvals ___ref) != nil && (:tvals ___ref).point > (:readPoint this))
            (ß (:lock ___ref).readLock().unlock())
            (throw (:retryex this))
        )

        (let [#_"LockingTransactionInfo" ___refinfo (:tinfo ___ref)]
            ;; writer exists
            (if (ß ___refinfo != nil && ___refinfo.running())
                (do
                    (ß (:lock ___ref).readLock().unlock())

                    (when (ß ___refinfo != (:info this)) ;; not us, ensure is doomed
                        (ß blockAndBail(___refinfo))
                    )
                )
                (do
                    (ß (:ensures this).add(___ref))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" doCommute [#_"LockingTransaction" this, #_"Ref" ___ref, #_"IFn" ___fn, #_"ISeq" ___args]
        (when (ß !this.info.running())
            (throw (:retryex this))
        )
        (when (ß !this.vals.containsKey(___ref))
            (let [#_"Object" ___val nil]
                (try
                    (ß (:lock ___ref).readLock().lock())
                    (§ ass ___val (ß ((:tvals ___ref) == nil) ? nil :or (:tvals ___ref).val))
                    (finally
                        (ß (:lock ___ref).readLock().unlock())
                    )
                )
                (ß (:vals this).put(___ref, ___val))
            )
        )
        (let [#_"ArrayList<CFn>" ___fns (ß (:commutes this).get(___ref))]
            (when (nil? ___fns)
                (ß (:commutes this).put(___ref, (§ ass ___fns (ArrayList.))))
            )
            (ß ___fns.add(CFn'new(___fn, ___args)))
            (let [#_"Object" ___ret (ß ___fn.applyTo(RT'cons((:vals this).get(___ref), ___args)))]
                (ß (:vals this).put(___ref, ___ret))
                ___ret
            )
        )
    )
)
)

(java-ns cloiure.lang.LongRange

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

#_private
(defprotocol LongRangeBoundsCheck
    #_abstract
    (#_"boolean" LongRangeBoundsCheck'''exceededBounds [#_"LongRangeBoundsCheck" this, #_"long" ___val])
)

#_non-static
(class-ns LongRangeIterator (§ implements Iterator)
    (defn- #_"LongRangeIterator" LongRangeIterator'init []
        (hash-map
            #_"long" :next 0
            #_"boolean" :hasNext false
        )
    )

    (defn #_"LongRangeIterator" LongRangeIterator'new []
        (let [this (LongRangeIterator'init)]
            (§ ass (:next this) (:start this))
            (§ ass (:hasNext this) true)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"LongRangeIterator" this]
        (:hasNext this)
    )

    #_method
    (§ defn #_"Object" next [#_"LongRangeIterator" this]
        (if (:hasNext this)
            (do
                (let [#_"long" ___ret (:next this)]
                    (try
                        (§ ass (:next this) (Numbers'add-2ll (:next this), (:step this)))
                        (§ ass (:hasNext this) (ß !this.boundsCheck.exceededBounds((:next this))))
                        (catch ArithmeticException ___e
                            (§ ass (:hasNext this) false)
                        )
                    )
                    ___ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"LongRangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

#_private
(class-ns LongChunk (§ implements IChunk)
    (defn- #_"LongChunk" LongChunk'init []
        (hash-map
            #_"long" :start 0
            #_"long" :step 0
            #_"int" :count 0
        )
    )

    (defn #_"LongChunk" LongChunk'new [#_"long" ___start, #_"long" ___step, #_"int" ___count]
        (let [this (LongChunk'init)]
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:count this) ___count)
            this
        )
    )

    #_method
    (§ defn #_"long" first [#_"LongChunk" this]
        (:start this)
    )

    #_method
    (§ defn #_"Object" nth [#_"LongChunk" this, #_"int" ___i]
        (ß (:start this) + (___i * (:step this)))
    )

    #_method
    (§ defn #_"Object" nth [#_"LongChunk" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < (:count this))
            (§ return (ß (:start this) + (___i * (:step this))))
        )
        ___notFound
    )

    #_method
    (§ defn #_"int" count [#_"LongChunk" this]
        (:count this)
    )

    #_method
    (§ defn #_"LongChunk" dropFirst [#_"LongChunk" this]
        (when (ß (:count this) <= 1)
            (throw (IllegalStateException. "dropFirst of empty chunk"))
        )
        (ß LongChunk'new((:start this) + (:step this), (:step this), (:count this) - 1))
    )

    #_method
    (§ defn #_"Object" reduce [#_"LongChunk" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"long" ___x (:start this)]
            (let [#_"Object" ___ret ___init]
                (loop-when-recur [#_"int" ___i 0] (< ___i (:count this)) [(inc ___i)]
                    (§ ass ___ret (ß ___f.invoke(___ret, ___x)))
                    (when (RT'isReduced ___ret)
                        (§ return ___ret)
                    )
                    (§ ass ___x (+ ___x (:step this)))
                )
                ___ret
            )
        )
    )
)

;;;
 ; Implements the special common case of a finite range based on long start, end, and step.
 ;;
(class-ns LongRange (§ extends ASeq) (§ implements Counted, IChunkedSeq, IReduce)
    (def- #_"int" LongRange'CHUNK_SIZE 32)

    (defn- #_"LongRangeBoundsCheck" LongRange'positiveStep [#_"long" ___end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"LongRangeBoundsCheck" this, #_"long" ___val]
                (ß (___val >= ___end))
            )
        )
    )

    (defn- #_"LongRangeBoundsCheck" LongRange'negativeStep [#_"long" ___end]
        (§ reify LongRangeBoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"LongRangeBoundsCheck" this, #_"long" ___val]
                (ß (___val <= ___end))
            )
        )
    )

    (defn- #_"LongRange" LongRange'init []
        (hash-map
            ;; Invariants guarantee this is never an empty or infinite seq
            #_"long" :start 0
            #_"long" :end 0
            #_"long" :step 0
            #_"LongRangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"LongChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"LongRange" LongRange'new-4 [#_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck]
        (let [this (merge (ASeq'new) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-6 [#_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck, #_"LongChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn- #_"LongRange" LongRange'new-7 [#_"IPersistentMap" ___meta, #_"long" ___start, #_"long" ___end, #_"long" ___step, #_"LongRangeBoundsCheck" ___boundsCheck, #_"LongChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new ___meta) (LongRange'init))]
            (§ ass (:start this) ___start)
            (§ ass (:end this) ___end)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn #_"ISeq" LongRange'create-1 [#_"long" ___end]
        (when (> ___end 0)
            (§ return (ß LongRange'new-4(0, ___end, 1, positiveStep(___end))))
        )
        PersistentList'EMPTY
    )

    (defn #_"ISeq" LongRange'create-2 [#_"long" ___start, #_"long" ___end]
        (when (ß ___start >= ___end)
            (§ return PersistentList'EMPTY)
        )
        (ß LongRange'new-4(___start, ___end, 1, positiveStep(___end)))
    )

    (defn #_"ISeq" LongRange'create-3 [#_"long" ___start, #_"long" ___end, #_"long" ___step]
        (cond (> ___step 0)
            (do
                (when (ß ___end <= ___start)
                    (§ return PersistentList'EMPTY)
                )
                (ß LongRange'new-4(___start, ___end, ___step, positiveStep(___end)))
            )
            (< ___step 0)
            (do
                (when (ß ___end >= ___start)
                    (§ return PersistentList'EMPTY)
                )
                (ß LongRange'new-4(___start, ___end, ___step, negativeStep(___end)))
            )
            :else
            (do
                (when (ß ___end == ___start)
                    (§ return PersistentList'EMPTY)
                )
                (Repeat'create-1 ___start)
            )
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"LongRange" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (LongRange'new-7 ___meta, (:start this), (:end this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
    )

    #_method
    (§ defn #_"Object" first [#_"LongRange" this]
        (:start this)
    )

    #_method
    (§ defn #_"void" forceChunk [#_"LongRange" this]
        (when (some? (:_chunk this))
            (§ return nil)
        )

        (§ let [#_"long" ___count]
            (try
                (§ ass ___count (ß rangeCount((:start this), (:end this), (:step this))))
                (catch ArithmeticException ___e
                    ;; size of total range is > Long.MAX_VALUE so must step to count
                    ;; this only happens in pathological range cases like:
                    ;; (range -9223372036854775808 9223372036854775807 9223372036854775807)
                    (§ ass ___count (ß steppingCount((:start this), (:end this), (:step this))))
                )
            )

            (cond (ß ___count > LongRange'CHUNK_SIZE) ;; not last chunk
                (do
                    (let [#_"long" ___nextStart (ß (:start this) + ((:step this) * LongRange'CHUNK_SIZE))] ;; cannot overflow, must be < end
                        (§ ass (:_chunkNext this) (LongRange'new-4 ___nextStart, (:end this), (:step this), (:boundsCheck this)))
                        (§ ass (:_chunk this) (LongChunk'new (:start this), (:step this), LongRange'CHUNK_SIZE))
                    )
                )
                :else ;; last chunk
                (do
                    (§ ass (:_chunk this) (ß LongChunk'new((:start this), (:step this), (int) ___count))) ;; count must be <= CHUNK_SIZE
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"ISeq" next [#_"LongRange" this]
        (when (some? (:_next this))
            (§ return (:_next this))
        )

        (ß forceChunk())
        (when (ß (:_chunk this).count() > 1)
            (let [#_"LongChunk" ___smallerChunk (ß (:_chunk this).dropFirst())]
                (§ ass (:_next this) (ß LongRange'new-6(___smallerChunk.first(), (:end this), (:step this), (:boundsCheck this), ___smallerChunk, (:_chunkNext this))))
                (§ return (:_next this))
            )
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"LongRange" this]
        (ß forceChunk())
        (:_chunk this)
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"LongRange" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"LongRange" this]
        (ß forceChunk())
        (when (nil? (:_chunkNext this))
            (§ return PersistentList'EMPTY)
        )
        (:_chunkNext this)
    )

    ;; fallback count mechanism for pathological cases
    ;; returns either exact count or CHUNK_SIZE+1
    #_method
    (§ defn #_"long" steppingCount [#_"LongRange" this, #_"long" ___start, #_"long" ___end, #_"long" ___step]
        (let [#_"long" ___count 1]
            (let [#_"long" ___s ___start]
                (while (ß ___count <= LongRange'CHUNK_SIZE)
                    (try
                        (§ ass ___s (Numbers'add-2ll ___s, ___step))
                        (if (ß (:boundsCheck this).exceededBounds(___s))
                            (do
                                (§ break )
                            )
                            (do
                                (§ ass ___count (inc ___count))
                            )
                        )
                        (catch ArithmeticException ___e
                            (§ break )
                        )
                    )
                )
                ___count
            )
        )
    )

    ;; returns exact size of remaining items OR throws ArithmeticException for overflow case
    #_method
    (§ defn #_"long" rangeCount [#_"LongRange" this, #_"long" ___start, #_"long" ___end, #_"long" ___step]
        ;; (1) count = ceiling ((end - start) / step)
        ;; (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
        ;; thus: count = end - start + step + o / step
        (ß Numbers'add-2ll(Numbers'add-2ll(Numbers'minus-2ll(___end, ___start), ___step), ((:step this) > 0) ? -1 :or 1) / ___step)
    )

    #_method
    (§ defn #_"int" count [#_"LongRange" this]
        (try
            (let [#_"long" ___c (ß rangeCount((:start this), (:end this), (:step this)))]
                (if (ß ___c > Integer/MAX_VALUE)
                    (do
                        (ß Numbers'throwIntOverflow())
                    )
                    (do
                        (ß (int) ___c)
                    )
                )
            )
            (catch ArithmeticException ___e
                ;; rare case from large range or step, fall back to iterating and counting
                (let [#_"Iterator" ___iter (ß this.iterator())]
                    (let [#_"long" ___count 0]
                        (while (ß ___iter.hasNext())
                            (ß ___iter.next())
                            (§ ass ___count (inc ___count))
                        )

                        (if (ß ___count > Integer/MAX_VALUE)
                            (do
                                (ß Numbers'throwIntOverflow())
                            )
                            (do
                                (ß (int)___count)
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"LongRange" this, #_"IFn" ___f]
        (let [#_"Object" ___acc (:start this)]
            (let [#_"long" ___i (+ (:start this) (:step this))]
                (while (ß !this.boundsCheck.exceededBounds(___i))
                    (§ ass ___acc (ß ___f.invoke(___acc, ___i)))
                    (when (ß ___acc instanceof Reduced)
                        (§ return (ß ((Reduced)___acc).deref()))
                    )
                    (§ ass ___i (+ ___i (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"LongRange" this, #_"IFn" ___f, #_"Object" ___val]
        (let [#_"Object" ___acc ___val]
            (let [#_"long" ___i (:start this)]
                (§ loop
                    (§ ass ___acc (ß ___f.invoke(___acc, ___i)))
                    (when (RT'isReduced ___acc)
                        (§ return (ß ((Reduced)___acc).deref()))
                    )
                    (§ ass ___i (+ ___i (:step this)))
                    (§ recur-if (!this.boundsCheck.exceededBounds(___i)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"LongRange" this]
        (LongRangeIterator'new)
    )
)
)

(java-ns cloiure.lang.MapEntry

(§ import java.util.Iterator)

(class-ns MapEntry (§ extends AMapEntry)
    (defn #_"MapEntry" MapEntry'create [#_"Object" ___key, #_"Object" ___val]
        (MapEntry'new ___key, ___val)
    )

    (defn- #_"MapEntry" MapEntry'init []
        (hash-map
            #_"Object" :_key nil
            #_"Object" :_val nil
        )
    )

    (defn #_"MapEntry" MapEntry'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (AMapEntry'new) (MapEntry'init))]
            (§ ass (:_key this) ___key)
            (§ ass (:_val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" key [#_"MapEntry" this]
        (:_key this)
    )

    #_method
    (§ defn #_"Object" val [#_"MapEntry" this]
        (:_val this)
    )

    #_method
    (§ defn #_"Object" getKey [#_"MapEntry" this]
        (ß key())
    )

    #_method
    (§ defn #_"Object" getValue [#_"MapEntry" this]
        (ß val())
    )
)
)

(java-ns cloiure.lang.MapEquivalence

;; marker interface
(defprotocol MapEquivalence
)
)

(java-ns cloiure.lang.MethodImplCache

(§ import java.util.Map)

(class-ns Entry
    (defn- #_"Entry" Entry'init []
        (hash-map
            #_"Class" :c nil
            #_"IFn" :fn nil
        )
    )

    (defn #_"Entry" Entry'new [#_"Class" ___c, #_"IFn" ___fn]
        (let [this (Entry'init)]
            (§ ass (:c this) ___c)
            (§ ass (:fn this) ___fn)
            this
        )
    )
)

(class-ns MethodImplCache
    (defn- #_"MethodImplCache" MethodImplCache'init []
        (hash-map
            #_"IPersistentMap" :protocol nil
            #_"Keyword" :methodk nil
            #_"int" :shift 0
            #_"int" :mask 0
            #_"Object[]" :table nil ;; [class, entry. class, entry ...]
            #_"Map" :map nil

            #_"Entry" :mre nil
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-2 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk]
        (MethodImplCache'new-5 ___protocol, ___methodk, 0, 0, RT'EMPTY_ARRAY)
    )

    (defn #_"MethodImplCache" MethodImplCache'new-5 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk, #_"int" ___shift, #_"int" ___mask, #_"Object[]" ___table]
        (let [this (MethodImplCache'init)]
            (§ ass (:protocol this) ___protocol)
            (§ ass (:methodk this) ___methodk)
            (§ ass (:shift this) ___shift)
            (§ ass (:mask this) ___mask)
            (§ ass (:table this) ___table)
            (§ ass (:map this) nil)
            this
        )
    )

    (defn #_"MethodImplCache" MethodImplCache'new-3 [#_"IPersistentMap" ___protocol, #_"Keyword" ___methodk, #_"Map" ___map]
        (let [this (MethodImplCache'init)]
            (§ ass (:protocol this) ___protocol)
            (§ ass (:methodk this) ___methodk)
            (§ ass (:shift this) 0)
            (§ ass (:mask this) 0)
            (§ ass (:table this) nil)
            (§ ass (:map this) ___map)
            this
        )
    )

    #_method
    (§ defn #_"IFn" fnFor [#_"MethodImplCache" this, #_"Class" ___c]
        (let [#_"Entry" ___last (:mre this)]
            (when (ß ___last != nil && (:c ___last) == ___c)
                (§ return (:fn ___last))
            )
            (ß findFnFor(___c))
        )
    )

    #_method
    (§ defn #_"IFn" findFnFor [#_"MethodImplCache" this, #_"Class" ___c]
        (if (some? (:map this))
            (do
                (let [#_"Entry" ___e (ß (Entry) (:map this).get(___c))]
                    (§ ass (:mre this) ___e)
                    (ß (___e != nil) ? (:fn ___e) :or nil)
                )
            )
            (do
                (let [#_"int" ___idx (ß ((Util'hash(___c) >> (:shift this)) & (:mask this)) << 1)]
                    (when (ß ___idx < (:table this).length && (:table this)[___idx] == ___c)
                        (let [#_"Entry" ___e (ß ((Entry) (:table this)[___idx + 1]))]
                            (§ ass (:mre this) ___e)
                            (§ return (ß (___e != nil) ? (:fn ___e) :or nil))
                        )
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.MultiFn

(§ import java.util.Map)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns MultiFn (§ extends AFn)
    (§ def #_"Var" MultiFn'assoc (RT'var-2 "cloiure.core", "assoc"))
    (§ def #_"Var" MultiFn'dissoc (RT'var-2 "cloiure.core", "dissoc"))
    (§ def #_"Var" MultiFn'isa (RT'var-2 "cloiure.core", "isa?"))
    (§ def #_"Var" MultiFn'parents (RT'var-2 "cloiure.core", "parents"))

    (defn- #_"MultiFn" MultiFn'init []
        (hash-map
            #_"IFn" :dispatchFn nil
            #_"Object" :defaultDispatchVal nil
            #_"IRef" :hierarchy nil
            #_"String" :name nil
            #_"ReentrantReadWriteLock" :rw nil

            #_volatile
            #_"IPersistentMap" :methodTable nil
            #_volatile
            #_"IPersistentMap" :preferTable nil
            #_volatile
            #_"IPersistentMap" :methodCache nil
            #_volatile
            #_"Object" :cachedHierarchy nil
        )
    )

    (defn #_"MultiFn" MultiFn'new [#_"String" ___name, #_"IFn" ___dispatchFn, #_"Object" ___defaultDispatchVal, #_"IRef" ___hierarchy]
        (let [this (merge (AFn'new) (MultiFn'init))]
            (§ ass (:rw this) (ReentrantReadWriteLock.))
            (§ ass (:name this) ___name)
            (§ ass (:dispatchFn this) ___dispatchFn)
            (§ ass (:defaultDispatchVal this) ___defaultDispatchVal)
            (§ ass (:methodTable this) PersistentHashMap'EMPTY)
            (§ ass (:methodCache this) (ß getMethodTable()))
            (§ ass (:preferTable this) PersistentHashMap'EMPTY)
            (§ ass (:hierarchy this) ___hierarchy)
            (§ ass (:cachedHierarchy this) nil)
            this
        )
    )

    #_method
    (§ defn #_"MultiFn" reset [#_"MultiFn" this]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (§ ass (:methodCache this) (§ ass (:preferTable this) PersistentHashMap'EMPTY)))
            (§ ass (:cachedHierarchy this) nil)
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" addMethod [#_"MultiFn" this, #_"Object" ___dispatchVal, #_"IFn" ___method]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (ß getMethodTable().assoc(___dispatchVal, ___method)))
            (ß resetCache())
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" removeMethod [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodTable this) (ß getMethodTable().without(___dispatchVal)))
            (ß resetCache())
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"MultiFn" preferMethod [#_"MultiFn" this, #_"Object" ___dispatchValX, #_"Object" ___dispatchValY]
        (ß (:rw this).writeLock().lock())
        (try
            (when (ß prefers(___dispatchValY, ___dispatchValX))
                (throw (IllegalStateException. (String/format "Preference conflict in multimethod '%s': %s is already preferred to %s", (§ array (:name this), ___dispatchValY, ___dispatchValX))))
            )
            (§ ass (:preferTable this) (ß getPreferTable().assoc(___dispatchValX, RT'conj((IPersistentCollection) RT'get-3(getPreferTable(), ___dispatchValX, PersistentHashSet'EMPTY), ___dispatchValY))))
            (ß resetCache())
            this
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn- #_"boolean" prefers [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (let [#_"IPersistentSet" ___xprefs (ß (IPersistentSet) getPreferTable().valAt(___x))]
            (when (ß ___xprefs != nil && ___xprefs.contains(___y))
                (§ return true)
            )
            (loop-when-recur [#_"ISeq" ___ps (ß RT'seq(MultiFn'parents.invoke(___y)))] (some? ___ps) [(ß ___ps.next())]
                (when (ß prefers(___x, ___ps.first()))
                    (§ return true)
                )
            )
            (loop-when-recur [#_"ISeq" ___ps (ß RT'seq(MultiFn'parents.invoke(___x)))] (some? ___ps) [(ß ___ps.next())]
                (when (ß prefers(___ps.first(), ___y))
                    (§ return true)
                )
            )
            false
        )
    )

    #_method
    (§ defn- #_"boolean" isA [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (ß RT'booleanCast-1o(isa.invoke((:hierarchy this).deref(), ___x, ___y)))
    )

    #_method
    (§ defn- #_"boolean" dominates [#_"MultiFn" this, #_"Object" ___x, #_"Object" ___y]
        (ß prefers(___x, ___y) || isA(___x, ___y))
    )

    #_method
    (§ defn- #_"IPersistentMap" resetCache [#_"MultiFn" this]
        (ß (:rw this).writeLock().lock())
        (try
            (§ ass (:methodCache this) (ß getMethodTable()))
            (§ ass (:cachedHierarchy this) (ß (:hierarchy this).deref()))
            (:methodCache this)
            (finally
                (ß (:rw this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"IFn" getMethod [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (when (ß (:cachedHierarchy this) != (:hierarchy this).deref())
            (ß resetCache())
        )
        (let [#_"IFn" ___targetFn (ß (IFn) (:methodCache this).valAt(___dispatchVal))]
            (when (some? ___targetFn)
                (§ return ___targetFn)
            )
            (ß findAndCacheBestMethod(___dispatchVal))
        )
    )

    #_method
    (§ defn- #_"IFn" getFn [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (let [#_"IFn" ___targetFn (ß getMethod(___dispatchVal))]
            (when (nil? ___targetFn)
                (throw (IllegalArgumentException. (String/format "No method in multimethod '%s' for dispatch value: %s", (§ array (:name this), ___dispatchVal))))
            )
            ___targetFn
        )
    )

    #_method
    (§ defn- #_"IFn" findAndCacheBestMethod [#_"MultiFn" this, #_"Object" ___dispatchVal]
        (ß (:rw this).readLock().lock())
        (§ let [#_"Object" ___bestValue]
            (let [#_"IPersistentMap" ___mt (:methodTable this)]
                (let [#_"IPersistentMap" ___pt (:preferTable this)]
                    (let [#_"Object" ___ch (:cachedHierarchy this)]
                        (try
                            (let [#_"Map$Entry" ___bestEntry nil]
                                (doseq [#_"Object" ___o (ß getMethodTable())]
                                    (let [#_"Map$Entry" ___e (ß (Map$Entry) ___o)]
                                        (when (ß isA(___dispatchVal, ___e.getKey()))
                                            (when (ß ___bestEntry == nil || dominates(___e.getKey(), ___bestEntry.getKey()))
                                                (§ ass ___bestEntry ___e)
                                            )
                                            (when (ß !dominates(___bestEntry.getKey(), ___e.getKey()))
                                                (throw (IllegalArgumentException. (String/format "Multiple methods in multimethod '%s' match dispatch value: %s -> %s and %s, and neither is preferred", (§ array (:name this), ___dispatchVal, (ß ___e.getKey()), (ß ___bestEntry.getKey())))))
                                            )
                                        )
                                    )
                                )
                                (if (nil? ___bestEntry)
                                    (do
                                        (§ ass ___bestValue (ß (:methodTable this).valAt((:defaultDispatchVal this))))
                                        (when (nil? ___bestValue)
                                            (§ return nil)
                                        )
                                    )
                                    (do
                                        (§ ass ___bestValue (ß ___bestEntry.getValue()))
                                    )
                                )
                            )
                            (finally
                                (ß (:rw this).readLock().unlock())
                            )
                        )

                        ;; ensure basis has stayed stable throughout, else redo
                        (ß (:rw this).writeLock().lock())
                        (try
                            (if (ß ___mt == (:methodTable this) && ___pt == (:preferTable this) && ___ch == (:cachedHierarchy this) && (:cachedHierarchy this) == (:hierarchy this).deref())
                                (do
                                    ;; place in cache
                                    (§ ass (:methodCache this) (ß (:methodCache this).assoc(___dispatchVal, ___bestValue)))
                                    (ß (IFn) ___bestValue)
                                )
                                (do
                                    (ß resetCache())
                                    (ß findAndCacheBestMethod(___dispatchVal))
                                )
                            )
                            (finally
                                (ß (:rw this).writeLock().unlock())
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this]
        (ß getFn((:dispatchFn this).invoke()).invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1]
        (ß getFn((:dispatchFn this).invoke(___arg1)).invoke(Util'ret1(___arg1, (§ ass ___arg1 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), Util'ret1(___arg2, (§ ass ___arg2 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), Util'ret1(___arg2, (§ ass ___arg2 nil)), Util'ret1(___arg3, (§ ass ___arg3 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß getFn((:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19, ___arg20)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"MultiFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß getFn(
                (:dispatchFn this).invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14,
                    ___arg15, ___arg16, ___arg17, ___arg18, ___arg19, ___arg20, ___args)).
            invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)),
                    ___args))
    )

    #_method
    (§ defn #_"IPersistentMap" getMethodTable [#_"MultiFn" this]
        (:methodTable this)
    )

    #_method
    (§ defn #_"IPersistentMap" getPreferTable [#_"MultiFn" this]
        (:preferTable this)
    )
)
)

(java-ns cloiure.lang.Murmur3
;;;
 ; MurmurHash3 was written by Austin Appleby, and is placed in the public
 ; domain. The author hereby disclaims copyright to this source code.
 ;;

;;;
 ; Source:
 ; http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp
 ; (Modified to adapt to Guava coding conventions and to use the HashFunction interface)
 ;;

;;;
 ; Modified to remove stuff Clojure doesn't need, placed under clojure.lang namespace,
 ; all fns made static, added hashOrdered/Unordered
 ;;

(§ import java.nio.ByteBuffer)

;;;
 ; See http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp
 ; MurmurHash3_x86_32
 ;
 ; @author Austin Appleby
 ; @author Dimitris Andreou
 ; @author Kurt Alfred Kluever
 ;;
#_stateless
(class-ns Murmur3
    (def- #_"int" Murmur3'seed 0)
    (def- #_"int" Murmur3'C1 0xcc9e2d51)
    (def- #_"int" Murmur3'C2 0x1b873593)

    (defn #_"int" Murmur3'hashInt [#_"int" ___input]
        (when (ß ___input == 0)
            (§ return 0)
        )
        (let [#_"int" ___k1 (ß mixK1(___input))]
            (let [#_"int" ___h1 (ß mixH1(Murmur3'seed, ___k1))]
                (Murmur3'fmix ___h1, 4)
            )
        )
    )

    (defn #_"int" Murmur3'hashLong [#_"long" ___input]
        (when (ß ___input == 0)
            (§ return 0)
        )
        (let [#_"int" ___low (ß (int) ___input)]
            (let [#_"int" ___high (ß (int) (___input >>> 32))]
                (let [#_"int" ___k1 (ß mixK1(___low))]
                    (let [#_"int" ___h1 (ß mixH1(Murmur3'seed, ___k1))]
                        (§ ass ___k1 (ß mixK1(___high)))
                        (§ ass ___h1 (ß mixH1(___h1, ___k1)))

                        (Murmur3'fmix ___h1, 8)
                    )
                )
            )
        )
    )

    (defn #_"int" Murmur3'hashUnencodedChars [#_"CharSequence" ___input]
        (let [#_"int" ___h1 Murmur3'seed]
            ;; step through the CharSequence 2 chars at a time
            (loop-when-recur [#_"int" ___i 1] (ß ___i < ___input.length()) [(+ ___i 2)]
                (let [#_"int" ___k1 (ß ___input.charAt(___i - 1) | (___input.charAt(___i) << 16))]
                    (§ ass ___k1 (ß mixK1(___k1)))
                    (§ ass ___h1 (ß mixH1(___h1, ___k1)))
                )
            )

            ;; deal with any remaining characters
            (when (ß (___input.length() & 1) == 1)
                (let [#_"int" ___k1 (ß ___input.charAt(___input.length() - 1))]
                    (§ ass ___k1 (ß mixK1(___k1)))
                    (§ ass ___h1 (ß ___h1 :xor ___k1))
                )
            )

            (ß Murmur3'fmix(___h1, 2 * ___input.length()))
        )
    )

    (defn #_"int" Murmur3'mixCollHash [#_"int" ___hash, #_"int" ___count]
        (let [#_"int" ___h1 Murmur3'seed]
            (let [#_"int" ___k1 (ß mixK1(___hash))]
                (§ ass ___h1 (ß mixH1(___h1, ___k1)))
                (Murmur3'fmix ___h1, ___count)
            )
        )
    )

    (defn #_"int" Murmur3'hashOrdered [#_"Iterable" ___xs]
        (let [#_"int" ___n 0]
            (let [#_"int" ___hash 1]
                (doseq [#_"Object" ___x ___xs]
                    (§ ass ___hash (ß 31 * ___hash + Util'hasheq(___x)))
                    (§ ass ___n (inc ___n))
                )

                (ß mixCollHash(___hash, ___n))
            )
        )
    )

    (defn #_"int" Murmur3'hashUnordered [#_"Iterable" ___xs]
        (let [#_"int" ___hash 0]
            (let [#_"int" ___n 0]
                (doseq [#_"Object" ___x ___xs]
                    (§ ass ___hash (ß ___hash + Util'hasheq(___x)))
                    (§ ass ___n (inc ___n))
                )

                (ß mixCollHash(___hash, ___n))
            )
        )
    )

    (defn- #_"int" Murmur3'mixK1 [#_"int" ___k1]
        (§ ass ___k1 (ß ___k1 * Murmur3'C1))
        (§ ass ___k1 (Integer/rotateLeft ___k1, 15))
        (§ ass ___k1 (ß ___k1 * Murmur3'C2))
        ___k1
    )

    (defn- #_"int" Murmur3'mixH1 [#_"int" ___h1, #_"int" ___k1]
        (§ ass ___h1 (ß ___h1 :xor ___k1))
        (§ ass ___h1 (Integer/rotateLeft ___h1, 13))
        (§ ass ___h1 (ß ___h1 * 5 + 0xe6546b64))
        ___h1
    )

    ;; Finalization mix - force all bits of a hash block to avalanche
    (defn- #_"int" Murmur3'fmix [#_"int" ___h1, #_"int" ___length]
        (§ ass ___h1 (ß ___h1 :xor ___length))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 16)))
        (§ ass ___h1 (* ___h1 0x85ebca6b))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 13)))
        (§ ass ___h1 (* ___h1 0xc2b2ae35))
        (§ ass ___h1 (ß ___h1 :xor (___h1 >>> 16)))
        ___h1
    )
)
)

(java-ns cloiure.lang.Named

(defprotocol Named
    #_abstract
    (#_"String" Named'''getNamespace [#_"Named" this])
    #_abstract
    (#_"String" Named'''getName [#_"Named" this])
)
)

(java-ns cloiure.lang.Namespace

(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns Namespace (§ extends AReference)
    (def #_"ConcurrentHashMap<Symbol, Namespace>" Namespace'namespaces (ConcurrentHashMap.))

    (defn- #_"Namespace" Namespace'init []
        (hash-map
            #_"Symbol" :name nil

            #_transient
            #_"AtomicReference<IPersistentMap>" :mappings (AtomicReference.)
            #_transient
            #_"AtomicReference<IPersistentMap>" :aliases (AtomicReference.)
        )
    )

    (defn #_"Namespace" Namespace'new [#_"Symbol" ___name]
        (let [this (merge (AReference'new (ß ___name.meta())) (Namespace'init))]
            (§ ass (:name this) ___name)
            (ß (:mappings this).set(RT'DEFAULT_IMPORTS))
            (ß (:aliases this).set(RT'map()))
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"Namespace" this]
        (ß (:name this).toString())
    )

    (defn #_"ISeq" Namespace'all []
        (ß RT'seq(namespaces.values()))
    )

    #_method
    (§ defn #_"Symbol" getName [#_"Namespace" this]
        (:name this)
    )

    #_method
    (§ defn #_"IPersistentMap" getMappings [#_"Namespace" this]
        (ß (:mappings this).get())
    )

    #_method
    (§ defn #_"Var" intern [#_"Namespace" this, #_"Symbol" ___sym]
        (when (ß (:ns ___sym) != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (ß getMappings())]
            (§ let [#_"Object" ___o]
                (let [#_"Var" ___v nil]
                    (while (nil? (§ ass ___o (ß ___map.valAt(___sym))))
                        (when (nil? ___v)
                            (§ ass ___v (Var'new-2 this, ___sym))
                        )
                        (let [#_"IPersistentMap" ___newMap (ß ___map.assoc(___sym, ___v))]
                            (ß (:mappings this).compareAndSet(___map, ___newMap))
                            (§ ass ___map (ß getMappings()))
                        )
                    )
                    (when (ß ___o instanceof Var && ((Var) ___o).ns == this)
                        (§ return (ß (Var) ___o))
                    )

                    (when (nil? ___v)
                        (§ ass ___v (Var'new-2 this, ___sym))
                    )

                    (ß warnOrFailOnReplace(___sym, ___o, ___v))

                    (while (ß !this.mappings.compareAndSet(___map, ___map.assoc(___sym, ___v)))
                        (§ ass ___map (ß getMappings()))
                    )

                    ___v
                )
            )
        )
    )

    #_method
    (§ defn- #_"void" warnOrFailOnReplace [#_"Namespace" this, #_"Symbol" ___sym, #_"Object" ___o, #_"Object" ___v]
        (when (ß ___o instanceof Var)
            (let [#_"Namespace" ___ns (ß ((Var)___o).ns)]
                (when (ß ___ns == this || (___v instanceof Var && ((Var)___v).ns == RT'CLOIURE_NS))
                    (§ return nil)
                )
                (when (ß ___ns != RT'CLOIURE_NS)
                    (throw (IllegalStateException. (str ___sym " already refers to: " ___o " in namespace: " (:name this))))
                )
            )
        )
        (ß RT'errPrintWriter().println("WARNING: " + ___sym + " already refers to: " + ___o + " in namespace: " + (:name this) + ", being replaced by: " + ___v))
        nil
    )

    #_method
    (§ defn #_"Object" reference [#_"Namespace" this, #_"Symbol" ___sym, #_"Object" ___val]
        (when (ß (:ns ___sym) != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (ß getMappings())]
            (§ let [#_"Object" ___o]
                (while (nil? (§ ass ___o (ß ___map.valAt(___sym))))
                    (let [#_"IPersistentMap" ___newMap (ß ___map.assoc(___sym, ___val))]
                        (ß (:mappings this).compareAndSet(___map, ___newMap))
                        (§ ass ___map (ß getMappings()))
                    )
                )
                (when (ß ___o == ___val)
                    (§ return ___o)
                )

                (ß warnOrFailOnReplace(___sym, ___o, ___val))

                (while (ß !this.mappings.compareAndSet(___map, ___map.assoc(___sym, ___val)))
                    (§ ass ___map (ß getMappings()))
                )

                ___val
            )
        )
    )

    (defn #_"boolean" Namespace'areDifferentInstancesOfSameClassName [#_"Class" ___cls1, #_"Class" ___cls2]
        (ß (___cls1 != ___cls2) && (___cls1.getName().equals(___cls2.getName())))
    )

    #_method
    (§ defn #_"Class" referenceClass [#_"Namespace" this, #_"Symbol" ___sym, #_"Class" ___val]
        (when (ß (:ns ___sym) != nil)
            (throw (IllegalArgumentException. "Can't intern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (ß getMappings())]
            (let [#_"Class" ___c (ß (Class) ___map.valAt(___sym))]
                (while (ß (___c == nil) || (areDifferentInstancesOfSameClassName(___c, ___val)))
                    (let [#_"IPersistentMap" ___newMap (ß ___map.assoc(___sym, ___val))]
                        (ß (:mappings this).compareAndSet(___map, ___newMap))
                        (§ ass ___map (ß getMappings()))
                        (§ ass ___c (ß (Class) ___map.valAt(___sym)))
                    )
                )
                (when (ß ___c == ___val)
                    (§ return ___c)
                )

                (throw (IllegalStateException. (str ___sym " already refers to: " ___c " in namespace: " (:name this))))
            )
        )
    )

    #_method
    (§ defn #_"void" unmap [#_"Namespace" this, #_"Symbol" ___sym]
        (when (ß (:ns ___sym) != nil)
            (throw (IllegalArgumentException. "Can't unintern namespace-qualified symbol"))
        )
        (let [#_"IPersistentMap" ___map (ß getMappings())]
            (while (ß ___map.containsKey(___sym))
                (let [#_"IPersistentMap" ___newMap (ß ___map.without(___sym))]
                    (ß (:mappings this).compareAndSet(___map, ___newMap))
                    (§ ass ___map (ß getMappings()))
                )
            )
            nil
        )
    )

    #_method
    (§ defn #_"Class" importClass [#_"Namespace" this, #_"Symbol" ___sym, #_"Class" ___c]
        (ß referenceClass(___sym, ___c))
    )

    #_method
    (§ defn #_"Class" importClass [#_"Namespace" this, #_"Class" ___c]
        (let [#_"String" ___n (ß ___c.getName())]
            (ß importClass(Symbol'intern-1(___n.substring(___n.lastIndexOf(\.) + 1)), ___c))
        )
    )

    #_method
    (§ defn #_"Var" refer [#_"Namespace" this, #_"Symbol" ___sym, #_"Var" ___var]
        (ß (Var) reference(___sym, ___var))
    )

    (defn #_"Namespace" Namespace'findOrCreate [#_"Symbol" ___name]
        (let [#_"Namespace" ___ns (ß namespaces.get(___name))]
            (when (some? ___ns)
                (§ return ___ns)
            )
            (let [#_"Namespace" ___newns (Namespace'new ___name)]
                (§ ass ___ns (ß namespaces.putIfAbsent(___name, ___newns)))
                (ß (___ns == nil) ? ___newns :or ___ns)
            )
        )
    )

    (defn #_"Namespace" Namespace'remove [#_"Symbol" ___name]
        (when (ß ___name.equals(RT'CLOIURE_NS.name))
            (throw (IllegalArgumentException. "Cannot remove cloiure namespace"))
        )
        (ß namespaces.remove(___name))
    )

    (defn #_"Namespace" Namespace'find [#_"Symbol" ___name]
        (ß namespaces.get(___name))
    )

    #_method
    (§ defn #_"Object" getMapping [#_"Namespace" this, #_"Symbol" ___name]
        (ß (:mappings this).get().valAt(___name))
    )

    #_method
    (§ defn #_"Var" findInternedVar [#_"Namespace" this, #_"Symbol" ___symbol]
        (let [#_"Object" ___o (ß (:mappings this).get().valAt(___symbol))]
            (when (ß ___o != nil && ___o instanceof Var && ((Var) ___o).ns == this)
                (§ return (ß (Var) ___o))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" getAliases [#_"Namespace" this]
        (ß (:aliases this).get())
    )

    #_method
    (§ defn #_"Namespace" lookupAlias [#_"Namespace" this, #_"Symbol" ___alias]
        (let [#_"IPersistentMap" ___map (ß getAliases())]
            (ß (Namespace) ___map.valAt(___alias))
        )
    )

    #_method
    (§ defn #_"void" addAlias [#_"Namespace" this, #_"Symbol" ___alias, #_"Namespace" ___ns]
        (when (ß ___alias == nil || ___ns == nil)
            (throw (NullPointerException. "Expecting Symbol + Namespace"))
        )
        (let [#_"IPersistentMap" ___map (ß getAliases())]
            (while (ß !___map.containsKey(___alias))
                (let [#_"IPersistentMap" ___newMap (ß ___map.assoc(___alias, ___ns))]
                    (ß (:aliases this).compareAndSet(___map, ___newMap))
                    (§ ass ___map (ß getAliases()))
                )
            )
            ;; you can rebind an alias, but only to the initially-aliased namespace.
            (when (ß !___map.valAt(___alias).equals(___ns))
                (throw (IllegalStateException. (str "Alias " ___alias " already exists in namespace " (:name this) ", aliasing " (ß ___map.valAt(___alias)))))
            )
            nil
        )
    )

    #_method
    (§ defn #_"void" removeAlias [#_"Namespace" this, #_"Symbol" ___alias]
        (let [#_"IPersistentMap" ___map (ß getAliases())]
            (while (ß ___map.containsKey(___alias))
                (let [#_"IPersistentMap" ___newMap (ß ___map.without(___alias))]
                    (ß (:aliases this).compareAndSet(___map, ___newMap))
                    (§ ass ___map (ß getAliases()))
                )
            )
            nil
        )
    )
)
)

(java-ns cloiure.lang.Numbers

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(defprotocol Ops
    #_abstract
    (#_"Ops" Ops'''combine [#_"Ops" this, #_"Ops" ___y])
    #_abstract
    (#_"Ops" Ops'''opsWithLong [#_"Ops" this, #_"LongOps" ___x])
    #_abstract
    (#_"Ops" Ops'''opsWithDouble [#_"Ops" this, #_"DoubleOps" ___x])
    #_abstract
    (#_"Ops" Ops'''opsWithRatio [#_"Ops" this, #_"RatioOps" ___x])
    #_abstract
    (#_"Ops" Ops'''opsWithBigInt [#_"Ops" this, #_"BigIntOps" ___x])
    #_abstract
    (#_"Ops" Ops'''opsWithBigDecimal [#_"Ops" this, #_"BigDecimalOps" ___x])
    #_abstract
    (#_"boolean" Ops'''isZero [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"boolean" Ops'''isPos [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"boolean" Ops'''isNeg [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''add [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''addP [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''multiply [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''multiplyP [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''divide [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''quotient [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''remainder [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''equiv [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''lt [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''lte [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"boolean" Ops'''gte [#_"Ops" this, #_"Number" ___x, #_"Number" ___y])
    #_abstract
    (#_"Number" Ops'''negate [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''negateP [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''inc [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''incP [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''dec [#_"Ops" this, #_"Number" ___x])
    #_abstract
    (#_"Number" Ops'''decP [#_"Ops" this, #_"Number" ___x])
)

#_stateless
#_abstract
(class-ns OpsP (§ implements Ops)
    #_protected
    (defn #_"OpsP" OpsP'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Number" addP [#_"OpsP" this, #_"Number" ___x, #_"Number" ___y]
        (ß add(___x, ___y))
    )

    #_method
    (§ defn #_"Number" multiplyP [#_"OpsP" this, #_"Number" ___x, #_"Number" ___y]
        (ß multiply(___x, ___y))
    )

    #_method
    (§ defn #_"Number" negateP [#_"OpsP" this, #_"Number" ___x]
        (ß negate(___x))
    )

    #_method
    (§ defn #_"Number" incP [#_"OpsP" this, #_"Number" ___x]
        (ß inc(___x))
    )

    #_method
    (§ defn #_"Number" decP [#_"OpsP" this, #_"Number" ___x]
        (ß dec(___x))
    )
)

(class-ns LongOps (§ implements Ops)
    (defn #_"LongOps" LongOps'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Ops" combine [#_"LongOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"RatioOps" ___x]
        Numbers'RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"BigIntOps" ___x]
        Numbers'BIGINT_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"LongOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" isZero [#_"LongOps" this, #_"Number" ___x]
        (ß (___x.longValue() == 0))
    )

    #_method
    (§ defn #_"boolean" isPos [#_"LongOps" this, #_"Number" ___x]
        (ß (___x.longValue() > 0))
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"LongOps" this, #_"Number" ___x]
        (ß (___x.longValue() < 0))
    )

    #_method
    (§ defn #_"Number" add [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(Numbers'add-2ll(___x.longValue(), ___y.longValue())))
    )

    #_method
    (§ defn #_"Number" addP [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___lx (ß ___x.longValue()) #_"long" ___ly (ß ___y.longValue())]
            (let [#_"long" ___ret (+ ___lx ___ly)]
                (when (ß (___ret :xor ___lx) < 0 && (___ret :xor ___ly) < 0)
                    (§ return (ß Numbers'BIGINT_OPS.add(___x, ___y)))
                )
                (ß num(___ret))
            )
        )
    )

    #_method
    (§ defn #_"Number" multiply [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(Numbers'multiply-2ll(___x.longValue(), ___y.longValue())))
    )

    #_method
    (§ defn #_"Number" multiplyP [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___lx (ß ___x.longValue()) #_"long" ___ly (ß ___y.longValue())]
            (when (ß ___lx == Long/MIN_VALUE && ___ly < 0)
                (§ return (ß Numbers'BIGINT_OPS.multiply(___x, ___y)))
            )
            (let [#_"long" ___ret (* ___lx ___ly)]
                (when (ß ___ly != 0 && ___ret / ___ly != ___lx)
                    (§ return (ß Numbers'BIGINT_OPS.multiply(___x, ___y)))
                )
                (ß num(___ret))
            )
        )
    )

    (defn #_"long" LongOps'gcd [#_"long" ___u, #_"long" ___v]
        (while (ß ___v != 0)
            (let [#_"long" ___r (ß ___u % ___v)]
                (§ ass ___u ___v)
                (§ ass ___v ___r)
            )
        )
        ___u
    )

    #_method
    (§ defn #_"Number" divide [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"long" ___n (ß ___x.longValue())]
            (let [#_"long" ___val (ß ___y.longValue())]
                (let [#_"long" ___gcd (LongOps'gcd ___n, ___val)]
                    (when (ß ___gcd == 0)
                        (§ return (ß num(0)))
                    )

                    (§ ass ___n (/ ___n ___gcd))
                    (let [#_"long" ___d (/ ___val ___gcd)]
                        (when (ß ___d == 1)
                            (§ return (ß num(___n)))
                        )
                        (when (< ___d 0)
                            (§ ass ___n (- ___n))
                            (§ ass ___d (- ___d))
                        )
                        (ß Ratio'new(BigInteger/valueOf(___n), BigInteger/valueOf(___d)))
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" quotient [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(___x.longValue() / ___y.longValue()))
    )

    #_method
    (§ defn #_"Number" remainder [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß num(___x.longValue() % ___y.longValue()))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.longValue() == ___y.longValue()))
    )

    #_method
    (§ defn #_"boolean" lt [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.longValue() < ___y.longValue()))
    )

    #_method
    (§ defn #_"boolean" lte [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.longValue() <= ___y.longValue()))
    )

    #_method
    (§ defn #_"boolean" gte [#_"LongOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.longValue() >= ___y.longValue()))
    )

    #_method
    (§ defn #_"Number" negate [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (ß num(Numbers'minus-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" negateP [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (when (ß ___val > Long/MIN_VALUE)
                (§ return (ß num(-val)))
            )
            (ß BigInt'fromBigInteger(BigInteger/valueOf(___val).negate()))
        )
    )

    #_method
    (§ defn #_"Number" inc [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (ß num(Numbers'inc-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" incP [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (when (ß ___val < Long/MAX_VALUE)
                (§ return (ß num(___val + 1)))
            )
            (ß Numbers'BIGINT_OPS.inc(___x))
        )
    )

    #_method
    (§ defn #_"Number" dec [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (ß num(Numbers'dec-1l(___val)))
        )
    )

    #_method
    (§ defn #_"Number" decP [#_"LongOps" this, #_"Number" ___x]
        (let [#_"long" ___val (ß ___x.longValue())]
            (when (ß ___val > Long/MIN_VALUE)
                (§ return (ß num(___val - 1)))
            )
            (ß Numbers'BIGINT_OPS.dec(___x))
        )
    )
)

(class-ns DoubleOps (§ extends OpsP)
    (defn #_"DoubleOps" DoubleOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" combine [#_"DoubleOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"DoubleOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"DoubleOps" this, #_"BigDecimalOps" ___x]
        this
    )

    #_method
    (§ defn #_"boolean" isZero [#_"DoubleOps" this, #_"Number" ___x]
        (ß (___x.doubleValue() == 0))
    )

    #_method
    (§ defn #_"boolean" isPos [#_"DoubleOps" this, #_"Number" ___x]
        (ß (___x.doubleValue() > 0))
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"DoubleOps" this, #_"Number" ___x]
        (ß (___x.doubleValue() < 0))
    )

    #_method
    (§ defn #_"Number" add [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf(___x.doubleValue() + ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" multiply [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf(___x.doubleValue() * ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" divide [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Double/valueOf(___x.doubleValue() / ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" quotient [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'quotient-2dd(___x.doubleValue(), ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" remainder [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'remainder-2dd(___x.doubleValue(), ___y.doubleValue()))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.doubleValue() == ___y.doubleValue()))
    )

    #_method
    (§ defn #_"boolean" lt [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.doubleValue() < ___y.doubleValue()))
    )

    #_method
    (§ defn #_"boolean" lte [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.doubleValue() <= ___y.doubleValue()))
    )

    #_method
    (§ defn #_"boolean" gte [#_"DoubleOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (___x.doubleValue() >= ___y.doubleValue()))
    )

    #_method
    (§ defn #_"Number" negate [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf(-x.doubleValue()))
    )

    #_method
    (§ defn #_"Number" inc [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf(___x.doubleValue() + 1))
    )

    #_method
    (§ defn #_"Number" dec [#_"DoubleOps" this, #_"Number" ___x]
        (ß Double/valueOf(___x.doubleValue() - 1))
    )
)

(class-ns RatioOps (§ extends OpsP)
    (defn #_"RatioOps" RatioOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" combine [#_"RatioOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"RatioOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" isZero [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß ((:numerator ___r).signum() == 0))
        )
    )

    #_method
    (§ defn #_"boolean" isPos [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß ((:numerator ___r).signum() > 0))
        )
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß ((:numerator ___r).signum() < 0))
        )
    )

    (defn #_"Number" RatioOps'normalizeRet [#_"Number" ___ret, #_"Number" ___x, #_"Number" ___y]
        ___ret
    )

    #_method
    (§ defn #_"Number" add [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß divide((:numerator ___ry).multiply((:denominator ___rx)).add((:numerator ___rx).multiply((:denominator ___ry))), (:denominator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" multiply [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß Numbers'divide-2ii((:numerator ___ry).multiply((:numerator ___rx)), (:denominator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" divide [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"Number" ___ret (ß Numbers'divide-2ii((:denominator ___ry).multiply((:numerator ___rx)), (:numerator ___ry).multiply((:denominator ___rx))))]
                    (RatioOps'normalizeRet ___ret, ___x, ___y)
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" quotient [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"BigInteger" ___q (ß (:numerator ___rx).multiply((:denominator ___ry)).divide((:denominator ___rx).multiply((:numerator ___ry))))]
                    (ß RatioOps'normalizeRet(BigInt'fromBigInteger(___q), ___x, ___y))
                )
            )
        )
    )

    #_method
    (§ defn #_"Number" remainder [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (let [#_"BigInteger" ___q (ß (:numerator ___rx).multiply((:denominator ___ry)).divide((:denominator ___rx).multiply((:numerator ___ry))))]
                    (let [#_"Number" ___ret (ß Numbers'minus-2oo(___x, Numbers'multiply-2oo(___q, ___y)))]
                        (RatioOps'normalizeRet ___ret, ___x, ___y)
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß ((:numerator ___rx).equals((:numerator ___ry)) && (:denominator ___rx).equals((:denominator ___ry))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" lt [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'lt-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" lte [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'lte-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"boolean" gte [#_"RatioOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"Ratio" ___rx (ß toRatio(___x))]
            (let [#_"Ratio" ___ry (ß toRatio(___y))]
                (ß Numbers'gte-2oo((:numerator ___rx).multiply((:denominator ___ry)), (:numerator ___ry).multiply((:denominator ___rx))))
            )
        )
    )

    #_method
    (§ defn #_"Number" negate [#_"RatioOps" this, #_"Number" ___x]
        (let [#_"Ratio" ___r (ß (Ratio) ___x)]
            (ß Ratio'new((:numerator ___r).negate(), (:denominator ___r)))
        )
    )

    #_method
    (§ defn #_"Number" inc [#_"RatioOps" this, #_"Number" ___x]
        (Numbers'add-2ol ___x, 1)
    )

    #_method
    (§ defn #_"Number" dec [#_"RatioOps" this, #_"Number" ___x]
        (Numbers'add-2ol ___x, -1)
    )
)

(class-ns BigIntOps (§ extends OpsP)
    (defn #_"BigIntOps" BigIntOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" combine [#_"BigIntOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"RatioOps" ___x]
        Numbers'RATIO_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigIntOps" this, #_"BigDecimalOps" ___x]
        Numbers'BIGDECIMAL_OPS
    )

    #_method
    (§ defn #_"boolean" isZero [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß (:bipart ___bx) == nil)
                (§ return (ß ((:lpart ___bx) == 0)))
            )
            (ß ((:bipart ___bx).signum() == 0))
        )
    )

    #_method
    (§ defn #_"boolean" isPos [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß (:bipart ___bx) == nil)
                (§ return (ß ((:lpart ___bx) > 0)))
            )
            (ß ((:bipart ___bx).signum() > 0))
        )
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInt" ___bx (ß toBigInt(___x))]
            (when (ß (:bipart ___bx) == nil)
                (§ return (ß ((:lpart ___bx) < 0)))
            )
            (ß ((:bipart ___bx).signum() < 0))
        )
    )

    #_method
    (§ defn #_"Number" add [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).add(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" multiply [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).multiply(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" divide [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß Numbers'divide-2ii(toBigInteger(___x), toBigInteger(___y)))
    )

    #_method
    (§ defn #_"Number" quotient [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).quotient(toBigInt(___y)))
    )

    #_method
    (§ defn #_"Number" remainder [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).remainder(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).equals(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" lt [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß toBigInt(___x).lt(toBigInt(___y)))
    )

    #_method
    (§ defn #_"boolean" lte [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigInteger(___x).compareTo(toBigInteger(___y)) <= 0))
    )

    #_method
    (§ defn #_"boolean" gte [#_"BigIntOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigInteger(___x).compareTo(toBigInteger(___y)) >= 0))
    )

    #_method
    (§ defn #_"Number" negate [#_"BigIntOps" this, #_"Number" ___x]
        (ß BigInt'fromBigInteger(toBigInteger(___x).negate()))
    )

    #_method
    (§ defn #_"Number" inc [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInteger" ___bx (ß toBigInteger(___x))]
            (ß BigInt'fromBigInteger(___bx.add(BigInteger/ONE)))
        )
    )

    #_method
    (§ defn #_"Number" dec [#_"BigIntOps" this, #_"Number" ___x]
        (let [#_"BigInteger" ___bx (ß toBigInteger(___x))]
            (ß BigInt'fromBigInteger(___bx.subtract(BigInteger/ONE)))
        )
    )
)

(class-ns BigDecimalOps (§ extends OpsP)
    (§ def #_"Var" BigDecimalOps'MATH_CONTEXT RT'MATH_CONTEXT)

    (defn #_"BigDecimalOps" BigDecimalOps'new []
        (OpsP'new)
    )

    #_method
    (§ defn #_"Ops" combine [#_"BigDecimalOps" this, #_"Ops" ___y]
        (ß ___y.opsWith(this))
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"LongOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"DoubleOps" ___x]
        Numbers'DOUBLE_OPS
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"RatioOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"BigIntOps" ___x]
        this
    )

    #_method
    (§ defn #_"Ops" opsWith [#_"BigDecimalOps" this, #_"BigDecimalOps" ___x]
        this
    )

    #_method
    (§ defn #_"boolean" isZero [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß (___bx.signum() == 0))
        )
    )

    #_method
    (§ defn #_"boolean" isPos [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß (___bx.signum() > 0))
        )
    )

    #_method
    (§ defn #_"boolean" isNeg [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
            (ß (___bx.signum() < 0))
        )
    )

    #_method
    (§ defn #_"Number" add [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).add(toBigDecimal(___y)) :or toBigDecimal(___x).add(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" multiply [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).multiply(toBigDecimal(___y)) :or toBigDecimal(___x).multiply(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" divide [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).divide(toBigDecimal(___y)) :or toBigDecimal(___x).divide(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" quotient [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).divideToIntegralValue(toBigDecimal(___y)) :or toBigDecimal(___x).divideToIntegralValue(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"Number" remainder [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? toBigDecimal(___x).remainder(toBigDecimal(___y)) :or toBigDecimal(___x).remainder(toBigDecimal(___y), ___mc))
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigDecimal(___x).compareTo(toBigDecimal(___y)) == 0))
    )

    #_method
    (§ defn #_"boolean" lt [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigDecimal(___x).compareTo(toBigDecimal(___y)) < 0))
    )

    #_method
    (§ defn #_"boolean" lte [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigDecimal(___x).compareTo(toBigDecimal(___y)) <= 0))
    )

    #_method
    (§ defn #_"boolean" gte [#_"BigDecimalOps" this, #_"Number" ___x, #_"Number" ___y]
        (ß (toBigDecimal(___x).compareTo(toBigDecimal(___y)) >= 0))
    )

    #_method
    (§ defn #_"Number" negate [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (ß (___mc == nil) ? ((BigDecimal) ___x).negate() :or ((BigDecimal) ___x).negate(___mc))
        )
    )

    #_method
    (§ defn #_"Number" inc [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                (ß (___mc == nil) ? ___bx.add(BigDecimal/ONE) :or ___bx.add(BigDecimal/ONE, ___mc))
            )
        )
    )

    #_method
    (§ defn #_"Number" dec [#_"BigDecimalOps" this, #_"Number" ___x]
        (let [#_"MathContext" ___mc (ß (MathContext) BigDecimalOps'MATH_CONTEXT.deref())]
            (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                (ß (___mc == nil) ? ___bx.subtract(BigDecimal/ONE) :or ___bx.subtract(BigDecimal/ONE, ___mc))
            )
        )
    )
)

(def Category'enum-set
    (hash-set
        :Category'INTEGER
        :Category'FLOATING
        :Category'DECIMAL
        :Category'RATIO
    )
)

#_stateless
(class-ns Numbers
    (defn #_"boolean" Numbers'isZero-1o [#_"Object" ___x]
        (ß ops(___x).isZero((Number)___x))
    )

    (defn #_"boolean" Numbers'isPos-1o [#_"Object" ___x]
        (ß ops(___x).isPos((Number)___x))
    )

    (defn #_"boolean" Numbers'isNeg-1o [#_"Object" ___x]
        (ß ops(___x).isNeg((Number)___x))
    )

    (defn #_"Number" Numbers'minus-1o [#_"Object" ___x]
        (ß ops(___x).negate((Number)___x))
    )

    (defn #_"Number" Numbers'minusP-1o [#_"Object" ___x]
        (ß ops(___x).negateP((Number)___x))
    )

    (defn #_"Number" Numbers'inc-1o [#_"Object" ___x]
        (ß ops(___x).inc((Number)___x))
    )

    (defn #_"Number" Numbers'incP-1o [#_"Object" ___x]
        (ß ops(___x).incP((Number)___x))
    )

    (defn #_"Number" Numbers'dec-1o [#_"Object" ___x]
        (ß ops(___x).dec((Number)___x))
    )

    (defn #_"Number" Numbers'decP-1o [#_"Object" ___x]
        (ß ops(___x).decP((Number)___x))
    )

    (defn #_"Number" Numbers'add-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).add((Number)___x, (Number)___y))
    )

    (defn #_"Number" Numbers'addP-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).addP((Number)___x, (Number)___y))
    )

    (defn #_"Number" Numbers'minus-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (ß ops(___x).combine(___yops).add((Number)___x, ___yops.negate((Number)___y)))
        )
    )

    (defn #_"Number" Numbers'minusP-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (let [#_"Number" ___negativeY (ß ___yops.negateP((Number) ___y))]
                (let [#_"Ops" ___negativeYOps (ß ops(___negativeY))]
                    (ß ops(___x).combine(___negativeYOps).addP((Number)___x, ___negativeY))
                )
            )
        )
    )

    (defn #_"Number" Numbers'multiply-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).multiply((Number)___x, (Number)___y))
    )

    (defn #_"Number" Numbers'multiplyP-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).multiplyP((Number)___x, (Number)___y))
    )

    (defn #_"Number" Numbers'divide-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return (ß (Number)___x))
            )
            (ß isNaN(___y))
            (do
                (§ return (ß (Number)___y))
            )
        )
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((Number)___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).divide((Number)___x, (Number)___y))
        )
    )

    (defn #_"Number" Numbers'quotient-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((Number) ___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).quotient((Number)___x, (Number)___y))
        )
    )

    (defn #_"Number" Numbers'remainder-2oo [#_"Object" ___x, #_"Object" ___y]
        (let [#_"Ops" ___yops (ß ops(___y))]
            (when (ß ___yops.isZero((Number) ___y))
                (throw (ArithmeticException. "Divide by zero"))
            )
            (ß ops(___x).combine(___yops).remainder((Number)___x, (Number)___y))
        )
    )

    (defn #_"double" Numbers'quotient-2dd [#_"double" ___n, #_"double" ___d]
        (when (ß ___d == 0)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" ___q (/ ___n ___d)]
            (cond (ß ___q <= Long/MAX_VALUE && ___q >= Long/MIN_VALUE)
                (do
                    (ß (double)(long) ___q)
                )
                :else ;; bigint quotient
                (do
                    (ß (BigDecimal. ___q).toBigInteger().doubleValue())
                )
            )
        )
    )

    (defn #_"double" Numbers'remainder-2dd [#_"double" ___n, #_"double" ___d]
        (when (ß ___d == 0)
            (throw (ArithmeticException. "Divide by zero"))
        )

        (let [#_"double" ___q (/ ___n ___d)]
            (cond (ß ___q <= Long/MAX_VALUE && ___q >= Long/MIN_VALUE)
                (do
                    (ß (___n - ((long) ___q) * ___d))
                )
                :else ;; bigint quotient
                (do
                    (let [#_"Number" ___bq (ß (BigDecimal. ___q).toBigInteger())]
                        (ß (___n - ___bq.doubleValue() * ___d))
                    )
                )
            )
        )
    )

    (defn #_"boolean" Numbers'equiv-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß equiv((Number) ___x, (Number) ___y))
    )

    (defn #_"boolean" Numbers'equiv-2nn [#_"Number" ___x, #_"Number" ___y]
        (ß ops(___x).combine(ops(___y)).equiv(___x, ___y))
    )

    (defn #_"boolean" Numbers'equal [#_"Number" ___x, #_"Number" ___y]
        (ß (category(___x) == category(___y) && ops(___x).combine(ops(___y)).equiv(___x, ___y)))
    )

    (defn #_"boolean" Numbers'lt-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lt((Number)___x, (Number)___y))
    )

    (defn #_"boolean" Numbers'lte-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lte((Number)___x, (Number)___y))
    )

    (defn #_"boolean" Numbers'gt-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).lt((Number)___y, (Number)___x))
    )

    (defn #_"boolean" Numbers'gte-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß ops(___x).combine(ops(___y)).gte((Number)___x, (Number)___y))
    )

    (defn #_"int" Numbers'compare [#_"Number" ___x, #_"Number" ___y]
        (let [#_"Ops" ___ops (ß ops(___x).combine(ops(___y)))]
            (cond (ß ___ops.lt(___x, ___y))
                (do
                    (§ return -1)
                )
                (ß ___ops.lt(___y, ___x))
                (do
                    (§ return 1)
                )
            )
            0
        )
    )

    (defn #_"BigInt" Numbers'toBigInt [#_"Object" ___x]
        (when (ß ___x instanceof BigInt)
            (§ return (ß (BigInt) ___x))
        )
        (if (ß ___x instanceof BigInteger)
            (do
                (ß BigInt'fromBigInteger((BigInteger) ___x))
            )
            (do
                (ß BigInt'fromLong(((Number) ___x).longValue()))
            )
        )
    )

    (defn #_"BigInteger" Numbers'toBigInteger [#_"Object" ___x]
        (cond (ß ___x instanceof BigInteger)
            (do
                (ß (BigInteger) ___x)
            )
            (ß ___x instanceof BigInt)
            (do
                (ß ((BigInt) ___x).toBigInteger())
            )
            :else
            (do
                (ß BigInteger/valueOf(((Number) ___x).longValue()))
            )
        )
    )

    (defn #_"BigDecimal" Numbers'toBigDecimal [#_"Object" ___x]
        (cond (ß ___x instanceof BigDecimal)
            (do
                (ß (BigDecimal) ___x)
            )
            (ß ___x instanceof BigInt)
            (do
                (let [#_"BigInt" ___bi (ß (BigInt) ___x)]
                    (if (ß (:bipart ___bi) == nil)
                        (do
                            (ß BigDecimal/valueOf((:lpart ___bi)))
                        )
                        (do
                            (§ unsure BigDecimal. (:bipart ___bi))
                        )
                    )
                )
            )
            (ß ___x instanceof BigInteger)
            (do
                (§ unsure BigDecimal. (ß (BigInteger) ___x))
            )
            (ß ___x instanceof Double)
            (do
                (§ unsure BigDecimal. (ß ((Number) ___x).doubleValue()))
            )
            (ß ___x instanceof Float)
            (do
                (§ unsure BigDecimal. (ß ((Number) ___x).doubleValue()))
            )
            (ß ___x instanceof Ratio)
            (do
                (let [#_"Ratio" ___r (ß (Ratio)___x)]
                    (ß (BigDecimal)divide((§ unsure BigDecimal. (:numerator ___r)), (:denominator ___r)))
                )
            )
            :else
            (do
                (BigDecimal/valueOf (ß ((Number) ___x).longValue()))
            )
        )
    )

    (defn #_"Ratio" Numbers'toRatio [#_"Object" ___x]
        (cond (ß ___x instanceof Ratio)
            (do
                (§ return (ß (Ratio) ___x))
            )
            (ß ___x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                    (let [#_"BigInteger" ___bv (ß ___bx.unscaledValue())]
                        (let [#_"int" ___scale (ß ___bx.scale())]
                            (if (< ___scale 0)
                                (do
                                    (§ return (ß Ratio'new(___bv.multiply(BigInteger/TEN.pow(-scale)), BigInteger/ONE)))
                                )
                                (do
                                    (§ return (ß Ratio'new(___bv, BigInteger/TEN.pow(___scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        (ß Ratio'new(toBigInteger(___x), BigInteger/ONE))
    )

    (defn #_"Number" Numbers'rationalize [#_"Number" ___x]
        (cond (ß ___x instanceof Float || ___x instanceof Double)
            (do
                (§ return (ß rationalize(BigDecimal/valueOf(___x.doubleValue()))))
            )
            (ß ___x instanceof BigDecimal)
            (do
                (let [#_"BigDecimal" ___bx (ß (BigDecimal) ___x)]
                    (let [#_"BigInteger" ___bv (ß ___bx.unscaledValue())]
                        (let [#_"int" ___scale (ß ___bx.scale())]
                            (if (< ___scale 0)
                                (do
                                    (§ return (ß BigInt'fromBigInteger(___bv.multiply(BigInteger/TEN.pow(-scale)))))
                                )
                                (do
                                    (§ return (ß divide(___bv, BigInteger/TEN.pow(___scale))))
                                )
                            )
                        )
                    )
                )
            )
        )
        ___x
    )

    (defn #_"Number" Numbers'reduceBigInt [#_"BigInt" ___val]
        (if (ß (:bipart ___val) == nil)
            (do
                (ß num((:lpart ___val)))
            )
            (do
                (:bipart ___val)
            )
        )
    )

    (defn #_"Number" Numbers'divide-2ii [#_"BigInteger" ___n, #_"BigInteger" ___d]
        (when (ß ___d.equals(BigInteger/ZERO))
            (throw (ArithmeticException. "Divide by zero"))
        )
        (let [#_"BigInteger" ___gcd (ß ___n.gcd(___d))]
            (when (ß ___gcd.equals(BigInteger/ZERO))
                (§ return BigInt'ZERO)
            )
            (§ ass ___n (ß ___n.divide(___gcd)))
            (§ ass ___d (ß ___d.divide(___gcd)))
            (cond (ß ___d.equals(BigInteger/ONE))
                (do
                    (§ return (BigInt'fromBigInteger ___n))
                )
                (ß ___d.equals(BigInteger/ONE.negate()))
                (do
                    (§ return (ß BigInt'fromBigInteger(___n.negate())))
                )
            )
            (ß Ratio'new(((___d.signum() < 0) ? ___n.negate() :or ___n), ((___d.signum() < 0) ? ___d.negate() :or ___d)))
        )
    )

    (defn #_"int" Numbers'shiftLeftInt [#_"int" ___x, #_"int" ___n]
        (ß ___x << ___n)
    )

    (defn #_"long" Numbers'shiftLeft-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß shiftLeft(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftLeft-2ol [#_"Object" ___x, #_"long" ___y]
        (ß shiftLeft(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'shiftLeft-2lo [#_"long" ___x, #_"Object" ___y]
        (ß shiftLeft(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftLeft-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x << ___n)
    )

    (defn #_"int" Numbers'shiftRightInt [#_"int" ___x, #_"int" ___n]
        (ß ___x >> ___n)
    )

    (defn #_"long" Numbers'shiftRight-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß shiftRight(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftRight-2ol [#_"Object" ___x, #_"long" ___y]
        (ß shiftRight(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'shiftRight-2lo [#_"long" ___x, #_"Object" ___y]
        (ß shiftRight(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'shiftRight-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x >> ___n)
    )

    (defn #_"int" Numbers'unsignedShiftRightInt [#_"int" ___x, #_"int" ___n]
        (ß ___x >>> ___n)
    )

    (defn #_"long" Numbers'unsignedShiftRight-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß unsignedShiftRight(bitOpsCast(___x), bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ol [#_"Object" ___x, #_"long" ___y]
        (ß unsignedShiftRight(bitOpsCast(___x), ___y))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2lo [#_"long" ___x, #_"Object" ___y]
        (ß unsignedShiftRight(___x, bitOpsCast(___y)))
    )
    (defn #_"long" Numbers'unsignedShiftRight-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x >>> ___n)
    )

    (§ def #_"LongOps" Numbers'LONG_OPS (LongOps'new))
    (§ def #_"DoubleOps" Numbers'DOUBLE_OPS (DoubleOps'new))
    (§ def #_"RatioOps" Numbers'RATIO_OPS (RatioOps'new))
    (§ def #_"BigIntOps" Numbers'BIGINT_OPS (BigIntOps'new))
    (§ def #_"BigDecimalOps" Numbers'BIGDECIMAL_OPS (BigDecimalOps'new))

    (defn #_"Ops" Numbers'ops [#_"Object" ___x]
        (let [#_"Class" ___xc (ß ___x.getClass())]
            (cond (ß ___xc == (§ class Long))
                (do
                    Numbers'LONG_OPS
                )
                (ß ___xc == (§ class Double))
                (do
                    Numbers'DOUBLE_OPS
                )
                (ß ___xc == (§ class Integer))
                (do
                    Numbers'LONG_OPS
                )
                (ß ___xc == (§ class Float))
                (do
                    Numbers'DOUBLE_OPS
                )
                (ß ___xc == (§ class BigInt))
                (do
                    Numbers'BIGINT_OPS
                )
                (ß ___xc == (§ class BigInteger))
                (do
                    Numbers'BIGINT_OPS
                )
                (ß ___xc == (§ class Ratio))
                (do
                    Numbers'RATIO_OPS
                )
                (ß ___xc == (§ class BigDecimal))
                (do
                    Numbers'BIGDECIMAL_OPS
                )
                :else
                (do
                    Numbers'LONG_OPS
                )
            )
        )
    )

    (defn #_"int" Numbers'hasheqFrom [#_"Number" ___x, #_"Class" ___xc]
        (when (ß ___xc == (§ class Integer) || ___xc == (§ class Short) || ___xc == (§ class Byte) || (___xc == (§ class BigInteger) && lte(___x, Long/MAX_VALUE) && gte(___x, Long/MIN_VALUE)))
            (let [#_"long" ___lpart (ß ___x.longValue())]
                (§ return (Murmur3'hashLong ___lpart))
            )
        )
        (when (ß ___xc == (§ class BigDecimal))
            ;; stripTrailingZeros() to make all numerically equal
            ;; BigDecimal values come out the same before calling
            ;; hashCode. Special check for 0 because
            ;; stripTrailingZeros() does not do anything to values
            ;; equal to 0 with different scales.
            (if (ß isZero(___x))
                (do
                    (§ return (ß BigDecimal/ZERO.hashCode()))
                )
                (do
                    (§ return (ß ((BigDecimal) ___x).stripTrailingZeros().hashCode()))
                )
            )
        )
        (when (ß ___xc == (§ class Float) && ___x.equals((float) -0.0))
            (§ return 0) ;; match 0.0f
        )
        (ß ___x.hashCode())
    )

    (defn #_"int" Numbers'hasheq [#_"Number" ___x]
        (let [#_"Class" ___xc (ß ___x.getClass())]
            (when (ß ___xc == (§ class Long))
                (let [#_"long" ___lpart (ß ___x.longValue())]
                    (§ return (Murmur3'hashLong ___lpart))
                )
            )
            (when (ß ___xc == (§ class Double))
                (when (ß ___x.equals(-0.0))
                    (§ return 0) ;; match 0.0
                )
                (§ return (ß ___x.hashCode()))
            )
            (ß hasheqFrom(___x, ___xc))
        )
    )

    (defn #_"Category" Numbers'category [#_"Object" ___x]
        (let [#_"Class" ___xc (ß ___x.getClass())]
            (cond (ß ___xc == (§ class Integer))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Double))
                (do
                    (ß :Category'FLOATING)
                )
                (ß ___xc == (§ class Long))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Float))
                (do
                    (ß :Category'FLOATING)
                )
                (ß ___xc == (§ class BigInt))
                (do
                    (ß :Category'INTEGER)
                )
                (ß ___xc == (§ class Ratio))
                (do
                    (ß :Category'RATIO)
                )
                (ß ___xc == (§ class BigDecimal))
                (do
                    (ß :Category'DECIMAL)
                )
                :else
                (do
                    (ß :Category'INTEGER)
                )
            )
        )
    )

    (defn #_"long" Numbers'bitOpsCast [#_"Object" ___x]
        (let [#_"Class" ___xc (ß ___x.getClass())]
            (when (ß ___xc == (§ class Long) || ___xc == (§ class Integer) || ___xc == (§ class Short) || ___xc == (§ class Byte))
                (§ return (RT'longCast-1o ___x))
            )
            ;; no bignums, no decimals
            (throw (IllegalArgumentException. (str "bit operation not supported for: " ___xc)))
        )
    )

    (defn #_"float[]" Numbers'float_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"float[]" ___ret (float-array ___size)]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"float" ___f (ß ((Number) ___init).floatValue())]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).floatValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"float[]" Numbers'float_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (float-array (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"float[]" ___ret (float-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).floatValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"double[]" Numbers'double_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"double[]" ___ret (double-array ___size)]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"double" ___f (ß ((Number) ___init).doubleValue())]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).doubleValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"double[]" Numbers'double_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (double-array (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"double[]" ___ret (double-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).doubleValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"int[]" Numbers'int_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"int[]" ___ret (int-array ___size)]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"int" ___f (ß ((Number) ___init).intValue())]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).intValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"int[]" Numbers'int_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (int-array (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"int[]" ___ret (int-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).intValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"long[]" Numbers'long_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"long[]" ___ret (long-array ___size)]
            (if (ß ___init instanceof Number)
                (do
                    (let [#_"long" ___f (ß ((Number) ___init).longValue())]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___f)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).longValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"long[]" Numbers'long_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (long-array (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"long[]" ___ret (long-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).longValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"short[]" Numbers'short_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"short[]" ___ret (short-array ___size)]
            (if (ß ___init instanceof Short)
                (do
                    (let [#_"short" ___s (ß (Short) ___init)]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___s)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).shortValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"short[]" Numbers'short_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (short-array (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"short[]" ___ret (short-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).shortValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"char[]" Numbers'char_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"char[]" ___ret (char-array ___size)]
            (if (ß ___init instanceof Character)
                (do
                    (let [#_"char" ___c (ß (Character) ___init)]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___c)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß (Character) ___s.first()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"char[]" Numbers'char_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (char-array (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"char[]" ___ret (char-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß (Character) ___s.first()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"byte[]" Numbers'byte_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"byte[]" ___ret (byte-array ___size)]
            (if (ß ___init instanceof Byte)
                (do
                    (let [#_"byte" ___b (ß (Byte) ___init)]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).byteValue()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"byte[]" Numbers'byte_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (byte-array (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"byte[]" ___ret (byte-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß ((Number) ___s.first()).byteValue()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-2 [#_"int" ___size, #_"Object" ___init]
        (let [#_"boolean[]" ___ret (boolean-array ___size)]
            (if (ß ___init instanceof Boolean)
                (do
                    (let [#_"boolean" ___b (ß (Boolean) ___init)]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___ret.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) ___b)
                        )
                    )
                )
                (do
                    (let [#_"ISeq" ___s (RT'seq ___init)]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß (Boolean)___s.first()))
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"boolean[]" Numbers'boolean_array-1 [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (boolean-array (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"boolean[]" ___ret (boolean-array ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß (Boolean)___s.first()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"boolean[]" Numbers'booleans [#_"Object" ___array]
        (booleans ___array)
    )

    (defn #_"byte[]" Numbers'bytes [#_"Object" ___array]
        (bytes ___array)
    )

    (defn #_"char[]" Numbers'chars [#_"Object" ___array]
        (chars ___array)
    )

    (defn #_"short[]" Numbers'shorts [#_"Object" ___array]
        (shorts ___array)
    )

    (defn #_"float[]" Numbers'floats [#_"Object" ___array]
        (floats ___array)
    )

    (defn #_"double[]" Numbers'doubles [#_"Object" ___array]
        (doubles ___array)
    )

    (defn #_"int[]" Numbers'ints [#_"Object" ___array]
        (ints ___array)
    )

    (defn #_"long[]" Numbers'longs [#_"Object" ___array]
        (longs ___array)
    )

    (defn #_"Number" Numbers'num-1o [#_"Object" ___x]
        (ß (Number) ___x)
    )

    (defn #_"Number" Numbers'num-1f [#_"float" ___x]
        (Float/valueOf ___x)
    )

    (defn #_"Number" Numbers'num-1d [#_"double" ___x]
        (Double/valueOf ___x)
    )

    (defn #_"double" Numbers'add-2dd [#_"double" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2dd [#_"double" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'minus-2dd [#_"double" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2dd [#_"double" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minus-1d [#_"double" ___x]
        (- ___x)
    )

    (defn #_"double" Numbers'minusP-1d [#_"double" ___x]
        (- ___x)
    )

    (defn #_"double" Numbers'inc-1d [#_"double" ___x]
        (inc ___x)
    )

    (defn #_"double" Numbers'incP-1d [#_"double" ___x]
        (inc ___x)
    )

    (defn #_"double" Numbers'dec-1d [#_"double" ___x]
        (dec ___x)
    )

    (defn #_"double" Numbers'decP-1d [#_"double" ___x]
        (dec ___x)
    )

    (defn #_"double" Numbers'multiply-2dd [#_"double" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2dd [#_"double" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'divide-2dd [#_"double" ___x, #_"double" ___y]
        (/ ___x ___y)
    )

    (defn #_"boolean" Numbers'equiv-2dd [#_"double" ___x, #_"double" ___y]
        (ß (___x == ___y))
    )

    (defn #_"boolean" Numbers'lt-2dd [#_"double" ___x, #_"double" ___y]
        (ß (___x < ___y))
    )

    (defn #_"boolean" Numbers'lte-2dd [#_"double" ___x, #_"double" ___y]
        (ß (___x <= ___y))
    )

    (defn #_"boolean" Numbers'gt-2dd [#_"double" ___x, #_"double" ___y]
        (ß (___x > ___y))
    )

    (defn #_"boolean" Numbers'gte-2dd [#_"double" ___x, #_"double" ___y]
        (ß (___x >= ___y))
    )

    (defn #_"boolean" Numbers'isPos-1d [#_"double" ___x]
        (ß (___x > 0))
    )

    (defn #_"boolean" Numbers'isNeg-1d [#_"double" ___x]
        (ß (___x < 0))
    )

    (defn #_"boolean" Numbers'isZero-1d [#_"double" ___x]
        (ß (___x == 0))
    )

    (defn #_"int" Numbers'throwIntOverflow []
        (throw (ArithmeticException. "integer overflow"))
    )

    (defn #_"int" Numbers'unchecked_int_add [#_"int" ___x, #_"int" ___y]
        (+ ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_subtract [#_"int" ___x, #_"int" ___y]
        (- ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_negate [#_"int" ___x]
        (- ___x)
    )

    (defn #_"int" Numbers'unchecked_int_inc [#_"int" ___x]
        (inc ___x)
    )

    (defn #_"int" Numbers'unchecked_int_dec [#_"int" ___x]
        (dec ___x)
    )

    (defn #_"int" Numbers'unchecked_int_multiply [#_"int" ___x, #_"int" ___y]
        (* ___x ___y)
    )

    (defn #_"long" Numbers'not-1o [#_"Object" ___x]
        (ß not(bitOpsCast(___x)))
    )

    (defn #_"long" Numbers'not-1l [#_"long" ___x]
        (ß ~___x)
    )

    (defn #_"long" Numbers'and-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß and(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'and-2ol [#_"Object" ___x, #_"long" ___y]
        (ß and(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'and-2lo [#_"long" ___x, #_"Object" ___y]
        (ß and(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'and-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x & ___y)
    )

    (defn #_"long" Numbers'or-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß or(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'or-2ol [#_"Object" ___x, #_"long" ___y]
        (ß or(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'or-2lo [#_"long" ___x, #_"Object" ___y]
        (ß or(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'or-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x | ___y)
    )

    (defn #_"long" Numbers'xor-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß xor(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'xor-2ol [#_"Object" ___x, #_"long" ___y]
        (ß xor(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'xor-2lo [#_"long" ___x, #_"Object" ___y]
        (ß xor(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'xor-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x :xor ___y)
    )

    (defn #_"long" Numbers'andNot-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß andNot(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'andNot-2ol [#_"Object" ___x, #_"long" ___y]
        (ß andNot(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'andNot-2lo [#_"long" ___x, #_"Object" ___y]
        (ß andNot(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'andNot-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x & ~___y)
    )

    (defn #_"long" Numbers'clearBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß clearBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'clearBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß clearBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'clearBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß clearBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'clearBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x & ~(1 << ___n))
    )

    (defn #_"long" Numbers'setBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß setBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'setBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß setBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'setBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß setBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'setBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x | (1 << ___n))
    )

    (defn #_"long" Numbers'flipBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß flipBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'flipBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß flipBit(bitOpsCast(___x), ___y))
    )

    (defn #_"long" Numbers'flipBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß flipBit(___x, bitOpsCast(___y)))
    )

    (defn #_"long" Numbers'flipBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ___x :xor (1 << ___n))
    )

    (defn #_"boolean" Numbers'testBit-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß testBit(bitOpsCast(___x), bitOpsCast(___y)))
    )

    (defn #_"boolean" Numbers'testBit-2ol [#_"Object" ___x, #_"long" ___y]
        (ß testBit(bitOpsCast(___x), ___y))
    )

    (defn #_"boolean" Numbers'testBit-2lo [#_"long" ___x, #_"Object" ___y]
        (ß testBit(___x, bitOpsCast(___y)))
    )

    (defn #_"boolean" Numbers'testBit-2ll [#_"long" ___x, #_"long" ___n]
        (ß ((___x & (1 << ___n)) != 0))
    )

    (defn #_"int" Numbers'unchecked_int_divide [#_"int" ___x, #_"int" ___y]
        (/ ___x ___y)
    )

    (defn #_"int" Numbers'unchecked_int_remainder [#_"int" ___x, #_"int" ___y]
        (ß ___x % ___y)
    )

    (defn #_"Number" Numbers'num-1l [#_"long" ___x]
        (Long/valueOf ___x)
    )

    (defn #_"long" Numbers'unchecked_add-2ll [#_"long" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_minus-2ll [#_"long" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_multiply-2ll [#_"long" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"long" Numbers'unchecked_minus-1l [#_"long" ___x]
        (- ___x)
    )

    (defn #_"long" Numbers'unchecked_inc-1l [#_"long" ___x]
        (inc ___x)
    )

    (defn #_"long" Numbers'unchecked_dec-1l [#_"long" ___x]
        (dec ___x)
    )

    (defn #_"Number" Numbers'unchecked_add-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß add(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_minus-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß minus(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_multiply-2oo [#_"Object" ___x, #_"Object" ___y]
        (ß multiply(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_minus-1o [#_"Object" ___x]
        (ß minus(___x))
    )

    (defn #_"Number" Numbers'unchecked_inc-1o [#_"Object" ___x]
        (ß inc(___x))
    )

    (defn #_"Number" Numbers'unchecked_dec-1o [#_"Object" ___x]
        (ß dec(___x))
    )

    (defn #_"double" Numbers'unchecked_add-2dd [#_"double" ___x, #_"double" ___y]
        (ß add(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_minus-2dd [#_"double" ___x, #_"double" ___y]
        (ß minus(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_multiply-2dd [#_"double" ___x, #_"double" ___y]
        (ß multiply(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_minus-1d [#_"double" ___x]
        (ß minus(___x))
    )

    (defn #_"double" Numbers'unchecked_inc-1d [#_"double" ___x]
        (ß inc(___x))
    )

    (defn #_"double" Numbers'unchecked_dec-1d [#_"double" ___x]
        (ß dec(___x))
    )

    (defn #_"double" Numbers'unchecked_add-2do [#_"double" ___x, #_"Object" ___y]
        (ß add(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_minus-2do [#_"double" ___x, #_"Object" ___y]
        (ß minus(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_multiply-2do [#_"double" ___x, #_"Object" ___y]
        (ß multiply(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_add-2od [#_"Object" ___x, #_"double" ___y]
        (ß add(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_minus-2od [#_"Object" ___x, #_"double" ___y]
        (ß minus(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_multiply-2od [#_"Object" ___x, #_"double" ___y]
        (ß multiply(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_add-2dl [#_"double" ___x, #_"long" ___y]
        (ß add(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_minus-2dl [#_"double" ___x, #_"long" ___y]
        (ß minus(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_multiply-2dl [#_"double" ___x, #_"long" ___y]
        (ß multiply(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_add-2ld [#_"long" ___x, #_"double" ___y]
        (ß add(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_minus-2ld [#_"long" ___x, #_"double" ___y]
        (ß minus(___x, ___y))
    )

    (defn #_"double" Numbers'unchecked_multiply-2ld [#_"long" ___x, #_"double" ___y]
        (ß multiply(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_add-2lo [#_"long" ___x, #_"Object" ___y]
        (ß add(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_minus-2lo [#_"long" ___x, #_"Object" ___y]
        (ß minus(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_multiply-2lo [#_"long" ___x, #_"Object" ___y]
        (ß multiply(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_add-2ol [#_"Object" ___x, #_"long" ___y]
        (ß add(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_minus-2ol [#_"Object" ___x, #_"long" ___y]
        (ß minus(___x, ___y))
    )

    (defn #_"Number" Numbers'unchecked_multiply-2ol [#_"Object" ___x, #_"long" ___y]
        (ß multiply(___x, ___y))
    )

    (defn #_"Number" Numbers'quotient-2do [#_"double" ___x, #_"Object" ___y]
        (ß quotient((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'quotient-2od [#_"Object" ___x, #_"double" ___y]
        (ß quotient(___x, (Object)___y))
    )

    (defn #_"Number" Numbers'quotient-2lo [#_"long" ___x, #_"Object" ___y]
        (ß quotient((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'quotient-2ol [#_"Object" ___x, #_"long" ___y]
        (ß quotient(___x, (Object)___y))
    )

    (defn #_"double" Numbers'quotient-2dl [#_"double" ___x, #_"long" ___y]
        (ß quotient(___x, (double)___y))
    )

    (defn #_"double" Numbers'quotient-2ld [#_"long" ___x, #_"double" ___y]
        (ß quotient((double)___x, ___y))
    )

    (defn #_"Number" Numbers'remainder-2do [#_"double" ___x, #_"Object" ___y]
        (ß remainder((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'remainder-2od [#_"Object" ___x, #_"double" ___y]
        (ß remainder(___x, (Object)___y))
    )

    (defn #_"Number" Numbers'remainder-2lo [#_"long" ___x, #_"Object" ___y]
        (ß remainder((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'remainder-2ol [#_"Object" ___x, #_"long" ___y]
        (ß remainder(___x, (Object)___y))
    )

    (defn #_"double" Numbers'remainder-2dl [#_"double" ___x, #_"long" ___y]
        (ß remainder(___x, (double)___y))
    )

    (defn #_"double" Numbers'remainder-2ld [#_"long" ___x, #_"double" ___y]
        (ß remainder((double)___x, ___y))
    )

    (defn #_"long" Numbers'add-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (+ ___x ___y)]
            (when (ß (___ret :xor ___x) < 0 && (___ret :xor ___y) < 0)
                (§ return (ß throwIntOverflow()))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'addP-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (+ ___x ___y)]
            (when (ß (___ret :xor ___x) < 0 && (___ret :xor ___y) < 0)
                (§ return (ß addP((Number)___x, (Number)___y)))
            )
            (ß num(___ret))
        )
    )

    (defn #_"long" Numbers'minus-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (- ___x ___y)]
            (when (ß ((___ret :xor ___x) < 0 && (___ret :xor ~___y) < 0))
                (§ return (ß throwIntOverflow()))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'minusP-2ll [#_"long" ___x, #_"long" ___y]
        (let [#_"long" ___ret (- ___x ___y)]
            (when (ß ((___ret :xor ___x) < 0 && (___ret :xor ~___y) < 0))
                (§ return (ß minusP((Number)___x, (Number)___y)))
            )
            (ß num(___ret))
        )
    )

    (defn #_"long" Numbers'minus-1l [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (- ___x)
    )

    (defn #_"Number" Numbers'minusP-1l [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß BigInt'fromBigInteger(BigInteger/valueOf(___x).negate())))
        )
        (ß num(-x))
    )

    (defn #_"long" Numbers'inc-1l [#_"long" ___x]
        (when (ß ___x == Long/MAX_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (inc ___x)
    )

    (defn #_"Number" Numbers'incP-1l [#_"long" ___x]
        (when (ß ___x == Long/MAX_VALUE)
            (§ return (ß Numbers'BIGINT_OPS.inc(___x)))
        )
        (ß num(___x + 1))
    )

    (defn #_"long" Numbers'dec-1l [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß throwIntOverflow()))
        )
        (dec ___x)
    )

    (defn #_"Number" Numbers'decP-1l [#_"long" ___x]
        (when (ß ___x == Long/MIN_VALUE)
            (§ return (ß Numbers'BIGINT_OPS.dec(___x)))
        )
        (ß num(___x - 1))
    )

    (defn #_"long" Numbers'multiply-2ll [#_"long" ___x, #_"long" ___y]
        (when (ß ___x == Long/MIN_VALUE && ___y < 0)
            (§ return (ß throwIntOverflow()))
        )
        (let [#_"long" ___ret (* ___x ___y)]
            (when (ß ___y != 0 && ___ret / ___y != ___x)
                (§ return (ß throwIntOverflow()))
            )
            ___ret
        )
    )

    (defn #_"Number" Numbers'multiplyP-2ll [#_"long" ___x, #_"long" ___y]
        (when (ß ___x == Long/MIN_VALUE && ___y < 0)
            (§ return (ß multiplyP((Number)___x, (Number)___y)))
        )
        (let [#_"long" ___ret (* ___x ___y)]
            (when (ß ___y != 0 && ___ret / ___y != ___x)
                (§ return (ß multiplyP((Number)___x, (Number)___y)))
            )
            (ß num(___ret))
        )
    )

    (defn #_"long" Numbers'quotient-2ll [#_"long" ___x, #_"long" ___y]
        (/ ___x ___y)
    )

    (defn #_"long" Numbers'remainder-2ll [#_"long" ___x, #_"long" ___y]
        (ß ___x % ___y)
    )

    (defn #_"boolean" Numbers'equiv-2ll [#_"long" ___x, #_"long" ___y]
        (ß (___x == ___y))
    )

    (defn #_"boolean" Numbers'lt-2ll [#_"long" ___x, #_"long" ___y]
        (ß (___x < ___y))
    )

    (defn #_"boolean" Numbers'lte-2ll [#_"long" ___x, #_"long" ___y]
        (ß (___x <= ___y))
    )

    (defn #_"boolean" Numbers'gt-2ll [#_"long" ___x, #_"long" ___y]
        (ß (___x > ___y))
    )

    (defn #_"boolean" Numbers'gte-2ll [#_"long" ___x, #_"long" ___y]
        (ß (___x >= ___y))
    )

    (defn #_"boolean" Numbers'isPos-1l [#_"long" ___x]
        (ß (___x > 0))
    )

    (defn #_"boolean" Numbers'isNeg-1l [#_"long" ___x]
        (ß (___x < 0))
    )

    (defn #_"boolean" Numbers'isZero-1l [#_"long" ___x]
        (ß (___x == 0))
    )

    ;; overload resolution

    (defn #_"Number" Numbers'add-2lo [#_"long" ___x, #_"Object" ___y]
        (ß add((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'add-2ol [#_"Object" ___x, #_"long" ___y]
        (ß add(___x, (Object)___y))
    )

    (defn #_"Number" Numbers'addP-2lo [#_"long" ___x, #_"Object" ___y]
        (ß addP((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'addP-2ol [#_"Object" ___x, #_"long" ___y]
        (ß addP(___x, (Object)___y))
    )

    (defn #_"double" Numbers'add-2do [#_"double" ___x, #_"Object" ___y]
        (ß add(___x, ((Number)___y).doubleValue()))
    )

    (defn #_"double" Numbers'add-2od [#_"Object" ___x, #_"double" ___y]
        (ß add(((Number)___x).doubleValue(), ___y))
    )

    (defn #_"double" Numbers'add-2dl [#_"double" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'add-2ld [#_"long" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2do [#_"double" ___x, #_"Object" ___y]
        (ß addP(___x, ((Number)___y).doubleValue()))
    )

    (defn #_"double" Numbers'addP-2od [#_"Object" ___x, #_"double" ___y]
        (ß addP(((Number)___x).doubleValue(), ___y))
    )

    (defn #_"double" Numbers'addP-2dl [#_"double" ___x, #_"long" ___y]
        (+ ___x ___y)
    )

    (defn #_"double" Numbers'addP-2ld [#_"long" ___x, #_"double" ___y]
        (+ ___x ___y)
    )

    (defn #_"Number" Numbers'minus-2lo [#_"long" ___x, #_"Object" ___y]
        (ß minus((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'minus-2ol [#_"Object" ___x, #_"long" ___y]
        (ß minus(___x, (Object)___y))
    )

    (defn #_"Number" Numbers'minusP-2lo [#_"long" ___x, #_"Object" ___y]
        (ß minusP((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'minusP-2ol [#_"Object" ___x, #_"long" ___y]
        (ß minusP(___x, (Object)___y))
    )

    (defn #_"double" Numbers'minus-2do [#_"double" ___x, #_"Object" ___y]
        (ß minus(___x, ((Number)___y).doubleValue()))
    )

    (defn #_"double" Numbers'minus-2od [#_"Object" ___x, #_"double" ___y]
        (ß minus(((Number)___x).doubleValue(), ___y))
    )

    (defn #_"double" Numbers'minus-2dl [#_"double" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minus-2ld [#_"long" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2do [#_"double" ___x, #_"Object" ___y]
        (ß minus(___x, ((Number)___y).doubleValue()))
    )

    (defn #_"double" Numbers'minusP-2od [#_"Object" ___x, #_"double" ___y]
        (ß minus(((Number)___x).doubleValue(), ___y))
    )

    (defn #_"double" Numbers'minusP-2dl [#_"double" ___x, #_"long" ___y]
        (- ___x ___y)
    )

    (defn #_"double" Numbers'minusP-2ld [#_"long" ___x, #_"double" ___y]
        (- ___x ___y)
    )

    (defn #_"Number" Numbers'multiply-2lo [#_"long" ___x, #_"Object" ___y]
        (ß multiply((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'multiply-2ol [#_"Object" ___x, #_"long" ___y]
        (ß multiply(___x, (Object)___y))
    )

    (defn #_"Number" Numbers'multiplyP-2lo [#_"long" ___x, #_"Object" ___y]
        (ß multiplyP((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'multiplyP-2ol [#_"Object" ___x, #_"long" ___y]
        (ß multiplyP(___x, (Object)___y))
    )

    (defn #_"double" Numbers'multiply-2do [#_"double" ___x, #_"Object" ___y]
        (ß multiply(___x, ((Number)___y).doubleValue()))
    )

    (defn #_"double" Numbers'multiply-2od [#_"Object" ___x, #_"double" ___y]
        (ß multiply(((Number)___x).doubleValue(), ___y))
    )

    (defn #_"double" Numbers'multiply-2dl [#_"double" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiply-2ld [#_"long" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2do [#_"double" ___x, #_"Object" ___y]
        (ß multiplyP(___x, ((Number)___y).doubleValue()))
    )

    (defn #_"double" Numbers'multiplyP-2od [#_"Object" ___x, #_"double" ___y]
        (ß multiplyP(((Number)___x).doubleValue(), ___y))
    )

    (defn #_"double" Numbers'multiplyP-2dl [#_"double" ___x, #_"long" ___y]
        (* ___x ___y)
    )

    (defn #_"double" Numbers'multiplyP-2ld [#_"long" ___x, #_"double" ___y]
        (* ___x ___y)
    )

    (defn #_"Number" Numbers'divide-2lo [#_"long" ___x, #_"Object" ___y]
        (ß divide((Object)___x, ___y))
    )

    (defn #_"Number" Numbers'divide-2ol [#_"Object" ___x, #_"long" ___y]
        (ß divide(___x, (Object)___y))
    )

    (defn #_"double" Numbers'divide-2do [#_"double" ___x, #_"Object" ___y]
        (ß ___x / ((Number)___y).doubleValue())
    )

    (defn #_"double" Numbers'divide-2od [#_"Object" ___x, #_"double" ___y]
        (ß ((Number)___x).doubleValue() / ___y)
    )

    (defn #_"double" Numbers'divide-2dl [#_"double" ___x, #_"long" ___y]
        (/ ___x ___y)
    )

    (defn #_"double" Numbers'divide-2ld [#_"long" ___x, #_"double" ___y]
        (/ ___x ___y)
    )

    (defn #_"Number" Numbers'divide-2ll [#_"long" ___x, #_"long" ___y]
        (ß divide((Number)___x, (Number)___y))
    )

    (defn #_"boolean" Numbers'lt-2lo [#_"long" ___x, #_"Object" ___y]
        (ß lt((Object)___x, ___y))
    )

    (defn #_"boolean" Numbers'lt-2ol [#_"Object" ___x, #_"long" ___y]
        (ß lt(___x, (Object)___y))
    )

    (defn #_"boolean" Numbers'lt-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x < ((Number)___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'lt-2od [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() < ___y))
    )

    (defn #_"boolean" Numbers'lt-2dl [#_"double" ___x, #_"long" ___y]
        (ß (___x < ___y))
    )

    (defn #_"boolean" Numbers'lt-2ld [#_"long" ___x, #_"double" ___y]
        (ß (___x < ___y))
    )

    (defn #_"boolean" Numbers'lte-2lo [#_"long" ___x, #_"Object" ___y]
        (ß lte((Object)___x, ___y))
    )

    (defn #_"boolean" Numbers'lte-2ol [#_"Object" ___x, #_"long" ___y]
        (ß lte(___x, (Object)___y))
    )

    (defn #_"boolean" Numbers'lte-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x <= ((Number)___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'lte-2od [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() <= ___y))
    )

    (defn #_"boolean" Numbers'lte-2dl [#_"double" ___x, #_"long" ___y]
        (ß (___x <= ___y))
    )

    (defn #_"boolean" Numbers'lte-2ld [#_"long" ___x, #_"double" ___y]
        (ß (___x <= ___y))
    )

    (defn #_"boolean" Numbers'gt-2lo [#_"long" ___x, #_"Object" ___y]
        (ß gt((Object)___x, ___y))
    )

    (defn #_"boolean" Numbers'gt-2ol [#_"Object" ___x, #_"long" ___y]
        (ß gt(___x, (Object)___y))
    )

    (defn #_"boolean" Numbers'gt-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x > ((Number)___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'gt-2od [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() > ___y))
    )

    (defn #_"boolean" Numbers'gt-2dl [#_"double" ___x, #_"long" ___y]
        (ß (___x > ___y))
    )

    (defn #_"boolean" Numbers'gt-2ld [#_"long" ___x, #_"double" ___y]
        (ß (___x > ___y))
    )

    (defn #_"boolean" Numbers'gte-2lo [#_"long" ___x, #_"Object" ___y]
        (ß gte((Object)___x, ___y))
    )

    (defn #_"boolean" Numbers'gte-2ol [#_"Object" ___x, #_"long" ___y]
        (ß gte(___x, (Object)___y))
    )

    (defn #_"boolean" Numbers'gte-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x >= ((Number)___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'gte-2od [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() >= ___y))
    )

    (defn #_"boolean" Numbers'gte-2dl [#_"double" ___x, #_"long" ___y]
        (ß (___x >= ___y))
    )

    (defn #_"boolean" Numbers'gte-2ld [#_"long" ___x, #_"double" ___y]
        (ß (___x >= ___y))
    )

    (defn #_"boolean" Numbers'equiv-2lo [#_"long" ___x, #_"Object" ___y]
        (ß equiv((Object)___x, ___y))
    )

    (defn #_"boolean" Numbers'equiv-2ol [#_"Object" ___x, #_"long" ___y]
        (ß equiv(___x, (Object)___y))
    )

    (defn #_"boolean" Numbers'equiv-2do [#_"double" ___x, #_"Object" ___y]
        (ß (___x == ((Number)___y).doubleValue()))
    )

    (defn #_"boolean" Numbers'equiv-2od [#_"Object" ___x, #_"double" ___y]
        (ß (((Number)___x).doubleValue() == ___y))
    )

    (defn #_"boolean" Numbers'equiv-2dl [#_"double" ___x, #_"long" ___y]
        (ß (___x == ___y))
    )

    (defn #_"boolean" Numbers'equiv-2ld [#_"long" ___x, #_"double" ___y]
        (ß (___x == ___y))
    )

    (defn #_"boolean" Numbers'isNaN [#_"Object" ___x]
        (ß (___x instanceof Double) && ((Double)___x).isNaN() || (___x instanceof Float) && ((Float)___x).isNaN())
    )

    (defn #_"double" Numbers'max-2dd [#_"double" ___x, #_"double" ___y]
        (Math/max ___x, ___y)
    )

    (defn #_"Object" Numbers'max-2dl [#_"double" ___x, #_"long" ___y]
        (when (Double/isNaN ___x)
            (§ return ___x)
        )
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2do [#_"double" ___x, #_"Object" ___y]
        (cond (Double/isNaN ___x)
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß ___x > ((Number)___y).doubleValue())
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2ld [#_"long" ___x, #_"double" ___y]
        (when (Double/isNaN ___y)
            (§ return ___y)
        )
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"long" Numbers'max-2ll [#_"long" ___x, #_"long" ___y]
        (if (> ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2lo [#_"long" ___x, #_"Object" ___y]
        (when (ß isNaN(___y))
            (§ return ___y)
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2ol [#_"Object" ___x, #_"long" ___y]
        (when (ß isNaN(___x))
            (§ return ___x)
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2od [#_"Object" ___x, #_"double" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (Double/isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (ß ((Number)___x).doubleValue() > ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'max-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß gt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"double" Numbers'min-2dd [#_"double" ___x, #_"double" ___y]
        (Math/min ___x, ___y)
    )

    (defn #_"Object" Numbers'min-2dl [#_"double" ___x, #_"long" ___y]
        (when (Double/isNaN ___x)
            (§ return ___x)
        )
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2do [#_"double" ___x, #_"Object" ___y]
        (cond (Double/isNaN ___x)
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß ___x < ((Number)___y).doubleValue())
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2ld [#_"long" ___x, #_"double" ___y]
        (when (Double/isNaN ___y)
            (§ return ___y)
        )
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"long" Numbers'min-2ll [#_"long" ___x, #_"long" ___y]
        (if (< ___x ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2lo [#_"long" ___x, #_"Object" ___y]
        (when (ß isNaN(___y))
            (§ return ___y)
        )
        (if (ß lt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2ol [#_"Object" ___x, #_"long" ___y]
        (when (ß isNaN(___x))
            (§ return ___x)
        )
        (if (ß lt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2od [#_"Object" ___x, #_"double" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (Double/isNaN ___y)
            (do
                (§ return ___y)
            )
        )
        (if (ß ((Number)___x).doubleValue() < ___y)
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )

    (defn #_"Object" Numbers'min-2oo [#_"Object" ___x, #_"Object" ___y]
        (cond (ß isNaN(___x))
            (do
                (§ return ___x)
            )
            (ß isNaN(___y))
            (do
                (§ return ___y)
            )
        )
        (if (ß lt(___x, ___y))
            (do
                ___x
            )
            (do
                ___y
            )
        )
    )
)
)

(java-ns cloiure.lang.Obj

#_abstract
(class-ns Obj (§ implements IObj)
    (defn- #_"Obj" Obj'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"Obj" Obj'new-1 [#_"IPersistentMap" ___meta]
        (let [this (Obj'init)]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    (defn #_"Obj" Obj'new-0 []
        (let [this (Obj'init)]
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"Obj" this]
        (:_meta this)
    )

    #_abstract
    (§ defn #_"Obj" withMeta [#_"Obj" this, #_"IPersistentMap" ___meta])
)
)

(java-ns cloiure.lang.PersistentArrayMap

(§ import java.util.Arrays)
(§ import java.util.Iterator)
(§ import java.util.Map)
(§ import java.util.NoSuchElementException)

(class-ns MSeq (§ extends ASeq) (§ implements Counted)
    (defn- #_"MSeq" MSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    (defn #_"MSeq" MSeq'new-2 [#_"Object[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new) (MSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    (defn #_"MSeq" MSeq'new-3 [#_"IPersistentMap" ___meta, #_"Object[]" ___array, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (MSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"MSeq" this]
        (ß MapEntry'create((:array this)[(:i this)], (:array this)[(:i this) + 1]))
    )

    #_method
    (§ defn #_"ISeq" next [#_"MSeq" this]
        (when (ß (:i this) + 2 < (:array this).length)
            (§ return (ß MSeq'new-2((:array this), (:i this) + 2)))
        )
        nil
    )

    #_method
    (§ defn #_"int" count [#_"MSeq" this]
        (ß ((:array this).length - (:i this)) / 2)
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"MSeq" this, #_"IPersistentMap" ___meta]
        (MSeq'new-3 ___meta, (:array this), (:i this))
    )
)

(class-ns MIter (§ implements Iterator)
    (defn- #_"MIter" MIter'init []
        (hash-map
            #_"IFn" :f nil
            #_"Object[]" :array nil
            #_"int" :i 0
        )
    )

    ;; for iterator
    (defn #_"MIter" MIter'new-2 [#_"Object[]" ___array, #_"IFn" ___f]
        (MIter'new-3 ___array, -2, ___f)
    )

    ;; for entryAt
    (defn #_"MIter" MIter'new-3 [#_"Object[]" ___array, #_"int" ___i, #_"IFn" ___f]
        (let [this (MIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"MIter" this]
        (ß ((:i this) < (:array this).length - 2))
    )

    #_method
    (§ defn #_"Object" next [#_"MIter" this]
        (try
            (§ ass (:i this) (+ (:i this) 2))
            (ß (:f this).invoke((:array this)[(:i this)], (:array this)[(:i this) + 1]))
            (catch IndexOutOfBoundsException ___e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"MIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransientArrayMap (§ extends ATransientMap)
    (defn- #_"TransientArrayMap" TransientArrayMap'init []
        (hash-map
            #_volatile
            #_"int" :len 0
            #_"Object[]" :array nil
            #_volatile
            #_"Thread" :owner nil
        )
    )

    (defn #_"TransientArrayMap" TransientArrayMap'new [#_"Object[]" ___array]
        (let [this (merge (ATransientMap'new) (TransientArrayMap'init))]
            (§ ass (:owner this) (ß Thread/currentThread()))
            (§ ass (:array this) (make-array Object (ß Math/max(PersistentArrayMap'HASHTABLE_THRESHOLD, ___array.length))))
            (ß System/arraycopy(___array, 0, (:array this), 0, ___array.length))
            (§ ass (:len this) (ß ___array.length))
            this
        )
    )

    #_method
    (§ defn- #_"int" indexOf [#_"TransientArrayMap" this, #_"Object" ___key]
        (loop-when-recur [#_"int" ___i 0] (< ___i (:len this)) [(+ ___i 2)]
            (when (ß equalKey((:array this)[___i], ___key))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"ITransientMap" doAssoc [#_"TransientArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (ß indexOf(___key))]
            (cond (ß ___i >= 0) ;; already have key,
                (do
                    (when (ß (:array this)[___i + 1] != ___val) ;; no change, no op
                        (§ ass (ß (:array this)[___i + 1]) ___val)
                    )
                )
                :else ;; didn't have key, grow
                (do
                    (when (ß (:len this) >= (:array this).length)
                        (§ return (ß PersistentHashMap'create-1a((:array this)).asTransient().assoc(___key, ___val)))
                    )
                    (§ ass (ß (:array this)[(:len this)]) ___key)
                    (§ ass (:len this) (+ (:len this) 1))
                    (§ ass (ß (:array this)[(:len this)]) ___val)
                    (§ ass (:len this) (+ (:len this) 1))
                )
            )
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" doWithout [#_"TransientArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0) ;; have key, will remove
                (when (ß (:len this) >= 2)
                    (§ ass (ß (:array this)[___i]) (ß (:array this)[(:len this) - 2]))
                    (§ ass (ß (:array this)[___i + 1]) (ß (:array this)[(:len this) - 1]))
                )
                (§ ass (:len this) (- (:len this) 2))
            )
            this
        )
    )

    #_method
    (§ defn #_"Object" doValAt [#_"TransientArrayMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0)
                (§ return (ß (:array this)[___i + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"int" doCount [#_"TransientArrayMap" this]
        (/ (:len this) 2)
    )

    #_method
    (§ defn #_"IPersistentMap" doPersistent [#_"TransientArrayMap" this]
        (ß ensureEditable())
        (§ ass (:owner this) nil)
        (let [#_"Object[]" ___a (make-array Object (:len this))]
            (System/arraycopy (:array this), 0, ___a, 0, (:len this))
            (PersistentArrayMap'new-1 ___a)
        )
    )

    #_method
    (§ defn #_"void" ensureEditable [#_"TransientArrayMap" this]
        (when (nil? (:owner this))
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

;;;
 ; Simple implementation of persistent map on an array
 ;
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; Copies array on every change, so only appropriate for _very_small_ maps
 ;
 ; nil keys and values are ok, but you won't be able to distinguish a nil value via valAt - use contains/entryAt
 ;;
(class-ns PersistentArrayMap (§ extends APersistentMap) (§ implements IObj, IEditableCollection, IMapIterable, IKVReduce)
    (§ def #_"PersistentArrayMap" PersistentArrayMap'EMPTY (PersistentArrayMap'new-0))
    (def #_"int" PersistentArrayMap'HASHTABLE_THRESHOLD 16)

    (defn #_"IPersistentMap" PersistentArrayMap'create [#_"Map" ___other]
        (let [#_"ITransientMap" ___ret (ß PersistentArrayMap'EMPTY.asTransient())]
            (doseq [#_"Object" ___o (ß ___other.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            (ß ___ret.persistent())
        )
    )

    (defn- #_"PersistentArrayMap" PersistentArrayMap'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IPersistentMap" :_meta nil
        )
    )

    #_protected
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-0 []
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:array this) (make-array Object 0))
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"PersistentArrayMap" withMeta [#_"PersistentArrayMap" this, #_"IPersistentMap" ___meta]
        (PersistentArrayMap'new-2 ___meta, (:array this))
    )

    #_method
    (§ defn #_"PersistentArrayMap" create [#_"PersistentArrayMap" this, #_"Object..." ___init]
        (ß PersistentArrayMap'new-2(meta(), ___init))
    )

    #_method
    (§ defn #_"IPersistentMap" createHT [#_"PersistentArrayMap" this, #_"Object[]" ___init]
        (ß PersistentHashMap'create-2(meta(), ___init))
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createWithCheck [#_"Object[]" ___init]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
            (loop-when-recur [#_"int" ___j (+ ___i 2)] (ß ___j < ___init.length) [(+ ___j 2)]
                (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                    (throw (IllegalArgumentException. (str "Duplicate key: " (ß ___init[___i]))))
                )
            )
        )
        (PersistentArrayMap'new-1 ___init)
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'createAsIfByAssoc [#_"Object[]" ___init]
        (when (ß (___init.length & 1) == 1)
            (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (§ array (ß ___init[___init.length - 1])))))
        )
        ;; If this looks like it is doing busy-work, it is because it
        ;; is achieving these goals: O(n^2) run time like
        ;; createWithCheck(), never modify init arg, and only
        ;; allocate memory if there are duplicate keys.
        (let [#_"int" ___n 0]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
                (let [#_"boolean" ___duplicateKey false]
                    (loop-when-recur [#_"int" ___j 0] (< ___j ___i) [(+ ___j 2)]
                        (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                            (§ ass ___duplicateKey true)
                            (§ break )
                        )
                    )
                    (when (ß !___duplicateKey)
                        (§ ass ___n (+ ___n 2))
                    )
                )
            )
            (when (ß ___n < ___init.length)
                ;; Create a new shorter array with unique keys, and
                ;; the last value associated with each key. To behave
                ;; like assoc, the first occurrence of each key must
                ;; be used, since its metadata may be different than
                ;; later equal keys.
                (let [#_"Object[]" ___nodups (make-array Object ___n)]
                    (let [#_"int" ___m 0]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
                            (let [#_"boolean" ___duplicateKey false]
                                (loop-when-recur [#_"int" ___j 0] (< ___j ___m) [(+ ___j 2)]
                                    (when (ß PersistentArrayMap'equalKey(___init[___i], ___nodups[___j]))
                                        (§ ass ___duplicateKey true)
                                        (§ break )
                                    )
                                )
                                (when (ß !___duplicateKey)
                                    (§ let [#_"int" ___j]
                                        (loop-when-recur [___j (ß ___init.length - 2)] (ß ___j >= ___i) [(- ___j 2)]
                                            (when (ß PersistentArrayMap'equalKey(___init[___i], ___init[___j]))
                                                (§ break )
                                            )
                                        )
                                        (§ ass (ß ___nodups[___m]) (ß ___init[___i]))
                                        (§ ass (ß ___nodups[___m + 1]) (ß ___init[___j + 1]))
                                        (§ ass ___m (+ ___m 2))
                                    )
                                )
                            )
                        )
                        (when (ß ___m != ___n)
                            (throw (IllegalArgumentException. (str "Internal error: m=" ___m)))
                        )
                        (§ ass ___init ___nodups)
                    )
                )
            )
            (PersistentArrayMap'new-1 ___init)
        )
    )

    ;;;
     ; This ctor captures/aliases the passed array, so do not modify later
     ;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentArrayMap" PersistentArrayMap'new-1 [#_"Object[]" ___init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:array this) ___init)
            (§ ass (:_meta this) nil)
            this
        )
    )

    (defn #_"PersistentArrayMap" PersistentArrayMap'new-2 [#_"IPersistentMap" ___meta, #_"Object[]" ___init]
        (let [this (merge (APersistentMap'new) (PersistentArrayMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:array this) ___init)
            this
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentArrayMap" this]
        (ß (:array this).length / 2)
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentArrayMap" this, #_"Object" ___key]
        (ß (indexOf(___key) >= 0))
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0)
                (§ return (ß (IMapEntry) MapEntry'create((:array this)[___i], (:array this)[___i + 1])))
            )
            nil
        )
    )

    #_method
    (§ defn #_"IPersistentMap" assocEx [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (ß indexOf(___key))]
            (§ let [#_"Object[]" ___newArray]
                (cond (ß ___i >= 0)
                    (do
                        (throw (Util'runtimeException-1 "Key already present"))
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß (:array this).length > PersistentArrayMap'HASHTABLE_THRESHOLD)
                            (§ return (ß createHT((:array this)).assocEx(___key, ___val)))
                        )
                        (§ ass ___newArray (make-array Object (ß (:array this).length + 2)))
                        (when (ß (:array this).length > 0)
                            (ß System/arraycopy((:array this), 0, ___newArray, 2, (:array this).length))
                        )
                        (§ ass (ß ___newArray[0]) ___key)
                        (§ ass (ß ___newArray[1]) ___val)
                    )
                )
                (ß create(___newArray))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" assoc [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___i (ß indexOf(___key))]
            (§ let [#_"Object[]" ___newArray]
                (cond (ß ___i >= 0) ;; already have key, same-sized replacement
                    (do
                        (when (ß (:array this)[___i + 1] == ___val) ;; no change, no op
                            (§ return this)
                        )
                        (§ ass ___newArray (ß (:array this).clone()))
                        (§ ass (ß ___newArray[___i + 1]) ___val)
                    )
                    :else ;; didn't have key, grow
                    (do
                        (when (ß (:array this).length > PersistentArrayMap'HASHTABLE_THRESHOLD)
                            (§ return (ß createHT((:array this)).assoc(___key, ___val)))
                        )
                        (§ ass ___newArray (make-array Object (ß (:array this).length + 2)))
                        (when (ß (:array this).length > 0)
                            (ß System/arraycopy((:array this), 0, ___newArray, 0, (:array this).length))
                        )
                        (§ ass (ß ___newArray[___newArray.length - 2]) ___key)
                        (§ ass (ß ___newArray[___newArray.length - 1]) ___val)
                    )
                )
                (ß create(___newArray))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentMap" without [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0) ;; have key, will remove
                (let [#_"int" ___newlen (ß (:array this).length - 2)]
                    (when (ß ___newlen == 0)
                        (§ return (ß empty()))
                    )
                    (let [#_"Object[]" ___newArray (make-array Object ___newlen)]
                        (System/arraycopy (:array this), 0, ___newArray, 0, ___i)
                        (ß System/arraycopy((:array this), ___i + 2, ___newArray, ___i, ___newlen - ___i))
                        (§ return (ß create(___newArray)))
                    )
                )
            )
            ;; don't have key, no op
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" empty [#_"PersistentArrayMap" this]
        (ß (IPersistentMap) PersistentArrayMap'EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentArrayMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___i (ß indexOf(___key))]
            (when (ß ___i >= 0)
                (§ return (ß (:array this)[___i + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentArrayMap" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"int" capacity [#_"PersistentArrayMap" this]
        (ß count())
    )

    #_method
    (§ defn- #_"int" indexOfObject [#_"PersistentArrayMap" this, #_"Object" ___key]
        (let [#_"EquivPred" ___ep (Util'equivPred ___key)]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:array this).length) [(+ ___i 2)]
                (when (ß ___ep.equiv(___key, (:array this)[___i]))
                    (§ return ___i)
                )
            )
            -1
        )
    )

    #_method
    (§ defn- #_"int" indexOf [#_"PersistentArrayMap" this, #_"Object" ___key]
        (if (ß ___key instanceof Keyword)
            (do
                (loop-when-recur [#_"int" ___i 0] (ß ___i < (:array this).length) [(+ ___i 2)]
                    (when (ß ___key == (:array this)[___i])
                        (§ return ___i)
                    )
                )
                -1
            )
            (do
                (ß indexOfObject(___key))
            )
        )
    )

    (defn #_"boolean" PersistentArrayMap'equalKey [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 instanceof Keyword)
            (§ return (ß (___k1 == ___k2)))
        )
        (Util'equiv-2oo ___k1, ___k2)
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_ENTRY)
    )

    #_method
    (§ defn #_"Iterator" keyIterator [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_KEY)
    )

    #_method
    (§ defn #_"Iterator" valIterator [#_"PersistentArrayMap" this]
        (MIter'new-2 (:array this), APersistentMap'MAKE_VAL)
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentArrayMap" this]
        (when (ß (:array this).length > 0)
            (§ return (MSeq'new-2 (:array this), 0))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentArrayMap" this]
        (:_meta this)
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentArrayMap" this, #_"IFn" ___f, #_"Object" ___init]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:array this).length) [(+ ___i 2)]
            (§ ass ___init (ß ___f.invoke(___init, (:array this)[___i], (:array this)[___i + 1])))
            (when (RT'isReduced ___init)
                (§ return (ß ((IDeref)___init).deref()))
            )
        )
        ___init
    )

    #_method
    (§ defn #_"ITransientMap" asTransient [#_"PersistentArrayMap" this]
        (TransientArrayMap'new (:array this))
    )
)
)

(java-ns cloiure.lang.PersistentHashMap

(§ import java.util.*)
(§ import java.util.concurrent.Callable)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns TransientHashMap (§ extends ATransientMap)
    (defn- #_"TransientHashMap" TransientHashMap'init []
        (hash-map
            #_"AtomicReference<Thread>" :edit nil
            #_volatile
            #_"INode" :root nil
            #_volatile
            #_"int" :count 0
            #_volatile
            #_"boolean" :hasNull false
            #_volatile
            #_"Object" :nullValue nil
            #_"Box" :leafFlag (Box'new nil)
        )
    )

    (defn #_"TransientHashMap" TransientHashMap'new-1 [#_"PersistentHashMap" ___m]
        (TransientHashMap'new-5 (§ pars new AtomicReference<Thread>(Thread/currentThread()), (:root ___m), (:count ___m), (:hasNull ___m), (:nullValue ___m)))
    )

    (defn #_"TransientHashMap" TransientHashMap'new-5 [#_"AtomicReference<Thread>" ___edit, #_"INode" ___root, #_"int" ___count, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (ATransientMap'new) (TransientHashMap'init))]
            (§ ass (:edit this) ___edit)
            (§ ass (:root this) ___root)
            (§ ass (:count this) ___count)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" doAssoc [#_"TransientHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___key)
            (when (ß (:nullValue this) != ___val)
                (§ ass (:nullValue this) ___val)
            )
            (when (ß !this.hasNull)
                (§ ass (:count this) (ß (:count this) + 1))
                (§ ass (:hasNull this) true)
            )
            (§ return this)
        )
        (§ ass (ß (:leafFlag this).val) nil)
        (let [#_"INode" ___n (ß (((:root this) == nil) ? BitmapIndexedNode'EMPTY :or (:root this)).assoc((:edit this), 0, hash(___key), ___key, ___val, (:leafFlag this)))]
            (when (ß ___n != (:root this))
                (§ ass (:root this) ___n)
            )
            (when (ß (:leafFlag this).val != nil)
                (§ ass (:count this) (ß (:count this) + 1))
            )
            this
        )
    )

    #_method
    (§ defn #_"ITransientMap" doWithout [#_"TransientHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (when (ß !this.hasNull)
                (§ return this)
            )
            (§ ass (:hasNull this) false)
            (§ ass (:nullValue this) nil)
            (§ ass (:count this) (ß (:count this) - 1))
            (§ return this)
        )
        (when (nil? (:root this))
            (§ return this)
        )
        (§ ass (ß (:leafFlag this).val) nil)
        (let [#_"INode" ___n (ß (:root this).without((:edit this), 0, hash(___key), ___key, (:leafFlag this)))]
            (when (ß ___n != (:root this))
                (§ ass (:root this) ___n)
            )
            (when (ß (:leafFlag this).val != nil)
                (§ ass (:count this) (ß (:count this) - 1))
            )
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" doPersistent [#_"TransientHashMap" this]
        (ß (:edit this).set(nil))
        (PersistentHashMap'new-4 (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_method
    (§ defn #_"Object" doValAt [#_"TransientHashMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (nil? ___key)
            (if (:hasNull this)
                (do
                    (§ return (:nullValue this))
                )
                (do
                    (§ return ___notFound)
                )
            )
        )
        (when (nil? (:root this))
            (§ return ___notFound)
        )
        (ß (:root this).find(0, hash(___key), ___key, ___notFound))
    )

    #_method
    (§ defn #_"int" doCount [#_"TransientHashMap" this]
        (:count this)
    )

    #_method
    (§ defn #_"void" ensureEditable [#_"TransientHashMap" this]
        (when (ß (:edit this).get() == nil)
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )
)

(defprotocol INode
    #_abstract
    (#_"INode" INode'''assoc6 [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf])
    #_abstract
    (#_"INode" INode'''without4 [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key])
    #_abstract
    (#_"IMapEntry" INode'''find4 [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key])
    #_abstract
    (#_"Object" INode'''find5 [#_"INode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound])
    #_abstract
    (#_"ISeq" INode'''nodeSeq [#_"INode" this])
    #_abstract
    (#_"INode" INode'''assoc7 [#_"INode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf])
    #_abstract
    (#_"INode" INode'''without6 [#_"INode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf])
    #_abstract
    (#_"Object" INode'''kvreduce [#_"INode" this, #_"IFn" ___f, #_"Object" ___init])
    #_abstract
    (#_"Object" INode'''fold [#_"INode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin])
    ;; returns the result of (f [k v]) for each iterated element
    #_abstract
    (#_"Iterator" INode'''iterator [#_"INode" this, #_"IFn" ___f])
)

(class-ns HSeq (§ extends ASeq)
    (defn #_"ISeq" HSeq'create-1 [#_"INode[]" ___nodes]
        (HSeq'create-4 nil, ___nodes, 0, nil)
    )

    (defn- #_"ISeq" HSeq'create-4 [#_"IPersistentMap" ___meta, #_"INode[]" ___nodes, #_"int" ___i, #_"ISeq" ___s]
        (when (some? ___s)
            (§ return (HSeq'new ___meta, ___nodes, ___i, ___s))
        )
        (loop-when-recur [#_"int" ___j ___i] (ß ___j < ___nodes.length) [(inc ___j)]
            (when (ß ___nodes[___j] != nil)
                (let [#_"ISeq" ___ns (ß ___nodes[___j].nodeSeq())]
                    (when (some? ___ns)
                        (§ return (ß HSeq'new(___meta, ___nodes, ___j + 1, ___ns)))
                    )
                )
            )
        )
        nil
    )

    (defn- #_"HSeq" HSeq'init []
        (hash-map
            #_"INode[]" :nodes nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn- #_"HSeq" HSeq'new [#_"IPersistentMap" ___meta, #_"INode[]" ___nodes, #_"int" ___i, #_"ISeq" ___s]
        (let [this (merge (ASeq'new ___meta) (HSeq'init))]
            (§ ass (:nodes this) ___nodes)
            (§ ass (:i this) ___i)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"HSeq" this, #_"IPersistentMap" ___meta]
        (HSeq'new ___meta, (:nodes this), (:i this), (:s this))
    )

    #_method
    (§ defn #_"Object" first [#_"HSeq" this]
        (ß (:s this).first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"HSeq" this]
        (ß HSeq'create-4(nil, (:nodes this), (:i this), (:s this).next()))
    )
)

(class-ns HIter (§ implements Iterator)
    (defn- #_"HIter" HIter'init []
        (hash-map
            #_"INode[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Iterator" :nestedIter nil
        )
    )

    (defn- #_"HIter" HIter'new [#_"INode[]" ___array, #_"IFn" ___f]
        (let [this (HIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"HIter" this]
        (while true
            (when (some? (:nestedIter this))
                (if (ß (:nestedIter this).hasNext())
                    (do
                        (§ return true)
                    )
                    (do
                        (§ ass (:nestedIter this) nil)
                    )
                )
            )

            (if (ß (:i this) < (:array this).length)
                (do
                    (let [#_"INode" ___node (ß (:array this)[(:i this)])]
                        (§ ass (:i this) (+ (:i this) 1))
                        (when (some? ___node)
                            (§ ass (:nestedIter this) (ß ___node.iterator((:f this))))
                        )
                    )
                )
                (do
                    (§ return false)
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" next [#_"HIter" this]
        (if (ß hasNext())
            (do
                (ß (:nestedIter this).next())
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"HIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ArrayNode (§ implements INode)
    (defn- #_"ArrayNode" ArrayNode'init []
        (hash-map
            #_"int" :count 0
            #_"INode[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"ArrayNode" ArrayNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___count, #_"INode[]" ___array]
        (let [this (ArrayNode'init)]
            (§ ass (:array this) ___array)
            (§ ass (:edit this) ___edit)
            (§ ass (:count this) ___count)
            this
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return (ß ArrayNode'new(nil, (:count this) + 1, cloneAndSet((:array this), ___idx, BitmapIndexedNode'EMPTY.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))))
                )
                (let [#_"INode" ___n (ß ___node.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (ß ArrayNode'new(nil, (:count this), cloneAndSet((:array this), ___idx, ___n)))
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" without [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return this)
                )
                (let [#_"INode" ___n (ß ___node.without(___shift + 5, ___hash, ___key))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (if (nil? ___n)
                        (do
                            (when (ß (:count this) <= 8) ;; shrink
                                (§ return (ß pack(nil, ___idx)))
                            )
                            (ß ArrayNode'new(nil, (:count this) - 1, cloneAndSet((:array this), ___idx, ___n)))
                        )
                        (do
                            (ß ArrayNode'new(nil, (:count this), cloneAndSet((:array this), ___idx, ___n)))
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" find [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return nil)
                )
                (ß ___node.find(___shift + 5, ___hash, ___key))
            )
        )
    )

    #_method
    (§ defn #_"Object" find [#_"ArrayNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return ___notFound)
                )
                (ß ___node.find(___shift + 5, ___hash, ___key, ___notFound))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" nodeSeq [#_"ArrayNode" this]
        (HSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"ArrayNode" this, #_"IFn" ___f]
        (HIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"ArrayNode" this, #_"IFn" ___f, #_"Object" ___init]
        (doseq [#_"INode" ___node (:array this)]
            (when (some? ___node)
                (§ ass ___init (ß ___node.kvreduce(___f, ___init)))
                (when (RT'isReduced ___init)
                    (§ return ___init)
                )
            )
        )
        ___init
    )

    #_method
    (§ defn #_"Object" fold [#_"ArrayNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (let [#_"List<Callable>" ___tasks (ArrayList.)]
            (doseq [#_"INode" ___node (:array this)]
                (when (some? ___node)
                    (ß ___tasks.add(
                            (§ reify Callable()
                                #_method
                                (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                                    (ß ___node.fold(___combinef, ___reducef, ___fjtask, ___fjfork, ___fjjoin))
                                )
                            )
                        )
                    )
                )
            )

            (ArrayNode'foldTasks ___tasks, ___combinef, ___fjtask, ___fjfork, ___fjjoin)
        )
    )

    (defn #_"Object" ArrayNode'foldTasks [#_"List<Callable>" ___tasks, #_"IFn" ___combinef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (when (ß ___tasks.isEmpty())
            (§ return (ß ___combinef.invoke()))
        )

        (when (ß ___tasks.size() == 1)
            (let [#_"Object" ___ret nil]
                (try
                    (§ return (ß ___tasks.get(0).call()))
                    (catch Exception ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
        )

        (let [#_"List<Callable>" ___t1 (ß ___tasks.subList(0, ___tasks.size() / 2))]
            (let [#_"List<Callable>" ___t2 (ß ___tasks.subList(___tasks.size() / 2, ___tasks.size()))]
                (let [#_"Object" ___forked
                        (ß ___fjfork.invoke(___fjtask.invoke(
                                (§ reify Callable()
                                    #_method
                                    (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                                        (ArrayNode'foldTasks ___t2, ___combinef, ___fjtask, ___fjfork, ___fjjoin)
                                    )
                                )
                            ))
                        )]
                    (ß ___combinef.invoke(ArrayNode'foldTasks(___t1, ___combinef, ___fjtask, ___fjfork, ___fjjoin), ___fjjoin.invoke(___forked)))
                )
            )
        )
    )

    #_method
    (§ defn- #_"ArrayNode" ensureEditable [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (ß ArrayNode'new(___edit, (:count this), (:array this).clone()))
    )

    #_method
    (§ defn- #_"ArrayNode" editAndSet [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"INode" ___n]
        (let [#_"ArrayNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß (:array ___editable)[___i]) ___n)
            ___editable
        )
    )

    #_method
    (§ defn- #_"INode" pack [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___idx]
        (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) - 1)))]
            (let [#_"int" ___j 1]
                (let [#_"int" ___bitmap 0]
                    (loop-when-recur [#_"int" ___i 0] (< ___i ___idx) [(inc ___i)]
                        (when (ß (:array this)[___i] != nil)
                            (§ ass (ß ___newArray[___j]) (ß (:array this)[___i]))
                            (§ ass ___bitmap (ß ___bitmap | (1 << ___i)))
                            (§ ass ___j (+ ___j 2))
                        )
                    )
                    (loop-when-recur [#_"int" ___i (inc ___idx)] (ß ___i < (:array this).length) [(inc ___i)]
                        (when (ß (:array this)[___i] != nil)
                            (§ ass (ß ___newArray[___j]) (ß (:array this)[___i]))
                            (§ ass ___bitmap (ß ___bitmap | (1 << ___i)))
                            (§ ass ___j (+ ___j 2))
                        )
                    )
                    (BitmapIndexedNode'new ___edit, ___bitmap, ___newArray)
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (let [#_"ArrayNode" ___editable (ß editAndSet(___edit, ___idx, BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))]
                        (§ ass (:count ___editable) (ß (:count ___editable) + 1))
                        (§ return ___editable)
                    )
                )
                (let [#_"INode" ___n (ß ___node.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (ß editAndSet(___edit, ___idx, ___n))
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" without [#_"ArrayNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___idx (ß mask(___hash, ___shift))]
            (let [#_"INode" ___node (ß (:array this)[___idx])]
                (when (nil? ___node)
                    (§ return this)
                )
                (let [#_"INode" ___n (ß ___node.without(___edit, ___shift + 5, ___hash, ___key, ___removedLeaf))]
                    (when (ß ___n == ___node)
                        (§ return this)
                    )
                    (when (nil? ___n)
                        (when (ß (:count this) <= 8) ;; shrink
                            (§ return (ß pack(___edit, ___idx)))
                        )
                        (let [#_"ArrayNode" ___editable (ß editAndSet(___edit, ___idx, ___n))]
                            (§ ass (:count ___editable) (ß (:count ___editable) - 1))
                            (§ return ___editable)
                        )
                    )
                    (ß editAndSet(___edit, ___idx, ___n))
                )
            )
        )
    )
)

(class-ns BitmapIndexedNode (§ implements INode)
    (def #_"BitmapIndexedNode" BitmapIndexedNode'EMPTY (ß BitmapIndexedNode'new(nil, 0, new Object[0])))

    (defn- #_"BitmapIndexedNode" BitmapIndexedNode'init []
        (hash-map
            #_"int" :bitmap 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"BitmapIndexedNode" BitmapIndexedNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___bitmap, #_"Object[]" ___array]
        (let [this (BitmapIndexedNode'init)]
            (§ ass (:bitmap this) ___bitmap)
            (§ ass (:array this) ___array)
            (§ ass (:edit this) ___edit)
            this
        )
    )

    #_method
    (§ defn #_"int" index [#_"BitmapIndexedNode" this, #_"int" ___bit]
        (ß Integer/bitCount((:bitmap this) & (___bit - 1)))
    )

    #_method
    (§ defn #_"INode" assoc [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (let [#_"int" ___idx (ß index(___bit))]
                (if (ß ((:bitmap this) & ___bit) != 0)
                    (do
                        (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                            (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                                (when (nil? ___keyOrNull)
                                    (let [#_"INode" ___n (ß ((INode) ___valOrNode).assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                                        (when (ß ___n == ___valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___n))))
                                    )
                                )
                                (when (Util'equiv-2oo ___key, ___keyOrNull)
                                    (when (ß ___val == ___valOrNode)
                                        (§ return this)
                                    )
                                    (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___val))))
                                )
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx, nil, 2 * ___idx + 1, createNode(___shift + 5, ___keyOrNull, ___valOrNode, ___hash, ___key, ___val))))
                            )
                        )
                    )
                    (do
                        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
                            (if (ß ___n >= 16)
                                (do
                                    (let [#_"INode[]" ___nodes (§ typeless make-array INode 32)]
                                        (let [#_"int" ___jdx (ß mask(___hash, ___shift))]
                                            (§ ass (ß ___nodes[___jdx]) (ß BitmapIndexedNode'EMPTY.assoc(___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))
                                            (let [#_"int" ___j 0]
                                                (loop-when-recur [#_"int" ___i 0] (< ___i 32) [(inc ___i)]
                                                    (when (ß (((:bitmap this) >>> ___i) & 1) != 0)
                                                        (if (ß (:array this)[___j] == nil)
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß (INode) (:array this)[___j + 1]))
                                                            )
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß BitmapIndexedNode'EMPTY.assoc(___shift + 5, hash((:array this)[___j]), (:array this)[___j], (:array this)[___j + 1], ___addedLeaf)))
                                                            )
                                                        )
                                                        (§ ass ___j (+ ___j 2))
                                                    )
                                                )
                                                (ß ArrayNode'new(nil, ___n + 1, ___nodes))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Object[]" ___newArray (make-array Object (ß 2 * (___n + 1)))]
                                        (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * ___idx))
                                        (§ ass (ß ___newArray[2 * ___idx]) ___key)
                                        (§ ass (:val ___addedLeaf) ___addedLeaf)
                                        (§ ass (ß ___newArray[2 * ___idx + 1]) ___val)
                                        (ß System/arraycopy((:array this), 2 * ___idx, ___newArray, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                        (ß BitmapIndexedNode'new(nil, (:bitmap this) | ___bit, ___newArray))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" without [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß ((:bitmap this) & ___bit) == 0)
                (§ return this)
            )
            (let [#_"int" ___idx (ß index(___bit))]
                (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (let [#_"INode" ___n (ß ((INode) ___valOrNode).without(___shift + 5, ___hash, ___key))]
                                (when (ß ___n == ___valOrNode)
                                    (§ return this)
                                )
                                (when (some? ___n)
                                    (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this), cloneAndSet((:array this), 2 * ___idx + 1, ___n))))
                                )
                                (when (ß (:bitmap this) == ___bit)
                                    (§ return nil)
                                )
                                (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this) :xor ___bit, removePair((:array this), ___idx))))
                            )
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            ;; TODO: collapse
                            (§ return (ß BitmapIndexedNode'new(nil, (:bitmap this) :xor ___bit, removePair((:array this), ___idx))))
                        )
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"IMapEntry" find [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß ((:bitmap this) & ___bit) == 0)
                (§ return nil)
            )
            (let [#_"int" ___idx (ß index(___bit))]
                (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (§ return (ß ((INode) ___valOrNode).find(___shift + 5, ___hash, ___key)))
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ return (ß (IMapEntry) MapEntry'create(___keyOrNull, ___valOrNode)))
                        )
                        nil
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" find [#_"BitmapIndexedNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß ((:bitmap this) & ___bit) == 0)
                (§ return ___notFound)
            )
            (let [#_"int" ___idx (ß index(___bit))]
                (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (§ return (ß ((INode) ___valOrNode).find(___shift + 5, ___hash, ___key, ___notFound)))
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ return ___valOrNode)
                        )
                        ___notFound
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" nodeSeq [#_"BitmapIndexedNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"BitmapIndexedNode" this, #_"IFn" ___f]
        (NodeIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"BitmapIndexedNode" this, #_"IFn" ___f, #_"Object" ___init]
        (NodeSeq'kvreduce (:array this), ___f, ___init)
    )

    #_method
    (§ defn #_"Object" fold [#_"BitmapIndexedNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (ß NodeSeq'kvreduce((:array this), ___reducef, ___combinef.invoke()))
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" ensureEditable [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
            (let [#_"Object[]" ___newArray (make-array Object (ß (___n >= 0) ? 2 * (___n + 1) :or 4))] ;; make room for next assoc
                (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * ___n))
                (BitmapIndexedNode'new ___edit, (:bitmap this), ___newArray)
            )
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" editAndSet [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a]
        (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß (:array ___editable)[___i]) ___a)
            ___editable
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" editAndSet [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß (:array ___editable)[___i]) ___a)
            (§ ass (ß (:array ___editable)[___j]) ___b)
            ___editable
        )
    )

    #_method
    (§ defn- #_"BitmapIndexedNode" editAndRemovePair [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___bit, #_"int" ___i]
        (when (ß (:bitmap this) == ___bit)
            (§ return nil)
        )
        (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) :xor ___bit))
            (ß System/arraycopy((:array ___editable), 2 * (___i + 1), (:array ___editable), 2 * ___i, (:array ___editable).length - 2 * (___i + 1)))
            (§ ass (ß (:array ___editable)[(:array ___editable).length - 2]) nil)
            (§ ass (ß (:array ___editable)[(:array ___editable).length - 1]) nil)
            ___editable
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (let [#_"int" ___idx (ß index(___bit))]
                (if (ß ((:bitmap this) & ___bit) != 0)
                    (do
                        (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                            (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                                (when (nil? ___keyOrNull)
                                    (let [#_"INode" ___n (ß ((INode) ___valOrNode).assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf))]
                                        (when (ß ___n == ___valOrNode)
                                            (§ return this)
                                        )
                                        (§ return (ß editAndSet(___edit, 2 * ___idx + 1, ___n)))
                                    )
                                )
                                (when (Util'equiv-2oo ___key, ___keyOrNull)
                                    (when (ß ___val == ___valOrNode)
                                        (§ return this)
                                    )
                                    (§ return (ß editAndSet(___edit, 2 * ___idx + 1, ___val)))
                                )
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (ß editAndSet(___edit, 2 * ___idx, nil, 2 * ___idx + 1, createNode(___edit, ___shift + 5, ___keyOrNull, ___valOrNode, ___hash, ___key, ___val)))
                            )
                        )
                    )
                    (do
                        (let [#_"int" ___n (Integer/bitCount (:bitmap this))]
                            (when (ß ___n * 2 < (:array this).length)
                                (§ ass (:val ___addedLeaf) ___addedLeaf)
                                (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
                                    (ß System/arraycopy((:array ___editable), 2 * ___idx, (:array ___editable), 2 * (___idx + 1), 2 * (___n - ___idx)))
                                    (§ ass (ß (:array ___editable)[2 * ___idx]) ___key)
                                    (§ ass (ß (:array ___editable)[2 * ___idx + 1]) ___val)
                                    (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) | ___bit))
                                    (§ return ___editable)
                                )
                            )
                            (if (ß ___n >= 16)
                                (do
                                    (let [#_"INode[]" ___nodes (§ typeless make-array INode 32)]
                                        (let [#_"int" ___jdx (ß mask(___hash, ___shift))]
                                            (§ ass (ß ___nodes[___jdx]) (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, ___hash, ___key, ___val, ___addedLeaf)))
                                            (let [#_"int" ___j 0]
                                                (loop-when-recur [#_"int" ___i 0] (< ___i 32) [(inc ___i)]
                                                    (when (ß (((:bitmap this) >>> ___i) & 1) != 0)
                                                        (if (ß (:array this)[___j] == nil)
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß (INode) (:array this)[___j + 1]))
                                                            )
                                                            (do
                                                                (§ ass (ß ___nodes[___i]) (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift + 5, hash((:array this)[___j]), (:array this)[___j], (:array this)[___j + 1], ___addedLeaf)))
                                                            )
                                                        )
                                                        (§ ass ___j (+ ___j 2))
                                                    )
                                                )
                                                (ß ArrayNode'new(___edit, ___n + 1, ___nodes))
                                            )
                                        )
                                    )
                                )
                                (do
                                    (let [#_"Object[]" ___newArray (make-array Object (ß 2 * (___n + 4)))]
                                        (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * ___idx))
                                        (§ ass (ß ___newArray[2 * ___idx]) ___key)
                                        (§ ass (:val ___addedLeaf) ___addedLeaf)
                                        (§ ass (ß ___newArray[2 * ___idx + 1]) ___val)
                                        (ß System/arraycopy((:array this), 2 * ___idx, ___newArray, 2 * (___idx + 1), 2 * (___n - ___idx)))
                                        (let [#_"BitmapIndexedNode" ___editable (ß ensureEditable(___edit))]
                                            (§ ass (:array ___editable) ___newArray)
                                            (§ ass (:bitmap ___editable) (ß (:bitmap ___editable) | ___bit))
                                            ___editable
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"INode" without [#_"BitmapIndexedNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___bit (ß bitpos(___hash, ___shift))]
            (when (ß ((:bitmap this) & ___bit) == 0)
                (§ return this)
            )
            (let [#_"int" ___idx (ß index(___bit))]
                (let [#_"Object" ___keyOrNull (ß (:array this)[2 * ___idx])]
                    (let [#_"Object" ___valOrNode (ß (:array this)[2 * ___idx + 1])]
                        (when (nil? ___keyOrNull)
                            (let [#_"INode" ___n (ß ((INode) ___valOrNode).without(___edit, ___shift + 5, ___hash, ___key, ___removedLeaf))]
                                (when (ß ___n == ___valOrNode)
                                    (§ return this)
                                )
                                (when (some? ___n)
                                    (§ return (ß editAndSet(___edit, 2 * ___idx + 1, ___n)))
                                )
                                (when (ß (:bitmap this) == ___bit)
                                    (§ return nil)
                                )
                                (§ return (ß editAndRemovePair(___edit, ___bit, ___idx)))
                            )
                        )
                        (when (Util'equiv-2oo ___key, ___keyOrNull)
                            (§ ass (:val ___removedLeaf) ___removedLeaf)
                            ;; TODO: collapse
                            (§ return (ß editAndRemovePair(___edit, ___bit, ___idx)))
                        )
                        this
                    )
                )
            )
        )
    )
)

(class-ns HashCollisionNode (§ implements INode)
    (defn- #_"HashCollisionNode" HashCollisionNode'init []
        (hash-map
            #_"int" :hash 0
            #_"int" :count 0
            #_"Object[]" :array nil
            #_"AtomicReference<Thread>" :edit nil
        )
    )

    (defn #_"HashCollisionNode" HashCollisionNode'new [#_"AtomicReference<Thread>" ___edit, #_"int" ___hash, #_"int" ___count, #_"Object..." ___array]
        (let [this (HashCollisionNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:hash this) ___hash)
            (§ ass (:count this) ___count)
            (§ ass (:array this) ___array)
            this
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (when (ß ___hash == (:hash this))
            (let [#_"int" ___idx (ß findIndex(___key))]
                (when (ß ___idx != -1)
                    (when (ß (:array this)[___idx + 1] == ___val)
                        (§ return this)
                    )
                    (§ return (ß HashCollisionNode'new(nil, ___hash, (:count this), cloneAndSet((:array this), ___idx + 1, ___val))))
                )
                (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) + 1)))]
                    (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * (:count this)))
                    (§ ass (ß ___newArray[2 * (:count this)]) ___key)
                    (§ ass (ß ___newArray[2 * (:count this) + 1]) ___val)
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (§ return (ß HashCollisionNode'new((:edit this), ___hash, (:count this) + 1, ___newArray)))
                )
            )
        )
        ;; nest it in a bitmap node
        (ß BitmapIndexedNode'new(nil, bitpos((:hash this), ___shift), new Object[] (§ array nil, this )).assoc(___shift, ___hash, ___key, ___val, ___addedLeaf))
    )

    #_method
    (§ defn #_"INode" without [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß findIndex(___key))]
            (when (ß ___idx == -1)
                (§ return this)
            )
            (when (ß (:count this) == 1)
                (§ return nil)
            )
            (ß HashCollisionNode'new(nil, ___hash, (:count this) - 1, removePair((:array this), ___idx / 2)))
        )
    )

    #_method
    (§ defn #_"IMapEntry" find [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key]
        (let [#_"int" ___idx (ß findIndex(___key))]
            (when (< ___idx 0)
                (§ return nil)
            )
            (when (ß Util'equiv-2oo(___key, (:array this)[___idx]))
                (§ return (ß (IMapEntry) MapEntry'create((:array this)[___idx], (:array this)[___idx + 1])))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" find [#_"HashCollisionNode" this, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"int" ___idx (ß findIndex(___key))]
            (when (< ___idx 0)
                (§ return ___notFound)
            )
            (when (ß Util'equiv-2oo(___key, (:array this)[___idx]))
                (§ return (ß (:array this)[___idx + 1]))
            )
            ___notFound
        )
    )

    #_method
    (§ defn #_"ISeq" nodeSeq [#_"HashCollisionNode" this]
        (NodeSeq'create-1 (:array this))
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"HashCollisionNode" this, #_"IFn" ___f]
        (NodeIter'new (:array this), ___f)
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"HashCollisionNode" this, #_"IFn" ___f, #_"Object" ___init]
        (NodeSeq'kvreduce (:array this), ___f, ___init)
    )

    #_method
    (§ defn #_"Object" fold [#_"HashCollisionNode" this, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        (ß NodeSeq'kvreduce((:array this), ___reducef, ___combinef.invoke()))
    )

    #_method
    (§ defn #_"int" findIndex [#_"HashCollisionNode" this, #_"Object" ___key]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < 2 * (:count this)) [(+ ___i 2)]
            (when (ß Util'equiv-2oo(___key, (:array this)[___i]))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn- #_"HashCollisionNode" ensureEditable [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit]
        (when (ß (:edit this) == ___edit)
            (§ return this)
        )
        (let [#_"Object[]" ___newArray (make-array Object (ß 2 * ((:count this) + 1)))] ;; make room for next assoc
            (ß System/arraycopy((:array this), 0, ___newArray, 0, 2 * (:count this)))
            (HashCollisionNode'new ___edit, (:hash this), (:count this), ___newArray)
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" ensureEditable [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___count, #_"Object[]" ___array]
        (when (ß (:edit this) == ___edit)
            (§ ass (:array this) ___array)
            (§ ass (:count this) ___count)
            (§ return this)
        )
        (HashCollisionNode'new ___edit, (:hash this), ___count, ___array)
    )

    #_method
    (§ defn- #_"HashCollisionNode" editAndSet [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a]
        (let [#_"HashCollisionNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß (:array ___editable)[___i]) ___a)
            ___editable
        )
    )

    #_method
    (§ defn- #_"HashCollisionNode" editAndSet [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"HashCollisionNode" ___editable (ß ensureEditable(___edit))]
            (§ ass (ß (:array ___editable)[___i]) ___a)
            (§ ass (ß (:array ___editable)[___j]) ___b)
            ___editable
        )
    )

    #_method
    (§ defn #_"INode" assoc [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Object" ___val, #_"Box" ___addedLeaf]
        (when (ß ___hash == (:hash this))
            (let [#_"int" ___idx (ß findIndex(___key))]
                (when (ß ___idx != -1)
                    (when (ß (:array this)[___idx + 1] == ___val)
                        (§ return this)
                    )
                    (§ return (ß editAndSet(___edit, ___idx + 1, ___val)))
                )
                (when (ß (:array this).length > 2 * (:count this))
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (let [#_"HashCollisionNode" ___editable (ß editAndSet(___edit, 2 * (:count this), ___key, 2 * (:count this) + 1, ___val))]
                        (§ ass (:count ___editable) (ß (:count ___editable) + 1))
                        (§ return ___editable)
                    )
                )
                (let [#_"Object[]" ___newArray (make-array Object (ß (:array this).length + 2))]
                    (ß System/arraycopy((:array this), 0, ___newArray, 0, (:array this).length))
                    (§ ass (ß ___newArray[(:array this).length]) ___key)
                    (§ ass (ß ___newArray[(:array this).length + 1]) ___val)
                    (§ ass (:val ___addedLeaf) ___addedLeaf)
                    (§ return (ß ensureEditable(___edit, (:count this) + 1, ___newArray)))
                )
            )
        )
        ;; nest it in a bitmap node
        (ß BitmapIndexedNode'new(___edit, bitpos((:hash this), ___shift), new Object[] (§ array nil, this, nil, nil )).assoc(___edit, ___shift, ___hash, ___key, ___val, ___addedLeaf))
    )

    #_method
    (§ defn #_"INode" without [#_"HashCollisionNode" this, #_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"int" ___hash, #_"Object" ___key, #_"Box" ___removedLeaf]
        (let [#_"int" ___idx (ß findIndex(___key))]
            (when (ß ___idx == -1)
                (§ return this)
            )
            (§ ass (:val ___removedLeaf) ___removedLeaf)
            (when (ß (:count this) == 1)
                (§ return nil)
            )
            (let [#_"HashCollisionNode" ___editable (ß ensureEditable(___edit))]
                (§ ass (ß (:array ___editable)[___idx]) (ß (:array ___editable)[2 * (:count this) - 2]))
                (§ ass (ß (:array ___editable)[___idx + 1]) (ß (:array ___editable)[2 * (:count this) - 1]))
                (§ ass (ß (:array ___editable)[2 * (:count this) - 2]) (§ ass (ß (:array ___editable)[2 * (:count this) - 1]) nil))
                (§ ass (:count ___editable) (ß (:count ___editable) - 1))
                ___editable
            )
        )
    )
)

(class-ns NodeIter (§ implements Iterator)
    (def- #_"Object" NodeIter'NULL (Object.))

    (defn- #_"NodeIter" NodeIter'init []
        (hash-map
            #_"Object[]" :array nil
            #_"IFn" :f nil
            #_"int" :i 0
            #_"Object" :nextEntry NodeIter'NULL
            #_"Iterator" :nextIter nil
        )
    )

    (defn #_"NodeIter" NodeIter'new [#_"Object[]" ___array, #_"IFn" ___f]
        (let [this (NodeIter'init)]
            (§ ass (:array this) ___array)
            (§ ass (:f this) ___f)
            this
        )
    )

    #_method
    (§ defn- #_"boolean" advance [#_"NodeIter" this]
        (while (ß (:i this) < (:array this).length)
            (let [#_"Object" ___key (ß (:array this)[(:i this)])]
                (let [#_"Object" ___nodeOrVal (ß (:array this)[(:i this) + 1])]
                    (§ ass (:i this) (+ (:i this) 2))
                    (cond (some? ___key)
                        (do
                            (§ ass (:nextEntry this) (ß (:f this).invoke(___key, ___nodeOrVal)))
                            (§ return true)
                        )
                        (some? ___nodeOrVal)
                        (do
                            (let [#_"Iterator" ___iter (ß ((INode) ___nodeOrVal).iterator((:f this)))]
                                (when (ß ___iter != nil && ___iter.hasNext())
                                    (§ ass (:nextIter this) ___iter)
                                    (§ return true)
                                )
                            )
                        )
                    )
                )
            )
        )
        false
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"NodeIter" this]
        (when (ß (:nextEntry this) != NodeIter'NULL || (:nextIter this) != nil)
            (§ return true)
        )
        (ß advance())
    )

    #_method
    (§ defn #_"Object" next [#_"NodeIter" this]
        (let [#_"Object" ___ret (:nextEntry this)]
            (cond (ß ___ret != NodeIter'NULL)
                (do
                    (§ ass (:nextEntry this) NodeIter'NULL)
                    (§ return ___ret)
                )
                (some? (:nextIter this))
                (do
                    (§ ass ___ret (ß (:nextIter this).next()))
                    (when (ß !this.nextIter.hasNext())
                        (§ ass (:nextIter this) nil)
                    )
                    (§ return ___ret)
                )
                (ß advance())
                (do
                    (§ return (ß next()))
                )
            )
            (throw (NoSuchElementException.))
        )
    )

    #_method
    (§ defn #_"void" remove [#_"NodeIter" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns NodeSeq (§ extends ASeq)
    (defn- #_"NodeSeq" NodeSeq'init []
        (hash-map
            #_"Object[]" :array nil
            #_"int" :i 0
            #_"ISeq" :s nil
        )
    )

    (defn #_"NodeSeq" NodeSeq'new-2 [#_"Object[]" ___array, #_"int" ___i]
        (NodeSeq'new-4 nil, ___array, ___i, nil)
    )

    (defn #_"ISeq" NodeSeq'create-1 [#_"Object[]" ___array]
        (NodeSeq'create-3 ___array, 0, nil)
    )

    (defn #_"Object" NodeSeq'kvreduce [#_"Object[]" ___array, #_"IFn" ___f, #_"Object" ___init]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___array.length) [(+ ___i 2)]
            (if (ß ___array[___i] != nil)
                (do
                    (§ ass ___init (ß ___f.invoke(___init, ___array[___i], ___array[___i + 1])))
                )
                (do
                    (let [#_"INode" ___node (ß (INode) ___array[___i + 1])]
                        (when (some? ___node)
                            (§ ass ___init (ß ___node.kvreduce(___f, ___init)))
                        )
                    )
                )
            )
            (when (RT'isReduced ___init)
                (§ return ___init)
            )
        )
        ___init
    )

    (defn- #_"ISeq" NodeSeq'create-3 [#_"Object[]" ___array, #_"int" ___i, #_"ISeq" ___s]
        (when (some? ___s)
            (§ return (NodeSeq'new-4 nil, ___array, ___i, ___s))
        )
        (loop-when-recur [#_"int" ___j ___i] (ß ___j < ___array.length) [(+ ___j 2)]
            (when (ß ___array[___j] != nil)
                (§ return (NodeSeq'new-4 nil, ___array, ___j, nil))
            )
            (let [#_"INode" ___node (ß (INode) ___array[___j + 1])]
                (when (some? ___node)
                    (let [#_"ISeq" ___nodeSeq (ß ___node.nodeSeq())]
                        (when (some? ___nodeSeq)
                            (§ return (ß NodeSeq'new-4(nil, ___array, ___j + 2, ___nodeSeq)))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn #_"NodeSeq" NodeSeq'new-4 [#_"IPersistentMap" ___meta, #_"Object[]" ___array, #_"int" ___i, #_"ISeq" ___s]
        (let [this (merge (ASeq'new ___meta) (NodeSeq'init))]
            (§ ass (:array this) ___array)
            (§ ass (:i this) ___i)
            (§ ass (:s this) ___s)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"NodeSeq" this, #_"IPersistentMap" ___meta]
        (NodeSeq'new-4 ___meta, (:array this), (:i this), (:s this))
    )

    #_method
    (§ defn #_"Object" first [#_"NodeSeq" this]
        (when (some? (:s this))
            (§ return (ß (:s this).first()))
        )
        (ß MapEntry'create((:array this)[(:i this)], (:array this)[(:i this) + 1]))
    )

    #_method
    (§ defn #_"ISeq" next [#_"NodeSeq" this]
        (when (some? (:s this))
            (§ return (ß NodeSeq'create-3((:array this), (:i this), (:s this).next())))
        )
        (ß NodeSeq'create-3((:array this), (:i this) + 2, nil))
    )
)

;;;
 ; A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
 ;
 ; Uses path copying for persistence
 ; HashCollision leaves vs. extended hashing
 ; Node polymorphism vs. conditionals
 ; No sub-tree pools or root-resizing
 ; Any errors are my own
 ;;
(class-ns PersistentHashMap (§ extends APersistentMap) (§ implements IEditableCollection, IObj, IMapIterable, IKVReduce)
    (§ def #_"PersistentHashMap" PersistentHashMap'EMPTY (PersistentHashMap'new-4 0, nil, false, nil))
    (def- #_"Object" PersistentHashMap'NOT_FOUND (Object.))

    (defn #_"IPersistentMap" PersistentHashMap'create-1m [#_"Map" ___other]
        (let [#_"ITransientMap" ___ret (ß PersistentHashMap'EMPTY.asTransient())]
            (doseq [#_"Object" ___o (ß ___other.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            (ß ___ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-1a [#_"Object..." ___init]
        (let [#_"ITransientMap" ___ret (ß PersistentHashMap'EMPTY.asTransient())]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
                (§ ass ___ret (ß ___ret.assoc(___init[___i], ___init[___i + 1])))
            )
            (ß (PersistentHashMap) ___ret.persistent())
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1a [#_"Object..." ___init]
        (let [#_"ITransientMap" ___ret (ß PersistentHashMap'EMPTY.asTransient())]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(+ ___i 2)]
                (§ ass ___ret (ß ___ret.assoc(___init[___i], ___init[___i + 1])))
                (when (ß ___ret.count() != ___i / 2 + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (ß ___init[___i]))))
                )
            )
            (ß (PersistentHashMap) ___ret.persistent())
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'create-1s [#_"ISeq" ___items]
        (let [#_"ITransientMap" ___ret (ß PersistentHashMap'EMPTY.asTransient())]
            (loop-when-recur [___items ___items] (some? ___items) [(ß ___items.next().next())]
                (when (ß ___items.next() == nil)
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (§ array (ß ___items.first())))))
                )
                (§ ass ___ret (ß ___ret.assoc(___items.first(), RT'second(___items))))
            )
            (ß (PersistentHashMap) ___ret.persistent())
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'createWithCheck-1s [#_"ISeq" ___items]
        (let [#_"ITransientMap" ___ret (ß PersistentHashMap'EMPTY.asTransient())]
            (loop-when-recur [___items ___items #_"int" ___i 0] (some? ___items) [(ß ___items.next().next()) (inc ___i)]
                (when (ß ___items.next() == nil)
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (§ array (ß ___items.first())))))
                )
                (§ ass ___ret (ß ___ret.assoc(___items.first(), RT'second(___items))))
                (when (ß ___ret.count() != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (ß ___items.first()))))
                )
            )
            (ß (PersistentHashMap) ___ret.persistent())
        )
    )

    ;;;
     ; @param init {key1, val1, key2, val2, ...}
     ;;
    (defn #_"PersistentHashMap" PersistentHashMap'create-2 [#_"IPersistentMap" ___meta, #_"Object..." ___init]
        (ß create(___init).withMeta(___meta))
    )

    (defn- #_"PersistentHashMap" PersistentHashMap'init []
        (hash-map
            #_"int" :count 0
            #_"INode" :root nil
            #_"boolean" :hasNull false
            #_"Object" :nullValue nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-4 [#_"int" ___count, #_"INode" ___root, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass (:count this) ___count)
            (§ ass (:root this) ___root)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            (§ ass (:_meta this) nil)
            this
        )
    )

    (defn #_"PersistentHashMap" PersistentHashMap'new-5 [#_"IPersistentMap" ___meta, #_"int" ___count, #_"INode" ___root, #_"boolean" ___hasNull, #_"Object" ___nullValue]
        (let [this (merge (APersistentMap'new) (PersistentHashMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:count this) ___count)
            (§ ass (:root this) ___root)
            (§ ass (:hasNull this) ___hasNull)
            (§ ass (:nullValue this) ___nullValue)
            this
        )
    )

    (defn #_"int" PersistentHashMap'hash [#_"Object" ___k]
        (Util'hasheq ___k)
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (:hasNull this))
        )
        (ß ((:root this) != nil) ? ((:root this).find(0, hash(___key), ___key, PersistentHashMap'NOT_FOUND) != PersistentHashMap'NOT_FOUND) :or false)
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (ß (:hasNull this) ? (IMapEntry) MapEntry'create(nil, (:nullValue this)) :or nil))
        )
        (ß ((:root this) != nil) ? (:root this).find(0, hash(___key), ___key) :or nil)
    )

    #_method
    (§ defn #_"IPersistentMap" assoc [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___key)
            (when (ß (:hasNull this) && ___val == (:nullValue this))
                (§ return this)
            )
            (§ return (ß PersistentHashMap'new-5(meta(), (:hasNull this) ? (:count this) :or (:count this) + 1, (:root this), true, ___val)))
        )
        (let [#_"Box" ___addedLeaf (Box'new nil)]
            (let [#_"INode" ___newroot (ß (((:root this) == nil) ? BitmapIndexedNode'EMPTY :or (:root this)).assoc(0, hash(___key), ___key, ___val, ___addedLeaf))]
                (when (ß ___newroot == (:root this))
                    (§ return this)
                )
                (ß PersistentHashMap'new-5(meta(), ((:val ___addedLeaf) == nil) ? (:count this) :or (:count this) + 1, ___newroot, (:hasNull this), (:nullValue this)))
            )
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (when (nil? ___key)
            (§ return (ß (:hasNull this) ? (:nullValue this) :or ___notFound))
        )
        (ß ((:root this) != nil) ? (:root this).find(0, hash(___key), ___key, ___notFound) :or ___notFound)
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentHashMap" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"IPersistentMap" assocEx [#_"PersistentHashMap" this, #_"Object" ___key, #_"Object" ___val]
        (when (ß containsKey(___key))
            (throw (Util'runtimeException-1 "Key already present"))
        )
        (ß assoc(___key, ___val))
    )

    #_method
    (§ defn #_"IPersistentMap" without [#_"PersistentHashMap" this, #_"Object" ___key]
        (when (nil? ___key)
            (§ return (ß (:hasNull this) ? PersistentHashMap'new-5(meta(), (:count this) - 1, (:root this), false, nil) :or this))
        )
        (when (nil? (:root this))
            (§ return this)
        )
        (let [#_"INode" ___newroot (ß (:root this).without(0, hash(___key), ___key))]
            (when (ß ___newroot == (:root this))
                (§ return this)
            )
            (ß PersistentHashMap'new-5(meta(), (:count this) - 1, ___newroot, (:hasNull this), (:nullValue this)))
        )
    )

    (def #_"Iterator" PersistentHashMap'EMPTY_ITER
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn- #_"Iterator" iterator [#_"PersistentHashMap" this, #_"IFn" ___f]
        (let [#_"Iterator" ___rootIter (ß ((:root this) == nil) ? PersistentHashMap'EMPTY_ITER :or (:root this).iterator(___f))]
            (if (:hasNull this)
                (do
                    (§ reify Iterator()
                        (§ init
                            (hash-map
                                #_"boolean" :seen false
                            )
                        )

                        #_method
                        (§ defn #_"boolean" hasNext [#_"Iterator" this]
                            (if (ß !this.seen)
                                (do
                                    true
                                )
                                (do
                                    (ß ___rootIter.hasNext())
                                )
                            )
                        )

                        #_method
                        (§ defn #_"Object" next [#_"Iterator" this]
                            (if (ß !this.seen)
                                (do
                                    (§ ass (:seen this) true)
                                    (ß ___f.invoke(nil, (:nullValue this)))
                                )
                                (do
                                    (ß ___rootIter.next())
                                )
                            )
                        )

                        #_method
                        (§ defn #_"void" remove [#_"Iterator" this]
                            (throw (UnsupportedOperationException.))
                        )
                    )
                )
                (do
                    ___rootIter
                )
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap'MAKE_ENTRY))
    )

    #_method
    (§ defn #_"Iterator" keyIterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap'MAKE_KEY))
    )

    #_method
    (§ defn #_"Iterator" valIterator [#_"PersistentHashMap" this]
        (ß iterator(APersistentMap'MAKE_VAL))
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentHashMap" this, #_"IFn" ___f, #_"Object" ___init]
        (§ ass ___init (ß (:hasNull this) ? ___f.invoke(___init, nil, (:nullValue this)) :or ___init))
        (when (RT'isReduced ___init)
            (§ return (ß ((IDeref)___init).deref()))
        )
        (when (some? (:root this))
            (§ ass ___init (ß (:root this).kvreduce(___f, ___init)))
            (if (RT'isReduced ___init)
                (do
                    (§ return (ß ((IDeref)___init).deref()))
                )
                (do
                    (§ return ___init)
                )
            )
        )
        ___init
    )

    #_method
    (§ defn #_"Object" fold [#_"PersistentHashMap" this, #_"long" ___n, #_"IFn" ___combinef, #_"IFn" ___reducef, #_"IFn" ___fjinvoke, #_"IFn" ___fjtask, #_"IFn" ___fjfork, #_"IFn" ___fjjoin]
        ;; we are ignoring n for now
        (let [#_"Callable" ___top
                (§ reify Callable()
                    #_method
                    (§ defn #_"Object" call [#_"Callable" this] #_(§ throws Exception)
                        (let [#_"Object" ___ret (ß ___combinef.invoke())]
                            (when (some? (:root this))
                                (§ ass ___ret (ß ___combinef.invoke(___ret, (:root this).fold(___combinef, ___reducef, ___fjtask, ___fjfork, ___fjjoin))))
                            )
                            (ß (:hasNull this) ? ___combinef.invoke(___ret, ___reducef.invoke(___combinef.invoke(), nil, (:nullValue this))) :or ___ret)
                        )
                    )
                )]
            (ß ___fjinvoke.invoke(___top))
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentHashMap" this]
        (:count this)
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentHashMap" this]
        (let [#_"ISeq" ___s (ß ((:root this) != nil) ? (:root this).nodeSeq() :or nil)]
            (ß (:hasNull this) ? Cons'new-2(MapEntry'create(nil, (:nullValue this)), ___s) :or ___s)
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentHashMap" this]
        (ß PersistentHashMap'EMPTY.withMeta(meta()))
    )

    (defn #_"int" PersistentHashMap'mask [#_"int" ___hash, #_"int" ___shift]
        (ß (___hash >>> ___shift) & 0x01f)
    )

    #_method
    (§ defn #_"PersistentHashMap" withMeta [#_"PersistentHashMap" this, #_"IPersistentMap" ___meta]
        (PersistentHashMap'new-5 ___meta, (:count this), (:root this), (:hasNull this), (:nullValue this))
    )

    #_method
    (§ defn #_"TransientHashMap" asTransient [#_"PersistentHashMap" this]
        (TransientHashMap'new-1 this)
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentHashMap" this]
        (:_meta this)
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-3 [#_"Object[]" ___array, #_"int" ___i, #_"Object" ___a]
        (let [#_"Object[]" ___clone (ß ___array.clone())]
            (§ ass (ß ___clone[___i]) ___a)
            ___clone
        )
    )

    (defn- #_"Object[]" PersistentHashMap'cloneAndSet-5 [#_"Object[]" ___array, #_"int" ___i, #_"Object" ___a, #_"int" ___j, #_"Object" ___b]
        (let [#_"Object[]" ___clone (ß ___array.clone())]
            (§ ass (ß ___clone[___i]) ___a)
            (§ ass (ß ___clone[___j]) ___b)
            ___clone
        )
    )

    (defn- #_"Object[]" PersistentHashMap'removePair [#_"Object[]" ___array, #_"int" ___i]
        (let [#_"Object[]" ___newArray (make-array Object (ß ___array.length - 2))]
            (ß System/arraycopy(___array, 0, ___newArray, 0, 2 * ___i))
            (ß System/arraycopy(___array, 2 * (___i + 1), ___newArray, 2 * ___i, ___newArray.length - 2 * ___i))
            ___newArray
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-6 [#_"int" ___shift, #_"Object" ___key1, #_"Object" ___val1, #_"int" ___key2hash, #_"Object" ___key2, #_"Object" ___val2]
        (let [#_"int" ___key1hash (ß hash(___key1))]
            (when (ß ___key1hash == ___key2hash)
                (§ return (ß HashCollisionNode'new(nil, ___key1hash, 2, new Object[] (§ array ___key1, ___val1, ___key2, ___val2 ))))
            )
            (let [#_"Box" ___addedLeaf (Box'new nil)]
                (let [#_"AtomicReference<Thread>" ___edit (AtomicReference.)]
                    (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift, ___key1hash, ___key1, ___val1, ___addedLeaf).assoc(___edit, ___shift, ___key2hash, ___key2, ___val2, ___addedLeaf))
                )
            )
        )
    )

    (defn- #_"INode" PersistentHashMap'createNode-7 [#_"AtomicReference<Thread>" ___edit, #_"int" ___shift, #_"Object" ___key1, #_"Object" ___val1, #_"int" ___key2hash, #_"Object" ___key2, #_"Object" ___val2]
        (let [#_"int" ___key1hash (ß hash(___key1))]
            (when (ß ___key1hash == ___key2hash)
                (§ return (ß HashCollisionNode'new(nil, ___key1hash, 2, new Object[] (§ array ___key1, ___val1, ___key2, ___val2 ))))
            )
            (let [#_"Box" ___addedLeaf (Box'new nil)]
                (ß BitmapIndexedNode'EMPTY.assoc(___edit, ___shift, ___key1hash, ___key1, ___val1, ___addedLeaf).assoc(___edit, ___shift, ___key2hash, ___key2, ___val2, ___addedLeaf))
            )
        )
    )

    (defn- #_"int" PersistentHashMap'bitpos [#_"int" ___hash, #_"int" ___shift]
        (ß 1 << mask(___hash, ___shift))
    )
)
)

(java-ns cloiure.lang.PersistentHashSet

(§ import java.util.List)

#_stateless
(class-ns TransientHashSet (§ extends ATransientSet)
    (defn #_"TransientHashSet" TransientHashSet'new [#_"ITransientMap" ___impl]
        (ATransientSet'new ___impl)
    )

    #_method
    (§ defn #_"IPersistentCollection" persistent [#_"TransientHashSet" this]
        (ß PersistentHashSet'new(nil, (:impl this).persistent()))
    )
)

(class-ns PersistentHashSet (§ extends APersistentSet) (§ implements IObj, IEditableCollection)
    (§ def #_"PersistentHashSet" PersistentHashSet'EMPTY (PersistentHashSet'new nil, PersistentHashMap'EMPTY))

    (defn #_"PersistentHashSet" PersistentHashSet'create-1a [#_"Object..." ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(inc ___i)]
                (§ ass ___ret (ß (ITransientSet)___ret.conj(___init[___i])))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1l [#_"List" ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (doseq [#_"Object" ___key ___init]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___key)))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'create-1s [#_"ISeq" ___items]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (loop-when-recur [___items ___items] (some? ___items) [(ß ___items.next())]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___items.first())))
            )
            (ß (PersistentHashSet)___ret.persistent())
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1a [#_"Object..." ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___init.length) [(inc ___i)]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___init[___i])))
                (when (ß ___ret.count() != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (ß ___init[___i]))))
                )
            )
            (ß (PersistentHashSet) ___ret.persistent())
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1l [#_"List" ___init]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (let [#_"int" ___i 0]
                (doseq [#_"Object" ___key ___init]
                    (§ ass ___ret (ß (ITransientSet) ___ret.conj(___key)))
                    (when (ß ___ret.count() != ___i + 1)
                        (throw (IllegalArgumentException. (str "Duplicate key: " ___key)))
                    )
                    (§ ass ___i (inc ___i))
                )
                (ß (PersistentHashSet) ___ret.persistent())
            )
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'createWithCheck-1s [#_"ISeq" ___items]
        (let [#_"ITransientSet" ___ret (ß (ITransientSet)PersistentHashSet'EMPTY.asTransient())]
            (loop-when-recur [___items ___items #_"int" ___i 0] (some? ___items) [(ß ___items.next()) (inc ___i)]
                (§ ass ___ret (ß (ITransientSet) ___ret.conj(___items.first())))
                (when (ß ___ret.count() != ___i + 1)
                    (throw (IllegalArgumentException. (str "Duplicate key: " (ß ___items.first()))))
                )
            )
            (ß (PersistentHashSet) ___ret.persistent())
        )
    )

    (defn- #_"PersistentHashSet" PersistentHashSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentHashSet" PersistentHashSet'new [#_"IPersistentMap" ___meta, #_"IPersistentMap" ___impl]
        (let [this (merge (APersistentSet'new ___impl) (PersistentHashSet'init))]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"IPersistentSet" disjoin [#_"PersistentHashSet" this, #_"Object" ___key]
        (when (ß contains(___key))
            (§ return (ß PersistentHashSet'new(meta(), (:impl this).without(___key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" cons [#_"PersistentHashSet" this, #_"Object" ___o]
        (when (ß contains(___o))
            (§ return this)
        )
        (ß PersistentHashSet'new(meta(), (:impl this).assoc(___o, ___o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentHashSet" this]
        (ß PersistentHashSet'EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentHashSet" withMeta [#_"PersistentHashSet" this, #_"IPersistentMap" ___meta]
        (PersistentHashSet'new ___meta, (:impl this))
    )

    #_method
    (§ defn #_"ITransientCollection" asTransient [#_"PersistentHashSet" this]
        (ß TransientHashSet'new(((PersistentHashMap) (:impl this)).asTransient()))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentHashSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentList

(§ import java.util.*)

(class-ns Primordial (§ extends RestFn)
    (defn #_"Primordial" Primordial'new []
        (RestFn'new)
    )

    #_method
    (§ defn #_"int" getRequiredArity [#_"Primordial" this]
        0
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"Primordial" this, #_"Object" ___args]
        (when (ß ___args instanceof ArraySeq)
            (let [#_"Object[]" ___argsarray (ß ((ArraySeq) ___args).array)]
                (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
                    (loop-when-recur [#_"int" ___i (ß ___argsarray.length - 1)] (ß ___i >= ((ArraySeq)___args).i) [(dec ___i)]
                        (§ ass ___ret (ß (IPersistentList) ___ret.cons(___argsarray[___i])))
                    )
                    (§ return ___ret)
                )
            )
        )
        (let [#_"LinkedList" ___list (LinkedList.)]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(ß ___s.next())]
                (ß ___list.add(___s.first()))
            )
            (ß create(___list))
        )
    )

    (defn #_"Object" Primordial'invokeStatic [#_"ISeq" ___args]
        (when (ß ___args instanceof ArraySeq)
            (let [#_"Object[]" ___argsarray (ß ((ArraySeq) ___args).array)]
                (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
                    (loop-when-recur [#_"int" ___i (ß ___argsarray.length - 1)] (ß ___i >= 0) [(dec ___i)]
                        (§ ass ___ret (ß (IPersistentList) ___ret.cons(___argsarray[___i])))
                    )
                    (§ return ___ret)
                )
            )
        )
        (let [#_"LinkedList" ___list (LinkedList.)]
            (loop-when-recur [#_"ISeq" ___s (RT'seq ___args)] (some? ___s) [(ß ___s.next())]
                (ß ___list.add(___s.first()))
            )
            (ß create(___list))
        )
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"Primordial" this, #_"IPersistentMap" ___meta]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"Primordial" this]
        nil
    )
)

#_stateless
(class-ns EmptyList (§ extends Obj) (§ implements IPersistentList, List, ISeq, Counted, IHashEq)
    (§ def #_"int" EmptyList'HASHEQ (Murmur3'hashOrdered Collections/EMPTY_LIST))

    (defn #_"EmptyList" EmptyList'new [#_"IPersistentMap" ___meta]
        (Obj'new ___meta)
    )

    #_method
    (§ defn #_"int" hashCode [#_"EmptyList" this]
        1
    )

    #_method
    (defn #_"int" EmptyList'hasheq [#_"EmptyList" this]
        EmptyList'HASHEQ
    )

    #_method
    (§ defn #_"String" toString [#_"EmptyList" this]
        "()"
    )

    #_method
    (§ defn #_"boolean" equals [#_"EmptyList" this, #_"Object" ___o]
        (ß ((___o instanceof Sequential || ___o instanceof List) && RT'seq(___o) == nil))
    )

    #_method
    (§ defn #_"boolean" equiv [#_"EmptyList" this, #_"Object" ___o]
        (ß equals(___o))
    )

    #_method
    (§ defn #_"Object" first [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" next [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"ISeq" more [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"PersistentList" cons [#_"EmptyList" this, #_"Object" ___o]
        (ß PersistentList'new-4(meta(), ___o, nil, 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"EmptyList" this]
        this
    )

    #_method
    (§ defn #_"EmptyList" withMeta [#_"EmptyList" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != meta())
            (§ return (EmptyList'new ___meta))
        )
        this
    )

    #_method
    (§ defn #_"Object" peek [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"IPersistentList" pop [#_"EmptyList" this]
        (throw (IllegalStateException. "Can't pop empty list"))
    )

    #_method
    (§ defn #_"int" count [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"ISeq" seq [#_"EmptyList" this]
        nil
    )

    #_method
    (§ defn #_"int" size [#_"EmptyList" this]
        0
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"EmptyList" this]
        true
    )

    #_method
    (§ defn #_"boolean" contains [#_"EmptyList" this, #_"Object" ___o]
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"EmptyList" this]
        (§ reify Iterator()
            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                false
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (throw (NoSuchElementException.))
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"EmptyList" this]
        RT'EMPTY_ARRAY
    )

    #_method
    (§ defn #_"boolean" add [#_"EmptyList" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"EmptyList" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"EmptyList" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"EmptyList" this, #_"Collection" ___collection]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"EmptyList" this, #_"Collection" ___collection]
        (ß ___collection.isEmpty())
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"EmptyList" this, #_"Object[]" ___objects]
        (when (ß ___objects.length > 0)
            (§ ass (ß ___objects[0]) nil)
        )
        ___objects
    )

    #_method
    (§ defn- #_"List" reify [#_"EmptyList" this]
        (Collections/unmodifiableList (ArrayList. this))
    )

    #_method
    (§ defn #_"List" subList [#_"EmptyList" this, #_"int" ___fromIndex, #_"int" ___toIndex]
        (ß reify().subList(___fromIndex, ___toIndex))
    )

    #_method
    (§ defn #_"Object" set [#_"EmptyList" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"Object" remove [#_"EmptyList" this, #_"int" ___index]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"int" indexOf [#_"EmptyList" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (ß seq()) #_"int" ___i 0] (some? ___s) [(ß ___s.next()) (inc ___i)]
            (when (ß Util'equiv-2oo(___s.first(), ___o))
                (§ return ___i)
            )
        )
        -1
    )

    #_method
    (§ defn #_"int" lastIndexOf [#_"EmptyList" this, #_"Object" ___o]
        (ß reify().lastIndexOf(___o))
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"EmptyList" this]
        (ß reify().listIterator())
    )

    #_method
    (§ defn #_"ListIterator" listIterator [#_"EmptyList" this, #_"int" ___index]
        (ß reify().listIterator(___index))
    )

    #_method
    (§ defn #_"Object" get [#_"EmptyList" this, #_"int" ___index]
        (RT'nth-2 this, ___index)
    )

    #_method
    (§ defn #_"void" add [#_"EmptyList" this, #_"int" ___index, #_"Object" ___element]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"EmptyList" this, #_"int" ___index, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns PersistentList (§ extends ASeq) (§ implements IPersistentList, IReduce, List, Counted)
    (§ def #_"IFn" PersistentList'creator (Primordial'new))

    (§ def #_"EmptyList" PersistentList'EMPTY (EmptyList'new nil))

    (defn- #_"PersistentList" PersistentList'init []
        (hash-map
            #_"Object" :_first nil
            #_"IPersistentList" :_rest nil
            #_"int" :_count 0
        )
    )

    (defn #_"PersistentList" PersistentList'new-1 [#_"Object" ___first]
        (let [this (merge (ASeq'new) (PersistentList'init))]
            (§ ass (:_first this) ___first)
            (§ ass (:_rest this) nil)

            (§ ass (:_count this) 1)
            this
        )
    )

    (defn #_"PersistentList" PersistentList'new-4 [#_"IPersistentMap" ___meta, #_"Object" ____first, #_"IPersistentList" ____rest, #_"int" ____count]
        (let [this (merge (ASeq'new ___meta) (PersistentList'init))]
            (§ ass (:_first this) ____first)
            (§ ass (:_rest this) ____rest)
            (§ ass (:_count this) ____count)
            this
        )
    )

    (defn #_"IPersistentList" PersistentList'create [#_"List" ___init]
        (let [#_"IPersistentList" ___ret PersistentList'EMPTY]
            (loop-when-recur [#_"ListIterator" ___i (ß ___init.listIterator(___init.size()))] (ß ___i.hasPrevious()) [___i]
                (§ ass ___ret (ß (IPersistentList) ___ret.cons(___i.previous())))
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" first [#_"PersistentList" this]
        (:_first this)
    )

    #_method
    (§ defn #_"ISeq" next [#_"PersistentList" this]
        (when (ß (:_count this) == 1)
            (§ return nil)
        )
        (ß (ISeq) (:_rest this))
    )

    #_method
    (§ defn #_"Object" peek [#_"PersistentList" this]
        (ß first())
    )

    #_method
    (§ defn #_"IPersistentList" pop [#_"PersistentList" this]
        (when (nil? (:_rest this))
            (§ return (ß PersistentList'EMPTY.withMeta((:_meta this))))
        )
        (:_rest this)
    )

    #_method
    (§ defn #_"int" count [#_"PersistentList" this]
        (:_count this)
    )

    #_method
    (§ defn #_"PersistentList" cons [#_"PersistentList" this, #_"Object" ___o]
        (ß PersistentList'new-4(meta(), ___o, this, (:_count this) + 1))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentList" this]
        (ß PersistentList'EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentList" withMeta [#_"PersistentList" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta != (:_meta this))
            (§ return (PersistentList'new-4 ___meta, (:_first this), (:_rest this), (:_count this)))
        )
        this
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentList" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (ß first())]
            (loop-when-recur [#_"ISeq" ___s (ß next())] (some? ___s) [(ß ___s.next())]
                (§ ass ___ret (ß ___f.invoke(___ret, ___s.first())))
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentList" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret (ß ___f.invoke(___start, first()))]
            (loop-when-recur [#_"ISeq" ___s (ß next())] (some? ___s) [(ß ___s.next())]
                (when (RT'isReduced ___ret)
                    (§ return (ß ((IDeref)___ret).deref()))
                )
                (§ ass ___ret (ß ___f.invoke(___ret, ___s.first())))
            )
            (when (RT'isReduced ___ret)
                (§ return (ß ((IDeref)___ret).deref()))
            )
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.PersistentQueue

(§ import java.util.Collection)
(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns QSeq (§ extends ASeq)
    (defn- #_"QSeq" QSeq'init []
        (hash-map
            #_"ISeq" :f nil
            #_"ISeq" :rseq nil
        )
    )

    (defn #_"QSeq" QSeq'new-2 [#_"ISeq" ___f, #_"ISeq" ___rseq]
        (let [this (merge (ASeq'new) (QSeq'init))]
            (§ ass (:f this) ___f)
            (§ ass (:rseq this) ___rseq)
            this
        )
    )

    (defn #_"QSeq" QSeq'new-3 [#_"IPersistentMap" ___meta, #_"ISeq" ___f, #_"ISeq" ___rseq]
        (let [this (merge (ASeq'new ___meta) (QSeq'init))]
            (§ ass (:f this) ___f)
            (§ ass (:rseq this) ___rseq)
            this
        )
    )

    #_method
    (§ defn #_"Object" first [#_"QSeq" this]
        (ß (:f this).first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"QSeq" this]
        (let [#_"ISeq" ___f1 (ß (:f this).next())]
            (let [#_"ISeq" ___r1 (:rseq this)]
                (when (nil? ___f1)
                    (when (nil? (:rseq this))
                        (§ return nil)
                    )
                    (§ ass ___f1 (:rseq this))
                    (§ ass ___r1 nil)
                )
                (QSeq'new-2 ___f1, ___r1)
            )
        )
    )

    #_method
    (§ defn #_"int" count [#_"QSeq" this]
        (ß RT'count((:f this)) + RT'count((:rseq this)))
    )

    #_method
    (§ defn #_"QSeq" withMeta [#_"QSeq" this, #_"IPersistentMap" ___meta]
        (QSeq'new-3 ___meta, (:f this), (:rseq this))
    )
)

;;;
 ; conses onto rear, peeks/pops from front
 ; See Okasaki's Batched Queues
 ; This differs in that it uses a PersistentVector as the rear, which is in-order,
 ; so no reversing or suspensions required for persistent use
 ;;
(class-ns PersistentQueue (§ extends Obj) (§ implements IPersistentList, Collection, Counted, IHashEq)
    (§ def #_"PersistentQueue" PersistentQueue'EMPTY (PersistentQueue'new nil, 0, nil, nil))

    (defn- #_"PersistentQueue" PersistentQueue'init []
        (hash-map
            #_"int" :cnt 0
            #_"ISeq" :f nil
            #_"PersistentVector" :r nil
            #_"int" :_hash 0
            #_"int" :_hasheq 0
        )
    )

    (defn #_"PersistentQueue" PersistentQueue'new [#_"IPersistentMap" ___meta, #_"int" ___cnt, #_"ISeq" ___f, #_"PersistentVector" ___r]
        (let [this (merge (Obj'new ___meta) (PersistentQueue'init))]
            (§ ass (:cnt this) ___cnt)
            (§ ass (:f this) ___f)
            (§ ass (:r this) ___r)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentQueue" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (ß seq()) ___ms ___ms] (some? ___s) [(ß ___s.next()) (ß ___ms.next())]
                (when (ß ___ms == nil || !Util'equiv-2oo(___s.first(), ___ms.first()))
                    (§ return false)
                )
            )
            (ß (___ms == nil))
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentQueue" this, #_"Object" ___obj]
        (when (ß !(___obj instanceof Sequential))
            (§ return false)
        )
        (let [#_"ISeq" ___ms (RT'seq ___obj)]
            (loop-when-recur [#_"ISeq" ___s (ß seq()) ___ms ___ms] (some? ___s) [(ß ___s.next()) (ß ___ms.next())]
                (when (ß ___ms == nil || !Util'equals(___s.first(), ___ms.first()))
                    (§ return false)
                )
            )
            (ß (___ms == nil))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"PersistentQueue" this]
        (let [#_"int" ___hash (:_hash this)]
            (when (ß ___hash == 0)
                (§ ass ___hash 1)
                (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
                    (§ ass ___hash (ß 31 * ___hash + ((___s.first() == nil) ? 0 :or ___s.first().hashCode())))
                )
                (§ ass (:_hash this) ___hash)
            )
            ___hash
        )
    )

    #_method
    (§ defn #_"int" hasheq [#_"PersistentQueue" this]
        (let [#_"int" ___cached (:_hasheq this)]
            (when (ß ___cached == 0)
                (§ ass (:_hasheq this) (§ ass ___cached (Murmur3'hashOrdered this)))
            )
            ___cached
        )
    )

    #_method
    (§ defn #_"Object" peek [#_"PersistentQueue" this]
        (RT'first (:f this))
    )

    #_method
    (§ defn #_"PersistentQueue" pop [#_"PersistentQueue" this]
        (when (nil? (:f this)) ;; hmmm... pop of empty queue -> empty queue?
            (§ return this)
        )
        (let [#_"ISeq" ___f1 (ß (:f this).next())]
            (let [#_"PersistentVector" ___r1 (:r this)]
                (when (nil? ___f1)
                    (§ ass ___f1 (RT'seq (:r this)))
                    (§ ass ___r1 nil)
                )
                (ß PersistentQueue'new(meta(), (:cnt this) - 1, ___f1, ___r1))
            )
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentQueue" this]
        (:cnt this)
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentQueue" this]
        (when (nil? (:f this))
            (§ return nil)
        )
        (ß QSeq'new-2((:f this), RT'seq((:r this))))
    )

    #_method
    (§ defn #_"PersistentQueue" cons [#_"PersistentQueue" this, #_"Object" ___o]
        (if (nil? (:f this)) ;; empty
            (do
                (ß PersistentQueue'new(meta(), (:cnt this) + 1, RT'list-1(___o), nil))
            )
            (do
                (ß PersistentQueue'new(meta(), (:cnt this) + 1, (:f this), (((:r this) != nil) ? (:r this) :or PersistentVector'EMPTY).cons(___o)))
            )
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentQueue" this]
        (ß PersistentQueue'EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentQueue" withMeta [#_"PersistentQueue" this, #_"IPersistentMap" ___meta]
        (PersistentQueue'new ___meta, (:cnt this), (:f this), (:r this))
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"PersistentQueue" this]
        (ß RT'seqToArray(seq()))
    )

    #_method
    (§ defn #_"boolean" add [#_"PersistentQueue" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" remove [#_"PersistentQueue" this, #_"Object" ___o]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" addAll [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"void" clear [#_"PersistentQueue" this]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" retainAll [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" removeAll [#_"PersistentQueue" this, #_"Collection" ___c]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (§ defn #_"boolean" containsAll [#_"PersistentQueue" this, #_"Collection" ___c]
        (doseq [#_"Object" ___o ___c]
            (when (ß contains(___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Object[]" toArray [#_"PersistentQueue" this, #_"Object[]" ___a]
        (ß RT'seqToPassedArray(seq(), ___a))
    )

    #_method
    (§ defn #_"int" size [#_"PersistentQueue" this]
        (ß count())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"PersistentQueue" this]
        (ß (count() == 0))
    )

    #_method
    (§ defn #_"boolean" contains [#_"PersistentQueue" this, #_"Object" ___o]
        (loop-when-recur [#_"ISeq" ___s (ß seq())] (some? ___s) [(ß ___s.next())]
            (when (ß Util'equiv-2oo(___s.first(), ___o))
                (§ return true)
            )
        )
        false
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentQueue" this]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"ISeq" :fseq (:f this)
                    #_"Iterator" :riter (ß ((:r this) != nil) ? (:r this).iterator() :or nil)
                )
            )

            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (ß (((:fseq this) != nil && (:fseq this).seq() != nil) || ((:riter this) != nil && (:riter this).hasNext())))
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (cond (some? (:fseq this))
                    (do
                        (let [#_"Object" ___ret (ß (:fseq this).first())]
                            (§ ass (:fseq this) (ß (:fseq this).next()))
                            ___ret
                        )
                    )
                    (ß (:riter this) != nil && (:riter this).hasNext())
                    (do
                        (ß (:riter this).next())
                    )
                    :else
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )
)
)

(java-ns cloiure.lang.PersistentTreeMap

(§ import java.util.*)

#_abstract
(class-ns TNode (§ extends AMapEntry)
    (defn- #_"TNode" TNode'init []
        (hash-map
            #_"Object" :key nil
        )
    )

    (defn #_"TNode" TNode'new [#_"Object" ___key]
        (let [this (merge (AMapEntry'new) (TNode'init))]
            (§ ass (:key this) ___key)
            this
        )
    )

    #_method
    (§ defn #_"Object" key [#_"TNode" this]
        (:key this)
    )

    #_method
    (§ defn #_"Object" val [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"Object" getKey [#_"TNode" this]
        (ß key())
    )

    #_method
    (§ defn #_"Object" getValue [#_"TNode" this]
        (ß val())
    )

    #_method
    (§ defn #_"TNode" left [#_"TNode" this]
        nil
    )

    #_method
    (§ defn #_"TNode" right [#_"TNode" this]
        nil
    )

    #_abstract
    (§ defn #_"TNode" addLeft [#_"TNode" this, #_"TNode" ___ins])
    #_abstract
    (§ defn #_"TNode" addRight [#_"TNode" this, #_"TNode" ___ins])
    #_abstract
    (§ defn #_"TNode" removeLeft [#_"TNode" this, #_"TNode" ___del])
    #_abstract
    (§ defn #_"TNode" removeRight [#_"TNode" this, #_"TNode" ___del])
    #_abstract
    (§ defn #_"TNode" blacken [#_"TNode" this])
    #_abstract
    (§ defn #_"TNode" redden [#_"TNode" this])

    #_method
    (§ defn #_"TNode" balanceLeft [#_"TNode" this, #_"TNode" ___parent]
        (ß black((:key ___parent), ___parent.val(), this, ___parent.right()))
    )

    #_method
    (§ defn #_"TNode" balanceRight [#_"TNode" this, #_"TNode" ___parent]
        (ß black((:key ___parent), ___parent.val(), ___parent.left(), this))
    )

    #_abstract
    (§ defn #_"TNode" replace [#_"TNode" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right])

    #_method
    (§ defn #_"Object" kvreduce [#_"TNode" this, #_"IFn" ___f, #_"Object" ___init]
        (when (ß left() != nil)
            (§ ass ___init (ß left().kvreduce(___f, ___init)))
            (when (RT'isReduced ___init)
                (§ return ___init)
            )
        )
        (§ ass ___init (ß ___f.invoke(___init, key(), val())))
        (when (RT'isReduced ___init)
            (§ return ___init)
        )

        (when (ß right() != nil)
            (§ ass ___init (ß right().kvreduce(___f, ___init)))
        )
        ___init
    )
)

#_stateless
(class-ns Black (§ extends TNode)
    (defn #_"Black" Black'new [#_"Object" ___key]
        (TNode'new ___key)
    )

    #_method
    (§ defn #_"TNode" addLeft [#_"Black" this, #_"TNode" ___ins]
        (ß ___ins.balanceLeft(this))
    )

    #_method
    (§ defn #_"TNode" addRight [#_"Black" this, #_"TNode" ___ins]
        (ß ___ins.balanceRight(this))
    )

    #_method
    (§ defn #_"TNode" removeLeft [#_"Black" this, #_"TNode" ___del]
        (ß balanceLeftDel((:key this), val(), ___del, right()))
    )

    #_method
    (§ defn #_"TNode" removeRight [#_"Black" this, #_"TNode" ___del]
        (ß balanceRightDel((:key this), val(), left(), ___del))
    )

    #_method
    (§ defn #_"TNode" blacken [#_"Black" this]
        this
    )

    #_method
    (§ defn #_"TNode" redden [#_"Black" this]
        (Red'new (:key this))
    )

    #_method
    (§ defn #_"TNode" replace [#_"Black" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (ß black(___key, ___val, ___left, ___right))
    )
)

(class-ns BlackVal (§ extends Black)
    (defn- #_"BlackVal" BlackVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackVal" BlackVal'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (Black'new ___key) (BlackVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"BlackVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" redden [#_"BlackVal" this]
        (RedVal'new (:key this), (:val this))
    )
)

(class-ns BlackBranch (§ extends Black)
    (defn- #_"BlackBranch" BlackBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"BlackBranch" BlackBranch'new [#_"Object" ___key, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (Black'new ___key) (BlackBranch'init))]
            (§ ass (:left this) ___left)
            (§ ass (:right this) ___right)
            this
        )
    )

    #_method
    (§ defn #_"TNode" left [#_"BlackBranch" this]
        (:left this)
    )

    #_method
    (§ defn #_"TNode" right [#_"BlackBranch" this]
        (:right this)
    )

    #_method
    (§ defn #_"TNode" redden [#_"BlackBranch" this]
        (RedBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns BlackBranchVal (§ extends BlackBranch)
    (defn- #_"BlackBranchVal" BlackBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"BlackBranchVal" BlackBranchVal'new [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (BlackBranch'new ___key, ___left, ___right) (BlackBranchVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"BlackBranchVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" redden [#_"BlackBranchVal" this]
        (RedBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

#_stateless
(class-ns Red (§ extends TNode)
    (defn #_"Red" Red'new [#_"Object" ___key]
        (TNode'new ___key)
    )

    #_method
    (§ defn #_"TNode" addLeft [#_"Red" this, #_"TNode" ___ins]
        (ß red((:key this), val(), ___ins, right()))
    )

    #_method
    (§ defn #_"TNode" addRight [#_"Red" this, #_"TNode" ___ins]
        (ß red((:key this), val(), left(), ___ins))
    )

    #_method
    (§ defn #_"TNode" removeLeft [#_"Red" this, #_"TNode" ___del]
        (ß red((:key this), val(), ___del, right()))
    )

    #_method
    (§ defn #_"TNode" removeRight [#_"Red" this, #_"TNode" ___del]
        (ß red((:key this), val(), left(), ___del))
    )

    #_method
    (§ defn #_"TNode" blacken [#_"Red" this]
        (Black'new (:key this))
    )

    #_method
    (§ defn #_"TNode" redden [#_"Red" this]
        (throw (UnsupportedOperationException. "Invariant violation"))
    )

    #_method
    (§ defn #_"TNode" replace [#_"Red" this, #_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (ß red(___key, ___val, ___left, ___right))
    )
)

(class-ns RedVal (§ extends Red)
    (defn- #_"RedVal" RedVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedVal" RedVal'new [#_"Object" ___key, #_"Object" ___val]
        (let [this (merge (Red'new ___key) (RedVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"RedVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" blacken [#_"RedVal" this]
        (BlackVal'new (:key this), (:val this))
    )
)

(class-ns RedBranch (§ extends Red)
    (defn- #_"RedBranch" RedBranch'init []
        (hash-map
            #_"TNode" :left nil
            #_"TNode" :right nil
        )
    )

    (defn #_"RedBranch" RedBranch'new [#_"Object" ___key, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (Red'new ___key) (RedBranch'init))]
            (§ ass (:left this) ___left)
            (§ ass (:right this) ___right)
            this
        )
    )

    #_method
    (§ defn #_"TNode" left [#_"RedBranch" this]
        (:left this)
    )

    #_method
    (§ defn #_"TNode" right [#_"RedBranch" this]
        (:right this)
    )

    #_method
    (§ defn #_"TNode" balanceLeft [#_"RedBranch" this, #_"TNode" ___parent]
        (cond (ß (:left this) instanceof Red)
            (do
                (ß red((:key this), val(), (:left this).blacken(), black((:key ___parent), ___parent.val(), (:right this), ___parent.right())))
            )
            (ß (:right this) instanceof Red)
            (do
                (ß red((:right this).key, (:right this).val(), black((:key this), val(), (:left this), (:right this).left()), black((:key ___parent), ___parent.val(), (:right this).right(), ___parent.right())))
            )
            :else
            (do
                (ß super.balanceLeft(___parent))
            )
        )
    )

    #_method
    (§ defn #_"TNode" balanceRight [#_"RedBranch" this, #_"TNode" ___parent]
        (cond (ß (:right this) instanceof Red)
            (do
                (ß red((:key this), val(), black((:key ___parent), ___parent.val(), ___parent.left(), (:left this)), (:right this).blacken()))
            )
            (ß (:left this) instanceof Red)
            (do
                (ß red((:left this).key, (:left this).val(), black((:key ___parent), ___parent.val(), ___parent.left(), (:left this).left()), black((:key this), val(), (:left this).right(), (:right this))))
            )
            :else
            (do
                (ß super.balanceRight(___parent))
            )
        )
    )

    #_method
    (§ defn #_"TNode" blacken [#_"RedBranch" this]
        (BlackBranch'new (:key this), (:left this), (:right this))
    )
)

(class-ns RedBranchVal (§ extends RedBranch)
    (defn- #_"RedBranchVal" RedBranchVal'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"RedBranchVal" RedBranchVal'new [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (let [this (merge (RedBranch'new ___key, ___left, ___right) (RedBranchVal'init))]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" val [#_"RedBranchVal" this]
        (:val this)
    )

    #_method
    (§ defn #_"TNode" blacken [#_"RedBranchVal" this]
        (BlackBranchVal'new (:key this), (:val this), (:left this), (:right this))
    )
)

(class-ns TSeq (§ extends ASeq)
    (defn- #_"TSeq" TSeq'init []
        (hash-map
            #_"ISeq" :stack nil
            #_"boolean" :asc false
            #_"int" :cnt 0
        )
    )

    (defn #_"TSeq" TSeq'new-2 [#_"ISeq" ___stack, #_"boolean" ___asc]
        (let [this (merge (ASeq'new) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) -1)
            this
        )
    )

    (defn #_"TSeq" TSeq'new-3 [#_"ISeq" ___stack, #_"boolean" ___asc, #_"int" ___cnt]
        (let [this (merge (ASeq'new) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) ___cnt)
            this
        )
    )

    (defn #_"TSeq" TSeq'new-4 [#_"IPersistentMap" ___meta, #_"ISeq" ___stack, #_"boolean" ___asc, #_"int" ___cnt]
        (let [this (merge (ASeq'new ___meta) (TSeq'init))]
            (§ ass (:stack this) ___stack)
            (§ ass (:asc this) ___asc)
            (§ ass (:cnt this) ___cnt)
            this
        )
    )

    (defn #_"TSeq" TSeq'create [#_"TNode" ___t, #_"boolean" ___asc, #_"int" ___cnt]
        (ß TSeq'new-3(TSeq'push(___t, nil, ___asc), ___asc, ___cnt))
    )

    (defn #_"ISeq" TSeq'push [#_"TNode" ___t, #_"ISeq" ___stack, #_"boolean" ___asc]
        (while (some? ___t)
            (§ ass ___stack (RT'cons ___t, ___stack))
            (§ ass ___t (ß ___asc ? ___t.left() :or ___t.right()))
        )
        ___stack
    )

    #_method
    (§ defn #_"Object" first [#_"TSeq" this]
        (ß (:stack this).first())
    )

    #_method
    (§ defn #_"ISeq" next [#_"TSeq" this]
        (let [#_"TNode" ___t (ß (TNode) (:stack this).first())]
            (let [#_"ISeq" ___nextstack (ß TSeq'push((:asc this) ? ___t.right() :or ___t.left(), (:stack this).next(), (:asc this)))]
                (when (some? ___nextstack)
                    (§ return (ß TSeq'new-3(___nextstack, (:asc this), (:cnt this) - 1)))
                )
                nil
            )
        )
    )

    #_method
    (§ defn #_"int" count [#_"TSeq" this]
        (when (< (:cnt this) 0)
            (§ return (ß super.count()))
        )
        (:cnt this)
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"TSeq" this, #_"IPersistentMap" ___meta]
        (TSeq'new-4 ___meta, (:stack this), (:asc this), (:cnt this))
    )
)

(class-ns NodeIterator (§ implements Iterator)
    (defn- #_"NodeIterator" NodeIterator'init []
        (hash-map
            #_"Stack" :stack (Stack.)
            #_"boolean" :asc false
        )
    )

    (defn #_"NodeIterator" NodeIterator'new [#_"TNode" ___t, #_"boolean" ___asc]
        (let [this (NodeIterator'init)]
            (§ ass (:asc this) ___asc)
            (ß push(___t))
            this
        )
    )

    #_method
    (§ defn #_"void" push [#_"NodeIterator" this, #_"TNode" ___t]
        (while (some? ___t)
            (ß (:stack this).push(___t))
            (§ ass ___t (ß (:asc this) ? ___t.left() :or ___t.right()))
        )
        nil
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"NodeIterator" this]
        (ß !this.stack.isEmpty())
    )

    #_method
    (§ defn #_"Object" next [#_"NodeIterator" this]
        (try
            (let [#_"TNode" ___t (ß (TNode) (:stack this).pop())]
                (ß push((:asc this) ? ___t.right() :or ___t.left()))
                ___t
            )
            (catch EmptyStackException ___e
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"NodeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns KeyIterator (§ implements Iterator)
    (defn- #_"KeyIterator" KeyIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"KeyIterator" KeyIterator'new [#_"NodeIterator" ___it]
        (let [this (KeyIterator'init)]
            (§ ass (:it this) ___it)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"KeyIterator" this]
        (ß (:it this).hasNext())
    )

    #_method
    (§ defn #_"Object" next [#_"KeyIterator" this]
        (ß ((TNode) (:it this).next()).key)
    )

    #_method
    (§ defn #_"void" remove [#_"KeyIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns ValIterator (§ implements Iterator)
    (defn- #_"ValIterator" ValIterator'init []
        (hash-map
            #_"NodeIterator" :it nil
        )
    )

    (defn #_"ValIterator" ValIterator'new [#_"NodeIterator" ___it]
        (let [this (ValIterator'init)]
            (§ ass (:it this) ___it)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"ValIterator" this]
        (ß (:it this).hasNext())
    )

    #_method
    (§ defn #_"Object" next [#_"ValIterator" this]
        (ß ((TNode) (:it this).next()).val())
    )

    #_method
    (§ defn #_"void" remove [#_"ValIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Persistent Red Black Tree
 ; Note that instances of this class are constant values
 ; i.e. add/remove etc return new values
 ;
 ; See Okasaki, Kahrs, Larsen et al
 ;;
(class-ns PersistentTreeMap (§ extends APersistentMap) (§ implements IObj, Reversible, Sorted, IKVReduce)
    (§ def #_"PersistentTreeMap" PersistentTreeMap'EMPTY (PersistentTreeMap'new-0))

    (defn #_"IPersistentMap" PersistentTreeMap'create-1m [#_"Map" ___other]
        (let [#_"IPersistentMap" ___ret PersistentTreeMap'EMPTY]
            (doseq [#_"Object" ___o (ß ___other.entrySet())]
                (let [#_"Map$Entry" ___e (ß (Entry) ___o)]
                    (§ ass ___ret (ß ___ret.assoc(___e.getKey(), ___e.getValue())))
                )
            )
            ___ret
        )
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'init []
        (hash-map
            #_"Comparator" :comp nil
            #_"TNode" :tree nil
            #_"int" :_count 0
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-0 []
        (PersistentTreeMap'new-1 RT'DEFAULT_COMPARATOR)
    )

    (defn- #_"PersistentTreeMap" PersistentTreeMap'new-1 [#_"Comparator" ___comp]
        (PersistentTreeMap'new-2 nil, ___comp)
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-2 [#_"IPersistentMap" ___meta, #_"Comparator" ___comp]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:comp this) ___comp)
            (§ ass (:_meta this) ___meta)
            (§ ass (:tree this) nil)
            (§ ass (:_count this) 0)
            this
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4m [#_"IPersistentMap" ___meta, #_"Comparator" ___comp, #_"TNode" ___tree, #_"int" ____count]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:comp this) ___comp)
            (§ ass (:tree this) ___tree)
            (§ ass (:_count this) ____count)
            this
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" withMeta [#_"PersistentTreeMap" this, #_"IPersistentMap" ___meta]
        (PersistentTreeMap'new-4m ___meta, (:comp this), (:tree this), (:_count this))
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-1s [#_"ISeq" ___items]
        (let [#_"IPersistentMap" ___ret PersistentTreeMap'EMPTY]
            (loop-when-recur [___items ___items] (some? ___items) [(ß ___items.next().next())]
                (when (ß ___items.next() == nil)
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (§ array (ß ___items.first())))))
                )
                (§ ass ___ret (ß ___ret.assoc(___items.first(), RT'second(___items))))
            )
            (ß (PersistentTreeMap) ___ret)
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'create-2 [#_"Comparator" ___comp, #_"ISeq" ___items]
        (let [#_"IPersistentMap" ___ret (PersistentTreeMap'new-1 ___comp)]
            (loop-when-recur [___items ___items] (some? ___items) [(ß ___items.next().next())]
                (when (ß ___items.next() == nil)
                    (throw (IllegalArgumentException. (String/format "No value supplied for key: %s", (§ array (ß ___items.first())))))
                )
                (§ ass ___ret (ß ___ret.assoc(___items.first(), RT'second(___items))))
            )
            (ß (PersistentTreeMap) ___ret)
        )
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"PersistentTreeMap" this, #_"Object" ___key]
        (ß (entryAt(___key) != nil))
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentTreeMap" this, #_"Object" ___obj]
        (try
            (ß super.equals(___obj))
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentTreeMap" this, #_"Object" ___obj]
        (try
            (ß super.equiv(___obj))
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" assocEx [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (ß add((:tree this), ___key, ___val, ___found))]
                (when (nil? ___t) ;; nil == already contains key
                    (throw (Util'runtimeException-1 "Key already present"))
                )
                (ß PersistentTreeMap'new-4c((:comp this), ___t.blacken(), (:_count this) + 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" assoc [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___val]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (ß add((:tree this), ___key, ___val, ___found))]
                (when (nil? ___t) ;; nil == already contains key
                    (let [#_"TNode" ___foundNode (ß (TNode) (:val ___found))]
                        (when (ß ___foundNode.val() == ___val) ;; note only get same collection on identity of val, not equals()
                            (§ return this)
                        )
                        (§ return (ß PersistentTreeMap'new-4c((:comp this), replace((:tree this), ___key, ___val), (:_count this), meta())))
                    )
                )
                (ß PersistentTreeMap'new-4c((:comp this), ___t.blacken(), (:_count this) + 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"PersistentTreeMap" without [#_"PersistentTreeMap" this, #_"Object" ___key]
        (let [#_"Box" ___found (Box'new nil)]
            (let [#_"TNode" ___t (ß remove((:tree this), ___key, ___found))]
                (when (nil? ___t)
                    (when (ß (:val ___found) == nil) ;; nil == doesn't contain key
                        (§ return this)
                    )
                    ;; empty
                    (§ return (ß PersistentTreeMap'new-2(meta(), (:comp this))))
                )
                (ß PersistentTreeMap'new-4c((:comp this), ___t.blacken(), (:_count this) - 1, meta()))
            )
        )
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeMap" this]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), true, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentTreeMap" this]
        (ß PersistentTreeMap'new-2(meta(), (:comp this)))
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"PersistentTreeMap" this]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), false, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"Comparator" comparator [#_"PersistentTreeMap" this]
        (:comp this)
    )

    #_method
    (§ defn #_"Object" entryKey [#_"PersistentTreeMap" this, #_"Object" ___entry]
        (ß ((IMapEntry) ___entry).key())
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeMap" this, #_"boolean" ___ascending]
        (when (> (:_count this) 0)
            (§ return (TSeq'create (:tree this), ___ascending, (:_count this)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" seqFrom [#_"PersistentTreeMap" this, #_"Object" ___key, #_"boolean" ___ascending]
        (when (> (:_count this) 0)
            (let [#_"ISeq" ___stack nil]
                (let [#_"TNode" ___t (:tree this)]
                    (while (some? ___t)
                        (let [#_"int" ___c (ß doCompare(___key, (:key ___t)))]
                            (cond (ß ___c == 0)
                                (do
                                    (§ ass ___stack (RT'cons ___t, ___stack))
                                    (§ return (TSeq'new-2 ___stack, ___ascending))
                                )
                                ___ascending
                                (do
                                    (if (< ___c 0)
                                        (do
                                            (§ ass ___stack (RT'cons ___t, ___stack))
                                            (§ ass ___t (ß ___t.left()))
                                        )
                                        (do
                                            (§ ass ___t (ß ___t.right()))
                                        )
                                    )
                                )
                                :else
                                (do
                                    (if (> ___c 0)
                                        (do
                                            (§ ass ___stack (RT'cons ___t, ___stack))
                                            (§ ass ___t (ß ___t.right()))
                                        )
                                        (do
                                            (§ ass ___t (ß ___t.left()))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when (some? ___stack)
                        (§ return (TSeq'new-2 ___stack, ___ascending))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"NodeIterator" iterator [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), true)
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentTreeMap" this, #_"IFn" ___f, #_"Object" ___init]
        (when (some? (:tree this))
            (§ ass ___init (ß (:tree this).kvreduce(___f, ___init)))
        )
        (when (RT'isReduced ___init)
            (§ ass ___init (ß ((IDeref)___init).deref()))
        )
        ___init
    )

    #_method
    (§ defn #_"NodeIterator" reverseIterator [#_"PersistentTreeMap" this]
        (NodeIterator'new (:tree this), false)
    )

    #_method
    (§ defn #_"Iterator" keys [#_"PersistentTreeMap" this]
        (ß keys(iterator()))
    )

    #_method
    (§ defn #_"Iterator" vals [#_"PersistentTreeMap" this]
        (ß vals(iterator()))
    )

    #_method
    (§ defn #_"Iterator" keys [#_"PersistentTreeMap" this, #_"NodeIterator" ___it]
        (KeyIterator'new ___it)
    )

    #_method
    (§ defn #_"Iterator" vals [#_"PersistentTreeMap" this, #_"NodeIterator" ___it]
        (ValIterator'new ___it)
    )

    #_method
    (§ defn #_"Object" minKey [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (ß min())]
            (ß (___t != nil) ? (:key ___t) :or nil)
        )
    )

    #_method
    (§ defn #_"TNode" min [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (:tree this)]
            (when (some? ___t)
                (while (ß ___t.left() != nil)
                    (§ ass ___t (ß ___t.left()))
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"Object" maxKey [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (ß max())]
            (ß (___t != nil) ? (:key ___t) :or nil)
        )
    )

    #_method
    (§ defn #_"TNode" max [#_"PersistentTreeMap" this]
        (let [#_"TNode" ___t (:tree this)]
            (when (some? ___t)
                (while (ß ___t.right() != nil)
                    (§ ass ___t (ß ___t.right()))
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"int" depth [#_"PersistentTreeMap" this]
        (ß depth((:tree this)))
    )

    #_method
    (§ defn #_"int" depth [#_"PersistentTreeMap" this, #_"TNode" ___t]
        (when (nil? ___t)
            (§ return 0)
        )
        (ß 1 + Math/max(depth(___t.left()), depth(___t.right())))
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentTreeMap" this, #_"Object" ___key, #_"Object" ___notFound]
        (let [#_"TNode" ___n (ß entryAt(___key))]
            (ß (___n != nil) ? ___n.val() :or ___notFound)
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"PersistentTreeMap" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"int" capacity [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_method
    (§ defn #_"int" count [#_"PersistentTreeMap" this]
        (:_count this)
    )

    #_method
    (§ defn #_"TNode" entryAt [#_"PersistentTreeMap" this, #_"Object" ___key]
        (let [#_"TNode" ___t (:tree this)]
            (while (some? ___t)
                (let [#_"int" ___c (ß doCompare(___key, (:key ___t)))]
                    (cond (ß ___c == 0)
                        (do
                            (§ return ___t)
                        )
                        (< ___c 0)
                        (do
                            (§ ass ___t (ß ___t.left()))
                        )
                        :else
                        (do
                            (§ ass ___t (ß ___t.right()))
                        )
                    )
                )
            )
            ___t
        )
    )

    #_method
    (§ defn #_"int" doCompare [#_"PersistentTreeMap" this, #_"Object" ___k1, #_"Object" ___k2]
        (ß (:comp this).compare(___k1, ___k2))
    )

    #_method
    (§ defn #_"TNode" add [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Object" ___val, #_"Box" ___found]
        (when (nil? ___t)
            (when (nil? ___val)
                (§ return (Red'new ___key))
            )
            (§ return (RedVal'new ___key, ___val))
        )
        (let [#_"int" ___c (ß doCompare(___key, (:key ___t)))]
            (when (ß ___c == 0)
                (§ ass (:val ___found) ___t)
                (§ return nil)
            )
            (let [#_"TNode" ___ins (ß (___c < 0) ? add(___t.left(), ___key, ___val, ___found) :or add(___t.right(), ___key, ___val, ___found))]
                (when (nil? ___ins) ;; found below
                    (§ return nil)
                )
                (when (< ___c 0)
                    (§ return (ß ___t.addLeft(___ins)))
                )
                (ß ___t.addRight(___ins))
            )
        )
    )

    #_method
    (§ defn #_"TNode" remove [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Box" ___found]
        (when (nil? ___t)
            (§ return nil) ;; not found indicator
        )
        (let [#_"int" ___c (ß doCompare(___key, (:key ___t)))]
            (when (ß ___c == 0)
                (§ ass (:val ___found) ___t)
                (§ return (ß append(___t.left(), ___t.right())))
            )
            (let [#_"TNode" ___del (ß (___c < 0) ? remove(___t.left(), ___key, ___found) :or remove(___t.right(), ___key, ___found))]
                (when (ß ___del == nil && (:val ___found) == nil) ;; not found below
                    (§ return nil)
                )
                (when (< ___c 0)
                    (if (ß ___t.left() instanceof Black)
                        (do
                            (§ return (ß balanceLeftDel((:key ___t), ___t.val(), ___del, ___t.right())))
                        )
                        (do
                            (§ return (ß red((:key ___t), ___t.val(), ___del, ___t.right())))
                        )
                    )
                )
                (when (ß ___t.right() instanceof Black)
                    (§ return (ß balanceRightDel((:key ___t), ___t.val(), ___t.left(), ___del)))
                )
                (ß red((:key ___t), ___t.val(), ___t.left(), ___del))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'append [#_"TNode" ___left, #_"TNode" ___right]
        (cond (nil? ___left)
            (do
                ___right
            )
            (nil? ___right)
            (do
                ___left
            )
            (ß ___left instanceof Red)
            (do
                (if (ß ___right instanceof Red)
                    (do
                        (let [#_"TNode" ___app (ß append(___left.right(), ___right.left()))]
                            (if (ß ___app instanceof Red)
                                (do
                                    (ß red((:key ___app), ___app.val(), red((:key ___left), ___left.val(), ___left.left(), ___app.left()), red((:key ___right), ___right.val(), ___app.right(), ___right.right())))
                                )
                                (do
                                    (ß red((:key ___left), ___left.val(), ___left.left(), red((:key ___right), ___right.val(), ___app, ___right.right())))
                                )
                            )
                        )
                    )
                    (do
                        (ß red((:key ___left), ___left.val(), ___left.left(), append(___left.right(), ___right)))
                    )
                )
            )
            (ß ___right instanceof Red)
            (do
                (ß red((:key ___right), ___right.val(), append(___left, ___right.left()), ___right.right()))
            )
            :else ;; black/black
            (do
                (let [#_"TNode" ___app (ß append(___left.right(), ___right.left()))]
                    (if (ß ___app instanceof Red)
                        (do
                            (ß red((:key ___app), ___app.val(), PersistentTreeMap'black((:key ___left), ___left.val(), ___left.left(), ___app.left()), PersistentTreeMap'black((:key ___right), ___right.val(), ___app.right(), ___right.right())))
                        )
                        (do
                            (ß balanceLeftDel((:key ___left), ___left.val(), ___left.left(), PersistentTreeMap'black((:key ___right), ___right.val(), ___app, ___right.right())))
                        )
                    )
                )
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceLeftDel [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___del, #_"TNode" ___right]
        (cond (ß ___del instanceof Red)
            (do
                (ß red(___key, ___val, ___del.blacken(), ___right))
            )
            (ß ___right instanceof Black)
            (do
                (ß rightBalance(___key, ___val, ___del, ___right.redden()))
            )
            (ß ___right instanceof Red && ___right.left() instanceof Black)
            (do
                (ß red(___right.left().key, ___right.left().val(), PersistentTreeMap'black(___key, ___val, ___del, ___right.left().left()), rightBalance((:key ___right), ___right.val(), ___right.left().right(), ___right.right().redden())))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'balanceRightDel [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___del]
        (cond (ß ___del instanceof Red)
            (do
                (ß red(___key, ___val, ___left, ___del.blacken()))
            )
            (ß ___left instanceof Black)
            (do
                (ß leftBalance(___key, ___val, ___left.redden(), ___del))
            )
            (ß ___left instanceof Red && ___left.right() instanceof Black)
            (do
                (ß red(___left.right().key, ___left.right().val(), leftBalance((:key ___left), ___left.val(), ___left.left().redden(), ___left.right().left()), PersistentTreeMap'black(___key, ___val, ___left.right().right(), ___del)))
            )
            :else
            (do
                (throw (UnsupportedOperationException. "Invariant violation"))
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'leftBalance [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___ins, #_"TNode" ___right]
        (cond (ß ___ins instanceof Red && ___ins.left() instanceof Red)
            (do
                (ß red((:key ___ins), ___ins.val(), ___ins.left().blacken(), PersistentTreeMap'black(___key, ___val, ___ins.right(), ___right)))
            )
            (ß ___ins instanceof Red && ___ins.right() instanceof Red)
            (do
                (ß red(___ins.right().key, ___ins.right().val(), PersistentTreeMap'black((:key ___ins), ___ins.val(), ___ins.left(), ___ins.right().left()), PersistentTreeMap'black(___key, ___val, ___ins.right().right(), ___right)))
            )
            :else
            (do
                (PersistentTreeMap'black ___key, ___val, ___ins, ___right)
            )
        )
    )

    (defn #_"TNode" PersistentTreeMap'rightBalance [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___ins]
        (cond (ß ___ins instanceof Red && ___ins.right() instanceof Red)
            (do
                (ß red((:key ___ins), ___ins.val(), PersistentTreeMap'black(___key, ___val, ___left, ___ins.left()), ___ins.right().blacken()))
            )
            (ß ___ins instanceof Red && ___ins.left() instanceof Red)
            (do
                (ß red(___ins.left().key, ___ins.left().val(), PersistentTreeMap'black(___key, ___val, ___left, ___ins.left().left()), PersistentTreeMap'black((:key ___ins), ___ins.val(), ___ins.left().right(), ___ins.right())))
            )
            :else
            (do
                (PersistentTreeMap'black ___key, ___val, ___left, ___ins)
            )
        )
    )

    #_method
    (§ defn #_"TNode" replace [#_"PersistentTreeMap" this, #_"TNode" ___t, #_"Object" ___key, #_"Object" ___val]
        (let [#_"int" ___c (ß doCompare(___key, (:key ___t)))]
            (ß ___t.replace((:key ___t), (___c == 0) ? ___val :or ___t.val(), (___c < 0) ? replace(___t.left(), ___key, ___val) :or ___t.left(), (___c > 0) ? replace(___t.right(), ___key, ___val) :or ___t.right()))
        )
    )

    (defn #_"PersistentTreeMap" PersistentTreeMap'new-4c [#_"Comparator" ___comp, #_"TNode" ___tree, #_"int" ___count, #_"IPersistentMap" ___meta]
        (let [this (merge (APersistentMap'new) (PersistentTreeMap'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:comp this) ___comp)
            (§ ass (:tree this) ___tree)
            (§ ass (:_count this) ___count)
            this
        )
    )

    (defn #_"Red" PersistentTreeMap'red [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (when (ß ___left == nil && ___right == nil)
            (when (nil? ___val)
                (§ return (Red'new ___key))
            )
            (§ return (RedVal'new ___key, ___val))
        )
        (when (nil? ___val)
            (§ return (RedBranch'new ___key, ___left, ___right))
        )
        (RedBranchVal'new ___key, ___val, ___left, ___right)
    )

    (defn #_"Black" PersistentTreeMap'black [#_"Object" ___key, #_"Object" ___val, #_"TNode" ___left, #_"TNode" ___right]
        (when (ß ___left == nil && ___right == nil)
            (when (nil? ___val)
                (§ return (Black'new ___key))
            )
            (§ return (BlackVal'new ___key, ___val))
        )
        (when (nil? ___val)
            (§ return (BlackBranch'new ___key, ___left, ___right))
        )
        (BlackBranchVal'new ___key, ___val, ___left, ___right)
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentTreeMap" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentTreeSet

(§ import java.util.Comparator)

(class-ns PersistentTreeSet (§ extends APersistentSet) (§ implements IObj, Reversible, Sorted)
    (§ def #_"PersistentTreeSet" PersistentTreeSet'EMPTY (PersistentTreeSet'new nil, PersistentTreeMap'EMPTY))

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-1 [#_"ISeq" ___items]
        (let [#_"PersistentTreeSet" ___ret PersistentTreeSet'EMPTY]
            (loop-when-recur [___items ___items] (some? ___items) [(ß ___items.next())]
                (§ ass ___ret (ß (PersistentTreeSet) ___ret.cons(___items.first())))
            )
            ___ret
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'create-2 [#_"Comparator" ___comp, #_"ISeq" ___items]
        (let [#_"PersistentTreeSet" ___ret (ß PersistentTreeSet'new(nil, PersistentTreeMap'new-2(nil, ___comp)))]
            (loop-when-recur [___items ___items] (some? ___items) [(ß ___items.next())]
                (§ ass ___ret (ß (PersistentTreeSet) ___ret.cons(___items.first())))
            )
            ___ret
        )
    )

    (defn- #_"PersistentTreeSet" PersistentTreeSet'init []
        (hash-map
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentTreeSet" PersistentTreeSet'new [#_"IPersistentMap" ___meta, #_"IPersistentMap" ___impl]
        (let [this (merge (APersistentSet'new ___impl) (PersistentTreeSet'init))]
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"PersistentTreeSet" this, #_"Object" ___obj]
        (try
            (ß super.equals(___obj))
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"boolean" equiv [#_"PersistentTreeSet" this, #_"Object" ___obj]
        (try
            (ß super.equiv(___obj))
            (catch ClassCastException ___e
                false
            )
        )
    )

    #_method
    (§ defn #_"IPersistentSet" disjoin [#_"PersistentTreeSet" this, #_"Object" ___key]
        (when (ß contains(___key))
            (§ return (ß PersistentTreeSet'new(meta(), (:impl this).without(___key))))
        )
        this
    )

    #_method
    (§ defn #_"IPersistentSet" cons [#_"PersistentTreeSet" this, #_"Object" ___o]
        (when (ß contains(___o))
            (§ return this)
        )
        (ß PersistentTreeSet'new(meta(), (:impl this).assoc(___o, ___o)))
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentTreeSet" this]
        (ß PersistentTreeSet'new(meta(), (PersistentTreeMap)this.impl.empty()))
    )

    #_method
    (§ defn #_"ISeq" rseq [#_"PersistentTreeSet" this]
        (ß KeySeq'create(((Reversible) (:impl this)).rseq()))
    )

    #_method
    (§ defn #_"PersistentTreeSet" withMeta [#_"PersistentTreeSet" this, #_"IPersistentMap" ___meta]
        (PersistentTreeSet'new ___meta, (:impl this))
    )

    #_method
    (§ defn #_"Comparator" comparator [#_"PersistentTreeSet" this]
        (ß ((Sorted)this.impl).comparator())
    )

    #_method
    (§ defn #_"Object" entryKey [#_"PersistentTreeSet" this, #_"Object" ___entry]
        ___entry
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentTreeSet" this, #_"boolean" ___ascending]
        (let [#_"PersistentTreeMap" ___m (ß (PersistentTreeMap) (:impl this))]
            (ß RT'keys(___m.seq(___ascending)))
        )
    )

    #_method
    (§ defn #_"ISeq" seqFrom [#_"PersistentTreeSet" this, #_"Object" ___key, #_"boolean" ___ascending]
        (let [#_"PersistentTreeMap" ___m (ß (PersistentTreeMap) (:impl this))]
            (ß RT'keys(___m.seqFrom(___key, ___ascending)))
        )
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentTreeSet" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.PersistentVector

(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.concurrent.atomic.AtomicReference)

(class-ns VNode
    (defn- #_"VNode" VNode'init []
        (hash-map
            #_transient
            #_"AtomicReference<Thread>" :edit nil
            #_"Object[]" :array nil
        )
    )

    (defn #_"VNode" VNode'new-2 [#_"AtomicReference<Thread>" ___edit, #_"Object[]" ___array]
        (let [this (VNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:array this) ___array)
            this
        )
    )

    (defn #_"VNode" VNode'new-1 [#_"AtomicReference<Thread>" ___edit]
        (let [this (VNode'init)]
            (§ ass (:edit this) ___edit)
            (§ ass (:array this) (make-array Object 32))
            this
        )
    )
)

(class-ns ChunkedSeq (§ extends ASeq) (§ implements IChunkedSeq, Counted)
    (defn- #_"ChunkedSeq" ChunkedSeq'init []
        (hash-map
            #_"PersistentVector" :vec nil
            #_"Object[]" :node nil
            #_"int" :i 0
            #_"int" :offset 0
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-3 [#_"PersistentVector" ___vec, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            (§ ass (:node this) (ß ___vec.arrayFor(___i)))
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-5 [#_"IPersistentMap" ___meta, #_"PersistentVector" ___vec, #_"Object[]" ___node, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new ___meta) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:node this) ___node)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            this
        )
    )

    (defn #_"ChunkedSeq" ChunkedSeq'new-4 [#_"PersistentVector" ___vec, #_"Object[]" ___node, #_"int" ___i, #_"int" ___offset]
        (let [this (merge (ASeq'new) (ChunkedSeq'init))]
            (§ ass (:vec this) ___vec)
            (§ ass (:node this) ___node)
            (§ ass (:i this) ___i)
            (§ ass (:offset this) ___offset)
            this
        )
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"ChunkedSeq" this]
        (ArrayChunk'new-2 (:node this), (:offset this))
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"ChunkedSeq" this]
        (when (ß (:i this) + (:node this).length < (:vec this).cnt)
            (§ return (ß ChunkedSeq'new-3((:vec this), (:i this) + (:node this).length, 0)))
        )
        nil
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"ChunkedSeq" this]
        (let [#_"ISeq" ___s (ß chunkedNext())]
            (when (nil? ___s)
                (§ return PersistentList'EMPTY)
            )
            ___s
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"ChunkedSeq" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (ChunkedSeq'new-5 ___meta, (:vec this), (:node this), (:i this), (:offset this))
    )

    #_method
    (§ defn #_"Object" first [#_"ChunkedSeq" this]
        (ß (:node this)[(:offset this)])
    )

    #_method
    (§ defn #_"ISeq" next [#_"ChunkedSeq" this]
        (when (ß (:offset this) + 1 < (:node this).length)
            (§ return (ß ChunkedSeq'new-4((:vec this), (:node this), (:i this), (:offset this) + 1)))
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"int" count [#_"ChunkedSeq" this]
        (ß (:vec this).cnt - ((:i this) + (:offset this)))
    )
)

(class-ns TransientVector (§ extends AFn) (§ implements ITransientVector, ITransientAssociative2, Counted)
    (defn- #_"TransientVector" TransientVector'init []
        (hash-map
            #_volatile
            #_"int" :cnt 0
            #_volatile
            #_"int" :shift 0
            #_volatile
            #_"VNode" :root nil
            #_volatile
            #_"Object[]" :tail nil
        )
    )

    (defn #_"TransientVector" TransientVector'new-4 [#_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (AFn'new) (TransientVector'init))]
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    (defn #_"TransientVector" TransientVector'new-1 [#_"PersistentVector" ___v]
        (TransientVector'new-4 (§ pars (:cnt ___v), (:shift ___v), editableRoot((:root ___v)), editableTail((:tail ___v))))
    )

    #_method
    (§ defn #_"int" count [#_"TransientVector" this]
        (ß ensureEditable())
        (:cnt this)
    )

    #_method
    (§ defn #_"VNode" ensureEditable [#_"TransientVector" this, #_"VNode" ___node]
        (when (ß (:edit ___node) == (:root this).edit)
            (§ return ___node)
        )
        (ß VNode'new-2((:root this).edit, (:array ___node).clone()))
    )

    #_method
    (§ defn #_"void" ensureEditable [#_"TransientVector" this]
        (when (ß (:root this).edit.get() == nil)
            (throw (IllegalAccessError. "Transient used after persistent! call"))
        )
        nil
    )

    (defn #_"VNode" TransientVector'editableRoot [#_"VNode" ___node]
        (ß VNode'new-2(new AtomicReference<Thread>(Thread/currentThread()), (:array ___node).clone()))
    )

    #_method
    (§ defn #_"PersistentVector" persistent [#_"TransientVector" this]
        (ß ensureEditable())
        (ß (:root this).edit.set(nil))
        (let [#_"Object[]" ___trimmedTail (make-array Object (ß (:cnt this) - tailoff()))]
            (ß System/arraycopy((:tail this), 0, ___trimmedTail, 0, ___trimmedTail.length))
            (PersistentVector'new-4 (:cnt this), (:shift this), (:root this), ___trimmedTail)
        )
    )

    (defn #_"Object[]" TransientVector'editableTail [#_"Object[]" ___tl]
        (let [#_"Object[]" ___ret (make-array Object 32)]
            (ß System/arraycopy(___tl, 0, ___ret, 0, ___tl.length))
            ___ret
        )
    )

    #_method
    (§ defn #_"TransientVector" conj [#_"TransientVector" this, #_"Object" ___val]
        (ß ensureEditable())
        (let [#_"int" ___i (:cnt this)]
            ;; room in tail?
            (when (ß ___i - tailoff() < 32)
                (§ ass (ß (:tail this)[___i & 0x01f]) ___val)
                (§ ass (:cnt this) (+ (:cnt this) 1))
                (§ return this)
            )
            ;; full tail, push into tree
            (§ let [#_"VNode" ___newroot]
                (let [#_"VNode" ___tailnode (ß VNode'new-2((:root this).edit, (:tail this)))]
                    (§ ass (:tail this) (make-array Object 32))
                    (§ ass (ß (:tail this)[0]) ___val)
                    (let [#_"int" ___newshift (:shift this)]
                        ;; overflow root?
                        (if (ß ((:cnt this) >>> 5) > (1 << (:shift this)))
                            (do
                                (§ ass ___newroot (VNode'new-1 (ß (:root this).edit)))
                                (§ ass (ß (:array ___newroot)[0]) (:root this))
                                (§ ass (ß (:array ___newroot)[1]) (ß newPath((:root this).edit, (:shift this), ___tailnode)))
                                (§ ass ___newshift (+ ___newshift 5))
                            )
                            (do
                                (§ ass ___newroot (ß pushTail((:shift this), (:root this), ___tailnode)))
                            )
                        )
                        (§ ass (:root this) ___newroot)
                        (§ ass (:shift this) ___newshift)
                        (§ ass (:cnt this) (+ (:cnt this) 1))
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" pushTail [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___parent, #_"VNode" ___tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in parent
        (§ ass ___parent (ß ensureEditable(___parent)))
        (let [#_"int" ___subidx (ß (((:cnt this) - 1) >>> ___level) & 0x01f)]
            (let [#_"VNode" ___ret ___parent]
                (§ let [#_"VNode" ___nodeToInsert]
                    (if (ß ___level == 5)
                        (do
                            (§ ass ___nodeToInsert ___tailnode)
                        )
                        (do
                            (let [#_"VNode" ___child (ß (VNode) (:array ___parent)[___subidx])]
                                (§ ass ___nodeToInsert (ß (___child != nil) ? pushTail(___level - 5, ___child, ___tailnode) :or newPath((:root this).edit, ___level - 5, ___tailnode)))
                            )
                        )
                    )
                    (§ ass (ß (:array ___ret)[___subidx]) ___nodeToInsert)
                    ___ret
                )
            )
        )
    )

    #_method
    (§ defn- #_"int" tailoff [#_"TransientVector" this]
        (when (< (:cnt this) 32)
            (§ return 0)
        )
        (ß (((:cnt this) - 1) >>> 5) << 5)
    )

    #_method
    (§ defn- #_"Object[]" arrayFor [#_"TransientVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= tailoff())
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (ß (VNode) (:array ___node)[(___i >>> ___level) & 0x01f]))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn- #_"Object[]" editableArrayFor [#_"TransientVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= tailoff())
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (ß ensureEditable((VNode) (:array ___node)[(___i >>> ___level) & 0x01f])))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" valAt [#_"TransientVector" this, #_"Object" ___key]
        ;; note - relies on ensureEditable in 2-arg valAt
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [#_"TransientVector" this, #_"Object" ___key, #_"Object" ___notFound]
        (ß ensureEditable())
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (when (ß ___i >= 0 && ___i < (:cnt this))
                    (§ return (ß nth(___i)))
                )
            )
        )
        ___notFound
    )

    (def- #_"Object" TransientVector'NOT_FOUND (Object.))

    #_method
    (§ defn #_"boolean" containsKey [#_"TransientVector" this, #_"Object" ___key]
        (ß (valAt(___key, TransientVector'NOT_FOUND) != TransientVector'NOT_FOUND))
    )

    #_method
    (§ defn #_"IMapEntry" entryAt [#_"TransientVector" this, #_"Object" ___key]
        (let [#_"Object" ___v (ß valAt(___key, TransientVector'NOT_FOUND))]
            (when (ß ___v != TransientVector'NOT_FOUND)
                (§ return (MapEntry'create ___key, ___v))
            )
            nil
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"TransientVector" this, #_"Object" ___arg1]
        ;; note - relies on ensureEditable in nth
        (when (Util'isInteger ___arg1)
            (§ return (ß nth(((Number) ___arg1).intValue())))
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn #_"Object" nth [#_"TransientVector" this, #_"int" ___i]
        (ß ensureEditable())
        (let [#_"Object[]" ___node (ß arrayFor(___i))]
            (ß ___node[___i & 0x01f])
        )
    )

    #_method
    (§ defn #_"Object" nth [#_"TransientVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < count())
            (§ return (ß nth(___i)))
        )
        ___notFound
    )

    #_method
    (§ defn #_"TransientVector" assocN [#_"TransientVector" this, #_"int" ___i, #_"Object" ___val]
        (ß ensureEditable())
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= tailoff())
                (§ ass (ß (:tail this)[___i & 0x01f]) ___val)
                (§ return this)
            )

            (§ ass (:root this) (ß doAssoc((:shift this), (:root this), ___i, ___val)))
            (§ return this)
        )
        (when (ß ___i == (:cnt this))
            (§ return (ß conj(___val)))
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"TransientVector" assoc [#_"TransientVector" this, #_"Object" ___key, #_"Object" ___val]
        ;; note - relies on ensureEditable in assocN
        (when (Util'isInteger ___key)
            (let [#_"int" ___i (ß ((Number) ___key).intValue())]
                (§ return (ß assocN(___i, ___val)))
            )
        )
        (throw (IllegalArgumentException. "Key must be integer"))
    )

    #_method
    (§ defn- #_"VNode" doAssoc [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___node, #_"int" ___i, #_"Object" ___val]
        (§ ass ___node (ß ensureEditable(___node)))
        (let [#_"VNode" ___ret ___node]
            (if (ß ___level == 0)
                (do
                    (§ ass (ß (:array ___ret)[___i & 0x01f]) ___val)
                )
                (do
                    (let [#_"int" ___subidx (ß (___i >>> ___level) & 0x01f)]
                        (§ ass (ß (:array ___ret)[___subidx]) (ß doAssoc(___level - 5, (VNode) (:array ___node)[___subidx], ___i, ___val)))
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"TransientVector" pop [#_"TransientVector" this]
        (ß ensureEditable())
        (when (ß (:cnt this) == 0)
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß (:cnt this) == 1)
            (§ ass (:cnt this) 0)
            (§ return this)
        )
        (let [#_"int" ___i (- (:cnt this) 1)]
            ;; pop in tail?
            (when (ß (___i & 0x01f) > 0)
                (§ ass (:cnt this) (- (:cnt this) 1))
                (§ return this)
            )

            (let [#_"Object[]" ___newtail (ß editableArrayFor((:cnt this) - 2))]
                (let [#_"VNode" ___newroot (ß popTail((:shift this), (:root this)))]
                    (let [#_"int" ___newshift (:shift this)]
                        (when (nil? ___newroot)
                            (§ ass ___newroot (VNode'new-1 (ß (:root this).edit)))
                        )
                        (when (ß (:shift this) > 5 && (:array ___newroot)[1] == nil)
                            (§ ass ___newroot (ß ensureEditable((VNode) (:array ___newroot)[0])))
                            (§ ass ___newshift (- ___newshift 5))
                        )
                        (§ ass (:root this) ___newroot)
                        (§ ass (:shift this) ___newshift)
                        (§ ass (:cnt this) (- (:cnt this) 1))
                        (§ ass (:tail this) ___newtail)
                        this
                    )
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" popTail [#_"TransientVector" this, #_"int" ___level, #_"VNode" ___node]
        (§ ass ___node (ß ensureEditable(___node)))
        (let [#_"int" ___subidx (ß (((:cnt this) - 2) >>> ___level) & 0x01f)]
            (cond (> ___level 5)
                (do
                    (let [#_"VNode" ___newchild (ß popTail(___level - 5, (VNode) (:array ___node)[___subidx]))]
                        (if (ß ___newchild == nil && ___subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"VNode" ___ret ___node]
                                    (§ ass (ß (:array ___ret)[___subidx]) ___newchild)
                                    ___ret
                                )
                            )
                        )
                    )
                )
                (ß ___subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"VNode" ___ret ___node]
                        (§ ass (ß (:array ___ret)[___subidx]) nil)
                        ___ret
                    )
                )
            )
        )
    )
)

(class-ns PersistentVector (§ extends APersistentVector) (§ implements IObj, IEditableCollection, IReduce, IKVReduce)
    (def #_"AtomicReference<Thread>" PersistentVector'NOEDIT (AtomicReference. nil))
    (def #_"VNode" PersistentVector'EMPTY_NODE (ß VNode'new-2(PersistentVector'NOEDIT, new Object[32])))

    (def #_"PersistentVector" PersistentVector'EMPTY (ß PersistentVector'new-4(0, 5, PersistentVector'EMPTY_NODE, new Object[] (§ array ))))

    (def- #_"IFn" PersistentVector'TRANSIENT_VECTOR_CONJ
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___coll, #_"Object" ___val]
                (ß ((ITransientVector)___coll).conj(___val))
            )
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___coll]
                ___coll
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'adopt [#_"Object[]" ___items]
        (ß PersistentVector'new-4(___items.length, 5, PersistentVector'EMPTY_NODE, ___items))
    )

    (defn #_"PersistentVector" PersistentVector'create-1r [#_"IReduceInit" ___items]
        (let [#_"TransientVector" ___ret (ß PersistentVector'EMPTY.asTransient())]
            (ß ___items.reduce(PersistentVector'TRANSIENT_VECTOR_CONJ, ___ret))
            (ß ___ret.persistent())
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1s [#_"ISeq" ___items]
        (let [#_"Object[]" ___arr (make-array Object 32)]
            (let [#_"int" ___i 0]
                (loop-when-recur [___items ___items] (ß ___items != nil && ___i < 32) [(ß ___items.next())]
                    (§ ass (ß ___arr[___i]) (ß ___items.first()))
                    (§ ass ___i (inc ___i))
                )

                (cond (some? ___items) ;; >32, construct with array directly
                    (do
                        (let [#_"PersistentVector" ___start (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, ___arr)]
                            (let [#_"TransientVector" ___ret (ß ___start.asTransient())]
                                (loop-when-recur [___items ___items] (some? ___items) [(ß ___items.next())]
                                    (§ ass ___ret (ß ___ret.conj(___items.first())))
                                )
                                (ß ___ret.persistent())
                            )
                        )
                    )
                    (ß ___i == 32) ;; exactly 32, skip copy
                    (do
                        (PersistentVector'new-4 32, 5, PersistentVector'EMPTY_NODE, ___arr)
                    )
                    :else ;; <32, copy to minimum array and construct
                    (do
                        (let [#_"Object[]" ___arr2 (make-array Object ___i)]
                            (System/arraycopy ___arr, 0, ___arr2, 0, ___i)
                            (PersistentVector'new-4 ___i, 5, PersistentVector'EMPTY_NODE, ___arr2)
                        )
                    )
                )
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1l [#_"List" ___list]
        (let [#_"int" ___size (ß ___list.size())]
            (when (ß ___size <= 32)
                (§ return (ß PersistentVector'new-4(___size, 5, PersistentVector'EMPTY_NODE, ___list.toArray())))
            )

            (let [#_"TransientVector" ___ret (ß PersistentVector'EMPTY.asTransient())]
                (loop-when-recur [#_"int" ___i 0] (< ___i ___size) [(inc ___i)]
                    (§ ass ___ret (ß ___ret.conj(___list.get(___i))))
                )
                (ß ___ret.persistent())
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1i [#_"Iterable" ___items]
        ;; optimize common case
        (when (ß ___items instanceof ArrayList)
            (§ return (ß create((ArrayList)___items)))
        )

        (let [#_"Iterator" ___iter (ß ___items.iterator())]
            (let [#_"TransientVector" ___ret (ß PersistentVector'EMPTY.asTransient())]
                (while (ß ___iter.hasNext())
                    (§ ass ___ret (ß ___ret.conj(___iter.next())))
                )
                (ß ___ret.persistent())
            )
        )
    )

    (defn #_"PersistentVector" PersistentVector'create-1a [#_"Object..." ___items]
        (let [#_"TransientVector" ___ret (ß PersistentVector'EMPTY.asTransient())]
            (doseq [#_"Object" ___item ___items]
                (§ ass ___ret (ß ___ret.conj(___item)))
            )
            (ß ___ret.persistent())
        )
    )

    (defn- #_"PersistentVector" PersistentVector'init []
        (hash-map
            #_"int" :cnt 0
            #_"int" :shift 0
            #_"VNode" :root nil
            #_"Object[]" :tail nil
            #_"IPersistentMap" :_meta nil
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-4 [#_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass (:_meta this) nil)
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    (defn #_"PersistentVector" PersistentVector'new-5 [#_"IPersistentMap" ___meta, #_"int" ___cnt, #_"int" ___shift, #_"VNode" ___root, #_"Object[]" ___tail]
        (let [this (merge (APersistentVector'new) (PersistentVector'init))]
            (§ ass (:_meta this) ___meta)
            (§ ass (:cnt this) ___cnt)
            (§ ass (:shift this) ___shift)
            (§ ass (:root this) ___root)
            (§ ass (:tail this) ___tail)
            this
        )
    )

    #_method
    (§ defn #_"TransientVector" asTransient [#_"PersistentVector" this]
        (TransientVector'new-1 this)
    )

    #_method
    (§ defn #_"int" tailoff [#_"PersistentVector" this]
        (when (< (:cnt this) 32)
            (§ return 0)
        )
        (ß (((:cnt this) - 1) >>> 5) << 5)
    )

    #_method
    (§ defn #_"Object[]" arrayFor [#_"PersistentVector" this, #_"int" ___i]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= tailoff())
                (§ return (:tail this))
            )
            (let [#_"VNode" ___node (:root this)]
                (loop-when-recur [#_"int" ___level (:shift this)] (> ___level 0) [(- ___level 5)]
                    (§ ass ___node (ß (VNode) (:array ___node)[(___i >>> ___level) & 0x01f]))
                )
                (§ return (:array ___node))
            )
        )
        (throw (IndexOutOfBoundsException.))
    )

    #_method
    (§ defn #_"Object" nth [#_"PersistentVector" this, #_"int" ___i]
        (let [#_"Object[]" ___node (ß arrayFor(___i))]
            (ß ___node[___i & 0x01f])
        )
    )

    #_method
    (§ defn #_"Object" nth [#_"PersistentVector" this, #_"int" ___i, #_"Object" ___notFound]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (§ return (ß nth(___i)))
        )
        ___notFound
    )

    #_method
    (§ defn #_"PersistentVector" assocN [#_"PersistentVector" this, #_"int" ___i, #_"Object" ___val]
        (when (ß ___i >= 0 && ___i < (:cnt this))
            (when (ß ___i >= tailoff())
                (let [#_"Object[]" ___newTail (make-array Object (ß (:tail this).length))]
                    (ß System/arraycopy((:tail this), 0, ___newTail, 0, (:tail this).length))
                    (§ ass (ß ___newTail[___i & 0x01f]) ___val)

                    (§ return (ß PersistentVector'new-5(meta(), (:cnt this), (:shift this), (:root this), ___newTail)))
                )
            )

            (§ return (ß PersistentVector'new-5(meta(), (:cnt this), (:shift this), doAssoc((:shift this), (:root this), ___i, ___val), (:tail this))))
        )
        (when (ß ___i == (:cnt this))
            (§ return (ß cons(___val)))
        )
        (throw (IndexOutOfBoundsException.))
    )

    (defn- #_"VNode" PersistentVector'doAssoc [#_"int" ___level, #_"VNode" ___node, #_"int" ___i, #_"Object" ___val]
        (let [#_"VNode" ___ret (ß VNode'new-2((:edit ___node), (:array ___node).clone()))]
            (if (ß ___level == 0)
                (do
                    (§ ass (ß (:array ___ret)[___i & 0x01f]) ___val)
                )
                (do
                    (let [#_"int" ___subidx (ß (___i >>> ___level) & 0x01f)]
                        (§ ass (ß (:array ___ret)[___subidx]) (ß doAssoc(___level - 5, (VNode) (:array ___node)[___subidx], ___i, ___val)))
                    )
                )
            )
            ___ret
        )
    )

    #_method
    (§ defn #_"int" count [#_"PersistentVector" this]
        (:cnt this)
    )

    #_method
    (§ defn #_"PersistentVector" withMeta [#_"PersistentVector" this, #_"IPersistentMap" ___meta]
        (PersistentVector'new-5 ___meta, (:cnt this), (:shift this), (:root this), (:tail this))
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"PersistentVector" this]
        (:_meta this)
    )

    #_method
    (§ defn #_"PersistentVector" cons [#_"PersistentVector" this, #_"Object" ___val]
        ;; room in tail?
        (when (ß (:cnt this) - tailoff() < 32)
            (let [#_"Object[]" ___newTail (make-array Object (ß (:tail this).length + 1))]
                (ß System/arraycopy((:tail this), 0, ___newTail, 0, (:tail this).length))
                (§ ass (ß ___newTail[(:tail this).length]) ___val)
                (§ return (ß PersistentVector'new-5(meta(), (:cnt this) + 1, (:shift this), (:root this), ___newTail)))
            )
        )
        ;; full tail, push into tree
        (§ let [#_"VNode" ___newroot]
            (let [#_"VNode" ___tailnode (ß VNode'new-2((:root this).edit, (:tail this)))]
                (let [#_"int" ___newshift (:shift this)]
                    ;; overflow root?
                    (if (ß ((:cnt this) >>> 5) > (1 << (:shift this)))
                        (do
                            (§ ass ___newroot (VNode'new-1 (ß (:root this).edit)))
                            (§ ass (ß (:array ___newroot)[0]) (:root this))
                            (§ ass (ß (:array ___newroot)[1]) (ß PersistentVector'newPath((:root this).edit, (:shift this), ___tailnode)))
                            (§ ass ___newshift (+ ___newshift 5))
                        )
                        (do
                            (§ ass ___newroot (ß pushTail((:shift this), (:root this), ___tailnode)))
                        )
                    )
                    (ß PersistentVector'new-5(meta(), (:cnt this) + 1, ___newshift, ___newroot, new Object[] (§ array ___val )))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" pushTail [#_"PersistentVector" this, #_"int" ___level, #_"VNode" ___parent, #_"VNode" ___tailnode]
        ;; if parent is leaf, insert node,
        ;; else does it map to an existing child? -> nodeToInsert = pushNode one more level
        ;; else alloc new path
        ;; return nodeToInsert placed in copy of parent
        (let [#_"int" ___subidx (ß (((:cnt this) - 1) >>> ___level) & 0x01f)]
            (let [#_"VNode" ___ret (ß VNode'new-2((:edit ___parent), (:array ___parent).clone()))]
                (§ let [#_"VNode" ___nodeToInsert]
                    (if (ß ___level == 5)
                        (do
                            (§ ass ___nodeToInsert ___tailnode)
                        )
                        (do
                            (let [#_"VNode" ___child (ß (VNode) (:array ___parent)[___subidx])]
                                (§ ass ___nodeToInsert (ß (___child != nil) ? pushTail(___level - 5, ___child, ___tailnode) :or PersistentVector'newPath((:root this).edit, ___level - 5, ___tailnode)))
                            )
                        )
                    )
                    (§ ass (ß (:array ___ret)[___subidx]) ___nodeToInsert)
                    ___ret
                )
            )
        )
    )

    (defn- #_"VNode" PersistentVector'newPath [#_"AtomicReference<Thread>" ___edit, #_"int" ___level, #_"VNode" ___node]
        (when (ß ___level == 0)
            (§ return ___node)
        )
        (let [#_"VNode" ___ret (VNode'new-1 ___edit)]
            (§ ass (ß (:array ___ret)[0]) (ß PersistentVector'newPath(___edit, ___level - 5, ___node)))
            ___ret
        )
    )

    #_method
    (§ defn #_"IChunkedSeq" chunkedSeq [#_"PersistentVector" this]
        (when (ß count() == 0)
            (§ return nil)
        )
        (ChunkedSeq'new-3 this, 0, 0)
    )

    #_method
    (§ defn #_"ISeq" seq [#_"PersistentVector" this]
        (ß chunkedSeq())
    )

    #_override
    #_method
    (§ defn #_"Iterator" rangedIterator [#_"PersistentVector" this, #_"int" ___start, #_"int" ___end]
        (§ reify Iterator()
            (§ init
                (hash-map
                    #_"int" :i ___start
                    #_"int" :base (- (:i this) (% (:i this) 32))
                    #_"Object[]" :array (ß (___start < count()) ? arrayFor((:i this)) :or nil)
                )
            )

            #_method
            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                (ß ((:i this) < ___end))
            )

            #_method
            (§ defn #_"Object" next [#_"Iterator" this]
                (if (< (:i this) ___end)
                    (do
                        (when (ß (:i this) - (:base this) == 32)
                            (§ ass (:array this) (ß arrayFor((:i this))))
                            (§ ass (:base this) (+ (:base this) 32))
                        )
                        (let [_ (ß (:array this)[(:i this) & 0x01f])]
                            (§ ass (:i this) (+ (:i this) 1))
                            _
                        )
                    )
                    (do
                        (throw (NoSuchElementException.))
                    )
                )
            )

            #_method
            (§ defn #_"void" remove [#_"Iterator" this]
                (throw (UnsupportedOperationException.))
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"PersistentVector" this]
        (ß rangedIterator(0, count()))
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentVector" this, #_"IFn" ___f]
        (§ let [#_"Object" ___init]
            (if (> (:cnt this) 0)
                (do
                    (§ ass ___init (ß arrayFor(0)[0]))
                )
                (do
                    (§ return (ß ___f.invoke()))
                )
            )
            (let [#_"int" ___step 0]
                (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                    (let [#_"Object[]" ___array (ß arrayFor(___i))]
                        (loop-when-recur [#_"int" ___j (ß (___i == 0) ? 1 :or 0)] (ß ___j < ___array.length) [(inc ___j)]
                            (§ ass ___init (ß ___f.invoke(___init, ___array[___j])))
                            (when (RT'isReduced ___init)
                                (§ return (ß ((IDeref)___init).deref()))
                            )
                        )
                        (§ ass ___step (ß ___array.length))
                    )
                )
                ___init
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"PersistentVector" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"int" ___step 0]
            (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                (let [#_"Object[]" ___array (ß arrayFor(___i))]
                    (loop-when-recur [#_"int" ___j 0] (ß ___j < ___array.length) [(inc ___j)]
                        (§ ass ___init (ß ___f.invoke(___init, ___array[___j])))
                        (when (RT'isReduced ___init)
                            (§ return (ß ((IDeref)___init).deref()))
                        )
                    )
                    (§ ass ___step (ß ___array.length))
                )
            )
            ___init
        )
    )

    #_method
    (§ defn #_"Object" kvreduce [#_"PersistentVector" this, #_"IFn" ___f, #_"Object" ___init]
        (let [#_"int" ___step 0]
            (loop-when-recur [#_"int" ___i 0] (< ___i (:cnt this)) [(+ ___i ___step)]
                (let [#_"Object[]" ___array (ß arrayFor(___i))]
                    (loop-when-recur [#_"int" ___j 0] (ß ___j < ___array.length) [(inc ___j)]
                        (§ ass ___init (ß ___f.invoke(___init, ___j + ___i, ___array[___j])))
                        (when (RT'isReduced ___init)
                            (§ return (ß ((IDeref)___init).deref()))
                        )
                    )
                    (§ ass ___step (ß ___array.length))
                )
            )
            ___init
        )
    )

    #_method
    (§ defn #_"IPersistentCollection" empty [#_"PersistentVector" this]
        (ß PersistentVector'EMPTY.withMeta(meta()))
    )

    #_method
    (§ defn #_"PersistentVector" pop [#_"PersistentVector" this]
        (when (ß (:cnt this) == 0)
            (throw (IllegalStateException. "Can't pop empty vector"))
        )
        (when (ß (:cnt this) == 1)
            (§ return (ß PersistentVector'EMPTY.withMeta(meta())))
        )
        (when (ß (:cnt this) - tailoff() > 1)
            (let [#_"Object[]" ___newTail (make-array Object (ß (:tail this).length - 1))]
                (ß System/arraycopy((:tail this), 0, ___newTail, 0, ___newTail.length))
                (§ return (ß PersistentVector'new-5(meta(), (:cnt this) - 1, (:shift this), (:root this), ___newTail)))
            )
        )
        (let [#_"Object[]" ___newtail (ß arrayFor((:cnt this) - 2))]
            (let [#_"VNode" ___newroot (ß popTail((:shift this), (:root this)))]
                (let [#_"int" ___newshift (:shift this)]
                    (when (nil? ___newroot)
                        (§ ass ___newroot PersistentVector'EMPTY_NODE)
                    )
                    (when (ß (:shift this) > 5 && (:array ___newroot)[1] == nil)
                        (§ ass ___newroot (ß (VNode) (:array ___newroot)[0]))
                        (§ ass ___newshift (- ___newshift 5))
                    )
                    (ß PersistentVector'new-5(meta(), (:cnt this) - 1, ___newshift, ___newroot, ___newtail))
                )
            )
        )
    )

    #_method
    (§ defn- #_"VNode" popTail [#_"PersistentVector" this, #_"int" ___level, #_"VNode" ___node]
        (let [#_"int" ___subidx (ß (((:cnt this) - 2) >>> ___level) & 0x01f)]
            (cond (> ___level 5)
                (do
                    (let [#_"VNode" ___newchild (ß popTail(___level - 5, (VNode) (:array ___node)[___subidx]))]
                        (if (ß ___newchild == nil && ___subidx == 0)
                            (do
                                nil
                            )
                            (do
                                (let [#_"VNode" ___ret (ß VNode'new-2((:root this).edit, (:array ___node).clone()))]
                                    (§ ass (ß (:array ___ret)[___subidx]) ___newchild)
                                    ___ret
                                )
                            )
                        )
                    )
                )
                (ß ___subidx == 0)
                (do
                    nil
                )
                :else
                (do
                    (let [#_"VNode" ___ret (ß VNode'new-2((:root this).edit, (:array ___node).clone()))]
                        (§ ass (ß (:array ___ret)[___subidx]) nil)
                        ___ret
                    )
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.ProxyHandler

(§ import java.lang.reflect.InvocationHandler)
(§ import java.lang.reflect.Method)

(class-ns ProxyHandler (§ implements InvocationHandler)
    (defn- #_"ProxyHandler" ProxyHandler'init []
        (hash-map
            ;; method-name-string->fn
            #_"IPersistentMap" :fns nil
        )
    )

    (defn #_"ProxyHandler" ProxyHandler'new [#_"IPersistentMap" ___fns]
        (let [this (ProxyHandler'init)]
            (§ ass (:fns this) ___fns)
            this
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"ProxyHandler" this, #_"Object" ___proxy, #_"java.lang.reflect.Method" ___method, #_"Object[]" ___args] #_(§ throws Throwable)
        (let [#_"Class" ___rt (ß ___method.getReturnType())]
            (let [#_"IFn" ___fn (ß (IFn) (:fns this).valAt(___method.getName()))]
                (when (nil? ___fn)
                    (cond (ß ___rt == Void/TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß ___method.getName().equals("equals"))
                        (do
                            (§ return (ß (___proxy == ___args[0])))
                        )
                        (ß ___method.getName().equals("hashCode"))
                        (do
                            (§ return (System/identityHashCode ___proxy))
                        )
                        (ß ___method.getName().equals("toString"))
                        (do
                            (§ return (ß "Proxy: " + System/identityHashCode(___proxy)))
                        )
                    )
                    (throw (UnsupportedOperationException.))
                )
                (let [#_"Object" ___ret (ß ___fn.applyTo(ArraySeq'create-1(___args)))]
                    (cond (ß ___rt == Void/TYPE)
                        (do
                            (§ return nil)
                        )
                        (ß ___rt.isPrimitive())
                        (do
                            (cond (ß ___rt == Character/TYPE)
                                (do
                                    (§ return ___ret)
                                )
                                (ß ___rt == Integer/TYPE)
                                (do
                                    (§ return (ß ((Number) ___ret).intValue()))
                                )
                                (ß ___rt == Long/TYPE)
                                (do
                                    (§ return (ß ((Number) ___ret).longValue()))
                                )
                                (ß ___rt == Float/TYPE)
                                (do
                                    (§ return (ß ((Number) ___ret).floatValue()))
                                )
                                (ß ___rt == Double/TYPE)
                                (do
                                    (§ return (ß ((Number) ___ret).doubleValue()))
                                )
                                (ß ___rt == Boolean/TYPE && !(___ret instanceof Boolean))
                                (do
                                    (§ return (ß (___ret == nil) ? Boolean/FALSE :or Boolean/TRUE))
                                )
                                (ß ___rt == Byte/TYPE)
                                (do
                                    (§ return (ß (byte) ((Number) ___ret).intValue()))
                                )
                                (ß ___rt == Short/TYPE)
                                (do
                                    (§ return (ß (short) ((Number) ___ret).intValue()))
                                )
                            )
                        )
                    )
                    ___ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.Range

(§ import java.util.*)

#_private
(defprotocol RangeBoundsCheck
    #_abstract
    (#_"boolean" RangeBoundsCheck'''exceededBounds [#_"RangeBoundsCheck" this, #_"Object" ___val])
)

#_private
#_non-static
(class-ns RangeIterator (§ implements Iterator)
    (defn- #_"RangeIterator" RangeIterator'init []
        (hash-map
            #_"Object" :next nil
        )
    )

    (defn #_"RangeIterator" RangeIterator'new []
        (let [this (RangeIterator'init)]
            (§ ass (:next this) (:start this))
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"RangeIterator" this]
        (ß (!this.boundsCheck.exceededBounds((:next this))))
    )

    #_method
    (§ defn #_"Object" next [#_"RangeIterator" this]
        (if (ß hasNext())
            (do
                (let [#_"Object" ___ret (:next this)]
                    (§ ass (:next this) (Numbers'addP-2oo (:next this), (:step this)))
                    ___ret
                )
            )
            (do
                (throw (NoSuchElementException.))
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"RangeIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

;;;
 ; Implements generic numeric (potentially infinite) range.
 ;;
(class-ns Range (§ extends ASeq) (§ implements IChunkedSeq, IReduce)
    (def- #_"int" Range'CHUNK_SIZE 32)

    (defn- #_"RangeBoundsCheck" Range'positiveStep [#_"Object" ___end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"RangeBoundsCheck" this, #_"Object" ___val]
                (Numbers'gte-2oo ___val, ___end)
            )
        )
    )

    (defn- #_"RangeBoundsCheck" Range'negativeStep [#_"Object" ___end]
        (§ reify RangeBoundsCheck()
            #_method
            (§ defn #_"boolean" exceededBounds [#_"RangeBoundsCheck" this, #_"Object" ___val]
                (Numbers'lte-2oo ___val, ___end)
            )
        )
    )

    (defn- #_"Range" Range'init []
        (hash-map
            ;; Invariants guarantee this is never an "empty" seq
            #_"Object" :end nil
            #_"Object" :start nil
            #_"Object" :step nil
            #_"RangeBoundsCheck" :boundsCheck nil

            #_volatile
            #_"IChunk" :_chunk nil ;; lazy
            #_volatile
            #_"ISeq" :_chunkNext nil ;; lazy
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Range" Range'new-4 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck]
        (let [this (merge (ASeq'new) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            this
        )
    )

    (defn- #_"Range" Range'new-6 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck, #_"IChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn- #_"Range" Range'new-7 [#_"IPersistentMap" ___meta, #_"Object" ___start, #_"Object" ___end, #_"Object" ___step, #_"RangeBoundsCheck" ___boundsCheck, #_"IChunk" ___chunk, #_"ISeq" ___chunkNext]
        (let [this (merge (ASeq'new ___meta) (Range'init))]
            (§ ass (:end this) ___end)
            (§ ass (:start this) ___start)
            (§ ass (:step this) ___step)
            (§ ass (:boundsCheck this) ___boundsCheck)
            (§ ass (:_chunk this) ___chunk)
            (§ ass (:_chunkNext this) ___chunkNext)
            this
        )
    )

    (defn #_"ISeq" Range'create-1 [#_"Object" ___end]
        (when (Numbers'isPos-1o ___end)
            (§ return (ß Range'new-4(0, ___end, 1, positiveStep(___end))))
        )
        PersistentList'EMPTY
    )

    (defn #_"ISeq" Range'create-2 [#_"Object" ___start, #_"Object" ___end]
        (Range'create-3 ___start, ___end, 1)
    )

    (defn #_"ISeq" Range'create-3 [#_"Object" ___start, #_"Object" ___end, #_"Object" ___step]
        (when (ß (Numbers'isPos-1o(___step) && Numbers'gt-2oo(___start, ___end)) || (Numbers'isNeg-1o(___step) && Numbers'gt-2oo(___end, ___start)) || Numbers'equiv-2oo(___start, ___end))
            (§ return PersistentList'EMPTY)
        )
        (when (Numbers'isZero-1o ___step)
            (§ return (Repeat'create-1 ___start))
        )
        (ß Range'new-4(___start, ___end, ___step, Numbers'isPos-1o(___step) ? positiveStep(___end) :or negativeStep(___end)))
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"Range" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == (:_meta this))
            (§ return this)
        )
        (Range'new-7 ___meta, (:end this), (:start this), (:step this), (:boundsCheck this), (:_chunk this), (:_chunkNext this))
    )

    #_method
    (§ defn #_"Object" first [#_"Range" this]
        (:start this)
    )

    #_method
    (§ defn #_"void" forceChunk [#_"Range" this]
        (when (some? (:_chunk this))
            (§ return nil)
        )

        (let [#_"Object[]" ___arr (make-array Object Range'CHUNK_SIZE)]
            (let [#_"int" ___n 0]
                (let [#_"Object" ___val (:start this)]
                    (while (ß ___n < Range'CHUNK_SIZE)
                        (§ ass (ß ___arr[___n]) ___val)
                        (§ ass ___n (inc ___n))
                        (§ ass ___val (Numbers'addP-2oo ___val, (:step this)))
                        (when (ß (:boundsCheck this).exceededBounds(___val))
                            ;; partial last chunk
                            (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, ___n))
                            (§ return nil)
                        )
                    )

                    ;; full last chunk
                    (when (ß (:boundsCheck this).exceededBounds(___val))
                        (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, Range'CHUNK_SIZE))
                        (§ return nil)
                    )

                    ;; full intermediate chunk
                    (§ ass (:_chunk this) (ArrayChunk'new-3 ___arr, 0, Range'CHUNK_SIZE))
                    (§ ass (:_chunkNext this) (Range'new-4 ___val, (:end this), (:step this), (:boundsCheck this)))
                    nil
                )
            )
        )
    )

    #_method
    (§ defn #_"ISeq" next [#_"Range" this]
        (when (some? (:_next this))
            (§ return (:_next this))
        )

        (ß forceChunk())
        (when (ß (:_chunk this).count() > 1)
            (let [#_"IChunk" ___smallerChunk (ß (:_chunk this).dropFirst())]
                (§ ass (:_next this) (ß Range'new-6(___smallerChunk.nth(0), (:end this), (:step this), (:boundsCheck this), ___smallerChunk, (:_chunkNext this))))
                (§ return (:_next this))
            )
        )
        (ß chunkedNext())
    )

    #_method
    (§ defn #_"IChunk" chunkedFirst [#_"Range" this]
        (ß forceChunk())
        (:_chunk this)
    )

    #_method
    (§ defn #_"ISeq" chunkedNext [#_"Range" this]
        (ß chunkedMore().seq())
    )

    #_method
    (§ defn #_"ISeq" chunkedMore [#_"Range" this]
        (ß forceChunk())
        (when (nil? (:_chunkNext this))
            (§ return PersistentList'EMPTY)
        )
        (:_chunkNext this)
    )

    #_method
    (§ defn #_"Object" reduce [#_"Range" this, #_"IFn" ___f]
        (let [#_"Object" ___acc (:start this)]
            (let [#_"Number" ___i (Numbers'addP-2oo (:start this), (:step this))]
                (while (ß !this.boundsCheck.exceededBounds(___i))
                    (§ ass ___acc (ß ___f.invoke(___acc, ___i)))
                    (when (RT'isReduced ___acc)
                        (§ return (ß ((Reduced)___acc).deref()))
                    )
                    (§ ass ___i (Numbers'addP-2oo ___i, (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Range" this, #_"IFn" ___f, #_"Object" ___val]
        (let [#_"Object" ___acc ___val]
            (let [#_"Object" ___i (:start this)]
                (while (ß !this.boundsCheck.exceededBounds(___i))
                    (§ ass ___acc (ß ___f.invoke(___acc, ___i)))
                    (when (RT'isReduced ___acc)
                        (§ return (ß ((Reduced)___acc).deref()))
                    )
                    (§ ass ___i (Numbers'addP-2oo ___i, (:step this)))
                )
                ___acc
            )
        )
    )

    #_method
    (§ defn #_"Iterator" iterator [#_"Range" this]
        (RangeIterator'new)
    )
)
)

(java-ns cloiure.lang.Ratio

(§ import java.math.BigInteger)
(§ import java.math.BigDecimal)
(§ import java.math.MathContext)

(class-ns Ratio (§ extends Number) (§ implements Comparable)
    (defn- #_"Ratio" Ratio'init []
        (hash-map
            #_"BigInteger" :numerator nil
            #_"BigInteger" :denominator nil
        )
    )

    (defn #_"Ratio" Ratio'new [#_"BigInteger" ___numerator, #_"BigInteger" ___denominator]
        (let [this (merge (Number'new) (Ratio'init))]
            (§ ass (:numerator this) ___numerator)
            (§ ass (:denominator this) ___denominator)
            this
        )
    )

    #_method
    (§ defn #_"boolean" equals [#_"Ratio" this, #_"Object" ___arg0]
        (ß (___arg0 != nil && ___arg0 instanceof Ratio && ((Ratio) ___arg0).numerator.equals((:numerator this)) && ((Ratio) ___arg0).denominator.equals((:denominator this))))
    )

    #_method
    (§ defn #_"int" hashCode [#_"Ratio" this]
        (ß (:numerator this).hashCode() :xor (:denominator this).hashCode())
    )

    #_method
    (§ defn #_"String" toString [#_"Ratio" this]
        (ß (:numerator this).toString() + "/" + (:denominator this).toString())
    )

    #_method
    (§ defn #_"int" intValue [#_"Ratio" this]
        (ß (int) doubleValue())
    )

    #_method
    (§ defn #_"long" longValue [#_"Ratio" this]
        (ß bigIntegerValue().longValue())
    )

    #_method
    (§ defn #_"float" floatValue [#_"Ratio" this]
        (ß (float)doubleValue())
    )

    #_method
    (§ defn #_"double" doubleValue [#_"Ratio" this]
        (ß decimalValue(MathContext/DECIMAL64).doubleValue())
    )

    #_method
    (§ defn #_"BigDecimal" decimalValue [#_"Ratio" this]
        (ß decimalValue(MathContext/UNLIMITED))
    )

    #_method
    (§ defn #_"BigDecimal" decimalValue [#_"Ratio" this, #_"MathContext" ___mc]
        (let [#_"BigDecimal" ___numerator (§ unsure BigDecimal. (:numerator this))]
            (let [#_"BigDecimal" ___denominator (§ unsure BigDecimal. (:denominator this))]
                (ß ___numerator.divide(___denominator, ___mc))
            )
        )
    )

    #_method
    (§ defn #_"BigInteger" bigIntegerValue [#_"Ratio" this]
        (ß (:numerator this).divide((:denominator this)))
    )

    #_method
    (§ defn #_"int" compareTo [#_"Ratio" this, #_"Object" ___o]
        (let [#_"Number" ___other (ß (Number)___o)]
            (Numbers'compare this, ___other)
        )
    )
)
)

(java-ns cloiure.lang.ReaderConditional

(class-ns ReaderConditional (§ implements ILookup)
    (§ def #_"Keyword" ReaderConditional'FORM_KW (Keyword'intern-1 "form"))
    (§ def #_"Keyword" ReaderConditional'SPLICING_KW (Keyword'intern-1 "splicing?"))

    (defn #_"ReaderConditional" ReaderConditional'create [#_"Object" ___form, #_"boolean" ___splicing]
        (ReaderConditional'new ___form, ___splicing)
    )

    (defn- #_"ReaderConditional" ReaderConditional'init []
        (hash-map
            #_"Object" :form nil
            #_"Boolean" :splicing nil
        )
    )

    (defn- #_"ReaderConditional" ReaderConditional'new [#_"Object" ___form, #_"boolean" ___splicing]
        (let [this (ReaderConditional'init)]
            (§ ass (:form this) ___form)
            (§ ass (:splicing this) ___splicing)
            this
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"ReaderConditional" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [#_"ReaderConditional" this, #_"Object" ___key, #_"Object" ___notFound]
        (cond (ß ReaderConditional'FORM_KW.equals(___key))
            (do
                (:form this)
            )
            (ß ReaderConditional'SPLICING_KW.equals(___key))
            (do
                (:splicing this)
            )
            :else
            (do
                ___notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" equals [#_"ReaderConditional" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (ß ___o == nil || getClass() != ___o.getClass())
            (§ return false)
        )

        (let [#_"ReaderConditional" ___that (ß (ReaderConditional) ___o)]
            (when (ß ((:form this) != nil) ? !this.form.equals((:form ___that)) :or (:form ___that) != nil)
                (§ return false)
            )
            (when (ß ((:splicing this) != nil) ? !this.splicing.equals((:splicing ___that)) :or (:splicing ___that) != nil)
                (§ return false)
            )
            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" hashCode [#_"ReaderConditional" this]
        (let [#_"int" ___result (Util'hash (:form this))]
            (§ ass ___result (ß 31 * ___result + Util'hash((:splicing this))))
            ___result
        )
    )
)
)

(java-ns cloiure.lang.RecordIterator

(§ import java.util.Iterator)

(class-ns RecordIterator (§ implements Iterator)
    (defn- #_"RecordIterator" RecordIterator'init []
        (hash-map
            #_"int" :i 0
            #_"int" :basecnt 0
            #_"ILookup" :rec nil
            #_"IPersistentVector" :basefields nil
            #_"Iterator" :extmap nil
        )
    )

    (defn #_"RecordIterator" RecordIterator'new [#_"ILookup" ___rec, #_"IPersistentVector" ___basefields, #_"Iterator" ___extmap]
        (let [this (RecordIterator'init)]
            (§ ass (:rec this) ___rec)
            (§ ass (:basefields this) ___basefields)
            (§ ass (:basecnt this) (ß ___basefields.count()))
            (§ ass (:extmap this) ___extmap)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"RecordIterator" this]
        (if (< (:i this) (:basecnt this))
            (do
                true
            )
            (do
                (ß (:extmap this).hasNext())
            )
        )
    )

    #_method
    (§ defn #_"Object" next [#_"RecordIterator" this]
        (if (< (:i this) (:basecnt this))
            (do
                (let [#_"Object" ___k (ß (:basefields this).nth((:i this)))]
                    (§ ass (:i this) (+ (:i this) 1))
                    (ß MapEntry'create(___k, (:rec this).valAt(___k)))
                )
            )
            (do
                (ß (:extmap this).next())
            )
        )
    )

    #_method
    (§ defn #_"void" remove [#_"RecordIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Reduced

(class-ns Reduced (§ implements IDeref)
    (defn- #_"Reduced" Reduced'init []
        (hash-map
            #_"Object" :val nil
        )
    )

    (defn #_"Reduced" Reduced'new [#_"Object" ___val]
        (let [this (Reduced'init)]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Reduced" this]
        (:val this)
    )
)
)

(java-ns cloiure.lang.Ref

(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.atomic.AtomicLong)
(§ import java.util.concurrent.locks.ReentrantReadWriteLock)

(class-ns RefTVal
    (defn- #_"RefTVal" RefTVal'init []
        (hash-map
            #_"Object" :val nil
            #_"long" :point 0
            #_"RefTVal" :prior nil
            #_"RefTVal" :next nil
        )
    )

    (defn #_"RefTVal" RefTVal'new-3 [#_"Object" ___val, #_"long" ___point, #_"RefTVal" ___prior]
        (let [this (RefTVal'init)]
            (§ ass (:val this) ___val)
            (§ ass (:point this) ___point)
            (§ ass (:prior this) ___prior)
            (§ ass (:next this) (:next ___prior))
            (§ ass (ß (:prior this).next) this)
            (§ ass (ß (:next this).prior) this)
            this
        )
    )

    (defn #_"RefTVal" RefTVal'new-2 [#_"Object" ___val, #_"long" ___point]
        (let [this (RefTVal'init)]
            (§ ass (:val this) ___val)
            (§ ass (:point this) ___point)
            (§ ass (:next this) this)
            (§ ass (:prior this) this)
            this
        )
    )
)

(class-ns Ref (§ extends ARef) (§ implements IFn, Comparable<Ref>, IRef)
    (def #_"AtomicLong" Ref'ids (AtomicLong.))

    (defn- #_"Ref" Ref'init []
        (hash-map
            #_"RefTVal" :tvals nil
            #_"AtomicInteger" :faults nil
            #_"ReentrantReadWriteLock" :lock nil
            #_"LockingTransactionInfo" :tinfo nil
            #_"long" :id 0

            #_volatile
            #_"int" :minHistory 0
            #_volatile
            #_"int" :maxHistory 10
        )
    )

    (defn #_"Ref" Ref'new-1 [#_"Object" ___initVal]
        (Ref'new-2 ___initVal, nil)
    )

    (defn #_"Ref" Ref'new-2 [#_"Object" ___initVal, #_"IPersistentMap" ___meta]
        (let [this (merge (ARef'new-1 ___meta) (Ref'init))]
            (§ ass (:id this) (ß Ref'ids.getAndIncrement()))
            (§ ass (:faults this) (AtomicInteger.))
            (§ ass (:lock this) (ReentrantReadWriteLock.))
            (§ ass (:tvals this) (RefTVal'new-2 ___initVal, 0))
            this
        )
    )

    #_method
    (§ defn #_"int" compareTo [#_"Ref" this, #_"Ref" ___ref]
        (cond (ß (:id this) == (:id ___ref))
            (do
                0
            )
            (ß (:id this) < (:id ___ref))
            (do
                -1
            )
            :else
            (do
                1
            )
        )
    )

    #_method
    (§ defn #_"int" getMinHistory [#_"Ref" this]
        (:minHistory this)
    )

    #_method
    (§ defn #_"Ref" setMinHistory [#_"Ref" this, #_"int" ___minHistory]
        (§ ass (:minHistory this) ___minHistory)
        this
    )

    #_method
    (§ defn #_"int" getMaxHistory [#_"Ref" this]
        (:maxHistory this)
    )

    #_method
    (§ defn #_"Ref" setMaxHistory [#_"Ref" this, #_"int" ___maxHistory]
        (§ ass (:maxHistory this) ___maxHistory)
        this
    )

    ;; the latest val

    ;; ok out of transaction
    #_method
    (§ defn #_"Object" currentVal [#_"Ref" this]
        (try
            (ß (:lock this).readLock().lock())
            (when (some? (:tvals this))
                (§ return (ß (:tvals this).val))
            )
            (throw (IllegalStateException. (str (ß this.toString()) " is unbound.")))
            (finally
                (ß (:lock this).readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Ref" this]
        (let [#_"LockingTransaction" ___t (ß LockingTransaction'getRunning())]
            (when (nil? ___t)
                (§ return (ß currentVal()))
            )
            (ß ___t.doGet(this))
        )
    )

    #_method
    (§ defn #_"Object" set [#_"Ref" this, #_"Object" ___val]
        (ß LockingTransaction'getEx().doSet(this, ___val))
    )

    #_method
    (§ defn #_"Object" commute [#_"Ref" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (ß LockingTransaction'getEx().doCommute(this, ___fn, ___args))
    )

    #_method
    (§ defn #_"Object" alter [#_"Ref" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (let [#_"LockingTransaction" ___t (ß LockingTransaction'getEx())]
            (ß ___t.doSet(this, ___fn.applyTo(RT'cons(___t.doGet(this), ___args))))
        )
    )

    #_method
    (§ defn #_"void" touch [#_"Ref" this]
        (ß LockingTransaction'getEx().doEnsure(this))
        nil
    )

    #_method
    (§ defn #_"boolean" isBound [#_"Ref" this]
        (try
            (ß (:lock this).readLock().lock())
            (ß ((:tvals this) != nil))
            (finally
                (ß (:lock this).readLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"void" trimHistory [#_"Ref" this]
        (try
            (ß (:lock this).writeLock().lock())
            (when (some? (:tvals this))
                (§ ass (ß (:tvals this).next) (:tvals this))
                (§ ass (ß (:tvals this).prior) (:tvals this))
            )
            (finally
                (ß (:lock this).writeLock().unlock())
            )
        )
        nil
    )

    #_method
    (§ defn #_"int" getHistoryCount [#_"Ref" this]
        (try
            (ß (:lock this).writeLock().lock())
            (ß histCount())
            (finally
                (ß (:lock this).writeLock().unlock())
            )
        )
    )

    #_method
    (§ defn #_"int" histCount [#_"Ref" this]
        (if (nil? (:tvals this))
            (do
                0
            )
            (do
                (let [#_"int" ___count 0]
                    (loop-when-recur [#_"RefTVal" ___tv (ß (:tvals this).next)] (ß ___tv != (:tvals this)) [(:next ___tv)]
                        (§ ass ___count (inc ___count))
                    )
                    ___count
                )
            )
        )
    )

    #_method
    (§ defn #_"IFn" fn [#_"Ref" this]
        (ß (IFn) deref())
    )

    #_method
    (§ defn #_"Object" call [#_"Ref" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"Ref" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this]
        (ß fn().invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1]
        (ß fn().invoke(___arg1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß fn().invoke(___arg1, ___arg2))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß fn().invoke(___arg1, ___arg2, ___arg3))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19, ___arg20))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Ref" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß fn().invoke(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, ___arg6, ___arg7, ___arg8, ___arg9, ___arg10, ___arg11, ___arg12, ___arg13, ___arg14, ___arg15,
                ___arg16, ___arg17, ___arg18, ___arg19, ___arg20, ___args))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Ref" this, #_"ISeq" ___arglist]
        (AFn'applyToHelper this, ___arglist)
    )
)
)

(java-ns cloiure.lang.Reflector

(§ import java.lang.reflect.Constructor)
(§ import java.lang.reflect.Field)
(§ import java.lang.reflect.Method)
(§ import java.lang.reflect.Modifier)
(§ import java.util.ArrayList)
(§ import java.util.Iterator)
(§ import java.util.List)

#_stateless
(class-ns Reflector
    (defn #_"Object" Reflector'invokeInstanceMethod [#_"Object" ___target, #_"String" ___methodName, #_"Object[]" ___args]
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"List" ___methods (ß getMethods(___c, ___args.length, ___methodName, false))]
                (ß invokeMatchingMethod(___methodName, ___methods, ___target, ___args))
            )
        )
    )

    (defn- #_"Throwable" Reflector'getCauseOrElse [#_"Exception" ___e]
        (when (ß ___e.getCause() != nil)
            (§ return (ß ___e.getCause()))
        )
        ___e
    )

    (defn- #_"RuntimeException" Reflector'throwCauseOrElseException [#_"Exception" ___e]
        (when (ß ___e.getCause() != nil)
            (throw (ß Util'sneakyThrow(___e.getCause())))
        )
        (throw (Util'sneakyThrow ___e))
    )

    (defn- #_"String" Reflector'noMethodReport [#_"String" ___methodName, #_"Object" ___target]
        (ß "No matching method found: " + ___methodName + ((___target == nil) ? "" :or " for " + ___target.getClass()))
    )

    (defn #_"Object" Reflector'invokeMatchingMethod [#_"String" ___methodName, #_"List" ___methods, #_"Object" ___target, #_"Object[]" ___args]
        (let [#_"java.lang.reflect.Method" ___m nil]
            (let [#_"Object[]" ___boxedArgs nil]
                (cond (ß ___methods.isEmpty())
                    (do
                        (throw (§ unsure IllegalArgumentException. (ß noMethodReport(___methodName, ___target))))
                    )
                    (ß ___methods.size() == 1)
                    (do
                        (§ ass ___m (ß (java.lang.reflect.Method) ___methods.get(0)))
                        (§ ass ___boxedArgs (ß boxArgs(___m.getParameterTypes(), ___args)))
                    )
                    :else ;; overloaded w/same arity
                    (do
                        (let [#_"java.lang.reflect.Method" ___foundm nil]
                            (loop-when-recur [#_"Iterator" ___i (ß ___methods.iterator())] (ß ___i.hasNext()) [___i]
                                (§ ass ___m (ß (java.lang.reflect.Method) ___i.next()))

                                (let [#_"Class[]" ___params (ß ___m.getParameterTypes())]
                                    (when (ß isCongruent(___params, ___args))
                                        (when (ß ___foundm == nil || Compiler'subsumes(___params, ___foundm.getParameterTypes()))
                                            (§ ass ___foundm ___m)
                                            (§ ass ___boxedArgs (ß boxArgs(___params, ___args)))
                                        )
                                    )
                                )
                            )
                            (§ ass ___m ___foundm)
                        )
                    )
                )
                (when (nil? ___m)
                    (throw (§ unsure IllegalArgumentException. (ß noMethodReport(___methodName, ___target))))
                )

                (when (ß !Modifier/isPublic(___m.getDeclaringClass().getModifiers()))
                    ;; public method of non-public class, try to find it in hierarchy
                    (let [#_"java.lang.reflect.Method" ___oldm ___m]
                        (§ ass ___m (ß getAsMethodOfPublicBase(___target.getClass(), ___m)))
                        (when (nil? ___m)
                            (throw (IllegalArgumentException. (str "Can't call public method of non-public class: " (ß ___oldm.toString()))))
                        )
                    )
                )
                (try
                    (ß Reflector'prepRet(___m.getReturnType(), ___m.invoke(___target, ___boxedArgs)))
                    (catch Exception ___e
                        (throw (ß Util'sneakyThrow(getCauseOrElse(___e))))
                    )
                )
            )
        )
    )

    (defn #_"java.lang.reflect.Method" Reflector'getAsMethodOfPublicBase [#_"Class" ___c, #_"java.lang.reflect.Method" ___m]
        (doseq [#_"Class" ___iface (ß ___c.getInterfaces())]
            (doseq [#_"java.lang.reflect.Method" ___im (ß ___iface.getMethods())]
                (when (ß isMatch(___im, ___m))
                    (§ return ___im)
                )
            )
        )
        (let [#_"Class" ___sc (ß ___c.getSuperclass())]
            (when (nil? ___sc)
                (§ return nil)
            )
            (doseq [#_"java.lang.reflect.Method" ___scm (ß ___sc.getMethods())]
                (when (ß isMatch(___scm, ___m))
                    (§ return ___scm)
                )
            )
            (ß getAsMethodOfPublicBase(___sc, ___m))
        )
    )

    (defn #_"boolean" Reflector'isMatch [#_"java.lang.reflect.Method" ___lhs, #_"java.lang.reflect.Method" ___rhs]
        (when (ß !___lhs.getName().equals(___rhs.getName()) || !Modifier/isPublic(___lhs.getDeclaringClass().getModifiers()))
            (§ return false)
        )

        (let [#_"Class[]" ___types1 (ß ___lhs.getParameterTypes())]
            (let [#_"Class[]" ___types2 (ß ___rhs.getParameterTypes())]
                (when (ß ___types1.length != ___types2.length)
                    (§ return false)
                )

                (let [#_"boolean" ___match true]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___types1.length) [(inc ___i)]
                        (when (ß !___types1[___i].isAssignableFrom(___types2[___i]))
                            (§ ass ___match false)
                            (§ break )
                        )
                    )
                    ___match
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeConstructor [#_"Class" ___c, #_"Object[]" ___args]
        (try
            (let [#_"Constructor[]" ___allctors (ß ___c.getConstructors())]
                (let [#_"ArrayList" ___ctors (ArrayList.)]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allctors.length) [(inc ___i)]
                        (let [#_"Constructor" ___ctor (ß ___allctors[___i])]
                            (when (ß ___ctor.getParameterTypes().length == ___args.length)
                                (ß ___ctors.add(___ctor))
                            )
                        )
                    )
                    (cond (ß ___ctors.isEmpty())
                        (do
                            (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                        )
                        (ß ___ctors.size() == 1)
                        (do
                            (let [#_"Constructor" ___ctor (ß (Constructor) ___ctors.get(0))]
                                (ß ___ctor.newInstance(boxArgs(___ctor.getParameterTypes(), ___args)))
                            )
                        )
                        :else ;; overloaded w/same arity
                        (do
                            (loop-when-recur [#_"Iterator" ___iterator (ß ___ctors.iterator())] (ß ___iterator.hasNext()) [___iterator]
                                (let [#_"Constructor" ___ctor (ß (Constructor) ___iterator.next())]
                                    (let [#_"Class[]" ___params (ß ___ctor.getParameterTypes())]
                                        (when (ß isCongruent(___params, ___args))
                                            (let [#_"Object[]" ___boxedArgs (ß boxArgs(___params, ___args))]
                                                (§ return (ß ___ctor.newInstance(___boxedArgs)))
                                            )
                                        )
                                    )
                                )
                            )
                            (throw (IllegalArgumentException. (str "No matching ctor found for " ___c)))
                        )
                    )
                )
            )
            (catch Exception ___e
                (throw (ß Util'sneakyThrow(getCauseOrElse(___e))))
            )
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethodVariadic [#_"String" ___className, #_"String" ___methodName, #_"Object..." ___args]
        (ß invokeStaticMethod(___className, ___methodName, ___args))
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3s [#_"String" ___className, #_"String" ___methodName, #_"Object[]" ___args]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (ß invokeStaticMethod(___c, ___methodName, ___args))
        )
    )

    (defn #_"Object" Reflector'invokeStaticMethod-3c [#_"Class" ___c, #_"String" ___methodName, #_"Object[]" ___args]
        (when (ß ___methodName.equals("new"))
            (§ return (ß invokeConstructor(___c, ___args)))
        )
        (let [#_"List" ___methods (ß getMethods(___c, ___args.length, ___methodName, true))]
            (ß invokeMatchingMethod(___methodName, ___methods, nil, ___args))
        )
    )

    (defn #_"Object" Reflector'getStaticField-2s [#_"String" ___className, #_"String" ___fieldName]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (ß getStaticField(___c, ___fieldName))
        )
    )

    (defn #_"Object" Reflector'getStaticField-2c [#_"Class" ___c, #_"String" ___fieldName]
        (let [#_"Field" ___f (ß getField(___c, ___fieldName, true))]
            (when (some? ___f)
                (try
                    (§ return (ß Reflector'prepRet(___f.getType(), ___f.get(nil))))
                    (catch IllegalAccessException ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
            (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " ___c)))
        )
    )

    (defn #_"Object" Reflector'setStaticField-3s [#_"String" ___className, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Class" ___c (RT'classForName-1 ___className)]
            (ß setStaticField(___c, ___fieldName, ___val))
        )
    )

    (defn #_"Object" Reflector'setStaticField-3c [#_"Class" ___c, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Field" ___f (ß getField(___c, ___fieldName, true))]
            (when (some? ___f)
                (try
                    (ß ___f.set(nil, boxArg(___f.getType(), ___val)))
                    (catch IllegalAccessException ___e
                        (throw (Util'sneakyThrow ___e))
                    )
                )
                (§ return ___val)
            )
            (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " ___c)))
        )
    )

    (defn #_"Object" Reflector'getInstanceField [#_"Object" ___target, #_"String" ___fieldName]
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"Field" ___f (ß getField(___c, ___fieldName, false))]
                (when (some? ___f)
                    (try
                        (§ return (ß Reflector'prepRet(___f.getType(), ___f.get(___target))))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                )
                (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " (ß ___target.getClass()))))
            )
        )
    )

    (defn #_"Object" Reflector'setInstanceField [#_"Object" ___target, #_"String" ___fieldName, #_"Object" ___val]
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"Field" ___f (ß getField(___c, ___fieldName, false))]
                (when (some? ___f)
                    (try
                        (ß ___f.set(___target, boxArg(___f.getType(), ___val)))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                    (§ return ___val)
                )
                (throw (IllegalArgumentException. (str "No matching field found: " ___fieldName " for " (ß ___target.getClass()))))
            )
        )
    )

    ;; not used as of Clojure 1.6, but left for runtime compatibility with compiled bytecode from older versions
    (defn #_"Object" Reflector'invokeNoArgInstanceMember-2 [#_"Object" ___target, #_"String" ___name]
        (ß invokeNoArgInstanceMember(___target, ___name, false))
    )

    (defn #_"Object" Reflector'invokeNoArgInstanceMember-3 [#_"Object" ___target, #_"String" ___name, #_"boolean" ___requireField]
        (let [#_"Class" ___c (ß ___target.getClass())]
            (if ___requireField
                (do
                    (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                        (if (some? ___f)
                            (do
                                (ß getInstanceField(___target, ___name))
                            )
                            (do
                                (throw (IllegalArgumentException. (str "No matching field found: " ___name " for " (ß ___target.getClass()))))
                            )
                        )
                    )
                )
                (do
                    (let [#_"List" ___meths (ß getMethods(___c, 0, ___name, false))]
                        (if (ß ___meths.size() > 0)
                            (do
                                (ß invokeMatchingMethod(___name, ___meths, ___target, RT'EMPTY_ARRAY))
                            )
                            (do
                                (ß getInstanceField(___target, ___name))
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-2 [#_"Object" ___target, #_"String" ___name]
        ;; check for field first
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                (when (some? ___f) ;; field get
                    (try
                        (§ return (ß Reflector'prepRet(___f.getType(), ___f.get(___target))))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                )
                (ß invokeInstanceMethod(___target, ___name, RT'EMPTY_ARRAY))
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3o [#_"String" ___name, #_"Object" ___target, #_"Object" ___arg1]
        ;; check for field first
        (let [#_"Class" ___c (ß ___target.getClass())]
            (let [#_"Field" ___f (ß getField(___c, ___name, false))]
                (when (some? ___f) ;; field set
                    (try
                        (ß ___f.set(___target, boxArg(___f.getType(), ___arg1)))
                        (catch IllegalAccessException ___e
                            (throw (Util'sneakyThrow ___e))
                        )
                    )
                    (§ return ___arg1)
                )
                (ß invokeInstanceMethod(___target, ___name, new Object[] (§ array ___arg1 )))
            )
        )
    )

    (defn #_"Object" Reflector'invokeInstanceMember-3a [#_"String" ___name, #_"Object" ___target, #_"Object..." ___args]
        (ß invokeInstanceMethod(___target, ___name, ___args))
    )

    (defn #_"Field" Reflector'getField [#_"Class" ___c, #_"String" ___name, #_"boolean" ___getStatics]
        (let [#_"Field[]" ___allfields (ß ___c.getFields())]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allfields.length) [(inc ___i)]
                (when (ß ___name.equals(___allfields[___i].getName()) && Modifier/isStatic(___allfields[___i].getModifiers()) == ___getStatics)
                    (§ return (ß ___allfields[___i]))
                )
            )
            nil
        )
    )

    (defn #_"List" Reflector'getMethods [#_"Class" ___c, #_"int" ___arity, #_"String" ___name, #_"boolean" ___getStatics]
        (let [#_"java.lang.reflect.Method[]" ___allmethods (ß ___c.getMethods())]
            (let [#_"ArrayList" ___methods (ArrayList.)]
                (let [#_"ArrayList" ___bridgeMethods (ArrayList.)]
                    (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allmethods.length) [(inc ___i)]
                        (let [#_"java.lang.reflect.Method" ___method (ß ___allmethods[___i])]
                            (when (ß ___name.equals(___method.getName()) && Modifier/isStatic(___method.getModifiers()) == ___getStatics && ___method.getParameterTypes().length == ___arity)
                                (try
                                    (if (ß ___method.isBridge() && ___c.getMethod(___method.getName(), ___method.getParameterTypes()).equals(___method))
                                        (do
                                            (ß ___bridgeMethods.add(___method))
                                        )
                                        (do
                                            (ß ___methods.add(___method))
                                        )
                                    )
                                    (catch NoSuchMethodException ___e
                                    )
                                )
                            )
                        )
                    )

                    (when (ß ___methods.isEmpty())
                        (ß ___methods.addAll(___bridgeMethods))
                    )
                    (when (ß !___getStatics && ___c.isInterface())
                        (§ ass ___allmethods (ß (§ class Object).getMethods()))
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___allmethods.length) [(inc ___i)]
                            (when (ß ___name.equals(___allmethods[___i].getName()) && Modifier/isStatic(___allmethods[___i].getModifiers()) == ___getStatics && ___allmethods[___i].getParameterTypes().length == ___arity)
                                (ß ___methods.add(___allmethods[___i]))
                            )
                        )
                    )
                    ___methods
                )
            )
        )
    )

    (defn #_"Object" Reflector'boxArg [#_"Class" ___paramType, #_"Object" ___arg]
        (cond (ß !___paramType.isPrimitive())
            (do
                (§ return (ß ___paramType.cast(___arg)))
            )
            (ß ___paramType == (§ class boolean))
            (do
                (§ return (ß (§ class Boolean).cast(___arg)))
            )
            (ß ___paramType == (§ class char))
            (do
                (§ return (ß (§ class Character).cast(___arg)))
            )
            (ß ___arg instanceof Number)
            (do
                (let [#_"Number" ___n (ß (Number) ___arg)]
                    (cond (ß ___paramType == (§ class int))
                        (do
                            (§ return (ß ___n.intValue()))
                        )
                        (ß ___paramType == (§ class float))
                        (do
                            (§ return (ß ___n.floatValue()))
                        )
                        (ß ___paramType == (§ class double))
                        (do
                            (§ return (ß ___n.doubleValue()))
                        )
                        (ß ___paramType == (§ class long))
                        (do
                            (§ return (ß ___n.longValue()))
                        )
                        (ß ___paramType == (§ class short))
                        (do
                            (§ return (ß ___n.shortValue()))
                        )
                        (ß ___paramType == (§ class byte))
                        (do
                            (§ return (ß ___n.byteValue()))
                        )
                    )
                )
            )
        )
        (throw (IllegalArgumentException. (str "Unexpected param type, expected: " ___paramType ", given: " (ß ___arg.getClass().getName()))))
    )

    (defn #_"Object[]" Reflector'boxArgs [#_"Class[]" ___params, #_"Object[]" ___args]
        (when (ß ___params.length == 0)
            (§ return nil)
        )
        (let [#_"Object[]" ___ret (make-array Object (ß ___params.length))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___params.length) [(inc ___i)]
                (let [#_"Object" ___arg (ß ___args[___i])]
                    (let [#_"Class" ___paramType (ß ___params[___i])]
                        (§ ass (ß ___ret[___i]) (ß boxArg(___paramType, ___arg)))
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"boolean" Reflector'paramArgTypeMatch [#_"Class" ___paramType, #_"Class" ___argType]
        (when (nil? ___argType)
            (§ return (ß !___paramType.isPrimitive()))
        )
        (when (ß ___paramType == ___argType || ___paramType.isAssignableFrom(___argType))
            (§ return true)
        )
        (cond (ß ___paramType == (§ class int))
            (do
                (§ return (ß ___argType == (§ class Integer)
                    || ___argType == (§ class long)
                    || ___argType == (§ class Long)
                    || ___argType == (§ class short)
                    || ___argType == (§ class byte)))
            )
            (ß ___paramType == (§ class float))
            (do
                (§ return (ß ___argType == (§ class Float)
                    || ___argType == (§ class double)))
            )
            (ß ___paramType == (§ class double))
            (do
                (§ return (ß ___argType == (§ class Double)
                    || ___argType == (§ class float)))
            )
            (ß ___paramType == (§ class long))
            (do
                (§ return (ß ___argType == (§ class Long)
                    || ___argType == (§ class int)
                    || ___argType == (§ class short)
                    || ___argType == (§ class byte)))
            )
            (ß ___paramType == (§ class char))
            (do
                (§ return (ß ___argType == (§ class Character)))
            )
            (ß ___paramType == (§ class short))
            (do
                (§ return (ß ___argType == (§ class Short)))
            )
            (ß ___paramType == (§ class byte))
            (do
                (§ return (ß ___argType == (§ class Byte)))
            )
            (ß ___paramType == (§ class boolean))
            (do
                (§ return (ß ___argType == (§ class Boolean)))
            )
        )
        false
    )

    (defn #_"boolean" Reflector'isCongruent [#_"Class[]" ___params, #_"Object[]" ___args]
        (let [#_"boolean" ___ret false]
            (when (nil? ___args)
                (§ return (ß (___params.length == 0)))
            )
            (when (ß ___params.length == ___args.length)
                (§ ass ___ret true)
                (loop-when-recur [#_"int" ___i 0] (ß ___ret && ___i < ___params.length) [(inc ___i)]
                    (let [#_"Object" ___arg (ß ___args[___i])]
                        (let [#_"Class" ___argType (ß (___arg == nil) ? nil :or ___arg.getClass())]
                            (let [#_"Class" ___paramType (ß ___params[___i])]
                                (§ ass ___ret (ß paramArgTypeMatch(___paramType, ___argType)))
                            )
                        )
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"Object" Reflector'prepRet [#_"Class" ___c, #_"Object" ___x]
        (when (ß !(___c.isPrimitive() || ___c == (§ class Boolean)))
            (§ return ___x)
        )
        (when (ß ___x instanceof Boolean)
            (§ return (ß ((Boolean) ___x) ? Boolean/TRUE :or Boolean/FALSE))
        )
        ___x
    )
)
)

(java-ns cloiure.lang.Repeat

(class-ns Repeat (§ extends ASeq) (§ implements IReduce)
    (def- #_"long" Repeat'INFINITE -1)

    (defn- #_"Repeat" Repeat'init []
        (hash-map
            #_"long" :count 0 ;; always INFINITE or >0
            #_"Object" :val nil
            #_volatile
            #_"ISeq" :_next nil ;; cached
        )
    )

    (defn- #_"Repeat" Repeat'new-2 [#_"long" ___count, #_"Object" ___val]
        (let [this (merge (ASeq'new) (Repeat'init))]
            (§ ass (:count this) ___count)
            (§ ass (:val this) ___val)
            this
        )
    )

    (defn- #_"Repeat" Repeat'new-3 [#_"IPersistentMap" ___meta, #_"long" ___count, #_"Object" ___val]
        (let [this (merge (ASeq'new ___meta) (Repeat'init))]
            (§ ass (:count this) ___count)
            (§ ass (:val this) ___val)
            this
        )
    )

    (defn #_"Repeat" Repeat'create-1 [#_"Object" ___val]
        (Repeat'new-2 Repeat'INFINITE, ___val)
    )

    (defn #_"ISeq" Repeat'create-2 [#_"long" ___count, #_"Object" ___val]
        (when (ß ___count <= 0)
            (§ return PersistentList'EMPTY)
        )
        (Repeat'new-2 ___count, ___val)
    )

    #_method
    (§ defn #_"Object" first [#_"Repeat" this]
        (:val this)
    )

    #_method
    (§ defn #_"ISeq" next [#_"Repeat" this]
        (when (nil? (:_next this))
            (cond (> (:count this) 1)
                (do
                    (§ ass (:_next this) (ß Repeat'new-2((:count this) - 1, (:val this))))
                )
                (ß (:count this) == Repeat'INFINITE)
                (do
                    (§ ass (:_next this) this)
                )
            )
        )
        (:_next this)
    )

    #_method
    (§ defn #_"Repeat" withMeta [#_"Repeat" this, #_"IPersistentMap" ___meta]
        (Repeat'new-3 ___meta, (:count this), (:val this))
    )

    #_method
    (§ defn #_"Object" reduce [#_"Repeat" this, #_"IFn" ___f]
        (let [#_"Object" ___ret (:val this)]
            (if (ß (:count this) == Repeat'INFINITE)
                (do
                    (while true
                        (§ ass ___ret (ß ___f.invoke(___ret, (:val this))))
                        (when (RT'isReduced ___ret)
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"long" ___i 1] (< ___i (:count this)) [(inc ___i)]
                        (§ ass ___ret (ß ___f.invoke(___ret, (:val this))))
                        (when (RT'isReduced ___ret)
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                    )
                    ___ret
                )
            )
        )
    )

    #_method
    (§ defn #_"Object" reduce [#_"Repeat" this, #_"IFn" ___f, #_"Object" ___start]
        (let [#_"Object" ___ret ___start]
            (if (ß (:count this) == Repeat'INFINITE)
                (do
                    (while true
                        (§ ass ___ret (ß ___f.invoke(___ret, (:val this))))
                        (when (RT'isReduced ___ret)
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                    )
                )
                (do
                    (loop-when-recur [#_"long" ___i 0] (< ___i (:count this)) [(inc ___i)]
                        (§ ass ___ret (ß ___f.invoke(___ret, (:val this))))
                        (when (RT'isReduced ___ret)
                            (§ return (ß ((IDeref)___ret).deref()))
                        )
                    )
                    ___ret
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.RestFn

#_stateless
#_abstract
(class-ns RestFn (§ extends AFunction)
    #_protected
    (defn #_"RestFn" RestFn'new []
        (AFunction'new)
    )

    #_abstract
    (§ defn #_"int" getRequiredArity [#_"RestFn" this])

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___args]
        nil
    )

    #_protected
    #_method
    (§ defn #_"Object" doInvoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object" ___args]
        nil
    )

    #_method
    (§ defn #_"Object" applyTo [#_"RestFn" this, #_"ISeq" ___args]
        (when (ß RT'boundedLength(___args, getRequiredArity()) <= getRequiredArity())
            (§ return (ß AFn'applyToHelper(this, Util'ret1(___args, (§ ass ___args nil)))))
        )
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (§ return (ß doInvoke(Util'ret1(___args, (§ ass ___args nil)))))
            )
            (§ case 1)
            (do
                (§ return (ß doInvoke(___args.first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 2)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 3)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 4)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 5)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 6)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 7)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 8)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 9)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 10)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 11)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 12)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 13)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 14)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 15)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 16)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 17)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 18)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 19)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
            (§ case 20)
            (do
                (§ return (ß doInvoke(___args.first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        (§ ass ___args (ß ___args.next())).first(),
                        Util'ret1(___args.next(), (§ ass ___args nil)))))
            )
        )
        (ß throwArity(-1))
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(nil))
            )
            (§ default )
            (do
                (ß throwArity(0))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(ArraySeq'create-1(Util'ret1(___arg1, (§ ass ___arg1 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(Util'ret1(___arg1, (§ ass ___arg1 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(1))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(2))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg3, (§ ass ___arg3 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(3))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg4, (§ ass ___arg4 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(4))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(5))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(6))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(7))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(8))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(9))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    ArraySeq'create-1(
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(10))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(11))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(12))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(13))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(14))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(15))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(16))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(17))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(18))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg19, (§ ass ___arg19 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(19))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ArraySeq'create-1(
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        ArraySeq'create-1(
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)), nil))
            )
            (§ default )
            (do
                (ß throwArity(20))
            )
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"RestFn" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (§ switch (ß getRequiredArity())
            (§ case 0)
            (do
                (ß doInvoke(
                    ontoArrayPrepend(___args,
                        Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 1)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg2, (§ ass ___arg2 nil)),
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 2)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg3, (§ ass ___arg3 nil)),
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 3)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg4, (§ ass ___arg4 nil)),
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 4)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg5, (§ ass ___arg5 nil)),
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 5)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg6, (§ ass ___arg6 nil)),
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 6)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg7, (§ ass ___arg7 nil)),
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 7)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg8, (§ ass ___arg8 nil)),
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 8)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg9, (§ ass ___arg9 nil)),
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 9)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg10, (§ ass ___arg10 nil)),
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 10)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg11, (§ ass ___arg11 nil)),
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 11)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg12, (§ ass ___arg12 nil)),
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 12)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg13, (§ ass ___arg13 nil)),
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 13)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg14, (§ ass ___arg14 nil)),
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 14)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg15, (§ ass ___arg15 nil)),
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 15)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg16, (§ ass ___arg16 nil)),
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 16)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg17, (§ ass ___arg17 nil)),
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 17)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg18, (§ ass ___arg18 nil)),
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 18)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg19, (§ ass ___arg19 nil)),
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 19)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                        ontoArrayPrepend(___args,
                            Util'ret1(___arg20, (§ ass ___arg20 nil)))))
            )
            (§ case 20)
            (do
                (ß doInvoke(
                    Util'ret1(___arg1, (§ ass ___arg1 nil)),
                    Util'ret1(___arg2, (§ ass ___arg2 nil)),
                    Util'ret1(___arg3, (§ ass ___arg3 nil)),
                    Util'ret1(___arg4, (§ ass ___arg4 nil)),
                    Util'ret1(___arg5, (§ ass ___arg5 nil)),
                    Util'ret1(___arg6, (§ ass ___arg6 nil)),
                    Util'ret1(___arg7, (§ ass ___arg7 nil)),
                    Util'ret1(___arg8, (§ ass ___arg8 nil)),
                    Util'ret1(___arg9, (§ ass ___arg9 nil)),
                    Util'ret1(___arg10, (§ ass ___arg10 nil)),
                    Util'ret1(___arg11, (§ ass ___arg11 nil)),
                    Util'ret1(___arg12, (§ ass ___arg12 nil)),
                    Util'ret1(___arg13, (§ ass ___arg13 nil)),
                    Util'ret1(___arg14, (§ ass ___arg14 nil)),
                    Util'ret1(___arg15, (§ ass ___arg15 nil)),
                    Util'ret1(___arg16, (§ ass ___arg16 nil)),
                    Util'ret1(___arg17, (§ ass ___arg17 nil)),
                    Util'ret1(___arg18, (§ ass ___arg18 nil)),
                    Util'ret1(___arg19, (§ ass ___arg19 nil)),
                    Util'ret1(___arg20, (§ ass ___arg20 nil)),
                        ArraySeq'create-1(___args)))
            )
            (§ default )
            (do
                (ß throwArity(21))
            )
        )
    )

    #_protected
    (defn #_"ISeq" RestFn'ontoArrayPrepend [#_"Object[]" ___array, #_"Object..." ___args]
        (let [#_"ISeq" ___ret (ArraySeq'create-1 ___array)]
            (loop-when-recur [#_"int" ___i (ß ___args.length - 1)] (ß ___i >= 0) [(dec ___i)]
                (§ ass ___ret (ß RT'cons(___args[___i], ___ret)))
            )
            ___ret
        )
    )

    #_protected
    (defn #_"ISeq" RestFn'findKey [#_"Object" ___key, #_"ISeq" ___args]
        (while (some? ___args)
            (when (ß ___key == ___args.first())
                (§ return (ß ___args.next()))
            )
            (§ ass ___args (RT'next ___args))
            (§ ass ___args (RT'next ___args))
        )
        nil
    )
)
)

(java-ns cloiure.lang.Reversible

(defprotocol Reversible
    #_abstract
    (#_"ISeq" Reversible'''rseq [#_"Reversible" this])
)
)

(java-ns cloiure.lang.RT

(§ import java.net.MalformedURLException)
(§ import java.util.concurrent.atomic.AtomicInteger)
(§ import java.util.concurrent.Callable)
(§ import java.util.*)
(§ import java.util.regex.Matcher)
(§ import java.util.regex.Pattern)
(§ import java.io.*)
(§ import java.lang.reflect.Array)
(§ import java.math.BigDecimal)
(§ import java.math.BigInteger)
(§ import java.security.AccessController)
(§ import java.security.PrivilegedAction)
(§ import java.net.URL)
(§ import java.net.JarURLConnection)
(§ import java.nio.charset.Charset)
(§ import java.net.URLConnection)

#_private
#_closure
(class-ns DefaultComparator (§ implements Comparator)
    (defn #_"DefaultComparator" DefaultComparator'new []
        (hash-map)
    )

    #_method
    (§ defn #_"int" compare [#_"DefaultComparator" this, #_"Object" ___o1, #_"Object" ___o2]
        (Util'compare ___o1, ___o2)
    )
)

#_stateless
(class-ns RT
    (def #_"Boolean" RT'T Boolean/TRUE)
    (def #_"Boolean" RT'F Boolean/FALSE)
    (def #_"String" RT'LOADER_SUFFIX "__init")

    ;; simple-symbol->class
    (def #_"IPersistentMap" RT'DEFAULT_IMPORTS (ß map(
        (§ map
            (Symbol'intern-1 "Boolean")                         (§ class Boolean)
            (Symbol'intern-1 "Byte")                            (§ class Byte)
            (Symbol'intern-1 "Character")                       (§ class Character)
            (Symbol'intern-1 "Class")                           (§ class Class)
            (Symbol'intern-1 "ClassLoader")                     (§ class ClassLoader)
            (Symbol'intern-1 "Compiler")                        (§ class Compiler)
            (Symbol'intern-1 "Double")                          (§ class Double)
            (Symbol'intern-1 "Enum")                            (§ class Enum)
            (Symbol'intern-1 "Float")                           (§ class Float)
            (Symbol'intern-1 "InheritableThreadLocal")          (§ class InheritableThreadLocal)
            (Symbol'intern-1 "Integer")                         (§ class Integer)
            (Symbol'intern-1 "Long")                            (§ class Long)
            (Symbol'intern-1 "Math")                            (§ class Math)
            (Symbol'intern-1 "Number")                          (§ class Number)
            (Symbol'intern-1 "Object")                          (§ class Object)
            (Symbol'intern-1 "Package")                         (§ class Package)
            (Symbol'intern-1 "Process")                         (§ class Process)
            (Symbol'intern-1 "ProcessBuilder")                  (§ class ProcessBuilder)
            (Symbol'intern-1 "Runtime")                         (§ class Runtime)
            (Symbol'intern-1 "RuntimePermission")               (§ class RuntimePermission)
            (Symbol'intern-1 "SecurityManager")                 (§ class SecurityManager)
            (Symbol'intern-1 "Short")                           (§ class Short)
            (Symbol'intern-1 "StackTraceElement")               (§ class StackTraceElement)
            (Symbol'intern-1 "StrictMath")                      (§ class StrictMath)
            (Symbol'intern-1 "String")                          (§ class String)
            (Symbol'intern-1 "StringBuffer")                    (§ class StringBuffer)
            (Symbol'intern-1 "StringBuilder")                   (§ class StringBuilder)
            (Symbol'intern-1 "System")                          (§ class System)
            (Symbol'intern-1 "Thread")                          (§ class Thread)
            (Symbol'intern-1 "ThreadGroup")                     (§ class ThreadGroup)
            (Symbol'intern-1 "ThreadLocal")                     (§ class ThreadLocal)
            (Symbol'intern-1 "Throwable")                       (§ class Throwable)
            (Symbol'intern-1 "Void")                            (§ class Void)
            (Symbol'intern-1 "Appendable")                      (§ class Appendable)
            (Symbol'intern-1 "CharSequence")                    (§ class CharSequence)
            (Symbol'intern-1 "Cloneable")                       (§ class Cloneable)
            (Symbol'intern-1 "Comparable")                      (§ class Comparable)
            (Symbol'intern-1 "Iterable")                        (§ class Iterable)
            (Symbol'intern-1 "Readable")                        (§ class Readable)
            (Symbol'intern-1 "Runnable")                        (§ class Runnable)
            (Symbol'intern-1 "Callable")                        (§ class Callable)
            (Symbol'intern-1 "BigInteger")                      (§ class BigInteger)
            (Symbol'intern-1 "BigDecimal")                      (§ class BigDecimal)
            (Symbol'intern-1 "ArithmeticException")             (§ class ArithmeticException)
            (Symbol'intern-1 "ArrayIndexOutOfBoundsException")  (§ class ArrayIndexOutOfBoundsException)
            (Symbol'intern-1 "ArrayStoreException")             (§ class ArrayStoreException)
            (Symbol'intern-1 "ClassCastException")              (§ class ClassCastException)
            (Symbol'intern-1 "ClassNotFoundException")          (§ class ClassNotFoundException)
            (Symbol'intern-1 "CloneNotSupportedException")      (§ class CloneNotSupportedException)
            (Symbol'intern-1 "EnumConstantNotPresentException") (§ class EnumConstantNotPresentException)
            (Symbol'intern-1 "Exception")                       (§ class Exception)
            (Symbol'intern-1 "IllegalAccessException")          (§ class IllegalAccessException)
            (Symbol'intern-1 "IllegalArgumentException")        (§ class IllegalArgumentException)
            (Symbol'intern-1 "IllegalMonitorStateException")    (§ class IllegalMonitorStateException)
            (Symbol'intern-1 "IllegalStateException")           (§ class IllegalStateException)
            (Symbol'intern-1 "IllegalThreadStateException")     (§ class IllegalThreadStateException)
            (Symbol'intern-1 "IndexOutOfBoundsException")       (§ class IndexOutOfBoundsException)
            (Symbol'intern-1 "InstantiationException")          (§ class InstantiationException)
            (Symbol'intern-1 "InterruptedException")            (§ class InterruptedException)
            (Symbol'intern-1 "NegativeArraySizeException")      (§ class NegativeArraySizeException)
            (Symbol'intern-1 "NoSuchFieldException")            (§ class NoSuchFieldException)
            (Symbol'intern-1 "NoSuchMethodException")           (§ class NoSuchMethodException)
            (Symbol'intern-1 "NullPointerException")            (§ class NullPointerException)
            (Symbol'intern-1 "NumberFormatException")           (§ class NumberFormatException)
            (Symbol'intern-1 "RuntimeException")                (§ class RuntimeException)
            (Symbol'intern-1 "SecurityException")               (§ class SecurityException)
            (Symbol'intern-1 "StringIndexOutOfBoundsException") (§ class StringIndexOutOfBoundsException)
            (Symbol'intern-1 "TypeNotPresentException")         (§ class TypeNotPresentException)
            (Symbol'intern-1 "UnsupportedOperationException")   (§ class UnsupportedOperationException)
            (Symbol'intern-1 "AbstractMethodError")             (§ class AbstractMethodError)
            (Symbol'intern-1 "AssertionError")                  (§ class AssertionError)
            (Symbol'intern-1 "ClassCircularityError")           (§ class ClassCircularityError)
            (Symbol'intern-1 "ClassFormatError")                (§ class ClassFormatError)
            (Symbol'intern-1 "Error")                           (§ class Error)
            (Symbol'intern-1 "ExceptionInInitializerError")     (§ class ExceptionInInitializerError)
            (Symbol'intern-1 "IllegalAccessError")              (§ class IllegalAccessError)
            (Symbol'intern-1 "IncompatibleClassChangeError")    (§ class IncompatibleClassChangeError)
            (Symbol'intern-1 "InstantiationError")              (§ class InstantiationError)
            (Symbol'intern-1 "InternalError")                   (§ class InternalError)
            (Symbol'intern-1 "LinkageError")                    (§ class LinkageError)
            (Symbol'intern-1 "NoClassDefFoundError")            (§ class NoClassDefFoundError)
            (Symbol'intern-1 "NoSuchFieldError")                (§ class NoSuchFieldError)
            (Symbol'intern-1 "NoSuchMethodError")               (§ class NoSuchMethodError)
            (Symbol'intern-1 "OutOfMemoryError")                (§ class OutOfMemoryError)
            (Symbol'intern-1 "StackOverflowError")              (§ class StackOverflowError)
            (Symbol'intern-1 "ThreadDeath")                     (§ class ThreadDeath)
            (Symbol'intern-1 "UnknownError")                    (§ class UnknownError)
            (Symbol'intern-1 "UnsatisfiedLinkError")            (§ class UnsatisfiedLinkError)
            (Symbol'intern-1 "UnsupportedClassVersionError")    (§ class UnsupportedClassVersionError)
            (Symbol'intern-1 "VerifyError")                     (§ class VerifyError)
            (Symbol'intern-1 "VirtualMachineError")             (§ class VirtualMachineError)
            (Symbol'intern-1 "Thread$UncaughtExceptionHandler") (§ class Thread$UncaughtExceptionHandler)
            (Symbol'intern-1 "Thread$State")                    (§ class Thread$State)
            (Symbol'intern-1 "Deprecated")                      (§ class Deprecated)
            (Symbol'intern-1 "Override")                        (§ class Override)
            (Symbol'intern-1 "SuppressWarnings")                (§ class SuppressWarnings)
        )
    )))

    ;; single instance of UTF-8 Charset, so as to avoid catching UnsupportedCharsetExceptions everywhere
    (def #_"Charset" RT'UTF8 (Charset/forName "UTF-8"))

    (defn #_"Object" RT'readTrueFalseUnknown [#_"String" ___s]
        (cond (ß ___s.equals("true"))
            (do
                (§ return Boolean/TRUE)
            )
            (ß ___s.equals("false"))
            (do
                (§ return Boolean/FALSE)
            )
        )
        (Keyword'intern-2 nil, "unknown")
    )

    (def #_"Namespace" RT'CLOIURE_NS (ß Namespace'findOrCreate(Symbol'intern-1("cloiure.core"))))
    (def #_"Var" RT'OUT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*out*"), (OutputStreamWriter. System/out)).setDynamic()))
    (def #_"Var" RT'IN (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*in*"), LineNumberingPushbackReader'new-1((InputStreamReader. System/in))).setDynamic()))
    (def #_"Var" RT'ERR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*err*"), (PrintWriter. (§ pars (OutputStreamWriter. System/err), true))).setDynamic()))
    (§ def #_"Keyword" RT'TAG_KEY (Keyword'intern-2 nil, "tag"))
    (§ def #_"Keyword" RT'CONST_KEY (Keyword'intern-2 nil, "const"))
    (def #_"Var" RT'AGENT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*agent*"), nil).setDynamic()))
    (def #_"Object" RT'readeval (ß readTrueFalseUnknown(System/getProperty("cloiure.read.eval", "true"))))
    (def #_"Var" RT'READEVAL (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*read-eval*"), readeval).setDynamic()))
    (def #_"Var" RT'DATA_READERS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*data-readers*"), RT'map()).setDynamic()))
    (def #_"Var" RT'DEFAULT_DATA_READER_FN (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*default-data-reader-fn*"), RT'map()).setDynamic()))
    (def #_"Var" RT'DEFAULT_DATA_READERS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("default-data-readers"), RT'map())))
    (def #_"Var" RT'SUPPRESS_READ (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*suppress-read*"), nil).setDynamic()))
    (def #_"Var" RT'ASSERT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*assert*"), RT'T).setDynamic()))
    (def #_"Var" RT'MATH_CONTEXT (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*math-context*"), nil).setDynamic()))
    (§ def #_"Keyword" RT'LINE_KEY (Keyword'intern-2 nil, "line"))
    (§ def #_"Keyword" RT'COLUMN_KEY (Keyword'intern-2 nil, "column"))
    (§ def #_"Keyword" RT'FILE_KEY (Keyword'intern-2 nil, "file"))
    (§ def #_"Keyword" RT'DECLARED_KEY (Keyword'intern-2 nil, "declared"))
    (§ def #_"Keyword" RT'DOC_KEY (Keyword'intern-2 nil, "doc"))
    (def #_"Var" RT'USE_CONTEXT_CLASSLOADER (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*use-context-classloader*"), RT'T).setDynamic()))
    ;; boolean
    (def #_"Var" RT'UNCHECKED_MATH (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-1("cloiure.core")), Symbol'intern-1("*unchecked-math*"), Boolean/FALSE).setDynamic()))

    (§ def #_"Symbol" RT'LOAD_FILE (Symbol'intern-1 "load-file"))
    (§ def #_"Symbol" RT'IN_NAMESPACE (Symbol'intern-1 "in-ns"))
    (§ def #_"Symbol" RT'NAMESPACE (Symbol'intern-1 "ns"))
    (§ def #_"Symbol" RT'IDENTICAL (Symbol'intern-1 "identical?"))
    (def #_"Var" RT'CMD_LINE_ARGS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*command-line-args*"), nil).setDynamic()))
    ;; symbol
    (def #_"Var" RT'CURRENT_NS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*ns*"), RT'CLOIURE_NS).setDynamic()))

    (def #_"Var" RT'FLUSH_ON_NEWLINE (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*flush-on-newline*"), RT'T).setDynamic()))
    (def #_"Var" RT'PRINT_META (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-meta*"), RT'F).setDynamic()))
    (def #_"Var" RT'PRINT_READABLY (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-readably*"), RT'T).setDynamic()))
    (def #_"Var" RT'PRINT_DUP (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*print-dup*"), RT'F).setDynamic()))
    (def #_"Var" RT'WARN_ON_REFLECTION (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*warn-on-reflection*"), RT'F).setDynamic()))
    (def #_"Var" RT'ALLOW_UNRESOLVED_VARS (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*allow-unresolved-vars*"), RT'F).setDynamic()))
    (def #_"Var" RT'READER_RESOLVER (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*reader-resolver*"), nil).setDynamic()))

    (def #_"Var" RT'IN_NS_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("in-ns"), RT'F)))
    (def #_"Var" RT'NS_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("ns"), RT'F)))
    (def #_"Var" RT'FN_LOADER_VAR (ß Var'intern-3(RT'CLOIURE_NS, Symbol'intern-1("*fn-loader*"), nil).setDynamic()))
    (def #_"Var" RT'PRINT_INITIALIZED (ß Var'intern-2n(RT'CLOIURE_NS, Symbol'intern-1("print-initialized"))))
    (def #_"Var" RT'PR_ON (ß Var'intern-2n(RT'CLOIURE_NS, Symbol'intern-1("pr-on"))))

    (def #_"IFn" RT'inNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1]
                (let [#_"Symbol" ___nsname (ß (Symbol) ___arg1)]
                    (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsname)]
                        (ß RT'CURRENT_NS.set(___ns))
                        ___ns
                    )
                )
            )
        )
    )

    (def #_"IFn" RT'bootNamespace
        (§ reify AFn()
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" _____form, #_"Object" _____env, #_"Object" ___arg1]
                (let [#_"Symbol" ___nsname (ß (Symbol) ___arg1)]
                    (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsname)]
                        (ß RT'CURRENT_NS.set(___ns))
                        ___ns
                    )
                )
            )
        )
    )

    (defn #_"List<String>" RT'processCommandLine [#_"String[]" ___args]
        (let [#_"List<String>" ___arglist (Arrays/asList ___args)]
            (let [#_"int" ___split (ß ___arglist.indexOf("--"))]
                (when (ß ___split >= 0)
                    (ß RT'CMD_LINE_ARGS.bindRoot(RT'seq(___arglist.subList(___split + 1, ___args.length))))
                    (§ return (ß ___arglist.subList(0, ___split)))
                )
                ___arglist
            )
        )
    )

    ;; duck typing stderr plays nice with e.g. swank
    (defn #_"PrintWriter" RT'errPrintWriter []
        (let [#_"Writer" ___w (ß (Writer) RT'ERR.deref())]
            (if (ß ___w instanceof PrintWriter)
                (do
                    (ß (PrintWriter) ___w)
                )
                (do
                    (§ unsure PrintWriter. ___w)
                )
            )
        )
    )

    (def #_"Object[]" RT'EMPTY_ARRAY (make-array Object 0))
    (§ def #_"Comparator" RT'DEFAULT_COMPARATOR (DefaultComparator'new))

    (def #_"AtomicInteger" RT'ID (AtomicInteger. 1))

    (defn #_"void" RT'addURL [#_"Object" ___url] #_(§ throws MalformedURLException)
        (let [#_"URL" ___u (ß (___url instanceof String) ? (URL. (§ pars (String) ___url)) :or (URL) ___url)]
            (let [#_"ClassLoader" ___ccl (ß Thread/currentThread().getContextClassLoader())]
                (if (ß ___ccl instanceof DynamicClassLoader)
                    (do
                        (ß ((DynamicClassLoader)___ccl).addURL(___u))
                    )
                    (do
                        (throw (IllegalAccessError. "Context classloader is not a DynamicClassLoader"))
                    )
                )
                nil
            )
        )
    )

    (def #_"boolean" RT'CHECK_SPEC_ASSERTS false #_"cloiure.spec.check-asserts")
    (def #_"boolean" RT'INSTRUMENT_MACROS true #_"cloiure.spec.skip-macros")
    #_volatile
    (def #_"boolean" RT'CHECK_SPECS false)

    (§ static
        (let [#_"Keyword" ___arglistskw (Keyword'intern-2 nil, "arglists")]
            (let [#_"Symbol" ___namesym (Symbol'intern-1 "name")]
                (ß RT'OUT.setTag(Symbol'intern-1("java.io.Writer")))
                (ß RT'CURRENT_NS.setTag(Symbol'intern-1("cloiure.lang.Namespace")))
                (ß RT'AGENT.setMeta(map(RT'DOC_KEY, "The agent currently running an action on this thread, else nil")))
                (ß RT'AGENT.setTag(Symbol'intern-1("cloiure.lang.Agent")))
                (ß RT'MATH_CONTEXT.setTag(Symbol'intern-1("java.math.MathContext")))
                (let [#_"Var" ___nv (Var'intern-3 RT'CLOIURE_NS, RT'NAMESPACE, bootNamespace)]
                    (ß ___nv.setMacro())
                    (§ let [#_"Var" ___v]
                        (§ ass ___v (Var'intern-3 RT'CLOIURE_NS, RT'IN_NAMESPACE, inNamespace))
                        (ß ___v.setMeta(map(RT'DOC_KEY, "Sets *ns* to the namespace named by the symbol, creating it if needed.", ___arglistskw, list(vector(___namesym)))))
                        (§ ass ___v (ß Var'intern-3(RT'CLOIURE_NS, RT'LOAD_FILE,
                                (§ reify AFn()
                                    #_method
                                    (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___arg1]
                                        (try
                                            (ß Compiler'loadFile((String) ___arg1))
                                            (catch IOException ___e
                                                (throw (Util'sneakyThrow ___e))
                                            )
                                        )
                                    )
                                )
                            ))
                        )
                        (ß ___v.setMeta(map(RT'DOC_KEY, "Sequentially read and evaluate the set of forms contained in the file.", ___arglistskw, list(vector(___namesym)))))
                        (try
                            (ß doInit())
                            (catch Exception ___e
                                (throw (Util'sneakyThrow ___e))
                            )
                        )

                        (§ ass RT'CHECK_SPECS RT'INSTRUMENT_MACROS)
                    )
                )
            )
        )
    )

    (defn #_"Keyword" RT'keyword [#_"String" ___ns, #_"String" ___name]
        (Keyword'intern (Symbol'intern-2 ___ns, ___name))
    )

    (defn #_"Var" RT'var-2 [#_"String" ___ns, #_"String" ___name]
        (ß Var'intern-2n(Namespace'findOrCreate(Symbol'intern-2(nil, ___ns)), Symbol'intern-2(nil, ___name)))
    )

    (defn #_"Var" RT'var-3 [#_"String" ___ns, #_"String" ___name, #_"Object" ___init]
        (ß Var'intern-3(Namespace'findOrCreate(Symbol'intern-2(nil, ___ns)), Symbol'intern-2(nil, ___name), ___init))
    )

    (defn #_"void" RT'loadResourceScript-1 [#_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___name, true))
        nil
    )

    (defn #_"void" RT'maybeLoadResourceScript [#_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___name, false))
        nil
    )

    (defn #_"void" RT'loadResourceScript-2s [#_"String" ___name, #_"boolean" ___failIfNotFound] #_(§ throws IOException)
        (ß loadResourceScript((§ class RT), ___name, ___failIfNotFound))
        nil
    )

    (defn #_"void" RT'loadResourceScript-2c [#_"Class" ___c, #_"String" ___name] #_(§ throws IOException)
        (ß loadResourceScript(___c, ___name, true))
        nil
    )

    (defn #_"void" RT'loadResourceScript-3 [#_"Class" ___c, #_"String" ___name, #_"boolean" ___failIfNotFound] #_(§ throws IOException)
        (let [#_"int" ___slash (ß ___name.lastIndexOf(\/))]
            (let [#_"String" ___file (ß (___slash >= 0) ? ___name.substring(___slash + 1) :or ___name)]
                (let [#_"InputStream" ___ins (ß resourceAsStream(baseLoader(), ___name))]
                    (cond (some? ___ins)
                        (do
                            (try
                                (ß Compiler'load-3((InputStreamReader. ___ins, RT'UTF8), ___name, ___file))
                                (finally
                                    (ß ___ins.close())
                                )
                            )
                        )
                        ___failIfNotFound
                        (do
                            (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " ___name)))
                        )
                    )
                    nil
                )
            )
        )
    )

    (defn #_"long" RT'lastModified [#_"URL" ___url, #_"String" ___libfile] #_(§ throws IOException)
        (let [#_"URLConnection" ___connection (ß ___url.openConnection())]
            (try
                (if (ß ___url.getProtocol().equals("jar"))
                    (do
                        (ß ((JarURLConnection) ___connection).getJarFile().getEntry(___libfile).getTime())
                    )
                    (do
                        (ß ___connection.getLastModified())
                    )
                )
                (finally
                    (let [#_"InputStream" ___ins (ß ___connection.getInputStream())]
                        (when (some? ___ins)
                            (ß ___ins.close())
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'compile [#_"String" ___cljfile] #_(§ throws IOException)
        (let [#_"InputStream" ___ins (ß resourceAsStream(baseLoader(), ___cljfile))]
            (if (some? ___ins)
                (do
                    (try
                        (ß Compiler'compile((InputStreamReader. ___ins, RT'UTF8), ___cljfile, ___cljfile.substring(1 + ___cljfile.lastIndexOf("/"))))
                        (finally
                            (ß ___ins.close())
                        )
                    )
                )
                (do
                    (throw (FileNotFoundException. (str "Could not locate Cloiure resource on classpath: " ___cljfile)))
                )
            )
            nil
        )
    )

    (defn #_"void" RT'load-1 [#_"String" ___scriptbase] #_(§ throws IOException, ClassNotFoundException)
        (ß load(___scriptbase, true))
        nil
    )

    (defn #_"void" RT'load-2 [#_"String" ___scriptbase, #_"boolean" ___failIfNotFound] #_(§ throws IOException, ClassNotFoundException)
        (let [#_"String" ___classfile (ß ___scriptbase + RT'LOADER_SUFFIX + ".class")]
            (let [#_"String" ___cljfile (ß ___scriptbase + ".cli")]
                (let [#_"String" ___scriptfile ___cljfile]
                    (let [#_"URL" ___classURL (ß getResource(baseLoader(), ___classfile))]
                        (let [#_"URL" ___cljURL (ß getResource(baseLoader(), ___scriptfile))]
                            (when (nil? ___cljURL)
                                (§ ass ___scriptfile (ß ___scriptbase + ".clic"))
                                (§ ass ___cljURL (ß getResource(baseLoader(), ___scriptfile)))
                            )
                            (let [#_"boolean" ___loaded false]
                                (when (ß (___classURL != nil && (___cljURL == nil || lastModified(___classURL, ___classfile) > lastModified(___cljURL, ___scriptfile))) || ___classURL == nil)
                                    (try
                                        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
                                            (§ map
                                                RT'CURRENT_NS         (ß RT'CURRENT_NS.deref())
                                                RT'WARN_ON_REFLECTION (ß RT'WARN_ON_REFLECTION.deref())
                                                RT'UNCHECKED_MATH  (ß RT'UNCHECKED_MATH.deref())
                                            )
                                        )))
                                        (§ ass ___loaded (ß (loadClassForName(___scriptbase.replace(\/, \.) + RT'LOADER_SUFFIX) != nil)))
                                        (finally
                                            (ß Var'popThreadBindings())
                                        )
                                    )
                                )
                                (cond (ß !___loaded && ___cljURL != nil)
                                    (do
                                        (if (ß booleanCast(Compiler'COMPILE_FILES.deref()))
                                            (do
                                                (ß compile(___scriptfile))
                                            )
                                            (do
                                                (ß loadResourceScript((§ class RT), ___scriptfile))
                                            )
                                        )
                                    )
                                    (ß !___loaded && ___failIfNotFound)
                                    (do
                                        (throw (FileNotFoundException. (String/format "Could not locate %s or %s on classpath.%s", (§ array ___classfile, ___cljfile, (if (ß ___scriptbase.contains("_")) " Please check that namespaces with dashes use underscores in the Cloiure file name." "")))))
                                    )
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"void" RT'doInit [] #_(§ throws ClassNotFoundException, IOException)
        (ß load("cloiure/core"))

        (ß Var'pushThreadBindings(RT'mapUniqueKeys(
            (§ map
                RT'CURRENT_NS         (ß RT'CURRENT_NS.deref())
                RT'WARN_ON_REFLECTION (ß RT'WARN_ON_REFLECTION.deref())
                RT'UNCHECKED_MATH  (ß RT'UNCHECKED_MATH.deref())
            )
        )))
        (try
            (let [#_"Symbol" ___USER (Symbol'intern-1 "user")]
                (let [#_"Symbol" ___CLOIURE (Symbol'intern-1 "cloiure.core")]
                    (let [#_"Var" ___in_ns (ß var("cloiure.core", "in-ns"))]
                        (let [#_"Var" ___refer (ß var("cloiure.core", "refer"))]
                            (ß ___in_ns.invoke(___USER))
                            (ß ___refer.invoke(___CLOIURE))
                            (ß maybeLoadResourceScript("user.cli"))

                            ;; start socket servers
                            (let [#_"Var" ___require (ß var("cloiure.core", "require"))]
                                (let [#_"Symbol" ___SERVER (Symbol'intern-1 "cloiure.core.server")]
                                    (ß ___require.invoke(___SERVER))
                                    (let [#_"Var" ___start_servers (ß var("cloiure.core.server", "start-servers"))]
                                        (ß ___start_servers.invoke(System/getProperties()))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (ß Var'popThreadBindings())
            )
        )
        nil
    )

    (defn #_"int" RT'nextID []
        (ß RT'ID.getAndIncrement())
    )

    ;; Load a library in the System ClassLoader instead of Cloiure's own.
    (defn #_"void" RT'loadLibrary [#_"String" ___libname]
        (System/loadLibrary ___libname)
        nil
    )

    (def- #_"int" RT'CHUNK_SIZE 32)

    (defn #_"ISeq" RT'chunkIteratorSeq [#_"Iterator" ___iter]
        (when (ß ___iter.hasNext())
            (§ return (ß LazySeq'new-1(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this]
                            (let [#_"Object[]" ___arr (make-array Object RT'CHUNK_SIZE)]
                                (let [#_"int" ___n 0]
                                    (while (ß ___iter.hasNext() && ___n < RT'CHUNK_SIZE)
                                        (§ ass (ß ___arr[___n]) (ß ___iter.next()))
                                        (§ ass ___n (inc ___n))
                                    )
                                    (ß ChunkedCons'new-2(ArrayChunk'new-3(___arr, 0, ___n), chunkIteratorSeq(___iter)))
                                )
                            )
                        )
                    )
                ))
            )
        )
        nil
    )

    (defn #_"ISeq" RT'seq [#_"Object" ___coll]
        (cond (ß ___coll instanceof ASeq)
            (do
                (ß (ASeq) ___coll)
            )
            (ß ___coll instanceof LazySeq)
            (do
                (ß ((LazySeq) ___coll).seq())
            )
            :else
            (do
                (ß seqFrom(___coll))
            )
        )
    )

    ;; N.B. canSeq must be kept in sync with this!
    (defn #_"ISeq" RT'seqFrom [#_"Object" ___coll]
        (cond (ß ___coll instanceof Seqable)
            (do
                (ß ((Seqable) ___coll).seq())
            )
            (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof Iterable)
            (do
                (ß chunkIteratorSeq(((Iterable) ___coll).iterator()))
            )
            (ß ___coll.getClass().isArray())
            (do
                (ArraySeq'createFromObject ___coll)
            )
            (ß ___coll instanceof CharSequence)
            (do
                (ß StringSeq'create((CharSequence) ___coll))
            )
            (ß ___coll instanceof Map)
            (do
                (ß seq(((Map) ___coll).entrySet()))
            )
            :else
            (do
                (let [#_"Class" ___c (ß ___coll.getClass())]
                    (let [#_"Class" ___sc (ß ___c.getSuperclass())]
                        (throw (IllegalArgumentException. (str "Don't know how to create ISeq from: " (ß ___c.getName()))))
                    )
                )
            )
        )
    )

    (defn #_"boolean" RT'canSeq [#_"Object" ___coll]
        (ß ___coll instanceof ISeq
            || ___coll instanceof Seqable
            || ___coll == nil
            || ___coll instanceof Iterable
            || ___coll.getClass().isArray()
            || ___coll instanceof CharSequence
            || ___coll instanceof Map)
    )

    (defn #_"Iterator" RT'iter [#_"Object" ___coll]
        (cond (ß ___coll instanceof Iterable)
            (do
                (ß ((Iterable)___coll).iterator())
            )
            (nil? ___coll)
            (do
                (§ reify Iterator()
                    #_method
                    (§ defn #_"boolean" hasNext [#_"Iterator" this]
                        false
                    )

                    #_method
                    (§ defn #_"Object" next [#_"Iterator" this]
                        (throw (NoSuchElementException.))
                    )

                    #_method
                    (§ defn #_"void" remove [#_"Iterator" this]
                        (throw (UnsupportedOperationException.))
                    )
                )
            )
            (ß ___coll instanceof Map)
            (do
                (ß ((Map)___coll).entrySet().iterator())
            )
            (ß ___coll instanceof String)
            (do
                (let [#_"String" ___s (ß (String) ___coll)]
                    (§ reify Iterator()
                        (let [#_"int" ___i 0]
                            #_method
                            (§ defn #_"boolean" hasNext [#_"Iterator" this]
                                (ß (___i < ___s.length()))
                            )

                            #_method
                            (§ defn #_"Object" next [#_"Iterator" this]
                                (let [_ (ß ___s.charAt(___i))]
                                    (§ ass ___i (inc ___i))
                                    _
                                )
                            )

                            #_method
                            (§ defn #_"void" remove [#_"Iterator" this]
                                (throw (UnsupportedOperationException.))
                            )
                        )
                    )
                )
            )
            (ß ___coll.getClass().isArray())
            (do
                (ArrayIter'createFromObject ___coll)
            )
            :else
            (do
                (ß iter(seq(___coll)))
            )
        )
    )

    (defn #_"Object" RT'seqOrElse [#_"Object" ___o]
        (ß (seq(___o) == nil) ? nil :or ___o)
    )

    (defn #_"ISeq" RT'keys [#_"Object" ___coll]
        (if (ß ___coll instanceof IPersistentMap)
            (do
                (ß KeySeq'createFromMap((IPersistentMap)___coll))
            )
            (do
                (ß KeySeq'create(seq(___coll)))
            )
        )
    )

    (defn #_"ISeq" RT'vals [#_"Object" ___coll]
        (if (ß ___coll instanceof IPersistentMap)
            (do
                (ß ValSeq'createFromMap((IPersistentMap)___coll))
            )
            (do
                (ß ValSeq'create(seq(___coll)))
            )
        )
    )

    (defn #_"IPersistentMap" RT'meta [#_"Object" ___x]
        (when (ß ___x instanceof IMeta)
            (§ return (ß ((IMeta) ___x).meta()))
        )
        nil
    )

    (defn #_"int" RT'count [#_"Object" ___o]
        (when (ß ___o instanceof Counted)
            (§ return (ß ((Counted) ___o).count()))
        )
        (ß countFrom(Util'ret1(___o, (§ ass ___o nil))))
    )

    (defn #_"int" RT'countFrom [#_"Object" ___o]
        (cond (nil? ___o)
            (do
                (§ return 0)
            )
            (ß ___o instanceof IPersistentCollection)
            (do
                (let [#_"ISeq" ___s (ß seq(___o))]
                    (§ ass ___o nil)
                    (let [#_"int" ___i 0]
                        (loop-when-recur [___s ___s] (some? ___s) [(ß ___s.next())]
                            (when (ß ___s instanceof Counted)
                                (§ return (ß ___i + ___s.count()))
                            )
                            (§ ass ___i (inc ___i))
                        )
                        (§ return ___i)
                    )
                )
            )
            (ß ___o instanceof CharSequence)
            (do
                (§ return (ß ((CharSequence) ___o).length()))
            )
            (ß ___o instanceof Collection)
            (do
                (§ return (ß ((Collection) ___o).size()))
            )
            (ß ___o instanceof Map)
            (do
                (§ return (ß ((Map) ___o).size()))
            )
            (ß ___o instanceof Map$Entry)
            (do
                (§ return 2)
            )
            (ß ___o.getClass().isArray())
            (do
                (§ return (Array/getLength ___o))
            )
        )

        (throw (UnsupportedOperationException. (str "count not supported on this type: " (ß ___o.getClass().getSimpleName()))))
    )

    (defn #_"IPersistentCollection" RT'conj [#_"IPersistentCollection" ___coll, #_"Object" ___x]
        (when (nil? ___coll)
            (§ return (PersistentList'new-1 ___x))
        )
        (ß ___coll.cons(___x))
    )

    (defn #_"ISeq" RT'cons [#_"Object" ___x, #_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                (PersistentList'new-1 ___x)
            )
            (ß ___coll instanceof ISeq)
            (do
                (ß Cons'new-2(___x, (ISeq) ___coll))
            )
            :else
            (do
                (ß Cons'new-2(___x, seq(___coll)))
            )
        )
    )

    (defn #_"Object" RT'first [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß ((ISeq) ___x).first()))
        )
        (let [#_"ISeq" ___seq (ß seq(___x))]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ß ___seq.first())
        )
    )

    (defn #_"Object" RT'second [#_"Object" ___x]
        (ß first(next(___x)))
    )

    (defn #_"Object" RT'third [#_"Object" ___x]
        (ß first(next(next(___x))))
    )

    (defn #_"Object" RT'fourth [#_"Object" ___x]
        (ß first(next(next(next(___x)))))
    )

    (defn #_"ISeq" RT'next [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß ((ISeq) ___x).next()))
        )
        (let [#_"ISeq" ___seq (ß seq(___x))]
            (when (nil? ___seq)
                (§ return nil)
            )
            (ß ___seq.next())
        )
    )

    (defn #_"ISeq" RT'more [#_"Object" ___x]
        (when (ß ___x instanceof ISeq)
            (§ return (ß ((ISeq) ___x).more()))
        )
        (let [#_"ISeq" ___seq (ß seq(___x))]
            (when (nil? ___seq)
                (§ return PersistentList'EMPTY)
            )
            (ß ___seq.more())
        )
    )

    (defn #_"Object" RT'peek [#_"Object" ___x]
        (when (nil? ___x)
            (§ return nil)
        )
        (ß ((IPersistentStack) ___x).peek())
    )

    (defn #_"Object" RT'pop [#_"Object" ___x]
        (when (nil? ___x)
            (§ return nil)
        )
        (ß ((IPersistentStack) ___x).pop())
    )

    (defn #_"Object" RT'get-2 [#_"Object" ___coll, #_"Object" ___key]
        (when (ß ___coll instanceof ILookup)
            (§ return (ß ((ILookup) ___coll).valAt(___key)))
        )
        (ß getFrom(___coll, ___key))
    )

    (defn #_"Object" RT'getFrom-2 [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return nil)
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (§ return (ß ___m.get(___key)))
                )
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" ___set (ß (IPersistentSet) ___coll)]
                    (§ return (ß ___set.get(___key)))
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || ___coll.getClass().isArray()))
            (do
                (let [#_"int" ___n (ß ((Number) ___key).intValue())]
                    (when (ß ___n >= 0 && ___n < count(___coll))
                        (§ return (ß nth(___coll, ___n)))
                    )
                    (§ return nil)
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" ___set (ß (ITransientSet) ___coll)]
                    (§ return (ß ___set.get(___key)))
                )
            )
        )

        nil
    )

    (defn #_"Object" RT'get-3 [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___notFound]
        (when (ß ___coll instanceof ILookup)
            (§ return (ß ((ILookup) ___coll).valAt(___key, ___notFound)))
        )
        (ß getFrom(___coll, ___key, ___notFound))
    )

    (defn #_"Object" RT'getFrom-3 [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___notFound]
        (cond (nil? ___coll)
            (do
                (§ return ___notFound)
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (when (ß ___m.containsKey(___key))
                        (§ return (ß ___m.get(___key)))
                    )
                    (§ return ___notFound)
                )
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (let [#_"IPersistentSet" ___set (ß (IPersistentSet) ___coll)]
                    (when (ß ___set.contains(___key))
                        (§ return (ß ___set.get(___key)))
                    )
                    (§ return ___notFound)
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || ___coll.getClass().isArray()))
            (do
                (let [#_"int" ___n (ß ((Number) ___key).intValue())]
                    (§ return (ß (___n >= 0 && ___n < count(___coll)) ? nth(___coll, ___n) :or ___notFound))
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (let [#_"ITransientSet" ___set (ß (ITransientSet) ___coll)]
                    (when (ß ___set.contains(___key))
                        (§ return (ß ___set.get(___key)))
                    )
                    (§ return ___notFound)
                )
            )
        )
        ___notFound
    )

    (defn #_"Associative" RT'assoc [#_"Object" ___coll, #_"Object" ___key, #_"Object" ___val]
        (when (nil? ___coll)
            (§ return (ß PersistentArrayMap'new-1(new Object[] (§ array ___key, ___val ))))
        )
        (ß ((Associative) ___coll).assoc(___key, ___val))
    )

    (defn #_"Object" RT'contains [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return RT'F)
            )
            (ß ___coll instanceof Associative)
            (do
                (§ return (ß ((Associative) ___coll).containsKey(___key) ? RT'T :or RT'F))
            )
            (ß ___coll instanceof IPersistentSet)
            (do
                (§ return (ß ((IPersistentSet) ___coll).contains(___key) ? RT'T :or RT'F))
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (§ return (ß ___m.containsKey(___key) ? RT'T :or RT'F))
                )
            )
            (ß ___coll instanceof Set)
            (do
                (let [#_"Set" ___s (ß (Set) ___coll)]
                    (§ return (ß ___s.contains(___key) ? RT'T :or RT'F))
                )
            )
            (ß ___key instanceof Number && (___coll instanceof String || ___coll.getClass().isArray()))
            (do
                (let [#_"int" ___n (ß ((Number) ___key).intValue())]
                    (§ return (ß (___n >= 0 && ___n < count(___coll)) ? RT'T :or RT'F))
                )
            )
            (ß ___coll instanceof ITransientSet)
            (do
                (§ return (ß ((ITransientSet)___coll).contains(___key) ? RT'T :or RT'F))
            )
            (ß ___coll instanceof ITransientAssociative2)
            (do
                (§ return (ß (((ITransientAssociative2)___coll).containsKey(___key)) ? RT'T :or RT'F))
            )
        )
        (throw (IllegalArgumentException. (str "contains? not supported on type: " (ß ___coll.getClass().getName()))))
    )

    (defn #_"Object" RT'find [#_"Object" ___coll, #_"Object" ___key]
        (cond (nil? ___coll)
            (do
                (§ return nil)
            )
            (ß ___coll instanceof Associative)
            (do
                (§ return (ß ((Associative) ___coll).entryAt(___key)))
            )
            (ß ___coll instanceof Map)
            (do
                (let [#_"Map" ___m (ß (Map) ___coll)]
                    (when (ß ___m.containsKey(___key))
                        (§ return (ß MapEntry'create(___key, ___m.get(___key))))
                    )
                    (§ return nil)
                )
            )
            (ß ___coll instanceof ITransientAssociative2)
            (do
                (§ return (ß ((ITransientAssociative2) ___coll).entryAt(___key)))
            )
        )
        (throw (IllegalArgumentException. (str "find not supported on type: " (ß ___coll.getClass().getName()))))
    )

    ;; takes a seq of key, val, key, val

    ;; returns tail starting at val of matching key if found, else nil
    (defn #_"ISeq" RT'findKey [#_"Keyword" ___key, #_"ISeq" ___keyvals]
        (while (some? ___keyvals)
            (let [#_"ISeq" ___r (ß ___keyvals.next())]
                (when (nil? ___r)
                    (throw (Util'runtimeException-1 "Malformed keyword argslist"))
                )
                (when (ß ___keyvals.first() == ___key)
                    (§ return ___r)
                )
                (§ ass ___keyvals (ß ___r.next()))
            )
        )
        nil
    )

    (defn #_"Object" RT'dissoc [#_"Object" ___coll, #_"Object" ___key]
        (when (nil? ___coll)
            (§ return nil)
        )
        (ß ((IPersistentMap) ___coll).without(___key))
    )

    (defn #_"Object" RT'nth-2 [#_"Object" ___coll, #_"int" ___n]
        (when (ß ___coll instanceof Indexed)
            (§ return (ß ((Indexed) ___coll).nth(___n)))
        )
        (ß nthFrom(Util'ret1(___coll, (§ ass ___coll nil)), ___n))
    )

    (defn #_"Object" RT'nthFrom-2 [#_"Object" ___coll, #_"int" ___n]
        (cond (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof CharSequence)
            (do
                (ß Character/valueOf(((CharSequence) ___coll).charAt(___n)))
            )
            (ß ___coll.getClass().isArray())
            (do
                (ß Reflector'prepRet(___coll.getClass().getComponentType(), Array/get(___coll, ___n)))
            )
            (ß ___coll instanceof RandomAccess)
            (do
                (ß ((List) ___coll).get(___n))
            )
            (ß ___coll instanceof Matcher)
            (do
                (ß ((Matcher) ___coll).group(___n))
            )
            (ß ___coll instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___coll)]
                    (cond (ß ___n == 0)
                        (do
                            (§ return (ß ___e.getKey()))
                        )
                        (ß ___n == 1)
                        (do
                            (§ return (ß ___e.getValue()))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            (ß ___coll instanceof Sequential)
            (do
                (let [#_"ISeq" ___seq (RT'seq ___coll)]
                    (§ ass ___coll nil)
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (ß ___i <= ___n && ___seq != nil) [(inc ___i) (ß ___seq.next())]
                        (when (ß ___i == ___n)
                            (§ return (ß ___seq.first()))
                        )
                    )
                    (throw (IndexOutOfBoundsException.))
                )
            )
            :else
            (do
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (ß ___coll.getClass().getSimpleName()))))
            )
        )
    )

    (defn #_"Object" RT'nth-3 [#_"Object" ___coll, #_"int" ___n, #_"Object" ___notFound]
        (when (ß ___coll instanceof Indexed)
            (let [#_"Indexed" ___v (ß (Indexed) ___coll)]
                (§ return (ß ___v.nth(___n, ___notFound)))
            )
        )
        (ß nthFrom(___coll, ___n, ___notFound))
    )

    (defn #_"Object" RT'nthFrom-3 [#_"Object" ___coll, #_"int" ___n, #_"Object" ___notFound]
        (cond (nil? ___coll)
            (do
                ___notFound
            )
            (< ___n 0)
            (do
                ___notFound
            )
            (ß ___coll instanceof CharSequence)
            (do
                (let [#_"CharSequence" ___s (ß (CharSequence) ___coll)]
                    (when (ß ___n < ___s.length())
                        (§ return (ß Character/valueOf(___s.charAt(___n))))
                    )
                    ___notFound
                )
            )
            (ß ___coll.getClass().isArray())
            (do
                (when (ß ___n < Array/getLength(___coll))
                    (§ return (ß Reflector'prepRet(___coll.getClass().getComponentType(), Array/get(___coll, ___n))))
                )
                ___notFound
            )
            (ß ___coll instanceof RandomAccess)
            (do
                (let [#_"List" ___list (ß (List) ___coll)]
                    (when (ß ___n < ___list.size())
                        (§ return (ß ___list.get(___n)))
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Matcher)
            (do
                (let [#_"Matcher" ___m (ß (Matcher) ___coll)]
                    (when (ß ___n < ___m.groupCount())
                        (§ return (ß ___m.group(___n)))
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Map$Entry)
            (do
                (let [#_"Map$Entry" ___e (ß (Map$Entry) ___coll)]
                    (cond (ß ___n == 0)
                        (do
                            (§ return (ß ___e.getKey()))
                        )
                        (ß ___n == 1)
                        (do
                            (§ return (ß ___e.getValue()))
                        )
                    )
                    ___notFound
                )
            )
            (ß ___coll instanceof Sequential)
            (do
                (let [#_"ISeq" ___seq (RT'seq ___coll)]
                    (§ ass ___coll nil)
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (ß ___i <= ___n && ___seq != nil) [(inc ___i) (ß ___seq.next())]
                        (when (ß ___i == ___n)
                            (§ return (ß ___seq.first()))
                        )
                    )
                    ___notFound
                )
            )
            :else
            (do
                (throw (UnsupportedOperationException. (str "nth not supported on this type: " (ß ___coll.getClass().getSimpleName()))))
            )
        )
    )

    (defn #_"Object" RT'assocN [#_"int" ___n, #_"Object" ___val, #_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                nil
            )
            (ß ___coll instanceof IPersistentVector)
            (do
                (ß ((IPersistentVector) ___coll).assocN(___n, ___val))
            )
            (ß ___coll instanceof Object[])
            (do
                ;; hmm... this is not persistent
                (let [#_"Object[]" ___array (ß ((Object[]) ___coll))]
                    (§ ass (ß ___array[___n]) ___val)
                    ___array
                )
            )
            :else
            (do
                nil
            )
        )
    )

    (defn #_"boolean" RT'hasTag [#_"Object" ___o, #_"Object" ___tag]
        (ß Util'equals(___tag, RT'get-2(RT'meta(___o), RT'TAG_KEY)))
    )

    (defn #_"Object" RT'box-1o [#_"Object" ___x]
        ___x
    )

    (defn #_"Character" RT'box-1c [#_"char" ___x]
        (Character/valueOf ___x)
    )

    (defn #_"Object" RT'box-1z [#_"boolean" ___x]
        (ß ___x ? RT'T :or RT'F)
    )

    (defn #_"Object" RT'box-1Z [#_"Boolean" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1s [#_"short" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1i [#_"int" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1l [#_"long" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1f [#_"float" ___x]
        ___x
    )

    (defn #_"Number" RT'box-1d [#_"double" ___x]
        ___x
    )

    (defn #_"char" RT'charCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Character)
            (§ return (ß ((Character) ___x).charValue()))
        )
        (let [#_"long" ___n (ß ((Number) ___x).longValue())]
            (when (ß ___n < Character/MIN_VALUE || ___n > Character/MAX_VALUE)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            (ß (char) ___n)
        )
    )

    (defn #_"char" RT'charCast-1b [#_"byte" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1s [#_"short" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"char" RT'charCast-1i [#_"int" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1l [#_"long" ___x]
        (let [#_"char" ___i (ß (char) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
            )
            ___i
        )
    )

    (defn #_"char" RT'charCast-1f [#_"float" ___x]
        (when (ß ___x >= Character/MIN_VALUE && ___x <= Character/MAX_VALUE)
            (§ return (ß (char) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
    )

    (defn #_"char" RT'charCast-1d [#_"double" ___x]
        (when (ß ___x >= Character/MIN_VALUE && ___x <= Character/MAX_VALUE)
            (§ return (ß (char) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for char: " ___x)))
    )

    (defn #_"boolean" RT'booleanCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Boolean)
            (§ return (ß ((Boolean) ___x).booleanValue()))
        )
        (ß (___x != nil))
    )

    (defn #_"boolean" RT'booleanCast-1b [#_"boolean" ___x]
        ___x
    )

    (defn #_"byte" RT'byteCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Byte)
            (§ return (ß ((Byte) ___x).byteValue()))
        )
        (let [#_"long" ___n (ß longCast(___x))]
            (when (ß ___n < Byte/MIN_VALUE || ___n > Byte/MAX_VALUE)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            (ß (byte) ___n)
        )
    )

    (defn #_"byte" RT'byteCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"byte" RT'byteCast-1s [#_"short" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1i [#_"int" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1l [#_"long" ___x]
        (let [#_"byte" ___i (ß (byte) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
            )
            ___i
        )
    )

    (defn #_"byte" RT'byteCast-1f [#_"float" ___x]
        (when (ß ___x >= Byte/MIN_VALUE && ___x <= Byte/MAX_VALUE)
            (§ return (ß (byte) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
    )

    (defn #_"byte" RT'byteCast-1d [#_"double" ___x]
        (when (ß ___x >= Byte/MIN_VALUE && ___x <= Byte/MAX_VALUE)
            (§ return (ß (byte) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for byte: " ___x)))
    )

    (defn #_"short" RT'shortCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Short)
            (§ return (ß ((Short) ___x).shortValue()))
        )
        (let [#_"long" ___n (ß longCast(___x))]
            (when (ß ___n < Short/MIN_VALUE || ___n > Short/MAX_VALUE)
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            (ß (short) ___n)
        )
    )

    (defn #_"short" RT'shortCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"short" RT'shortCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"short" RT'shortCast-1i [#_"int" ___x]
        (let [#_"short" ___i (ß (short) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            ___i
        )
    )

    (defn #_"short" RT'shortCast-1l [#_"long" ___x]
        (let [#_"short" ___i (ß (short) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
            )
            ___i
        )
    )

    (defn #_"short" RT'shortCast-1f [#_"float" ___x]
        (when (ß ___x >= Short/MIN_VALUE && ___x <= Short/MAX_VALUE)
            (§ return (ß (short) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
    )

    (defn #_"short" RT'shortCast-1d [#_"double" ___x]
        (when (ß ___x >= Short/MIN_VALUE && ___x <= Short/MAX_VALUE)
            (§ return (ß (short) ___x))
        )
        (throw (IllegalArgumentException. (str "Value out of range for short: " ___x)))
    )

    (defn #_"int" RT'intCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Integer)
            (§ return (ß ((Integer)___x).intValue()))
        )
        (when (ß ___x instanceof Number)
            (let [#_"long" ___n (ß longCast(___x))]
                (§ return (ß intCast(___n)))
            )
        )
        (ß ((Character) ___x).charValue())
    )

    (defn #_"int" RT'intCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"int" RT'intCast-1f [#_"float" ___x]
        (when (ß ___x < Integer/MIN_VALUE || ___x > Integer/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
        )
        (ß (int) ___x)
    )

    (defn #_"int" RT'intCast-1l [#_"long" ___x]
        (let [#_"int" ___i (ß (int) ___x)]
            (when (ß ___i != ___x)
                (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
            )
            ___i
        )
    )

    (defn #_"int" RT'intCast-1d [#_"double" ___x]
        (when (ß ___x < Integer/MIN_VALUE || ___x > Integer/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for int: " ___x)))
        )
        (ß (int) ___x)
    )

    (defn #_"long" RT'longCast-1o [#_"Object" ___x]
        (cond (ß ___x instanceof Integer || ___x instanceof Long)
            (do
                (ß ((Number) ___x).longValue())
            )
            (ß ___x instanceof BigInt)
            (do
                (let [#_"BigInt" ___bi (ß (BigInt) ___x)]
                    (if (ß (:bipart ___bi) == nil)
                        (do
                            (:lpart ___bi)
                        )
                        (do
                            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
                        )
                    )
                )
            )
            (ß ___x instanceof BigInteger)
            (do
                (let [#_"BigInteger" ___bi (ß (BigInteger) ___x)]
                    (if (ß ___bi.bitLength() < 64)
                        (do
                            (ß ___bi.longValue())
                        )
                        (do
                            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
                        )
                    )
                )
            )
            (ß ___x instanceof Byte || ___x instanceof Short)
            (do
                (ß ((Number) ___x).longValue())
            )
            (ß ___x instanceof Ratio)
            (do
                (ß longCast(((Ratio)___x).bigIntegerValue()))
            )
            (ß ___x instanceof Character)
            (do
                (ß longCast(((Character) ___x).charValue()))
            )
            :else
            (do
                (ß longCast(((Number)___x).doubleValue()))
            )
        )
    )

    (defn #_"long" RT'longCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1f [#_"float" ___x]
        (when (ß ___x < Long/MIN_VALUE || ___x > Long/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
        )
        (ß (long) ___x)
    )

    (defn #_"long" RT'longCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"long" RT'longCast-1d [#_"double" ___x]
        (when (ß ___x < Long/MIN_VALUE || ___x > Long/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for long: " ___x)))
        )
        (ß (long) ___x)
    )

    (defn #_"float" RT'floatCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Float)
            (§ return (ß ((Float) ___x).floatValue()))
        )
        (let [#_"double" ___n (ß ((Number) ___x).doubleValue())]
            (when (ß ___n < -Float/MAX_VALUE || ___n > Float/MAX_VALUE)
                (throw (IllegalArgumentException. (str "Value out of range for float: " ___x)))
            )
            (ß (float) ___n)
        )
    )

    (defn #_"float" RT'floatCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"float" RT'floatCast-1d [#_"double" ___x]
        (when (ß ___x < -Float/MAX_VALUE || ___x > Float/MAX_VALUE)
            (throw (IllegalArgumentException. (str "Value out of range for float: " ___x)))
        )
        (ß (float) ___x)
    )

    (defn #_"double" RT'doubleCast-1o [#_"Object" ___x]
        (ß ((Number) ___x).doubleValue())
    )

    (defn #_"double" RT'doubleCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"double" RT'doubleCast-1d [#_"double" ___x]
        ___x
    )

    (defn #_"byte" RT'uncheckedByteCast-1o [#_"Object" ___x]
        (ß ((Number) ___x).byteValue())
    )

    (defn #_"byte" RT'uncheckedByteCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"byte" RT'uncheckedByteCast-1s [#_"short" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1i [#_"int" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1l [#_"long" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1f [#_"float" ___x]
        (ß (byte) ___x)
    )

    (defn #_"byte" RT'uncheckedByteCast-1d [#_"double" ___x]
        (ß (byte) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1o [#_"Object" ___x]
        (ß ((Number) ___x).shortValue())
    )

    (defn #_"short" RT'uncheckedShortCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"short" RT'uncheckedShortCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"short" RT'uncheckedShortCast-1i [#_"int" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1l [#_"long" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1f [#_"float" ___x]
        (ß (short) ___x)
    )

    (defn #_"short" RT'uncheckedShortCast-1d [#_"double" ___x]
        (ß (short) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Character)
            (§ return (ß ((Character) ___x).charValue()))
        )
        (ß (char) ((Number) ___x).longValue())
    )

    (defn #_"char" RT'uncheckedCharCast-1b [#_"byte" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1s [#_"short" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"char" RT'uncheckedCharCast-1i [#_"int" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1l [#_"long" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1f [#_"float" ___x]
        (ß (char) ___x)
    )

    (defn #_"char" RT'uncheckedCharCast-1d [#_"double" ___x]
        (ß (char) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1o [#_"Object" ___x]
        (when (ß ___x instanceof Number)
            (§ return (ß ((Number)___x).intValue()))
        )
        (ß ((Character) ___x).charValue())
    )

    (defn #_"int" RT'uncheckedIntCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1c [#_"char" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"int" RT'uncheckedIntCast-1l [#_"long" ___x]
        (ß (int) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1f [#_"float" ___x]
        (ß (int) ___x)
    )

    (defn #_"int" RT'uncheckedIntCast-1d [#_"double" ___x]
        (ß (int) ___x)
    )

    (defn #_"long" RT'uncheckedLongCast-1o [#_"Object" ___x]
        (ß ((Number) ___x).longValue())
    )

    (defn #_"long" RT'uncheckedLongCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"long" RT'uncheckedLongCast-1f [#_"float" ___x]
        (ß (long) ___x)
    )

    (defn #_"long" RT'uncheckedLongCast-1d [#_"double" ___x]
        (ß (long) ___x)
    )

    (defn #_"float" RT'uncheckedFloatCast-1o [#_"Object" ___x]
        (ß ((Number) ___x).floatValue())
    )

    (defn #_"float" RT'uncheckedFloatCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"float" RT'uncheckedFloatCast-1d [#_"double" ___x]
        (ß (float) ___x)
    )

    (defn #_"double" RT'uncheckedDoubleCast-1o [#_"Object" ___x]
        (ß ((Number) ___x).doubleValue())
    )

    (defn #_"double" RT'uncheckedDoubleCast-1b [#_"byte" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1s [#_"short" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1i [#_"int" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1l [#_"long" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1f [#_"float" ___x]
        ___x
    )

    (defn #_"double" RT'uncheckedDoubleCast-1d [#_"double" ___x]
        ___x
    )

    (defn #_"IPersistentMap" RT'map [#_"Object..." ___init]
        (cond (nil? ___init)
            (do
                (§ return PersistentArrayMap'EMPTY)
            )
            (ß ___init.length <= PersistentArrayMap'HASHTABLE_THRESHOLD)
            (do
                (§ return (PersistentArrayMap'createWithCheck ___init))
            )
        )
        (PersistentHashMap'createWithCheck-1a ___init)
    )

    (defn #_"IPersistentMap" RT'mapUniqueKeys [#_"Object..." ___init]
        (cond (nil? ___init)
            (do
                (§ return PersistentArrayMap'EMPTY)
            )
            (ß ___init.length <= PersistentArrayMap'HASHTABLE_THRESHOLD)
            (do
                (§ return (PersistentArrayMap'new-1 ___init))
            )
        )
        (PersistentHashMap'create-1a ___init)
    )

    (defn #_"IPersistentSet" RT'set [#_"Object..." ___init]
        (PersistentHashSet'createWithCheck-1a ___init)
    )

    (defn #_"IPersistentVector" RT'vector [#_"Object..." ___init]
        (LazilyPersistentVector'createOwning ___init)
    )

    (defn #_"IPersistentVector" RT'subvec [#_"IPersistentVector" ___v, #_"int" ___start, #_"int" ___end]
        (when (ß ___end < ___start || ___start < 0 || ___end > ___v.count())
            (throw (IndexOutOfBoundsException.))
        )
        (when (ß ___start == ___end)
            (§ return PersistentVector'EMPTY)
        )
        (SubVector'new nil, ___v, ___start, ___end)
    )

    (defn #_"ISeq" RT'list-0 []
        nil
    )

    (defn #_"ISeq" RT'list-1 [#_"Object" ___arg1]
        (PersistentList'new-1 ___arg1)
    )

    (defn #_"ISeq" RT'list-2 [#_"Object" ___arg1, #_"Object" ___arg2]
        (ß listStar(___arg1, ___arg2, nil))
    )

    (defn #_"ISeq" RT'list-3 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß listStar(___arg1, ___arg2, ___arg3, nil))
    )

    (defn #_"ISeq" RT'list-4 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß listStar(___arg1, ___arg2, ___arg3, ___arg4, nil))
    )

    (defn #_"ISeq" RT'list-5 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß listStar(___arg1, ___arg2, ___arg3, ___arg4, ___arg5, nil))
    )

    (defn #_"ISeq" RT'listStar-2 [#_"Object" ___arg1, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, ___rest))
    )

    (defn #_"ISeq" RT'listStar-3 [#_"Object" ___arg1, #_"Object" ___arg2, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, cons(___arg2, ___rest)))
    )

    (defn #_"ISeq" RT'listStar-4 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, cons(___arg2, cons(___arg3, ___rest))))
    )

    (defn #_"ISeq" RT'listStar-5 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, cons(___arg2, cons(___arg3, cons(___arg4, ___rest)))))
    )

    (defn #_"ISeq" RT'listStar-6 [#_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"ISeq" ___rest]
        (ß (ISeq) cons(___arg1, cons(___arg2, cons(___arg3, cons(___arg4, cons(___arg5, ___rest))))))
    )

    (defn #_"ISeq" RT'arrayToList [#_"Object[]" ___a]
        (let [#_"ISeq" ___ret nil]
            (loop-when-recur [#_"int" ___i (ß ___a.length - 1)] (ß ___i >= 0) [(dec ___i)]
                (§ ass ___ret (ß (ISeq) cons(___a[___i], ___ret)))
            )
            ___ret
        )
    )

    (defn #_"Object[]" RT'object_array [#_"Object" ___sizeOrSeq]
        (if (ß ___sizeOrSeq instanceof Number)
            (do
                (make-array Object (ß ((Number) ___sizeOrSeq).intValue()))
            )
            (do
                (let [#_"ISeq" ___s (RT'seq ___sizeOrSeq)]
                    (let [#_"int" ___size (RT'count ___s)]
                        (let [#_"Object[]" ___ret (make-array Object ___size)]
                            (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___size && ___s != nil) [(inc ___i) (ß ___s.next())]
                                (§ ass (ß ___ret[___i]) (ß ___s.first()))
                            )
                            ___ret
                        )
                    )
                )
            )
        )
    )

    (defn #_"Object[]" RT'toArray [#_"Object" ___coll]
        (cond (nil? ___coll)
            (do
                RT'EMPTY_ARRAY
            )
            (ß ___coll instanceof Object[])
            (do
                (ß (Object[]) ___coll)
            )
            (ß ___coll instanceof Collection)
            (do
                (ß ((Collection) ___coll).toArray())
            )
            (ß ___coll instanceof Iterable)
            (do
                (let [#_"ArrayList" ___ret (ArrayList.)]
                    (doseq [#_"Object" ___o (ß (Iterable)___coll)]
                        (ß ___ret.add(___o))
                    )
                    (ß ___ret.toArray())
                )
            )
            (ß ___coll instanceof Map)
            (do
                (ß ((Map) ___coll).entrySet().toArray())
            )
            (ß ___coll instanceof String)
            (do
                (let [#_"char[]" ___chars (ß ((String) ___coll).toCharArray())]
                    (let [#_"Object[]" ___ret (make-array Object (ß ___chars.length))]
                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___chars.length) [(inc ___i)]
                            (§ ass (ß ___ret[___i]) (ß ___chars[___i]))
                        )
                        ___ret
                    )
                )
            )
            (ß ___coll.getClass().isArray())
            (do
                (let [#_"ISeq" ___s (ß (seq(___coll)))]
                    (let [#_"Object[]" ___ret (make-array Object (ß count(___s)))]
                        (loop-when-recur [#_"int" ___i 0 ___s ___s] (ß ___i < ___ret.length) [(inc ___i) (ß ___s.next())]
                            (§ ass (ß ___ret[___i]) (ß ___s.first()))
                        )
                        ___ret
                    )
                )
            )
            :else
            (do
                (throw (Util'runtimeException-1 (str "Unable to convert: " (ß ___coll.getClass()) " to Object[]")))
            )
        )
    )

    (defn #_"Object[]" RT'seqToArray [#_"ISeq" ___seq]
        (let [#_"int" ___len (ß length(___seq))]
            (let [#_"Object[]" ___ret (make-array Object ___len)]
                (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (ß ___seq.next())]
                    (§ ass (ß ___ret[___i]) (ß ___seq.first()))
                )
                ___ret
            )
        )
    )

    ;; supports java Collection.toArray(T[])
    (defn #_"Object[]" RT'seqToPassedArray [#_"ISeq" ___seq, #_"Object[]" ___passed]
        (let [#_"Object[]" ___dest ___passed]
            (let [#_"int" ___len (ß count(___seq))]
                (when (ß ___len > ___dest.length)
                    (§ ass ___dest (ß (Object[]) Array/newInstance(___passed.getClass().getComponentType(), ___len)))
                )
                (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (ß ___seq.next())]
                    (§ ass (ß ___dest[___i]) (ß ___seq.first()))
                )
                (when (ß ___len < ___passed.length)
                    (§ ass (ß ___dest[___len]) nil)
                )
                ___dest
            )
        )
    )

    (defn #_"Object" RT'seqToTypedArray-1 [#_"ISeq" ___seq]
        (let [#_"Class" ___type (ß (___seq != nil && ___seq.first() != nil) ? ___seq.first().getClass() :or (§ class Object))]
            (ß seqToTypedArray(___type, ___seq))
        )
    )

    (defn #_"Object" RT'seqToTypedArray-2 [#_"Class" ___type, #_"ISeq" ___seq]
        (let [#_"Object" ___ret (ß Array/newInstance(___type, length(___seq)))]
            (cond (ß ___type == Integer/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (ß ___seq.next())]
                        (ß Array/set(___ret, ___i, intCast(___seq.first())))
                    )
                )
                (ß ___type == Byte/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (ß ___seq.next())]
                        (ß Array/set(___ret, ___i, byteCast(___seq.first())))
                    )
                )
                (ß ___type == Float/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (ß ___seq.next())]
                        (ß Array/set(___ret, ___i, floatCast(___seq.first())))
                    )
                )
                (ß ___type == Short/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (ß ___seq.next())]
                        (ß Array/set(___ret, ___i, shortCast(___seq.first())))
                    )
                )
                (ß ___type == Character/TYPE)
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (ß ___seq.next())]
                        (ß Array/set(___ret, ___i, charCast(___seq.first())))
                    )
                )
                :else
                (do
                    (loop-when-recur [#_"int" ___i 0 ___seq ___seq] (some? ___seq) [(inc ___i) (ß ___seq.next())]
                        (ß Array/set(___ret, ___i, ___seq.first()))
                    )
                )
            )
            ___ret
        )
    )

    (defn #_"int" RT'length [#_"ISeq" ___list]
        (let [#_"int" ___i 0]
            (loop-when-recur [#_"ISeq" ___c ___list] (some? ___c) [(ß ___c.next())]
                (§ ass ___i (inc ___i))
            )
            ___i
        )
    )

    (defn #_"int" RT'boundedLength [#_"ISeq" ___list, #_"int" ___limit]
        (let [#_"int" ___i 0]
            (loop-when-recur [#_"ISeq" ___c ___list] (ß ___c != nil && ___i <= ___limit) [(ß ___c.next())]
                (§ ass ___i (inc ___i))
            )
            ___i
        )
    )

    (defn #_"Character" RT'readRet [#_"int" ___ret]
        (when (ß ___ret == -1)
            (§ return nil)
        )
        (ß box((char) ___ret))
    )

    (defn #_"Character" RT'readChar [#_"Reader" ___r] #_(§ throws IOException)
        (let [#_"int" ___ret (ß ___r.read())]
            (ß readRet(___ret))
        )
    )

    (defn #_"Character" RT'peekChar [#_"Reader" ___r] #_(§ throws IOException)
        (§ let [#_"int" ___ret]
            (if (ß ___r instanceof PushbackReader)
                (do
                    (§ ass ___ret (ß ___r.read()))
                    (ß ((PushbackReader) ___r).unread(___ret))
                )
                (do
                    (ß ___r.mark(1))
                    (§ ass ___ret (ß ___r.read()))
                    (ß ___r.reset())
                )
            )

            (ß readRet(___ret))
        )
    )

    (defn #_"int" RT'getLineNumber [#_"Reader" ___r]
        (when (ß ___r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) ___r).getLineNumber()))
        )
        0
    )

    (defn #_"int" RT'getColumnNumber [#_"Reader" ___r]
        (when (ß ___r instanceof LineNumberingPushbackReader)
            (§ return (ß ((LineNumberingPushbackReader) ___r).getColumnNumber()))
        )
        0
    )

    (defn #_"LineNumberingPushbackReader" RT'getLineNumberingReader [#_"Reader" ___r]
        (when (ß isLineNumberingReader(___r))
            (§ return (ß (LineNumberingPushbackReader) ___r))
        )
        (LineNumberingPushbackReader'new-1 ___r)
    )

    (defn #_"boolean" RT'isLineNumberingReader [#_"Reader" ___r]
        (ß (___r instanceof LineNumberingPushbackReader))
    )

    (defn #_"boolean" RT'isReduced [#_"Object" ___r]
        (ß (___r instanceof Reduced))
    )

    (defn #_"String" RT'resolveClassNameInContext [#_"String" ___className]
        ;; todo - look up in context var
        ___className
    )

    (defn #_"boolean" RT'suppressRead []
        (ß booleanCast(RT'SUPPRESS_READ.deref()))
    )

    (defn #_"String" RT'printString [#_"Object" ___x]
        (try
            (let [#_"StringWriter" ___sw (StringWriter.)]
                (ß print(___x, ___sw))
                (ß ___sw.toString())
            )
            (catch Exception ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (defn #_"Object" RT'readString-1 [#_"String" ___s]
        (ß readString(___s, nil))
    )

    (defn #_"Object" RT'readString-2 [#_"String" ___s, #_"Object" ___opts]
        (let [#_"PushbackReader" ___r (PushbackReader. (§ pars (StringReader. ___s)))]
            (LispReader'read-2 ___r, ___opts)
        )
    )

    (defn #_"void" RT'print [#_"Object" ___x, #_"Writer" ___w] #_(§ throws IOException)
        ;; call multimethod
        (if (ß RT'PRINT_INITIALIZED.isBound() && RT'booleanCast-1o(RT'PRINT_INITIALIZED.deref()))
            (do
                (ß RT'PR_ON.invoke(___x, ___w))
            )
            (do
                (let [#_"boolean" ___readably (ß booleanCast(RT'PRINT_READABLY.deref()))]
                    (when (ß ___x instanceof Obj)
                        (let [#_"Obj" ___o (ß (Obj) ___x)]
                            (when (ß RT'count(___o.meta()) > 0 && ((___readably && booleanCast(RT'PRINT_META.deref())) || booleanCast(RT'PRINT_DUP.deref())))
                                (let [#_"IPersistentMap" ___meta (ß ___o.meta())]
                                    (ß ___w.write("#^"))
                                    (if (ß ___meta.count() == 1 && ___meta.containsKey(RT'TAG_KEY))
                                        (do
                                            (ß print(___meta.valAt(RT'TAG_KEY), ___w))
                                        )
                                        (do
                                            (ß print(___meta, ___w))
                                        )
                                    )
                                    (ß ___w.write(\space))
                                )
                            )
                        )
                    )
                    (cond (nil? ___x)
                        (do
                            (ß ___w.write("nil"))
                        )
                        (ß ___x instanceof ISeq || ___x instanceof IPersistentList)
                        (do
                            (ß ___w.write(\())
                            (ß printInnerSeq(seq(___x), ___w))
                            (ß ___w.write(\)))
                        )
                        (ß ___x instanceof String)
                        (do
                            (let [#_"String" ___s (ß (String) ___x)]
                                (if (ß !___readably)
                                    (do
                                        (ß ___w.write(___s))
                                    )
                                    (do
                                        (ß ___w.write(\")) ;; oops! "
                                        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___s.length()) [(inc ___i)]
                                            (let [#_"char" ___c (ß ___s.charAt(___i))]
                                                (§ switch ___c
                                                    (§ case \newline)
                                                    (do
                                                        (ß ___w.write("\\n"))
                                                        (§ break )
                                                    )
                                                    (§ case \tab)
                                                    (do
                                                        (ß ___w.write("\\t"))
                                                        (§ break )
                                                    )
                                                    (§ case \return)
                                                    (do
                                                        (ß ___w.write("\\r"))
                                                        (§ break )
                                                    )
                                                    (§ case \")
                                                    (do
                                                        (ß ___w.write("\\\""))
                                                        (§ break )
                                                    )
                                                    (§ case \\)
                                                    (do
                                                        (ß ___w.write("\\\\"))
                                                        (§ break )
                                                    )
                                                    (§ case \formfeed)
                                                    (do
                                                        (ß ___w.write("\\f"))
                                                        (§ break )
                                                    )
                                                    (§ case \backspace)
                                                    (do
                                                        (ß ___w.write("\\b"))
                                                        (§ break )
                                                    )
                                                    (§ default )
                                                    (do
                                                        (ß ___w.write(___c))
                                                        (§ break )
                                                    )
                                                )
                                            )
                                        )
                                        (ß ___w.write(\")) ;; oops! "
                                    )
                                )
                            )
                        )
                        (ß ___x instanceof IPersistentMap)
                        (do
                            (ß ___w.write(\{))
                            (loop-when-recur [#_"ISeq" ___s (ß seq(___x))] (some? ___s) [(ß ___s.next())]
                                (let [#_"IMapEntry" ___e (ß (IMapEntry) ___s.first())]
                                    (ß print(___e.key(), ___w))
                                    (ß ___w.write(\space))
                                    (ß print(___e.val(), ___w))
                                    (when (ß ___s.next() != nil)
                                        (ß ___w.write(", "))
                                    )
                                )
                            )
                            (ß ___w.write(\}))
                        )
                        (ß ___x instanceof IPersistentVector)
                        (do
                            (let [#_"IPersistentVector" ___a (ß (IPersistentVector) ___x)]
                                (ß ___w.write(\[))
                                (loop-when-recur [#_"int" ___i 0] (ß ___i < ___a.count()) [(inc ___i)]
                                    (ß print(___a.nth(___i), ___w))
                                    (when (ß ___i < ___a.count() - 1)
                                        (ß ___w.write(\space))
                                    )
                                )
                                (ß ___w.write(\]))
                            )
                        )
                        (ß ___x instanceof IPersistentSet)
                        (do
                            (ß ___w.write("#{"))
                            (loop-when-recur [#_"ISeq" ___s (ß seq(___x))] (some? ___s) [(ß ___s.next())]
                                (ß print(___s.first(), ___w))
                                (when (ß ___s.next() != nil)
                                    (ß ___w.write(" "))
                                )
                            )
                            (ß ___w.write(\}))
                        )
                        (ß ___x instanceof Character)
                        (do
                            (let [#_"char" ___c (ß ((Character) ___x).charValue())]
                                (if (ß !___readably)
                                    (do
                                        (ß ___w.write(___c))
                                    )
                                    (do
                                        (ß ___w.write(\\))
                                        (§ switch ___c
                                            (§ case \newline)
                                            (do
                                                (ß ___w.write("newline"))
                                                (§ break )
                                            )
                                            (§ case \tab)
                                            (do
                                                (ß ___w.write("tab"))
                                                (§ break )
                                            )
                                            (§ case \space)
                                            (do
                                                (ß ___w.write("space"))
                                                (§ break )
                                            )
                                            (§ case \backspace)
                                            (do
                                                (ß ___w.write("backspace"))
                                                (§ break )
                                            )
                                            (§ case \formfeed)
                                            (do
                                                (ß ___w.write("formfeed"))
                                                (§ break )
                                            )
                                            (§ case \return)
                                            (do
                                                (ß ___w.write("return"))
                                                (§ break )
                                            )
                                            (§ default )
                                            (do
                                                (ß ___w.write(___c))
                                                (§ break )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        (ß ___x instanceof Class)
                        (do
                            (ß ___w.write("#="))
                            (ß ___w.write(((Class) ___x).getName()))
                        )
                        (ß ___x instanceof BigDecimal && ___readably)
                        (do
                            (ß ___w.write(___x.toString()))
                            (ß ___w.write(\M))
                        )
                        (ß ___x instanceof BigInt && ___readably)
                        (do
                            (ß ___w.write(___x.toString()))
                            (ß ___w.write(\N))
                        )
                        (ß ___x instanceof BigInteger && ___readably)
                        (do
                            (ß ___w.write(___x.toString()))
                            (ß ___w.write("BIGINT"))
                        )
                        (ß ___x instanceof Var)
                        (do
                            (let [#_"Var" ___v (ß (Var) ___x)]
                                (ß ___w.write("#=(var " + (:ns ___v).name + "/" + (:sym ___v) + ")"))
                            )
                        )
                        (ß ___x instanceof Pattern)
                        (do
                            (let [#_"Pattern" ___p (ß (Pattern) ___x)]
                                (ß ___w.write("#\"" + ___p.pattern() + "\""))
                            )
                        )
                        :else
                        (do
                            (ß ___w.write(___x.toString()))
                        )
                    )
                )
            )
        )
        nil
    )

    (defn- #_"void" RT'printInnerSeq [#_"ISeq" ___x, #_"Writer" ___w] #_(§ throws IOException)
        (loop-when-recur [#_"ISeq" ___s ___x] (some? ___s) [(ß ___s.next())]
            (ß print(___s.first(), ___w))
            (when (ß ___s.next() != nil)
                (ß ___w.write(\space))
            )
        )
        nil
    )

    (defn #_"void" RT'formatAesthetic [#_"Writer" ___w, #_"Object" ___obj] #_(§ throws IOException)
        (if (nil? ___obj)
            (do
                (ß ___w.write("nil"))
            )
            (do
                (ß ___w.write(___obj.toString()))
            )
        )
        nil
    )

    (defn #_"void" RT'formatStandard [#_"Writer" ___w, #_"Object" ___obj] #_(§ throws IOException)
        (cond (nil? ___obj)
            (do
                (ß ___w.write("nil"))
            )
            (ß ___obj instanceof String)
            (do
                (ß ___w.write(\")) ;; oops! "
                (ß ___w.write((String) ___obj))
                (ß ___w.write(\")) ;; oops! "
            )
            (ß ___obj instanceof Character)
            (do
                (ß ___w.write(\\))
                (let [#_"char" ___c (ß ((Character) ___obj).charValue())]
                    (§ switch ___c
                        (§ case \newline)
                        (do
                            (ß ___w.write("newline"))
                            (§ break )
                        )
                        (§ case \tab)
                        (do
                            (ß ___w.write("tab"))
                            (§ break )
                        )
                        (§ case \space)
                        (do
                            (ß ___w.write("space"))
                            (§ break )
                        )
                        (§ case \backspace)
                        (do
                            (ß ___w.write("backspace"))
                            (§ break )
                        )
                        (§ case \formfeed)
                        (do
                            (ß ___w.write("formfeed"))
                            (§ break )
                        )
                        (§ default )
                        (do
                            (ß ___w.write(___c))
                            (§ break )
                        )
                    )
                )
            )
            :else
            (do
                (ß ___w.write(___obj.toString()))
            )
        )
        nil
    )

    (defn #_"Object" RT'format [#_"Object" ___o, #_"String" ___s, #_"Object..." ___args] #_(§ throws IOException)
        (§ let [#_"Writer" ___w]
            (cond (nil? ___o)
                (do
                    (§ ass ___w (StringWriter.))
                )
                (Util'equals ___o, RT'T)
                (do
                    (§ ass ___w (ß (Writer) RT'OUT.deref()))
                )
                :else
                (do
                    (§ ass ___w (ß (Writer) ___o))
                )
            )
            (ß doFormat(___w, ___s, ArraySeq'create-1(___args)))
            (when (nil? ___o)
                (§ return (ß ___w.toString()))
            )
            nil
        )
    )

    (defn #_"ISeq" RT'doFormat [#_"Writer" ___w, #_"String" ___s, #_"ISeq" ___args] #_(§ throws IOException)
        (loop-when-recur [#_"int" ___i 0] (ß ___i < ___s.length()) [___i]
            (let [#_"char" ___c (ß ___s.charAt(___i))]
                (§ ass ___i (inc ___i))
                (§ switch (Character/toLowerCase ___c)
                    (§ case \~)
                    (do
                        (let [#_"char" ___d (ß ___s.charAt(___i))]
                            (§ ass ___i (inc ___i))
                            (§ switch (Character/toLowerCase ___d)
                                (§ case \%)
                                (do
                                    (ß ___w.write(\newline))
                                    (§ break )
                                )
                                (§ case \t)
                                (do
                                    (ß ___w.write(\tab))
                                    (§ break )
                                )
                                (§ case \a)
                                (do
                                    (when (nil? ___args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT'formatAesthetic(___w, RT'first(___args)))
                                    (§ ass ___args (RT'next ___args))
                                    (§ break )
                                )
                                (§ case \s)
                                (do
                                    (when (nil? ___args)
                                        (throw (IllegalArgumentException. "Missing argument"))
                                    )
                                    (ß RT'formatStandard(___w, RT'first(___args)))
                                    (§ ass ___args (RT'next ___args))
                                    (§ break )
                                )
                                (§ case \{)
                                (do
                                    (let [#_"int" ___j (ß ___s.indexOf("~}", ___i))] ;; note - does not nest
                                        (when (ß ___j == -1)
                                            (throw (IllegalArgumentException. "Missing ~}"))
                                        )
                                        (let [#_"String" ___subs (ß ___s.substring(___i, ___j))]
                                            (loop-when-recur [#_"ISeq" ___sargs (ß RT'seq(RT'first(___args)))] (some? ___sargs) [___sargs]
                                                (§ ass ___sargs (ß doFormat(___w, ___subs, ___sargs)))
                                            )
                                            (§ ass ___args (RT'next ___args))
                                            (§ ass ___i (+ ___j 2)) ;; skip "~}"
                                            (§ break )
                                        )
                                    )
                                )
                                (§ case \^)
                                (do
                                    (when (nil? ___args)
                                        (§ return nil)
                                    )
                                    (§ break )
                                )
                                (§ case \~)
                                (do
                                    (ß ___w.write(\~))
                                    (§ break )
                                )
                                (§ default )
                                (do
                                    (throw (IllegalArgumentException. (str "Unsupported ~ directive: " ___d)))
                                )
                            )
                            (§ break )
                        )
                    )
                    (§ default )
                    (do
                        (ß ___w.write(___c))
                        (§ break )
                    )
                )
            )
        )
        ___args
    )

    (defn #_"Object[]" RT'setValues [#_"Object..." ___vals]
        (when (ß ___vals.length > 0)
            (§ return ___vals)
        )
        nil
    )

    (defn #_"ClassLoader" RT'makeClassLoader []
        (ß (ClassLoader) AccessController/doPrivileged(
                (§ reify PrivilegedAction()
                    #_method
                    (§ defn #_"Object" run [#_"PrivilegedAction" this]
                        (try
                            (ß Var'pushThreadBindings(RT'map(RT'USE_CONTEXT_CLASSLOADER, RT'T)))
                            (ß DynamicClassLoader'new-1(baseLoader()))
                            (finally
                                (ß Var'popThreadBindings())
                            )
                        )
                    )
                )
            )
        )
    )

    (defn #_"ClassLoader" RT'baseLoader []
        (cond (ß Compiler'LOADER.isBound())
            (do
                (§ return (ß (ClassLoader) Compiler'LOADER.deref()))
            )
            (ß booleanCast(RT'USE_CONTEXT_CLASSLOADER.deref()))
            (do
                (§ return (ß Thread/currentThread().getContextClassLoader()))
            )
        )
        (ß (§ class Compiler).getClassLoader())
    )

    (defn #_"InputStream" RT'resourceAsStream [#_"ClassLoader" ___loader, #_"String" ___name]
        (if (nil? ___loader)
            (do
                (ClassLoader/getSystemResourceAsStream ___name)
            )
            (do
                (ß ___loader.getResourceAsStream(___name))
            )
        )
    )

    (defn #_"URL" RT'getResource [#_"ClassLoader" ___loader, #_"String" ___name]
        (if (nil? ___loader)
            (do
                (ClassLoader/getSystemResource ___name)
            )
            (do
                (ß ___loader.getResource(___name))
            )
        )
    )

    (defn #_"Class" RT'classForName-3 [#_"String" ___name, #_"boolean" ___load, #_"ClassLoader" ___loader]
        (try
            (let [#_"Class" ___c nil]
                (when (ß !(___loader instanceof DynamicClassLoader))
                    (§ ass ___c (DynamicClassLoader'findInMemoryClass ___name))
                )
                (when (some? ___c)
                    (§ return ___c)
                )
                (Class/forName ___name, ___load, ___loader)
            )
            (catch ClassNotFoundException ___e
                (throw (Util'sneakyThrow ___e))
            )
        )
    )

    (defn #_"Class" RT'classForName-1 [#_"String" ___name]
        (ß classForName(___name, true, baseLoader()))
    )

    (defn #_"Class" RT'classForNameNonLoading [#_"String" ___name]
        (ß classForName(___name, false, baseLoader()))
    )

    (defn #_"Class" RT'loadClassForName [#_"String" ___name]
        (try
            (ß classForNameNonLoading(___name))
            (catch Exception ___e
                (if (ß ___e instanceof ClassNotFoundException)
                    (do
                        (§ return nil)
                    )
                    (do
                        (throw (Util'sneakyThrow ___e))
                    )
                )
            )
        )
        (ß classForName(___name))
    )

    (defn #_"float" RT'aget-2f [#_"float[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"float" RT'aset-3f [#_"float[]" ___xs, #_"int" ___i, #_"float" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1f [#_"float[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"float[]" RT'aclone-1f [#_"float[]" ___xs]
        (ß ___xs.clone())
    )

    (defn #_"double" RT'aget-2d [#_"double[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"double" RT'aset-3d [#_"double[]" ___xs, #_"int" ___i, #_"double" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1d [#_"double[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"double[]" RT'aclone-1d [#_"double[]" ___xs]
        (ß ___xs.clone())
    )

    (defn #_"int" RT'aget-2i [#_"int[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"int" RT'aset-3i [#_"int[]" ___xs, #_"int" ___i, #_"int" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1i [#_"int[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"int[]" RT'aclone-1i [#_"int[]" ___xs]
        (ß ___xs.clone())
    )

    (defn #_"long" RT'aget-2l [#_"long[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"long" RT'aset-3l [#_"long[]" ___xs, #_"int" ___i, #_"long" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1l [#_"long[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"long[]" RT'aclone-1l [#_"long[]" ___xs]
        (ß ___xs.clone())
    )

    (defn #_"char" RT'aget-2c [#_"char[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"char" RT'aset-3c [#_"char[]" ___xs, #_"int" ___i, #_"char" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1c [#_"char[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"char[]" RT'aclone-1c [#_"char[]" ___xs]
        (ß ___xs.clone())
    )

    (defn #_"byte" RT'aget-2b [#_"byte[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"byte" RT'aset-3b [#_"byte[]" ___xs, #_"int" ___i, #_"byte" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1b [#_"byte[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"byte[]" RT'aclone-1b [#_"byte[]" ___xs]
        (ß ___xs.clone())
    )

    (defn #_"short" RT'aget-2s [#_"short[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"short" RT'aset-3s [#_"short[]" ___xs, #_"int" ___i, #_"short" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1s [#_"short[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"short[]" RT'aclone-1s [#_"short[]" ___xs]
        (ß ___xs.clone())
    )

    (defn #_"boolean" RT'aget-2z [#_"boolean[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"boolean" RT'aset-3z [#_"boolean[]" ___xs, #_"int" ___i, #_"boolean" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1z [#_"boolean[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"boolean[]" RT'aclone-1z [#_"boolean[]" ___xs]
        (ß ___xs.clone())
    )

    (defn #_"Object" RT'aget-2o [#_"Object[]" ___xs, #_"int" ___i]
        (ß ___xs[___i])
    )

    (defn #_"Object" RT'aset-3o [#_"Object[]" ___xs, #_"int" ___i, #_"Object" ___v]
        (§ ass (ß ___xs[___i]) ___v)
        ___v
    )

    (defn #_"int" RT'alength-1o [#_"Object[]" ___xs]
        (ß ___xs.length)
    )

    (defn #_"Object[]" RT'aclone-1o [#_"Object[]" ___xs]
        (ß ___xs.clone())
    )
)
)

(java-ns cloiure.lang.Seqable

(defprotocol Seqable
    #_abstract
    (#_"ISeq" Seqable'''seq [#_"Seqable" this])
)
)

(java-ns cloiure.lang.SeqEnumeration

(§ import java.util.Enumeration)

(class-ns SeqEnumeration (§ implements Enumeration)
    (defn- #_"SeqEnumeration" SeqEnumeration'init []
        (hash-map
            #_"ISeq" :seq nil
        )
    )

    (defn #_"SeqEnumeration" SeqEnumeration'new [#_"ISeq" ___seq]
        (let [this (SeqEnumeration'init)]
            (§ ass (:seq this) ___seq)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasMoreElements [#_"SeqEnumeration" this]
        (ß ((:seq this) != nil))
    )

    #_method
    (§ defn #_"Object" nextElement [#_"SeqEnumeration" this]
        (let [#_"Object" ___ret (RT'first (:seq this))]
            (§ ass (:seq this) (RT'next (:seq this)))
            ___ret
        )
    )
)
)

(java-ns cloiure.lang.SeqIterator

(§ import java.util.Iterator)
(§ import java.util.NoSuchElementException)

(class-ns SeqIterator (§ implements Iterator)
    (def #_"Object" SeqIterator'START (Object.))

    (defn- #_"SeqIterator" SeqIterator'init []
        (hash-map
            #_"Object" :seq nil
            #_"Object" :next nil
        )
    )

    (defn #_"SeqIterator" SeqIterator'new [#_"Object" ___o]
        (let [this (SeqIterator'init)]
            (§ ass (:seq this) SeqIterator'START)
            (§ ass (:next this) ___o)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"SeqIterator" this]
        (cond (ß (:seq this) == SeqIterator'START)
            (do
                (§ ass (:seq this) nil)
                (§ ass (:next this) (RT'seq (:next this)))
            )
            (ß (:seq this) == (:next this))
            (do
                (§ ass (:next this) (RT'next (:seq this)))
            )
        )
        (ß ((:next this) != nil))
    )

    #_method
    (§ defn #_"Object" next [#_"SeqIterator" this] #_(§ throws NoSuchElementException)
        (when (ß !hasNext())
            (throw (NoSuchElementException.))
        )
        (§ ass (:seq this) (:next this))
        (RT'first (:next this))
    )

    #_method
    (§ defn #_"void" remove [#_"SeqIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Sequential

(defprotocol Sequential
)
)

(java-ns cloiure.lang.Settable

(defprotocol Settable
    #_abstract
    (#_"Object" Settable'''doSet [#_"Settable" this, #_"Object" ___val])
    #_abstract
    (#_"Object" Settable'''doReset [#_"Settable" this, #_"Object" ___val])
)
)

(java-ns cloiure.lang.Sorted

(§ import java.util.Comparator)

(defprotocol Sorted
    #_abstract
    (#_"Comparator" Sorted'''comparator [#_"Sorted" this])
    #_abstract
    (#_"Object" Sorted'''entryKey [#_"Sorted" this, #_"Object" ___entry])
    #_abstract
    (#_"ISeq" Sorted'''seq [#_"Sorted" this, #_"boolean" ___ascending])
    #_abstract
    (#_"ISeq" Sorted'''seqFrom [#_"Sorted" this, #_"Object" ___key, #_"boolean" ___ascending])
)
)

(java-ns cloiure.lang.StringSeq

(class-ns StringSeq (§ extends ASeq) (§ implements IndexedSeq)
    (defn #_"StringSeq" StringSeq'create [#_"CharSequence" ___s]
        (when (ß ___s.length() == 0)
            (§ return nil)
        )
        (StringSeq'new nil, ___s, 0)
    )

    (defn- #_"StringSeq" StringSeq'init []
        (hash-map
            #_"CharSequence" :s nil
            #_"int" :i 0
        )
    )

    (defn #_"StringSeq" StringSeq'new [#_"IPersistentMap" ___meta, #_"CharSequence" ___s, #_"int" ___i]
        (let [this (merge (ASeq'new ___meta) (StringSeq'init))]
            (§ ass (:s this) ___s)
            (§ ass (:i this) ___i)
            this
        )
    )

    #_method
    (§ defn #_"Obj" withMeta [#_"StringSeq" this, #_"IPersistentMap" ___meta]
        (when (ß ___meta == meta())
            (§ return this)
        )
        (StringSeq'new ___meta, (:s this), (:i this))
    )

    #_method
    (§ defn #_"Object" first [#_"StringSeq" this]
        (ß Character/valueOf((:s this).charAt((:i this))))
    )

    #_method
    (§ defn #_"ISeq" next [#_"StringSeq" this]
        (when (ß (:i this) + 1 < (:s this).length())
            (§ return (ß StringSeq'new((:_meta this), (:s this), (:i this) + 1)))
        )
        nil
    )

    #_method
    (§ defn #_"int" index [#_"StringSeq" this]
        (:i this)
    )

    #_method
    (§ defn #_"int" count [#_"StringSeq" this]
        (ß (:s this).length() - (:i this))
    )
)
)

(java-ns cloiure.lang.Symbol

(class-ns Symbol (§ extends AFn) (§ implements IObj, Comparable, Named, IHashEq)
    ;; the create thunks preserve binary compatibility with code compiled
    ;; against earlier version of Cloiure and can be removed (at some point).
    (defn #_"Symbol" Symbol'create-2 [#_"String" ___ns, #_"String" ___name]
        (Symbol'intern-2 ___ns, ___name)
    )

    (defn #_"Symbol" Symbol'create-1 [#_"String" ___nsname]
        (Symbol'intern-1 ___nsname)
    )

    (defn #_"Symbol" Symbol'intern-2 [#_"String" ___ns, #_"String" ___name]
        (Symbol'new-2 ___ns, ___name)
    )

    (defn #_"Symbol" Symbol'intern-1 [#_"String" ___nsname]
        (let [#_"int" ___i (ß ___nsname.indexOf(\/))]
            (if (ß ___i == -1 || ___nsname.equals("/"))
                (do
                    (Symbol'new-2 nil, ___nsname)
                )
                (do
                    (ß Symbol'new-2(___nsname.substring(0, ___i), ___nsname.substring(___i + 1)))
                )
            )
        )
    )

    (defn- #_"Symbol" Symbol'init []
        (hash-map
            #_"String" :ns nil
            #_"String" :name nil
            #_"int" :_hasheq 0
            #_"IPersistentMap" :_meta nil
            #_transient
            #_"String" :_str nil
        )
    )

    (defn- #_"Symbol" Symbol'new-2 [#_"String" ___ns_interned, #_"String" ___name_interned]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass (:name this) ___name_interned)
            (§ ass (:ns this) ___ns_interned)
            (§ ass (:_meta this) nil)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"Symbol" this]
        (when (nil? (:_str this))
            (if (some? (:ns this))
                (do
                    (§ ass (:_str this) (ß ((:ns this) + "/" + (:name this))))
                )
                (do
                    (§ ass (:_str this) (:name this))
                )
            )
        )
        (:_str this)
    )

    #_method
    (§ defn #_"String" getNamespace [#_"Symbol" this]
        (:ns this)
    )

    #_method
    (§ defn #_"String" getName [#_"Symbol" this]
        (:name this)
    )

    #_method
    (§ defn #_"boolean" equals [#_"Symbol" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (ß !(___o instanceof Symbol))
            (§ return false)
        )

        (let [#_"Symbol" ___symbol (ß (Symbol) ___o)]
            (ß Util'equals((:ns this), (:ns ___symbol)) && (:name this).equals((:name ___symbol)))
        )
    )

    #_method
    (§ defn #_"int" hashCode [#_"Symbol" this]
        (ß Util'hashCombine((:name this).hashCode(), Util'hash((:ns this))))
    )

    #_method
    (§ defn #_"int" hasheq [#_"Symbol" this]
        (when (ß (:_hasheq this) == 0)
            (§ ass (:_hasheq this) (ß Util'hashCombine(Murmur3'hashUnencodedChars((:name this)), Util'hash((:ns this)))))
        )
        (:_hasheq this)
    )

    #_method
    (§ defn #_"IObj" withMeta [#_"Symbol" this, #_"IPersistentMap" ___meta]
        (Symbol'new-3 ___meta, (:ns this), (:name this))
    )

    (defn- #_"Symbol" Symbol'new-3 [#_"IPersistentMap" ___meta, #_"String" ___ns, #_"String" ___name]
        (let [this (merge (AFn'new) (Symbol'init))]
            (§ ass (:name this) ___name)
            (§ ass (:ns this) ___ns)
            (§ ass (:_meta this) ___meta)
            this
        )
    )

    #_method
    (§ defn #_"int" compareTo [#_"Symbol" this, #_"Object" ___o]
        (let [#_"Symbol" ___s (ß (Symbol) ___o)]
            (when (ß this.equals(___o))
                (§ return 0)
            )
            (when (ß (:ns this) == nil && (:ns ___s) != nil)
                (§ return -1)
            )
            (when (ß (:ns this) != nil)
                (when (ß (:ns ___s) == nil)
                    (§ return 1)
                )
                (let [#_"int" ___nsc (ß (:ns this).compareTo((:ns ___s)))]
                    (when (ß ___nsc != 0)
                        (§ return ___nsc)
                    )
                )
            )
            (ß (:name this).compareTo((:name ___s)))
        )
    )

    #_method
    (§ defn #_"Object" invoke [#_"Symbol" this, #_"Object" ___obj]
        (RT'get-2 ___obj, this)
    )

    #_method
    (§ defn #_"Object" invoke [#_"Symbol" this, #_"Object" ___obj, #_"Object" ___notFound]
        (RT'get-3 ___obj, this, ___notFound)
    )

    #_method
    (§ defn #_"IPersistentMap" meta [#_"Symbol" this]
        (:_meta this)
    )
)
)

(java-ns cloiure.lang.TaggedLiteral

(class-ns TaggedLiteral (§ implements ILookup)
    (§ def #_"Keyword" TaggedLiteral'TAG_KW (Keyword'intern-1 "tag"))
    (§ def #_"Keyword" TaggedLiteral'FORM_KW (Keyword'intern-1 "form"))

    (defn #_"TaggedLiteral" TaggedLiteral'create [#_"Symbol" ___tag, #_"Object" ___form]
        (TaggedLiteral'new ___tag, ___form)
    )

    (defn- #_"TaggedLiteral" TaggedLiteral'init []
        (hash-map
            #_"Symbol" :tag nil
            #_"Object" :form nil
        )
    )

    (defn- #_"TaggedLiteral" TaggedLiteral'new [#_"Symbol" ___tag, #_"Object" ___form]
        (let [this (TaggedLiteral'init)]
            (§ ass (:tag this) ___tag)
            (§ ass (:form this) ___form)
            this
        )
    )

    #_method
    (§ defn #_"Object" valAt [#_"TaggedLiteral" this, #_"Object" ___key]
        (ß valAt(___key, nil))
    )

    #_method
    (§ defn #_"Object" valAt [#_"TaggedLiteral" this, #_"Object" ___key, #_"Object" ___notFound]
        (cond (ß TaggedLiteral'FORM_KW.equals(___key))
            (do
                (:form this)
            )
            (ß TaggedLiteral'TAG_KW.equals(___key))
            (do
                (:tag this)
            )
            :else
            (do
                ___notFound
            )
        )
    )

    #_override
    #_method
    (§ defn #_"boolean" equals [#_"TaggedLiteral" this, #_"Object" ___o]
        (when (ß this == ___o)
            (§ return true)
        )
        (when (ß ___o == nil || getClass() != ___o.getClass())
            (§ return false)
        )

        (let [#_"TaggedLiteral" ___that (ß (TaggedLiteral) ___o)]
            (when (ß ((:form this) != nil) ? !this.form.equals((:form ___that)) :or (:form ___that) != nil)
                (§ return false)
            )
            (when (ß ((:tag this) != nil) ? !this.tag.equals((:tag ___that)) :or (:tag ___that) != nil)
                (§ return false)
            )

            true
        )
    )

    #_override
    #_method
    (§ defn #_"int" hashCode [#_"TaggedLiteral" this]
        (let [#_"int" ___result (Util'hash (:tag this))]
            (§ ass ___result (ß 31 * ___result + Util'hash((:form this))))
            ___result
        )
    )
)
)

(java-ns cloiure.lang.TransactionalHashMap

(§ import java.util.concurrent.ConcurrentMap)
(§ import java.util.*)

(class-ns TransactionalHashMap #_"<K, V>" (§ extends AbstractMap #_"<K, V>") (§ implements ConcurrentMap #_"<K, V>")
    (defn- #_"TransactionalHashMap" TransactionalHashMap'init []
        (hash-map
            #_"Ref[]" :bins nil
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-0 []
        (TransactionalHashMap'new-1i 421)
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1i [#_"int" ___nBins]
        (let [this (merge (AbstractMap'new) (TransactionalHashMap'init))]
            (§ ass (:bins this) (§ typeless make-array Ref ___nBins))
            (loop-when-recur [#_"int" ___i 0] (< ___i ___nBins) [(inc ___i)]
                (§ ass (ß (:bins this)[___i]) (Ref'new-1 PersistentHashMap'EMPTY))
            )
            this
        )
    )

    (defn #_"TransactionalHashMap" TransactionalHashMap'new-1m [#_"Map<? extends K, ? extends V>" ___m]
        (let [this (TransactionalHashMap'new-1i (ß ___m.size()))]
            (ß putAll(___m))
            this
        )
    )

    #_method
    (§ defn #_"IPersistentMap" mapAt [#_"TransactionalHashMap" this, #_"int" ___bin]
        (ß (IPersistentMap) (:bins this)[___bin].deref())
    )

    #_method
    (§ defn #_"int" binFor [#_"TransactionalHashMap" this, #_"Object" ___k]
        ;; spread hashes, a la Cliff Click
        (let [#_"int" ___h (ß ___k.hashCode())]
            (§ ass ___h (ß ___h :xor ((___h >>> 20) :xor (___h >>> 12))))
            (§ ass ___h (ß ___h :xor ((___h >>> 7) :xor (___h >>> 4))))
            (ß ___h % (:bins this).length)
        )
    )

    #_method
    (§ defn #_"Entry" entryAt [#_"TransactionalHashMap" this, #_"Object" ___k]
        (ß mapAt(binFor(___k)).entryAt(___k))
    )

    #_method
    (§ defn #_"int" size [#_"TransactionalHashMap" this]
        (let [#_"int" ___n 0]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bins this).length) [(inc ___i)]
                (§ ass ___n (ß ___n + mapAt(___i).count()))
            )
            ___n
        )
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"TransactionalHashMap" this]
        (ß (size() == 0))
    )

    #_method
    (§ defn #_"boolean" containsKey [#_"TransactionalHashMap" this, #_"Object" ___k]
        (ß (entryAt(___k) != nil))
    )

    #_method
    (§ defn #_"V" get [#_"TransactionalHashMap" this, #_"Object" ___k]
        (let [#_"Entry" ___e (ß entryAt(___k))]
            (when (some? ___e)
                (§ return (ß (V) ___e.getValue()))
            )
            nil
        )
    )

    #_method
    (§ defn #_"V" put [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß (:bins this)[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Object" ___ret (ß ___map.valAt(___k))]
                    (ß ___r.set(___map.assoc(___k, ___v)))
                    (ß (V) ___ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"V" remove [#_"TransactionalHashMap" this, #_"Object" ___k]
        (let [#_"Ref" ___r (ß (:bins this)[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Object" ___ret (ß ___map.valAt(___k))]
                    (ß ___r.set(___map.without(___k)))
                    (ß (V) ___ret)
                )
            )
        )
    )

    #_method
    (§ defn #_"void" putAll [#_"TransactionalHashMap" this, #_"Map<? extends K, ? extends V>" ___map]
        (loop-when-recur [#_"Iterator" ___i (ß ___map.entrySet().iterator())] (ß ___i.hasNext()) [___i]
            (let [#_"Entry<K, V>" ___e (ß (Entry) ___i.next())]
                (ß put(___e.getKey(), ___e.getValue()))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" clear [#_"TransactionalHashMap" this]
        (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bins this).length) [(inc ___i)]
            (let [#_"Ref" ___r (ß (:bins this)[___i])]
                (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                    (when (ß ___map.count() > 0)
                        (ß ___r.set(PersistentHashMap'EMPTY))
                    )
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Set<Entry<K, V>>" entrySet [#_"TransactionalHashMap" this]
        (let [#_"ArrayList<Map$Entry<K, V>>" ___entries (ArrayList. (ß (:bins this).length))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:bins this).length) [(inc ___i)]
                (let [#_"IPersistentMap" ___map (ß mapAt(___i))]
                    (when (ß ___map.count() > 0)
                        (ß ___entries.addAll((Collection) RT'seq(___map)))
                    )
                )
            )
            (§ reify AbstractSet<Entry<K, V>>()
                #_method
                (§ defn #_"Iterator" iterator [#_"AbstractSet<Entry<K, V>>" this]
                    (ß Collections/unmodifiableList(___entries).iterator())
                )

                #_method
                (§ defn #_"int" size [#_"AbstractSet<Entry<K, V>>" this]
                    (ß ___entries.size())
                )
            )
        )
    )

    #_method
    (§ defn #_"V" putIfAbsent [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß (:bins this)[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Entry" ___e (ß ___map.entryAt(___k))]
                    (if (nil? ___e)
                        (do
                            (ß ___r.set(___map.assoc(___k, ___v)))
                            nil
                        )
                        (do
                            (ß (V) ___e.getValue())
                        )
                    )
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" remove [#_"TransactionalHashMap" this, #_"Object" ___k, #_"Object" ___v]
        (let [#_"Ref" ___r (ß (:bins this)[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Entry" ___e (ß ___map.entryAt(___k))]
                    (when (ß ___e != nil && ___e.getValue().equals(___v))
                        (ß ___r.set(___map.without(___k)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"boolean" replace [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___oldv, #_"V" ___newv]
        (let [#_"Ref" ___r (ß (:bins this)[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Entry" ___e (ß ___map.entryAt(___k))]
                    (when (ß ___e != nil && ___e.getValue().equals(___oldv))
                        (ß ___r.set(___map.assoc(___k, ___newv)))
                        (§ return true)
                    )
                    false
                )
            )
        )
    )

    #_method
    (§ defn #_"V" replace [#_"TransactionalHashMap" this, #_"K" ___k, #_"V" ___v]
        (let [#_"Ref" ___r (ß (:bins this)[binFor(___k)])]
            (let [#_"IPersistentMap" ___map (ß (IPersistentMap) ___r.deref())]
                (let [#_"Entry" ___e (ß ___map.entryAt(___k))]
                    (when (some? ___e)
                        (ß ___r.set(___map.assoc(___k, ___v)))
                        (§ return (ß (V) ___e.getValue()))
                    )
                    nil
                )
            )
        )
    )
)
)

(java-ns cloiure.lang.TransformerIterator

(§ import java.util.Iterator)
(§ import java.util.List)
(§ import java.util.NoSuchElementException)
(§ import java.util.Queue)
(§ import java.util.LinkedList)

#_private
(defprotocol Buffer
    #_abstract
    (#_"Buffer" Buffer'''add [#_"Buffer" this, #_"Object" ___o])
    #_abstract
    (#_"Object" Buffer'''remove [#_"Buffer" this])
    #_abstract
    (#_"boolean" Buffer'''isEmpty [#_"Buffer" this])
)

#_private
(class-ns EmptyBuffer (§ implements Buffer)
    (defn #_"EmptyBuffer" EmptyBuffer'new []
        (hash-map)
    )

    #_method
    (§ defn #_"Buffer" add [#_"EmptyBuffer" this, #_"Object" ___o]
        (SingleBuffer'new ___o)
    )

    #_method
    (§ defn #_"Object" remove [#_"EmptyBuffer" this]
        (throw (IllegalStateException. "Removing object from empty buffer"))
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"EmptyBuffer" this]
        true
    )

    #_method
    (§ defn #_"String" toString [#_"EmptyBuffer" this]
        "EmptyBuffer"
    )
)

#_private
(class-ns SingleBuffer (§ implements Buffer)
    (defn- #_"SingleBuffer" SingleBuffer'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"SingleBuffer" SingleBuffer'new [#_"Object" ___o]
        (let [this (SingleBuffer'init)]
            (§ ass (:val this) ___o)
            this
        )
    )

    #_method
    (§ defn #_"Buffer" add [#_"SingleBuffer" this, #_"Object" ___o]
        (if (ß (:val this) == TransformerIterator'NONE)
            (do
                (§ ass (:val this) ___o)
                this
            )
            (do
                (ManyBuffer'new (:val this), ___o)
            )
        )
    )

    #_method
    (§ defn #_"Object" remove [#_"SingleBuffer" this]
        (when (ß (:val this) == TransformerIterator'NONE)
            (throw (IllegalStateException. "Removing object from empty buffer"))
        )
        (let [#_"Object" ___ret (:val this)]
            (§ ass (:val this) TransformerIterator'NONE)
            ___ret
        )
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"SingleBuffer" this]
        (ß ((:val this) == TransformerIterator'NONE))
    )

    #_method
    (§ defn #_"String" toString [#_"SingleBuffer" this]
        (ß "SingleBuffer: " + (:val this))
    )
)

#_private
(class-ns ManyBuffer (§ implements Buffer)
    (defn- #_"ManyBuffer" ManyBuffer'init []
        (hash-map
            #_"Queue" :vals (LinkedList.)
        )
    )

    (defn #_"ManyBuffer" ManyBuffer'new [#_"Object" ___o1, #_"Object" ___o2]
        (let [this (ManyBuffer'init)]
            (ß (:vals this).add(___o1))
            (ß (:vals this).add(___o2))
            this
        )
    )

    #_method
    (§ defn #_"Buffer" add [#_"ManyBuffer" this, #_"Object" ___o]
        (ß (:vals this).add(___o))
        this
    )

    #_method
    (§ defn #_"Object" remove [#_"ManyBuffer" this]
        (ß (:vals this).remove())
    )

    #_method
    (§ defn #_"boolean" isEmpty [#_"ManyBuffer" this]
        (ß (:vals this).isEmpty())
    )

    #_method
    (§ defn #_"String" toString [#_"ManyBuffer" this]
        (ß "ManyBuffer: " + (:vals this).toString())
    )
)

#_private
(class-ns MultiIterator (§ implements Iterator)
    (defn- #_"MultiIterator" MultiIterator'init []
        (hash-map
            #_"Iterator[]" :iters nil
        )
    )

    (defn #_"MultiIterator" MultiIterator'new [#_"Iterator[]" ___iters]
        (let [this (MultiIterator'init)]
            (§ ass (:iters this) ___iters)
            this
        )
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"MultiIterator" this]
        (doseq [#_"Iterator" ___iter (:iters this)]
            (when (ß !___iter.hasNext())
                (§ return false)
            )
        )
        true
    )

    #_method
    (§ defn #_"Object" next [#_"MultiIterator" this]
        (let [#_"Object[]" ___nexts (make-array Object (ß (:iters this).length))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < (:iters this).length) [(inc ___i)]
                (§ ass (ß ___nexts[___i]) (ß (:iters this)[___i].next()))
            )
            (ArraySeq'new-2 ___nexts, 0)
        )
    )

    #_method
    (§ defn #_"void" remove [#_"MultiIterator" this]
        (throw (UnsupportedOperationException.))
    )
)

(class-ns TransformerIterator (§ implements Iterator)
    (def- #_"Buffer" TransformerIterator'EMPTY (EmptyBuffer'new))
    (def- #_"Object" TransformerIterator'NONE (Object.))

    (defn- #_"TransformerIterator" TransformerIterator'init []
        (hash-map
            ;; Source
            #_"Iterator" :sourceIter nil
            #_"IFn" :xf nil
            #_"boolean" :multi false

            ;; Iteration state
            #_volatile
            #_"Buffer" :buffer TransformerIterator'EMPTY
            #_volatile
            #_"Object" :next TransformerIterator'NONE
            #_volatile
            #_"boolean" :completed false
        )
    )

    (defn- #_"TransformerIterator" TransformerIterator'new [#_"IFn" ___xform, #_"Iterator" ___sourceIter, #_"boolean" ___multi]
        (let [this (TransformerIterator'init)]
            (§ ass (:sourceIter this) ___sourceIter)
            (§ ass (:xf this) (ß (IFn) ___xform.invoke(
                    (§ reify AFn()
                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this]
                            nil
                        )

                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___acc]
                            ___acc
                        )

                        #_method
                        (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___acc, #_"Object" ___o]
                            (§ ass (:buffer this) (ß (:buffer this).add(___o)))
                            ___acc
                        )
                    )
                )
            ))
            (§ ass (:multi this) ___multi)
            this
        )
    )

    (defn #_"Iterator" TransformerIterator'create [#_"IFn" ___xform, #_"Iterator" ___source]
        (TransformerIterator'new ___xform, ___source, false)
    )

    (defn #_"Iterator" TransformerIterator'createMulti [#_"IFn" ___xform, #_"List" ___sources]
        (let [#_"Iterator[]" ___iters (make-array Iterator (ß ___sources.size()))]
            (loop-when-recur [#_"int" ___i 0] (ß ___i < ___sources.size()) [(inc ___i)]
                (§ ass (ß ___iters[___i]) (ß (Iterator)___sources.get(___i)))
            )
            (ß TransformerIterator'new(___xform, MultiIterator'new(___iters), true))
        )
    )

    #_method
    (§ defn- #_"boolean" step [#_"TransformerIterator" this]
        (when (ß (:next this) != TransformerIterator'NONE)
            (§ return true)
        )

        (while (ß (:next this) == TransformerIterator'NONE)
            (if (ß (:buffer this).isEmpty())
                (do
                    (cond (:completed this)
                        (do
                            (§ return false)
                        )
                        (ß (:sourceIter this).hasNext())
                        (do
                            (let [#_"Object" ___iter nil]
                                (if (:multi this)
                                    (do
                                        (§ ass ___iter (ß (:xf this).applyTo(RT'cons(nil, (:sourceIter this).next()))))
                                    )
                                    (do
                                        (§ ass ___iter (ß (:xf this).invoke(nil, (:sourceIter this).next())))
                                    )
                                )

                                (when (RT'isReduced ___iter)
                                    (ß (:xf this).invoke(nil))
                                    (§ ass (:completed this) true)
                                )
                            )
                        )
                        :else
                        (do
                            (ß (:xf this).invoke(nil))
                            (§ ass (:completed this) true)
                        )
                    )
                )
                (do
                    (§ ass (:next this) (ß (:buffer this).remove()))
                )
            )
        )
        true
    )

    #_method
    (§ defn #_"boolean" hasNext [#_"TransformerIterator" this]
        (ß step())
    )

    #_method
    (§ defn #_"Object" next [#_"TransformerIterator" this]
        (when (ß hasNext())
            (let [#_"Object" ___ret (:next this)]
                (§ ass (:next this) TransformerIterator'NONE)
                (§ return ___ret)
            )
        )
        (throw (NoSuchElementException.))
    )

    #_method
    (§ defn #_"void" remove [#_"TransformerIterator" this]
        (throw (UnsupportedOperationException.))
    )
)
)

(java-ns cloiure.lang.Tuple

(§ import java.util.Collection)
(§ import java.util.RandomAccess)

#_stateless
(class-ns Tuple
    (def #_"int" Tuple'MAX_SIZE 6)

    (defn #_"IPersistentVector" Tuple'create-0 []
        PersistentVector'EMPTY
    )

    (defn #_"IPersistentVector" Tuple'create-1 [#_"Object" ___v0]
        (RT'vector ___v0)
    )

    (defn #_"IPersistentVector" Tuple'create-2 [#_"Object" ___v0, #_"Object" ___v1]
        (RT'vector ___v0, ___v1)
    )

    (defn #_"IPersistentVector" Tuple'create-3 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2]
        (RT'vector ___v0, ___v1, ___v2)
    )

    (defn #_"IPersistentVector" Tuple'create-4 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3]
        (RT'vector ___v0, ___v1, ___v2, ___v3)
    )

    (defn #_"IPersistentVector" Tuple'create-5 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3, #_"Object" ___v4]
        (RT'vector ___v0, ___v1, ___v2, ___v3, ___v4)
    )

    (defn #_"IPersistentVector" Tuple'create-6 [#_"Object" ___v0, #_"Object" ___v1, #_"Object" ___v2, #_"Object" ___v3, #_"Object" ___v4, #_"Object" ___v5]
        (RT'vector ___v0, ___v1, ___v2, ___v3, ___v4, ___v5)
    )
)
)

(java-ns cloiure.lang.Util

(§ import java.io.IOException)
(§ import java.lang.ref.Reference)
(§ import java.math.BigInteger)
(§ import java.util.Collection)
(§ import java.util.Map)
(§ import java.util.concurrent.ConcurrentHashMap)
(§ import java.lang.ref.ReferenceQueue)

(defprotocol EquivPred
    #_abstract
    (#_"boolean" EquivPred'''equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2])
)

#_stateless
(class-ns Util
    (defn #_"boolean" Util'equiv-2oo [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return true)
        )
        (when (some? ___k1)
            (cond (ß ___k1 instanceof Number && ___k2 instanceof Number)
                (do
                    (§ return (ß Numbers'equal((Number)___k1, (Number)___k2)))
                )
                (ß ___k1 instanceof IPersistentCollection || ___k2 instanceof IPersistentCollection)
                (do
                    (§ return (ß pcequiv(___k1, ___k2)))
                )
            )
            (§ return (ß ___k1.equals(___k2)))
        )
        false
    )

    (def #_"EquivPred" Util'equivNull
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (ß (___k2 == nil))
            )
        )
    )

    (def #_"EquivPred" Util'equivEquals
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (ß ___k1.equals(___k2))
            )
        )
    )

    (def #_"EquivPred" Util'equivNumber
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (when (ß ___k2 instanceof Number)
                    (§ return (ß Numbers'equal((Number) ___k1, (Number) ___k2)))
                )
                false
            )
        )
    )

    (def #_"EquivPred" Util'equivColl
        (§ reify EquivPred()
            #_method
            (§ defn #_"boolean" equiv [#_"EquivPred" this, #_"Object" ___k1, #_"Object" ___k2]
                (when (ß ___k1 instanceof IPersistentCollection || ___k2 instanceof IPersistentCollection)
                    (§ return (ß pcequiv(___k1, ___k2)))
                )
                (ß ___k1.equals(___k2))
            )
        )
    )

    (defn #_"EquivPred" Util'equivPred [#_"Object" ___k1]
        (cond (nil? ___k1)
            (do
                (§ return Util'equivNull)
            )
            (ß ___k1 instanceof Number)
            (do
                (§ return Util'equivNumber)
            )
            (ß ___k1 instanceof String || ___k1 instanceof Symbol)
            (do
                (§ return Util'equivEquals)
            )
            (ß ___k1 instanceof Collection || ___k1 instanceof Map)
            (do
                (§ return Util'equivColl)
            )
        )
        Util'equivEquals
    )

    (defn #_"boolean" Util'equiv-2ll [#_"long" ___k1, #_"long" ___k2]
        (ß (___k1 == ___k2))
    )

    (defn #_"boolean" Util'equiv-2ol [#_"Object" ___k1, #_"long" ___k2]
        (ß equiv(___k1, (Object)___k2))
    )

    (defn #_"boolean" Util'equiv-2lo [#_"long" ___k1, #_"Object" ___k2]
        (ß equiv((Object)___k1, ___k2))
    )

    (defn #_"boolean" Util'equiv-2dd [#_"double" ___k1, #_"double" ___k2]
        (ß (___k1 == ___k2))
    )

    (defn #_"boolean" Util'equiv-2od [#_"Object" ___k1, #_"double" ___k2]
        (ß equiv(___k1, (Object)___k2))
    )

    (defn #_"boolean" Util'equiv-2do [#_"double" ___k1, #_"Object" ___k2]
        (ß equiv((Object)___k1, ___k2))
    )

    (defn #_"boolean" Util'equiv-2bb [#_"boolean" ___k1, #_"boolean" ___k2]
        (ß (___k1 == ___k2))
    )

    (defn #_"boolean" Util'equiv-2ob [#_"Object" ___k1, #_"boolean" ___k2]
        (ß equiv(___k1, (Object)___k2))
    )

    (defn #_"boolean" Util'equiv-2bo [#_"boolean" ___k1, #_"Object" ___k2]
        (ß equiv((Object)___k1, ___k2))
    )

    (defn #_"boolean" Util'equiv-2cc [#_"char" ___c1, #_"char" ___c2]
        (ß (___c1 == ___c2))
    )

    (defn #_"boolean" Util'pcequiv [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 instanceof IPersistentCollection)
            (§ return (ß ((IPersistentCollection)___k1).equiv(___k2)))
        )
        (ß ((IPersistentCollection)___k2).equiv(___k1))
    )

    (defn #_"boolean" Util'equals [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return true)
        )
        (ß (___k1 != nil && ___k1.equals(___k2)))
    )

    (defn #_"boolean" Util'identical [#_"Object" ___k1, #_"Object" ___k2]
        (ß (___k1 == ___k2))
    )

    (defn #_"Class" Util'classOf [#_"Object" ___x]
        (when (some? ___x)
            (§ return (ß ___x.getClass()))
        )
        nil
    )

    (defn #_"int" Util'compare [#_"Object" ___k1, #_"Object" ___k2]
        (when (ß ___k1 == ___k2)
            (§ return 0)
        )
        (when (some? ___k1)
            (when (nil? ___k2)
                (§ return 1)
            )
            (when (ß ___k1 instanceof Number)
                (§ return (ß Numbers'compare((Number) ___k1, (Number) ___k2)))
            )
            (§ return (ß ((Comparable) ___k1).compareTo(___k2)))
        )
        -1
    )

    (defn #_"int" Util'hash [#_"Object" ___o]
        (when (nil? ___o)
            (§ return 0)
        )
        (ß ___o.hashCode())
    )

    (defn #_"int" Util'hasheq [#_"Object" ___o]
        (when (nil? ___o)
            (§ return 0)
        )
        (when (ß ___o instanceof IHashEq)
            (§ return (ß dohasheq((IHashEq) ___o)))
        )
        (when (ß ___o instanceof Number)
            (§ return (ß Numbers'hasheq((Number)___o)))
        )
        (when (ß ___o instanceof String)
            (§ return (ß Murmur3'hashInt(___o.hashCode())))
        )
        (ß ___o.hashCode())
    )

    (defn- #_"int" Util'dohasheq [#_"IHashEq" ___o]
        (ß ___o.hasheq())
    )

    (defn #_"int" Util'hashCombine [#_"int" ___seed, #_"int" ___hash]
        ;; a la boost
        (§ ass ___seed (ß ___seed :xor (___hash + 0x9e3779b9 + (___seed << 6) + (___seed >> 2))))
        ___seed
    )

    (defn #_"boolean" Util'isPrimitive [#_"Class" ___c]
        (ß (___c != nil && ___c.isPrimitive() && !(___c == Void/TYPE)))
    )

    (defn #_"boolean" Util'isInteger [#_"Object" ___x]
        (ß (___x instanceof Integer || ___x instanceof Long || ___x instanceof BigInt || ___x instanceof BigInteger))
    )

    (defn #_"Object" Util'ret1 [#_"Object" ___ret, #_"Object" ___nil]
        ___ret
    )

    (defn #_"<K, V> void" Util'clearCache [#_"ReferenceQueue" ___rq, #_"ConcurrentHashMap<K, Reference<V>>" ___cache]
        ;; cleanup any dead entries
        (when (ß ___rq.poll() != nil)
            (while (ß ___rq.poll() != nil)
            )
            (doseq [#_"Map$Entry<K, Reference<V>>" ___e (ß ___cache.entrySet())]
                (let [#_"Reference<V>" ___val (ß ___e.getValue())]
                    (when (ß ___val != nil && ___val.get() == nil)
                        (ß ___cache.remove(___e.getKey(), ___val))
                    )
                )
            )
        )
        nil
    )

    (defn #_"RuntimeException" Util'runtimeException-1 [#_"String" ___s]
        (RuntimeException. ___s)
    )

    (defn #_"RuntimeException" Util'runtimeException-2 [#_"String" ___s, #_"Throwable" ___e]
        (RuntimeException. ___s, ___e)
    )

    ;;;
     ; Throw even checked exceptions without being required
     ; to declare them or catch them. Suggested idiom:
     ;
     ; <code>throw sneakyThrow(some exception);</code>
     ;;
    (defn #_"RuntimeException" Util'sneakyThrow [#_"Throwable" ___t]
        ;; http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html
        (when (nil? ___t)
            (throw (NullPointerException.))
        )
        (ß Util'<RuntimeException>sneakyThrow0(___t))
        nil
    )

    (defn- #_"<T extends Throwable> void" Util'sneakyThrow0 [#_"Throwable" ___t] #_(§ throws T)
        (throw (ß (T) ___t))
    )

    (defn #_"Object" Util'loadWithClass [#_"String" ___scriptbase, #_"Class<?>" ___loadFrom] #_(§ throws IOException, ClassNotFoundException)
        (ß Var'pushThreadBindings(RT'map(
            (§ map
                Compiler'LOADER (ß ___loadFrom.getClassLoader())
            )
        )))
        (try
            (ß RT'var-2("cloiure.core", "load").invoke(___scriptbase))
            (finally
                (ß Var'popThreadBindings())
            )
        )
    )
)
)

(java-ns cloiure.lang.Var

(§ import java.util.concurrent.atomic.AtomicBoolean)

(class-ns TBox
    (defn- #_"TBox" TBox'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
            #_"Thread" :thread nil
        )
    )

    (defn #_"TBox" TBox'new [#_"Thread" ___t, #_"Object" ___val]
        (let [this (TBox'init)]
            (§ ass (:thread this) ___t)
            (§ ass (:val this) ___val)
            this
        )
    )
)

(class-ns Unbound (§ extends AFn)
    (defn- #_"Unbound" Unbound'init []
        (hash-map
            #_"Var" :v nil
        )
    )

    (defn #_"Unbound" Unbound'new [#_"Var" ___v]
        (let [this (merge (AFn'new) (Unbound'init))]
            (§ ass (:v this) ___v)
            this
        )
    )

    #_method
    (§ defn #_"String" toString [#_"Unbound" this]
        (ß "Unbound: " + (:v this))
    )

    #_method
    (§ defn #_"Object" throwArity [#_"Unbound" this, #_"int" ___n]
        (throw (IllegalStateException. (str "Attempting to call unbound fn: " (:v this))))
    )
)

(class-ns Frame
    (§ def #_"Frame" Frame'TOP (Frame'new PersistentHashMap'EMPTY, nil))

    (defn- #_"Frame" Frame'init []
        (hash-map
            ;; Var->TBox
            #_"Associative" :bindings nil
            ;; Var->val
            #_"Frame" :prev nil
        )
    )

    (defn #_"Frame" Frame'new [#_"Associative" ___bindings, #_"Frame" ___prev]
        (let [this (Frame'init)]
            (§ ass (:bindings this) ___bindings)
            (§ ass (:prev this) ___prev)
            this
        )
    )

    #_protected
    #_method
    (§ defn #_"Object" clone [#_"Frame" this]
        (ß Frame'new((:bindings this), nil))
    )
)

(class-ns Var (§ extends ARef) (§ implements IFn, IRef, Settable)
    (def #_"ThreadLocal<Frame>" Var'dvals
        (§ reify ThreadLocal<Frame>()
            #_protected
            #_method
            (§ defn #_"Frame" initialValue [#_"ThreadLocal<Frame>" this]
                Frame'TOP
            )
        )
    )

    #_volatile
    (def #_"int" Var'rev 0)

    (§ def #_"Keyword" Var'privateKey (Keyword'intern-2 nil, "private"))
    (def #_"IPersistentMap" Var'privateMeta (ß PersistentArrayMap'new-1(new Object[] (§ array privateKey, Boolean/TRUE ))))
    (§ def #_"Keyword" Var'macroKey (Keyword'intern-2 nil, "macro"))
    (§ def #_"Keyword" Var'nameKey (Keyword'intern-2 nil, "name"))
    (§ def #_"Keyword" Var'nsKey (Keyword'intern-2 nil, "ns"))

    (defn #_"Object" Var'getThreadBindingFrame []
        (ß Var'dvals.get())
    )

    (defn #_"Object" Var'cloneThreadBindingFrame []
        (ß Var'dvals.get().clone())
    )

    (defn #_"void" Var'resetThreadBindingFrame [#_"Object" ___frame]
        (ß Var'dvals.set((Frame) ___frame))
        nil
    )

    (defn #_"Var" Var'intern-3 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root]
        (ß intern(___ns, ___sym, ___root, true))
    )

    (defn #_"Var" Var'intern-4 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root, #_"boolean" ___replaceRoot]
        (let [#_"Var" ___dvout (ß ___ns.intern(___sym))]
            (when (ß !___dvout.hasRoot() || ___replaceRoot)
                (ß ___dvout.bindRoot(___root))
            )
            ___dvout
        )
    )

    (defn #_"Var" Var'find [#_"Symbol" ___nsQualifiedSym]
        (when (ß (:ns ___nsQualifiedSym) == nil)
            (throw (IllegalArgumentException. "Symbol must be namespace-qualified"))
        )
        (let [#_"Namespace" ___ns (ß Namespace'find(Symbol'intern-1((:ns ___nsQualifiedSym))))]
            (when (nil? ___ns)
                (throw (IllegalArgumentException. (str "No such namespace: " (:ns ___nsQualifiedSym))))
            )
            (ß ___ns.findInternedVar(Symbol'intern-1((:name ___nsQualifiedSym))))
        )
    )

    (defn #_"Var" Var'intern-2s [#_"Symbol" ___nsName, #_"Symbol" ___sym]
        (let [#_"Namespace" ___ns (Namespace'findOrCreate ___nsName)]
            (ß intern(___ns, ___sym))
        )
    )

    (defn #_"Var" Var'internPrivate [#_"String" ___nsName, #_"String" ___sym]
        (let [#_"Namespace" ___ns (ß Namespace'findOrCreate(Symbol'intern-1(___nsName)))]
            (let [#_"Var" ___ret (ß intern(___ns, Symbol'intern-1(___sym)))]
                (ß ___ret.setMeta(privateMeta))
                ___ret
            )
        )
    )

    (defn #_"Var" Var'intern-2n [#_"Namespace" ___ns, #_"Symbol" ___sym]
        (ß ___ns.intern(___sym))
    )

    (defn #_"Var" Var'create-0 []
        (Var'new-2 nil, nil)
    )

    (defn #_"Var" Var'create-1 [#_"Object" ___root]
        (Var'new-3 nil, nil, ___root)
    )

    (defn- #_"Var" Var'init []
        (hash-map
            #_volatile
            #_"Object" :root nil

            #_volatile
            #_"boolean" :dynamic false
            #_transient
            #_"AtomicBoolean" :threadBound nil
            #_"Symbol" :sym nil
            #_"Namespace" :ns nil
        )
    )

    (defn #_"Var" Var'new-2 [#_"Namespace" ___ns, #_"Symbol" ___sym]
        (let [this (merge (ARef'new-0) (Var'init))]
            (§ ass (:ns this) ___ns)
            (§ ass (:sym this) ___sym)
            (§ ass (:threadBound this) (AtomicBoolean. false))
            (§ ass (:root this) (Unbound'new this))
            (ß setMeta(PersistentHashMap'EMPTY))
            this
        )
    )

    (defn #_"Var" Var'new-3 [#_"Namespace" ___ns, #_"Symbol" ___sym, #_"Object" ___root]
        (let [this (Var'new-2 ___ns, ___sym)]
            (§ ass (:root this) ___root)
            (§ ass rev (+ rev 1))
            this
        )
    )

    #_method
    (§ defn #_"Var" setDynamic [#_"Var" this]
        (§ ass (:dynamic this) true)
        this
    )

    #_method
    (§ defn #_"Var" setDynamic [#_"Var" this, #_"boolean" ___b]
        (§ ass (:dynamic this) ___b)
        this
    )

    #_method
    (§ defn #_"boolean" isDynamic [#_"Var" this]
        (:dynamic this)
    )

    #_method
    (§ defn #_"String" toString [#_"Var" this]
        (when (some? (:ns this))
            (§ return (ß "#'" + (:ns this).name + "/" + (:sym this)))
        )
        (ß "#<Var: " + (((:sym this) != nil) ? (:sym this).toString() :or "--unnamed--") + ">")
    )

    #_method
    (§ defn #_"boolean" isBound [#_"Var" this]
        (ß (hasRoot() || ((:threadBound this).get() && Var'dvals.get().bindings.containsKey(this))))
    )

    #_method
    (§ defn #_"Object" get [#_"Var" this]
        (when (ß !this.threadBound.get())
            (§ return (:root this))
        )
        (ß deref())
    )

    #_method
    (§ defn #_"Object" deref [#_"Var" this]
        (let [#_"TBox" ___b (ß getThreadBinding())]
            (when (some? ___b)
                (§ return (:val ___b))
            )
            (:root this)
        )
    )

    #_method
    (§ defn #_"void" setValidator [#_"Var" this, #_"IFn" ___vf]
        (when (ß hasRoot())
            (ß validate(___vf, (:root this)))
        )
        (§ ass (:validator this) ___vf)
        nil
    )

    #_method
    (§ defn #_"Object" alter [#_"Var" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (ß set(___fn.applyTo(RT'cons(deref(), ___args))))
        this
    )

    #_method
    (§ defn #_"Object" set [#_"Var" this, #_"Object" ___val]
        (ß validate(getValidator(), ___val))
        (let [#_"TBox" ___b (ß getThreadBinding())]
            (when (some? ___b)
                (when (ß Thread/currentThread() != (:thread ___b))
                    (throw (IllegalStateException. (String/format "Can't set!: %s from non-binding thread", (§ array (:sym this)))))
                )
                (§ ass (:val ___b) ___val)
                (§ return ___val)
            )
            (throw (IllegalStateException. (String/format "Can't change/establish root binding of: %s with set", (§ array (:sym this)))))
        )
    )

    #_method
    (§ defn #_"Object" doSet [#_"Var" this, #_"Object" ___val]
        (ß set(___val))
    )

    #_method
    (§ defn #_"Object" doReset [#_"Var" this, #_"Object" ___val]
        (ß bindRoot(___val))
        ___val
    )

    #_method
    (§ defn #_"void" setMeta [#_"Var" this, #_"IPersistentMap" ___m]
        ;; ensure these basis keys
        (ß resetMeta(___m.assoc(nameKey, (:sym this)).assoc(nsKey, (:ns this))))
        nil
    )

    #_method
    (§ defn #_"void" setMacro [#_"Var" this]
        (ß alterMeta(assoc, RT'list-2(macroKey, RT'T)))
        nil
    )

    #_method
    (§ defn #_"boolean" isMacro [#_"Var" this]
        (ß RT'booleanCast-1o(meta().valAt(macroKey)))
    )

    #_method
    (§ defn #_"boolean" isPublic [#_"Var" this]
        (ß !RT'booleanCast-1o(meta().valAt(privateKey)))
    )

    #_method
    (§ defn #_"Object" getRawRoot [#_"Var" this]
        (:root this)
    )

    #_method
    (§ defn #_"Object" getTag [#_"Var" this]
        (ß meta().valAt(RT'TAG_KEY))
    )

    #_method
    (§ defn #_"void" setTag [#_"Var" this, #_"Symbol" ___tag]
        (ß alterMeta(assoc, RT'list-2(RT'TAG_KEY, ___tag)))
        nil
    )

    #_method
    (§ defn #_"boolean" hasRoot [#_"Var" this]
        (ß !((:root this) instanceof Unbound))
    )

    ;; binding root always clears macro flag
    #_method
    (§ defn #_"void" bindRoot [#_"Var" this, #_"Object" ___root]
        (§ sync this
            (ß validate(getValidator(), ___root))
            (let [#_"Object" ___oldroot (:root this)]
                (§ ass (:root this) ___root)
                (§ ass rev (+ rev 1))
                (ß alterMeta(Var'dissoc, RT'list-1(macroKey)))
                (ß notifyWatches(___oldroot, (:root this)))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" swapRoot [#_"Var" this, #_"Object" ___root]
        (§ sync this
            (ß validate(getValidator(), ___root))
            (let [#_"Object" ___oldroot (:root this)]
                (§ ass (:root this) ___root)
                (§ ass rev (+ rev 1))
                (ß notifyWatches(___oldroot, ___root))
            )
        )
        nil
    )

    #_method
    (§ defn #_"void" unbindRoot [#_"Var" this]
        (§ sync this
            (§ ass (:root this) (Unbound'new this))
            (§ ass rev (+ rev 1))
        )
        nil
    )

    #_method
    (§ defn #_"void" commuteRoot [#_"Var" this, #_"IFn" ___fn]
        (§ sync this
            (let [#_"Object" ___newRoot (ß ___fn.invoke((:root this)))]
                (ß validate(getValidator(), ___newRoot))
                (let [#_"Object" ___oldroot (:root this)]
                    (§ ass (:root this) ___newRoot)
                    (§ ass rev (+ rev 1))
                    (ß notifyWatches(___oldroot, ___newRoot))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"Object" alterRoot [#_"Var" this, #_"IFn" ___fn, #_"ISeq" ___args]
        (§ sync this
            (let [#_"Object" ___newRoot (ß ___fn.applyTo(RT'cons((:root this), ___args)))]
                (ß validate(getValidator(), ___newRoot))
                (let [#_"Object" ___oldroot (:root this)]
                    (§ ass (:root this) ___newRoot)
                    (§ ass rev (+ rev 1))
                    (ß notifyWatches(___oldroot, ___newRoot))
                    ___newRoot
                )
            )
        )
    )

    (defn #_"void" Var'pushThreadBindings [#_"Associative" ___bindings]
        (let [#_"Frame" ___f (ß Var'dvals.get())]
            (let [#_"Associative" ___bmap (:bindings ___f)]
                (loop-when-recur [#_"ISeq" ___bs (ß ___bindings.seq())] (some? ___bs) [(ß ___bs.next())]
                    (let [#_"IMapEntry" ___e (ß (IMapEntry) ___bs.first())]
                        (let [#_"Var" ___v (ß (Var) ___e.key())]
                            (when (ß !___v.dynamic)
                                (throw (IllegalStateException. (String/format "Can't dynamically bind non-dynamic var: %s/%s", (§ array (:ns ___v), (:sym ___v)))))
                            )
                            (ß ___v.validate(___v.getValidator(), ___e.val()))
                            (ß (:threadBound ___v).set(true))
                            (§ ass ___bmap (ß ___bmap.assoc(___v, TBox'new(Thread/currentThread(), ___e.val()))))
                        )
                    )
                )
                (ß Var'dvals.set(Frame'new(___bmap, ___f)))
                nil
            )
        )
    )

    (defn #_"void" Var'popThreadBindings []
        (let [#_"Frame" ___f (ß Var'dvals.get().prev)]
            (cond (nil? ___f)
                (do
                    (throw (IllegalStateException. "Pop without matching push"))
                )
                (ß ___f == Frame'TOP)
                (do
                    (ß Var'dvals.remove())
                )
                :else
                (do
                    (ß Var'dvals.set(___f))
                )
            )
            nil
        )
    )

    (defn #_"Associative" Var'getThreadBindings []
        (let [#_"Frame" ___f (ß Var'dvals.get())]
            (let [#_"IPersistentMap" ___ret PersistentHashMap'EMPTY]
                (loop-when-recur [#_"ISeq" ___bs (ß (:bindings ___f).seq())] (some? ___bs) [(ß ___bs.next())]
                    (let [#_"IMapEntry" ___e (ß (IMapEntry) ___bs.first())]
                        (let [#_"Var" ___v (ß (Var) ___e.key())]
                            (let [#_"TBox" ___b (ß (TBox) ___e.val())]
                                (§ ass ___ret (ß ___ret.assoc(___v, (:val ___b))))
                            )
                        )
                    )
                )
                ___ret
            )
        )
    )

    #_method
    (§ defn #_"TBox" getThreadBinding [#_"Var" this]
        (when (ß (:threadBound this).get())
            (let [#_"IMapEntry" ___e (ß Var'dvals.get().bindings.entryAt(this))]
                (when (some? ___e)
                    (§ return (ß (TBox) ___e.val()))
                )
            )
        )
        nil
    )

    #_method
    (§ defn #_"IFn" fn [#_"Var" this]
        (ß (IFn) deref())
    )

    #_method
    (§ defn #_"Object" call [#_"Var" this]
        (ß invoke())
    )

    #_method
    (§ defn #_"void" run [#_"Var" this]
        (ß invoke())
        nil
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this]
        (ß fn().invoke())
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil)),
                Util'ret1(___arg20, (§ ass ___arg20 nil))))
    )

    #_method
    (§ defn #_"Object" invoke [#_"Var" this, #_"Object" ___arg1, #_"Object" ___arg2, #_"Object" ___arg3, #_"Object" ___arg4, #_"Object" ___arg5, #_"Object" ___arg6, #_"Object" ___arg7, #_"Object" ___arg8, #_"Object" ___arg9, #_"Object" ___arg10, #_"Object" ___arg11, #_"Object" ___arg12, #_"Object" ___arg13, #_"Object" ___arg14, #_"Object" ___arg15, #_"Object" ___arg16, #_"Object" ___arg17, #_"Object" ___arg18, #_"Object" ___arg19, #_"Object" ___arg20, #_"Object..." ___args]
        (ß fn().invoke(Util'ret1(___arg1, (§ ass ___arg1 nil)),
                Util'ret1(___arg2, (§ ass ___arg2 nil)),
                Util'ret1(___arg3, (§ ass ___arg3 nil)),
                Util'ret1(___arg4, (§ ass ___arg4 nil)),
                Util'ret1(___arg5, (§ ass ___arg5 nil)),
                Util'ret1(___arg6, (§ ass ___arg6 nil)),
                Util'ret1(___arg7, (§ ass ___arg7 nil)),
                Util'ret1(___arg8, (§ ass ___arg8 nil)),
                Util'ret1(___arg9, (§ ass ___arg9 nil)),
                Util'ret1(___arg10, (§ ass ___arg10 nil)),
                Util'ret1(___arg11, (§ ass ___arg11 nil)),
                Util'ret1(___arg12, (§ ass ___arg12 nil)),
                Util'ret1(___arg13, (§ ass ___arg13 nil)),
                Util'ret1(___arg14, (§ ass ___arg14 nil)),
                Util'ret1(___arg15, (§ ass ___arg15 nil)),
                Util'ret1(___arg16, (§ ass ___arg16 nil)),
                Util'ret1(___arg17, (§ ass ___arg17 nil)),
                Util'ret1(___arg18, (§ ass ___arg18 nil)),
                Util'ret1(___arg19, (§ ass ___arg19 nil)),
                Util'ret1(___arg20, (§ ass ___arg20 nil)),
                (Object[])Util'ret1(___args, (§ ass ___args nil))))
    )

    #_method
    (§ defn #_"Object" applyTo [#_"Var" this, #_"ISeq" ___arglist]
        (ß fn().applyTo(___arglist))
    )

    (def #_"IFn" Var'assoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___m, #_"Object" ___k, #_"Object" ___v]
                (RT'assoc ___m, ___k, ___v)
            )
        )
    )

    (def #_"IFn" Var'dissoc
        (§ reify AFn()
            #_override
            #_method
            (§ defn #_"Object" invoke [#_"AFn" this, #_"Object" ___c, #_"Object" ___k]
                (RT'dissoc ___c, ___k)
            )
        )
    )
)
)

(java-ns cloiure.lang.Volatile

(class-ns Volatile (§ implements IDeref)
    (defn- #_"Volatile" Volatile'init []
        (hash-map
            #_volatile
            #_"Object" :val nil
        )
    )

    (defn #_"Volatile" Volatile'new [#_"Object" ___val]
        (let [this (Volatile'init)]
            (§ ass (:val this) ___val)
            this
        )
    )

    #_method
    (§ defn #_"Object" deref [#_"Volatile" this]
        (:val this)
    )

    #_method
    (§ defn #_"Object" reset [#_"Volatile" this, #_"Object" ___newval]
        (§ ass (:val this) ___newval)
    )
)
)

(java-ns cloiure.main

(§ import cloiure.lang.Symbol)
(§ import cloiure.lang.Var)
(§ import cloiure.lang.RT)

#_stateless
(class-ns main
    (§ def- #_"Symbol" main'CLOIURE_MAIN (Symbol'intern-1 "cloiure.main"))
    (§ def- #_"Var" main'REQUIRE (RT'var-2 "cloiure.core", "require"))
    (§ def- #_"Var" main'MAIN (RT'var-2 "cloiure.main", "main"))

    (defn #_"void" -main [#_"String[]" ___args]
        (ß main'REQUIRE.invoke(main'CLOIURE_MAIN))
        (ß main'MAIN.applyTo(RT'seq(___args)))
        nil
    )
)
)
